<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TonyCrane&#39;s Blog</title>
  
  <subtitle>鹤翔万里的博客</subtitle>
  <link href="https://tonycrane.github.io/atom.xml" rel="self"/>
  
  <link href="https://tonycrane.github.io/"/>
  <updated>2021-06-29T13:08:15.478Z</updated>
  <id>https://tonycrane.github.io/</id>
  
  <author>
    <name>Tony Wang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Learn Haskell</title>
    <link href="https://tonycrane.github.io/p/b3ca5c18.html"/>
    <id>https://tonycrane.github.io/p/b3ca5c18.html</id>
    <published>2021-06-21T10:07:58.000Z</published>
    <updated>2021-06-29T13:08:15.478Z</updated>
    
    <content type="html"><![CDATA[<p style="text-align: center;">学习一门新语言之Haskell</p><p>之前一直很好奇函数式编程，觉得Haskell挺有意思的，想学学<br>现在高考完放假了，可以有时间具体学一学了<br>这里没有Haskell的教程，只有一些我在学习这门语言的时候易忘的东西和想到的问题</p><span id="more"></span><h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h2><p><del>这部分足足看了一下午</del></p><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>Haskell语言中的lambda表达式是用<code>\</code>来表示的（因为看着像$\mathtt{\lambda}$？）<br>具体语法是</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\para1 para2 ... -&gt; return</span><br></pre></td></tr></table></figure><p>“-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。</p><h3 id="fold和scan"><a href="#fold和scan" class="headerlink" title="fold和scan"></a>fold和scan</h3><p>fold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表<br>传入的二元函数<code>f :: a -&gt; b -&gt; b</code>将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数）</p><h4 id="foldl"><a href="#foldl" class="headerlink" title="foldl"></a>foldl</h4><p>左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl</span> f a xs</span><br></pre></td></tr></table></figure><p>它的结果计算过程为</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; foldl f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f a x1</span><br><span class="line">[<span class="number">2.</span>] a = f a x2 = f (f a x1) x2</span><br><span class="line">[<span class="number">3.</span>] a = f a x3 = f (f (f a x1) x2) x3</span><br></pre></td></tr></table></figure><p>可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]<br>而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表</p><h4 id="foldr"><a href="#foldr" class="headerlink" title="foldr"></a>foldr</h4><p>右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldr</span> f a xs</span><br></pre></td></tr></table></figure><p>它的结果计算过程为</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; foldr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f x3 a</span><br><span class="line">[<span class="number">2.</span>] a = f x2 a = f x2 (f x3 a)</span><br><span class="line">[<span class="number">3.</span>] a = f x1 a = f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure><p>从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]<br>因此可以使用递归来写一个和foldr效果一样的函数:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">foldr&#x27;</span> _ x [] = x</span><br><span class="line"><span class="title">foldr&#x27;</span> f a (x:xs) = f x (foldr&#x27; f a xs)</span><br></pre></td></tr></table></figure><p>也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表</p><p>例如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; foldr (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="type">True</span>    <span class="comment">-- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了</span></span><br><span class="line"><span class="title">ghci</span>&gt; foldl (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="comment">-- 这里什么都不会发生，直到电脑内存被爆掉</span></span><br><span class="line"><span class="comment">-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表</span></span><br></pre></td></tr></table></figure><h4 id="scanl和scanr"><a href="#scanl和scanr" class="headerlink" title="scanl和scanr"></a>scanl和scanr</h4><p>scan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表<br>scanl则向右延伸这个列表，scanr则向左延伸这个列表<br>但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; scanr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] 最右侧元素(<span class="number">-1</span> <span class="keyword">in</span> python) : a</span><br><span class="line">[<span class="number">2.</span>] 右侧第二个元素(<span class="number">-2</span>) : f x3 a</span><br><span class="line">[<span class="number">3.</span>] 右侧第三个元素(<span class="number">-3</span>) : f x2 (f x3 a)</span><br><span class="line">[<span class="number">4.</span>] 右侧第四个元素(<span class="number">-4</span>) : f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure><p>可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素<br>因此可以用递归来写一个和scanr效果一样的函数：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">scanr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanr&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="comment">-- scanr&#x27; f a (x:xs) = f x (foldr f a xs) : scanr&#x27; f a xs</span></span><br><span class="line"><span class="title">scanr&#x27;</span> f a (x:xs) = f x q : qs</span><br><span class="line">                    <span class="keyword">where</span> qs@(q:_) = scanr&#x27; f a xs</span><br></pre></td></tr></table></figure><p>scanl也是同理：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">scanl&#x27;</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanl&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="title">scanl&#x27;</span> f a (x:xs) = a : scanl&#x27; f (f a x) xs</span><br></pre></td></tr></table></figure><p>也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanl (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">28</span>,<span class="number">36</span>,<span class="number">45</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanr (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[*** <span class="type">Exception</span>: stack overflow</span><br></pre></td></tr></table></figure><h4 id="使用foldr编写foldl"><a href="#使用foldr编写foldl" class="headerlink" title="使用foldr编写foldl"></a>使用foldr编写foldl</h4><p>pdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldl&#x27;</span> f z xs = foldr (\x g y -&gt; g (f y x)) id xs z</span><br></pre></td></tr></table></figure><p>它利用 foldr (\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。</p><p>先来看一下foldr的类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">foldr</span> :: <span class="type">Foldable</span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line"><span class="comment">-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br></pre></td></tr></table></figure><p>但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。</p><p>所以这里foldr的类型可以写成：</p><p style="text-align: center;">(a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b)</p><p>对应于用法 foldr (\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）<br>而xs对应于[a]；id对应于(b -&gt; b)<br>所以 (\x g y -&gt; g (f y x)) 要对应于：</p><p style="text-align: center;">(a -> (b -> b) -> (b -> b))</p><p>因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。</p><p>再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b<br>所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为：</p><p style="text-align: center;">b -> (b -> b)</p><p>现在根据foldr的定义：</p><p style="text-align: center;">foldr f a (x:xs) = f x (foldr f a xs)</p><p>带入计算一下：</p><blockquote><p>xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn]</p><p>定义中的f即为(\x g y -&gt; g (f y x))，a即为id</p></blockquote><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  foldr (\x g y -&gt; g (f y x)) id xs z</span><br><span class="line">= (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br></pre></td></tr></table></figure><p>写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br></pre></td></tr></table></figure><p>不难发现，原式 (foldr (…) id xs) z 等价于：</p><p style="text-align: center;">(foldr (...) id xs') (f z x1)</p><p>跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’<br>因此下一步：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;&#x27;) (f (f (f z x1) x2) x3)</span><br><span class="line">= ...</span><br></pre></td></tr></table></figure><p>可以发现，已经有了规律。那么最终停止时是什么样呢？</p><p>最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []<br>而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id</p><p>所以最后的结果：<br>(id的定义：id x = x)</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= ...</span><br><span class="line">= (foldr (...) id []) (f (.. (f z x1) ..) xn)</span><br><span class="line">= id (f (.. (f z x1) ..) xn)</span><br><span class="line">= f (.. (f z x1) ..) xn</span><br></pre></td></tr></table></figure><p>那么最后这个结果就很熟悉了，它就是 foldl f z xs。<br>所以我们推导出了这个用foldr表示foldl的写法是正确的。</p><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Haskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用<code>:m + ...</code>，比如加载Data.List模块：</p><p style="text-align: center;">Prelude> :m + Data.List</p><p>而在hs文件中引入模块，需要使用<code>import</code>语句，下面和python的对比可以便于理解：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="comment">-- from Data.List import *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">nub</span>, <span class="title">sort</span>)</span><br><span class="line"><span class="comment">-- from Data.List import nub, sort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List <span class="keyword">hiding</span> (<span class="title">nub</span>)</span><br><span class="line"><span class="comment">-- 从Data.List中引入所有，但不引入nub函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List</span><br><span class="line"><span class="comment">-- import Data.List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List <span class="keyword">as</span> Li</span><br><span class="line"><span class="comment">-- import Data.List as Li</span></span><br></pre></td></tr></table></figure><h3 id="编写Modules"><a href="#编写Modules" class="headerlink" title="编写Modules"></a>编写Modules</h3><p>模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫<code>ModuleA.hs</code>，那它的头部需要写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleA</span><br><span class="line">( <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">, <span class="title">functionC</span></span><br><span class="line">) <span class="keyword">where</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。</p><h2 id="Types-amp-Typeclasses"><a href="#Types-amp-Typeclasses" class="headerlink" title="Types &amp; Typeclasses"></a>Types &amp; Typeclasses</h2><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Haskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。<br>Type的首字母全为大写，常用的有：</p><ul><li><code>Int</code>：整型，有上下界范围，-2147483647～2147483648</li><li><code>Integer</code>：整数，无界，但是效率比Int低</li><li><code>Float</code>：单精度浮点型</li><li><code>Double</code>：双精度浮点型</li><li><code>Bool</code>：布尔值</li><li><code>Char</code>：字符</li><li><code>String</code>：字符串，等同于<code>[Char]</code></li><li><code>Ording</code>：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT</li></ul><p>列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加<code>[]</code>。</p><p>元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。</p><h3 id="Typeclasses"><a href="#Typeclasses" class="headerlink" title="Typeclasses"></a>Typeclasses</h3><p>类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个Typeclass<br>Typeclass的首字母也全为大写，常见的有：</p><ul><li><code>Eq</code>：可判断是否相等</li><li><code>Ord</code>：可比较大小</li><li><code>Show</code>：可展示成字符串</li><li><code>Read</code>：可从字符串转换成特定类型</li><li><code>Enum</code>：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀</li><li><code>Bounded</code>: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded</li><li><code>Integral</code>：是整数，包括Int和Integer</li><li><code>RealFloat</code>： 是实浮点数，包括Float和Double</li><li><code>RealFrac</code>：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中）</li><li><code>Floating</code>：是浮点数，包括Float、Double和Complex（在Data.Complex模块中）</li><li><code>Real</code>：是实数，包括Integral和RealFrac的成员</li><li><code>Fractional</code>：是分数，包括RealFrac和Floating的成员</li><li><code>Num</code>：是数字，包括上述所有数字相关的类型</li></ul><h3 id="Type-variables"><a href="#Type-variables" class="headerlink" title="Type variables"></a>Type variables</h3><p>如果查看一个函数的类型，比如<code>head</code>，那么将会返回以下类型：</p><p style="text-align: center;">head :: [a] -> a</p><p>其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。</p><p>在函数的类型表达式其实可以看作$\lambda$表达式，它适用于$\alpha$变换（$\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。</p><p>在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如<code>(==)</code>函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么<code>(==)</code>的类型就是：</p><p style="text-align: center;">(==) :: (Eq a) => a -> a -> Bool</p><p>其中<code>=&gt;</code>前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以<code>(==)</code>函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。</p><h3 id="定义新Type"><a href="#定义新Type" class="headerlink" title="定义新Type"></a>定义新Type</h3><p>定义一个新的Type需要使用<code>data</code>关键字，比如定义<code>Bool</code>需要使用：</p><p style="text-align: center;">data Bool = False | True</p><p>其中<code>=</code>左侧的部分定义了新类型的名称<code>Bool</code>，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。<br>并且名称和值构造器的首字母都需要大写。</p><p>另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span>   </span></span><br></pre></td></tr></table></figure><p>它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。<br>如果查看Circle的类型，将返回：</p><p style="text-align: center;">Circle :: Float -> Float -> Float -> Shape</p><p>如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上<code>deriving (Show)</code>:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure><p>类型的名称和值构造器名称也可以相同，比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure><h4 id="导出Type"><a href="#导出Type" class="headerlink" title="导出Type"></a>导出Type</h4><p>在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件<code>Shapes.hs</code>中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Shapes</span><br><span class="line">( <span class="type">Shape(..)</span></span><br><span class="line">, <span class="type">Point(..)</span></span><br><span class="line">, <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">) <span class="keyword">where</span></span><br></pre></td></tr></table></figure><p>其中的<code>Shape(..)</code>导出了Shape类型和它所有的值构造器，<code>..</code>代表了它的所有值构造器。因此，<code>Shape(..)</code>相当于<code>Shape (Circle, Rectangle)</code>。</p><p>如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将<code>Shape(..)</code>替换为<code>Shape</code>，这样就只导出了Shape类型，而不导出其值构造器。</p><h4 id="Record-Syntax"><a href="#Record-Syntax" class="headerlink" title="Record Syntax"></a>Record Syntax</h4><p>如果想要方便地取出类型实例中的参数，可以使用Record语法，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   , <span class="title">ycoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure><p>在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> point = <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; xcoord point</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; ycoord point</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure><p>同时也可以通过下面方法来创建这个point：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">point</span> = <span class="type">Point</span> &#123;ycoord=<span class="number">2.0</span>, xcoord=<span class="number">1.0</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="Type-parameters"><a href="#Type-parameters" class="headerlink" title="Type parameters"></a>Type parameters</h4><p>值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义：</p><p style="text-align: center;">data Maybe a = Nothing | Just a</p><p>它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。<br>他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Nothing</span> :: <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> <span class="number">1</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> &#x27;a&#x27; :: <span class="type">Maybe</span> <span class="type">Char</span></span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;abc&quot;</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]</span><br></pre></td></tr></table></figure><p>可以用这种方法改写Point：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> x y = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="title">x</span></span></span><br><span class="line"><span class="class">                       , <span class="title">ycoord</span> :: <span class="title">y</span></span></span><br><span class="line"><span class="class">                       &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure><p>但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。</p><p>而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> (<span class="type">Ord</span> <span class="title">k</span>) =&gt; <span class="type">Map</span> k v = ... </span></span><br><span class="line"><span class="title">toList</span> :: (<span class="type">Ord</span> k) =&gt; <span class="type">Map</span> k a -&gt; [(k, a)]</span><br></pre></td></tr></table></figure><h4 id="Derived-instances"><a href="#Derived-instances" class="headerlink" title="Derived instances"></a>Derived instances</h4><p>想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span>   </span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)  </span><br></pre></td></tr></table></figure><p>这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右）</p><h4 id="Type-synonyms"><a href="#Type-synonyms" class="headerlink" title="Type synonyms"></a>Type synonyms</h4><p>为了阅读方便，书写简便，可以使用<code>type</code>关键字为已有类型创建别名（sysnonyms）。比如String的定义：</p><p style="text-align: center;">type String = [Char]</p><p>在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。<br>同时，类型别名也可以接收类型参数</p><h4 id="Recursive-data-structures"><a href="#Recursive-data-structures" class="headerlink" title="Recursive data structures"></a>Recursive data structures</h4><p><del>教程写得跟天书似的，明天再看qwq</del></p><p style="text-align: center; font-size: x-large; font-weight: bolder"> 未完待续 </p>]]></content>
    
    
    <summary type="html">&lt;p style=&quot;text-align: center;&quot;&gt;学习一门新语言之Haskell&lt;/p&gt;

&lt;p&gt;之前一直很好奇函数式编程，觉得Haskell挺有意思的，想学学&lt;br&gt;现在高考完放假了，可以有时间具体学一学了&lt;br&gt;这里没有Haskell的教程，只有一些我在学习这门语言的时候易忘的东西和想到的问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="Haskell" scheme="https://tonycrane.github.io/tags/Haskell/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>修复manim中Text类的bug</title>
    <link href="https://tonycrane.github.io/p/b6815e8.html"/>
    <id>https://tonycrane.github.io/p/b6815e8.html</id>
    <published>2020-05-05T23:59:39.000Z</published>
    <updated>2021-06-21T14:47:07.558Z</updated>
    
    <content type="html"><![CDATA[<p>在使用manim时,对于Text类,会有一些bug,我尝试修复了它们</p><ol><li>在<code>shaders</code>分支下无法使用Text类</li><li>Text文字的stroke边框不完整,导致显示stroke会非常难看</li><li>含有空格的Text的空格不在文字内部,而在<code>ORIGIN</code>的位置,导致<code>Transform</code>时会有字符在原位置和<code>ORIGIN</code>之间 <del>反复横跳</del></li><li>Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小</li></ol><p>这些问题已经通过<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>修复到了manim的master分支中</p><span id="more"></span><h2 id="mathcal-Bug-1"><a href="#mathcal-Bug-1" class="headerlink" title="$\mathcal{Bug\ 1.}$"></a>$\mathcal{Bug\ 1.}$</h2><p>当在<code>shaders</code>分支下使用Text类时会出现如下报错:<br><img src="../images/text_bug1.png"><br>其中最后一行让我发现此时的p0和p1的大小不相等,不能相加(broadcast),而p0和p1是通过贝赛尔曲线的次数(在shaders下是3)来拆分<code>self.points</code>的<br>所以可能是<code>self.points</code>的长度不为3的倍数,导致了错误.在<code>print(len(self.points))</code>后发现确实是这样<br>然后我又用了 <del>玄学</del> 手段,删掉了SVGMobject的最后一个点,发现可以正常渲染</p><p>此时我又去看了cairo自动生成的svg代码,根据我之前学svg的一点经验,发现每个<code>&lt;path/&gt;</code>的路径结尾都为<code>Z M ... ... /&quot;&gt;</code><br>而<code>Z</code>是将路径闭合,但闭合后又多出了一个<code>M</code>控制符,这会导致manim在处理svg时额外生成一个点<br>而删掉每个路径字符串的最后一个<code>M</code>控制符,可以直接使用正则表达式匹配出来,然后替换掉<br><img src="../images/text_bug1_svg.png"></p><p>我第一个想到的正则表达式是<code>Z M .*? /&quot;&gt;</code>,但是如果在路径的中间出现<code>Z M</code>,则会将其后面有用的部分一起删除<br>而有用的部分一定含有控制符,所以将控制符排除,就可以仅仅匹配掉最后一个<code>M</code>,正则表达式:<code>Z M [^A-Za-z]*? /&quot;&gt;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_last_M</span>(<span class="params">self, file_name</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fpr:</span><br><span class="line">        content = fpr.read()</span><br><span class="line">    content = re.sub(<span class="string">r&#x27;Z M [^[A-Za-z]*? &quot;\/&gt;&#x27;</span>, <span class="string">&#x27;Z &quot;/&gt;&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fpw:</span><br><span class="line">        fpw.write(content)</span><br></pre></td></tr></table></figure><h2 id="mathcal-Bug-2"><a href="#mathcal-Bug-2" class="headerlink" title="$\mathcal{Bug\ 2.}$"></a>$\mathcal{Bug\ 2.}$</h2><p>Text文字的stroke边框不完整,导致stroke显示不全,也会对<code>DrawBorderThenFill</code>造成影响,也有B站的观众向我提了这个问题</p><blockquote><p>– 话说，感觉每个Chapter之间的文字是不是先画出轮廓再填充上色，画完轮廓的时候停顿了一下。但是停顿的时候轮廓没有画完，有些地方有点断续的感觉<br>– Text类的bug，stroke日常乱套</p></blockquote><p>为了解决这个问题,我只显示了stroke,并且用<code>debugTeX</code>标出了构成每个字符的<code>self.points</code>的位置,比如”manim”如下:<br><img src="../images/text_bug2_before.png"><br>通过观察和与<a href="https://github.com/xy-23">@XiaoYoung</a>交流之后,确定了cairo生成的svg并不能使路径自动闭合<br>而在一般查看svg的软件(Chrome)中,svg图像只显示内部(fill),而stroke被忽略(很细),所以正常使用没问题<br>但是在manim中有时需要使用stroke,这时cairo生成的svg出现了bug,路径没有完全闭合</p><p>我最开始的想法是直接通过<code>.add_line_to()</code>方法将svg收尾相连,但是这显然只解决了m和n<br>而a和i是由两条路径复合而成的,其中的每条路径都没有闭合,所以都需要手动闭合,所以我决定遍历<code>self.points</code><br>这时我使用了一个<code>last</code>变量来记录遍历到当前位置所在的路径上的起点,并且如果到了下一条路径(索引为nppc的倍数,并且不与前一个点相重合),就将首尾连接上,并更新<code>last</code></p><p>而这样做还需要一个特判,当points为空时(空格)直接跳过,否则<code>points[0]</code>会报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nppc = self.n_points_per_cubic_curve</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> self:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(each.points) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    points = each.points</span><br><span class="line">    last = points[<span class="number">0</span>]</span><br><span class="line">    each.clear_points()</span><br><span class="line">    <span class="keyword">for</span> index, point <span class="keyword">in</span> <span class="built_in">enumerate</span>(points):</span><br><span class="line">        each.append_points([point])</span><br><span class="line">        <span class="keyword">if</span> index != <span class="built_in">len</span>(points) - <span class="number">1</span> <span class="keyword">and</span> (index + <span class="number">1</span>) % nppc == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">any</span>(point != points[index+<span class="number">1</span>]):</span><br><span class="line">            each.add_line_to(last)</span><br><span class="line">            last = points[index + <span class="number">1</span>]</span><br><span class="line">    each.add_line_to(last)</span><br></pre></td></tr></table></figure><p>这样做之后,这个bug就完全解决了,而且中文也同时适用,对比如下,上为修复之前,下为修复之后(都为仅显示stroke)<br><img src="../images/text_bug2_after.png"><br><img src="../images/text_bug2_en.png"><br><img src="../images/text_bug2_cn.png"></p><h2 id="mathcal-Bug-3"><a href="#mathcal-Bug-3" class="headerlink" title="$\mathcal{Bug\ 3.}$"></a>$\mathcal{Bug\ 3.}$</h2><p>这个是非常常见的问题了,如下:<br><img src="../images/text_bug3_before.gif"><br>之前解决这个问题是通过’假空格’,即用一个不常用字符表示空格,并将其设为背景色,或者opacity改成0<br>通过debugTeX可以发现,Text的空格占字符而且位置在ORIGIN<br>而TextMobject中的空格直接不占位置.所以我直接在处理bug2的同时,将<code>len(each.points) == 0</code>的处理中加上了<code>self.remove(each)</code>,这样就暂时解决了<br><img src="../images/text_bug3.png"><br><img src="../images/text_bug3_after.gif"><br>而<a href="https://github.com/xy-23">@XiaoYoung</a>也提醒了我,这样的处理会干扰t2c的自动上色(下标改变了),在<a href="https://github.com/3b1b/manim/pull/1018">#1018</a>这里,他决定单开一个pr来修复这个bug,所以我就把这一个commit删除掉了</p><h2 id="mathcal-Bug-4"><a href="#mathcal-Bug-4" class="headerlink" title="$\mathcal{Bug\ 4.}$"></a>$\mathcal{Bug\ 4.}$</h2><p>Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小<br>通过阅读源码可以发现,TextMobject在<code>__init__()</code>的结尾,有一句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.height <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    self.scale(TEX_MOB_SCALE_FACTOR)</span><br></pre></td></tr></table></figure><p>而这个<code>TEX_MOB_SCALE_FACTOR</code>默认为<code>0.05</code>,即将默认的SVGMobject(高度为固定默认值)缩小为0.05倍<br>而Text类最后缩小了0.1倍,导致了大小不等,将其改为0.05后,就方便统一大小了<br><img src="../images/text_bug4.png"></p><h2 id="mathcal-Pull-Requests"><a href="#mathcal-Pull-Requests" class="headerlink" title="$\mathcal{Pull\ Requests}$"></a>$\mathcal{Pull\ Requests}$</h2><p>第一次提交pr,记录一下</p><ol><li>将原repo fork到自己的用户上</li><li>clone下来fork的repo</li><li>进行更改,add/commit/push,commit的注释要规范</li><li>在GitHub网页上,打开fork的repo,会有一个按钮<code>New Pull Request</code></li><li>比较,确认更改,然后<code>Create Pull Request</code>,表述出pr的必要性和验证,提交pr</li><li>等待repo管理员merge</li></ol><p>这次修复bug的pr在<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>和<a href="https://github.com/3b1b/manim/pull/1031">#1031</a><br>其中<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>被merge了,而<a href="https://github.com/3b1b/manim/pull/1031">#1031</a>还在等待</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用manim时,对于Text类,会有一些bug,我尝试修复了它们&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在&lt;code&gt;shaders&lt;/code&gt;分支下无法使用Text类&lt;/li&gt;
&lt;li&gt;Text文字的stroke边框不完整,导致显示stroke会非常难看&lt;/li&gt;
&lt;li&gt;含有空格的Text的空格不在文字内部,而在&lt;code&gt;ORIGIN&lt;/code&gt;的位置,导致&lt;code&gt;Transform&lt;/code&gt;时会有字符在原位置和&lt;code&gt;ORIGIN&lt;/code&gt;之间 &lt;del&gt;反复横跳&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些问题已经通过&lt;a href=&quot;https://github.com/3b1b/manim/pull/1030&quot;&gt;#1030&lt;/a&gt;修复到了manim的master分支中&lt;/p&gt;</summary>
    
    
    
    <category term="manim" scheme="https://tonycrane.github.io/categories/manim/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/categories/manim/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="github" scheme="https://tonycrane.github.io/tags/github/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="manim" scheme="https://tonycrane.github.io/tags/manim/"/>
    
    <category term="python" scheme="https://tonycrane.github.io/tags/python/"/>
    
    <category term="bug" scheme="https://tonycrane.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>树上莫队-笔记  /「SPOJ 10707」COT2-题解</title>
    <link href="https://tonycrane.github.io/p/24f5ddbc.html"/>
    <id>https://tonycrane.github.io/p/24f5ddbc.html</id>
    <published>2020-04-30T06:35:44.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/SP10707">SPOJ 10707 COT2-Count on a tree II</a>这道题目来学习一下 <strong>树上莫队</strong><br>当需要离线查询 <strong>树上</strong> 的多区间问题时,可以使用 <strong>树上莫队</strong> 来解决</p><p>主要通过 <strong>欧拉序</strong> 将树转化为一条链,然后在链上执行普通莫队的操作</p><span id="more"></span><h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><h3 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h3><p>正常进行<code>dfs</code>,在入和出时各加入序列中<br>比如样例的树如下:<br><img src="/p/24f5ddbc/graph.png"><br>其欧拉序为<code>1 2 2 3 5 5 6 6 7 7 3 4 8 8 4 1</code><br>可以很好地呈现出子树的关系,即两个相同的数$x$之间的部分为$x$子树中的节点<br>其有一个性质:<strong>区间内出现两次的点不在其路径上</strong><br>根据这个性质,可以将树转化为链来求解了</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>除了将树转化为欧拉序之外,还需要求出左右端点的$LCA$,以及一个点$\texttt{u}$在欧拉序中第一次出现的位置$\texttt{fst[u]}$,第二次(最后一次)出现的位置$\texttt{lst[u]}$</p><p>在进行莫队操作时,如果第一次经过这个点,则<code>add</code>其贡献,第二次经过这个点,则说明这个点不在所求链上,<code>del</code>其贡献<br>这个用一个<code>vis</code>数组,反复进行异或操作就可以解决</p><p>再考虑询问的区间的$l,r$应该赋值为$\texttt{fst}$还是$\texttt{lst}$<br>设左端点的深度小于右端点</p><ol><li>如果$LCA$和左端点相等,则说明$[l,r]$在一条链上,$l$和$r$均取$\texttt{fst}$即可</li><li>否则是两条链$[l, LCA],[LCA,r]$, 防止左右端点被统计两次导致贡献被删除,需要$l$取$\texttt{lst}$,$r$取$\texttt{fst}$</li></ol><p>最后考虑贡献</p><ol><li>若是上面第一种情况,在一条链上,直接统计欧拉序区间内所有点即可,重复两次的根据前文的性质会直接删掉</li><li>若是上面第二种情况,由于左右端点都在$LCA$这颗子树内,所以区间中并不会出现$LCA$,但是却一定会经过,所以额外将$LCA$加入贡献,并且记录下当前结果之后,再将其贡献减去,防止影响下一个查询</li></ol><p><strong>注意:</strong> 转化为欧拉序之后的序列长度为$2n$</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol><li><code>dfs</code>: $O(n)$</li><li>求$LCA$:$O(n\log n)$</li><li>莫队: $O(n\sqrt{n})$</li></ol><p>综上,树上莫队的复杂度 <del>差不多</del> 也是$O(n\sqrt{n})$</p><h2 id="针对-mathcal-SP10707-的具体实现"><a href="#针对-mathcal-SP10707-的具体实现" class="headerlink" title="针对$\mathcal{SP10707}$的具体实现"></a>针对$\mathcal{SP10707}$的具体实现</h2><p>没啥说的,模板题,做法全在上面了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, Ans, len, ocnt;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], fst[maxn], lst[maxn], vis[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">int</span> ord[maxn], val[maxn], dep[maxn], fa[maxn][<span class="number">25</span>], old[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, pos, lca;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">if</span> (a.pos &amp; <span class="number">1</span>) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    <span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> t): <span class="built_in">from</span>(f), <span class="built_in">to</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(f, t));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(t, f));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[t].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">    G[f].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    ord[++ocnt] = u; fst[u] = ocnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == f) <span class="keyword">continue</span>;</span><br><span class="line">        dep[e.to] = dep[u] + <span class="number">1</span>;</span><br><span class="line">        fa[e.to][<span class="number">0</span>] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j) &#123;</span><br><span class="line">            fa[e.to][j] = fa[fa[e.to][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(e.to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    ord[++ocnt] = u; lst[u] = ocnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[fa[y][i]] &gt;= dep[x]) y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i]) &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[val[x]]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[val[x]]) Ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[val[x]]++;</span><br><span class="line">    <span class="keyword">if</span> (cnt[val[x]] == <span class="number">1</span>) Ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="built_in">add</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">del</span>(x);</span><br><span class="line">    vis[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(<span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) old[i] = val[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n); <span class="keyword">int</span> len_ = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len_, val[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">add</span>(<span class="built_in">read</span>(), <span class="built_in">read</span>()); </span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> il = <span class="built_in">read</span>(), ir = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> LCA = <span class="built_in">lca</span>(il, ir);</span><br><span class="line">        <span class="keyword">if</span> (fst[il] &gt; fst[ir]) <span class="built_in">swap</span>(il, ir);</span><br><span class="line">        <span class="keyword">if</span> (il == LCA) &#123;</span><br><span class="line">            q[i].l = fst[il]; q[i].r = fst[ir];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].l = lst[il]; q[i].r = fst[ir]; q[i].lca = LCA;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].id = i; q[i].pos = (q[i].l - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">chg</span>(ord[l++]);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">chg</span>(ord[r--]);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">chg</span>(ord[--l]);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">chg</span>(ord[++r]);</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca) <span class="built_in">chg</span>(q[i].lca);</span><br><span class="line">        ans[q[i].id] = Ans;</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca) <span class="built_in">chg</span>(q[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过&lt;a href=&quot;https://www.luogu.com.cn/problem/SP10707&quot;&gt;SPOJ 10707 COT2-Count on a tree II&lt;/a&gt;这道题目来学习一下 &lt;strong&gt;树上莫队&lt;/strong&gt;&lt;br&gt;当需要离线查询 &lt;strong&gt;树上&lt;/strong&gt; 的多区间问题时,可以使用 &lt;strong&gt;树上莫队&lt;/strong&gt; 来解决&lt;/p&gt;
&lt;p&gt;主要通过 &lt;strong&gt;欧拉序&lt;/strong&gt; 将树转化为一条链,然后在链上执行普通莫队的操作&lt;/p&gt;</summary>
    
    
    
    <category term="C++算法" scheme="https://tonycrane.github.io/categories/C-%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="算法" scheme="https://tonycrane.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="莫队" scheme="https://tonycrane.github.io/tags/%E8%8E%AB%E9%98%9F/"/>
    
    <category term="SPOJ" scheme="https://tonycrane.github.io/tags/SPOJ/"/>
    
  </entry>
  
  <entry>
    <title>回滚莫队-笔记  /「AtCoder 1219」歴史の研究-题解</title>
    <link href="https://tonycrane.github.io/p/7d7b5548.html"/>
    <id>https://tonycrane.github.io/p/7d7b5548.html</id>
    <published>2020-04-30T02:58:35.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/AT1219">AtCoder 1219 歴史の研究</a>这道题目来学习一下 <strong>回滚莫队</strong><br><strong>回滚莫队</strong> 适用于容易进行<code>add</code>操作,而不容易实现<code>del</code>的情况</p><p>通过莫队的分块,指针移动的思想,可以让左指针进行回滚操作, <em>近似</em> 达到<code>del</code>的效果</p><span id="more"></span><h2 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>由于莫队对所有询问离线排序后,当左端点在同一个块内时,右端点递增<br>所以对于每个块,右指针直接向右依次执行<code>add</code>操作即可</p><p>对于左指针,在一个块内时,可以每次都从块的右边界向左进行<code>add</code>,由于不方便进行<code>del</code>操作,所以可以先记录下左指针在右边界时的<code>Ans</code>,然后每次向左移动到<code>q[i].l</code>时,将左指针再移回右边界,并且将<code>Ans</code>回滚到移动之前的值。由于分块,这样做的复杂度也不会很大</p><p>综上,对于每个块,<strong>右指针依次向右推进,左指针在右边界和查询的左端点之间反复横跳</strong><br>这样,执行的就只剩<code>add</code>操作,通过左指针的横跳,避免了<code>del</code>操作</p><p>注意,当左右端点都在同一个块时,只要暴力求出结果就可以了<br><strong>一定要注意</strong>: 不要使用奇偶排序,必须保证右端点的 <strong>单调递增</strong></p><p>对于每个块内的处理,大概如下图:<br><img src="/p/7d7b5548/RollBackMosAlgo.png" alt="橙色箭头:左指针的移动 蓝色箭头:右指针的移动"></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度由以下几个方面组成</p><ol><li>询问排序</li><li>同一个块内的暴力求解</li><li>左指针的移动(<del>横跳</del>)</li><li>右指针的顺次移动</li></ol><p>下面来 <del>不严谨</del> 简要地计算一下时间复杂度</p><ol><li><strong>排序</strong>:$O(n\log n)$</li><li><strong>暴力</strong>:暴力的区间最长为$\sqrt{n}$,所以单次暴力的复杂度为$O(\sqrt{n})$,$n$次暴力的复杂度为$O(n\sqrt{n})$<del>其实到不了n次</del></li><li><strong>左指针移动</strong>: 进行<code>add</code>操作的复杂度为$O(1)$,块长$\sqrt{n}$,每次左移最坏复杂度$O(\sqrt{n})$,回滚时仍需要$O(\sqrt{n})$清除贡献<br>所以对于所有块,一共要移动$q$次,总的复杂度为$O(2q\sqrt{n})$</li><li><strong>右指针移动</strong>: 对于每个块,最坏只要移动$n$次,一共$\sqrt{n}$个块,所以复杂度为$O(n\sqrt{n})$</li></ol><p>综上,总的复杂度为$O(n\log n)+O(2q\sqrt{n})+O(n\sqrt{n})\ \sim\ O(n\sqrt{n})$</p><h2 id="针对-mathcal-AT1219-的具体实现"><a href="#针对-mathcal-AT1219-的具体实现" class="headerlink" title="针对$\mathcal{AT1219}$的具体实现"></a>针对$\mathcal{AT1219}$的具体实现</h2><p>添加贡献的<code>add</code>操作很容易实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">    Ans = <span class="built_in">max</span>(Ans, <span class="number">1LL</span> * cnt[a[x]] * old[a[x]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一块内的暴力也很容易实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) cnt2[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        cnt2[a[i]]++;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1LL</span> * cnt2[a[i]] * old[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余情况下根据前面所说,可以实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);  <span class="comment">// 右指针右移,添加贡献</span></span><br><span class="line">LL tmp = Ans;                 <span class="comment">// 记录左指针移动前的答案</span></span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);  <span class="comment">// 左指针左移,添加贡献</span></span><br><span class="line">ans[q[i].id] = Ans;</span><br><span class="line"><span class="keyword">while</span> (l &lt; rpos[k] + <span class="number">1</span>) cnt[a[l++]]--; <span class="comment">// 左指针移动回右边界,并途中删除对cnt的贡献</span></span><br><span class="line">Ans = tmp;                    <span class="comment">// 回滚到移动前的答案</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, len, l, r;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[maxn], rpos[maxn], old[maxn], cnt2[maxn];</span><br><span class="line">LL Ans, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, pos;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) cnt2[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        cnt2[a[i]]++;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1LL</span> * cnt2[a[i]] * old[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">    Ans = <span class="built_in">max</span>(Ans, <span class="number">1LL</span> * cnt[a[x]] * old[a[x]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(n); <span class="keyword">int</span> num = <span class="built_in">ceil</span>((<span class="keyword">double</span>)n / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) rpos[i] = len * i; rpos[num] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) old[i] = a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len_ = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len_, a[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(); q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i; q[i].pos = (q[i].l - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, i = <span class="number">1</span>; k &lt;= num; ++k) &#123;</span><br><span class="line">        l = rpos[k] + <span class="number">1</span>, r = rpos[k], Ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">        <span class="keyword">while</span> (q[i].pos == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].l / len == q[i].r / len) &#123;</span><br><span class="line">                ans[q[i].id] = <span class="built_in">solve</span>(q[i].l, q[i].r);</span><br><span class="line">                i++; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">            LL tmp = Ans;</span><br><span class="line">            <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">            ans[q[i].id] = Ans;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; rpos[k] + <span class="number">1</span>) cnt[a[l++]]--;</span><br><span class="line">            Ans = tmp; i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过&lt;a href=&quot;https://www.luogu.com.cn/problem/AT1219&quot;&gt;AtCoder 1219 歴史の研究&lt;/a&gt;这道题目来学习一下 &lt;strong&gt;回滚莫队&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;回滚莫队&lt;/strong&gt; 适用于容易进行&lt;code&gt;add&lt;/code&gt;操作,而不容易实现&lt;code&gt;del&lt;/code&gt;的情况&lt;/p&gt;
&lt;p&gt;通过莫队的分块,指针移动的思想,可以让左指针进行回滚操作, &lt;em&gt;近似&lt;/em&gt; 达到&lt;code&gt;del&lt;/code&gt;的效果&lt;/p&gt;</summary>
    
    
    
    <category term="C++算法" scheme="https://tonycrane.github.io/categories/C-%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="算法" scheme="https://tonycrane.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="莫队" scheme="https://tonycrane.github.io/tags/%E8%8E%AB%E9%98%9F/"/>
    
    <category term="AtCoder" scheme="https://tonycrane.github.io/tags/AtCoder/"/>
    
  </entry>
  
  <entry>
    <title>带修莫队-笔记  /「Luogu P1903」数颜色-题解</title>
    <link href="https://tonycrane.github.io/p/838c5e29.html"/>
    <id>https://tonycrane.github.io/p/838c5e29.html</id>
    <published>2020-04-29T01:00:14.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/P1903">Luogu P1903 数颜色/维护序列</a>这道题目来学习一下 <strong>带修莫队</strong><br>顾名思义,<strong>带修莫队</strong> 不仅要支持普通莫队的查询操作,还要支持数据中途的修改</p><p>比如这道题目,需要实现以下目标</p><ol><li>查询$[L,R]$区间内不同颜色画笔的种数</li><li>将$pos$处的画笔替换为$color$颜色</li></ol><p>达到这个目标,可以在普通莫队的基础上加一个时间维度,实现 <strong>带修莫队</strong></p><span id="more"></span> <h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>这里的每个查询的时间戳规定为 <strong>最近修改操作的时间戳</strong>,即最近一次修改是第几次修改<br>修改操作会增加总时间戳,查询操作不会增加时间戳</p><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>在普通莫队的左右两个指针的基础之上 <em>增加</em> 一个 <strong>时间戳指针</strong><br>当左右端点及时间戳移动到均和当前查询的一致,就可以记录下当前答案</p><p>所以需要在普通莫队的基础之上加上修改时间戳的修改操作,并加上以下两个判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (t &lt; q[i].t) <span class="built_in">chg</span>(++t);</span><br><span class="line"><span class="keyword">while</span> (t &gt; q[i].t) <span class="built_in">chg</span>(t--);</span><br></pre></td></tr></table></figure><p>当当前时间小于询问时间时,先将当前时间$+1$,再修改<br>当当前时间大于询问时间时,先修改,再将当前时间$-1$</p><p>与普通莫队还有一点不同:<br>所有询问的排序方法,先按照左端点分块升序,再按照右端点 <strong>分块升序</strong>,最后按照时间戳升序<br>这样复杂度才会达到最优,节省了一系列不必要的操作</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>当分块的大小为$n^{\frac{2}{3}}$时,复杂度最小为$O(n^{\frac{5}{3}})$<br>具体分析见上一篇文章:<a href="681257d9.html">浅析莫队算法的时间复杂度</a></p><h2 id="针对-mathcal-P1903-的具体实现"><a href="#针对-mathcal-P1903-的具体实现" class="headerlink" title="针对$\mathcal{P1903}$的具体实现"></a>针对$\mathcal{P1903}$的具体实现</h2><p>在每个询问<code>Query</code>的结构体内加一个时间戳$t$,并且按照上文实现排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block[a.l] != block[b.l]) <span class="keyword">return</span> block[a.l] &lt; block[b.l];</span><br><span class="line">    <span class="keyword">if</span> (block[a.r] != block[b.r]) <span class="keyword">return</span> block[a.r] &lt; block[b.r];</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再建一个结构体<code>Change</code>,表示每次修改操作的数据,需要$pos$和$color$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, color;</span><br><span class="line">&#125;c[maxn];</span><br></pre></td></tr></table></figure><p>正常的<code>add/del</code>操作不再赘述<br>现在来看一下修改时间对应数据的操作</p><ol><li>当当前时间的操作的位置$pos$在当前区间$[l,r]$时,对答案有影响,需要调整当前答案<br>先将$pos$位置上的贡献删去,再将当前修改操作的$color$添加进去</li><li>将$pos$位置上的数与$color$交换,这样可以保证之后可以再换回来</li></ol><p>实现如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[a[c[t].pos]] == <span class="number">0</span>) Ans--; <span class="comment">// 删除贡献</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[c[t].color]++  == <span class="number">0</span>) Ans++; <span class="comment">// 添加贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].color); <span class="comment">// 交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外这题修改数据后严重卡常,手动开了O3,Ofast,inline才过</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">140000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, t, len, cntq, cntr, Ans;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[<span class="number">1000010</span>], ans[maxn], block[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block[a.l] != block[b.l]) <span class="keyword">return</span> block[a.l] &lt; block[b.l];</span><br><span class="line">    <span class="keyword">if</span> (block[a.r] != block[b.r]) <span class="keyword">return</span> block[a.r] &lt; block[b.r];</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, color;</span><br><span class="line">&#125;c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == <span class="number">0</span>) Ans++;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == <span class="number">1</span>) Ans--;</span><br><span class="line">    cnt[a[x]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) &#123;</span><br><span class="line">        <span class="built_in">del</span>(c[t].pos);</span><br><span class="line">        <span class="keyword">if</span> (cnt[c[t].color] == <span class="number">0</span>) Ans++;</span><br><span class="line">        cnt[c[t].color]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        block[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt[<span class="number">10</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            q[++cntq].l = <span class="built_in">read</span>(); q[cntq].r = <span class="built_in">read</span>();</span><br><span class="line">            q[cntq].id = cntq; q[cntq].t = cntr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[++cntr].pos = <span class="built_in">read</span>();</span><br><span class="line">            c[cntr].color = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + cntq, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q[i].t) <span class="built_in">chg</span>(++t);</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q[i].t) <span class="built_in">chg</span>(t--);</span><br><span class="line">        ans[q[i].id] = Ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;通过&lt;a href=&quot;https://www.luogu.com.cn/problem/P1903&quot;&gt;Luogu P1903 数颜色/维护序列&lt;/a&gt;这道题目来学习一下 &lt;strong&gt;带修莫队&lt;/strong&gt;&lt;br&gt;顾名思义,&lt;strong&gt;带修莫队&lt;/strong&gt; 不仅要支持普通莫队的查询操作,还要支持数据中途的修改&lt;/p&gt;
&lt;p&gt;比如这道题目,需要实现以下目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询$[L,R]$区间内不同颜色画笔的种数&lt;/li&gt;
&lt;li&gt;将$pos$处的画笔替换为$color$颜色&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;达到这个目标,可以在普通莫队的基础上加一个时间维度,实现 &lt;strong&gt;带修莫队&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="C++算法" scheme="https://tonycrane.github.io/categories/C-%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="算法" scheme="https://tonycrane.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="莫队" scheme="https://tonycrane.github.io/tags/%E8%8E%AB%E9%98%9F/"/>
    
    <category term="Luogu" scheme="https://tonycrane.github.io/tags/Luogu/"/>
    
  </entry>
  
  <entry>
    <title>浅析莫队算法的时间复杂度</title>
    <link href="https://tonycrane.github.io/p/681257d9.html"/>
    <id>https://tonycrane.github.io/p/681257d9.html</id>
    <published>2020-04-28T23:29:52.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章来记录一下莫队算法时间复杂度的简单(<del>不严谨</del>)计算</p><p>首先分析一下莫队算法的时间复杂度有哪些方面构成</p><ol><li>对询问<code>Query</code>数组的排序</li><li>区间左指针的移动</li><li>区间右指针的移动<span id="more"></span> </li></ol><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>每个<code>add/del</code>操作的复杂度为$O(1)$</p><ol><li><p>排序使用<code>sort</code>可以在$O(n\log n)$内完成</p></li><li><p>由于左指针在排序中被分块,所以又分为块内移动和块间移动</p><ul><li><strong>块内</strong>: 设每块中含左端点$x_i$个,由于每块大小为$\sqrt{n}$,所以在块内移动的最坏复杂度为$O(x_i\sqrt{n})$。<br>因此对于所有块,将复杂度求和,即为$O(\displaystyle\sum_ix_i\sqrt{n})=O(n\sqrt{n})$</li><li><strong>块间</strong>: 左指针在每个块内移动之后,需要移动到下一个块内的左端点处,块间跳转最坏跨两个整块需要$O(2\sqrt{n})$。<br>总共需要跨$\sqrt{n}-1$个块,所以复杂度为$O((\sqrt{n}-1)\times 2\sqrt{n})\sim O(n)$</li></ul></li></ol><p>综上,左指针移动的复杂度为$O(n\sqrt{n})$<br>3. 当左指针在同一个块内时,右指针是有序的,因此当左指针在同一个块内时,右指针移动的最坏复杂度为$O(n)$即全部移动一遍。而每个块长度为$\sqrt{n}$,总长为$n$,所以一共$\sqrt{n}$个块,所以最坏复杂度为$O(n\sqrt{n})$</p><p>综上,普通莫队算法的时间复杂度为<br>$$<br>O(n\log n)+O(n\sqrt{n})+O(n\sqrt{n})\ \sim\ O(n\sqrt{n})<br>$$</p><h2 id="玄学的奇偶排序优化"><a href="#玄学的奇偶排序优化" class="headerlink" title="玄学的奇偶排序优化"></a><del>玄学</del>的奇偶排序优化</h2><p>见图:<br><img src="/p/681257d9/MosAlgoCompare.png" alt="左:无奇偶排序,右:有奇偶排序&lt;/br&gt;图中灰色虚线表示分块的边界;带端点的线段表示需要询问的区间;红色箭头表示两种方法右指针移动相同长度的部分;蓝色箭头表示不同的部分。可以看出,有奇偶排序的蓝色箭头变短,避免了无意义的大幅度跳动,节省了一些常数复杂度"></p><h2 id="分块大小不为-sqrt-n"><a href="#分块大小不为-sqrt-n" class="headerlink" title="分块大小不为$\sqrt{n}$"></a>分块大小不为$\sqrt{n}$</h2><p>还是和前面一样推复杂度,设块大小为$a&gt;1$</p><ol><li><strong>排序</strong>: 需要$O(n\log n)$</li><li><strong>左指针移动</strong>: <ul><li><strong>块内</strong>: $O(\displaystyle\sum_ix_ia)=O(na)$</li><li><strong>块间</strong>: $O((\dfrac{n}{a}-1)\times 2a)=O(n)$</li></ul></li><li><strong>右指针移动</strong>: $O(n\times \dfrac{n}{a})=O(\dfrac{n^2}{a})$</li></ol><p>综上,总的复杂度为$O(n\log n)+O(na)+O(n)+O(\dfrac{n^2}{a})=O(na+\dfrac{n^2}{a})$<br>根据均值不等式,若让上式复杂度最小,则需要$na=\dfrac{n^2}{a}$,即$a=\sqrt{n}$<br>所以当含有左右两个指针时,分块大小为$\sqrt{n}$时总复杂度最小,为$O(n\sqrt{n})$</p><h2 id="带修莫队-三指针"><a href="#带修莫队-三指针" class="headerlink" title="带修莫队(三指针)"></a>带修莫队(三指针)</h2><p>还是设分块的大小为$a&gt;1$,注意带修莫队排序优先级:先左端点所在块,再右端点所在块,后时间戳大小</p><ol><li><strong>排序</strong>: $O(n\log n)$</li><li><strong>左指针移动</strong>: 同上推导,复杂度为$O(na)$</li><li><strong>右指针移动</strong>: 相同右端点的块的复杂度同上$O(na)$,还有换左端点决定的块时的复杂度约为$O(\dfrac{n^2}{a})$</li><li><strong>时间戳移动</strong>: 由排序优先级可见,只有当右端点所在块相同时才会移动时间戳,而每次移动最坏需要移动$\sum t \sim n$<br>对于每个左端点相同的块,右端点块数为$\dfrac{n}{a}$,左端点有$\dfrac{n}{a}$个,所以一共需要$O(\dfrac{n}{a}\times\dfrac{n}{a}\times n)=O(\dfrac{n^3}{a^2})$</li></ol><p>综上,总的复杂度为$O(n\log n)+O(na)+O(na)+O(\dfrac{n^2}{a})+O(\dfrac{n^3}{a^2})\ \sim\  O(na+\dfrac{n^2}{a}+\dfrac{n^3}{a^2})$</p><p>由于$1&lt;a&lt;n$,所以$\dfrac{\dfrac{n^2}{a}}{\dfrac{n^3}{a^2}}=\dfrac{a}{n}&lt;1 \Rightarrow \dfrac{n^2}{a}&lt;\dfrac{n^3}{a^2}$,所以原式可化为$O(na+\dfrac{n^3}{a^2})$</p><p>根据均值不等式,当$na=\dfrac{n^3}{a^2}$时上式最小,即$a=\sqrt[3]{n^2}=n^{\frac{2}{3}}$<br>所以含有三个指针时,分块大小为$n^{\frac{2}{3}}$时总复杂度最小,为$O(n^{\frac{5}{3}})=O(n\sqrt[3]{n^2})$</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章来记录一下莫队算法时间复杂度的简单(&lt;del&gt;不严谨&lt;/del&gt;)计算&lt;/p&gt;
&lt;p&gt;首先分析一下莫队算法的时间复杂度有哪些方面构成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对询问&lt;code&gt;Query&lt;/code&gt;数组的排序&lt;/li&gt;
&lt;li&gt;区间左指针的移动&lt;/li&gt;
&lt;li&gt;区间右指针的移动&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="C++算法" scheme="https://tonycrane.github.io/categories/C-%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="算法" scheme="https://tonycrane.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="莫队" scheme="https://tonycrane.github.io/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」总结及图示</title>
    <link href="https://tonycrane.github.io/p/dccbc6bb.html"/>
    <id>https://tonycrane.github.io/p/dccbc6bb.html</id>
    <published>2020-04-28T03:13:02.000Z</published>
    <updated>2021-06-12T05:21:00.265Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">问题编号</th><th align="left">问题名称</th><th align="left">问题模型</th><th align="left">转化模型</th></tr></thead><tbody><tr><td align="center">1</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2756">飞行员配对方案问题</a></td><td align="left">二分图最大匹配</td><td align="left">网络最大流</td></tr><tr><td align="center">2</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2762">太空飞行计划问题</a></td><td align="left">最大权闭合图</td><td align="left">网络最小割</td></tr><tr><td align="center">3</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2764">最小路径覆盖问题</a></td><td align="left">有向无环图最小路径覆盖</td><td align="left">网络最大流</td></tr><tr><td align="center">4</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2765">魔术球问题</a></td><td align="left">有向无环图最小路径覆盖</td><td align="left">网络最大流</td></tr><tr><td align="center">5</td><td align="left"><a href="https://www.luogu.com.cn/problem/P3254">圆桌问题</a></td><td align="left">二分图多重匹配</td><td align="left">网络最大流</td></tr><tr><td align="center">6</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2766">最长不下降子序列问题</a></td><td align="left">最多不相交路径</td><td align="left">网络最大流</td></tr><tr><td align="center">7</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2763">试题库问题</a></td><td align="left">二分图多重匹配</td><td align="left">网络最大流</td></tr><tr><td align="center">8</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2775">机器人路径规划问题</a></td><td align="left">$IDA*$</td><td align="left">$IDA*$</td></tr><tr><td align="center">9</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2774">方格取数问题</a></td><td align="left">二分图点权最大独立集</td><td align="left">网络最小割</td></tr><tr><td align="center">10</td><td align="left"><a href="https://www.luogu.com.cn/problem/P1251">餐巾计划问题</a></td><td align="left">线性规划网络优化</td><td align="left">最小费用最大流</td></tr><tr><td align="center">11</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2770">航空路线问题</a></td><td align="left">最长不相交路径</td><td align="left">最小费用最大流</td></tr><tr><td align="center">12</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2761">软件补丁问题</a></td><td align="left">最小转移代价</td><td align="left">最短路径</td></tr><tr><td align="center">13</td><td align="left"><a href="https://www.luogu.com.cn/problem/P2754">星际转移问题</a></td><td align="left">网络判定</td><td align="left">网络最大流</td></tr><tr><td align="center">14</td><td align="left"><a href="https://www.luogu.com.cn/problem/P4011">孤岛营救问题</a></td><td align="left">分层图最短路径</td><td align="left">最短路径</td></tr><tr><td align="center">15</td><td align="left"><a href="https://www.luogu.com.cn/problem/P4009">汽车加油行驶问题</a></td><td align="left">分层图最短路径</td><td align="left">最短路径</td></tr><tr><td align="center">16</td><td align="left"><a href="https://www.luogu.com.cn/problem/P4013">数字梯形问题</a></td><td align="left">最大权不相交路径</td><td align="left">最小费用最大流</td></tr><tr><td align="center">17</td><td align="left"><a href="https://www.luogu.com.cn/problem/P4015">运输问题</a></td><td align="left">网络费用流量</td><td align="left">最小费用最大流</td></tr><tr><td align="center">18</td><td align="left"><a href="https://www.luogu.com.cn/problem/P4014">分配问题</a></td><td align="left">二分图最佳匹配</td><td align="left">最小费用最大流</td></tr><tr><td align="center">19</td><td align="left"><a href="https://www.luogu.com.cn/problem/P4016">负载平衡问题</a></td><td align="left">最小代价供求</td><td align="left">最小费用最大流</td></tr><tr><td align="center">20</td><td align="left"><a href="https://www.luogu.com.cn/problem/P4012">深海机器人问题</a></td><td align="left">线性规划网络优化</td><td align="left">最小费用最大流</td></tr><tr><td align="center">21</td><td align="left"><a href="https://www.luogu.com.cn/problem/P3358">最长k可重区间集问题</a></td><td align="left">最大权不相交路径</td><td align="left">最小费用最大流</td></tr><tr><td align="center">22</td><td align="left"><a href="https://www.luogu.com.cn/problem/P3357">最长k可重线段集问题</a></td><td align="left">最大权不相交路径</td><td align="left">最小费用最大流</td></tr><tr><td align="center">23</td><td align="left"><a href="https://www.luogu.com.cn/problem/P3356">火星探险问题</a></td><td align="left">线性规划网络优化</td><td align="left">最小费用最大流</td></tr><tr><td align="center">24</td><td align="left"><a href="https://www.luogu.com.cn/problem/P3355">骑士共存问题</a></td><td align="left">二分图最大独立集</td><td align="left">网络最小割</td></tr></tbody></table><span id="more"></span><h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><ul><li><strong>最大匹配</strong>: 匈牙利/最大流</li><li><strong>带权匹配</strong>: KM/费用流</li><li><strong>最小点覆盖</strong>: =最大匹配</li><li><strong>最小边覆盖</strong>: =总结点数-最大匹配</li><li><strong>最大独立集</strong>: =总结点数-最大匹配</li></ul><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul><li>建立超级源点,超级汇点</li><li>点存在限制,拆成出入点,将出入点之间的边看做点,限制流量</li><li>建图考虑左右二部</li><li>超级源点向源点的边可以限制总流量</li><li>无源汇有容量下界:<code>s-下界-&gt;v  u-下界-&gt;t  u-上界减下界-&gt;v</code>,当满流时存在可行流</li><li>最小割中赋流量为inf则一定不会割去</li><li>一些求最大问题,可以用sum-最小割</li><li>最大权闭合图: 建图,最小割,仍和s相连的为最大权闭合图,权值和为sum-最小割</li></ul><h3 id="24题"><a href="#24题" class="headerlink" title="24题"></a>24题</h3><ol><li>直接建二分图,最大流求最大匹配</li><li>最大权闭合图,建边,实验和仪器之间保证不切割容量为inf,跑最小割,找与s相连的实验和仪器</li><li>最大独立集,总结点数-最大流</li><li>贪心</li><li>二分图多重匹配,s-&gt;左点集和右点集-&gt;t之间的边容量不为1(即可以选多次)</li><li>动态规划+按照动态规划的dp数组的意义建边求最大流</li><li>二分图多重匹配,类型-题目数-&gt;汇点,保证可选多个,存在满流则存在答案沿满流输出</li><li>$IDA*$爆搜,但洛谷数据应该有问题</li><li>抽象出两个点集,求最大独立集</li><li>按照题目说明建图,跑费用流</li><li>按照题目说明建图,跑费用流</li><li>将错误状态进行压缩,然后跑最短路</li><li>根据时间逐层建图,直到跑出可行流</li><li>将拥有钥匙进行压缩,跑最短路</li><li>建出分层图,跑最短路或者费用流</li><li>对三个规则分别建图,跑费用流</li><li>纯费用流</li><li>二分图最佳匹配,使用费用流</li><li>费用流,注意环形</li><li>按照题目要求建图,跑费用流</li><li>离散化,将区间转化为边,费用流</li><li>转化问题,变成21题,注意端点处理和垂直于x轴的线段</li><li>按照题目要求建图,跑费用流,方案dfs</li><li>将图上所有格点转化为两个点集,建二分图,求最大独立集</li></ol><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><strong><del>更新中</del></strong><br><img src="/p/dccbc6bb/NF24P2762.png" alt="2"><br><img src="/p/dccbc6bb/NF24P2754.png" alt="13"><br><img src="/p/dccbc6bb/NF24P3358.png" alt="21"><br><img src="/p/dccbc6bb/NF24P3357.png" alt="22"></p>]]></content>
    
    
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;问题编号&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;问题名称&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;问题模型&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;转化模型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2756&quot;&gt;飞行员配对方案问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;二分图最大匹配&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;2&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2762&quot;&gt;太空飞行计划问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最大权闭合图&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最小割&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2764&quot;&gt;最小路径覆盖问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;有向无环图最小路径覆盖&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2765&quot;&gt;魔术球问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;有向无环图最小路径覆盖&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3254&quot;&gt;圆桌问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;二分图多重匹配&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;6&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2766&quot;&gt;最长不下降子序列问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最多不相交路径&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2763&quot;&gt;试题库问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;二分图多重匹配&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;8&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2775&quot;&gt;机器人路径规划问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;$IDA*$&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;$IDA*$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;9&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2774&quot;&gt;方格取数问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;二分图点权最大独立集&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最小割&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;10&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1251&quot;&gt;餐巾计划问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;线性规划网络优化&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;11&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2770&quot;&gt;航空路线问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最长不相交路径&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;12&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2761&quot;&gt;软件补丁问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小转移代价&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最短路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;13&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2754&quot;&gt;星际转移问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络判定&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;14&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4011&quot;&gt;孤岛营救问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;分层图最短路径&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最短路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;15&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4009&quot;&gt;汽车加油行驶问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;分层图最短路径&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最短路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;16&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4013&quot;&gt;数字梯形问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最大权不相交路径&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;17&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4015&quot;&gt;运输问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络费用流量&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;18&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4014&quot;&gt;分配问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;二分图最佳匹配&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;19&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4016&quot;&gt;负载平衡问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小代价供求&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;20&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P4012&quot;&gt;深海机器人问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;线性规划网络优化&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;21&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3358&quot;&gt;最长k可重区间集问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最大权不相交路径&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;22&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3357&quot;&gt;最长k可重线段集问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最大权不相交路径&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;23&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3356&quot;&gt;火星探险问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;线性规划网络优化&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最小费用最大流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;24&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3355&quot;&gt;骑士共存问题&lt;/a&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;二分图最大独立集&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;网络最小割&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu P1494」小Z的袜子-题解</title>
    <link href="https://tonycrane.github.io/p/49548215.html"/>
    <id>https://tonycrane.github.io/p/49548215.html</id>
    <published>2020-04-27T06:53:47.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P1494">「Luogu P1494」小Z的袜子</a><br>一道推公式，后使用莫队 <del>玄学</del> 优化的题目</p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n$个袜子,第$i$只袜子的颜色为$c_i$<br>有$m$个询问,用$L,R$表示<br>在区间$[L,R]$中随机取袜子,求取出两只袜子颜色相同的概率(最简分数)</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑区间$[L,R]$,其中颜色为$A$的袜子有$a$只,颜色为$B$的袜子有$b$只$…$</p><p>取出两只袜子的总情况数为<br>$$C_{R-L+1}^2=\frac{(R-L+1)(R-L)}{2}$$<br>取出两只袜子颜色都为$A$的情况数为<br>$$C_a^2=\frac{a(a - 1)}{2}$$<br>所以,取出两只袜子颜色相同的情况数为<br>$$\sum_{i}C_i^2=C_a^2+C_b^2+…=\frac{a(a-1)}{2}+\frac{b(b-1)}{2}+…$$<br>所以最终的概率为<br>$$<br>\begin{aligned}<br>P&amp;=\frac{\displaystyle\sum_{i}C_i^2}{C_{R-L+1}^2}\\\\<br>&amp;=\dfrac{\dfrac{a(a-1)}{2}+\dfrac{b(b-1)}{2}+…}{ \dfrac{(R-L+1)(R-L)}{2} }\\\\<br>&amp;=\dfrac{a^2+b^2+…-a-b-…}{(R-L+1)(R-L)}\\\\<br>&amp;=\dfrac{\displaystyle\sum_ii^2-\displaystyle\sum_ii}{(R-L+1)(R-L)}\\\\<br>&amp;=\dfrac{\displaystyle\sum_ii^2-(R-L+1)}{(R-L+1)(R-L)}<br>\end{aligned}<br>$$<br>所以要求的就是$\displaystyle\sum_ii^2$,可以用莫队来维护区间平方和得到</p><p>对于最终结果的表达式,令$a=$分子,$b=$分母,求出$ab$的最大公约数,并除去<br>最终答案即为$a/b$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, pos, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">if</span> (a.pos &amp; <span class="number">1</span>) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    <span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span> &#123;</span></span><br><span class="line">    LL a, b;</span><br><span class="line">&#125;ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, Ans, len;</span><br><span class="line">LL c[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Ans -= cnt[c[x]] * cnt[c[x]];</span><br><span class="line">    cnt[c[x]]--;</span><br><span class="line">    Ans += cnt[c[x]] * cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Ans -= cnt[c[x]] * cnt[c[x]];</span><br><span class="line">    cnt[c[x]]++;</span><br><span class="line">    Ans += cnt[c[x]] * cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(); q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i; q[i].pos = q[i].l / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ans[q[i].id].a = <span class="number">0</span>; ans[q[i].id].b = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL a = Ans - (r - l + <span class="number">1</span>);</span><br><span class="line">        LL b = <span class="number">1LL</span> * (r - l + <span class="number">1</span>) * (LL)(r - l);</span><br><span class="line">        LL g = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">        ans[q[i].id].a = a / g;</span><br><span class="line">        ans[q[i].id].b = b / g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, ans[i].a, ans[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P1494&quot;&gt;「Luogu P1494」小Z的袜子&lt;/a&gt;&lt;br&gt;一道推公式，后使用莫队 &lt;del&gt;玄学&lt;/del&gt; 优化的题目&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="莫队" scheme="https://tonycrane.github.io/tags/%E8%8E%AB%E9%98%9F/"/>
    
    <category term="数论" scheme="https://tonycrane.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」负载平衡问题-题解</title>
    <link href="https://tonycrane.github.io/p/b8624866.html"/>
    <id>https://tonycrane.github.io/p/b8624866.html</id>
    <published>2020-04-23T02:44:02.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4016">「Luogu P4016」负载平衡问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$个环形的仓库,每个仓库存储一定数量的货物<br>货物可以在相邻仓库之间搬运,最终达到每个仓货物数量一样的效果</p><p>求最少搬运次数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看题解说可以用数学方法推导,但是在24题里还是选择用费用流水过</p><p>先求出平均数,即目标<br>然后将每个仓库的货物数减去平均数,得出需要移动的数量</p><ol><li>如果大于$0$,则从 源点 向 该仓库 建一条 <strong>容量为差值,费用为$0$</strong> 的边(需要转移出,对答案无贡献)</li><li>如果小于$0$,则从 该仓库 向 汇点 建一条 <strong>容量为差值绝对值,费用为$0$</strong> 的边(吸收这些货物,对答案无贡献)</li><li>从 每个仓库 向 相邻两个仓库 建一条 <strong>容量为$inf$,费用为$1$</strong> 的边(转移货物的数量无要求,对答案贡献为$1$)</li></ol><p>注意建边3.需要考虑环形<br>求出最小费用最大流,最小费用即为结果</p><p>因为费用流大前提是满足最大流,而且此图中源点出发的与流入汇点的边的容量和相等,所以最大流情况下一定会全部流过,即达到仓库货物数量平衡</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小费用最大流模板省去了</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">110</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        num[i] = <span class="built_in">read</span>(); tot += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tot /= n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] - tot &gt; <span class="number">0</span>) <span class="built_in">add</span>(s, i, num[i] - tot, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (num[i] - tot &lt; <span class="number">0</span>) <span class="built_in">add</span>(i, t, tot - num[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, i - <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(i - <span class="number">1</span>, i, inf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, n, inf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(n, <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4016&quot;&gt;「Luogu P4016」负载平衡问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」运输问题-题解</title>
    <link href="https://tonycrane.github.io/p/152673e9.html"/>
    <id>https://tonycrane.github.io/p/152673e9.html</id>
    <published>2020-04-23T02:17:43.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4015">「Luogu P4015」运输问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$m$个仓库,$n$个商店,每个仓库有$a_i$个货物,每个商店需要$b_i$个货物<br>需要从仓库运输货物到商店中,且第$i$个仓库运输到第$j$个商店费用为$c_{i,j}$</p><p>求最小费用和最大费用</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>和<a href="http://tony031218.github.io/p/11b1dcbd.html">P4015 分配问题</a>一样<br>将所有仓库和所有商店各分为一个点集</p><ol><li>从 源点 向 每个仓库 建一条 <strong>容量为货物个数$a_i$,费用为$0$</strong> 的边(有$a_i$个货物需要运出,且对答案无贡献)</li><li>从 每个商店 向 汇点 建一条 <strong>容量为货物个数$b_i$,费用为$0$</strong> 的边(需要$b_i$个货物,且对答案无贡献)</li><li>从 每个仓库 向 每个商店 建一条 <strong>容量为$inf$,费用为对应费用</strong> 的边(每个仓库可以运出的最多货物不限制,且对答案工作为对应费用)</li></ol><p>求出最小费用最大流和最大费用最大流即可</p><p>由于费用流的大前提是流量最大,所以一定满足题目中要求的供需平衡即$\sum\limits_{i=1}^{m}a_i=\sum\limits_{j=1}^{n}b_j$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 费用流模板省略,在P4015题解那里有</span></span><br><span class="line"><span class="comment">// 代码里为了方便把mn调换了</span></span><br><span class="line"><span class="keyword">int</span> input1[<span class="number">110</span>], input2[<span class="number">110</span>], input3[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n + m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>(); input1[i] = c;</span><br><span class="line">        <span class="built_in">add</span>(s, i, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>(); input2[i] = c;</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="built_in">read</span>(); input3[i][j] = c;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, inf, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(s, i, input1[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(i + n, t, input2[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, inf, input3[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4015&quot;&gt;「Luogu P4015」运输问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」分配问题-题解</title>
    <link href="https://tonycrane.github.io/p/11b1dcbd.html"/>
    <id>https://tonycrane.github.io/p/11b1dcbd.html</id>
    <published>2020-04-23T01:50:17.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4014">「Luogu P4014」分配问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$件工作要分配给$n$个人做<br>给出每个人做每个工件的效益$c_{i,j}$</p><p>求最小效益和最大效益</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的最小/大费用最大流<br>将所有人和所有工作各分为一个点集</p><ol><li>从 源点 向 所有人 建一条 <strong>容量为$1$,费用为$0$</strong> 的边(只能选一次,且对答案无贡献)</li><li>从 所有工作 向 汇点 建一条 <strong>容量为$1$,费用为$0$</strong> 的边(只能做一次,且对答案无贡献)</li><li>从 每个人 向 所有工作 建一条 <strong>容量为$1$,费用为对应效益</strong> 的边(只能做一种工作,且对答案工作为对应效益)</li></ol><p>求出最小费用最大流和最大费用最大流</p><p>两个问之间要清空图并重建(因为求最大流过程中会修改flow)</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line"><span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line"><span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">0</span>) <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(s);</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">Edge&amp; e = edges[G[x][i]]; <span class="keyword">bool</span> judge;</span><br><span class="line">            <span class="keyword">if</span> (opt) judge = d[e.to] &lt; d[x] + e.cost;</span><br><span class="line">            <span class="keyword">else</span> judge = d[e.to] &gt; d[x] + e.cost;</span><br><span class="line"><span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; judge) &#123;</span><br><span class="line">d[e.to] = d[x] + e.cost;</span><br><span class="line">p[e.to] = G[x][i];</span><br><span class="line">a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line"><span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">vis[e.to] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!opt &amp;&amp; d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt &amp;&amp; d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flow += a[t];</span><br><span class="line">cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">edges[p[u]].flow += a[t];</span><br><span class="line">edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); s = <span class="number">0</span>; t = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="built_in">read</span>(); tmp[i][j] = c;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, <span class="number">1</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, <span class="number">1</span>, tmp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4014&quot;&gt;「Luogu P4014」分配问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」数字梯形问题-题解</title>
    <link href="https://tonycrane.github.io/p/86b4c1f9.html"/>
    <id>https://tonycrane.github.io/p/86b4c1f9.html</id>
    <published>2020-04-23T01:09:18.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4013">「Luogu P4013」数字梯形问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>梯形的第一行有$m$个数字<br>从梯形的顶部的$m$个数字开始,在每个数字处可以沿左下或右下方向移动,形成一条从梯形的顶至底的路径。</p><p>有三种规则:</p><ol><li>从梯形的顶至底的$m$条路径互不相交</li><li>从梯形的顶至底的$m$条路径仅在数字结点处相交</li><li>从梯形的顶至底的$m$条路径允许在数字结点相交或边相交</li></ol><p>求每种规则下经过数字的最大总和</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很明显是 <strong>最大费用最大流</strong></p><h4 id="规则1"><a href="#规则1" class="headerlink" title="规则1."></a>规则1.</h4><p>路径不相交,即没有公共点,也就是每个点只能经过一次<br>将每个点拆成入点和出点,就可以通过控制出入点之间的容量控制经过次数</p><ol><li>从 源点 向 第一行的$m$个点的入点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li><li>从 最后一行每个点的出点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li><li>从 每个点的入点 向 每个点的出点 接一条 <strong>容量为$1$,费用为该点数字</strong> 的边(对答案贡献为该点数字)</li><li>从 每个点的出点 向 左下右下两个点的入点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li></ol><h4 id="规则2"><a href="#规则2" class="headerlink" title="规则2."></a>规则2.</h4><p>每条路径仅在数字节点相交,也就是不能有重边<br>无需拆点控制每个点经过的次数,只需给每条向左下右下的边的容量设为$1$,即只能经过一次</p><ol><li>从 源点 向 第一行的$m$个点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li><li>从 最后一行每个点 接一条 <strong>容量为$inf$,费用为该点数字</strong> 的边(每个点可以使用多次)</li><li>从 每个点的 向 左下右下两个点 接一条 <strong>容量为$1$,费用为该点数字</strong> 的边</li></ol><h4 id="规则3"><a href="#规则3" class="headerlink" title="规则3."></a>规则3.</h4><p>边也可以重合,也就相当于没有规则,可以随意向左下右下走<br>只需将规则2.中建边3.的容量改成$inf$即可</p><p>对于每种情况,求出最大费用最大流,最大费用即为答案<br>注意求解规则2.3.之前要清空建的图</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大费用最大流模板部分省去了</span></span><br><span class="line"><span class="keyword">int</span> in[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="keyword">int</span> point[<span class="number">45</span>][<span class="number">45</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">read</span>(); n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            point[i][j] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 1</span></span><br><span class="line">    s = <span class="number">0</span>; t = cnt * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i] + cnt, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(point[i][j] + cnt, point[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(point[i][j] + cnt, point[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) </span><br><span class="line">            <span class="built_in">add</span>(point[i][j], point[i][j] + cnt, <span class="number">1</span>, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 2</span></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i], t, inf, in[n][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j], <span class="number">1</span>, in[i][j]);</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 3</span></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i], t, inf, in[n][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j], inf, in[i][j]);</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j + <span class="number">1</span>], inf, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4013&quot;&gt;「Luogu P4013」数字梯形问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」深海机器人问题-题解</title>
    <link href="https://tonycrane.github.io/p/cfb1d422.html"/>
    <id>https://tonycrane.github.io/p/cfb1d422.html</id>
    <published>2020-04-22T01:23:13.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4012">「Luogu P4012」深海机器人问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个$P\times Q$网格,机器人可以向北/东走,西南为$(0, 0)$,东北为$(Q, P)$<br>每个网格边上有生物标本,和价值<br>有$a$个起点,每个起点有不同的机器人个数<br>有$b$个终点,每个终点有不同的机器人个数作为目的地</p><p>求采集到生物标本的最高总价值</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最大费用最大流</p><ol><li>每两个节点之间建一条 <strong>容量为$1$,费用为标本价值</strong> 的边,和一条 <strong>容量为$inf$,费用为$0$</strong> 的边(标本只能采集一次)</li><li>从 源点 向 每个起点 建一条 <strong>容量为机器人个数,费用为$0$</strong> 的边</li><li>从 每个终点 向 汇点 建一条 <strong>容量为机器人个数,费用为$0$</strong> 的边</li></ol><p>跑出最大费用最大流,最大费用即为结果</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line"><span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line"><span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(s);</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">Edge&amp; e = edges[G[x][i]];</span><br><span class="line"><span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">d[e.to] = d[x] + e.cost;</span><br><span class="line">p[e.to] = G[x][i];</span><br><span class="line">a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line"><span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">vis[e.to] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flow += a[t];</span><br><span class="line">cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">edges[p[u]].flow += a[t];</span><br><span class="line">edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p_, q_;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * q_ + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a_ = <span class="built_in">read</span>(), b_ = <span class="built_in">read</span>();</span><br><span class="line">    p_ = <span class="built_in">read</span>() + <span class="number">1</span>; q_ = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">    s = <span class="number">0</span>, t = p_ * q_ + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p_; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; q_; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j + <span class="number">1</span>), <span class="number">1</span>, w);</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j + <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q_; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p_; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(j, i), <span class="built_in">point</span>(j + <span class="number">1</span>, i), <span class="number">1</span>, w);</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(j, i), <span class="built_in">point</span>(j + <span class="number">1</span>, i), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">read</span>(), x = <span class="built_in">read</span>() + <span class="number">1</span>, y = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(s, <span class="built_in">point</span>(x, y), k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>() + <span class="number">1</span>, y = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">point</span>(x, y), t, r, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4012&quot;&gt;「Luogu P4012」深海机器人问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="最大流" scheme="https://tonycrane.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」孤岛营救问题-题解</title>
    <link href="https://tonycrane.github.io/p/5c532c45.html"/>
    <id>https://tonycrane.github.io/p/5c532c45.html</id>
    <published>2020-04-22T00:45:49.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4011">「Luogu P4011」孤岛营救问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>起点为$(1,1)$,终点为$(n,m)$<br>有些格子上有若干个钥匙，两个格子之间可能有一堵墙或者一扇可以用对应钥匙打开的门<br>每次移动需要$1$个单位时间，其他动作不需要时间</p><p>求最少需要多少时间能从起点到达终点。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对拥有的钥匙状态进行压缩<br>从起点到终点跑bfs即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p, k;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn][maxn], key[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> keys, times;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k, <span class="keyword">int</span> t): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">keys</span>(k), <span class="built_in">times</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> skey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[<span class="number">1</span>][<span class="number">1</span>]; ++i) skey |= (<span class="number">1</span> &lt;&lt; (key[<span class="number">1</span>][<span class="number">1</span>][i] - <span class="number">1</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>, skey, <span class="number">0</span>)); vis[<span class="number">1</span>][<span class="number">1</span>][skey] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (u.x == n &amp;&amp; u.y == m) <span class="keyword">return</span> u.times;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> vx = u.x + go[k][<span class="number">0</span>], vy = u.y + go[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (vx &lt; <span class="number">1</span> || vx &gt; n || vy &lt; <span class="number">1</span> || vy &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> e = edge[u.x][u.y][vx][vy];</span><br><span class="line">            <span class="keyword">if</span> (e &lt; <span class="number">0</span> || (e &gt; <span class="number">0</span> &amp;&amp; !(<span class="number">1</span> &lt;&lt; (e - <span class="number">1</span>) &amp; u.keys))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> vkeys = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[vx][vy]; ++i) vkeys |= (<span class="number">1</span> &lt;&lt; (key[vx][vy][i] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> nxtkeys = u.keys | vkeys;</span><br><span class="line">            <span class="keyword">if</span> (vis[vx][vy][nxtkeys]) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">Node</span>(vx, vy, nxtkeys, u.times + <span class="number">1</span>));</span><br><span class="line">            vis[vx][vy][nxtkeys] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); p = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), x2 = <span class="built_in">read</span>(), y2 = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> g = <span class="built_in">read</span>();</span><br><span class="line">        edge[x1][y1][x2][y2] = ((g == <span class="number">0</span>) ? <span class="number">-1</span> : g);</span><br><span class="line">        edge[x2][y2][x1][y1] = edge[x1][y1][x2][y2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">        key[x1][y1][++cnt[x1][y1]] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4011&quot;&gt;「Luogu P4011」孤岛营救问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="最短路" scheme="https://tonycrane.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
    <category term="bfs" scheme="https://tonycrane.github.io/tags/bfs/"/>
    
    <category term="状态压缩" scheme="https://tonycrane.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」汽车加油行驶问题-题解</title>
    <link href="https://tonycrane.github.io/p/fab3e888.html"/>
    <id>https://tonycrane.github.io/p/fab3e888.html</id>
    <published>2020-04-21T07:05:51.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4009">「Luogu P4009」汽车加油行驶问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个$N\times N$的网格,表示有加油站的位置<br>汽车要从$(1, 1)$走到$(N, N)$,装满油可以行驶$K$条边,且只能沿边行驶<br>服从以下规则</p><ol><li>可以无费用向右或向下走,但耗1点油</li><li>向左走或者向上走时需要付费用$B$,并耗1点油</li><li>在加油站处,若油没满,则必须付费用$A$,加满油</li><li>可在没有加油站的位置开设加油站,费用$C$,并加满油,付费$A$</li><li>在起点处,油量为$K$</li></ol><p>求出最小费用</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>明显是最小费用最大流(其实分层图最短路也可以解决,因为每条边的容量都为1)<br>分层建图,每层表示油量,第$0$层表示满油($K$),第$1$层表示油量为$K-1$,第$2$层表示油量为$K-2$,$…$</p><ol><li>对于每层每个节点,如果不是加油站,则从 该点 向 下一层的右边和下边的节点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边(规则1.)</li><li>对于每层每个节点,如果不是加油站,则从 该点 向 下一层的左边和上边的节点 接一条 <strong>容量为$1$,费用为$B$</strong> 的边(规则2.)</li><li>对于每个节点,如果是加油站,则从 第$0$层的该点 按照上两条建边</li><li>对于每个节点,如果是加油站,则从 除$0$层外的每层节点 向 第$0$层的该点 接一条 <strong>容量为$1$,费用为$A$</strong> 的边(规则3.)</li><li>对于每个节点,如果不是加油站,则从 第$K$层的该点 向 第$0$层的该点 接一条 <strong>容量为$1$,费用为$A+C$</strong> 的边(规则4.)</li><li>从 源点 向 第$0$层的$(1, 1)$节点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li><li>从 每层的$(N, N)$节点 向 汇点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边(到终点不考虑油量)</li></ol><p>求出最小费用最大流即可</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line"><span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line"><span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(s);</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">Edge&amp; e = edges[G[x][i]];</span><br><span class="line"><span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">d[e.to] = d[x] + e.cost;</span><br><span class="line">p[e.to] = G[x][i];</span><br><span class="line">a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line"><span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">vis[e.to] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flow += a[t];</span><br><span class="line">cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">edges[p[u]].flow += a[t];</span><br><span class="line">edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, A, B, C;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * N + y + dep * N * N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = <span class="built_in">read</span>(); K = <span class="built_in">read</span>(); A = <span class="built_in">read</span>(); B = <span class="built_in">read</span>(); C = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; n = (K + <span class="number">1</span>) * N * N; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (in[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j, <span class="number">0</span>), <span class="number">1</span>, A);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; K; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in[i][j] &amp;&amp; k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i + <span class="number">1</span>, j, k + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j + <span class="number">1</span>, k + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i - <span class="number">1</span>, j, k + <span class="number">1</span>), <span class="number">1</span>, B);</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j - <span class="number">1</span>, k + <span class="number">1</span>), <span class="number">1</span>, B);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in[i][j]) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, K), <span class="built_in">point</span>(i, j, <span class="number">0</span>), <span class="number">1</span>, A + C);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="built_in">point</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">point</span>(N, N, k), t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P4009&quot;&gt;「Luogu P4009」汽车加油行驶问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」最长k可重线段集问题-题解</title>
    <link href="https://tonycrane.github.io/p/f48af49a.html"/>
    <id>https://tonycrane.github.io/p/f48af49a.html</id>
    <published>2020-04-21T02:35:30.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3357">「Luogu P3357」最长k可重线段集问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个开线段的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开线段,组成集合$\mathbf{S}$<br>使对于任何一条直线$x=p$,满足$\mathbf{S}$中与$x=p$相交的线段数不超过$k$,且$\mathbf{S}$中开线段总长度最大</p><p>求最大的长度</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>和<a href="https://www.luogu.com.cn/problem/P3358">「Luogu P3358」最长k可重区间集问题</a>类似<br>仅修改一下区间的输入部分即可</p><p>将每条线段映射到x轴上,发现可能不对,因为可能会存在垂直于x轴的线段,像P3358一样建图会省略掉这条线段</p><p>所以要将每个点扩大一倍,将左右端点x坐标相同的区间$(x, x)$更改为$(2x, 2x+1)$,使得不存在与x轴垂直的线段<br>如果左右端点x坐标不相同,则将$(x_1, x_2)$更改为$(2x_1+1, 2x_2)$</p><p>大概就是这么个道理:<br><img src="/p/f48af49a/NF24P3357.png"></p><p>剩下的做法和<a href="https://www.luogu.com.cn/problem/P3358">P3358</a>一样,<a href="https://tony031218.github.io/2020/04/21/%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E6%9C%80%E9%95%BFk%E5%8F%AF%E9%87%8D%E5%8C%BA%E9%97%B4%E9%9B%86%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/">P3358题解</a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line"><span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line"><span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(s);</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">Edge&amp; e = edges[G[x][i]];</span><br><span class="line"><span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">d[e.to] = d[x] + e.cost;</span><br><span class="line">p[e.to] = G[x][i];</span><br><span class="line">a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line"><span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">vis[e.to] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flow += a[t];</span><br><span class="line">cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">edges[p[u]].flow += a[t];</span><br><span class="line">edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;inter[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1020</span>], old[<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">long</span> <span class="keyword">long</span>)(a - c) * (a - c) + (<span class="keyword">long</span> <span class="keyword">long</span>)(b - d) * (b - d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_ = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">        inter[i].len = <span class="built_in">length</span>(a, b, c, d);</span><br><span class="line">        inter[i].l = a * <span class="number">2</span>;</span><br><span class="line">        inter[i].r = c * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == c) inter[i].r += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> inter[i].l += <span class="number">1</span>;</span><br><span class="line">        nums[i * <span class="number">2</span> - <span class="number">1</span>] = inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span>] = inter[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) old[i] = nums[i];</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) nums[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len, nums[i]) - old;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = nums[i * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        inter[i].r = nums[i * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; n = len + <span class="number">2</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(inter[i].l, inter[i].r, <span class="number">1</span>, inter[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P3357&quot;&gt;「Luogu P3357」最长k可重线段集问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」最长k可重区间集问题-题解</title>
    <link href="https://tonycrane.github.io/p/949e7ebf.html"/>
    <id>https://tonycrane.github.io/p/949e7ebf.html</id>
    <published>2020-04-21T00:33:31.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3358">「Luogu P3358」最长k可重区间集问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个开区间的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开区间,组成集合$\mathbf{S}$<br>使对于任何一个$x$,满足$\mathbf{S}$中包含$x$的区间数不超过$k$,且$\mathbf{S}$中开区间总长度最大</p><p>求最大的长度</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果两个区间没有重叠的话,则可以同时选择,在图上表现为串联<br>如果两个区间有重叠的话,则不能同时选择,在图上表现为并联(服从总流量的约束)<br>先对所有节点进行离散化,注意离散化前统计出区间的长</p><ol><li>从 源点 向 节点1 接一条 <strong>容量为$k$,费用为$0$</strong> 的边(最大容量为k,对答案无贡献)</li><li>从 每个节点$i$ 向 节点$i+1$ 接一条 <strong>容量为$inf$,费用为$0$</strong> 的边(可以随意通过,对答案无贡献)</li><li>从 最后一个节点 向 汇点 接一条 <strong>容量为$inf$,费用为$0$</strong> 的边(总流量有1.控制,对答案无贡献)(可以包含在2.里)</li><li>从 每个区间的左端点 向 其右端点 接一条 <strong>容量为$1$,费用为区间长</strong> 的边(只可用一次,对答案贡献为区间长度)</li></ol><p>求出最大费用最大流,最大费用即为最终的结果<br>样例的图如下:<br><img src="/p/949e7ebf/NF24P3358.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line"><span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line"><span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(s);</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">Edge&amp; e = edges[G[x][i]];</span><br><span class="line"><span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">d[e.to] = d[x] + e.cost;</span><br><span class="line">p[e.to] = G[x][i];</span><br><span class="line">a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line"><span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">vis[e.to] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flow += a[t];</span><br><span class="line">cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">edges[p[u]].flow += a[t];</span><br><span class="line">edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;inter[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1020</span>], old[<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_ = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = <span class="built_in">read</span>(); inter[i].r = <span class="built_in">read</span>();</span><br><span class="line">        inter[i].len = inter[i].r - inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span> - <span class="number">1</span>] = inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span>] = inter[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) old[i] = nums[i];</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) nums[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len, nums[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = nums[i * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        inter[i].r = nums[i * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; n = len + <span class="number">2</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(inter[i].l, inter[i].r, <span class="number">1</span>, inter[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P3358&quot;&gt;「Luogu P3358」最长k可重区间集问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」火星探险问题-题解</title>
    <link href="https://tonycrane.github.io/p/e7256d1.html"/>
    <id>https://tonycrane.github.io/p/e7256d1.html</id>
    <published>2020-04-20T07:42:19.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3356">「Luogu P3356」火星探险问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$辆车,$p\times q$的网格<br>为0可以通过,1有障碍不能通过,2为岩石可以采集<br>从(1, 1)开始到最右下角,只能向右或向下</p><p>求出使到达终点的车最多,而且采集的岩石最多的移动方案</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每个位置拆成入点和出点</p><ol><li>如果这个位置是$0$或$2$, 则从 入点 向 出点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li><li>如果这个位置是$2$, 则从 入点 向 出点 接一条 <strong>容量为$1$, 费用为$1$</strong> 的边</li><li>如果这个位置$u$的右边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li><li>如果这个位置$u$的下边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li></ol><p>跑最大费用最大流,最大流数即到达终点最多的车数<br>输出方案使用dfs,在流量网络中搜索输出路径</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], pre[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line"><span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line"><span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; pre[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">Q.<span class="built_in">push</span>(s);</span><br><span class="line"><span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">Edge&amp; e = edges[G[x][i]];</span><br><span class="line"><span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">d[e.to] = d[x] + e.cost;</span><br><span class="line">pre[e.to] = G[x][i];</span><br><span class="line">a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line"><span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">vis[e.to] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">flow += a[t];</span><br><span class="line">cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[pre[u]].from) &#123;</span><br><span class="line">edges[pre[u]].flow += a[t];</span><br><span class="line">edges[pre[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line"><span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, q;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * p + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> u, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        Edge&amp; ne = edges[G[u][i] ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (e.to == s || e.to == t || e.to == u - n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!e.flow) <span class="keyword">continue</span>;</span><br><span class="line">        e.flow--;</span><br><span class="line">        <span class="keyword">if</span> (e.to &gt; n) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y, e.to, id);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nx, ny, dir;</span><br><span class="line">        <span class="keyword">if</span> (e.to == <span class="built_in">point</span>(x, y) + <span class="number">1</span>) &#123;</span><br><span class="line">            nx = x; ny = y + <span class="number">1</span>;</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nx = x + <span class="number">1</span>; ny = y;</span><br><span class="line">            dir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id, dir);</span><br><span class="line">        <span class="built_in">dfs</span>(nx, ny, e.to + n, id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">read</span>(); p = <span class="built_in">read</span>(); q = <span class="built_in">read</span>();</span><br><span class="line">    n = p * q; s = <span class="number">0</span>; t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">0</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, inf, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in[<span class="number">1</span>][<span class="number">1</span>] != <span class="number">1</span>) <span class="built_in">add</span>(s, <span class="number">1</span>, c, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (in[i][j + <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; j + <span class="number">1</span> &lt;= p) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j) + n, <span class="built_in">point</span>(i, j + <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (in[i + <span class="number">1</span>][j] != <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= q) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j) + n, <span class="built_in">point</span>(i + <span class="number">1</span>, j), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in[q][p] != <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(q, p) + n, t, c, <span class="number">0</span>);</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d\n&quot;, ansflow, anscost);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ansflow; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P3356&quot;&gt;「Luogu P3356」火星探险问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
    <category term="费用流" scheme="https://tonycrane.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>manim教程系列-颜色 笔记</title>
    <link href="https://tonycrane.github.io/p/2e2c9a7.html"/>
    <id>https://tonycrane.github.io/p/2e2c9a7.html</id>
    <published>2020-04-18T05:18:52.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是在写 <strong>manim教程系列视频</strong> 的 <em>颜色</em> 部分时做的一些笔记,包括 整个视频的结构 和 写代码时了解的一些用法的笔记<br>视频已经发布,地址:<a href="https://www.bilibili.com/video/BV1vZ4y1x7hT">BV1vZ4y1x7hT</a></p><span id="more"></span><h2 id="视频结构大纲"><a href="#视频结构大纲" class="headerlink" title="视频结构大纲"></a>视频结构大纲</h2><ol start="0"><li><input checked disabled type="checkbox"> 开头<ul><li>开始,标题,展示所有要将的方法</li></ul></li><li><input checked disabled type="checkbox"> 颜色的表示<ul><li>所有<code>constants.py</code>中的颜色常量</li><li>使用hex表示颜色</li><li>使用rgb的ndarray表示颜色</li></ul></li><li><input checked disabled type="checkbox"> 颜色之间的转换<ul><li><code>rgb_to_hex</code></li><li><code>hex_to_rgb</code></li><li><code>color_to_rgb</code></li><li><code>rgb_to_color</code></li><li><code>color_to_int_rgb</code></li></ul></li><li><input checked disabled type="checkbox"> 颜色的运算函数<ul><li><code>invert_color</code></li><li><code>color_gradient</code></li><li><code>interpolate_color</code></li><li><code>average_color</code></li><li><code>random_color</code></li></ul></li><li><input checked disabled type="checkbox"> 设置颜色<ul><li><code>Mobject</code>略,一般上色的都为<code>VMobject</code></li><li><code>color</code>分为<code>stroke_color</code>和<code>fill_color</code></li><li>传入<code>color</code>, <code>stroke_color</code>, <code>fill_color</code></li><li><code>set_color</code>, <code>set_stroke</code>, <code>set_fill</code>方法的<code>color</code>和<code>opacity</code></li></ul></li><li><input checked disabled type="checkbox"> 给子物体上色<ul><li><code>set_color</code></li><li><code>set_color_by_gradient</code></li><li><code>set_colors_by_radial_gradient</code></li></ul></li><li><input checked disabled type="checkbox"> 光泽与渐变色<ul><li><code>set_sheen</code></li><li><code>set_color</code>中使用列表达到渐变色</li></ul></li></ol><h2 id="一些码视频时的笔记"><a href="#一些码视频时的笔记" class="headerlink" title="一些码视频时的笔记"></a>一些码视频时的笔记</h2><ul><li><code>isinstance</code>函数检测对象的类型</li><li>对一个字符串进行format时,想要用空格补齐左边到一定个数,可以使用<code>str(...).rjust(num)</code></li><li>涉及到<code>Transform</code>Text的地方,在Text里面不可以有空格,需要用白色的<code>~</code>来做出伪空格</li><li>字符串中查找一个字符的下标可以用<code>.index(&quot; &quot;, beg=..., end=...)</code>方法来查找第一次出现的位置,第二次出现需要传入<code>beg</code>为第一次位置+1</li><li>manim的<code>rgb_to_color</code>函数传入的rgb的值为0<del>1,不是0</del>255</li><li>用for循环遍历字典键值对<code>for key, value in dic.items():</code>,遍历其中一部分<code>for key, value in list(dic.items())[1:3]</code>将键值对转化为列表,并用切片</li><li><code>Arrow</code>的箭头为<code>.tip</code></li><li><code>.keys(),.values()</code>不为列表,需要套在<code>list()</code>里面</li><li><code>set_colors_by_radial_gradient</code>利用中心与center的距离对颜色进行插值,radius外的所有子物体全为outer_color颜色</li><li>含有<code>sheen_factor</code>的物体设置渐变色后与sheen_factor无关</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章是在写 &lt;strong&gt;manim教程系列视频&lt;/strong&gt; 的 &lt;em&gt;颜色&lt;/em&gt; 部分时做的一些笔记,包括 整个视频的结构 和 写代码时了解的一些用法的笔记&lt;br&gt;视频已经发布,地址:&lt;a href=&quot;https://www.bilibili.com/video/BV1vZ4y1x7hT&quot;&gt;BV1vZ4y1x7hT&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="manim" scheme="https://tonycrane.github.io/categories/manim/"/>
    
    <category term="笔记" scheme="https://tonycrane.github.io/categories/manim/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="笔记" scheme="https://tonycrane.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="manim" scheme="https://tonycrane.github.io/tags/manim/"/>
    
    <category term="python" scheme="https://tonycrane.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>「网络流24题」骑士共存问题-题解</title>
    <link href="https://tonycrane.github.io/p/11da5c27.html"/>
    <id>https://tonycrane.github.io/p/11da5c27.html</id>
    <published>2020-04-17T00:32:12.000Z</published>
    <updated>2020-05-05T02:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3355">「Luogu P3355」骑士共存问题</a></p><span id="more"></span><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n\times n$的棋盘,$m$个障碍(骑士不能放置)<br>求最多可以放多少个骑士,不能互相攻击</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先对棋盘进行黑白二染色,$x+y$为奇数和偶数为黑和白,求二分图最大独立集</p><ol><li>从 源点 向 黑色节点 接一条 <strong>容量为1</strong> 的边</li><li>从 白色节点 向 汇点 接一条 <strong>容量为1</strong> 的边</li><li>从 每个黑色节点 向 其能攻击到的白色节点接一条 <strong>容量为$inf$</strong> 的边</li></ol><p>求出最小割即最大流,结果为$\mathtt{n\times n - m - maxflow}$</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">8</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> valid[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        valid[x][y] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!valid[i][j]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(s, <span class="built_in">point</span>(i, j), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!valid[i][j]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), t, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!((i + j) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = i + go[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny = j + go[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;= nx &amp;&amp; nx &lt;= n &amp;&amp; <span class="number">1</span> &lt;= ny &amp;&amp; ny &lt;= n &amp;&amp; !valid[nx][ny]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(nx, ny), inf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n * n - m - maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;题目传送门: &lt;a href=&quot;https://www.luogu.com.cn/problem/P3355&quot;&gt;「Luogu P3355」骑士共存问题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="题解" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流24题" scheme="https://tonycrane.github.io/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
    
    <category term="Cpp" scheme="https://tonycrane.github.io/tags/Cpp/"/>
    
    <category term="NOIp" scheme="https://tonycrane.github.io/tags/NOIp/"/>
    
    <category term="题解" scheme="https://tonycrane.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
    <category term="网络流" scheme="https://tonycrane.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
</feed>
