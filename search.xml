<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「Learn Haskell」#0 总章</title>
    <url>/p/b3ca5c18.html</url>
    <content><![CDATA[<p style="text-align: center;">学习一门新语言之Haskell</p>

<p>之前一直很好奇函数式编程，觉得Haskell挺有意思的，想学学<br>现在高考完放假了，可以有时间具体学一学了<br>这里没有Haskell的教程，只有我在学习Haskell时写下的笔记</p>
<span id="more"></span>

<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a><br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a><br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a><br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子与应用函子</a></p>
</div>

<h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><ul>
<li><code>+ - * / ()</code>：加减乘除</li>
<li><code>div</code>：整除</li>
<li><code>mod</code>：取模</li>
<li><code>True False</code>：布尔值</li>
<li><code>|| &amp;&amp; not</code>：或且非</li>
<li><code>==</code>：条件判断，相等</li>
<li><code>/=</code>：条件判断，不等</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>Haskell中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; max <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>前缀（prefix）函数与中缀（infix）函数转换：</p>
<ul>
<li>对前缀函数加<code>``</code>使其变成中缀函数</li>
<li>对中缀函数加<code>()</code>使其变成前缀函数</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `div` <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">1</span> `max` <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; (||) <span class="type">True</span> <span class="type">False</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表是Haskell中很常见的数据类型，和Python中不同，Haskell中的列表中的所有元素必须是同一个类型。</p>
<p>以下是列表常用的函数：</p>
<ul>
<li><code>(++)</code> :: [a] -&gt; [a] -&gt; [a]：合并两个列表</li>
<li><code>(:)</code> :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。[1, 2, 3]是1:2:3:[]的语法糖</li>
<li><code>(!!)</code> :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。a !! 1相当于Python中的a[1]</li>
<li><code>head</code> :: [a] -&gt; a：返回列表的第一个元素</li>
<li><code>tail</code> :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]）</li>
<li><code>last</code> :: [a] -&gt; a：返回列表中的最后一个元素</li>
<li><code>init</code> :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表</li>
<li><code>length</code> :: Foldable t =&gt; t a -&gt; Int：返回列表的长度</li>
<li><code>null</code> :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空</li>
<li><code>reverse</code> :: [a] -&gt; [a]：返回翻转后的列表</li>
<li><code>take</code> :: Int -&gt; [a] -&gt; [a]：返回列表a的前n个元素的列表(take n a)</li>
<li><code>drop</code> :: Int -&gt; [a] -&gt; [a]：返回列表a中除去前n个元素后的列表(drop n a)</li>
<li><code>maximum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值</li>
<li><code>minimum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值</li>
<li><code>sum</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和</li>
<li><code>product</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积</li>
<li><code>elem</code> :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值n是否在列表a中(  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">elem</span> n a</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="title">n</span> `elem` a <span class="comment">--用``包上可以变成中缀函数使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Texas-ranges"><a href="#Texas-ranges" class="headerlink" title="Texas ranges"></a>Texas ranges</h3><p>使用<code>..</code>可以表示出范围并自动推导：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span> .. <span class="number">10</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;a&#x27; .. &#x27;z&#x27;]  </span><br><span class="line"><span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;<span class="type">K&#x27;</span> .. &#x27;<span class="type">Z&#x27;</span>]  </span><br><span class="line"><span class="string">&quot;KLMNOPQRSTUVWXYZ&quot;</span> </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">2</span>, <span class="number">4</span> .. <span class="number">20</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>, <span class="number">6</span> .. <span class="number">20</span>]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">5</span>, <span class="number">4</span> .. <span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>也可以用来生成无穷列表，如[1..]、[1, 3..]。同时也有函数可以生成无穷列表：</p>
<ul>
<li><code>cycle</code> :: [a] -&gt; [a]：将原列表不断循环生成无穷列表</li>
<li><code>repeat</code> :: a -&gt; [a]：将传入的值不断重复生成无穷列表<ul>
<li><code>replicate</code> :: Int -&gt; a -&gt; [a]：将值a重复n次，返回生成的列表(replicate n a)</li>
</ul>
</li>
</ul>
<h3 id="List-comprehension"><a href="#List-comprehension" class="headerlink" title="List comprehension"></a>List comprehension</h3><p>Haskell中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x * <span class="number">2</span> | x &lt;- [<span class="number">1</span> .. <span class="number">10</span>]]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [x * <span class="number">2</span> | x &lt;- [<span class="number">1</span> .. <span class="number">10</span>], x * <span class="number">2</span> &gt;= <span class="number">12</span>]  </span><br><span class="line">[<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50</span> .. <span class="number">100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>]  </span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; [x * y | x &lt;- [<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>], y &lt;- [<span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>]]  </span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>Haskell中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数：</p>
<ul>
<li><code>fst</code> :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素</li>
<li><code>snd</code> :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素</li>
<li><code>zip</code> :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组</li>
</ul>
<h2 id="Syntax-in-Functions"><a href="#Syntax-in-Functions" class="headerlink" title="Syntax in Functions"></a>Syntax in Functions</h2><p>函数可以直接定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">plus</span> x y = x + y</span><br></pre></td></tr></table></figure>
<p>这时Haskell会自动推断函数的类型为(Num a) =&gt; a -&gt; a -&gt; a。但是最好在定义函数前声明函数的类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">plus</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">plus</span> x y = x + y</span><br></pre></td></tr></table></figure>

<h3 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h3><p>定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a  </span><br><span class="line"><span class="title">first</span> (x, _, _) = x  </span><br><span class="line">  </span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b  </span><br><span class="line"><span class="title">second</span> (_, y, _) = y  </span><br><span class="line">  </span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c  </span><br><span class="line"><span class="title">third</span> (_, _, z) = z  </span><br></pre></td></tr></table></figure>
<p>其中<code>_</code>表示任何值，且不关心它的内容，只是用来占位</p>
<p>列表的(:)操作也可以用来进行模式匹配：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x</span><br><span class="line"></span><br><span class="line"><span class="title">sum&#x27;</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">sum&#x27;</span> [] = <span class="number">0</span>  </span><br><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs  </span><br></pre></td></tr></table></figure>
<p>但(++)操作不可以用来模式匹配</p>
<p>在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用<code>xs@(q:qs)</code>。比如[1, 2, 3]通过<code>xs@(q:qs)</code>匹配后，xs为[1, 2, 3]，q为1，qs为[2, 3]</p>
<h3 id="Guard-syntax"><a href="#Guard-syntax" class="headerlink" title="Guard syntax"></a>Guard syntax</h3><p>在函数的定义中，也可以使用守卫（guard）语法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">max&#x27;</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">max&#x27;</span> a b   </span><br><span class="line">    | a &gt; b     = a  </span><br><span class="line">    | otherwise = b </span><br></pre></td></tr></table></figure>
<p>先给出传入的参数变量，然后下一行缩进后加|，|后面等号前表示进行的判断，如果为True则返回这个等号后面的值；如果为False则继续判断下一行，直到otherwise</p>
<h3 id="Case-expressions"><a href="#Case-expressions" class="headerlink" title="Case expressions"></a>Case expressions</h3><p>在函数的定义中，也可以使用case表达式来配合模式匹配使用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result  </span><br><span class="line">                   pattern -&gt; result</span><br><span class="line">                   ...  </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x  </span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line">                      (x:_) -&gt; x  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; <span class="string">&quot;empty.&quot;</span>  </span><br><span class="line">                                               [x] -&gt; <span class="string">&quot;a singleton list.&quot;</span>   </span><br><span class="line">                                               xs -&gt; <span class="string">&quot;a longer list.&quot;</span>  </span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ what xs  </span><br><span class="line">    <span class="keyword">where</span> what [] = <span class="string">&quot;empty.&quot;</span>  </span><br><span class="line">          what [x] = <span class="string">&quot;a singleton list.&quot;</span>  </span><br><span class="line">          what xs = <span class="string">&quot;a longer list.&quot;</span> </span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>声明在函数定义中要使用的局部变量，可以使用where关键字：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">nitials</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">initials</span> firstname lastname = [f] ++ <span class="string">&quot;. &quot;</span> ++ [l] ++ <span class="string">&quot;.&quot;</span>  </span><br><span class="line">    <span class="keyword">where</span> (f:_) = firstname  </span><br><span class="line">          (l:_) = lastname  </span><br></pre></td></tr></table></figure>
<p>在where中，也可以使用上面的模式匹配</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let &lt;bindings&gt; in &lt;expression&gt;</code>语法可以在函数的定义中使用，也可以在普通算式或列表中使用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">cylinder</span> r h = </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h  </span><br><span class="line">        topArea = pi * r ^<span class="number">2</span>  </span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> * (<span class="keyword">let</span> a = <span class="number">9</span> <span class="keyword">in</span> a + <span class="number">1</span>) + <span class="number">2</span>  </span><br><span class="line"><span class="number">42</span> </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="keyword">let</span> square x = x * x <span class="keyword">in</span> (square <span class="number">5</span>, square <span class="number">3</span>, square <span class="number">2</span>)]  </span><br><span class="line">[(<span class="number">25</span>,<span class="number">9</span>,<span class="number">4</span>)] </span><br></pre></td></tr></table></figure>

<h3 id="if-statement"><a href="#if-statement" class="headerlink" title="if statement"></a>if statement</h3><p>Haskell中的if语句为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> ...</span><br><span class="line"><span class="comment">-- or if ... then ... else ...</span></span><br><span class="line"><span class="comment">-- or</span></span><br><span class="line"><span class="title">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> <span class="keyword">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> ...</span><br></pre></td></tr></table></figure>
<p>其中最后一个else无论如何也不可以省去</p>
<h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h2><h3 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h3><p>Haskell中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如max函数，它的类型签名是：</p>
<p style="text-align: center;">max :: Ord a => a -> a -> a</p>

<p>可以看成a -&gt; (a -&gt; a)，即接收一个参数，返回一个类型为a -&gt; a的函数。比如max 1的类型签名是：</p>
<p style="text-align: center;">max 1 :: (Ord a, Num a) => a -> a</p>

<p>因此max 1 2，也就等同于(max 1) 2，即将函数max 1应用在数字2上</p>
<p>同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions）</p>
<h3 id="一些高阶函数"><a href="#一些高阶函数" class="headerlink" title="一些高阶函数"></a>一些高阶函数</h3><h4 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h4><p style="text-align: center;">zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]</p>

<p>第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith max [<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]  </span><br></pre></td></tr></table></figure>

<h4 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h4><p style="text-align: center;">flip :: (a -> b -> c) -> b -> a -> c</p>

<p>flip函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">&quot;hello&quot;</span></span><br><span class="line">[(<span class="number">1</span>,&#x27;h&#x27;),(<span class="number">2</span>,&#x27;e&#x27;),(<span class="number">3</span>,&#x27;l&#x27;),(<span class="number">4</span>,&#x27;l&#x27;),(<span class="number">5</span>,&#x27;o&#x27;)]</span><br><span class="line"><span class="title">ghci</span>&gt; flip zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">&quot;hello&quot;</span>  </span><br><span class="line">[(&#x27;h&#x27;,<span class="number">1</span>),(&#x27;e&#x27;,<span class="number">2</span>),(&#x27;l&#x27;,<span class="number">3</span>),(&#x27;l&#x27;,<span class="number">4</span>),(&#x27;o&#x27;,<span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map函数接收一个函数f和一个列表a，将函数f应用在列表a的每个元素中，并返回得到的所有结果组成的列表b：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]  </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]  </span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p style="text-align: center;">filter :: (a -> Bool) -> [a] -> [a]</p>

<p>filter函数接收一个函数f和一个列表a，将列表a中的每个元素传入函数f中，如果结果为True就保留，结果为False就抛弃，返回所有保留的元素组成的新列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; filter even [<span class="number">1.</span><span class="number">.10</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] </span><br></pre></td></tr></table></figure>

<h4 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h4><p style="text-align: center;">takeWhile :: (a -> Bool) -> [a] -> [a]</p>

<p>takeWhile函数接收一个函数f和一个列表a，将列表a中从左向右每个元素传入函数f，直到结果为False停止，返回停止前传入的所有元素组成的新列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; takeWhile (/=&#x27; &#x27;) <span class="string">&quot;word1 word2&quot;</span></span><br><span class="line"><span class="string">&quot;word1&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-application"><a href="#Function-application" class="headerlink" title="Function application"></a>Function application</h3><p>函数应用可以使用<code>$</code>，<code>$</code>是一个函数，它的类型是：</p>
<p style="text-align: center;">($) :: (a -> b) -> a -> b</p>

<p>它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f</span> $ g x</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="title">f</span> (g x)</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="title">f</span> g x</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line">(f g) x</span><br></pre></td></tr></table></figure>
<h3 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h3><p>函数复合可以使用<code>.</code>，<code>.</code>也是一个函数，它的类型是：</p>
<p style="text-align: center;">(.) :: (b -> c) -> (a -> b) -> a -> c</p>

<p>定义是：</p>
<p style="text-align: center;">f . g = \x -> f (g x)</p>

<p>但是函数复合的优先级要比函数执行低，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum</span> . replicate <span class="number">5</span> . max <span class="number">6.7</span> <span class="number">8.9</span></span><br></pre></td></tr></table></figure>
<p>会先执行max 6.7 8.9并返回8.9，然后将sum、replicate 5、8.9复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用<code>$</code>来规定先复合再执行：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum</span> . replicate <span class="number">5</span> . max <span class="number">6.7</span> $ <span class="number">8.9</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>Haskell语言中的lambda表达式是用<code>\</code>来表示的（因为看着像$\mathtt{\lambda}$？）<br>具体语法是</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">\para1 para2 ... -&gt; return</span><br></pre></td></tr></table></figure>
<p>“-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。</p>
<h3 id="fold和scan"><a href="#fold和scan" class="headerlink" title="fold和scan"></a>fold和scan</h3><p>fold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表<br>传入的二元函数<code>f :: a -&gt; b -&gt; b</code>将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数）</p>
<h4 id="foldl"><a href="#foldl" class="headerlink" title="foldl"></a>foldl</h4><p>左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldl</span> f a xs</span><br></pre></td></tr></table></figure>
<p>它的结果计算过程为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; foldl f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f a x1</span><br><span class="line">[<span class="number">2.</span>] a = f a x2 = f (f a x1) x2</span><br><span class="line">[<span class="number">3.</span>] a = f a x3 = f (f (f a x1) x2) x3</span><br></pre></td></tr></table></figure>
<p>可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]<br>而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表</p>
<h4 id="foldr"><a href="#foldr" class="headerlink" title="foldr"></a>foldr</h4><p>右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> f a xs</span><br></pre></td></tr></table></figure>
<p>它的结果计算过程为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; foldr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f x3 a</span><br><span class="line">[<span class="number">2.</span>] a = f x2 a = f x2 (f x3 a)</span><br><span class="line">[<span class="number">3.</span>] a = f x1 a = f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure>
<p>从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]<br>因此可以使用递归来写一个和foldr效果一样的函数:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">foldr&#x27;</span> _ x [] = x</span><br><span class="line"><span class="title">foldr&#x27;</span> f a (x:xs) = f x (foldr&#x27; f a xs)</span><br></pre></td></tr></table></figure>
<p>也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表</p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; foldr (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="type">True</span>    <span class="comment">-- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了</span></span><br><span class="line"><span class="title">ghci</span>&gt; foldl (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="comment">-- 这里什么都不会发生，直到电脑内存被爆掉</span></span><br><span class="line"><span class="comment">-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表</span></span><br></pre></td></tr></table></figure>

<h4 id="scanl和scanr"><a href="#scanl和scanr" class="headerlink" title="scanl和scanr"></a>scanl和scanr</h4><p>scan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表<br>scanl则向右延伸这个列表，scanr则向左延伸这个列表<br>但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; scanr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] 最右侧元素(<span class="number">-1</span> <span class="keyword">in</span> python) : a</span><br><span class="line">[<span class="number">2.</span>] 右侧第二个元素(<span class="number">-2</span>) : f x3 a</span><br><span class="line">[<span class="number">3.</span>] 右侧第三个元素(<span class="number">-3</span>) : f x2 (f x3 a)</span><br><span class="line">[<span class="number">4.</span>] 右侧第四个元素(<span class="number">-4</span>) : f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure>
<p>可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素<br>因此可以用递归来写一个和scanr效果一样的函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">scanr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanr&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="comment">-- scanr&#x27; f a (x:xs) = f x (foldr f a xs) : scanr&#x27; f a xs</span></span><br><span class="line"><span class="title">scanr&#x27;</span> f a (x:xs) = f x q : qs</span><br><span class="line">                    <span class="keyword">where</span> qs@(q:_) = scanr&#x27; f a xs</span><br></pre></td></tr></table></figure>
<p>scanl也是同理：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">scanl&#x27;</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanl&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="title">scanl&#x27;</span> f a (x:xs) = a : scanl&#x27; f (f a x) xs</span><br></pre></td></tr></table></figure>

<p>也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanl (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">28</span>,<span class="number">36</span>,<span class="number">45</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanr (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[*** <span class="type">Exception</span>: stack overflow</span><br></pre></td></tr></table></figure>

<h4 id="使用foldr编写foldl"><a href="#使用foldr编写foldl" class="headerlink" title="使用foldr编写foldl"></a>使用foldr编写foldl</h4><p>pdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldl&#x27;</span> f z xs = foldr (\x g y -&gt; g (f y x)) id xs z</span><br></pre></td></tr></table></figure>

<p>它利用 foldr (\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。</p>
<p>先来看一下foldr的类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> :: <span class="type">Foldable</span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line"><span class="comment">-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br></pre></td></tr></table></figure>
<p>但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。</p>
<p>所以这里foldr的类型可以写成：</p>
<p style="text-align: center;">(a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b)</p>

<p>对应于用法 foldr (\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）<br>而xs对应于[a]；id对应于(b -&gt; b)<br>所以 (\x g y -&gt; g (f y x)) 要对应于：</p>
<p style="text-align: center;">(a -> (b -> b) -> (b -> b))</p>

<p>因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。</p>
<p>再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b<br>所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为：</p>
<p style="text-align: center;">b -> (b -> b)</p>

<p>现在根据foldr的定义：</p>
<p style="text-align: center;">foldr f a (x:xs) = f x (foldr f a xs)</p>

<p>带入计算一下：</p>
<blockquote>
<p>xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn]</p>
<p>定义中的f即为(\x g y -&gt; g (f y x))，a即为id</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  foldr (\x g y -&gt; g (f y x)) id xs z</span><br><span class="line">= (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br></pre></td></tr></table></figure>
<p>写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br></pre></td></tr></table></figure>
<p>不难发现，原式 (foldr (…) id xs) z 等价于：</p>
<p style="text-align: center;">(foldr (...) id xs') (f z x1)</p>

<p>跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’<br>因此下一步：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;&#x27;) (f (f (f z x1) x2) x3)</span><br><span class="line">= ...</span><br></pre></td></tr></table></figure>
<p>可以发现，已经有了规律。那么最终停止时是什么样呢？</p>
<p>最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []<br>而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id</p>
<p>所以最后的结果：<br>(id的定义：id x = x)</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= ...</span><br><span class="line">= (foldr (...) id []) (f (.. (f z x1) ..) xn)</span><br><span class="line">= id (f (.. (f z x1) ..) xn)</span><br><span class="line">= f (.. (f z x1) ..) xn</span><br></pre></td></tr></table></figure>
<p>那么最后这个结果就很熟悉了，它就是 foldl f z xs。<br>所以我们推导出了这个用foldr表示foldl的写法是正确的。</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Haskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用<code>:m + ...</code>，比如加载Data.List模块：</p>
<p style="text-align: center;">Prelude> :m + Data.List</p>

<p>而在hs文件中引入模块，需要使用<code>import</code>语句，下面和python的对比可以便于理解：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="comment">-- from Data.List import *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">nub</span>, <span class="title">sort</span>)</span><br><span class="line"><span class="comment">-- from Data.List import nub, sort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List <span class="keyword">hiding</span> (<span class="title">nub</span>)</span><br><span class="line"><span class="comment">-- 从Data.List中引入所有，但不引入nub函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List</span><br><span class="line"><span class="comment">-- import Data.List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List <span class="keyword">as</span> Li</span><br><span class="line"><span class="comment">-- import Data.List as Li</span></span><br></pre></td></tr></table></figure>

<h3 id="编写Modules"><a href="#编写Modules" class="headerlink" title="编写Modules"></a>编写Modules</h3><p>模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫<code>ModuleA.hs</code>，那它的头部需要写：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleA</span><br><span class="line">( <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">, <span class="title">functionC</span></span><br><span class="line">) <span class="keyword">where</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。</p>
<h2 id="Types-amp-Typeclasses"><a href="#Types-amp-Typeclasses" class="headerlink" title="Types &amp; Typeclasses"></a>Types &amp; Typeclasses</h2><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Haskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。<br>Type的首字母全为大写，常用的有：</p>
<ul>
<li><code>Int</code>：整型，有上下界范围，-2147483647～2147483648</li>
<li><code>Integer</code>：整数，无界，但是效率比Int低</li>
<li><code>Float</code>：单精度浮点型</li>
<li><code>Double</code>：双精度浮点型</li>
<li><code>Bool</code>：布尔值</li>
<li><code>Char</code>：字符</li>
<li><code>String</code>：字符串，等同于<code>[Char]</code></li>
<li><code>Ording</code>：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT</li>
</ul>
<p>列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加<code>[]</code>。</p>
<p>元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。</p>
<h3 id="Typeclasses"><a href="#Typeclasses" class="headerlink" title="Typeclasses"></a>Typeclasses</h3><p>类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个Typeclass<br>Typeclass的首字母也全为大写，常见的有：</p>
<ul>
<li><code>Eq</code>：可判断是否相等</li>
<li><code>Ord</code>：可比较大小</li>
<li><code>Show</code>：可展示成字符串</li>
<li><code>Read</code>：可从字符串转换成特定类型</li>
<li><code>Enum</code>：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀</li>
<li><code>Bounded</code>: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded</li>
<li><code>Integral</code>：是整数，包括Int和Integer</li>
<li><code>RealFloat</code>： 是实浮点数，包括Float和Double</li>
<li><code>RealFrac</code>：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中）</li>
<li><code>Floating</code>：是浮点数，包括Float、Double和Complex（在Data.Complex模块中）</li>
<li><code>Real</code>：是实数，包括Integral和RealFrac的成员</li>
<li><code>Fractional</code>：是分数，包括RealFrac和Floating的成员</li>
<li><code>Num</code>：是数字，包括上述所有数字相关的类型</li>
</ul>
<h3 id="Type-variables"><a href="#Type-variables" class="headerlink" title="Type variables"></a>Type variables</h3><p>如果查看一个函数的类型，比如<code>head</code>，那么将会返回以下类型：</p>
<p style="text-align: center;">head :: [a] -> a</p>

<p>其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。</p>
<p>在函数的类型表达式其实可以看作$\lambda$表达式，它适用于$\alpha$变换（$\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。</p>
<p>在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如<code>(==)</code>函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么<code>(==)</code>的类型就是：</p>
<p style="text-align: center;">(==) :: (Eq a) => a -> a -> Bool</p>

<p>其中<code>=&gt;</code>前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以<code>(==)</code>函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。</p>
<h3 id="定义新Type"><a href="#定义新Type" class="headerlink" title="定义新Type"></a>定义新Type</h3><p>定义一个新的Type需要使用<code>data</code>关键字，比如定义<code>Bool</code>需要使用：</p>
<p style="text-align: center;">data Bool = False | True</p>

<p>其中<code>=</code>左侧的部分定义了新类型的名称<code>Bool</code>，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。<br>并且名称和值构造器的首字母都需要大写。</p>
<p>另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span>   </span></span><br></pre></td></tr></table></figure>
<p>它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。<br>如果查看Circle的类型，将返回：</p>
<p style="text-align: center;">Circle :: Float -> Float -> Float -> Shape</p>

<p>如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上<code>deriving (Show)</code>:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>类型的名称和值构造器名称也可以相同，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="导出Type"><a href="#导出Type" class="headerlink" title="导出Type"></a>导出Type</h4><p>在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件<code>Shapes.hs</code>中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Shapes</span><br><span class="line">( <span class="type">Shape(..)</span></span><br><span class="line">, <span class="type">Point(..)</span></span><br><span class="line">, <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">) <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>Shape(..)</code>导出了Shape类型和它所有的值构造器，<code>..</code>代表了它的所有值构造器。因此，<code>Shape(..)</code>相当于<code>Shape (Circle, Rectangle)</code>。</p>
<p>如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将<code>Shape(..)</code>替换为<code>Shape</code>，这样就只导出了Shape类型，而不导出其值构造器。</p>
<h4 id="Record-Syntax"><a href="#Record-Syntax" class="headerlink" title="Record Syntax"></a>Record Syntax</h4><p>如果想要方便地取出类型实例中的参数，可以使用Record语法，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   , <span class="title">ycoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> point = <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; xcoord point</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; ycoord point</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>同时也可以通过下面方法来创建这个point：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">point</span> = <span class="type">Point</span> &#123;ycoord=<span class="number">2.0</span>, xcoord=<span class="number">1.0</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Type-parameters"><a href="#Type-parameters" class="headerlink" title="Type parameters"></a>Type parameters</h4><p>值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义：</p>
<p style="text-align: center;">data Maybe a = Nothing | Just a</p>

<p>它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。<br>他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">Nothing</span> :: <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> <span class="number">1</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> &#x27;a&#x27; :: <span class="type">Maybe</span> <span class="type">Char</span></span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;abc&quot;</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]</span><br></pre></td></tr></table></figure>

<p>可以用这种方法改写Point：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> x y = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="title">x</span></span></span><br><span class="line"><span class="class">                       , <span class="title">ycoord</span> :: <span class="title">y</span></span></span><br><span class="line"><span class="class">                       &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。</p>
<p>而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> (<span class="type">Ord</span> <span class="title">k</span>) =&gt; <span class="type">Map</span> k v = ... </span></span><br><span class="line"><span class="title">toList</span> :: (<span class="type">Ord</span> k) =&gt; <span class="type">Map</span> k a -&gt; [(k, a)]</span><br></pre></td></tr></table></figure>

<h4 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h4><p>Either是一个类型构造器，它有两个值构造器，定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Read</span>, <span class="type">Show</span>)  </span></span><br></pre></td></tr></table></figure>
<p>如果使用了Left，那它的a的类型就是具体的；如果使用了Right，那它的b的类型就是具体的：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Right</span> <span class="number">20</span>  </span><br><span class="line"><span class="type">Right</span> <span class="number">20</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Left</span> <span class="string">&quot;w00t&quot;</span>  </span><br><span class="line"><span class="type">Left</span> <span class="string">&quot;w00t&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Right</span> &#x27;a&#x27;  </span><br><span class="line"><span class="type">Right</span> &#x27;a&#x27; :: <span class="type">Either</span> a <span class="type">Char</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Left</span> <span class="type">True</span>  </span><br><span class="line"><span class="type">Left</span> <span class="type">True</span> :: <span class="type">Either</span> <span class="type">Bool</span> b  </span><br></pre></td></tr></table></figure>
<p>Either可以看作Maybe的补充，比如Maybe在使用时，出现异常可以返回Nothing，但只是一个Nothing，不包含任何信息；但Either包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Nothing</span></span><br><span class="line"><span class="title">safeDiv</span> x y = <span class="type">Just</span> (x `div` y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>而使用Either：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Either</span> <span class="type">String</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Left</span> <span class="string">&quot;Divided by zero&quot;</span></span><br><span class="line"><span class="title">safeDiv</span> x y = <span class="type">Right</span> (x `div` y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="type">Right</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="type">Left</span> <span class="string">&quot;Divided by zero&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Derived-instances"><a href="#Derived-instances" class="headerlink" title="Derived instances"></a>Derived instances</h4><p>想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span>   </span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)  </span><br></pre></td></tr></table></figure>
<p>这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右）</p>
<h4 id="Type-synonyms"><a href="#Type-synonyms" class="headerlink" title="Type synonyms"></a>Type synonyms</h4><p>为了阅读方便，书写简便，可以使用<code>type</code>关键字为已有类型创建别名（synonyms）。比如String的定义：</p>
<p style="text-align: center;">type String = [Char]</p>

<p>在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。<br>同时，类型别名也可以接收类型参数</p>
<h4 id="newtype-keyword"><a href="#newtype-keyword" class="headerlink" title="newtype keyword"></a>newtype keyword</h4><p>除了<code>data</code>、<code>type</code>关键字之外，还可以用<code>newtype</code>关键字来定义一个新的类型，比如<code>Control.Applicative</code>模块中的ZipList：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ZipList</span> a = &#123; <span class="title">getZipList</span> :: [<span class="title">a</span>] &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不同于type，它不是别名，可以使用record语法来直接定义取出值的函数</li>
<li>不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰</li>
</ul>
<h4 id="Recursive-data-structures"><a href="#Recursive-data-structures" class="headerlink" title="Recursive data structures"></a>Recursive data structures</h4><p>一个类型也可以递归定义，比如一颗二叉树：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">EmptyTree</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>)  </span></span><br></pre></td></tr></table></figure>

<h3 id="定义新Typeclass"><a href="#定义新Typeclass" class="headerlink" title="定义新Typeclass"></a>定义新Typeclass</h3><p>定义一个新的Typeclass需要使用class关键字，例如定义Eq类型类：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span>  </span><br><span class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span>  </span><br><span class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span>  </span><br><span class="line">    x == y = not (x /= y)  </span><br><span class="line">    x /= y = not (x == y)  </span><br></pre></td></tr></table></figure>
<p>其中<code>a</code>是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。</p>
<p>包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们（<code>(==) | (/=)</code>）成为这个类型类的最小完整定义（minimal complete definition）</p>
<p>查看一个类型类的成员需要实现的函数可以在GHCi中使用<code>:info</code>：</p>
<p style="text-align: center;">ghci> :info Eq</p>

<h4 id="手动创建实例"><a href="#手动创建实例" class="headerlink" title="手动创建实例"></a>手动创建实例</h4><p>使一个类型成为一个类型类的实例可以直接使用<code>deriving</code>来自动完成，也可以通过使用instance关键字来手动完成。比如使Point成为Show的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Point</span> <span class="keyword">where</span></span></span><br><span class="line">    show (<span class="type">Point</span> x y) = <span class="string">&quot;(&quot;</span> ++ show x ++ <span class="string">&quot;, &quot;</span> ++ show y ++ <span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- in ghci</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以自定义显示的内容，否则使用deriving的话只会直接将其转化为字符串。</p>
<p>同时也要注意类型和类型构造器的区别，传入给instance的第二个参数应该为类型而不是类型构造器，比如Maybe：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">Maybe</span> <span class="keyword">where</span></span>  </span><br><span class="line">    ...    </span><br><span class="line"><span class="comment">-- 错误用法，因为Maybe是类型构造器而不是类型</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    ...</span><br><span class="line"><span class="comment">-- 错误用法，因为m不一定是Eq的成员</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Eq</span> <span class="title">m</span>) =&gt; <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    <span class="type">Just</span> x == <span class="type">Just</span> y = x == y  </span><br><span class="line">    <span class="type">Nothing</span> == <span class="type">Nothing</span> = <span class="type">True</span>  </span><br><span class="line">    _ == _ = <span class="type">False</span>  </span><br></pre></td></tr></table></figure>

<h4 id="Functor-Typeclass"><a href="#Functor-Typeclass" class="headerlink" title="Functor Typeclass"></a>Functor Typeclass</h4><p>Functor也是一种类型类，它只规定了一个函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>其中<code>f</code>是一个类型构造器，而不是一个具体类型</p>
<h3 id="Kinds"><a href="#Kinds" class="headerlink" title="Kinds"></a>Kinds</h3><p>一个值的类型叫做类型（Type），而一个类型的类型叫做Kind。可以通过GHCi中<code>:k</code>来查看Kind：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Int</span></span><br><span class="line"><span class="type">Int</span> :: *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Maybe</span></span><br><span class="line"><span class="type">Maybe</span> :: * -&gt; *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="type">Maybe</span> <span class="type">Int</span> :: *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Either</span></span><br><span class="line"><span class="type">Either</span> :: * -&gt; * -&gt; *</span><br></pre></td></tr></table></figure>
<p>其中的星号<code>*</code>代表了一个具体类型（concrete type）。Int本身就是一个具体类型，所以Int的Kind是*。而Maybe是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以Maybe的Kind是* -&gt; *。如果给Maybe传入了一个Int，那么得到的Maybe Int就是一个具体的类型，它的Kind就是*。Either也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以Either的Kind是* -&gt; * -&gt; *。</p>
<h2 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h2><h3 id="运行Haskell程序"><a href="#运行Haskell程序" class="headerlink" title="运行Haskell程序"></a>运行Haskell程序</h3><p>不在GHCi中运行一个Haskell程序有两种方式：</p>
<ol>
<li>编译运行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ghc --make code</span><br><span class="line">$ ./code</span><br></pre></td></tr></table></figure></li>
<li>通过<code>runhaskell</code>命令直接运行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ runhaskell code.hs</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="输出文本"><a href="#输出文本" class="headerlink" title="输出文本"></a>输出文本</h3><p>在一个Haskell程序中输出文字需要定义一个main函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中putStrLn的类型是：</p>
<p style="text-align: center;">putStrLn :: String -> IO ()</p>

<p>putStrLn接收一个String类型，并返回一个结果为()类型的IO动作（I/O action）。所以main函数的类型为IO ()。（IO的Kind是* -&gt; *）</p>
<p>除此之外，还有其他默认提供的输出文本的函数：</p>
<ul>
<li><code>putStr</code>：输出文本，结尾不换行</li>
<li><code>putChar</code>：输出单个字符，结尾不换行。接收的参数为单个Char，不是String（用单引号不是双引号）</li>
<li><code>print</code>：可以接收任何Show的成员，先用show转化为字符串然后输出。等同于putStrLn . show</li>
</ul>
<h4 id="do-block"><a href="#do-block" class="headerlink" title="do block"></a>do block</h4><p>在main函数中使用多个putStrLn需要使用do语句：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    putStrLn <span class="string">&quot;Line1&quot;</span></span><br><span class="line">    putStrLn <span class="string">&quot;Line2&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中最后一行一定要返回IO ()类型的值</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>输入文字需要在do块中使用getLine：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    line &lt;- getLine</span><br><span class="line">    putStrLn line</span><br></pre></td></tr></table></figure>
<p>getLine的类型是：</p>
<p style="text-align: center;">getLine :: IO String</p>

<p>而&lt;-操作符将getLine中的String提取了出来给到了line，使line变成了String类型的一个字符串。</p>
<p>而且使用输入的字符串必须要经过一次&lt;-，不能直接使用getLine作为字符串，因为getLine不是String类型，而是IO String类型。</p>
<p>除此之外，还可以使用getChar来获取单个字符，但仍然需要使用&lt;-操作符来提取Char</p>
<h3 id="其他IO相关函数用法"><a href="#其他IO相关函数用法" class="headerlink" title="其他IO相关函数用法"></a>其他IO相关函数用法</h3><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>Haskell中的return和其他命令式语言中的return完全不同，它不会使函数直接结束并返回一个值。</p>
<p>main函数必须定义为类型为IO ()的函数，所以在main函数中使用if语句，如果不输出的话也不可以直接放下什么都不干，因为这时候main函数的类型不是IO ()。所以这时需要使用return ()来为main函数指定为IO ()类型，例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    line &lt;- getLine</span><br><span class="line">    <span class="keyword">if</span> null line</span><br><span class="line">        <span class="keyword">then</span> return () <span class="comment">-- &lt;-这里</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">do</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>使用&lt;-操作符也可以直接将return语句中的内容提取出来，比如a &lt;- return ‘A’，执行后a就是’A’。</p>
<h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p>when包含在<code>Control.Monad</code>模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会return ()。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad   </span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    when (c /= &#x27; &#x27;) $ <span class="keyword">do</span>  </span><br><span class="line">        putChar c  </span><br><span class="line">        main  </span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span>     </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    <span class="keyword">if</span> c /= &#x27; &#x27;  </span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">do</span>  </span><br><span class="line">            putChar c  </span><br><span class="line">            main  </span><br><span class="line">        <span class="keyword">else</span> return () </span><br></pre></td></tr></table></figure>

<h4 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h4><p>sequence在IO中使用时可以达成[IO a] -&gt; IO [a]的效果，所以可以用作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[a, b, c] &lt;- sequence [getLine, getLine, getLine]</span><br></pre></td></tr></table></figure>

<h4 id="mapM-amp-mapM"><a href="#mapM-amp-mapM" class="headerlink" title="mapM &amp; mapM_"></a>mapM &amp; mapM_</h4><p>在IO相关的地方使用map，可以使用mapM和mapM_，其中mapM有返回值而mapM_直接扔掉了返回值：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mapM print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line">[(),(),()]  </span><br><span class="line"><span class="title">ghci</span>&gt; mapM_ print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br></pre></td></tr></table></figure>

<h4 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h4><p>forever函数包含在<code>Control.Monad</code>模块中。在main函数开头加上forever函数可以使后面的do块一直重复执行直到程序被迫终止，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = forever $ <span class="keyword">do</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h4 id="forM"><a href="#forM" class="headerlink" title="forM"></a>forM</h4><p>forM函数包含在<code>Control.Monad</code>模块中，它的功能和mapM类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回IO a类型。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    colors &lt;- forM [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] (\a -&gt; <span class="keyword">do</span></span><br><span class="line">        putStrLn $ <span class="string">&quot;Which color do you associate with the number &quot;</span> ++ show a ++ <span class="string">&quot;?&quot;</span>  </span><br><span class="line">        color &lt;- getLine  </span><br><span class="line">        return color)</span><br><span class="line">    putStrLn <span class="string">&quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;</span>  </span><br><span class="line">    mapM putStrLn colors</span><br></pre></td></tr></table></figure>

<h4 id="getContents"><a href="#getContents" class="headerlink" title="getContents"></a>getContents</h4><p>getLine获取一整行，而getContents从标准输入中获取全部内容直到遇到EOF，并且它是lazy的，在执行了foo &lt;- getContents后，它并不会读取标准输入并且赋值到foo，而是等到需要使用foo的时候再从标准输入读取。</p>
<p>getContents在使用管道传入文字时很常用，可以代替forever+getLine使用，比如一个Haskell程序文件code.hs：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Char  </span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    contents &lt;- getContents  </span><br><span class="line">    putStr (map toUpper contents)  </span><br></pre></td></tr></table></figure>
<p>使用ghc –make code编译后，通过管道传入文字：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat text.txt | ./code</span><br></pre></td></tr></table></figure>
<p>会将text.txt中的所有字母转为大写并输出</p>
<h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>上述功能还可以转化为一个String -&gt; String的函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">upperStrings</span> = unlines . map (map toUpper) . lines</span><br></pre></td></tr></table></figure>
<p>而在main中使用这个函数就需要：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    contents &lt;- getContents</span><br><span class="line">    putStr (upperStrings contents)</span><br></pre></td></tr></table></figure>
<p>但是String -&gt; String类型的函数在输入输出中的使用太常见了，所以可以使用interact函数来简化。interact的类型是：</p>
<p style="text-align: center;">interact :: (String -> String) -> IO ()</p>

<p>可以看出它接收一个String -&gt; String的函数，并返回一个IO ()类型，所以可以直接用在main上。</p>
<p>于是整个转换为大写的程序就可以简化为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = interact $ unlines . map (map toUpper) . lines</span><br></pre></td></tr></table></figure>

<h3 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h3><p>以下与文件和流相关的函数都包含在<code>System.IO</code>模块中</p>
<h4 id="openFile"><a href="#openFile" class="headerlink" title="openFile"></a>openFile</h4><p>openFile函数可以用来打开一个文件，它的类型是：</p>
<p style="text-align: center;">openFile :: FilePath -> IOMode -> IO Handle</p>

<p>其中<code>FilePath</code>是String的type synonyms，用一个字符串来表示需要打开的文件的路径</p>
<p><code>IOMode</code>的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IOMode</span> = <span class="type">ReadMode</span> | <span class="type">WriteMode</span> | <span class="type">AppendMode</span> | <span class="type">ReadWriteMode</span></span></span><br></pre></td></tr></table></figure>
<p>所以它一共只有四个值，用来表示进行IO操作的模式</p>
<p>openFile返回一个IO Handle类型的值，将其用&lt;-操作符提取后会出现一个Handle的值。但不能从Handle中直接使用文字，还需要使用一系列函数：</p>
<ul>
<li><code>hGetContents</code> :: Handle -&gt; IO String ，从Handle中读取全部内容，返回一个IO String</li>
<li><code>hGetChar</code> :: Handle -&gt; IO Char ，从Handle中读取一个字符</li>
<li><code>hGetLine</code> :: Handle -&gt; IO String ，从Handle中读取一行，返回一个IO String</li>
<li><code>hPutStr</code> :: Handle -&gt; String -&gt; IO () ，向Handle中输出字符串</li>
<li><code>hPutStrLn</code> :: Handle -&gt; String -&gt; IO () ，同上</li>
</ul>
<p>在使用openFile进行文件操作后，需要使用hClose手动关闭Handle。hClose :: Handle -&gt; IO ()，接收一个Handle并返回IO ()，可以直接放在main函数末尾</p>
<p>所以使用openFile读取一个文件中的全部内容并输出的全部代码是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    handle &lt;- openFile <span class="string">&quot;text.txt&quot;</span> <span class="type">ReadMode</span></span><br><span class="line">    contents &lt;- hGetContents handle</span><br><span class="line">    putStrLn contents</span><br><span class="line">    hClose handle</span><br></pre></td></tr></table></figure>

<h4 id="withFile"><a href="#withFile" class="headerlink" title="withFile"></a>withFile</h4><p>withFile类似Python中的with open，它在读取文件使用之后不需要手动close文件。它的类型是：</p>
<p style="text-align: center;">withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a</p>

<p>可以看出，它接收三个参数：</p>
<ul>
<li><code>FilePath</code>：一个表示文件路径的String</li>
<li><code>IOMode</code>：打开文件的模式</li>
<li><code>(Handle -&gt; IO a)</code>：一个函数，表示对读取文件后的Handle索要进行的操作，需要返回一个I/O action；而这个返回值也将作为withFile的返回值</li>
</ul>
<p>现在使用withFile来改写上述代码：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = withFile <span class="string">&quot;text.txt&quot;</span> <span class="type">ReadMode</span> (\handle -&gt; <span class="keyword">do</span></span><br><span class="line">    contents &lt;- hGetContents handle</span><br><span class="line">    putStrLn contents)</span><br></pre></td></tr></table></figure>

<p>withFile的功能相当于以下函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">withFile&#x27;</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IOMode</span> -&gt; (<span class="type">Handle</span> -&gt; <span class="type">IO</span> a) -&gt; <span class="type">IO</span> a  </span><br><span class="line"><span class="title">withFile&#x27;</span> path mode f = <span class="keyword">do</span>  </span><br><span class="line">    handle &lt;- openFile path mode   </span><br><span class="line">    result &lt;- f handle  </span><br><span class="line">    hClose handle  </span><br><span class="line">    return result  </span><br></pre></td></tr></table></figure>

<h4 id="readFile"><a href="#readFile" class="headerlink" title="readFile"></a>readFile</h4><p>readFile可以更加简化读取文件内容的操作，它的类型：</p>
<p style="text-align: center;">readFile :: FilePath -> IO String</p>

<p>它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的I/O action：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    contents &lt;- readFile <span class="string">&quot;text.txt&quot;</span></span><br><span class="line">    putStrLn contents</span><br></pre></td></tr></table></figure>

<h4 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h4><p>writeFile简化了写入文件的操作，它的类型：</p>
<p style="text-align: center;">writeFile :: FilePath -> String -> IO ()</p>

<p>传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个IO ()</p>
<h4 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h4><p>appendFile类似writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾</p>
<h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><p>文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。</p>
<p>也可以通过<code>hSetBuffering</code>函数来手动设置缓冲区大小，这个函数的类型：</p>
<p style="text-align: center;">hSetBuffering :: Handle -> BufferMode -> IO ()</p>

<p>它接收一个handle，和一个BufferMode，并返回IO ()。其中BufferMode有以下几种：</p>
<ul>
<li><code>NoBuffering</code>：没有缓冲区，一次读入一个字符</li>
<li><code>LineBuffering</code>：缓冲区大小是一行，即每次读入一行内容</li>
<li><code>BlockBuffering (Maybe Int)</code>：缓冲区大小是一块，块的大小由Maybe Int指定：<ul>
<li><code>BlockBuffering (Nothing)</code>：使用系统默认的块大小</li>
<li><code>BlockBuffering (Just 2048)</code>：一块的大小是2048字节，即每次读入2048bytes的内容</li>
</ul>
</li>
</ul>
<p>缓冲区的刷新是自动的，也可以通过<code>hFlush</code>来手动刷新</p>
<p style="text-align: center;">hFlush :: Handle -> IO ()</p>

<p>传入一个handle，返回IO ()，即刷新对应handle的缓冲区</p>
<h4 id="openTempFile"><a href="#openTempFile" class="headerlink" title="openTempFile"></a>openTempFile</h4><p>openTempFile可以新建一个临时文件：</p>
<p style="text-align: center;">openTempFile :: FilePath -> String -> IO (FilePath, Handle)</p>

<p><code>FilePath</code>指临时文件要创建的位置路径，<code>String</code>指临时文件名字的前缀，返回一个I/O action，其内容第一个<code>FilePath</code>是创建得到的临时文件的路径，<code>Handle</code>是临时文件的handle</p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    (tempFile, tempHandle) &lt;- openTempFile <span class="string">&quot;.&quot;</span> <span class="string">&quot;temp&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    hClose tempHandle</span><br></pre></td></tr></table></figure>
<p><code>&quot;.&quot;</code>指临时文件要在当前目录创建，<code>&quot;temp&quot;</code>指临时文件名字以temp开头。最终得到的tempFile就是./temp…….，temp后为随机数字，如<code>./temp43620-0</code></p>
<h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><p>相关函数都包含在<code>System.Directory</code>模块中，全部内容见<a href="https://hackage.haskell.org/package/directory-1.3.6.2/docs/System-Directory.html">System.Directory</a></p>
<h4 id="getCurrentDirectory"><a href="#getCurrentDirectory" class="headerlink" title="getCurrentDirectory"></a>getCurrentDirectory</h4><p style="text-align: center;">getCurrentDirectory :: IO FilePath</p>

<p>直接返回一个I/O action，其内容是一个字符串表示当前路径的绝对路径</p>
<h4 id="removeFile"><a href="#removeFile" class="headerlink" title="removeFile"></a>removeFile</h4><p style="text-align: center;">removeFile :: FilePath -> IO ()</p>

<p>输入一个文件路径，并删除掉它</p>
<h4 id="renameFile"><a href="#renameFile" class="headerlink" title="renameFile"></a>renameFile</h4><p style="text-align: center;">renameFile :: FilePath -> FilePath -> IO ()</p>

<p>输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名</p>
<h4 id="doesFileExist"><a href="#doesFileExist" class="headerlink" title="doesFileExist"></a>doesFileExist</h4><p style="text-align: center;">doesFileExist :: FilePath -> IO Bool</p>

<p>检查文件是否存在，返回一个包含布尔值的I/O action</p>
<h3 id="Command-line-arguments"><a href="#Command-line-arguments" class="headerlink" title="Command line arguments"></a>Command line arguments</h3><p><code>System.Environment</code>模块中提供了两个函数可以用来处理传入命令行的参数</p>
<h4 id="getArgs"><a href="#getArgs" class="headerlink" title="getArgs"></a>getArgs</h4><p style="text-align: center;">getArgs :: IO [String]</p>

<p>不需要输入参数，直接返回一个I/O action，内容为传入命令行的参数（一个由String组成的列表）。相当于C语言中的argv[1:]</p>
<h4 id="getProgName"><a href="#getProgName" class="headerlink" title="getProgName"></a>getProgName</h4><p style="text-align: center;">getProgName :: IO String</p>

<p>返回I/O action，内容为程序的名字，相当于C语言中的argv[0]</p>
<h3 id="Randomness"><a href="#Randomness" class="headerlink" title="Randomness"></a>Randomness</h3><p>和随机数有关的函数都包含在<code>System.Random</code>模块中。GHCi启动时可能不会包含System.Random的配置，导致无法找到模块。需要通过stack打开:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stack ghci --package random</span><br></pre></td></tr></table></figure>

<p>Haskell要求同样的程序需要运行出同样的结果，除了用到了I/O action，所有会造成不同结果的函数都要交给I/O action来完成</p>
<p>那要使随机数脱离IO存在，就要用到随机生成器（random generator）</p>
<p><code>System.Random</code>模块提供了几个生成随机数的函数：</p>
<h4 id="random"><a href="#random" class="headerlink" title="random"></a>random</h4><p style="text-align: center;">random :: (Random a, RandomGen g) => g -> (a, g)</p>

<p>其中又有两个新的typeclass，Random表示可以取随机，RandomGen表示随机数生成器。random函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器</p>
<p>获取随机数生成器可以使用<code>mkStdGen</code>函数：</p>
<p style="text-align: center;">mkStdGen :: Int -> StdGen</p>

<p>其中<code>StdGen</code>是一个RandomGen的实例</p>
<p>运用random生成随机数需要指定类型，不然程序无法确定<code>a</code>是什么类型。例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Int</span>, <span class="type">StdGen</span>)</span><br><span class="line">(<span class="number">9216477508314497915</span>,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Char</span>, <span class="type">StdGen</span>)</span><br><span class="line">(&#x27;\<span class="number">537310</span>&#x27;,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Bool</span>, <span class="type">StdGen</span>)</span><br><span class="line">(<span class="type">True</span>,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">threeCoins</span> :: <span class="type">StdGen</span> -&gt; (<span class="type">Bool</span>, <span class="type">Bool</span>, <span class="type">Bool</span>)  </span><br><span class="line"><span class="title">threeCoins</span> gen =   </span><br><span class="line">    <span class="keyword">let</span> (firstCoin, newGen) = random gen  </span><br><span class="line">        (secondCoin, newGen&#x27;) = random newGen  </span><br><span class="line">        (thirdCoin, newGen&#x27;&#x27;) = random newGen&#x27;  </span><br><span class="line">    <span class="keyword">in</span>  (firstCoin, secondCoin, thirdCoin) </span><br></pre></td></tr></table></figure>

<h4 id="randoms"><a href="#randoms" class="headerlink" title="randoms"></a>randoms</h4><p style="text-align: center;">randoms :: (Random a, RandomGen g) => g -> [a]</p>

<p>randoms接收一个RandomGen，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器</p>
<h4 id="randomR"><a href="#randomR" class="headerlink" title="randomR"></a>randomR</h4><p style="text-align: center;">randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)</p>

<p>可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围(闭区间)</p>
<h4 id="randomRs"><a href="#randomRs" class="headerlink" title="randomRs"></a>randomRs</h4><p style="text-align: center;">randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]</p>

<p>同上两个，生成有范围的无穷随机数列表</p>
<h4 id="getStdGen"><a href="#getStdGen" class="headerlink" title="getStdGen"></a>getStdGen</h4><p>如果想要让程序每次运行得到不同的随机结果，需要使用<code>getStdGen</code>来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个I/O action，而不是一个直接的StdGen</p>
<p style="text-align: center;">getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen</p>

<p>即可以看成getStdGen :: IO StdGen，需要使用&lt;-操作符将StdGen提取出来</p>
<p>但是在同一个程序中，getStdGen的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数newStdGen</p>
<h4 id="newStdGen"><a href="#newStdGen" class="headerlink" title="newStdGen"></a>newStdGen</h4><p style="text-align: center;">newStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen</p>

<p>执行newStdGen会进行两个操作：</p>
<ul>
<li>更新全局随机数生成器，下次执行getStdGen会获得不同的结果</li>
<li>返回一个I/O action，包含一个新的StdGen（但是这个生成器和全局生成器也不同）</li>
</ul>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>程序在运行失败时会抛出异常，可以通过<code>Control.Exception</code>模块中的<code>catch</code>函数来捕获异常：</p>
<p style="text-align: center;">catch :: Exception e => IO a -> (e -> IO a) -> IO a</p>

<p>第一个参数是要进行的操作，以IO a为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = main&#x27; `catch` handler</span><br><span class="line"></span><br><span class="line"><span class="title">main&#x27;</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main&#x27;</span> = <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="title">handler</span> :: <span class="type">Exception</span> e =&gt; e -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">handler</span> e =  putStrLn <span class="string">&quot;...&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以利用守卫（guard）语法和<code>System.IO.Error</code>中的函数来判断IO异常的类型来进行不同操作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> System.IO.Error</span><br><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = toTry `catch` handler</span><br><span class="line">              </span><br><span class="line"><span class="title">toTry</span> :: <span class="type">IO</span> ()  </span><br><span class="line"><span class="title">toTry</span> = <span class="keyword">do</span> (fileName:_) &lt;- getArgs  </span><br><span class="line">           contents &lt;- readFile fileName  </span><br><span class="line">           putStrLn $ <span class="string">&quot;The file has &quot;</span> ++ show (length (lines contents)) ++ <span class="string">&quot; lines!&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">handler</span> :: <span class="type">IOError</span> -&gt; <span class="type">IO</span> ()  </span><br><span class="line"><span class="title">handler</span> e  </span><br><span class="line">    | isDoesNotExistError e = putStrLn <span class="string">&quot;The file doesn&#x27;t exist!&quot;</span>  </span><br><span class="line">    | otherwise = ioError e  </span><br></pre></td></tr></table></figure>

<p>具体相关全部函数见文档：<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Error.html">System.IO.Error</a>、<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception-Base.html">Control.Exception</a></p>
<h2 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h2><p>函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用<code>fmap</code> :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子</p>
<p>Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子</p>
<p>函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的<code>f a</code>和<code>f b</code>也是因为<code>f</code>是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中</p>
<p>Functor的定义是:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) :: a -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) = fmap . const</span><br></pre></td></tr></table></figure>
<p>可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>
<p>但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名：</p>
<p style="text-align: center;">const :: a -> b -> a</p>

<p>即接收两个参数，但始终只返回第一个参数</p>
<h3 id="Functor实例"><a href="#Functor实例" class="headerlink" title="Functor实例"></a>Functor实例</h3><h4 id><a href="#" class="headerlink" title="[]"></a>[]</h4><p>列表[]是一个函子，它通过map函数来实现fmap的功能：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">    fmap = map</span><br></pre></td></tr></table></figure>
<p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表</p>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe也具有kind * -&gt; *，它也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="Either-a"><a href="#Either-a" class="headerlink" title="Either a"></a>Either a</h4><p>Either的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Left</span> x) = <span class="type">Left</span> x</span><br><span class="line">    fmap f (<span class="type">Right</span> x) = <span class="type">Right</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Left</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Right</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在）</p>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>IO也是一个函子，使用fmap对IO中内容应用函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f action = <span class="keyword">do</span></span><br><span class="line">        result &lt;- action</span><br><span class="line">        return (f result)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (<span class="string">&quot;input: &quot;</span>++) getLine</span><br><span class="line"><span class="title">test</span></span><br><span class="line"><span class="string">&quot;input: test&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="a"><a href="#a" class="headerlink" title="(,) a"></a>(,) a</h4><p>(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,) a) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (x, y) = (x, f y)</span><br></pre></td></tr></table></figure>
<p>只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,) a b) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c) = (a, b, f c)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,,) a b c) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c, d) = (a, b, c, f d)</span><br></pre></td></tr></table></figure>

<h4 id="gt-r"><a href="#gt-r" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>-&gt;也是一个类型构造器，它的kind：</p>
<p style="text-align: center;">(->) :: * -> * -> *</p>

<p>一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中<code>r</code>是输入的类型）</p>
<p>规定的fmap的类型签名是：</p>
<p style="text-align: center;">fmap :: (a -> b) -> f a -> f b</p>

<p>其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b)</p>

<p>把其中的(-&gt;)换成中缀可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> (r -> a) -> (r -> b)</p>

<p>传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。<br>不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap f g = (\x -&gt; f (g x))</span><br></pre></td></tr></table></figure>
<p>所以(-&gt;) r的fmap其实就是函数复合(.)：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap = (.)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t fmap (*<span class="number">3</span>) (+<span class="number">100</span>)  </span><br><span class="line"><span class="title">fmap</span> (*<span class="number">3</span>) (+<span class="number">100</span>) :: (<span class="type">Num</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">3</span>) (+<span class="number">100</span>) <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) `fmap` (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) . (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span></span><br></pre></td></tr></table></figure>

<h3 id="Functor-Laws"><a href="#Functor-Laws" class="headerlink" title="Functor Laws"></a>Functor Laws</h3><p>所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律：</p>
<ol>
<li><code>fmap id = id</code>（其中id为函数<code>(\x -&gt; x)</code>）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap id [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; fmap id (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><code>fmap (f . g) = fmap f . fmap g</code>：即函子的fmap支持结合律<br> fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中<code>a</code>为一个函子<br> fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap ((*<span class="number">3</span>) . (+<span class="number">100</span>)) (<span class="type">Just</span> <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">303</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可</p>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h3><p>对于函子和fmap，有两种理解方法</p>
<ol>
<li>函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器</li>
<li>函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作<p style="text-align: center;">fmap :: (a -> b) -> (f a -> f b)</p>
接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数
<p style="text-align: center;">fmap g :: f a -> f b</p>
使普通的函数g可以在计算上下文<code>f</code>中使用，这种转换也被称为提升（lift）</li>
</ol>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;$&gt;"></a>&lt;$&gt;</h4><p><code>&lt;$&gt;</code>函数是<code>fmap</code>的中缀形式（它看着类似<code>$</code>，<code>f $ 3</code>将f应用在单个值3上，而<code>f &lt;$&gt; [1, 2, 3]</code>将f应用在一个函子上，也就是应用在一个函子内部的所有值上）：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">2</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="gt"><a href="#gt" class="headerlink" title="$&gt;"></a>$&gt;</h4><p><code>$&gt;</code>函数包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">($>) :: Functor f => f a -> b -> f b</p> 

<p>Functor定义时要求了<code>&lt;$</code>函数，将函子内部的元素全部替换为指定的某个值，而<code>$&gt;</code>正好将<code>&lt;$</code>函数的两个参数反了过来，相当于<code>flip (&lt;$)</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] $&gt; &#x27;a&#x27;</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p><code>void</code>函数也包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">void :: Functor f => f a -> f ()</p>

<p>void函数把一个函子内部的全部元素都变成空（<code>()</code>），<code>void x</code>相当于<code>() &lt;$ x</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; void [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[(), (), ()]</span><br><span class="line"><span class="title">ghci</span>&gt; void (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> ()</span><br></pre></td></tr></table></figure>

<h2 id="Applicative-Functor"><a href="#Applicative-Functor" class="headerlink" title="Applicative Functor"></a>Applicative Functor</h2><p>应用函子（Applicative Functor）是函子的升级版，它包含在<code>Control.Applicative</code>模块中。</p>
<p>fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">    pure :: a -&gt; f a</span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>应用函子要求实现两个函数：</p>
<ul>
<li><code>pure</code> :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just</li>
<li><code>&lt;*&gt;</code> :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。</li>
</ul>
<h3 id="Applicative-Functor实例"><a href="#Applicative-Functor实例" class="headerlink" title="Applicative Functor实例"></a>Applicative Functor实例</h3><h4 id="Maybe-1"><a href="#Maybe-1" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = <span class="type">Just</span></span><br><span class="line">    <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">    (<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x</li>
<li><code>&lt;*&gt;</code>函数：将装有函数的函子中的函数应用另一个函子中<ul>
<li>第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing</li>
<li>第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可</li>
</ul>
</li>
</ul>
<p>实际应用的例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">3</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12</p>
<p>第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了</p>
<p>而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>&lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (<span class="type">Just</span> (\y z -&gt; <span class="number">3</span> + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> (\z -&gt; <span class="number">3</span> + <span class="number">4</span> + z) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span> = <span class="type">Just</span> (+<span class="number">7</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。</p>
<p>而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是：</p>
<p style="text-align: center;">f <$> x <*> y <*> ...</*></*></$></p>

<h4 id="-1"><a href="#-1" class="headerlink" title="[]"></a>[]</h4><p>列表也是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">    pure x = [x]</span><br><span class="line">    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x]</li>
<li><code>&lt;*&gt;</code>函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表</li>
</ul>
<p>使用例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">3</span>), (*<span class="number">2</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [(+), (*)]  &lt;*&gt;  [<span class="number">1</span>, <span class="number">2</span>]  &lt;*&gt;  [<span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h4 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = return</span><br><span class="line">    a &lt;*&gt; b = <span class="keyword">do</span></span><br><span class="line">        f &lt;- a</span><br><span class="line">        x &lt;- b</span><br><span class="line">        return (f x)</span><br></pre></td></tr></table></figure>
<p>也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine</span><br><span class="line"><span class="type">Line1</span></span><br><span class="line"><span class="type">Line2</span></span><br><span class="line"><span class="string">&quot;Line1Line2&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="gt-r-1"><a href="#gt-r-1" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名：</p>
<p style="text-align: center;"><*> :: f (a -> b) -> f a -> f b</*></p>

<p>其中f为(-&gt;) r，将其代入并替换为中缀：</p>
<p style="text-align: center;"><*> :: (r -> a -> b) -> (r -> a) -> (r -> b)</*></p>

<p>可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b)</p>
<p>那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是：</p>
<p style="text-align: center;">\x -> f x (g x)</p>

<p>于是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    pure x = (\_ -&gt; x)</span><br><span class="line">    f &lt;*&gt; g = \x -&gt; f x (g x)</span><br></pre></td></tr></table></figure>
<p>将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x</p>
<p>应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line"><span class="number">508</span></span><br></pre></td></tr></table></figure>
<p>执行这句时发生了什么？：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) &lt;$&gt; (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) . (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span> = (\a -&gt; (+) ((+<span class="number">3</span>) a)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\a b -&gt; (a + <span class="number">3</span> + b)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + ((*<span class="number">100</span>) x)) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + x * <span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= <span class="number">5</span> + <span class="number">3</span> + <span class="number">5</span> * <span class="number">100</span> = <span class="number">508</span></span><br><span class="line">= (<span class="number">5</span> + <span class="number">3</span>) + (<span class="number">5</span> * <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+)</p>
<p>同样：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">2</span>) &lt;*&gt; (/<span class="number">2</span>) $ <span class="number">5</span>  </span><br><span class="line">[<span class="number">8.0</span>,<span class="number">10.0</span>,<span class="number">2.5</span>]  </span><br></pre></td></tr></table></figure>
<p>先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\x y z -&gt; [x,y,z])得到了最终的结果</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i</span><br><span class="line">= (\x -&gt; f (g x) (h x) (i x))</span><br></pre></td></tr></table></figure>

<h4 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h4><p>普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在<code>Control.Applicative</code>模块中</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">ZipList</span> <span class="keyword">where</span></span></span><br><span class="line">    pure x = <span class="type">ZipList</span> (repeat x)</span><br><span class="line">    <span class="type">ZipList</span> fs &lt;*&gt; <span class="type">ZipList</span> xs = <span class="type">ZipList</span> (zipWith ($) fs xs)</span><br></pre></td></tr></table></figure>
<p>但是ZipList并不是Show的实例，所以不能直接显示出来，要使用<code>getZipList</code>来获取它内部的列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getZipList $ (+) &lt;$&gt; <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &lt;*&gt; <span class="type">ZipList</span> [<span class="number">100</span>,<span class="number">100.</span>.]  </span><br><span class="line">[<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; getZipList $ (,,) &lt;$&gt; <span class="type">ZipList</span> <span class="string">&quot;dog&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;cat&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;rat&quot;</span>  </span><br><span class="line">[(&#x27;d&#x27;,&#x27;c&#x27;,&#x27;r&#x27;),(&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;),(&#x27;g&#x27;,&#x27;t&#x27;,&#x27;t&#x27;)]  </span><br></pre></td></tr></table></figure>

<h3 id="Applicative-Functor-Laws"><a href="#Applicative-Functor-Laws" class="headerlink" title="Applicative Functor Laws"></a>Applicative Functor Laws</h3><p>应用函子一般有四个定律，都是保证pure的正确性的：</p>
<ol>
<li><code>Identity law</code>：pure id &lt;*&gt; v = v</li>
<li><code>Homomorphism</code>：pure f &lt;*&gt; pure x = pure (f x)</li>
<li><code>Interchange</code>：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u</li>
<li><code>Composition</code>：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w</li>
</ol>
<h3 id="Intuition-1"><a href="#Intuition-1" class="headerlink" title="Intuition"></a>Intuition</h3><p>理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：<br>$$<br>[[\ \ g\ x_1\ x_2\ \cdots\ x_n\ \ ]]<br>$$</p>
<p>其中$x_i$的类型是$f\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是：</p>
<p>$$<br>t_1\to t_2\to\cdots\to t_n\to t<br>$$</p>
<p>所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\ x_1$结果的类型是：</p>
<p>$$<br>f\ \ (t_2\to t_3\to\cdots\to t_n\to t)<br>$$</p>
<p>但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\ g\ x_1\ x_2\ \cdots\ x_n\ ]]$，只需要：</p>
<p style="text-align: center;">g <$> x1 <*> x2 <*> ... <*> xn</*></*></*></$></p>

<p>而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算：</p>
<p style="text-align: center;">g <$> x1 <*> pure x2 <*> ... <*> xn</*></*></*></$></p>

<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="liftA-amp-liftA2-amp-liftA3"><a href="#liftA-amp-liftA2-amp-liftA3" class="headerlink" title="liftA &amp; liftA2 &amp; liftA3"></a>liftA &amp; liftA2 &amp; liftA3</h4><p style="text-align: center;">liftA :: Applicative f => (a -> b) -> f a -> f b</p>
<p style="text-align: center;">liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c</p>
<p style="text-align: center;">liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d</p>

<p>不难推测liftA就是fmap，<code>liftA2 f x1 x2</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2</code>，<code>liftA3 f x1 x2 x3</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3</code></p>
<h4 id="lt-amp-gt"><a href="#lt-amp-gt" class="headerlink" title="&lt;* &amp; *&gt;"></a>&lt;* &amp; *&gt;</h4><p>类型类似函子的<code>&lt;$</code>和<code>$&gt;</code>：</p>
<p style="text-align: center;">(&lt;*) :: Applicative f => f a -> f b -> f a</p>
<p style="text-align: center;">(*>) :: Applicative f => f a -> f b -> f b</p>

<p>&lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> &lt;* <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> *&gt; <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;* <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> *&gt; <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt;* [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] *&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [] &lt;* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; [] *&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h4 id="lt-gt-1"><a href="#lt-gt-1" class="headerlink" title="&lt;**&gt;"></a>&lt;**&gt;</h4><p style="text-align: center;">(**) :: Applicative f => f a -> f (a -> b) -> f b</p>

<p>接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;**&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; flip(&lt;*&gt;) [<span class="number">1</span>, <span class="number">2</span>] [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="when-amp-unless"><a href="#when-amp-unless" class="headerlink" title="when &amp; unless"></a>when &amp; unless</h4><p style="text-align: center;">when :: Applicative f => Bool -> f () -> f ()</p>

<p>传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过）</p>
<p>unless则与when相反，测试为True返回pure ()</p>
<h4 id="sequenceA"><a href="#sequenceA" class="headerlink" title="sequenceA"></a>sequenceA</h4><p style="text-align: center;">sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)</p>

<p>应用在列表上时，它的类型相当于：</p>
<p style="text-align: center;">[f a] -> f [a]</p>

<p>所以在列表上它的使用方法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Just</span> <span class="number">2</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Just</span> [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(+<span class="number">3</span>),(+<span class="number">2</span>),(+<span class="number">1</span>)] <span class="number">3</span>  </span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">6</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>],[]]  </span><br><span class="line">[]  </span><br></pre></td></tr></table></figure>
<p>它在对同一个参数应用不同函数时很有用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (\f -&gt; f <span class="number">7</span>) [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd]  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd] <span class="number">7</span>  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br></pre></td></tr></table></figure>

<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="https://stackoverflow.com/questions/6172004/writing-foldl-using-foldr">Writing foldl using foldr - StackOverflow</a></li>
<li><a href="https://blog.csdn.net/WinterShiver/article/details/103308165">Haskell：用foldr定义foldl</a></li>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Haskell wiki - Typeclassopedia</a></li>
<li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></li>
<li><a href="http://02s949.coding-pages.com/2018/08/15/haskellc/">Haskell学习 - functor</a></li>
</ul>
<p style="text-align: center; font-size: x-large; font-weight: bolder"> 未完待续 </p>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#5 函子与应用函子</title>
    <url>/p/290ecb74.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/a5bbe48a.html">&lt; #4</a></p>
<p>未完待续 &gt;</p>
</div>

<h2 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h2><p>函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用<code>fmap</code> :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子</p>
<span id="more"></span>

<p>Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子</p>
<p>函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的<code>f a</code>和<code>f b</code>也是因为<code>f</code>是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中</p>
<p>Functor的定义是:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) :: a -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) = fmap . const</span><br></pre></td></tr></table></figure>
<p>可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>
<p>但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名：</p>
<p style="text-align: center;">const :: a -> b -> a</p>

<p>即接收两个参数，但始终只返回第一个参数</p>
<h3 id="Functor实例"><a href="#Functor实例" class="headerlink" title="Functor实例"></a>Functor实例</h3><h4 id><a href="#" class="headerlink" title="[]"></a>[]</h4><p>列表[]是一个函子，它通过map函数来实现fmap的功能：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">    fmap = map</span><br></pre></td></tr></table></figure>
<p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表</p>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe也具有kind * -&gt; *，它也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="Either-a"><a href="#Either-a" class="headerlink" title="Either a"></a>Either a</h4><p>Either的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Left</span> x) = <span class="type">Left</span> x</span><br><span class="line">    fmap f (<span class="type">Right</span> x) = <span class="type">Right</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Left</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Right</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在）</p>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>IO也是一个函子，使用fmap对IO中内容应用函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f action = <span class="keyword">do</span></span><br><span class="line">        result &lt;- action</span><br><span class="line">        return (f result)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (<span class="string">&quot;input: &quot;</span>++) getLine</span><br><span class="line"><span class="title">test</span></span><br><span class="line"><span class="string">&quot;input: test&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="a"><a href="#a" class="headerlink" title="(,) a"></a>(,) a</h4><p>(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,) a) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (x, y) = (x, f y)</span><br></pre></td></tr></table></figure>
<p>只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,) a b) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c) = (a, b, f c)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,,) a b c) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c, d) = (a, b, c, f d)</span><br></pre></td></tr></table></figure>

<h4 id="gt-r"><a href="#gt-r" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>-&gt;也是一个类型构造器，它的kind：</p>
<p style="text-align: center;">(->) :: * -> * -> *</p>

<p>一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中<code>r</code>是输入的类型）</p>
<p>规定的fmap的类型签名是：</p>
<p style="text-align: center;">fmap :: (a -> b) -> f a -> f b</p>

<p>其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b)</p>

<p>把其中的(-&gt;)换成中缀可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> (r -> a) -> (r -> b)</p>

<p>传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。<br>不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap f g = (\x -&gt; f (g x))</span><br></pre></td></tr></table></figure>
<p>所以(-&gt;) r的fmap其实就是函数复合(.)：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap = (.)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t fmap (*<span class="number">3</span>) (+<span class="number">100</span>)  </span><br><span class="line"><span class="title">fmap</span> (*<span class="number">3</span>) (+<span class="number">100</span>) :: (<span class="type">Num</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">3</span>) (+<span class="number">100</span>) <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) `fmap` (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) . (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span></span><br></pre></td></tr></table></figure>

<h3 id="Functor-Laws"><a href="#Functor-Laws" class="headerlink" title="Functor Laws"></a>Functor Laws</h3><p>所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律：</p>
<ol>
<li><code>fmap id = id</code>（其中id为函数<code>(\x -&gt; x)</code>）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap id [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; fmap id (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><code>fmap (f . g) = fmap f . fmap g</code>：即函子的fmap支持结合律<br> fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中<code>a</code>为一个函子<br> fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap ((*<span class="number">3</span>) . (+<span class="number">100</span>)) (<span class="type">Just</span> <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">303</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可</p>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h3><p>对于函子和fmap，有两种理解方法</p>
<ol>
<li>函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器</li>
<li>函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作<p style="text-align: center;">fmap :: (a -> b) -> (f a -> f b)</p>
接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数
<p style="text-align: center;">fmap g :: f a -> f b</p>
使普通的函数g可以在计算上下文<code>f</code>中使用，这种转换也被称为提升（lift）</li>
</ol>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;$&gt;"></a>&lt;$&gt;</h4><p><code>&lt;$&gt;</code>函数是<code>fmap</code>的中缀形式（它看着类似<code>$</code>，<code>f $ 3</code>将f应用在单个值3上，而<code>f &lt;$&gt; [1, 2, 3]</code>将f应用在一个函子上，也就是应用在一个函子内部的所有值上）：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">2</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="gt"><a href="#gt" class="headerlink" title="$&gt;"></a>$&gt;</h4><p><code>$&gt;</code>函数包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">($>) :: Functor f => f a -> b -> f b</p> 

<p>Functor定义时要求了<code>&lt;$</code>函数，将函子内部的元素全部替换为指定的某个值，而<code>$&gt;</code>正好将<code>&lt;$</code>函数的两个参数反了过来，相当于<code>flip (&lt;$)</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] $&gt; &#x27;a&#x27;</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p><code>void</code>函数也包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">void :: Functor f => f a -> f ()</p>

<p>void函数把一个函子内部的全部元素都变成空（<code>()</code>），<code>void x</code>相当于<code>() &lt;$ x</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; void [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[(), (), ()]</span><br><span class="line"><span class="title">ghci</span>&gt; void (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> ()</span><br></pre></td></tr></table></figure>

<h2 id="Applicative-Functor"><a href="#Applicative-Functor" class="headerlink" title="Applicative Functor"></a>Applicative Functor</h2><p>应用函子（Applicative Functor）是函子的升级版，它包含在<code>Control.Applicative</code>模块中。</p>
<p>fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">    pure :: a -&gt; f a</span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>应用函子要求实现两个函数：</p>
<ul>
<li><code>pure</code> :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just</li>
<li><code>&lt;*&gt;</code> :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。</li>
</ul>
<h3 id="Applicative-Functor实例"><a href="#Applicative-Functor实例" class="headerlink" title="Applicative Functor实例"></a>Applicative Functor实例</h3><h4 id="Maybe-1"><a href="#Maybe-1" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = <span class="type">Just</span></span><br><span class="line">    <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">    (<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x</li>
<li><code>&lt;*&gt;</code>函数：将装有函数的函子中的函数应用另一个函子中<ul>
<li>第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing</li>
<li>第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可</li>
</ul>
</li>
</ul>
<p>实际应用的例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">3</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12</p>
<p>第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了</p>
<p>而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>&lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (<span class="type">Just</span> (\y z -&gt; <span class="number">3</span> + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> (\z -&gt; <span class="number">3</span> + <span class="number">4</span> + z) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span> = <span class="type">Just</span> (+<span class="number">7</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。</p>
<p>而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是：</p>
<p style="text-align: center;">f <$> x <*> y <*> ...</*></*></$></p>

<h4 id="-1"><a href="#-1" class="headerlink" title="[]"></a>[]</h4><p>列表也是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">    pure x = [x]</span><br><span class="line">    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x]</li>
<li><code>&lt;*&gt;</code>函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表</li>
</ul>
<p>使用例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">3</span>), (*<span class="number">2</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [(+), (*)]  &lt;*&gt;  [<span class="number">1</span>, <span class="number">2</span>]  &lt;*&gt;  [<span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h4 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = return</span><br><span class="line">    a &lt;*&gt; b = <span class="keyword">do</span></span><br><span class="line">        f &lt;- a</span><br><span class="line">        x &lt;- b</span><br><span class="line">        return (f x)</span><br></pre></td></tr></table></figure>
<p>也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine</span><br><span class="line"><span class="type">Line1</span></span><br><span class="line"><span class="type">Line2</span></span><br><span class="line"><span class="string">&quot;Line1Line2&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="gt-r-1"><a href="#gt-r-1" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名：</p>
<p style="text-align: center;"><*> :: f (a -> b) -> f a -> f b</*></p>

<p>其中f为(-&gt;) r，将其代入并替换为中缀：</p>
<p style="text-align: center;"><*> :: (r -> a -> b) -> (r -> a) -> (r -> b)</*></p>

<p>可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b)</p>
<p>那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是：</p>
<p style="text-align: center;">\x -> f x (g x)</p>

<p>于是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    pure x = (\_ -&gt; x)</span><br><span class="line">    f &lt;*&gt; g = \x -&gt; f x (g x)</span><br></pre></td></tr></table></figure>
<p>将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x</p>
<p>应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line"><span class="number">508</span></span><br></pre></td></tr></table></figure>
<p>执行这句时发生了什么？：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) &lt;$&gt; (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) . (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span> = (\a -&gt; (+) ((+<span class="number">3</span>) a)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\a b -&gt; (a + <span class="number">3</span> + b)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + ((*<span class="number">100</span>) x)) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + x * <span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= <span class="number">5</span> + <span class="number">3</span> + <span class="number">5</span> * <span class="number">100</span> = <span class="number">508</span></span><br><span class="line">= (<span class="number">5</span> + <span class="number">3</span>) + (<span class="number">5</span> * <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+)</p>
<p>同样：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">2</span>) &lt;*&gt; (/<span class="number">2</span>) $ <span class="number">5</span>  </span><br><span class="line">[<span class="number">8.0</span>,<span class="number">10.0</span>,<span class="number">2.5</span>]  </span><br></pre></td></tr></table></figure>
<p>先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\x y z -&gt; [x,y,z])得到了最终的结果</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i</span><br><span class="line">= (\x -&gt; f (g x) (h x) (i x))</span><br></pre></td></tr></table></figure>

<h4 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h4><p>普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在<code>Control.Applicative</code>模块中</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">ZipList</span> <span class="keyword">where</span></span></span><br><span class="line">    pure x = <span class="type">ZipList</span> (repeat x)</span><br><span class="line">    <span class="type">ZipList</span> fs &lt;*&gt; <span class="type">ZipList</span> xs = <span class="type">ZipList</span> (zipWith ($) fs xs)</span><br></pre></td></tr></table></figure>
<p>但是ZipList并不是Show的实例，所以不能直接显示出来，要使用<code>getZipList</code>来获取它内部的列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getZipList $ (+) &lt;$&gt; <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &lt;*&gt; <span class="type">ZipList</span> [<span class="number">100</span>,<span class="number">100.</span>.]  </span><br><span class="line">[<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; getZipList $ (,,) &lt;$&gt; <span class="type">ZipList</span> <span class="string">&quot;dog&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;cat&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;rat&quot;</span>  </span><br><span class="line">[(&#x27;d&#x27;,&#x27;c&#x27;,&#x27;r&#x27;),(&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;),(&#x27;g&#x27;,&#x27;t&#x27;,&#x27;t&#x27;)]  </span><br></pre></td></tr></table></figure>

<h3 id="Applicative-Functor-Laws"><a href="#Applicative-Functor-Laws" class="headerlink" title="Applicative Functor Laws"></a>Applicative Functor Laws</h3><p>应用函子一般有四个定律，都是保证pure的正确性的：</p>
<ol>
<li><code>Identity law</code>：pure id &lt;*&gt; v = v</li>
<li><code>Homomorphism</code>：pure f &lt;*&gt; pure x = pure (f x)</li>
<li><code>Interchange</code>：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u</li>
<li><code>Composition</code>：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w</li>
</ol>
<h3 id="Intuition-1"><a href="#Intuition-1" class="headerlink" title="Intuition"></a>Intuition</h3><p>理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：<br>$$<br>[[\ \ g\ x_1\ x_2\ \cdots\ x_n\ \ ]]<br>$$</p>
<p>其中$x_i$的类型是$f\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是：</p>
<p>$$<br>t_1\to t_2\to\cdots\to t_n\to t<br>$$</p>
<p>所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\ x_1$结果的类型是：</p>
<p>$$<br>f\ \ (t_2\to t_3\to\cdots\to t_n\to t)<br>$$</p>
<p>但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\ g\ x_1\ x_2\ \cdots\ x_n\ ]]$，只需要：</p>
<p style="text-align: center;">g <$> x1 <*> x2 <*> ... <*> xn</*></*></*></$></p>

<p>而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算：</p>
<p style="text-align: center;">g <$> x1 <*> pure x2 <*> ... <*> xn</*></*></*></$></p>

<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="liftA-amp-liftA2-amp-liftA3"><a href="#liftA-amp-liftA2-amp-liftA3" class="headerlink" title="liftA &amp; liftA2 &amp; liftA3"></a>liftA &amp; liftA2 &amp; liftA3</h4><p style="text-align: center;">liftA :: Applicative f => (a -> b) -> f a -> f b</p>
<p style="text-align: center;">liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c</p>
<p style="text-align: center;">liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d</p>

<p>不难推测liftA就是fmap，<code>liftA2 f x1 x2</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2</code>，<code>liftA3 f x1 x2 x3</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3</code></p>
<h4 id="lt-amp-gt"><a href="#lt-amp-gt" class="headerlink" title="&lt;* &amp; *&gt;"></a>&lt;* &amp; *&gt;</h4><p>类型类似函子的<code>&lt;$</code>和<code>$&gt;</code>：</p>
<p style="text-align: center;">(&lt;*) :: Applicative f => f a -> f b -> f a</p>
<p style="text-align: center;">(*>) :: Applicative f => f a -> f b -> f b</p>

<p>&lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> &lt;* <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> *&gt; <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;* <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> *&gt; <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt;* [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] *&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [] &lt;* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; [] *&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h4 id="lt-gt-1"><a href="#lt-gt-1" class="headerlink" title="&lt;**&gt;"></a>&lt;**&gt;</h4><p style="text-align: center;">(**) :: Applicative f => f a -> f (a -> b) -> f b</p>

<p>接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;**&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; flip(&lt;*&gt;) [<span class="number">1</span>, <span class="number">2</span>] [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="when-amp-unless"><a href="#when-amp-unless" class="headerlink" title="when &amp; unless"></a>when &amp; unless</h4><p style="text-align: center;">when :: Applicative f => Bool -> f () -> f ()</p>

<p>传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过）</p>
<p>unless则与when相反，测试为True返回pure ()</p>
<h4 id="sequenceA"><a href="#sequenceA" class="headerlink" title="sequenceA"></a>sequenceA</h4><p style="text-align: center;">sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)</p>

<p>应用在列表上时，它的类型相当于：</p>
<p style="text-align: center;">[f a] -> f [a]</p>

<p>所以在列表上它的使用方法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Just</span> <span class="number">2</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Just</span> [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(+<span class="number">3</span>),(+<span class="number">2</span>),(+<span class="number">1</span>)] <span class="number">3</span>  </span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">6</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>],[]]  </span><br><span class="line">[]  </span><br></pre></td></tr></table></figure>
<p>它在对同一个参数应用不同函数时很有用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (\f -&gt; f <span class="number">7</span>) [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd]  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd] <span class="number">7</span>  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Haskell wiki - Typeclassopedia</a></li>
<li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></li>
<li><a href="http://02s949.coding-pages.com/2018/08/15/haskellc/">Haskell学习 - functor</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a><br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a><br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a><br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子与应用函子</a></p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#4 输入输出与文件</title>
    <url>/p/a5bbe48a.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/369b7e08.html">&lt; #3</a></p>
<p><a href="/p/290ecb74.html">#5 &gt;</a></p>
</div>

<h2 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h2><h3 id="运行Haskell程序"><a href="#运行Haskell程序" class="headerlink" title="运行Haskell程序"></a>运行Haskell程序</h3><p>不在GHCi中运行一个Haskell程序有两种方式：</p>
<span id="more"></span>
<ol>
<li>编译运行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ghc --make code</span><br><span class="line">$ ./code</span><br></pre></td></tr></table></figure></li>
<li>通过<code>runhaskell</code>命令直接运行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ runhaskell code.hs</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="输出文本"><a href="#输出文本" class="headerlink" title="输出文本"></a>输出文本</h3><p>在一个Haskell程序中输出文字需要定义一个main函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中putStrLn的类型是：</p>
<p style="text-align: center;">putStrLn :: String -> IO ()</p>

<p>putStrLn接收一个String类型，并返回一个结果为()类型的IO动作（I/O action）。所以main函数的类型为IO ()。（IO的Kind是* -&gt; *）</p>
<p>除此之外，还有其他默认提供的输出文本的函数：</p>
<ul>
<li><code>putStr</code>：输出文本，结尾不换行</li>
<li><code>putChar</code>：输出单个字符，结尾不换行。接收的参数为单个Char，不是String（用单引号不是双引号）</li>
<li><code>print</code>：可以接收任何Show的成员，先用show转化为字符串然后输出。等同于putStrLn . show</li>
</ul>
<h4 id="do-block"><a href="#do-block" class="headerlink" title="do block"></a>do block</h4><p>在main函数中使用多个putStrLn需要使用do语句：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    putStrLn <span class="string">&quot;Line1&quot;</span></span><br><span class="line">    putStrLn <span class="string">&quot;Line2&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中最后一行一定要返回IO ()类型的值</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>输入文字需要在do块中使用getLine：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    line &lt;- getLine</span><br><span class="line">    putStrLn line</span><br></pre></td></tr></table></figure>
<p>getLine的类型是：</p>
<p style="text-align: center;">getLine :: IO String</p>

<p>而&lt;-操作符将getLine中的String提取了出来给到了line，使line变成了String类型的一个字符串。</p>
<p>而且使用输入的字符串必须要经过一次&lt;-，不能直接使用getLine作为字符串，因为getLine不是String类型，而是IO String类型。</p>
<p>除此之外，还可以使用getChar来获取单个字符，但仍然需要使用&lt;-操作符来提取Char</p>
<h3 id="其他IO相关函数用法"><a href="#其他IO相关函数用法" class="headerlink" title="其他IO相关函数用法"></a>其他IO相关函数用法</h3><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>Haskell中的return和其他命令式语言中的return完全不同，它不会使函数直接结束并返回一个值。</p>
<p>main函数必须定义为类型为IO ()的函数，所以在main函数中使用if语句，如果不输出的话也不可以直接放下什么都不干，因为这时候main函数的类型不是IO ()。所以这时需要使用return ()来为main函数指定为IO ()类型，例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    line &lt;- getLine</span><br><span class="line">    <span class="keyword">if</span> null line</span><br><span class="line">        <span class="keyword">then</span> return () <span class="comment">-- &lt;-这里</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">do</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>使用&lt;-操作符也可以直接将return语句中的内容提取出来，比如a &lt;- return ‘A’，执行后a就是’A’。</p>
<h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p>when包含在<code>Control.Monad</code>模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会return ()。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad   </span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    when (c /= &#x27; &#x27;) $ <span class="keyword">do</span>  </span><br><span class="line">        putChar c  </span><br><span class="line">        main  </span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span>     </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    <span class="keyword">if</span> c /= &#x27; &#x27;  </span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">do</span>  </span><br><span class="line">            putChar c  </span><br><span class="line">            main  </span><br><span class="line">        <span class="keyword">else</span> return () </span><br></pre></td></tr></table></figure>

<h4 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h4><p>sequence在IO中使用时可以达成[IO a] -&gt; IO [a]的效果，所以可以用作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[a, b, c] &lt;- sequence [getLine, getLine, getLine]</span><br></pre></td></tr></table></figure>

<h4 id="mapM-amp-mapM"><a href="#mapM-amp-mapM" class="headerlink" title="mapM &amp; mapM_"></a>mapM &amp; mapM_</h4><p>在IO相关的地方使用map，可以使用mapM和mapM_，其中mapM有返回值而mapM_直接扔掉了返回值：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mapM print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line">[(),(),()]  </span><br><span class="line"><span class="title">ghci</span>&gt; mapM_ print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br></pre></td></tr></table></figure>

<h4 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h4><p>forever函数包含在<code>Control.Monad</code>模块中。在main函数开头加上forever函数可以使后面的do块一直重复执行直到程序被迫终止，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = forever $ <span class="keyword">do</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h4 id="forM"><a href="#forM" class="headerlink" title="forM"></a>forM</h4><p>forM函数包含在<code>Control.Monad</code>模块中，它的功能和mapM类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回IO a类型。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    colors &lt;- forM [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] (\a -&gt; <span class="keyword">do</span></span><br><span class="line">        putStrLn $ <span class="string">&quot;Which color do you associate with the number &quot;</span> ++ show a ++ <span class="string">&quot;?&quot;</span>  </span><br><span class="line">        color &lt;- getLine  </span><br><span class="line">        return color)</span><br><span class="line">    putStrLn <span class="string">&quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;</span>  </span><br><span class="line">    mapM putStrLn colors</span><br></pre></td></tr></table></figure>

<h4 id="getContents"><a href="#getContents" class="headerlink" title="getContents"></a>getContents</h4><p>getLine获取一整行，而getContents从标准输入中获取全部内容直到遇到EOF，并且它是lazy的，在执行了foo &lt;- getContents后，它并不会读取标准输入并且赋值到foo，而是等到需要使用foo的时候再从标准输入读取。</p>
<p>getContents在使用管道传入文字时很常用，可以代替forever+getLine使用，比如一个Haskell程序文件code.hs：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Char  </span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    contents &lt;- getContents  </span><br><span class="line">    putStr (map toUpper contents)  </span><br></pre></td></tr></table></figure>
<p>使用ghc –make code编译后，通过管道传入文字：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat text.txt | ./code</span><br></pre></td></tr></table></figure>
<p>会将text.txt中的所有字母转为大写并输出</p>
<h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>上述功能还可以转化为一个String -&gt; String的函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">upperStrings</span> = unlines . map (map toUpper) . lines</span><br></pre></td></tr></table></figure>
<p>而在main中使用这个函数就需要：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    contents &lt;- getContents</span><br><span class="line">    putStr (upperStrings contents)</span><br></pre></td></tr></table></figure>
<p>但是String -&gt; String类型的函数在输入输出中的使用太常见了，所以可以使用interact函数来简化。interact的类型是：</p>
<p style="text-align: center;">interact :: (String -> String) -> IO ()</p>

<p>可以看出它接收一个String -&gt; String的函数，并返回一个IO ()类型，所以可以直接用在main上。</p>
<p>于是整个转换为大写的程序就可以简化为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = interact $ unlines . map (map toUpper) . lines</span><br></pre></td></tr></table></figure>

<h2 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h2><p>以下与文件和流相关的函数都包含在<code>System.IO</code>模块中</p>
<h3 id="openFile"><a href="#openFile" class="headerlink" title="openFile"></a>openFile</h3><p>openFile函数可以用来打开一个文件，它的类型是：</p>
<p style="text-align: center;">openFile :: FilePath -> IOMode -> IO Handle</p>

<p>其中<code>FilePath</code>是String的type synonyms，用一个字符串来表示需要打开的文件的路径</p>
<p><code>IOMode</code>的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IOMode</span> = <span class="type">ReadMode</span> | <span class="type">WriteMode</span> | <span class="type">AppendMode</span> | <span class="type">ReadWriteMode</span></span></span><br></pre></td></tr></table></figure>
<p>所以它一共只有四个值，用来表示进行IO操作的模式</p>
<p>openFile返回一个IO Handle类型的值，将其用&lt;-操作符提取后会出现一个Handle的值。但不能从Handle中直接使用文字，还需要使用一系列函数：</p>
<ul>
<li><code>hGetContents</code> :: Handle -&gt; IO String ，从Handle中读取全部内容，返回一个IO String</li>
<li><code>hGetChar</code> :: Handle -&gt; IO Char ，从Handle中读取一个字符</li>
<li><code>hGetLine</code> :: Handle -&gt; IO String ，从Handle中读取一行，返回一个IO String</li>
<li><code>hPutStr</code> :: Handle -&gt; String -&gt; IO () ，向Handle中输出字符串</li>
<li><code>hPutStrLn</code> :: Handle -&gt; String -&gt; IO () ，同上</li>
</ul>
<p>在使用openFile进行文件操作后，需要使用hClose手动关闭Handle。hClose :: Handle -&gt; IO ()，接收一个Handle并返回IO ()，可以直接放在main函数末尾</p>
<p>所以使用openFile读取一个文件中的全部内容并输出的全部代码是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    handle &lt;- openFile <span class="string">&quot;text.txt&quot;</span> <span class="type">ReadMode</span></span><br><span class="line">    contents &lt;- hGetContents handle</span><br><span class="line">    putStrLn contents</span><br><span class="line">    hClose handle</span><br></pre></td></tr></table></figure>

<h3 id="withFile"><a href="#withFile" class="headerlink" title="withFile"></a>withFile</h3><p>withFile类似Python中的with open，它在读取文件使用之后不需要手动close文件。它的类型是：</p>
<p style="text-align: center;">withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a</p>

<p>可以看出，它接收三个参数：</p>
<ul>
<li><code>FilePath</code>：一个表示文件路径的String</li>
<li><code>IOMode</code>：打开文件的模式</li>
<li><code>(Handle -&gt; IO a)</code>：一个函数，表示对读取文件后的Handle索要进行的操作，需要返回一个I/O action；而这个返回值也将作为withFile的返回值</li>
</ul>
<p>现在使用withFile来改写上述代码：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = withFile <span class="string">&quot;text.txt&quot;</span> <span class="type">ReadMode</span> (\handle -&gt; <span class="keyword">do</span></span><br><span class="line">    contents &lt;- hGetContents handle</span><br><span class="line">    putStrLn contents)</span><br></pre></td></tr></table></figure>

<p>withFile的功能相当于以下函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">withFile&#x27;</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IOMode</span> -&gt; (<span class="type">Handle</span> -&gt; <span class="type">IO</span> a) -&gt; <span class="type">IO</span> a  </span><br><span class="line"><span class="title">withFile&#x27;</span> path mode f = <span class="keyword">do</span>  </span><br><span class="line">    handle &lt;- openFile path mode   </span><br><span class="line">    result &lt;- f handle  </span><br><span class="line">    hClose handle  </span><br><span class="line">    return result  </span><br></pre></td></tr></table></figure>

<h3 id="readFile"><a href="#readFile" class="headerlink" title="readFile"></a>readFile</h3><p>readFile可以更加简化读取文件内容的操作，它的类型：</p>
<p style="text-align: center;">readFile :: FilePath -> IO String</p>

<p>它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的I/O action：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    contents &lt;- readFile <span class="string">&quot;text.txt&quot;</span></span><br><span class="line">    putStrLn contents</span><br></pre></td></tr></table></figure>

<h3 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h3><p>writeFile简化了写入文件的操作，它的类型：</p>
<p style="text-align: center;">writeFile :: FilePath -> String -> IO ()</p>

<p>传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个IO ()</p>
<h3 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h3><p>appendFile类似writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾</p>
<h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。</p>
<p>也可以通过<code>hSetBuffering</code>函数来手动设置缓冲区大小，这个函数的类型：</p>
<p style="text-align: center;">hSetBuffering :: Handle -> BufferMode -> IO ()</p>

<p>它接收一个handle，和一个BufferMode，并返回IO ()。其中BufferMode有以下几种：</p>
<ul>
<li><code>NoBuffering</code>：没有缓冲区，一次读入一个字符</li>
<li><code>LineBuffering</code>：缓冲区大小是一行，即每次读入一行内容</li>
<li><code>BlockBuffering (Maybe Int)</code>：缓冲区大小是一块，块的大小由Maybe Int指定：<ul>
<li><code>BlockBuffering (Nothing)</code>：使用系统默认的块大小</li>
<li><code>BlockBuffering (Just 2048)</code>：一块的大小是2048字节，即每次读入2048bytes的内容</li>
</ul>
</li>
</ul>
<p>缓冲区的刷新是自动的，也可以通过<code>hFlush</code>来手动刷新</p>
<p style="text-align: center;">hFlush :: Handle -> IO ()</p>

<p>传入一个handle，返回IO ()，即刷新对应handle的缓冲区</p>
<h3 id="openTempFile"><a href="#openTempFile" class="headerlink" title="openTempFile"></a>openTempFile</h3><p>openTempFile可以新建一个临时文件：</p>
<p style="text-align: center;">openTempFile :: FilePath -> String -> IO (FilePath, Handle)</p>

<p><code>FilePath</code>指临时文件要创建的位置路径，<code>String</code>指临时文件名字的前缀，返回一个I/O action，其内容第一个<code>FilePath</code>是创建得到的临时文件的路径，<code>Handle</code>是临时文件的handle</p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    (tempFile, tempHandle) &lt;- openTempFile <span class="string">&quot;.&quot;</span> <span class="string">&quot;temp&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    hClose tempHandle</span><br></pre></td></tr></table></figure>
<p><code>&quot;.&quot;</code>指临时文件要在当前目录创建，<code>&quot;temp&quot;</code>指临时文件名字以temp开头。最终得到的tempFile就是./temp…….，temp后为随机数字，如<code>./temp43620-0</code></p>
<h2 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h2><p>相关函数都包含在<code>System.Directory</code>模块中，全部内容见<a href="https://hackage.haskell.org/package/directory-1.3.6.2/docs/System-Directory.html">System.Directory</a></p>
<h3 id="getCurrentDirectory"><a href="#getCurrentDirectory" class="headerlink" title="getCurrentDirectory"></a>getCurrentDirectory</h3><p style="text-align: center;">getCurrentDirectory :: IO FilePath</p>

<p>直接返回一个I/O action，其内容是一个字符串表示当前路径的绝对路径</p>
<h3 id="removeFile"><a href="#removeFile" class="headerlink" title="removeFile"></a>removeFile</h3><p style="text-align: center;">removeFile :: FilePath -> IO ()</p>

<p>输入一个文件路径，并删除掉它</p>
<h3 id="renameFile"><a href="#renameFile" class="headerlink" title="renameFile"></a>renameFile</h3><p style="text-align: center;">renameFile :: FilePath -> FilePath -> IO ()</p>

<p>输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名</p>
<h3 id="doesFileExist"><a href="#doesFileExist" class="headerlink" title="doesFileExist"></a>doesFileExist</h3><p style="text-align: center;">doesFileExist :: FilePath -> IO Bool</p>

<p>检查文件是否存在，返回一个包含布尔值的I/O action</p>
<h2 id="Command-line-arguments"><a href="#Command-line-arguments" class="headerlink" title="Command line arguments"></a>Command line arguments</h2><p><code>System.Environment</code>模块中提供了两个函数可以用来处理传入命令行的参数</p>
<h3 id="getArgs"><a href="#getArgs" class="headerlink" title="getArgs"></a>getArgs</h3><p style="text-align: center;">getArgs :: IO [String]</p>

<p>不需要输入参数，直接返回一个I/O action，内容为传入命令行的参数（一个由String组成的列表）。相当于C语言中的argv[1:]</p>
<h3 id="getProgName"><a href="#getProgName" class="headerlink" title="getProgName"></a>getProgName</h3><p style="text-align: center;">getProgName :: IO String</p>

<p>返回I/O action，内容为程序的名字，相当于C语言中的argv[0]</p>
<h2 id="Randomness"><a href="#Randomness" class="headerlink" title="Randomness"></a>Randomness</h2><p>和随机数有关的函数都包含在<code>System.Random</code>模块中。GHCi启动时可能不会包含System.Random的配置，导致无法找到模块。需要通过stack打开:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stack ghci --package random</span><br></pre></td></tr></table></figure>

<p>Haskell要求同样的程序需要运行出同样的结果，除了用到了I/O action，所有会造成不同结果的函数都要交给I/O action来完成</p>
<p>那要使随机数脱离IO存在，就要用到随机生成器（random generator）</p>
<p><code>System.Random</code>模块提供了几个生成随机数的函数：</p>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p style="text-align: center;">random :: (Random a, RandomGen g) => g -> (a, g)</p>

<p>其中又有两个新的typeclass，Random表示可以取随机，RandomGen表示随机数生成器。random函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器</p>
<p>获取随机数生成器可以使用<code>mkStdGen</code>函数：</p>
<p style="text-align: center;">mkStdGen :: Int -> StdGen</p>

<p>其中<code>StdGen</code>是一个RandomGen的实例</p>
<p>运用random生成随机数需要指定类型，不然程序无法确定<code>a</code>是什么类型。例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Int</span>, <span class="type">StdGen</span>)</span><br><span class="line">(<span class="number">9216477508314497915</span>,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Char</span>, <span class="type">StdGen</span>)</span><br><span class="line">(&#x27;\<span class="number">537310</span>&#x27;,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Bool</span>, <span class="type">StdGen</span>)</span><br><span class="line">(<span class="type">True</span>,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">threeCoins</span> :: <span class="type">StdGen</span> -&gt; (<span class="type">Bool</span>, <span class="type">Bool</span>, <span class="type">Bool</span>)  </span><br><span class="line"><span class="title">threeCoins</span> gen =   </span><br><span class="line">    <span class="keyword">let</span> (firstCoin, newGen) = random gen  </span><br><span class="line">        (secondCoin, newGen&#x27;) = random newGen  </span><br><span class="line">        (thirdCoin, newGen&#x27;&#x27;) = random newGen&#x27;  </span><br><span class="line">    <span class="keyword">in</span>  (firstCoin, secondCoin, thirdCoin) </span><br></pre></td></tr></table></figure>

<h3 id="randoms"><a href="#randoms" class="headerlink" title="randoms"></a>randoms</h3><p style="text-align: center;">randoms :: (Random a, RandomGen g) => g -> [a]</p>

<p>randoms接收一个RandomGen，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器</p>
<h3 id="randomR"><a href="#randomR" class="headerlink" title="randomR"></a>randomR</h3><p style="text-align: center;">randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)</p>

<p>可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围(闭区间)</p>
<h3 id="randomRs"><a href="#randomRs" class="headerlink" title="randomRs"></a>randomRs</h3><p style="text-align: center;">randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]</p>

<p>同上两个，生成有范围的无穷随机数列表</p>
<h3 id="getStdGen"><a href="#getStdGen" class="headerlink" title="getStdGen"></a>getStdGen</h3><p>如果想要让程序每次运行得到不同的随机结果，需要使用<code>getStdGen</code>来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个I/O action，而不是一个直接的StdGen</p>
<p style="text-align: center;">getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen</p>

<p>即可以看成getStdGen :: IO StdGen，需要使用&lt;-操作符将StdGen提取出来</p>
<p>但是在同一个程序中，getStdGen的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数newStdGen</p>
<h3 id="newStdGen"><a href="#newStdGen" class="headerlink" title="newStdGen"></a>newStdGen</h3><p style="text-align: center;">newStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen</p>

<p>执行newStdGen会进行两个操作：</p>
<ul>
<li>更新全局随机数生成器，下次执行getStdGen会获得不同的结果</li>
<li>返回一个I/O action，包含一个新的StdGen（但是这个生成器和全局生成器也不同）</li>
</ul>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>程序在运行失败时会抛出异常，可以通过<code>Control.Exception</code>模块中的<code>catch</code>函数来捕获异常：</p>
<p style="text-align: center;">catch :: Exception e => IO a -> (e -> IO a) -> IO a</p>

<p>第一个参数是要进行的操作，以IO a为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = main&#x27; `catch` handler</span><br><span class="line"></span><br><span class="line"><span class="title">main&#x27;</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main&#x27;</span> = <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="title">handler</span> :: <span class="type">Exception</span> e =&gt; e -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">handler</span> e =  putStrLn <span class="string">&quot;...&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以利用守卫（guard）语法和<code>System.IO.Error</code>中的函数来判断IO异常的类型来进行不同操作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> System.IO.Error</span><br><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = toTry `catch` handler</span><br><span class="line">              </span><br><span class="line"><span class="title">toTry</span> :: <span class="type">IO</span> ()  </span><br><span class="line"><span class="title">toTry</span> = <span class="keyword">do</span> (fileName:_) &lt;- getArgs  </span><br><span class="line">           contents &lt;- readFile fileName  </span><br><span class="line">           putStrLn $ <span class="string">&quot;The file has &quot;</span> ++ show (length (lines contents)) ++ <span class="string">&quot; lines!&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">handler</span> :: <span class="type">IOError</span> -&gt; <span class="type">IO</span> ()  </span><br><span class="line"><span class="title">handler</span> e  </span><br><span class="line">    | isDoesNotExistError e = putStrLn <span class="string">&quot;The file doesn&#x27;t exist!&quot;</span>  </span><br><span class="line">    | otherwise = ioError e  </span><br></pre></td></tr></table></figure>

<p>具体相关全部函数见文档：<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Error.html">System.IO.Error</a>、<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception-Base.html">Control.Exception</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a><br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a><br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a><br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子与应用函子</a></p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#3 类型与类型类</title>
    <url>/p/369b7e08.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/53e482b7.html">&lt; #2</a></p>
<p><a href="/p/a5bbe48a.html">#4 &gt;</a></p>
</div>

<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>Haskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。<br>Type的首字母全为大写，常用的有：</p>
<ul>
<li><code>Int</code>：整型，有上下界范围，-2147483647～2147483648<span id="more"></span></li>
<li><code>Integer</code>：整数，无界，但是效率比Int低</li>
<li><code>Float</code>：单精度浮点型</li>
<li><code>Double</code>：双精度浮点型</li>
<li><code>Bool</code>：布尔值</li>
<li><code>Char</code>：字符</li>
<li><code>String</code>：字符串，等同于<code>[Char]</code></li>
<li><code>Ording</code>：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT</li>
</ul>
<p>列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加<code>[]</code>。</p>
<p>元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。</p>
<h2 id="Typeclasses"><a href="#Typeclasses" class="headerlink" title="Typeclasses"></a>Typeclasses</h2><p>类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个Typeclass<br>Typeclass的首字母也全为大写，常见的有：</p>
<ul>
<li><code>Eq</code>：可判断是否相等</li>
<li><code>Ord</code>：可比较大小</li>
<li><code>Show</code>：可展示成字符串</li>
<li><code>Read</code>：可从字符串转换成特定类型</li>
<li><code>Enum</code>：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀</li>
<li><code>Bounded</code>: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded</li>
<li><code>Integral</code>：是整数，包括Int和Integer</li>
<li><code>RealFloat</code>： 是实浮点数，包括Float和Double</li>
<li><code>RealFrac</code>：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中）</li>
<li><code>Floating</code>：是浮点数，包括Float、Double和Complex（在Data.Complex模块中）</li>
<li><code>Real</code>：是实数，包括Integral和RealFrac的成员</li>
<li><code>Fractional</code>：是分数，包括RealFrac和Floating的成员</li>
<li><code>Num</code>：是数字，包括上述所有数字相关的类型</li>
</ul>
<h2 id="Type-variables"><a href="#Type-variables" class="headerlink" title="Type variables"></a>Type variables</h2><p>如果查看一个函数的类型，比如<code>head</code>，那么将会返回以下类型：</p>
<p style="text-align: center;">head :: [a] -> a</p>

<p>其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。</p>
<p>在函数的类型表达式其实可以看作$\lambda$表达式，它适用于$\alpha$变换（$\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。</p>
<p>在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如<code>(==)</code>函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么<code>(==)</code>的类型就是：</p>
<p style="text-align: center;">(==) :: (Eq a) => a -> a -> Bool</p>

<p>其中<code>=&gt;</code>前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以<code>(==)</code>函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。</p>
<h2 id="定义新Type"><a href="#定义新Type" class="headerlink" title="定义新Type"></a>定义新Type</h2><p>定义一个新的Type需要使用<code>data</code>关键字，比如定义<code>Bool</code>需要使用：</p>
<p style="text-align: center;">data Bool = False | True</p>

<p>其中<code>=</code>左侧的部分定义了新类型的名称<code>Bool</code>，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。<br>并且名称和值构造器的首字母都需要大写。</p>
<p>另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span>   </span></span><br></pre></td></tr></table></figure>
<p>它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。<br>如果查看Circle的类型，将返回：</p>
<p style="text-align: center;">Circle :: Float -> Float -> Float -> Shape</p>

<p>如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上<code>deriving (Show)</code>:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>类型的名称和值构造器名称也可以相同，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="导出Type"><a href="#导出Type" class="headerlink" title="导出Type"></a>导出Type</h3><p>在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件<code>Shapes.hs</code>中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Shapes</span><br><span class="line">( <span class="type">Shape(..)</span></span><br><span class="line">, <span class="type">Point(..)</span></span><br><span class="line">, <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">) <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>Shape(..)</code>导出了Shape类型和它所有的值构造器，<code>..</code>代表了它的所有值构造器。因此，<code>Shape(..)</code>相当于<code>Shape (Circle, Rectangle)</code>。</p>
<p>如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将<code>Shape(..)</code>替换为<code>Shape</code>，这样就只导出了Shape类型，而不导出其值构造器。</p>
<h3 id="Record-Syntax"><a href="#Record-Syntax" class="headerlink" title="Record Syntax"></a>Record Syntax</h3><p>如果想要方便地取出类型实例中的参数，可以使用Record语法，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   , <span class="title">ycoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> point = <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; xcoord point</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; ycoord point</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>同时也可以通过下面方法来创建这个point：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">point</span> = <span class="type">Point</span> &#123;ycoord=<span class="number">2.0</span>, xcoord=<span class="number">1.0</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Type-parameters"><a href="#Type-parameters" class="headerlink" title="Type parameters"></a>Type parameters</h3><p>值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义：</p>
<p style="text-align: center;">data Maybe a = Nothing | Just a</p>

<p>它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。<br>他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">Nothing</span> :: <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> <span class="number">1</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> &#x27;a&#x27; :: <span class="type">Maybe</span> <span class="type">Char</span></span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;abc&quot;</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]</span><br></pre></td></tr></table></figure>

<p>可以用这种方法改写Point：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> x y = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="title">x</span></span></span><br><span class="line"><span class="class">                       , <span class="title">ycoord</span> :: <span class="title">y</span></span></span><br><span class="line"><span class="class">                       &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。</p>
<p>而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> (<span class="type">Ord</span> <span class="title">k</span>) =&gt; <span class="type">Map</span> k v = ... </span></span><br><span class="line"><span class="title">toList</span> :: (<span class="type">Ord</span> k) =&gt; <span class="type">Map</span> k a -&gt; [(k, a)]</span><br></pre></td></tr></table></figure>

<h4 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h4><p>Either是一个类型构造器，它有两个值构造器，定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Read</span>, <span class="type">Show</span>)  </span></span><br></pre></td></tr></table></figure>
<p>如果使用了Left，那它的a的类型就是具体的；如果使用了Right，那它的b的类型就是具体的：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Right</span> <span class="number">20</span>  </span><br><span class="line"><span class="type">Right</span> <span class="number">20</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Left</span> <span class="string">&quot;w00t&quot;</span>  </span><br><span class="line"><span class="type">Left</span> <span class="string">&quot;w00t&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Right</span> &#x27;a&#x27;  </span><br><span class="line"><span class="type">Right</span> &#x27;a&#x27; :: <span class="type">Either</span> a <span class="type">Char</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Left</span> <span class="type">True</span>  </span><br><span class="line"><span class="type">Left</span> <span class="type">True</span> :: <span class="type">Either</span> <span class="type">Bool</span> b  </span><br></pre></td></tr></table></figure>
<p>Either可以看作Maybe的补充，比如Maybe在使用时，出现异常可以返回Nothing，但只是一个Nothing，不包含任何信息；但Either包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Nothing</span></span><br><span class="line"><span class="title">safeDiv</span> x y = <span class="type">Just</span> (x `div` y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>而使用Either：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Either</span> <span class="type">String</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Left</span> <span class="string">&quot;Divided by zero&quot;</span></span><br><span class="line"><span class="title">safeDiv</span> x y = <span class="type">Right</span> (x `div` y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="type">Right</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="type">Left</span> <span class="string">&quot;Divided by zero&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Derived-instances"><a href="#Derived-instances" class="headerlink" title="Derived instances"></a>Derived instances</h3><p>想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span>   </span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)  </span><br></pre></td></tr></table></figure>
<p>这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右）</p>
<h3 id="Type-synonyms"><a href="#Type-synonyms" class="headerlink" title="Type synonyms"></a>Type synonyms</h3><p>为了阅读方便，书写简便，可以使用<code>type</code>关键字为已有类型创建别名（synonyms）。比如String的定义：</p>
<p style="text-align: center;">type String = [Char]</p>

<p>在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。<br>同时，类型别名也可以接收类型参数</p>
<h4 id="newtype-keyword"><a href="#newtype-keyword" class="headerlink" title="newtype keyword"></a>newtype keyword</h4><p>除了<code>data</code>、<code>type</code>关键字之外，还可以用<code>newtype</code>关键字来定义一个新的类型，比如<code>Control.Applicative</code>模块中的ZipList：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ZipList</span> a = &#123; <span class="title">getZipList</span> :: [<span class="title">a</span>] &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不同于type，它不是别名，可以使用record语法来直接定义取出值的函数</li>
<li>不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰</li>
</ul>
<h3 id="Recursive-data-structures"><a href="#Recursive-data-structures" class="headerlink" title="Recursive data structures"></a>Recursive data structures</h3><p>一个类型也可以递归定义，比如一颗二叉树：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">EmptyTree</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>)  </span></span><br></pre></td></tr></table></figure>

<h2 id="定义新Typeclass"><a href="#定义新Typeclass" class="headerlink" title="定义新Typeclass"></a>定义新Typeclass</h2><p>定义一个新的Typeclass需要使用class关键字，例如定义Eq类型类：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span>  </span><br><span class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span>  </span><br><span class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span>  </span><br><span class="line">    x == y = not (x /= y)  </span><br><span class="line">    x /= y = not (x == y)  </span><br></pre></td></tr></table></figure>
<p>其中<code>a</code>是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。</p>
<p>包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们（<code>(==) | (/=)</code>）成为这个类型类的最小完整定义（minimal complete definition）</p>
<p>查看一个类型类的成员需要实现的函数可以在GHCi中使用<code>:info</code>：</p>
<p style="text-align: center;">ghci> :info Eq</p>

<h3 id="手动创建实例"><a href="#手动创建实例" class="headerlink" title="手动创建实例"></a>手动创建实例</h3><p>使一个类型成为一个类型类的实例可以直接使用<code>deriving</code>来自动完成，也可以通过使用instance关键字来手动完成。比如使Point成为Show的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Point</span> <span class="keyword">where</span></span></span><br><span class="line">    show (<span class="type">Point</span> x y) = <span class="string">&quot;(&quot;</span> ++ show x ++ <span class="string">&quot;, &quot;</span> ++ show y ++ <span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- in ghci</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以自定义显示的内容，否则使用deriving的话只会直接将其转化为字符串。</p>
<p>同时也要注意类型和类型构造器的区别，传入给instance的第二个参数应该为类型而不是类型构造器，比如Maybe：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">Maybe</span> <span class="keyword">where</span></span>  </span><br><span class="line">    ...    </span><br><span class="line"><span class="comment">-- 错误用法，因为Maybe是类型构造器而不是类型</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    ...</span><br><span class="line"><span class="comment">-- 错误用法，因为m不一定是Eq的成员</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Eq</span> <span class="title">m</span>) =&gt; <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    <span class="type">Just</span> x == <span class="type">Just</span> y = x == y  </span><br><span class="line">    <span class="type">Nothing</span> == <span class="type">Nothing</span> = <span class="type">True</span>  </span><br><span class="line">    _ == _ = <span class="type">False</span>  </span><br></pre></td></tr></table></figure>

<h3 id="Functor-Typeclass"><a href="#Functor-Typeclass" class="headerlink" title="Functor Typeclass"></a>Functor Typeclass</h3><p>Functor也是一种类型类，它只规定了一个函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>其中<code>f</code>是一个类型构造器，而不是一个具体类型</p>
<h2 id="Kinds"><a href="#Kinds" class="headerlink" title="Kinds"></a>Kinds</h2><p>一个值的类型叫做类型（Type），而一个类型的类型叫做Kind。可以通过GHCi中<code>:k</code>来查看Kind：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Int</span></span><br><span class="line"><span class="type">Int</span> :: *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Maybe</span></span><br><span class="line"><span class="type">Maybe</span> :: * -&gt; *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="type">Maybe</span> <span class="type">Int</span> :: *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Either</span></span><br><span class="line"><span class="type">Either</span> :: * -&gt; * -&gt; *</span><br></pre></td></tr></table></figure>
<p>其中的星号<code>*</code>代表了一个具体类型（concrete type）。Int本身就是一个具体类型，所以Int的Kind是*。而Maybe是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以Maybe的Kind是* -&gt; *。如果给Maybe传入了一个Int，那么得到的Maybe Int就是一个具体的类型，它的Kind就是*。Either也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以Either的Kind是* -&gt; * -&gt; *。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a><br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a><br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a><br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子与应用函子</a></p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#2 高阶函数与模块</title>
    <url>/p/53e482b7.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/d63b5b5f.html">&lt; #1</a></p>
<p><a href="/p/369b7e08.html">#3 &gt;</a></p>
</div>

<h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h2><h3 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h3><p>Haskell中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如max函数，它的类型签名是：</p>
<span id="more"></span>
<p style="text-align: center;">max :: Ord a => a -> a -> a</p>

<p>可以看成a -&gt; (a -&gt; a)，即接收一个参数，返回一个类型为a -&gt; a的函数。比如max 1的类型签名是：</p>
<p style="text-align: center;">max 1 :: (Ord a, Num a) => a -> a</p>

<p>因此max 1 2，也就等同于(max 1) 2，即将函数max 1应用在数字2上</p>
<p>同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions）</p>
<h3 id="一些高阶函数"><a href="#一些高阶函数" class="headerlink" title="一些高阶函数"></a>一些高阶函数</h3><h4 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h4><p style="text-align: center;">zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]</p>

<p>第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith max [<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]  </span><br></pre></td></tr></table></figure>

<h4 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h4><p style="text-align: center;">flip :: (a -> b -> c) -> b -> a -> c</p>

<p>flip函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">&quot;hello&quot;</span></span><br><span class="line">[(<span class="number">1</span>,&#x27;h&#x27;),(<span class="number">2</span>,&#x27;e&#x27;),(<span class="number">3</span>,&#x27;l&#x27;),(<span class="number">4</span>,&#x27;l&#x27;),(<span class="number">5</span>,&#x27;o&#x27;)]</span><br><span class="line"><span class="title">ghci</span>&gt; flip zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">&quot;hello&quot;</span>  </span><br><span class="line">[(&#x27;h&#x27;,<span class="number">1</span>),(&#x27;e&#x27;,<span class="number">2</span>),(&#x27;l&#x27;,<span class="number">3</span>),(&#x27;l&#x27;,<span class="number">4</span>),(&#x27;o&#x27;,<span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map函数接收一个函数f和一个列表a，将函数f应用在列表a的每个元素中，并返回得到的所有结果组成的列表b：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]  </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]  </span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p style="text-align: center;">filter :: (a -> Bool) -> [a] -> [a]</p>

<p>filter函数接收一个函数f和一个列表a，将列表a中的每个元素传入函数f中，如果结果为True就保留，结果为False就抛弃，返回所有保留的元素组成的新列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; filter even [<span class="number">1.</span><span class="number">.10</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] </span><br></pre></td></tr></table></figure>

<h4 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h4><p style="text-align: center;">takeWhile :: (a -> Bool) -> [a] -> [a]</p>

<p>takeWhile函数接收一个函数f和一个列表a，将列表a中从左向右每个元素传入函数f，直到结果为False停止，返回停止前传入的所有元素组成的新列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; takeWhile (/=&#x27; &#x27;) <span class="string">&quot;word1 word2&quot;</span></span><br><span class="line"><span class="string">&quot;word1&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-application"><a href="#Function-application" class="headerlink" title="Function application"></a>Function application</h3><p>函数应用可以使用<code>$</code>，<code>$</code>是一个函数，它的类型是：</p>
<p style="text-align: center;">($) :: (a -> b) -> a -> b</p>

<p>它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。</p>
<!--more-->
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f</span> $ g x</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="title">f</span> (g x)</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="title">f</span> g x</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line">(f g) x</span><br></pre></td></tr></table></figure>
<h3 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h3><p>函数复合可以使用<code>.</code>，<code>.</code>也是一个函数，它的类型是：</p>
<p style="text-align: center;">(.) :: (b -> c) -> (a -> b) -> a -> c</p>

<p>定义是：</p>
<p style="text-align: center;">f . g = \x -> f (g x)</p>

<p>但是函数复合的优先级要比函数执行低，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum</span> . replicate <span class="number">5</span> . max <span class="number">6.7</span> <span class="number">8.9</span></span><br></pre></td></tr></table></figure>
<p>会先执行max 6.7 8.9并返回8.9，然后将sum、replicate 5、8.9复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用<code>$</code>来规定先复合再执行：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum</span> . replicate <span class="number">5</span> . max <span class="number">6.7</span> $ <span class="number">8.9</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>Haskell语言中的lambda表达式是用<code>\</code>来表示的（因为看着像$\mathtt{\lambda}$？）<br>具体语法是</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">\para1 para2 ... -&gt; return</span><br></pre></td></tr></table></figure>
<p>“-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。</p>
<h3 id="fold和scan"><a href="#fold和scan" class="headerlink" title="fold和scan"></a>fold和scan</h3><p>fold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表<br>传入的二元函数<code>f :: a -&gt; b -&gt; b</code>将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数）</p>
<h4 id="foldl"><a href="#foldl" class="headerlink" title="foldl"></a>foldl</h4><p>左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldl</span> f a xs</span><br></pre></td></tr></table></figure>
<p>它的结果计算过程为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; foldl f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f a x1</span><br><span class="line">[<span class="number">2.</span>] a = f a x2 = f (f a x1) x2</span><br><span class="line">[<span class="number">3.</span>] a = f a x3 = f (f (f a x1) x2) x3</span><br></pre></td></tr></table></figure>
<p>可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]<br>而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表</p>
<h4 id="foldr"><a href="#foldr" class="headerlink" title="foldr"></a>foldr</h4><p>右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> f a xs</span><br></pre></td></tr></table></figure>
<p>它的结果计算过程为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; foldr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f x3 a</span><br><span class="line">[<span class="number">2.</span>] a = f x2 a = f x2 (f x3 a)</span><br><span class="line">[<span class="number">3.</span>] a = f x1 a = f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure>
<p>从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]<br>因此可以使用递归来写一个和foldr效果一样的函数:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">foldr&#x27;</span> _ x [] = x</span><br><span class="line"><span class="title">foldr&#x27;</span> f a (x:xs) = f x (foldr&#x27; f a xs)</span><br></pre></td></tr></table></figure>
<p>也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表</p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; foldr (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="type">True</span>    <span class="comment">-- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了</span></span><br><span class="line"><span class="title">ghci</span>&gt; foldl (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="comment">-- 这里什么都不会发生，直到电脑内存被爆掉</span></span><br><span class="line"><span class="comment">-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表</span></span><br></pre></td></tr></table></figure>

<h4 id="scanl和scanr"><a href="#scanl和scanr" class="headerlink" title="scanl和scanr"></a>scanl和scanr</h4><p>scan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表<br>scanl则向右延伸这个列表，scanr则向左延伸这个列表<br>但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; scanr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] 最右侧元素(<span class="number">-1</span> <span class="keyword">in</span> python) : a</span><br><span class="line">[<span class="number">2.</span>] 右侧第二个元素(<span class="number">-2</span>) : f x3 a</span><br><span class="line">[<span class="number">3.</span>] 右侧第三个元素(<span class="number">-3</span>) : f x2 (f x3 a)</span><br><span class="line">[<span class="number">4.</span>] 右侧第四个元素(<span class="number">-4</span>) : f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure>
<p>可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素<br>因此可以用递归来写一个和scanr效果一样的函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">scanr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanr&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="comment">-- scanr&#x27; f a (x:xs) = f x (foldr f a xs) : scanr&#x27; f a xs</span></span><br><span class="line"><span class="title">scanr&#x27;</span> f a (x:xs) = f x q : qs</span><br><span class="line">                    <span class="keyword">where</span> qs@(q:_) = scanr&#x27; f a xs</span><br></pre></td></tr></table></figure>
<p>scanl也是同理：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">scanl&#x27;</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanl&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="title">scanl&#x27;</span> f a (x:xs) = a : scanl&#x27; f (f a x) xs</span><br></pre></td></tr></table></figure>

<p>也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanl (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">28</span>,<span class="number">36</span>,<span class="number">45</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanr (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[*** <span class="type">Exception</span>: stack overflow</span><br></pre></td></tr></table></figure>

<h4 id="使用foldr编写foldl"><a href="#使用foldr编写foldl" class="headerlink" title="使用foldr编写foldl"></a>使用foldr编写foldl</h4><p>pdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldl&#x27;</span> f z xs = foldr (\x g y -&gt; g (f y x)) id xs z</span><br></pre></td></tr></table></figure>

<p>它利用 foldr (\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。</p>
<p>先来看一下foldr的类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> :: <span class="type">Foldable</span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line"><span class="comment">-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br></pre></td></tr></table></figure>
<p>但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。</p>
<p>所以这里foldr的类型可以写成：</p>
<p style="text-align: center;">(a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b)</p>

<p>对应于用法 foldr (\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）<br>而xs对应于[a]；id对应于(b -&gt; b)<br>所以 (\x g y -&gt; g (f y x)) 要对应于：</p>
<p style="text-align: center;">(a -> (b -> b) -> (b -> b))</p>

<p>因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。</p>
<p>再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b<br>所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为：</p>
<p style="text-align: center;">b -> (b -> b)</p>

<p>现在根据foldr的定义：</p>
<p style="text-align: center;">foldr f a (x:xs) = f x (foldr f a xs)</p>

<p>带入计算一下：</p>
<blockquote>
<p>xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn]</p>
<p>定义中的f即为(\x g y -&gt; g (f y x))，a即为id</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  foldr (\x g y -&gt; g (f y x)) id xs z</span><br><span class="line">= (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br></pre></td></tr></table></figure>
<p>写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br></pre></td></tr></table></figure>
<p>不难发现，原式 (foldr (…) id xs) z 等价于：</p>
<p style="text-align: center;">(foldr (...) id xs') (f z x1)</p>

<p>跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’<br>因此下一步：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;&#x27;) (f (f (f z x1) x2) x3)</span><br><span class="line">= ...</span><br></pre></td></tr></table></figure>
<p>可以发现，已经有了规律。那么最终停止时是什么样呢？</p>
<p>最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []<br>而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id</p>
<p>所以最后的结果：<br>(id的定义：id x = x)</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= ...</span><br><span class="line">= (foldr (...) id []) (f (.. (f z x1) ..) xn)</span><br><span class="line">= id (f (.. (f z x1) ..) xn)</span><br><span class="line">= f (.. (f z x1) ..) xn</span><br></pre></td></tr></table></figure>
<p>那么最后这个结果就很熟悉了，它就是 foldl f z xs。<br>所以我们推导出了这个用foldr表示foldl的写法是正确的。</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Haskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用<code>:m + ...</code>，比如加载Data.List模块：</p>
<p style="text-align: center;">Prelude> :m + Data.List</p>

<p>而在hs文件中引入模块，需要使用<code>import</code>语句，下面和python的对比可以便于理解：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="comment">-- from Data.List import *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">nub</span>, <span class="title">sort</span>)</span><br><span class="line"><span class="comment">-- from Data.List import nub, sort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List <span class="keyword">hiding</span> (<span class="title">nub</span>)</span><br><span class="line"><span class="comment">-- 从Data.List中引入所有，但不引入nub函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List</span><br><span class="line"><span class="comment">-- import Data.List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List <span class="keyword">as</span> Li</span><br><span class="line"><span class="comment">-- import Data.List as Li</span></span><br></pre></td></tr></table></figure>

<h3 id="编写Modules"><a href="#编写Modules" class="headerlink" title="编写Modules"></a>编写Modules</h3><p>模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫<code>ModuleA.hs</code>，那它的头部需要写：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleA</span><br><span class="line">( <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">, <span class="title">functionC</span></span><br><span class="line">) <span class="keyword">where</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="https://stackoverflow.com/questions/6172004/writing-foldl-using-foldr">Writing foldl using foldr - StackOverflow</a></li>
<li><a href="https://blog.csdn.net/WinterShiver/article/details/103308165">Haskell：用foldr定义foldl</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a><br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a><br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a><br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子与应用函子</a></p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#1 基础语法与函数</title>
    <url>/p/d63b5b5f.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/b3ca5c18.html">&lt; #0</a></p>
<p><a href="/p/53e482b7.html">#2 &gt;</a></p>
</div>

<h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><ul>
<li><code>+ - * / ()</code>：加减乘除</li>
<li><code>div</code>：整除</li>
<li><code>mod</code>：取模</li>
<li><code>True False</code>：布尔值<span id="more"></span></li>
<li><code>|| &amp;&amp; not</code>：或且非</li>
<li><code>==</code>：条件判断，相等</li>
<li><code>/=</code>：条件判断，不等</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>Haskell中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; max <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>前缀（prefix）函数与中缀（infix）函数转换：</p>
<ul>
<li>对前缀函数加<code>``</code>使其变成中缀函数</li>
<li>对中缀函数加<code>()</code>使其变成前缀函数</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `div` <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">1</span> `max` <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; (||) <span class="type">True</span> <span class="type">False</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表是Haskell中很常见的数据类型，和Python中不同，Haskell中的列表中的所有元素必须是同一个类型。</p>
<p>以下是列表常用的函数：</p>
<!--more-->
<ul>
<li><code>(++)</code> :: [a] -&gt; [a] -&gt; [a]：合并两个列表</li>
<li><code>(:)</code> :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。[1, 2, 3]是1:2:3:[]的语法糖</li>
<li><code>(!!)</code> :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。a !! 1相当于Python中的a[1]</li>
<li><code>head</code> :: [a] -&gt; a：返回列表的第一个元素</li>
<li><code>tail</code> :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]）</li>
<li><code>last</code> :: [a] -&gt; a：返回列表中的最后一个元素</li>
<li><code>init</code> :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表</li>
<li><code>length</code> :: Foldable t =&gt; t a -&gt; Int：返回列表的长度</li>
<li><code>null</code> :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空</li>
<li><code>reverse</code> :: [a] -&gt; [a]：返回翻转后的列表</li>
<li><code>take</code> :: Int -&gt; [a] -&gt; [a]：返回列表a的前n个元素的列表(take n a)</li>
<li><code>drop</code> :: Int -&gt; [a] -&gt; [a]：返回列表a中除去前n个元素后的列表(drop n a)</li>
<li><code>maximum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值</li>
<li><code>minimum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值</li>
<li><code>sum</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和</li>
<li><code>product</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积</li>
<li><code>elem</code> :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值n是否在列表a中(  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">elem</span> n a</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="title">n</span> `elem` a <span class="comment">--用``包上可以变成中缀函数使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Texas-ranges"><a href="#Texas-ranges" class="headerlink" title="Texas ranges"></a>Texas ranges</h3><p>使用<code>..</code>可以表示出范围并自动推导：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span> .. <span class="number">10</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;a&#x27; .. &#x27;z&#x27;]  </span><br><span class="line"><span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;<span class="type">K&#x27;</span> .. &#x27;<span class="type">Z&#x27;</span>]  </span><br><span class="line"><span class="string">&quot;KLMNOPQRSTUVWXYZ&quot;</span> </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">2</span>, <span class="number">4</span> .. <span class="number">20</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>, <span class="number">6</span> .. <span class="number">20</span>]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">5</span>, <span class="number">4</span> .. <span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>也可以用来生成无穷列表，如[1..]、[1, 3..]。同时也有函数可以生成无穷列表：</p>
<ul>
<li><code>cycle</code> :: [a] -&gt; [a]：将原列表不断循环生成无穷列表</li>
<li><code>repeat</code> :: a -&gt; [a]：将传入的值不断重复生成无穷列表<ul>
<li><code>replicate</code> :: Int -&gt; a -&gt; [a]：将值a重复n次，返回生成的列表(replicate n a)</li>
</ul>
</li>
</ul>
<h3 id="List-comprehension"><a href="#List-comprehension" class="headerlink" title="List comprehension"></a>List comprehension</h3><p>Haskell中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x * <span class="number">2</span> | x &lt;- [<span class="number">1</span> .. <span class="number">10</span>]]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [x * <span class="number">2</span> | x &lt;- [<span class="number">1</span> .. <span class="number">10</span>], x * <span class="number">2</span> &gt;= <span class="number">12</span>]  </span><br><span class="line">[<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50</span> .. <span class="number">100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>]  </span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; [x * y | x &lt;- [<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>], y &lt;- [<span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>]]  </span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>Haskell中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数：</p>
<ul>
<li><code>fst</code> :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素</li>
<li><code>snd</code> :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素</li>
<li><code>zip</code> :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组</li>
</ul>
<h2 id="Syntax-in-Functions"><a href="#Syntax-in-Functions" class="headerlink" title="Syntax in Functions"></a>Syntax in Functions</h2><p>函数可以直接定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">plus</span> x y = x + y</span><br></pre></td></tr></table></figure>
<p>这时Haskell会自动推断函数的类型为(Num a) =&gt; a -&gt; a -&gt; a。但是最好在定义函数前声明函数的类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">plus</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">plus</span> x y = x + y</span><br></pre></td></tr></table></figure>

<h3 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h3><p>定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a  </span><br><span class="line"><span class="title">first</span> (x, _, _) = x  </span><br><span class="line">  </span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b  </span><br><span class="line"><span class="title">second</span> (_, y, _) = y  </span><br><span class="line">  </span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c  </span><br><span class="line"><span class="title">third</span> (_, _, z) = z  </span><br></pre></td></tr></table></figure>
<p>其中<code>_</code>表示任何值，且不关心它的内容，只是用来占位</p>
<p>列表的(:)操作也可以用来进行模式匹配：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x</span><br><span class="line"></span><br><span class="line"><span class="title">sum&#x27;</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">sum&#x27;</span> [] = <span class="number">0</span>  </span><br><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs  </span><br></pre></td></tr></table></figure>
<p>但(++)操作不可以用来模式匹配</p>
<p>在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用<code>xs@(q:qs)</code>。比如[1, 2, 3]通过<code>xs@(q:qs)</code>匹配后，xs为[1, 2, 3]，q为1，qs为[2, 3]</p>
<h3 id="Guard-syntax"><a href="#Guard-syntax" class="headerlink" title="Guard syntax"></a>Guard syntax</h3><p>在函数的定义中，也可以使用守卫（guard）语法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">max&#x27;</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">max&#x27;</span> a b   </span><br><span class="line">    | a &gt; b     = a  </span><br><span class="line">    | otherwise = b </span><br></pre></td></tr></table></figure>
<p>先给出传入的参数变量，然后下一行缩进后加|，|后面等号前表示进行的判断，如果为True则返回这个等号后面的值；如果为False则继续判断下一行，直到otherwise</p>
<h3 id="Case-expressions"><a href="#Case-expressions" class="headerlink" title="Case expressions"></a>Case expressions</h3><p>在函数的定义中，也可以使用case表达式来配合模式匹配使用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result  </span><br><span class="line">                   pattern -&gt; result</span><br><span class="line">                   ...  </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x  </span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line">                      (x:_) -&gt; x  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; <span class="string">&quot;empty.&quot;</span>  </span><br><span class="line">                                               [x] -&gt; <span class="string">&quot;a singleton list.&quot;</span>   </span><br><span class="line">                                               xs -&gt; <span class="string">&quot;a longer list.&quot;</span>  </span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ what xs  </span><br><span class="line">    <span class="keyword">where</span> what [] = <span class="string">&quot;empty.&quot;</span>  </span><br><span class="line">          what [x] = <span class="string">&quot;a singleton list.&quot;</span>  </span><br><span class="line">          what xs = <span class="string">&quot;a longer list.&quot;</span> </span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>声明在函数定义中要使用的局部变量，可以使用where关键字：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">nitials</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">initials</span> firstname lastname = [f] ++ <span class="string">&quot;. &quot;</span> ++ [l] ++ <span class="string">&quot;.&quot;</span>  </span><br><span class="line">    <span class="keyword">where</span> (f:_) = firstname  </span><br><span class="line">          (l:_) = lastname  </span><br></pre></td></tr></table></figure>
<p>在where中，也可以使用上面的模式匹配</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let &lt;bindings&gt; in &lt;expression&gt;</code>语法可以在函数的定义中使用，也可以在普通算式或列表中使用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">cylinder</span> r h = </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h  </span><br><span class="line">        topArea = pi * r ^<span class="number">2</span>  </span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> * (<span class="keyword">let</span> a = <span class="number">9</span> <span class="keyword">in</span> a + <span class="number">1</span>) + <span class="number">2</span>  </span><br><span class="line"><span class="number">42</span> </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="keyword">let</span> square x = x * x <span class="keyword">in</span> (square <span class="number">5</span>, square <span class="number">3</span>, square <span class="number">2</span>)]  </span><br><span class="line">[(<span class="number">25</span>,<span class="number">9</span>,<span class="number">4</span>)] </span><br></pre></td></tr></table></figure>

<h3 id="if-statement"><a href="#if-statement" class="headerlink" title="if statement"></a>if statement</h3><p>Haskell中的if语句为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> ...</span><br><span class="line"><span class="comment">-- or if ... then ... else ...</span></span><br><span class="line"><span class="comment">-- or</span></span><br><span class="line"><span class="title">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> <span class="keyword">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> ...</span><br></pre></td></tr></table></figure>
<p>其中最后一个else无论如何也不可以省去</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a><br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a><br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a><br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子与应用函子</a></p>
</div>
]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>修复manim中Text类的bug</title>
    <url>/p/b6815e8.html</url>
    <content><![CDATA[<p>在使用manim时,对于Text类,会有一些bug,我尝试修复了它们</p>
<ol>
<li>在<code>shaders</code>分支下无法使用Text类</li>
<li>Text文字的stroke边框不完整,导致显示stroke会非常难看</li>
<li>含有空格的Text的空格不在文字内部,而在<code>ORIGIN</code>的位置,导致<code>Transform</code>时会有字符在原位置和<code>ORIGIN</code>之间 <del>反复横跳</del></li>
<li>Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小</li>
</ol>
<p>这些问题已经通过<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>修复到了manim的master分支中</p>
<span id="more"></span>

<h2 id="mathcal-Bug-1"><a href="#mathcal-Bug-1" class="headerlink" title="$\mathcal{Bug\ 1.}$"></a>$\mathcal{Bug\ 1.}$</h2><p>当在<code>shaders</code>分支下使用Text类时会出现如下报错:<br><img src="../images/text_bug1.png"><br>其中最后一行让我发现此时的p0和p1的大小不相等,不能相加(broadcast),而p0和p1是通过贝赛尔曲线的次数(在shaders下是3)来拆分<code>self.points</code>的<br>所以可能是<code>self.points</code>的长度不为3的倍数,导致了错误.在<code>print(len(self.points))</code>后发现确实是这样<br>然后我又用了 <del>玄学</del> 手段,删掉了SVGMobject的最后一个点,发现可以正常渲染</p>
<p>此时我又去看了cairo自动生成的svg代码,根据我之前学svg的一点经验,发现每个<code>&lt;path/&gt;</code>的路径结尾都为<code>Z M ... ... /&quot;&gt;</code><br>而<code>Z</code>是将路径闭合,但闭合后又多出了一个<code>M</code>控制符,这会导致manim在处理svg时额外生成一个点<br>而删掉每个路径字符串的最后一个<code>M</code>控制符,可以直接使用正则表达式匹配出来,然后替换掉<br><img src="../images/text_bug1_svg.png"></p>
<p>我第一个想到的正则表达式是<code>Z M .*? /&quot;&gt;</code>,但是如果在路径的中间出现<code>Z M</code>,则会将其后面有用的部分一起删除<br>而有用的部分一定含有控制符,所以将控制符排除,就可以仅仅匹配掉最后一个<code>M</code>,正则表达式:<code>Z M [^A-Za-z]*? /&quot;&gt;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_last_M</span>(<span class="params">self, file_name</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fpr:</span><br><span class="line">        content = fpr.read()</span><br><span class="line">    content = re.sub(<span class="string">r&#x27;Z M [^[A-Za-z]*? &quot;\/&gt;&#x27;</span>, <span class="string">&#x27;Z &quot;/&gt;&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fpw:</span><br><span class="line">        fpw.write(content)</span><br></pre></td></tr></table></figure>

<h2 id="mathcal-Bug-2"><a href="#mathcal-Bug-2" class="headerlink" title="$\mathcal{Bug\ 2.}$"></a>$\mathcal{Bug\ 2.}$</h2><p>Text文字的stroke边框不完整,导致stroke显示不全,也会对<code>DrawBorderThenFill</code>造成影响,也有B站的观众向我提了这个问题</p>
<blockquote>
<p>– 话说，感觉每个Chapter之间的文字是不是先画出轮廓再填充上色，画完轮廓的时候停顿了一下。但是停顿的时候轮廓没有画完，有些地方有点断续的感觉<br>– Text类的bug，stroke日常乱套</p>
</blockquote>
<p>为了解决这个问题,我只显示了stroke,并且用<code>debugTeX</code>标出了构成每个字符的<code>self.points</code>的位置,比如”manim”如下:<br><img src="../images/text_bug2_before.png"><br>通过观察和与<a href="https://github.com/xy-23">@XiaoYoung</a>交流之后,确定了cairo生成的svg并不能使路径自动闭合<br>而在一般查看svg的软件(Chrome)中,svg图像只显示内部(fill),而stroke被忽略(很细),所以正常使用没问题<br>但是在manim中有时需要使用stroke,这时cairo生成的svg出现了bug,路径没有完全闭合</p>
<p>我最开始的想法是直接通过<code>.add_line_to()</code>方法将svg收尾相连,但是这显然只解决了m和n<br>而a和i是由两条路径复合而成的,其中的每条路径都没有闭合,所以都需要手动闭合,所以我决定遍历<code>self.points</code><br>这时我使用了一个<code>last</code>变量来记录遍历到当前位置所在的路径上的起点,并且如果到了下一条路径(索引为nppc的倍数,并且不与前一个点相重合),就将首尾连接上,并更新<code>last</code></p>
<p>而这样做还需要一个特判,当points为空时(空格)直接跳过,否则<code>points[0]</code>会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nppc = self.n_points_per_cubic_curve</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> self:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(each.points) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    points = each.points</span><br><span class="line">    last = points[<span class="number">0</span>]</span><br><span class="line">    each.clear_points()</span><br><span class="line">    <span class="keyword">for</span> index, point <span class="keyword">in</span> <span class="built_in">enumerate</span>(points):</span><br><span class="line">        each.append_points([point])</span><br><span class="line">        <span class="keyword">if</span> index != <span class="built_in">len</span>(points) - <span class="number">1</span> <span class="keyword">and</span> (index + <span class="number">1</span>) % nppc == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">any</span>(point != points[index+<span class="number">1</span>]):</span><br><span class="line">            each.add_line_to(last)</span><br><span class="line">            last = points[index + <span class="number">1</span>]</span><br><span class="line">    each.add_line_to(last)</span><br></pre></td></tr></table></figure>

<p>这样做之后,这个bug就完全解决了,而且中文也同时适用,对比如下,上为修复之前,下为修复之后(都为仅显示stroke)<br><img src="../images/text_bug2_after.png"><br><img src="../images/text_bug2_en.png"><br><img src="../images/text_bug2_cn.png"></p>
<h2 id="mathcal-Bug-3"><a href="#mathcal-Bug-3" class="headerlink" title="$\mathcal{Bug\ 3.}$"></a>$\mathcal{Bug\ 3.}$</h2><p>这个是非常常见的问题了,如下:<br><img src="../images/text_bug3_before.gif"><br>之前解决这个问题是通过’假空格’,即用一个不常用字符表示空格,并将其设为背景色,或者opacity改成0<br>通过debugTeX可以发现,Text的空格占字符而且位置在ORIGIN<br>而TextMobject中的空格直接不占位置.所以我直接在处理bug2的同时,将<code>len(each.points) == 0</code>的处理中加上了<code>self.remove(each)</code>,这样就暂时解决了<br><img src="../images/text_bug3.png"><br><img src="../images/text_bug3_after.gif"><br>而<a href="https://github.com/xy-23">@XiaoYoung</a>也提醒了我,这样的处理会干扰t2c的自动上色(下标改变了),在<a href="https://github.com/3b1b/manim/pull/1018">#1018</a>这里,他决定单开一个pr来修复这个bug,所以我就把这一个commit删除掉了</p>
<h2 id="mathcal-Bug-4"><a href="#mathcal-Bug-4" class="headerlink" title="$\mathcal{Bug\ 4.}$"></a>$\mathcal{Bug\ 4.}$</h2><p>Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小<br>通过阅读源码可以发现,TextMobject在<code>__init__()</code>的结尾,有一句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.height <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    self.scale(TEX_MOB_SCALE_FACTOR)</span><br></pre></td></tr></table></figure>
<p>而这个<code>TEX_MOB_SCALE_FACTOR</code>默认为<code>0.05</code>,即将默认的SVGMobject(高度为固定默认值)缩小为0.05倍<br>而Text类最后缩小了0.1倍,导致了大小不等,将其改为0.05后,就方便统一大小了<br><img src="../images/text_bug4.png"></p>
<h2 id="mathcal-Pull-Requests"><a href="#mathcal-Pull-Requests" class="headerlink" title="$\mathcal{Pull\ Requests}$"></a>$\mathcal{Pull\ Requests}$</h2><p>第一次提交pr,记录一下</p>
<ol>
<li>将原repo fork到自己的用户上</li>
<li>clone下来fork的repo</li>
<li>进行更改,add/commit/push,commit的注释要规范</li>
<li>在GitHub网页上,打开fork的repo,会有一个按钮<code>New Pull Request</code></li>
<li>比较,确认更改,然后<code>Create Pull Request</code>,表述出pr的必要性和验证,提交pr</li>
<li>等待repo管理员merge</li>
</ol>
<p>这次修复bug的pr在<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>和<a href="https://github.com/3b1b/manim/pull/1031">#1031</a><br>其中<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>被merge了,而<a href="https://github.com/3b1b/manim/pull/1031">#1031</a>还在等待</p>
]]></content>
      <categories>
        <category>manim</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>笔记</tag>
        <tag>manim</tag>
        <tag>python</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>树上莫队-笔记  /「SPOJ 10707」COT2-题解</title>
    <url>/p/24f5ddbc.html</url>
    <content><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/SP10707">SPOJ 10707 COT2-Count on a tree II</a>这道题目来学习一下 <strong>树上莫队</strong><br>当需要离线查询 <strong>树上</strong> 的多区间问题时,可以使用 <strong>树上莫队</strong> 来解决</p>
<p>主要通过 <strong>欧拉序</strong> 将树转化为一条链,然后在链上执行普通莫队的操作</p>
<span id="more"></span>

<h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><h3 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h3><p>正常进行<code>dfs</code>,在入和出时各加入序列中<br>比如样例的树如下:<br><img src="/p/24f5ddbc/graph.png"><br>其欧拉序为<code>1 2 2 3 5 5 6 6 7 7 3 4 8 8 4 1</code><br>可以很好地呈现出子树的关系,即两个相同的数$x$之间的部分为$x$子树中的节点<br>其有一个性质:<strong>区间内出现两次的点不在其路径上</strong><br>根据这个性质,可以将树转化为链来求解了</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>除了将树转化为欧拉序之外,还需要求出左右端点的$LCA$,以及一个点$\texttt{u}$在欧拉序中第一次出现的位置$\texttt{fst[u]}$,第二次(最后一次)出现的位置$\texttt{lst[u]}$</p>
<p>在进行莫队操作时,如果第一次经过这个点,则<code>add</code>其贡献,第二次经过这个点,则说明这个点不在所求链上,<code>del</code>其贡献<br>这个用一个<code>vis</code>数组,反复进行异或操作就可以解决</p>
<p>再考虑询问的区间的$l,r$应该赋值为$\texttt{fst}$还是$\texttt{lst}$<br>设左端点的深度小于右端点</p>
<ol>
<li>如果$LCA$和左端点相等,则说明$[l,r]$在一条链上,$l$和$r$均取$\texttt{fst}$即可</li>
<li>否则是两条链$[l, LCA],[LCA,r]$, 防止左右端点被统计两次导致贡献被删除,需要$l$取$\texttt{lst}$,$r$取$\texttt{fst}$</li>
</ol>
<p>最后考虑贡献</p>
<ol>
<li>若是上面第一种情况,在一条链上,直接统计欧拉序区间内所有点即可,重复两次的根据前文的性质会直接删掉</li>
<li>若是上面第二种情况,由于左右端点都在$LCA$这颗子树内,所以区间中并不会出现$LCA$,但是却一定会经过,所以额外将$LCA$加入贡献,并且记录下当前结果之后,再将其贡献减去,防止影响下一个查询</li>
</ol>
<p><strong>注意:</strong> 转化为欧拉序之后的序列长度为$2n$</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol>
<li><code>dfs</code>: $O(n)$</li>
<li>求$LCA$:$O(n\log n)$</li>
<li>莫队: $O(n\sqrt{n})$</li>
</ol>
<p>综上,树上莫队的复杂度 <del>差不多</del> 也是$O(n\sqrt{n})$</p>
<h2 id="针对-mathcal-SP10707-的具体实现"><a href="#针对-mathcal-SP10707-的具体实现" class="headerlink" title="针对$\mathcal{SP10707}$的具体实现"></a>针对$\mathcal{SP10707}$的具体实现</h2><p>没啥说的,模板题,做法全在上面了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, Ans, len, ocnt;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], fst[maxn], lst[maxn], vis[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">int</span> ord[maxn], val[maxn], dep[maxn], fa[maxn][<span class="number">25</span>], old[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, pos, lca;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">if</span> (a.pos &amp; <span class="number">1</span>) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    <span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> t): <span class="built_in">from</span>(f), <span class="built_in">to</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(f, t));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(t, f));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[t].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">    G[f].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    ord[++ocnt] = u; fst[u] = ocnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == f) <span class="keyword">continue</span>;</span><br><span class="line">        dep[e.to] = dep[u] + <span class="number">1</span>;</span><br><span class="line">        fa[e.to][<span class="number">0</span>] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j) &#123;</span><br><span class="line">            fa[e.to][j] = fa[fa[e.to][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(e.to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    ord[++ocnt] = u; lst[u] = ocnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[fa[y][i]] &gt;= dep[x]) y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i]) &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[val[x]]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[val[x]]) Ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[val[x]]++;</span><br><span class="line">    <span class="keyword">if</span> (cnt[val[x]] == <span class="number">1</span>) Ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="built_in">add</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">del</span>(x);</span><br><span class="line">    vis[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(<span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) old[i] = val[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n); <span class="keyword">int</span> len_ = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len_, val[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">add</span>(<span class="built_in">read</span>(), <span class="built_in">read</span>()); </span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> il = <span class="built_in">read</span>(), ir = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> LCA = <span class="built_in">lca</span>(il, ir);</span><br><span class="line">        <span class="keyword">if</span> (fst[il] &gt; fst[ir]) <span class="built_in">swap</span>(il, ir);</span><br><span class="line">        <span class="keyword">if</span> (il == LCA) &#123;</span><br><span class="line">            q[i].l = fst[il]; q[i].r = fst[ir];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].l = lst[il]; q[i].r = fst[ir]; q[i].lca = LCA;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].id = i; q[i].pos = (q[i].l - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">chg</span>(ord[l++]);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">chg</span>(ord[r--]);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">chg</span>(ord[--l]);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">chg</span>(ord[++r]);</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca) <span class="built_in">chg</span>(q[i].lca);</span><br><span class="line">        ans[q[i].id] = Ans;</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca) <span class="built_in">chg</span>(q[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>回滚莫队-笔记  /「AtCoder 1219」歴史の研究-题解</title>
    <url>/p/7d7b5548.html</url>
    <content><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/AT1219">AtCoder 1219 歴史の研究</a>这道题目来学习一下 <strong>回滚莫队</strong><br><strong>回滚莫队</strong> 适用于容易进行<code>add</code>操作,而不容易实现<code>del</code>的情况</p>
<p>通过莫队的分块,指针移动的思想,可以让左指针进行回滚操作, <em>近似</em> 达到<code>del</code>的效果</p>
<span id="more"></span>

<h2 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>由于莫队对所有询问离线排序后,当左端点在同一个块内时,右端点递增<br>所以对于每个块,右指针直接向右依次执行<code>add</code>操作即可</p>
<p>对于左指针,在一个块内时,可以每次都从块的右边界向左进行<code>add</code>,由于不方便进行<code>del</code>操作,所以可以先记录下左指针在右边界时的<code>Ans</code>,然后每次向左移动到<code>q[i].l</code>时,将左指针再移回右边界,并且将<code>Ans</code>回滚到移动之前的值。由于分块,这样做的复杂度也不会很大</p>
<p>综上,对于每个块,<strong>右指针依次向右推进,左指针在右边界和查询的左端点之间反复横跳</strong><br>这样,执行的就只剩<code>add</code>操作,通过左指针的横跳,避免了<code>del</code>操作</p>
<p>注意,当左右端点都在同一个块时,只要暴力求出结果就可以了<br><strong>一定要注意</strong>: 不要使用奇偶排序,必须保证右端点的 <strong>单调递增</strong></p>
<p>对于每个块内的处理,大概如下图:<br><img src="/p/7d7b5548/RollBackMosAlgo.png" alt="橙色箭头:左指针的移动 蓝色箭头:右指针的移动"></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度由以下几个方面组成</p>
<ol>
<li>询问排序</li>
<li>同一个块内的暴力求解</li>
<li>左指针的移动(<del>横跳</del>)</li>
<li>右指针的顺次移动</li>
</ol>
<p>下面来 <del>不严谨</del> 简要地计算一下时间复杂度</p>
<ol>
<li><strong>排序</strong>:$O(n\log n)$</li>
<li><strong>暴力</strong>:暴力的区间最长为$\sqrt{n}$,所以单次暴力的复杂度为$O(\sqrt{n})$,$n$次暴力的复杂度为$O(n\sqrt{n})$<del>其实到不了n次</del></li>
<li><strong>左指针移动</strong>: 进行<code>add</code>操作的复杂度为$O(1)$,块长$\sqrt{n}$,每次左移最坏复杂度$O(\sqrt{n})$,回滚时仍需要$O(\sqrt{n})$清除贡献<br>所以对于所有块,一共要移动$q$次,总的复杂度为$O(2q\sqrt{n})$</li>
<li><strong>右指针移动</strong>: 对于每个块,最坏只要移动$n$次,一共$\sqrt{n}$个块,所以复杂度为$O(n\sqrt{n})$</li>
</ol>
<p>综上,总的复杂度为$O(n\log n)+O(2q\sqrt{n})+O(n\sqrt{n})\ \sim\ O(n\sqrt{n})$</p>
<h2 id="针对-mathcal-AT1219-的具体实现"><a href="#针对-mathcal-AT1219-的具体实现" class="headerlink" title="针对$\mathcal{AT1219}$的具体实现"></a>针对$\mathcal{AT1219}$的具体实现</h2><p>添加贡献的<code>add</code>操作很容易实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">    Ans = <span class="built_in">max</span>(Ans, <span class="number">1LL</span> * cnt[a[x]] * old[a[x]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一块内的暴力也很容易实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) cnt2[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        cnt2[a[i]]++;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1LL</span> * cnt2[a[i]] * old[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余情况下根据前面所说,可以实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);  <span class="comment">// 右指针右移,添加贡献</span></span><br><span class="line">LL tmp = Ans;                 <span class="comment">// 记录左指针移动前的答案</span></span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);  <span class="comment">// 左指针左移,添加贡献</span></span><br><span class="line">ans[q[i].id] = Ans;</span><br><span class="line"><span class="keyword">while</span> (l &lt; rpos[k] + <span class="number">1</span>) cnt[a[l++]]--; <span class="comment">// 左指针移动回右边界,并途中删除对cnt的贡献</span></span><br><span class="line">Ans = tmp;                    <span class="comment">// 回滚到移动前的答案</span></span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, len, l, r;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[maxn], rpos[maxn], old[maxn], cnt2[maxn];</span><br><span class="line">LL Ans, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, pos;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) cnt2[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        cnt2[a[i]]++;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1LL</span> * cnt2[a[i]] * old[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">    Ans = <span class="built_in">max</span>(Ans, <span class="number">1LL</span> * cnt[a[x]] * old[a[x]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(n); <span class="keyword">int</span> num = <span class="built_in">ceil</span>((<span class="keyword">double</span>)n / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) rpos[i] = len * i; rpos[num] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) old[i] = a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len_ = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len_, a[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(); q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i; q[i].pos = (q[i].l - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, i = <span class="number">1</span>; k &lt;= num; ++k) &#123;</span><br><span class="line">        l = rpos[k] + <span class="number">1</span>, r = rpos[k], Ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">        <span class="keyword">while</span> (q[i].pos == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].l / len == q[i].r / len) &#123;</span><br><span class="line">                ans[q[i].id] = <span class="built_in">solve</span>(q[i].l, q[i].r);</span><br><span class="line">                i++; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">            LL tmp = Ans;</span><br><span class="line">            <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">            ans[q[i].id] = Ans;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; rpos[k] + <span class="number">1</span>) cnt[a[l++]]--;</span><br><span class="line">            Ans = tmp; i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>带修莫队-笔记  /「Luogu P1903」数颜色-题解</title>
    <url>/p/838c5e29.html</url>
    <content><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/P1903">Luogu P1903 数颜色/维护序列</a>这道题目来学习一下 <strong>带修莫队</strong><br>顾名思义,<strong>带修莫队</strong> 不仅要支持普通莫队的查询操作,还要支持数据中途的修改</p>
<p>比如这道题目,需要实现以下目标</p>
<ol>
<li>查询$[L,R]$区间内不同颜色画笔的种数</li>
<li>将$pos$处的画笔替换为$color$颜色</li>
</ol>
<p>达到这个目标,可以在普通莫队的基础上加一个时间维度,实现 <strong>带修莫队</strong></p>
<span id="more"></span> 

<h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>这里的每个查询的时间戳规定为 <strong>最近修改操作的时间戳</strong>,即最近一次修改是第几次修改<br>修改操作会增加总时间戳,查询操作不会增加时间戳</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>在普通莫队的左右两个指针的基础之上 <em>增加</em> 一个 <strong>时间戳指针</strong><br>当左右端点及时间戳移动到均和当前查询的一致,就可以记录下当前答案</p>
<p>所以需要在普通莫队的基础之上加上修改时间戳的修改操作,并加上以下两个判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (t &lt; q[i].t) <span class="built_in">chg</span>(++t);</span><br><span class="line"><span class="keyword">while</span> (t &gt; q[i].t) <span class="built_in">chg</span>(t--);</span><br></pre></td></tr></table></figure>
<p>当当前时间小于询问时间时,先将当前时间$+1$,再修改<br>当当前时间大于询问时间时,先修改,再将当前时间$-1$</p>
<p>与普通莫队还有一点不同:<br>所有询问的排序方法,先按照左端点分块升序,再按照右端点 <strong>分块升序</strong>,最后按照时间戳升序<br>这样复杂度才会达到最优,节省了一系列不必要的操作</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>当分块的大小为$n^{\frac{2}{3}}$时,复杂度最小为$O(n^{\frac{5}{3}})$<br>具体分析见上一篇文章:<a href="681257d9.html">浅析莫队算法的时间复杂度</a></p>
<h2 id="针对-mathcal-P1903-的具体实现"><a href="#针对-mathcal-P1903-的具体实现" class="headerlink" title="针对$\mathcal{P1903}$的具体实现"></a>针对$\mathcal{P1903}$的具体实现</h2><p>在每个询问<code>Query</code>的结构体内加一个时间戳$t$,并且按照上文实现排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block[a.l] != block[b.l]) <span class="keyword">return</span> block[a.l] &lt; block[b.l];</span><br><span class="line">    <span class="keyword">if</span> (block[a.r] != block[b.r]) <span class="keyword">return</span> block[a.r] &lt; block[b.r];</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再建一个结构体<code>Change</code>,表示每次修改操作的数据,需要$pos$和$color$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, color;</span><br><span class="line">&#125;c[maxn];</span><br></pre></td></tr></table></figure>

<p>正常的<code>add/del</code>操作不再赘述<br>现在来看一下修改时间对应数据的操作</p>
<ol>
<li>当当前时间的操作的位置$pos$在当前区间$[l,r]$时,对答案有影响,需要调整当前答案<br>先将$pos$位置上的贡献删去,再将当前修改操作的$color$添加进去</li>
<li>将$pos$位置上的数与$color$交换,这样可以保证之后可以再换回来</li>
</ol>
<p>实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[a[c[t].pos]] == <span class="number">0</span>) Ans--; <span class="comment">// 删除贡献</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[c[t].color]++  == <span class="number">0</span>) Ans++; <span class="comment">// 添加贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].color); <span class="comment">// 交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外这题修改数据后严重卡常,手动开了O3,Ofast,inline才过</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">140000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, t, len, cntq, cntr, Ans;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[<span class="number">1000010</span>], ans[maxn], block[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block[a.l] != block[b.l]) <span class="keyword">return</span> block[a.l] &lt; block[b.l];</span><br><span class="line">    <span class="keyword">if</span> (block[a.r] != block[b.r]) <span class="keyword">return</span> block[a.r] &lt; block[b.r];</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, color;</span><br><span class="line">&#125;c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == <span class="number">0</span>) Ans++;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == <span class="number">1</span>) Ans--;</span><br><span class="line">    cnt[a[x]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) &#123;</span><br><span class="line">        <span class="built_in">del</span>(c[t].pos);</span><br><span class="line">        <span class="keyword">if</span> (cnt[c[t].color] == <span class="number">0</span>) Ans++;</span><br><span class="line">        cnt[c[t].color]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        block[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt[<span class="number">10</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            q[++cntq].l = <span class="built_in">read</span>(); q[cntq].r = <span class="built_in">read</span>();</span><br><span class="line">            q[cntq].id = cntq; q[cntq].t = cntr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[++cntr].pos = <span class="built_in">read</span>();</span><br><span class="line">            c[cntr].color = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + cntq, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q[i].t) <span class="built_in">chg</span>(++t);</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q[i].t) <span class="built_in">chg</span>(t--);</span><br><span class="line">        ans[q[i].id] = Ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析莫队算法的时间复杂度</title>
    <url>/p/681257d9.html</url>
    <content><![CDATA[<p>这篇文章来记录一下莫队算法时间复杂度的简单(<del>不严谨</del>)计算</p>
<p>首先分析一下莫队算法的时间复杂度有哪些方面构成</p>
<ol>
<li>对询问<code>Query</code>数组的排序</li>
<li>区间左指针的移动</li>
<li>区间右指针的移动<span id="more"></span> </li>
</ol>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>每个<code>add/del</code>操作的复杂度为$O(1)$</p>
<ol>
<li><p>排序使用<code>sort</code>可以在$O(n\log n)$内完成</p>
</li>
<li><p>由于左指针在排序中被分块,所以又分为块内移动和块间移动</p>
<ul>
<li><strong>块内</strong>: 设每块中含左端点$x_i$个,由于每块大小为$\sqrt{n}$,所以在块内移动的最坏复杂度为$O(x_i\sqrt{n})$。<br>因此对于所有块,将复杂度求和,即为$O(\displaystyle\sum_ix_i\sqrt{n})=O(n\sqrt{n})$</li>
<li><strong>块间</strong>: 左指针在每个块内移动之后,需要移动到下一个块内的左端点处,块间跳转最坏跨两个整块需要$O(2\sqrt{n})$。<br>总共需要跨$\sqrt{n}-1$个块,所以复杂度为$O((\sqrt{n}-1)\times 2\sqrt{n})\sim O(n)$</li>
</ul>
</li>
</ol>
<p>综上,左指针移动的复杂度为$O(n\sqrt{n})$<br>3. 当左指针在同一个块内时,右指针是有序的,因此当左指针在同一个块内时,右指针移动的最坏复杂度为$O(n)$即全部移动一遍。而每个块长度为$\sqrt{n}$,总长为$n$,所以一共$\sqrt{n}$个块,所以最坏复杂度为$O(n\sqrt{n})$</p>
<p>综上,普通莫队算法的时间复杂度为<br>$$<br>O(n\log n)+O(n\sqrt{n})+O(n\sqrt{n})\ \sim\ O(n\sqrt{n})<br>$$</p>
<h2 id="玄学的奇偶排序优化"><a href="#玄学的奇偶排序优化" class="headerlink" title="玄学的奇偶排序优化"></a><del>玄学</del>的奇偶排序优化</h2><p>见图:<br><img src="/p/681257d9/MosAlgoCompare.png" alt="左:无奇偶排序,右:有奇偶排序&lt;/br&gt;图中灰色虚线表示分块的边界;带端点的线段表示需要询问的区间;红色箭头表示两种方法右指针移动相同长度的部分;蓝色箭头表示不同的部分。可以看出,有奇偶排序的蓝色箭头变短,避免了无意义的大幅度跳动,节省了一些常数复杂度"></p>
<h2 id="分块大小不为-sqrt-n"><a href="#分块大小不为-sqrt-n" class="headerlink" title="分块大小不为$\sqrt{n}$"></a>分块大小不为$\sqrt{n}$</h2><p>还是和前面一样推复杂度,设块大小为$a&gt;1$</p>
<ol>
<li><strong>排序</strong>: 需要$O(n\log n)$</li>
<li><strong>左指针移动</strong>: <ul>
<li><strong>块内</strong>: $O(\displaystyle\sum_ix_ia)=O(na)$</li>
<li><strong>块间</strong>: $O((\dfrac{n}{a}-1)\times 2a)=O(n)$</li>
</ul>
</li>
<li><strong>右指针移动</strong>: $O(n\times \dfrac{n}{a})=O(\dfrac{n^2}{a})$</li>
</ol>
<p>综上,总的复杂度为$O(n\log n)+O(na)+O(n)+O(\dfrac{n^2}{a})=O(na+\dfrac{n^2}{a})$<br>根据均值不等式,若让上式复杂度最小,则需要$na=\dfrac{n^2}{a}$,即$a=\sqrt{n}$<br>所以当含有左右两个指针时,分块大小为$\sqrt{n}$时总复杂度最小,为$O(n\sqrt{n})$</p>
<h2 id="带修莫队-三指针"><a href="#带修莫队-三指针" class="headerlink" title="带修莫队(三指针)"></a>带修莫队(三指针)</h2><p>还是设分块的大小为$a&gt;1$,注意带修莫队排序优先级:先左端点所在块,再右端点所在块,后时间戳大小</p>
<ol>
<li><strong>排序</strong>: $O(n\log n)$</li>
<li><strong>左指针移动</strong>: 同上推导,复杂度为$O(na)$</li>
<li><strong>右指针移动</strong>: 相同右端点的块的复杂度同上$O(na)$,还有换左端点决定的块时的复杂度约为$O(\dfrac{n^2}{a})$</li>
<li><strong>时间戳移动</strong>: 由排序优先级可见,只有当右端点所在块相同时才会移动时间戳,而每次移动最坏需要移动$\sum t \sim n$<br>对于每个左端点相同的块,右端点块数为$\dfrac{n}{a}$,左端点有$\dfrac{n}{a}$个,所以一共需要$O(\dfrac{n}{a}\times\dfrac{n}{a}\times n)=O(\dfrac{n^3}{a^2})$</li>
</ol>
<p>综上,总的复杂度为$O(n\log n)+O(na)+O(na)+O(\dfrac{n^2}{a})+O(\dfrac{n^3}{a^2})\ \sim\  O(na+\dfrac{n^2}{a}+\dfrac{n^3}{a^2})$</p>
<p>由于$1&lt;a&lt;n$,所以$\dfrac{\dfrac{n^2}{a}}{\dfrac{n^3}{a^2}}=\dfrac{a}{n}&lt;1 \Rightarrow \dfrac{n^2}{a}&lt;\dfrac{n^3}{a^2}$,所以原式可化为$O(na+\dfrac{n^3}{a^2})$</p>
<p>根据均值不等式,当$na=\dfrac{n^3}{a^2}$时上式最小,即$a=\sqrt[3]{n^2}=n^{\frac{2}{3}}$<br>所以含有三个指针时,分块大小为$n^{\frac{2}{3}}$时总复杂度最小,为$O(n^{\frac{5}{3}})=O(n\sqrt[3]{n^2})$</p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」总结及图示</title>
    <url>/p/dccbc6bb.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">问题编号</th>
<th align="left">问题名称</th>
<th align="left">问题模型</th>
<th align="left">转化模型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2756">飞行员配对方案问题</a></td>
<td align="left">二分图最大匹配</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2762">太空飞行计划问题</a></td>
<td align="left">最大权闭合图</td>
<td align="left">网络最小割</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2764">最小路径覆盖问题</a></td>
<td align="left">有向无环图最小路径覆盖</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2765">魔术球问题</a></td>
<td align="left">有向无环图最小路径覆盖</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3254">圆桌问题</a></td>
<td align="left">二分图多重匹配</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2766">最长不下降子序列问题</a></td>
<td align="left">最多不相交路径</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2763">试题库问题</a></td>
<td align="left">二分图多重匹配</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2775">机器人路径规划问题</a></td>
<td align="left">$IDA*$</td>
<td align="left">$IDA*$</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2774">方格取数问题</a></td>
<td align="left">二分图点权最大独立集</td>
<td align="left">网络最小割</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P1251">餐巾计划问题</a></td>
<td align="left">线性规划网络优化</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2770">航空路线问题</a></td>
<td align="left">最长不相交路径</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2761">软件补丁问题</a></td>
<td align="left">最小转移代价</td>
<td align="left">最短路径</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2754">星际转移问题</a></td>
<td align="left">网络判定</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4011">孤岛营救问题</a></td>
<td align="left">分层图最短路径</td>
<td align="left">最短路径</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4009">汽车加油行驶问题</a></td>
<td align="left">分层图最短路径</td>
<td align="left">最短路径</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4013">数字梯形问题</a></td>
<td align="left">最大权不相交路径</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4015">运输问题</a></td>
<td align="left">网络费用流量</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">18</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4014">分配问题</a></td>
<td align="left">二分图最佳匹配</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">19</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4016">负载平衡问题</a></td>
<td align="left">最小代价供求</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4012">深海机器人问题</a></td>
<td align="left">线性规划网络优化</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">21</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3358">最长k可重区间集问题</a></td>
<td align="left">最大权不相交路径</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">22</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3357">最长k可重线段集问题</a></td>
<td align="left">最大权不相交路径</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">23</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3356">火星探险问题</a></td>
<td align="left">线性规划网络优化</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">24</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3355">骑士共存问题</a></td>
<td align="left">二分图最大独立集</td>
<td align="left">网络最小割</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><ul>
<li><strong>最大匹配</strong>: 匈牙利/最大流</li>
<li><strong>带权匹配</strong>: KM/费用流</li>
<li><strong>最小点覆盖</strong>: =最大匹配</li>
<li><strong>最小边覆盖</strong>: =总结点数-最大匹配</li>
<li><strong>最大独立集</strong>: =总结点数-最大匹配</li>
</ul>
<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul>
<li>建立超级源点,超级汇点</li>
<li>点存在限制,拆成出入点,将出入点之间的边看做点,限制流量</li>
<li>建图考虑左右二部</li>
<li>超级源点向源点的边可以限制总流量</li>
<li>无源汇有容量下界:<code>s-下界-&gt;v  u-下界-&gt;t  u-上界减下界-&gt;v</code>,当满流时存在可行流</li>
<li>最小割中赋流量为inf则一定不会割去</li>
<li>一些求最大问题,可以用sum-最小割</li>
<li>最大权闭合图: 建图,最小割,仍和s相连的为最大权闭合图,权值和为sum-最小割</li>
</ul>
<h3 id="24题"><a href="#24题" class="headerlink" title="24题"></a>24题</h3><ol>
<li>直接建二分图,最大流求最大匹配</li>
<li>最大权闭合图,建边,实验和仪器之间保证不切割容量为inf,跑最小割,找与s相连的实验和仪器</li>
<li>最大独立集,总结点数-最大流</li>
<li>贪心</li>
<li>二分图多重匹配,s-&gt;左点集和右点集-&gt;t之间的边容量不为1(即可以选多次)</li>
<li>动态规划+按照动态规划的dp数组的意义建边求最大流</li>
<li>二分图多重匹配,类型-题目数-&gt;汇点,保证可选多个,存在满流则存在答案沿满流输出</li>
<li>$IDA*$爆搜,但洛谷数据应该有问题</li>
<li>抽象出两个点集,求最大独立集</li>
<li>按照题目说明建图,跑费用流</li>
<li>按照题目说明建图,跑费用流</li>
<li>将错误状态进行压缩,然后跑最短路</li>
<li>根据时间逐层建图,直到跑出可行流</li>
<li>将拥有钥匙进行压缩,跑最短路</li>
<li>建出分层图,跑最短路或者费用流</li>
<li>对三个规则分别建图,跑费用流</li>
<li>纯费用流</li>
<li>二分图最佳匹配,使用费用流</li>
<li>费用流,注意环形</li>
<li>按照题目要求建图,跑费用流</li>
<li>离散化,将区间转化为边,费用流</li>
<li>转化问题,变成21题,注意端点处理和垂直于x轴的线段</li>
<li>按照题目要求建图,跑费用流,方案dfs</li>
<li>将图上所有格点转化为两个点集,建二分图,求最大独立集</li>
</ol>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><strong><del>更新中</del></strong><br><img src="/p/dccbc6bb/NF24P2762.png" alt="2"><br><img src="/p/dccbc6bb/NF24P2754.png" alt="13"><br><img src="/p/dccbc6bb/NF24P3358.png" alt="21"><br><img src="/p/dccbc6bb/NF24P3357.png" alt="22"></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1494」小Z的袜子-题解</title>
    <url>/p/49548215.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P1494">「Luogu P1494」小Z的袜子</a><br>一道推公式，后使用莫队 <del>玄学</del> 优化的题目</p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n$个袜子,第$i$只袜子的颜色为$c_i$<br>有$m$个询问,用$L,R$表示<br>在区间$[L,R]$中随机取袜子,求取出两只袜子颜色相同的概率(最简分数)</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑区间$[L,R]$,其中颜色为$A$的袜子有$a$只,颜色为$B$的袜子有$b$只$…$</p>
<p>取出两只袜子的总情况数为<br>$$C_{R-L+1}^2=\frac{(R-L+1)(R-L)}{2}$$<br>取出两只袜子颜色都为$A$的情况数为<br>$$C_a^2=\frac{a(a - 1)}{2}$$<br>所以,取出两只袜子颜色相同的情况数为<br>$$\sum_{i}C_i^2=C_a^2+C_b^2+…=\frac{a(a-1)}{2}+\frac{b(b-1)}{2}+…$$<br>所以最终的概率为<br>$$<br>\begin{aligned}<br>P&amp;=\frac{\displaystyle\sum_{i}C_i^2}{C_{R-L+1}^2}\\\\<br>&amp;=\dfrac{\dfrac{a(a-1)}{2}+\dfrac{b(b-1)}{2}+…}{ \dfrac{(R-L+1)(R-L)}{2} }\\\\<br>&amp;=\dfrac{a^2+b^2+…-a-b-…}{(R-L+1)(R-L)}\\\\<br>&amp;=\dfrac{\displaystyle\sum_ii^2-\displaystyle\sum_ii}{(R-L+1)(R-L)}\\\\<br>&amp;=\dfrac{\displaystyle\sum_ii^2-(R-L+1)}{(R-L+1)(R-L)}<br>\end{aligned}<br>$$<br>所以要求的就是$\displaystyle\sum_ii^2$,可以用莫队来维护区间平方和得到</p>
<p>对于最终结果的表达式,令$a=$分子,$b=$分母,求出$ab$的最大公约数,并除去<br>最终答案即为$a/b$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, pos, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">if</span> (a.pos &amp; <span class="number">1</span>) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    <span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span> &#123;</span></span><br><span class="line">    LL a, b;</span><br><span class="line">&#125;ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, Ans, len;</span><br><span class="line">LL c[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Ans -= cnt[c[x]] * cnt[c[x]];</span><br><span class="line">    cnt[c[x]]--;</span><br><span class="line">    Ans += cnt[c[x]] * cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Ans -= cnt[c[x]] * cnt[c[x]];</span><br><span class="line">    cnt[c[x]]++;</span><br><span class="line">    Ans += cnt[c[x]] * cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(); q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i; q[i].pos = q[i].l / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ans[q[i].id].a = <span class="number">0</span>; ans[q[i].id].b = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL a = Ans - (r - l + <span class="number">1</span>);</span><br><span class="line">        LL b = <span class="number">1LL</span> * (r - l + <span class="number">1</span>) * (LL)(r - l);</span><br><span class="line">        LL g = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">        ans[q[i].id].a = a / g;</span><br><span class="line">        ans[q[i].id].b = b / g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, ans[i].a, ans[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」负载平衡问题-题解</title>
    <url>/p/b8624866.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4016">「Luogu P4016」负载平衡问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$个环形的仓库,每个仓库存储一定数量的货物<br>货物可以在相邻仓库之间搬运,最终达到每个仓货物数量一样的效果</p>
<p>求最少搬运次数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看题解说可以用数学方法推导,但是在24题里还是选择用费用流水过</p>
<p>先求出平均数,即目标<br>然后将每个仓库的货物数减去平均数,得出需要移动的数量</p>
<ol>
<li>如果大于$0$,则从 源点 向 该仓库 建一条 <strong>容量为差值,费用为$0$</strong> 的边(需要转移出,对答案无贡献)</li>
<li>如果小于$0$,则从 该仓库 向 汇点 建一条 <strong>容量为差值绝对值,费用为$0$</strong> 的边(吸收这些货物,对答案无贡献)</li>
<li>从 每个仓库 向 相邻两个仓库 建一条 <strong>容量为$inf$,费用为$1$</strong> 的边(转移货物的数量无要求,对答案贡献为$1$)</li>
</ol>
<p>注意建边3.需要考虑环形<br>求出最小费用最大流,最小费用即为结果</p>
<p>因为费用流大前提是满足最大流,而且此图中源点出发的与流入汇点的边的容量和相等,所以最大流情况下一定会全部流过,即达到仓库货物数量平衡</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小费用最大流模板省去了</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">110</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        num[i] = <span class="built_in">read</span>(); tot += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tot /= n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] - tot &gt; <span class="number">0</span>) <span class="built_in">add</span>(s, i, num[i] - tot, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (num[i] - tot &lt; <span class="number">0</span>) <span class="built_in">add</span>(i, t, tot - num[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, i - <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(i - <span class="number">1</span>, i, inf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, n, inf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(n, <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」运输问题-题解</title>
    <url>/p/152673e9.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4015">「Luogu P4015」运输问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$m$个仓库,$n$个商店,每个仓库有$a_i$个货物,每个商店需要$b_i$个货物<br>需要从仓库运输货物到商店中,且第$i$个仓库运输到第$j$个商店费用为$c_{i,j}$</p>
<p>求最小费用和最大费用</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>和<a href="http://tony031218.github.io/p/11b1dcbd.html">P4015 分配问题</a>一样<br>将所有仓库和所有商店各分为一个点集</p>
<ol>
<li>从 源点 向 每个仓库 建一条 <strong>容量为货物个数$a_i$,费用为$0$</strong> 的边(有$a_i$个货物需要运出,且对答案无贡献)</li>
<li>从 每个商店 向 汇点 建一条 <strong>容量为货物个数$b_i$,费用为$0$</strong> 的边(需要$b_i$个货物,且对答案无贡献)</li>
<li>从 每个仓库 向 每个商店 建一条 <strong>容量为$inf$,费用为对应费用</strong> 的边(每个仓库可以运出的最多货物不限制,且对答案工作为对应费用)</li>
</ol>
<p>求出最小费用最大流和最大费用最大流即可</p>
<p>由于费用流的大前提是流量最大,所以一定满足题目中要求的供需平衡即$\sum\limits_{i=1}^{m}a_i=\sum\limits_{j=1}^{n}b_j$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 费用流模板省略,在P4015题解那里有</span></span><br><span class="line"><span class="comment">// 代码里为了方便把mn调换了</span></span><br><span class="line"><span class="keyword">int</span> input1[<span class="number">110</span>], input2[<span class="number">110</span>], input3[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n + m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>(); input1[i] = c;</span><br><span class="line">        <span class="built_in">add</span>(s, i, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>(); input2[i] = c;</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="built_in">read</span>(); input3[i][j] = c;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, inf, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(s, i, input1[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(i + n, t, input2[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, inf, input3[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」分配问题-题解</title>
    <url>/p/11b1dcbd.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4014">「Luogu P4014」分配问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$件工作要分配给$n$个人做<br>给出每个人做每个工件的效益$c_{i,j}$</p>
<p>求最小效益和最大效益</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的最小/大费用最大流<br>将所有人和所有工作各分为一个点集</p>
<ol>
<li>从 源点 向 所有人 建一条 <strong>容量为$1$,费用为$0$</strong> 的边(只能选一次,且对答案无贡献)</li>
<li>从 所有工作 向 汇点 建一条 <strong>容量为$1$,费用为$0$</strong> 的边(只能做一次,且对答案无贡献)</li>
<li>从 每个人 向 所有工作 建一条 <strong>容量为$1$,费用为对应效益</strong> 的边(只能做一种工作,且对答案工作为对应效益)</li>
</ol>
<p>求出最小费用最大流和最大费用最大流</p>
<p>两个问之间要清空图并重建(因为求最大流过程中会修改flow)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">0</span>) <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]]; <span class="keyword">bool</span> judge;</span><br><span class="line">            <span class="keyword">if</span> (opt) judge = d[e.to] &lt; d[x] + e.cost;</span><br><span class="line">            <span class="keyword">else</span> judge = d[e.to] &gt; d[x] + e.cost;</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; judge) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!opt &amp;&amp; d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt &amp;&amp; d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost, <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); s = <span class="number">0</span>; t = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="built_in">read</span>(); tmp[i][j] = c;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, <span class="number">1</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, <span class="number">1</span>, tmp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」数字梯形问题-题解</title>
    <url>/p/86b4c1f9.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4013">「Luogu P4013」数字梯形问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>梯形的第一行有$m$个数字<br>从梯形的顶部的$m$个数字开始,在每个数字处可以沿左下或右下方向移动,形成一条从梯形的顶至底的路径。</p>
<p>有三种规则:</p>
<ol>
<li>从梯形的顶至底的$m$条路径互不相交</li>
<li>从梯形的顶至底的$m$条路径仅在数字结点处相交</li>
<li>从梯形的顶至底的$m$条路径允许在数字结点相交或边相交</li>
</ol>
<p>求每种规则下经过数字的最大总和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很明显是 <strong>最大费用最大流</strong></p>
<h4 id="规则1"><a href="#规则1" class="headerlink" title="规则1."></a>规则1.</h4><p>路径不相交,即没有公共点,也就是每个点只能经过一次<br>将每个点拆成入点和出点,就可以通过控制出入点之间的容量控制经过次数</p>
<ol>
<li>从 源点 向 第一行的$m$个点的入点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 最后一行每个点的出点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 每个点的入点 向 每个点的出点 接一条 <strong>容量为$1$,费用为该点数字</strong> 的边(对答案贡献为该点数字)</li>
<li>从 每个点的出点 向 左下右下两个点的入点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
</ol>
<h4 id="规则2"><a href="#规则2" class="headerlink" title="规则2."></a>规则2.</h4><p>每条路径仅在数字节点相交,也就是不能有重边<br>无需拆点控制每个点经过的次数,只需给每条向左下右下的边的容量设为$1$,即只能经过一次</p>
<ol>
<li>从 源点 向 第一行的$m$个点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 最后一行每个点 接一条 <strong>容量为$inf$,费用为该点数字</strong> 的边(每个点可以使用多次)</li>
<li>从 每个点的 向 左下右下两个点 接一条 <strong>容量为$1$,费用为该点数字</strong> 的边</li>
</ol>
<h4 id="规则3"><a href="#规则3" class="headerlink" title="规则3."></a>规则3.</h4><p>边也可以重合,也就相当于没有规则,可以随意向左下右下走<br>只需将规则2.中建边3.的容量改成$inf$即可</p>
<p>对于每种情况,求出最大费用最大流,最大费用即为答案<br>注意求解规则2.3.之前要清空建的图</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大费用最大流模板部分省去了</span></span><br><span class="line"><span class="keyword">int</span> in[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="keyword">int</span> point[<span class="number">45</span>][<span class="number">45</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">read</span>(); n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            point[i][j] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 1</span></span><br><span class="line">    s = <span class="number">0</span>; t = cnt * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i] + cnt, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(point[i][j] + cnt, point[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(point[i][j] + cnt, point[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) </span><br><span class="line">            <span class="built_in">add</span>(point[i][j], point[i][j] + cnt, <span class="number">1</span>, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 2</span></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i], t, inf, in[n][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j], <span class="number">1</span>, in[i][j]);</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 3</span></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i], t, inf, in[n][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j], inf, in[i][j]);</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j + <span class="number">1</span>], inf, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」深海机器人问题-题解</title>
    <url>/p/cfb1d422.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4012">「Luogu P4012」深海机器人问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个$P\times Q$网格,机器人可以向北/东走,西南为$(0, 0)$,东北为$(Q, P)$<br>每个网格边上有生物标本,和价值<br>有$a$个起点,每个起点有不同的机器人个数<br>有$b$个终点,每个终点有不同的机器人个数作为目的地</p>
<p>求采集到生物标本的最高总价值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最大费用最大流</p>
<ol>
<li>每两个节点之间建一条 <strong>容量为$1$,费用为标本价值</strong> 的边,和一条 <strong>容量为$inf$,费用为$0$</strong> 的边(标本只能采集一次)</li>
<li>从 源点 向 每个起点 建一条 <strong>容量为机器人个数,费用为$0$</strong> 的边</li>
<li>从 每个终点 向 汇点 建一条 <strong>容量为机器人个数,费用为$0$</strong> 的边</li>
</ol>
<p>跑出最大费用最大流,最大费用即为结果</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p_, q_;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * q_ + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a_ = <span class="built_in">read</span>(), b_ = <span class="built_in">read</span>();</span><br><span class="line">    p_ = <span class="built_in">read</span>() + <span class="number">1</span>; q_ = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">    s = <span class="number">0</span>, t = p_ * q_ + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p_; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; q_; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j + <span class="number">1</span>), <span class="number">1</span>, w);</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j + <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q_; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p_; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(j, i), <span class="built_in">point</span>(j + <span class="number">1</span>, i), <span class="number">1</span>, w);</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(j, i), <span class="built_in">point</span>(j + <span class="number">1</span>, i), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">read</span>(), x = <span class="built_in">read</span>() + <span class="number">1</span>, y = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(s, <span class="built_in">point</span>(x, y), k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>() + <span class="number">1</span>, y = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">point</span>(x, y), t, r, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」孤岛营救问题-题解</title>
    <url>/p/5c532c45.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4011">「Luogu P4011」孤岛营救问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>起点为$(1,1)$,终点为$(n,m)$<br>有些格子上有若干个钥匙，两个格子之间可能有一堵墙或者一扇可以用对应钥匙打开的门<br>每次移动需要$1$个单位时间，其他动作不需要时间</p>
<p>求最少需要多少时间能从起点到达终点。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对拥有的钥匙状态进行压缩<br>从起点到终点跑bfs即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p, k;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn][maxn], key[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> keys, times;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k, <span class="keyword">int</span> t): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">keys</span>(k), <span class="built_in">times</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> skey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[<span class="number">1</span>][<span class="number">1</span>]; ++i) skey |= (<span class="number">1</span> &lt;&lt; (key[<span class="number">1</span>][<span class="number">1</span>][i] - <span class="number">1</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>, skey, <span class="number">0</span>)); vis[<span class="number">1</span>][<span class="number">1</span>][skey] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (u.x == n &amp;&amp; u.y == m) <span class="keyword">return</span> u.times;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> vx = u.x + go[k][<span class="number">0</span>], vy = u.y + go[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (vx &lt; <span class="number">1</span> || vx &gt; n || vy &lt; <span class="number">1</span> || vy &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> e = edge[u.x][u.y][vx][vy];</span><br><span class="line">            <span class="keyword">if</span> (e &lt; <span class="number">0</span> || (e &gt; <span class="number">0</span> &amp;&amp; !(<span class="number">1</span> &lt;&lt; (e - <span class="number">1</span>) &amp; u.keys))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> vkeys = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[vx][vy]; ++i) vkeys |= (<span class="number">1</span> &lt;&lt; (key[vx][vy][i] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> nxtkeys = u.keys | vkeys;</span><br><span class="line">            <span class="keyword">if</span> (vis[vx][vy][nxtkeys]) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">Node</span>(vx, vy, nxtkeys, u.times + <span class="number">1</span>));</span><br><span class="line">            vis[vx][vy][nxtkeys] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); p = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), x2 = <span class="built_in">read</span>(), y2 = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> g = <span class="built_in">read</span>();</span><br><span class="line">        edge[x1][y1][x2][y2] = ((g == <span class="number">0</span>) ? <span class="number">-1</span> : g);</span><br><span class="line">        edge[x2][y2][x1][y1] = edge[x1][y1][x2][y2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">        key[x1][y1][++cnt[x1][y1]] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>bfs</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」汽车加油行驶问题-题解</title>
    <url>/p/fab3e888.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4009">「Luogu P4009」汽车加油行驶问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个$N\times N$的网格,表示有加油站的位置<br>汽车要从$(1, 1)$走到$(N, N)$,装满油可以行驶$K$条边,且只能沿边行驶<br>服从以下规则</p>
<ol>
<li>可以无费用向右或向下走,但耗1点油</li>
<li>向左走或者向上走时需要付费用$B$,并耗1点油</li>
<li>在加油站处,若油没满,则必须付费用$A$,加满油</li>
<li>可在没有加油站的位置开设加油站,费用$C$,并加满油,付费$A$</li>
<li>在起点处,油量为$K$</li>
</ol>
<p>求出最小费用</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>明显是最小费用最大流(其实分层图最短路也可以解决,因为每条边的容量都为1)<br>分层建图,每层表示油量,第$0$层表示满油($K$),第$1$层表示油量为$K-1$,第$2$层表示油量为$K-2$,$…$</p>
<ol>
<li>对于每层每个节点,如果不是加油站,则从 该点 向 下一层的右边和下边的节点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边(规则1.)</li>
<li>对于每层每个节点,如果不是加油站,则从 该点 向 下一层的左边和上边的节点 接一条 <strong>容量为$1$,费用为$B$</strong> 的边(规则2.)</li>
<li>对于每个节点,如果是加油站,则从 第$0$层的该点 按照上两条建边</li>
<li>对于每个节点,如果是加油站,则从 除$0$层外的每层节点 向 第$0$层的该点 接一条 <strong>容量为$1$,费用为$A$</strong> 的边(规则3.)</li>
<li>对于每个节点,如果不是加油站,则从 第$K$层的该点 向 第$0$层的该点 接一条 <strong>容量为$1$,费用为$A+C$</strong> 的边(规则4.)</li>
<li>从 源点 向 第$0$层的$(1, 1)$节点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 每层的$(N, N)$节点 向 汇点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边(到终点不考虑油量)</li>
</ol>
<p>求出最小费用最大流即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, A, B, C;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * N + y + dep * N * N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = <span class="built_in">read</span>(); K = <span class="built_in">read</span>(); A = <span class="built_in">read</span>(); B = <span class="built_in">read</span>(); C = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; n = (K + <span class="number">1</span>) * N * N; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (in[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j, <span class="number">0</span>), <span class="number">1</span>, A);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; K; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in[i][j] &amp;&amp; k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i + <span class="number">1</span>, j, k + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j + <span class="number">1</span>, k + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i - <span class="number">1</span>, j, k + <span class="number">1</span>), <span class="number">1</span>, B);</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j - <span class="number">1</span>, k + <span class="number">1</span>), <span class="number">1</span>, B);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in[i][j]) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, K), <span class="built_in">point</span>(i, j, <span class="number">0</span>), <span class="number">1</span>, A + C);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="built_in">point</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">point</span>(N, N, k), t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长k可重线段集问题-题解</title>
    <url>/p/f48af49a.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3357">「Luogu P3357」最长k可重线段集问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个开线段的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开线段,组成集合$\mathbf{S}$<br>使对于任何一条直线$x=p$,满足$\mathbf{S}$中与$x=p$相交的线段数不超过$k$,且$\mathbf{S}$中开线段总长度最大</p>
<p>求最大的长度</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>和<a href="https://www.luogu.com.cn/problem/P3358">「Luogu P3358」最长k可重区间集问题</a>类似<br>仅修改一下区间的输入部分即可</p>
<p>将每条线段映射到x轴上,发现可能不对,因为可能会存在垂直于x轴的线段,像P3358一样建图会省略掉这条线段</p>
<p>所以要将每个点扩大一倍,将左右端点x坐标相同的区间$(x, x)$更改为$(2x, 2x+1)$,使得不存在与x轴垂直的线段<br>如果左右端点x坐标不相同,则将$(x_1, x_2)$更改为$(2x_1+1, 2x_2)$</p>
<p>大概就是这么个道理:<br><img src="/p/f48af49a/NF24P3357.png"></p>
<p>剩下的做法和<a href="https://www.luogu.com.cn/problem/P3358">P3358</a>一样,<a href="https://tony031218.github.io/2020/04/21/%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E6%9C%80%E9%95%BFk%E5%8F%AF%E9%87%8D%E5%8C%BA%E9%97%B4%E9%9B%86%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/">P3358题解</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;inter[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1020</span>], old[<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">long</span> <span class="keyword">long</span>)(a - c) * (a - c) + (<span class="keyword">long</span> <span class="keyword">long</span>)(b - d) * (b - d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_ = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">        inter[i].len = <span class="built_in">length</span>(a, b, c, d);</span><br><span class="line">        inter[i].l = a * <span class="number">2</span>;</span><br><span class="line">        inter[i].r = c * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == c) inter[i].r += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> inter[i].l += <span class="number">1</span>;</span><br><span class="line">        nums[i * <span class="number">2</span> - <span class="number">1</span>] = inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span>] = inter[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) old[i] = nums[i];</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) nums[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len, nums[i]) - old;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = nums[i * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        inter[i].r = nums[i * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; n = len + <span class="number">2</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(inter[i].l, inter[i].r, <span class="number">1</span>, inter[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长k可重区间集问题-题解</title>
    <url>/p/949e7ebf.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3358">「Luogu P3358」最长k可重区间集问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个开区间的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开区间,组成集合$\mathbf{S}$<br>使对于任何一个$x$,满足$\mathbf{S}$中包含$x$的区间数不超过$k$,且$\mathbf{S}$中开区间总长度最大</p>
<p>求最大的长度</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果两个区间没有重叠的话,则可以同时选择,在图上表现为串联<br>如果两个区间有重叠的话,则不能同时选择,在图上表现为并联(服从总流量的约束)<br>先对所有节点进行离散化,注意离散化前统计出区间的长</p>
<ol>
<li>从 源点 向 节点1 接一条 <strong>容量为$k$,费用为$0$</strong> 的边(最大容量为k,对答案无贡献)</li>
<li>从 每个节点$i$ 向 节点$i+1$ 接一条 <strong>容量为$inf$,费用为$0$</strong> 的边(可以随意通过,对答案无贡献)</li>
<li>从 最后一个节点 向 汇点 接一条 <strong>容量为$inf$,费用为$0$</strong> 的边(总流量有1.控制,对答案无贡献)(可以包含在2.里)</li>
<li>从 每个区间的左端点 向 其右端点 接一条 <strong>容量为$1$,费用为区间长</strong> 的边(只可用一次,对答案贡献为区间长度)</li>
</ol>
<p>求出最大费用最大流,最大费用即为最终的结果<br>样例的图如下:<br><img src="/p/949e7ebf/NF24P3358.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;inter[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1020</span>], old[<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_ = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = <span class="built_in">read</span>(); inter[i].r = <span class="built_in">read</span>();</span><br><span class="line">        inter[i].len = inter[i].r - inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span> - <span class="number">1</span>] = inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span>] = inter[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) old[i] = nums[i];</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) nums[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len, nums[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = nums[i * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        inter[i].r = nums[i * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; n = len + <span class="number">2</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(inter[i].l, inter[i].r, <span class="number">1</span>, inter[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」火星探险问题-题解</title>
    <url>/p/e7256d1.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3356">「Luogu P3356」火星探险问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$辆车,$p\times q$的网格<br>为0可以通过,1有障碍不能通过,2为岩石可以采集<br>从(1, 1)开始到最右下角,只能向右或向下</p>
<p>求出使到达终点的车最多,而且采集的岩石最多的移动方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每个位置拆成入点和出点</p>
<ol>
<li>如果这个位置是$0$或$2$, 则从 入点 向 出点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
<li>如果这个位置是$2$, 则从 入点 向 出点 接一条 <strong>容量为$1$, 费用为$1$</strong> 的边</li>
<li>如果这个位置$u$的右边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
<li>如果这个位置$u$的下边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
</ol>
<p>跑最大费用最大流,最大流数即到达终点最多的车数<br>输出方案使用dfs,在流量网络中搜索输出路径</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], pre[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; pre[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				pre[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[pre[u]].from) &#123;</span><br><span class="line">		edges[pre[u]].flow += a[t];</span><br><span class="line">		edges[pre[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, q;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * p + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> u, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        Edge&amp; ne = edges[G[u][i] ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (e.to == s || e.to == t || e.to == u - n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!e.flow) <span class="keyword">continue</span>;</span><br><span class="line">        e.flow--;</span><br><span class="line">        <span class="keyword">if</span> (e.to &gt; n) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y, e.to, id);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nx, ny, dir;</span><br><span class="line">        <span class="keyword">if</span> (e.to == <span class="built_in">point</span>(x, y) + <span class="number">1</span>) &#123;</span><br><span class="line">            nx = x; ny = y + <span class="number">1</span>;</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nx = x + <span class="number">1</span>; ny = y;</span><br><span class="line">            dir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id, dir);</span><br><span class="line">        <span class="built_in">dfs</span>(nx, ny, e.to + n, id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">read</span>(); p = <span class="built_in">read</span>(); q = <span class="built_in">read</span>();</span><br><span class="line">    n = p * q; s = <span class="number">0</span>; t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">0</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, inf, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in[<span class="number">1</span>][<span class="number">1</span>] != <span class="number">1</span>) <span class="built_in">add</span>(s, <span class="number">1</span>, c, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (in[i][j + <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; j + <span class="number">1</span> &lt;= p) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j) + n, <span class="built_in">point</span>(i, j + <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (in[i + <span class="number">1</span>][j] != <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= q) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j) + n, <span class="built_in">point</span>(i + <span class="number">1</span>, j), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in[q][p] != <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(q, p) + n, t, c, <span class="number">0</span>);</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d\n&quot;, ansflow, anscost);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ansflow; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>manim教程系列-颜色 笔记</title>
    <url>/p/2e2c9a7.html</url>
    <content><![CDATA[<p>这篇文章是在写 <strong>manim教程系列视频</strong> 的 <em>颜色</em> 部分时做的一些笔记,包括 整个视频的结构 和 写代码时了解的一些用法的笔记<br>视频已经发布,地址:<a href="https://www.bilibili.com/video/BV1vZ4y1x7hT">BV1vZ4y1x7hT</a></p>
<span id="more"></span>

<h2 id="视频结构大纲"><a href="#视频结构大纲" class="headerlink" title="视频结构大纲"></a>视频结构大纲</h2><ol start="0">
<li><input checked disabled type="checkbox"> 开头<ul>
<li>开始,标题,展示所有要将的方法</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 颜色的表示<ul>
<li>所有<code>constants.py</code>中的颜色常量</li>
<li>使用hex表示颜色</li>
<li>使用rgb的ndarray表示颜色</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 颜色之间的转换<ul>
<li><code>rgb_to_hex</code></li>
<li><code>hex_to_rgb</code></li>
<li><code>color_to_rgb</code></li>
<li><code>rgb_to_color</code></li>
<li><code>color_to_int_rgb</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 颜色的运算函数<ul>
<li><code>invert_color</code></li>
<li><code>color_gradient</code></li>
<li><code>interpolate_color</code></li>
<li><code>average_color</code></li>
<li><code>random_color</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 设置颜色<ul>
<li><code>Mobject</code>略,一般上色的都为<code>VMobject</code></li>
<li><code>color</code>分为<code>stroke_color</code>和<code>fill_color</code></li>
<li>传入<code>color</code>, <code>stroke_color</code>, <code>fill_color</code></li>
<li><code>set_color</code>, <code>set_stroke</code>, <code>set_fill</code>方法的<code>color</code>和<code>opacity</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 给子物体上色<ul>
<li><code>set_color</code></li>
<li><code>set_color_by_gradient</code></li>
<li><code>set_colors_by_radial_gradient</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 光泽与渐变色<ul>
<li><code>set_sheen</code></li>
<li><code>set_color</code>中使用列表达到渐变色</li>
</ul>
</li>
</ol>
<h2 id="一些码视频时的笔记"><a href="#一些码视频时的笔记" class="headerlink" title="一些码视频时的笔记"></a>一些码视频时的笔记</h2><ul>
<li><code>isinstance</code>函数检测对象的类型</li>
<li>对一个字符串进行format时,想要用空格补齐左边到一定个数,可以使用<code>str(...).rjust(num)</code></li>
<li>涉及到<code>Transform</code>Text的地方,在Text里面不可以有空格,需要用白色的<code>~</code>来做出伪空格</li>
<li>字符串中查找一个字符的下标可以用<code>.index(&quot; &quot;, beg=..., end=...)</code>方法来查找第一次出现的位置,第二次出现需要传入<code>beg</code>为第一次位置+1</li>
<li>manim的<code>rgb_to_color</code>函数传入的rgb的值为0<del>1,不是0</del>255</li>
<li>用for循环遍历字典键值对<code>for key, value in dic.items():</code>,遍历其中一部分<code>for key, value in list(dic.items())[1:3]</code>将键值对转化为列表,并用切片</li>
<li><code>Arrow</code>的箭头为<code>.tip</code></li>
<li><code>.keys(),.values()</code>不为列表,需要套在<code>list()</code>里面</li>
<li><code>set_colors_by_radial_gradient</code>利用中心与center的距离对颜色进行插值,radius外的所有子物体全为outer_color颜色</li>
<li>含有<code>sheen_factor</code>的物体设置渐变色后与sheen_factor无关</li>
</ul>
]]></content>
      <categories>
        <category>manim</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>manim</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」骑士共存问题-题解</title>
    <url>/p/11da5c27.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3355">「Luogu P3355」骑士共存问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n\times n$的棋盘,$m$个障碍(骑士不能放置)<br>求最多可以放多少个骑士,不能互相攻击</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先对棋盘进行黑白二染色,$x+y$为奇数和偶数为黑和白,求二分图最大独立集</p>
<ol>
<li>从 源点 向 黑色节点 接一条 <strong>容量为1</strong> 的边</li>
<li>从 白色节点 向 汇点 接一条 <strong>容量为1</strong> 的边</li>
<li>从 每个黑色节点 向 其能攻击到的白色节点接一条 <strong>容量为$inf$</strong> 的边</li>
</ol>
<p>求出最小割即最大流,结果为$\mathtt{n\times n - m - maxflow}$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">8</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> valid[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        valid[x][y] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!valid[i][j]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(s, <span class="built_in">point</span>(i, j), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!valid[i][j]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), t, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!((i + j) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = i + go[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny = j + go[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;= nx &amp;&amp; nx &lt;= n &amp;&amp; <span class="number">1</span> &lt;= ny &amp;&amp; ny &lt;= n &amp;&amp; !valid[nx][ny]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(nx, ny), inf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n * n - m - maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」圆桌问题-题解</title>
    <url>/p/25e68a12.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3254">「Luogu P3254」圆桌问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$m$个单位,$n$个餐桌<br>第$i$个单位的代表人数$r_i$, 第$i$张餐桌能容纳的人数$c_i$<br>同一个单位的代表不能在同一个餐桌</p>
<p>若有一种方案,输出$1$,并输出方案<br>若没有方案,输出$0$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>二分图,左点集为单位,右点集为餐桌,求其 <strong>最大匹配</strong></p>
<ol>
<li>对于每个单位,从 这个点 向 所有餐桌 接一条 <strong>容量为1</strong> 的边(即每个餐桌只能容纳同一个单位的一个人)</li>
<li>从 源点 向 每个单位 接一条 <strong>容量为单位人数</strong> 的边(即每个单位所有人都要参加)</li>
<li>从 每个餐桌 向 汇点 接一条 <strong>容量为餐桌人数</strong> 的边</li>
</ol>
<p>如果最大流和所有单位总人数相等,则有可行方案<br>对于每个单位,输出出边满足$\mathtt{e.cap == e.flow}$的$\mathtt{e.to-m}$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">450</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">read</span>(); n = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = m + n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, j + m, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">read</span>(); tot += r;</span><br><span class="line">        <span class="built_in">add</span>(s, i, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(i + m, t, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == tot) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; ++u) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.to != s &amp;&amp; e.cap == e.flow) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e.to - m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」方格取数问题-题解</title>
    <url>/p/40e04941.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2774">「Luogu P2774」方格取数问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$m$行$n$列的方格图,每个方格中有一个正整数<br>从方格中取数,任意两个数所在方格没有公共边<br>求取出的数的最大总和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先选择所有方格,然后考虑删去一些方格<br>相邻$-&gt;$奇偶性不同,构成一个二分图,含有两个点集</p>
<ol>
<li>从 源点 向 点集$A$ 接一条 <strong>容量为点权</strong> 的边</li>
<li>从 点集$B$ 向 汇点 接一条 <strong>容量为点权</strong> 的边</li>
<li>从 点集$A$中每个点 向 与其相邻的在点集$B$中的点 接一条 <strong>容量为$inf$</strong> 的边(保证不被割)</li>
</ol>
<p>求出最小割即最大流即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">read</span>(); n = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n * m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">read</span>(); tot += a;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">add</span>(s, <span class="built_in">point</span>(i, j), a);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = i + go[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = j + go[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;= nx &amp;&amp; nx &lt;= m &amp;&amp; <span class="number">1</span> &lt;= ny &amp;&amp; ny &lt;= n) &#123;</span><br><span class="line">                        <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(nx, ny), inf);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), t, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」航空路线问题-题解</title>
    <url>/p/6bb5462a.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2770">「Luogu P2770」航空路线问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个城市,$n$个点,$v$条边,每个城市有一个名字<br>从西向东按序给出名字<br>求从最西出发到达最东并返回最西(除起点外,每个城市只能访问一次)的路径</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每个城市拆成入点和出点</p>
<ol>
<li>源点为点1的入点,汇点为点n的出点</li>
<li>对于 <strong>除源点汇点</strong> 的每个点, 从 入点 向 出点 建一条 <strong>容量为1,费用为1</strong> 的边(只能经过一次,且对答案贡献为1)</li>
<li>从 点1的入点 向 点1的出点 建一条 <strong>容量为2,费用为1</strong> 的边(可以经过2次,且对答案贡献为1)</li>
<li>从 点n的入点 向 点n的出点 建一条 <strong>容量为2,费用为1</strong> 的边(可以经过2次,且对答案贡献为1)</li>
<li>对于边$&lt;u, v&gt;$, 从 u的出点 向 v的入点 建一条 <strong>容量为1,费用为0</strong> 的边(可经过1次,对答案无贡献)</li>
</ol>
<p>求 <strong>最大费用最大流</strong>, 最大流$maxflow\leq 2$</p>
<ol>
<li>若最大流为$2$, 则会有一条道路, 经过的城市数为最大费用$maxcost-2$(减去重复的源点和汇点的贡献)<br>求路径可以<ul>
<li>先一次dfs找到从1到n的所有残量为0的路径(满流$\mathtt{e.cap == e.flow}$),正序输出</li>
<li>再一次dfs找到另一条满流路径,并用vis确保没有重复城市,倒序输出(不重复输出n)</li>
</ul>
</li>
<li>若最大流为$1$, 则直接从源点到汇点有一条通路, 输出$2$, 路径为$1-&gt;n-&gt;1$</li>
<li>若最大流为$0$, 则无解$\texttt{No Solution!}$</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string name[maxn];</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    cout &lt;&lt; name[u - n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to &lt;= n &amp;&amp; e.cap == e.flow) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(e.to + n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to &lt;= n &amp;&amp; e.cap == e.flow &amp;&amp; !vis[e.to + n]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(e.to + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; name[u - n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">1</span>; t = <span class="number">2</span> * n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; name[i];</span><br><span class="line">        id[name[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        string str1, str2;</span><br><span class="line">        cin &gt;&gt; str1;</span><br><span class="line">        cin &gt;&gt; str2;</span><br><span class="line">        <span class="keyword">int</span> u = id[str1], v = id[str2];</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(u + n, v, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, i + n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(s, s + n, <span class="number">2</span>, <span class="number">1</span>); <span class="built_in">add</span>(n, t, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxflow == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">        cout &lt;&lt; name[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; name[n] &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; name[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Solution!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长不下降子序列问题-题解</title>
    <url>/p/a66cf8af.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2766">「Luogu P2766」最长不下降子序列问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定正整数序列$x_1, x_2, …, x_n$ </p>
<ol>
<li>计算其 <strong>最长不下降子序列</strong> 的长度$S$</li>
<li>如果每个元素只允许使用一次,计算从给定的序列中最多可取出多少个长度为$S$的不下降子序列</li>
<li>如果允许在取出的序列中多次使用$x_1$和$x_n$,其他元素仍然只允许使用一次,则从给定序列中最多可取出多少个 <strong>不同</strong> 的长度为$S$的不下降子序列</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h4><p>动态规划<br><strong>状态转移方程</strong>:$\mathtt{f[i]=max_{1≤j&lt;i&amp;&amp;x_j≤x_i}\{f[j]+1\}}$<br><strong>初值</strong>: $\mathtt{f[0]=0}$<br><strong>结果</strong>: $\mathtt{max_{1\leq i\leq n}f[i]}$</p>
<h4 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h4><p>将每个点(索引)拆成两个点<br>应用了分层图的思想, 把图每个顶点$\mathtt{i}$按照$\mathtt{f[i]}$的不同分为了若干层<br>这样图中从$s$出发到$t$的任何一条路径都是一个满足条件的最长上升子序列<br>由于序列中每个点要不可重复地取出,需要把每个点拆分成两个点<br>单位网络的最大流就是增广路的条数,所以最大流量就是第二问结果。</p>
<ol>
<li>从 源点 向 每个$\mathtt{f[i]==1}$的点i的左点 建一条 <strong>容量为1</strong> 的边</li>
<li>从 每个点的左点 向 其右点 建一条 <strong>容量为1</strong> 的边</li>
<li>从 $\mathtt{f[i]==S}$的点i的右点 向 汇点 建一条 <strong>容量为1</strong> 的边</li>
<li>对于$j&lt;i$,若$\mathtt{x_j\leq x_i &amp;&amp; f[i] == f[j] + 1}$,则从 点j的右点 向 点i的左点 建一条 <strong>容量为1</strong> 的边</li>
</ol>
<h4 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h4><p>要求$x_1$和$x_n$可以重复使用,只需取消这两个点相关边的流量限制,求网络最大流即可</p>
<ol>
<li>从 源点 向 点1的左点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>从 点1的左点 向 点1的右点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>若$\mathtt{f[n]==S}$则从 点n的左点 向 点n的右点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>若$\mathtt{f[n]==S}$则从 点n的右点 向 汇点 建一条 <strong>容量为$inf$</strong> 的边</li>
</ol>
<p>注意判断当$n==1$时的情况(第三问答案会出现$inf$)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">510</span>], dp[<span class="number">510</span>], ans1, ans2, ans3; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        num[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt;= num[i] &amp;&amp; dp[j] &gt; dp[i]) dp[i] = dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]++;</span><br><span class="line">        ans1 = <span class="built_in">max</span>(ans1, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 2</span></span><br><span class="line">    s = <span class="number">0</span>, t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dp[i] == <span class="number">1</span>) <span class="built_in">add</span>(s, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(i, i + n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dp[i] == ans1) <span class="built_in">add</span> (i + n, t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) </span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt;= num[i] &amp;&amp; dp[i] == dp[j] + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">add</span>(j + n, i, <span class="number">1</span>);</span><br><span class="line">    ans2 = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="number">1</span>, inf); <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span> + n, inf);</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == ans1) &#123;</span><br><span class="line">        <span class="built_in">add</span>(n, n + n, inf);</span><br><span class="line">        <span class="built_in">add</span>(n + n, t, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    ans3 = ans2 + <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」太空飞行计划问题-题解</title>
    <url>/p/f5a4cbbc.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2762">「Luogu P2762」太空飞行计划问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$m$个实验，每个实验只可以进行一次，但会获得相应的奖金<br>有$n$个仪器，每个实验都需要一定的仪器，每个仪器可以运用于多个实验，但需要一定的价值</p>
<p>问奖金与代价的差的最大值是多少？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol>
<li>从源点向每个实验建 <strong>容量为实验奖金</strong> 的边</li>
<li>从每个仪器向汇点建 <strong>容量为仪器费用</strong> 的边</li>
<li>实验向对应仪器建 <strong>容量为$inf$</strong> 的边(保证不被割)</li>
</ol>
<p>然后求最小割即最大流,只会割断 <strong>源-&gt;实验</strong> 或者 <strong>仪器-&gt;汇</strong> 的点<br>最后一次bfs后,仍和源相连的实验/仪器为要进行的实验/需要的仪器</p>
<p>最大收益为所有支付的费用之和减最大流</p>
<p>样例的建边见下图:<br><img src="/p/f5a4cbbc/NF24P2762.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> endr = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;\r&#x27;</span>) endr = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn], tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_ = <span class="built_in">read</span>(), n_ = <span class="built_in">read</span>();</span><br><span class="line">    n = m_ + n_ + <span class="number">2</span>; s = <span class="number">0</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">read</span>(); tot += p;</span><br><span class="line">        <span class="built_in">add</span>(s, i, p);</span><br><span class="line">        <span class="keyword">char</span> tools[<span class="number">10000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(tools, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tools));</span><br><span class="line">        cin.<span class="built_in">getline</span>(tools, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">int</span> ulen = <span class="number">0</span>, tool;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">sscanf</span>(tools + ulen, <span class="string">&quot;%d&quot;</span>, &amp;tool) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, tool + m_, inf);</span><br><span class="line">            <span class="keyword">if</span> (tool == <span class="number">0</span>) </span><br><span class="line">                ulen++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (tool) &#123;</span><br><span class="line">                    tool /= <span class="number">10</span>;</span><br><span class="line">                    ulen++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ulen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(i + m_, t, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i + m_]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」软件补丁问题-题解</title>
    <url>/p/2f9adffb.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2761">「Luogu P2761」软件补丁问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$n$个错误,$m$个补丁</p>
<p>第$i$个补丁耗时$t_i$<br>使用该补丁需要软件中包含所有$B1_i$中的错误,并且不包含$B2_i$中的任何一个错误<br>该补丁可以修复错误$F1_i$,但会添加错误$F2_i$</p>
<p>找出修复所有错误的最短时间</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>错误较少,可以使用状态压缩,用2进制表示错误的修复情况(1表示未修复,0表示已修复)<br>起始状态$\texttt{111…1}$,结束状态$\texttt{000…0}$</p>
<p>每个状态当做图中的节点,即求起始状态到结束状态的最短路</p>
<p>由于补丁较少,不用连边,在最短路需要遍历边时,遍历所有补丁,并判断是否能够联通(即当前状态是否包含该补丁的$B1$,而不包含$B2$)<br>如果能够连接,则下一个状态为当前状态打上当前补丁(即修复$F1$,添加$F2$)<br>边权为当前补丁的耗时<br>使用SPFA跑最短路即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;0&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLL</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> b1, b2;</span><br><span class="line">    <span class="keyword">int</span> f1, f2;</span><br><span class="line">&#125;node[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((u &amp; node[i].b1) == node[i].b1 &amp;&amp; (u &amp; node[i].b2) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = ((u | node[i].f1) | node[i].f2) ^ node[i].f1;</span><br><span class="line">                <span class="keyword">if</span> (dis[v] &gt; dis[u] + node[i].time) &#123;</span><br><span class="line">                    dis[v] = dis[u] + node[i].time;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                        vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        node[i].time = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sta = <span class="built_in">read_</span>();</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">1</span>) node[i].b1 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">2</span>) node[i].b2 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sta = <span class="built_in">read_</span>();</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">2</span>) node[i].f1 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">1</span>) node[i].f2 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SPFA</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[t] == inf ? <span class="number">0</span> : dis[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」家园/星际转移问题-题解</title>
    <url>/p/af442de1.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2754">「Luogu P2754」家园/星际转移问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>1个地球,$n$个太空站,1个月球,$k$个人<br>$m$艘船,第$i$艘容纳$h_i$个人,停靠$r_i$站,分别为$S_{i,j}$,每次耗时1<br>初始人全在地球,结束人全在月球</p>
<p>求最短时间</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先根据输入的停靠位置,建立并查集,若地月不连通,则无解,输出$0$</p>
<p>再根据时间建边,时间每增加1,增加一层,求一次最大流,添加进答案<br>当答案大于$k$时,即可全部到达月球</p>
<p>样例的建图是这样:<br><img src="/p/af442de1/NF24P2754.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], ans, cur[maxn];</span><br><span class="line"><span class="keyword">int</span> ufs[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ufs[x] == x) ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) ufs[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); <span class="keyword">int</span> k = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) ufs[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        S[<span class="number">0</span>][i] = <span class="built_in">read</span>(); S[i][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= S[i][<span class="number">0</span>]; ++j) &#123;</span><br><span class="line">            S[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (S[i][j] == <span class="number">-1</span>) S[i][j] = n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">1</span>) <span class="built_in">unionn</span>(S[i][j], S[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(s) != <span class="built_in">find</span>(t)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">1</span>; ; ++time) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), i + time * (n + <span class="number">2</span>), inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(n + <span class="number">1</span> + time * (n + <span class="number">2</span>), n + <span class="number">1</span> + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), inf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (time - <span class="number">1</span>) % S[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">add</span>(S[i][tmp] + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), S[i][time % S[i][<span class="number">0</span>] + <span class="number">1</span>] + time * (n + <span class="number">2</span>), S[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">dinic</span>(s, t);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= k) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」餐巾计划问题-题解</title>
    <url>/p/93562de2.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P1251">「Luogu P1251」餐巾计划问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>在$N$天里,第$i$天需要$r_i$个餐巾</p>
<ol>
<li>可以购买餐巾,每张$p$元</li>
<li>可以将旧送快洗,$m$天,费用$f$元</li>
<li>可以将旧送慢洗,$n$天,费用$s$元</li>
<li>每天结束,可以送快洗,慢洗,保存</li>
</ol>
<p>设计最小花费</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每天拆成2个点(早晚),新建源点汇点(源点表示获得,汇点表示使用)</p>
<ol>
<li>每天早上的点,向汇点连 <strong>容量为$r_i$,费用为$0$</strong> 的边,表示当日需要使用</li>
<li>源点向每天晚上的点连 <strong>容量为$r_i$,费用为$0$</strong> 的边,每天晚上获得多少旧餐巾</li>
<li>源点向每天早上的点连 <strong>容量为$inf$,费用为$p$</strong> 的边,表示购买</li>
<li>每天晚上向$+m$天的早上连 <strong>容量为$inf$,费用为$f$</strong> 的边,表示快洗</li>
<li>每天晚上向$+n$天的早上连 <strong>容量为$inf$,费用为$s$</strong> 的边,表示快洗</li>
<li>每天晚上向第二天晚上连 <strong>容量为$inf$,费用为$0$</strong> 的边,表示保留</li>
</ol>
<p>跑最小费用最大流</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow, r[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = inf;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>(); s = <span class="number">0</span>; t = <span class="number">2</span> * N + <span class="number">1</span>;</span><br><span class="line">    n = t + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        r[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(s, i + N, r[i], <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i, t, r[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pr = <span class="built_in">read</span>(), t1 = <span class="built_in">read</span>(), c1 = <span class="built_in">read</span>(), t2 = <span class="built_in">read</span>(), c2 = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N) <span class="built_in">add</span>(i + N, i + N + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + t1 &lt;= N) <span class="built_in">add</span>(i + N, i + t1, inf, c1);</span><br><span class="line">        <span class="keyword">if</span> (i + t2 &lt;= N) <span class="built_in">add</span>(i + N, i + t2, inf, c2);</span><br><span class="line">        <span class="built_in">add</span>(s, i, inf, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2019」题解</title>
    <url>/p/7d7252b1.html</url>
    <content><![CDATA[<pre><code>~~今年的题真是毒瘤~~,一个蒟蒻要来写题解了
</code></pre>
<p>校门外有两棵树,一棵叫括号树一棵叫树上的数,这两棵树要被一匹叫格雷的马划分开为Emiya做饭,这两棵树问:那你猜猜我们的重心在哪啊</p>
<span id="more"></span>

<h2 id="D1T1-格雷码"><a href="#D1T1-格雷码" class="headerlink" title="$D1T1$ 格雷码"></a>$D1T1$ <a href="https://www.luogu.org/problem/P5657">格雷码</a></h2><h3 id="沙雕暴力dfs-我的做法"><a href="#沙雕暴力dfs-我的做法" class="headerlink" title="沙雕暴力dfs(我的做法)"></a><del>沙雕</del>暴力<code>dfs</code>(我的做法)</h3><p>考场上真是脑残了,拿dfs模拟,忘了二分的事了,还传了四个参数<br>注意:<strong>一定要用<code>unsigned long long</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ull x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">ull n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ull n, ull k, ull rev, ull from)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)) - <span class="number">1LL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k, <span class="number">1LL</span>, <span class="number">0LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">1</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k - (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)), <span class="number">1LL</span>, <span class="number">1LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">1</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k - (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)), <span class="number">0LL</span>, <span class="number">1LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k - (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)), <span class="number">0LL</span>, <span class="number">1LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k - (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)), <span class="number">1LL</span>, <span class="number">1LL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">dfs</span>(n, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 55ms 812kB */</span></span><br></pre></td></tr></table></figure>

<h3 id="二分模拟-lyd-巨佬的做法"><a href="#二分模拟-lyd-巨佬的做法" class="headerlink" title="二分模拟($lyd$巨佬的做法)"></a>二分模拟($lyd$巨佬的做法)</h3><p>考前做过一道类似的题,但可惜我忘了<br>$lyd$巨佬说他这题只做了15分钟</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n,k;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> two[<span class="number">65</span>];</span><br><span class="line"><span class="keyword">int</span> change=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	two[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">63</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		two[i]=two[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;=two[n<span class="number">-1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!change)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">				change^=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			k-=two[n<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(change)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">				change^=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 57ms 928kB */</span></span><br></pre></td></tr></table></figure>

<h3 id="位运算正解"><a href="#位运算正解" class="headerlink" title="位运算正解"></a>位运算正解</h3><p>格雷码的规律就是<br>第$i$位为$k\ xor\ \lfloor\frac{k}{2}\rfloor$的第$i$位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %llu&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    k ^= (k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (k &gt;&gt; n &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 54ms 932kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T2-括号树"><a href="#D1T2-括号树" class="headerlink" title="$D1T2$ 括号树"></a>$D1T2$ <a href="https://www.luogu.org/problem/P5658">括号树</a></h2><p>后面的先咕着,等着补</p>
<h2 id="D1T3-树上的数"><a href="#D1T3-树上的数" class="headerlink" title="$D1T3$ 树上的数"></a>$D1T3$ <a href="https://www.luogu.org/problem/P5659">树上的数</a></h2><h2 id="D2T1-Emiya-家今天的饭"><a href="#D2T1-Emiya-家今天的饭" class="headerlink" title="$D2T1$ $Emiya$家今天的饭"></a>$D2T1$ <a href="https://www.luogu.org/problem/P5664">$Emiya$家今天的饭</a></h2><h2 id="D2T2-划分"><a href="#D2T2-划分" class="headerlink" title="$D2T2$ 划分"></a>$D2T2$ <a href="https://www.luogu.org/problem/P5665">划分</a></h2><h2 id="D2T3-树的重心"><a href="#D2T3-树的重心" class="headerlink" title="$D2T3$ 树的重心"></a>$D2T3$ <a href="https://www.luogu.org/problem/P5666">树的重心</a></h2>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>CSP-S</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2019」自闭游记</title>
    <url>/p/1901119c.html</url>
    <content><![CDATA[<p>这次大概是第二年参加信息竞赛了(<del>虽然去年什么也不会就摸了110分,省四</del>)<br>按照惯例,该写篇游记(<del>流水账</del>)了</p>
<span id="more"></span>

<h2 id="Day-7-sim-2"><a href="#Day-7-sim-2" class="headerlink" title="$Day\ \  -7\sim -2$"></a>$Day\ \  -7\sim -2$</h2><p>本来还是挺有信心的,校内几十次模拟赛考自闭了,想想复赛结束后周一周二就要期中考试(<del>其实是”贴心”的年级组特意为我们OIer调的</del>)更自闭了<br>晚饭回来后,几个沙雕朋友听说我自闭了,围了一圈给我来了一遍<a href="https://www.bilibili.com/video/av53058902?from=search&seid=3943401388874538351">奥利给</a>,真的感动<br>回家和父母商量好,签了个申请书脱了一周产,还说让我专心学信息,期中考试先放下</p>
<p>脱产的时光还是很快乐的<br>早上六点多到校就开始整理模板,刷模板题<br>老师到了之后花三个半小时做模拟题<br>下午自习和$zty$巨佬研究问题<br>四天就这么过去了,打了一本子模板带去省城复习</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="$Day\ \ -1$"></a>$Day\ \ -1$</h2><p>上午十一点和机房$wjh$,$mjc$,$lyd$(<del>lyd AK IOI</del>)出发去车站了<br>还是去年的时间,还是去年的$KFC$,还是去年的垃圾笔记本<br>看的是累积了一年的数千行模板和经验</p>
<p>中午到了去年同样的酒店,晚上去了去年同样的吉大日新楼吃饭<br>回到酒店,$lyd$巨佬给同学讲爆搜技巧,$zyc$学长像去年一样来探望<del>苦逼的</del>$yzOIer$<br>睡前敲了一堆板子:快读,vim配置,ST表,树状数组,Trie树,树的重心,树的直径</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="$Day\ \ 1$"></a>$Day\ \ 1$</h2><p>还是在去年的等候室</p>
<p>进考场<br>$???$这防窥膜是什么鬼,什么都挡不了的好吧,看着还超难受<br>前排的灯也没有开,没开考眼睛就生疼</p>
<h3 id="Day1-T1"><a href="#Day1-T1" class="headerlink" title="$Day1\ T1$"></a>$Day1\ T1$</h3><p>看见题目,emmm怎么做都告诉你了,开个数组<code>reverse</code>模拟呗…<br>emmm不对,数组的话貌似要开$2^64$,不行不行<br>推规律,好像也就那么个意思,<code>dfs</code>模拟!!<br>然后一顿乱搞,dfs传值从2到3到4,写了好几十行<code>dfs</code><br>跑一边样例,没问题,大样例??好像爆了,改<code>long long</code>…照样爆<br>看一眼时间,艹一个小时了,得了得了,不改了</p>
<p>看完第二题,不行不行,得改完,$2^64$?不是<code>unsigned long long</code>吗<br>又加了常数的转换操作,大概可以了</p>
<p>此时一个半小时过去了…</p>
<h3 id="Day1-T2"><a href="#Day1-T2" class="headerlink" title="$Day1\ T2$"></a>$Day1\ T2$</h3><p>emmm括号匹配,靠前看过类似的,好像得用栈<br>一顿乱搞,发现审错题了…<br>树上??我应该不会,做链的小数据$35$分得了<br>自己出了几个样例(其实是没发现大样例有链上情况),用了$multiset,stack$乱搞,都过了,就扔下去看第三题了</p>
<h3 id="Day1-T3"><a href="#Day1-T3" class="headerlink" title="$Day1\ T3$"></a>$Day1\ T3$</h3><p>题目绕了十分多种,看了好几遍样例才明白题干<br>这咋做啊,正解肯定不会,链和菊花图想了半个多小时没想出来</p>
<p>最后剩二十分钟了,不还是有$n!$的暴力$10$分吗<br>飞速写完代码,编译…<code>vector</code>没有???不应该啊,改了好多遍也过不了,拉倒,随机数吧…随机数概率太小,从$1\sim n$依次输出..</p>
<p><del>其实编译没过是没有加<code>using namespace std;</code></del></p>
<p>中午老师请客去了去年同样的饭店,下午去了去年同样的欢乐城放松<del>自暴自弃</del><br>$day1$估分$135$,完了,明天得考一百多分才稳…</p>
<p>晚上睡前又看了看一天什么没用上的模板</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="$Day\ \ 2$"></a>$Day\ \ 2$</h2><p>在等候室看了树的重心,树的直径的模板<br>我跟lyd说:昨天没考,今天肯定有</p>
<h3 id="Day2-T1"><a href="#Day2-T1" class="headerlink" title="$Day2\ T1$"></a>$Day2\ T1$</h3><p>认真的审了题,想要$AC$<br>画了样例的图,woc二分图,网络流???<br>完了完了,考前没看,扔下一个$32$分$n!$暴力溜了</p>
<p><del>其实已经花了一个小时了</del></p>
<h3 id="Day2-T3"><a href="#Day2-T3" class="headerlink" title="$Day2\ T3$"></a>$Day2\ T3$</h3><p>第二题没看懂题面,看到第三题题目我就来了<br>$???$这个重心定义和我复习的不一样,大体思想差不多,开写</p>
<p>改了模板,写了上去,发现分割树???以前没做过,只好重新建图,删一条边建一次图<del>辣鸡效率</del><br>跑完???重心全是$2$,查了半天发现两棵树的节点数没处理…<br>改过来之后前几个点$25$分应该是没问题了</p>
<p>简单推了下链和完美二叉树,没推出来,放弃…<br>考试结束前也没想出来</p>
<h3 id="Day2-T2"><a href="#Day2-T2" class="headerlink" title="$Day2\ T2$"></a>$Day2\ T2$</h3><p>照着样例看了十分钟才明白题目啥意思<br>感觉应该是$DP$,但蒟蒻不会$DP$啊<br>算了,瞎写个状态转移方程吧,乱搞…<br>发现不是最优解,然后处理分块还有贪心什么的<br>改了一个小时还是不对,心想算了,爆零了,1=无缘了,又回去推链的重心</p>
<p>考试结束前,准备提交代码,把这题中间几行没用的删了删(<del>删少了几行</del>),再跑一遍,奇迹般的对了<br>测了一下几个样例,$0\to 64\ \ ???$</p>
<p>估分$100+35+0+32+64+25=256$,有点悬</p>
<p>下午刷洛谷,<code>橙蓝黑紫黑紫</code>…炸了(<del>现在掉色了</del>)<br><img src="https://i0.hdslb.com/bfs/album/cc13d523f06cd8315aed8d91a83f36d030bd0b73.jpg" alt="橙蓝黑紫黑紫"><br>晚上从车站回家在大雪里打车半个小时,到家颓废,第二天的期中彻底放弃</p>
<h2 id="Day-3-sim-4"><a href="#Day-3-sim-4" class="headerlink" title="$Day\ \ 3\sim 4$"></a>$Day\ \ 3\sim 4$</h2><p>期中考试<br>第一天开幕雷击,语文古文没背过,作文主旋律,然后三科一个月没学的文科,还有什么都没复习的英语</p>
<p>回家,老师传了公示代码,去$luogu$民间数据自测<br>$Day1\ T2\ \ 35\to 0\ 256\to 221$ 1=没希望,彻底自闭了,要$AFO$了</p>
<h2 id="Day-5-sim-6"><a href="#Day-5-sim-6" class="headerlink" title="$Day\ \ 5\sim 6$"></a>$Day\ \ 5\sim 6$</h2><p>中午去机房把东西收拾到小屋里,$zty,lyd$巨佬已经开始准备省选<br>期中成绩陆续出来了,总体来说还可以</p>
<p>中午和$zty$用<a href="https://github.com/Sojiv/Project_lemon">lemon</a>把全省代码拿民间数据跑了一遍,排名还可以,貌似还有希望</p>
<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>虽然考的很水,但学$OI$我绝不后悔<br>接下来要努力捡起文化课了</p>
<blockquote>
<p>文化课虽说恶心，但只有一年，一年完了就能读大学了，高考就与你无关了。 —$zcysky$</p>
</blockquote>
<p>加油!奥利给!!</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>游记</tag>
        <tag>CSP-S</tag>
      </tags>
  </entry>
  <entry>
    <title>「图论算法」树上并查集 dsu on tree</title>
    <url>/p/da7e0a9d.html</url>
    <content><![CDATA[<p>$dsu\ on\ tree$($disjoint\ set\ union\ \text{on tree}$)算法，也称 __树上并查集__。使用了并查集的<em>按秩合并</em>(<strong>启发式合并</strong>)的方法，结合 <em>树链剖分</em> 中的 <strong>轻重儿子划分</strong> ，对 <strong>树上暴力统计</strong> 进行了优化。使用这个算法需要满足以下两个条件：</p>
<span id="more"></span>

<ul>
<li>每次只对子树进行查询</li>
<li>过程中没有对树的修改</li>
</ul>
<p>可以将$O(n^2)$的暴力操作优化到$O(n\log_2n)$</p>
<h2 id="pre-树链剖分-轻重链划分"><a href="#pre-树链剖分-轻重链划分" class="headerlink" title="$pre.\ $树链剖分 - 轻重链划分"></a>$pre.\ $树链剖分 - 轻重链划分</h2><p>在$dsu\ on\ tree$算法中，只需要统计出每个节点的<em>轻重儿子</em>，而不需要划分轻重链，所以我们只需要树链剖分中的$\texttt{dfs1()}$，并且只保留和轻重儿子有关的操作即可</p>
<blockquote>
<p>关于 <strong>轻重儿子</strong> ：</p>
<ul>
<li>一个节点的所有子节点中，子树所含节点个数最多的子节点称为 <strong>重儿子</strong></li>
<li>除重儿子外，一个节点的其余儿子均为 <strong>轻儿子</strong></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>; <span class="comment">// 以x为根的子树大小初始化为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.to, x);</span><br><span class="line">        siz[x] += siz[e.to]; <span class="comment">// 加上子节点的大小</span></span><br><span class="line">        <span class="keyword">if</span> (siz[e.to] &gt; siz[son[x]]) &#123;</span><br><span class="line">            son[x] = e.to; <span class="comment">// 更新重儿子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="I-算法流程"><a href="#I-算法流程" class="headerlink" title="$I.\ $算法流程"></a>$I.\ $算法流程</h2><p>对于每一个节点$x$:</p>
<ul>
<li>遍历所有子节点<ul>
<li>递归计算所有轻儿子的子树，并删除其对答案的贡献</li>
</ul>
</li>
<li>递归计算重儿子，保留对答案的贡献</li>
<li>统计所有轻儿子对答案的贡献</li>
<li>更新节点答案</li>
</ul>
<p>伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (all edge from x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(e.to, x, <span class="number">0</span>); <span class="comment">// 暴力统计轻儿子的子树的贡献，并删除(opt=0)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) <span class="built_in">dfs</span>(son[x], x, <span class="number">1</span>); <span class="comment">// 统计重儿子的贡献，不删除</span></span><br><span class="line">    <span class="built_in">upd</span>(x); <span class="comment">// 暴力统计该节点所有轻儿子的贡献</span></span><br><span class="line">    ans[x] = now; <span class="comment">// 更新答案</span></span><br><span class="line">    <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">        <span class="built_in">del</span>(x); <span class="comment">// 删除需要删除的贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(x); <span class="comment">// 计算当前答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == Son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">upd</span>(e.to, x, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于暴力统计的只是轻儿子，而每个节点的轻儿子不超过$\log_2n$个，所以整个算法复杂度保证在了$O(n\log_2n)$</p>
<h2 id="II-模板题"><a href="#II-模板题" class="headerlink" title="$II.\ $模板题"></a>$II.\ $模板题</h2><p><a href="https://www.luogu.org/problemnew/solution/CF600E">$CodeForces\ 600E\ \ Lomsat\ gelral$</a> </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Mx, Son, col[maxn], son[maxn], siz[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.to, x);</span><br><span class="line">        siz[x] += siz[e.to];</span><br><span class="line">        <span class="keyword">if</span> (siz[e.to] &gt; siz[son[x]]) &#123;</span><br><span class="line">            son[x] = e.to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cnt[col[x]] += val;</span><br><span class="line">    <span class="keyword">if</span> (cnt[col[x]] &gt; Mx) &#123;</span><br><span class="line">        Mx = cnt[col[x]];</span><br><span class="line">        sum = col[x];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[col[x]] == Mx) &#123;</span><br><span class="line">        sum += (<span class="keyword">long</span> <span class="keyword">long</span>)col[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == Son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Add</span>(e.to, x, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.to != son[x]) <span class="built_in">dfs2</span>(e.to, x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x], x, <span class="number">1</span>);</span><br><span class="line">        Son = son[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Add</span>(x, fa, <span class="number">1</span>); Son = <span class="number">0</span>;</span><br><span class="line">    ans[x] = sum;</span><br><span class="line">    <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">        <span class="built_in">Add</span>(x, fa, <span class="number">-1</span>);</span><br><span class="line">        sum = <span class="number">0</span>, Mx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        col[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>图论</tag>
        <tag>dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1993」小K的农场-题解 &amp; 差分约束系统</title>
    <url>/p/6dcf876e.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problem/P1993">「Luogu P1993」小K的农场</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$m$个约束条件,$n$个农场<br>有三种条件,其中$a,b$表示编号为$a,b$的农场的植物个数</p>
<ol>
<li>$a-b≥c$</li>
<li>$a-b≤c$</li>
<li>$a=b$<br>求是否存在一种方案,使农场中的植物数满足约束要求</li>
</ol>
<h3 id="I-差分约束系统"><a href="#I-差分约束系统" class="headerlink" title="$I.$ 差分约束系统"></a>$I.$ 差分约束系统</h3><p>以第$1$种约束为例:<br>$$a-b\ge c\Rightarrow b\le a+(-c)$$<br>与求最短路径中的三角形不等式$dis[e.to]\le dis[u] + e.val$类似<br>所以我们对于约束条件$a-b\ge c$,从$a$到$b$建一条边权为$-c$的边<br>同理三种约束条件依次为</p>
<ol>
<li>$a-b\ge c$, 从$a$到$b$建$-c$单向边</li>
<li>$a-b\le c$, 从$b$到$a$建$c$单向边</li>
<li>$a=b$, 从$a$到$b$建权值为$0$的双向边</li>
</ol>
<p>如果存在一组解${x_1, x_2, \ldots, x_n}$,则对任意常数$\Delta$, ${x_1+\Delta, x_2+\Delta, \ldots, x_n+\Delta}$也是一组解<br>不妨先求一组负数解,于是就有了条件$x_i-x_0\le 0$<br>即,从$0$向所有节点建一条边权为$0$的单向边</p>
<p>求解时,设$\mathtt{dis[0]=0}$,然后以$0$为源点求单源最短路<br>如果存在负环,则系统无解<br>不存在负环,则$\mathtt{dis[i]}$为系统的一组解</p>
<h3 id="II-负环"><a href="#II-负环" class="headerlink" title="$II.$ 负环"></a>$II.$ 负环</h3><p>如果任意一条边被修改大于$n$次(执行$n$次松弛操作),这个图内一定存在至少一个负环<br>我们可以使用一个数组$cnt$来记录每条边执行松弛操作的次数<br>当向队列中添加节点$\mathtt{e.to}$时,$\mathtt{cnt[e.to]++}$<br>然后再判断$\mathtt{cnt[e.to]&gt;n}$,如果返回$\mathtt{true}$则存在负环</p>
<h3 id="III-SPFA-的-SLF-优化"><a href="#III-SPFA-的-SLF-优化" class="headerlink" title="$III.$ $SPFA$的$SLF$优化"></a>$III.$ $SPFA$的$SLF$优化</h3><p>本题如果直接跑$SPFA$的话,会$TLE\ 3$个点,即使手动开了$O3$优化,还是会$TLE\ 1$个点<br>所以我们可以使用$SLF(Small\ Label\ First)$优化</p>
<p>$SLF:$<br>当加入一个新节点$v$的时候</p>
<ul>
<li>如果此时的$\mathtt{dis[v]}$比队首$\mathtt{dis[q.front()]}$小的话，就把$v$点加入到队首</li>
<li>否则把他加入到队尾</li>
</ul>
<p>因为先扩展最小的点可以尽量使程序尽早的结束</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">val</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn], vis[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push_back</span>(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>(); vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (dis[e.to] &gt; dis[u] + e.val) &#123;</span><br><span class="line">                dis[e.to] = dis[u] + e.val;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; dis[e.to] &lt; dis[q.<span class="built_in">front</span>()]) &#123;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(e.to);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(e.to);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt[e.to]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[e.to] &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(a, b, -c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(b, a, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(a, b, <span class="number">0</span>); <span class="built_in">add</span>(b, a, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">SPFA</span>(<span class="number">0</span>) ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1.94s 1.61MB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」线段树</title>
    <url>/p/d1cf0d36.html</url>
    <content><![CDATA[<p>线段树($Segment\ Tree$)是一种基于分治思想的__二叉树__形数据结构，可以用于__区间__上的数据维护，它可以维护以下值</p>
<span id="more"></span>

<ul>
<li>$maxn\ minn$，区间上最大最小值</li>
<li>$sum$，区间和</li>
<li>$lmax$，每段上最大前缀和</li>
<li>$rmax$，每段上最大后缀和</li>
<li>$……$</li>
</ul>
<p>和以下操作</p>
<ul>
<li>$Add\ x\ y\ k$，把区间$[x,y]$内元素值全加$k$</li>
<li>$Query\ x\ y$，查询区间$[x,y]$内的某个值</li>
</ul>
<p>由于线段树会维护一种数据，其他也很好写，所以本篇以__区间和__为例</p>
<h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><p>在每次$Add$操作中，如果将相关区间的值全部更新，则会把时间复杂度提高到$O(n)$</p>
<p>所以我们可以采取一种__<em>延迟标记</em>__($lazy-tag$)的技巧，如果被标记，则说明本区间内的值被整体加上某个值了</p>
<p>详细方法见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SegmentTreeNode</span> &#123;</span> <span class="comment">//树上的节点</span></span><br><span class="line">        <span class="keyword">int</span> l, r;                   <span class="comment">//节点表示区间的左右端点</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum, add;         <span class="comment">//区间和和add的延迟标记</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l      <span class="comment">//方便访问</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> add(x) tree[x].add</span></span><br><span class="line">    &#125; tree[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> a[maxn], n, m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//建树</span></span><br><span class="line">        <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;           <span class="comment">//设置左右端点</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; <span class="built_in">sum</span>(p) = a[l]; <span class="keyword">return</span>; &#125; <span class="comment">//到达叶子节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(p * <span class="number">2</span>, l, mid);         <span class="comment">//递归构建左右树</span></span><br><span class="line">        <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) + <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">//更新数据，可改为需要维护的多个值的维护方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">//下传延迟标记</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">add</span>(p)) &#123; <span class="comment">//如果有标记</span></span><br><span class="line">            <span class="built_in">sum</span>(p * <span class="number">2</span>) += <span class="built_in">add</span>(p) * (<span class="built_in">r</span>(p * <span class="number">2</span>) - <span class="built_in">l</span>(p * <span class="number">2</span>) + <span class="number">1</span>); <span class="comment">//sum传至左儿子</span></span><br><span class="line">            <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>) += <span class="built_in">add</span>(p) * (<span class="built_in">r</span>(p * <span class="number">2</span> + <span class="number">1</span>) - <span class="built_in">l</span>(p * <span class="number">2</span> + <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">//右儿子</span></span><br><span class="line">            <span class="built_in">add</span>(p * <span class="number">2</span>) += <span class="built_in">add</span>(p);      <span class="comment">//延迟标记传至左儿子</span></span><br><span class="line">            <span class="built_in">add</span>(p * <span class="number">2</span> + <span class="number">1</span>) += <span class="built_in">add</span>(p);  <span class="comment">//右儿子</span></span><br><span class="line">            <span class="built_in">add</span>(p) = <span class="number">0</span>; <span class="comment">//本节点延迟标记清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123; <span class="comment">//更新区间内值</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p)) &#123; <span class="comment">//完全覆盖</span></span><br><span class="line">            <span class="built_in">sum</span>(p) += (<span class="keyword">long</span> <span class="keyword">long</span>)d * (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>); <span class="comment">//更新节点信息</span></span><br><span class="line">            <span class="built_in">add</span>(p) += d; <span class="comment">//打上延迟标记</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(p); <span class="comment">//下传标记</span></span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(p * <span class="number">2</span>, l, r, d);      <span class="comment">//递归更新左右</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;  mid) <span class="built_in">update</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) + <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>);      <span class="comment">//维护数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//查询操作</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p)) <span class="keyword">return</span> <span class="built_in">sum</span>(p); <span class="comment">//完全覆盖</span></span><br><span class="line">        <span class="built_in">pushdown</span>(p); <span class="comment">//下传标记</span></span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">query</span>(p * <span class="number">2</span>, l, r);     <span class="comment">//加上左右部分值</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;  mid) ans += <span class="built_in">query</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> add   <span class="comment">//防止后续使用add等出现错误</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> r</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了使代码简洁，还可以宏定义一些名称</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lt p&lt;&lt;1     <span class="comment">//左孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rt p&lt;&lt;1|1   <span class="comment">//右孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lt,l,mid    <span class="comment">//左子树</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt,mid+1,r  <span class="comment">//右子树</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3372">Luogu P3372 线段树1 (区间增加，区间查询和)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3373">Luogu P3373 线段树2 (区间增加，区间乘数，区间查询和)</a></p>
<p>$SPOJ$的$GSS$系列</p>
<ol>
<li><a href="https://www.luogu.org/problemnew/show/SP1043">SP1043 GSS1 - Can you answer these queries I</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP1557">SP1557 GSS2 - Can you answer these queries II</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP1716">SP1716 GSS3 - Can you answer these queries III</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP2713">SP2713 GSS4 - Can you answer these queries IV</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP2916">SP2916 GSS5 - Can you answer these queries V</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP4487">SP4487 GSS6 - Can you answer these queries VI</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP6779">SP6779 GSS7 - Can you answer these queries VII</a></li>
</ol>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」左偏树(可并堆)</title>
    <url>/p/7ab0d731.html</url>
    <content><![CDATA[<p>左偏树($Leftist\ Tree$)，是一种 __可以合并的堆状结构__，支持以下操作</p>
<span id="more"></span>

<ul>
<li>$Pop\ x$，删除节点$x$</li>
<li>$Merge\ x\ y$，合并两棵左偏树</li>
</ul>
<p>对于一个左偏树的节点，需要维护以下值</p>
<ul>
<li>$dist$，记录这个节点到它子树里面最近的叶子节点的距离</li>
<li>$value$，每个节点包含的值</li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>一个节点的$value$大于(或小于)左右孩子的$value$<strong><em>(堆性质)</em></strong> </li>
<li>一个节点的左孩子的$dist$不小于右孩子的$dist$<strong><em>(左偏性质)</em></strong></li>
<li>一个节点的距离始终等于右孩子+1</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Merge-操作"><a href="#Merge-操作" class="headerlink" title="$Merge$操作"></a>$Merge$操作</h3><p>首先我们设两个节点$x,y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了</p>
<p>合并了$x$的右子树和$y$后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护左偏性质，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x=dist_{rson(x)}+1$</p>
<h3 id="Pop-操作"><a href="#Pop-操作" class="headerlink" title="$Pop$操作"></a>$Pop$操作</h3><p>略$…$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LeftistTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LeftistTreeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> dis, val, rt;</span><br><span class="line">        <span class="keyword">int</span> ls, rs;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ls(x)  tree[x].ls</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rs(x)  tree[x].rs</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> dis(x) tree[x].dis</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> val(x) tree[x].val</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rt(x)  tree[x].rt</span></span><br><span class="line">    &#125;tree[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">val</span>(x) &gt; <span class="built_in">val</span>(y) || (<span class="built_in">val</span>(x) == <span class="built_in">val</span>(y) &amp;&amp; x &gt; y)) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rs</span>(x) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(x), y);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dis</span>(<span class="built_in">ls</span>(x)) &lt; <span class="built_in">dis</span>(<span class="built_in">rs</span>(x))) <span class="built_in">swap</span>(<span class="built_in">ls</span>(x), <span class="built_in">rs</span>(x));</span><br><span class="line">        <span class="built_in">rt</span>(<span class="built_in">ls</span>(x)) = <span class="built_in">rt</span>(<span class="built_in">rs</span>(x)) = <span class="built_in">rt</span>(x) = x;</span><br><span class="line">        <span class="built_in">dis</span>(x) = <span class="built_in">dis</span>(<span class="built_in">rs</span>(x)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rt</span>(x) == x ? x : <span class="built_in">rt</span>(x) = <span class="built_in">get</span>(<span class="built_in">rt</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">val</span>(x) = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">rt</span>(<span class="built_in">ls</span>(x)) = <span class="built_in">ls</span>(x); <span class="built_in">rt</span>(<span class="built_in">rs</span>(x)) = <span class="built_in">rs</span>(x);</span><br><span class="line">        <span class="built_in">rt</span>(x) = <span class="built_in">merge</span>(<span class="built_in">ls</span>(x), <span class="built_in">rs</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dis</span>(<span class="number">0</span>) = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">rt</span>(i) = i;</span><br><span class="line">            <span class="built_in">val</span>(i) = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SolveMerge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">val</span>(x) == <span class="number">-1</span> || <span class="built_in">val</span>(y) == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> fx = <span class="built_in">get</span>(x), fy = <span class="built_in">get</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            <span class="built_in">rt</span>(fx) = <span class="built_in">rt</span>(fy) = <span class="built_in">merge</span>(fx, fy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SolvePop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">val</span>(x) == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">val</span>(<span class="built_in">get</span>(x))), <span class="built_in">pop</span>(<span class="built_in">get</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3377">Luogu P3377 左偏树(可并堆)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」树状数组</title>
    <url>/p/8c13697e.html</url>
    <content><![CDATA[<p>树状数组($Binary\ Indexed\ Trees$)是一个维护__前缀和__的数据结构，需要支持以下操作</p>
<span id="more"></span>

<ul>
<li>$Add\ x\ y$，单点增加，<code>a[x] += y</code></li>
<li>$Query\ x$，查询前缀和</li>
</ul>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="lowbit-运算"><a href="#lowbit-运算" class="headerlink" title="$lowbit$运算"></a>$lowbit$运算</h3><p>$lowbit(n)$表示非负整数$n$在二进制表示下__最低位的1及其后边所有的0构成的数值__</p>
<p>为了实现$lowbit$运算，先把$n$取反，此时第$k$位变为$0$(设第$k$位是$1$，其后均为$0$)，第$0\sim k-1$位变为$1$，再整体加一，所以第$k$位变为$1$，其后为$0$，其前每位恰好与原数相反，再按位求与($&amp;$)即可得到。由于在补码下，$\sim n=-1-n$，所以</p>
<p>$$lowbit(n)=n\ &amp;\  (\sim n+1)=n\ &amp;\ -n$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &amp; -n; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>对于一个原序列$a[]$，可以建立一个数组$tree[]$，来保存$a$的区间$[x-lowbit(x)+1, x]$内值的和，即</p>
<p>$$tree[x] = \sum_{i=x-lowbit(x)+1}^x{a[i]}$$</p>
<p>同时$tree$数组可以看成一个树形结构，并满足以下性质</p>
<ul>
<li>每个节点$tree[x]$保存以$x$为根的子树中所有叶节点的和</li>
<li>每个节点$tree[x]$的子节点个数等于$lowbit(x)$的位数</li>
<li>除树根外，每个节点$tree[x]$的父亲节点为$tree[x+lowbit(x)]$</li>
<li>树的深度为$\log_2n$</li>
</ul>
<p>根据这些性质，就<del>很容易地</del>写出代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tree[maxn], n, m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> k &amp; -k; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; x &lt;= maxn; x += x &amp; -x) tree[x] += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= x &amp; -x) ans += tree[x];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">add</span>(i, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，树状数组可以嵌套维护，来解决更多问题，例如区间修改</p>
<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3374">Luogu P3374 树状数组1 (单点修改，区间查询)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3368">Luogu P3368 树状数组2 (区间修改，单点查询)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3372">Luogu P3372 线段树1 (区间修改，区间查询)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」并查集</title>
    <url>/p/9c4b8ceb.html</url>
    <content><![CDATA[<p>并查集($union-find\ \ set$)是一种可以__动态维护__若干个不重叠的__集合__，并支持__合并与查询__的数据结构，支持以下两种基本操作：</p>
<span id="more"></span>

<ul>
<li>$Find$，查询一个元素属于哪个集合(即查找根)</li>
<li>$Union$，把两个集合合并成一个集合</li>
</ul>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>我们可以使用树形结构存储集合，树上每个点表示一个元素，树根可以代表这个集合</p>
<p>使用一个数组<code>ufs[]</code>来保存每个节点的父亲节点</p>
<p>则合并$x,y$所在的集合可以表示为$ufs[root_x]=root_y$</p>
<p>查找根节点可以一直沿着数组向上查找</p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>防止整棵树的链非常长，导致每次查询时间复杂度极高，可以在__每次执行$Find$操作时，把访问的节点指向根节点__，这种方法称为__<em>路径压缩</em>__，$Find$操作的时间复杂度为$O(log_2n)$</p>
<p>$Code\ Below:$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，每个点独立(自己是自己的根)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ufs[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ufs[x] ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//union操作(注意union是C++关键字)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ufs[<span class="built_in">get</span>(x)] = <span class="built_in">get</span>(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>有时，需要维护的每个节点到根节点的边权值，可以增加一个数组<code>d[]</code>来保存权值，对于两个操作也有所更改</p>
<p>再增加一个数组<code>size[]</code>记录每个树根上集合大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ufs[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">    d[x] += d[ufs[x]];</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = fx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//union</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    ufs[fx] = fy; d[fx] = size[fy];</span><br><span class="line">    size[fy] += size[fx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可撤销并查集"><a href="#可撤销并查集" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h2><p>可能需要维护一个并查集并要求可以__撤销__两节点的连接关系</p>
<p>我们可以对每个操作$(u, v)$执行前，把节点$u$换为树根(<del>不难发现</del>，$ufs[]$变化的只有从$u$到原节点的一条链上)</p>
<p>然后对于操作</p>
<ul>
<li>$Connect\ u\ v$，需要把$u$的父亲节点设为$v$</li>
<li>$Delete\ u\ v$，可以把$v$的父亲节点设为$0$</li>
<li>$Query\ u\ v$，直接暴力搜索$v$所在的链即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFindSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ufs[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ufs[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">//换u为根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, fa = ufs[u]; u; fa = ufs[u]) &#123;</span><br><span class="line">            ufs[u] = i; i = u; u = fa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ufs[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteuv</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ufs[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; v != u &amp;&amp; v; v = ufs[v]);</span><br><span class="line">        <span class="built_in">puts</span>(v == u ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3367">Luogu P3367 并查集 (普通并查集)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P1196">Luogu P1196 银河英雄传说 (带权并查集)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P2147">Luogu P2147 洞穴勘探 (可撤销并查集)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P2723 P1631 P2850」小练习-题解</title>
    <url>/p/1faf5003.html</url>
    <content><![CDATA[<p>战神留的还有一道<a href="https://www.luogu.org/problemnew/show/P3378">「P3378」堆</a>,但是是模板,就不用多说了吧</p>
<span id="more"></span>

<h2 id="mathcal-「P2723」-丑数"><a href="#mathcal-「P2723」-丑数" class="headerlink" title="$\mathcal{「P2723」}$ 丑数"></a>$\mathcal{「P2723」}$ <a href="https://www.luogu.org/problemnew/show/P2723">丑数</a></h2><h3 id="92-分-STL-做法"><a href="#92-分-STL-做法" class="headerlink" title="$92$分$STL$做法"></a>$92$分$STL$做法</h3><p>思路很简单,每次弹出堆顶,依次乘$S$集合内的数,再压入优先队列($priority\_queue$)和集合($set$,目的是去重)中,输出最后一个堆顶即可<br>然而第$4$个点卡了十多秒,$92$分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, n, a[maxk], i, t;</span><br><span class="line">priority_queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>, vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; q;</span><br><span class="line">set&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>); s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt;= n) &#123;</span><br><span class="line">        t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> num = t * a[j];</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(num);</span><br><span class="line">                q.<span class="built_in">push</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 92points TLE with O2 */</span></span><br></pre></td></tr></table></figure>

<h3 id="100-分循环做法"><a href="#100-分循环做法" class="headerlink" title="$100$分循环做法"></a>$100$分循环做法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由题可知,当前产生的第$i$个丑数$s[i]$,是之前的某个丑数$\times a[j]$<br>某个丑数$\times a[j]$需要大于$s[i-1]$,而且要尽可能的小<br>于是我们可以枚举$j$,然后找到最小的一个丑数$minn$使$minn\times a[j]&gt;s[i-1]$</p>
<p><strong>但是..三重循环可能还会$TLE$</strong></p>
<p>很容易发现满足条件的丑数$x\times a[j]&gt;s[i-1]$,一定满足条件$x\times a[j]&gt;s[i-2]$<br>于是我们就可以从满足$x\times a[j]&gt;s[i-2]$的丑数$x$的位置往后枚举,找到满足条件$x\times a[j]&gt;s[i-1]$的丑数<br>代码里$b[j]$表示$a[j]$至少与第几小丑数相乘才能得到一个比$s[i-1]$大的丑数</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, n, a[maxk], i, t, s[maxn], b[maxk];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> minn = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">61</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[j] * s[b[j]] &lt;= s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                b[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[j] * s[b[j]] &lt; minn) &#123;</span><br><span class="line">                minn = a[j] * s[b[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = minn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, s[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 101ms 1584kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="mathcal-「P1631」-序列合并"><a href="#mathcal-「P1631」-序列合并" class="headerlink" title="$\mathcal{「P1631」}$ 序列合并"></a>$\mathcal{「P1631」}$ <a href="https://www.luogu.org/problemnew/show/P1631">序列合并</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>参考<a href="https://www.luogu.org/blog/user23845/solution-p1631">Red_w1nE</a></p>
<p>把$A$和$B$两个序列分别从小到大排序<br>这样,从$A$和$B$中各任取一个数相加得到$n^2$个和,可以把这些和看成形成了$n$个队列:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] + b[<span class="number">1</span>] &lt;= a[<span class="number">1</span>] + b[<span class="number">2</span>] &lt;= ... &lt;= a[<span class="number">1</span>] + B[n]</span><br><span class="line">a[<span class="number">2</span>] + b[<span class="number">1</span>] &lt;= a[<span class="number">2</span>] + b[<span class="number">2</span>] &lt;= ... &lt;= a[<span class="number">2</span>] + B[n]</span><br><span class="line">    ...            ...        ...        ...</span><br><span class="line">a[n] + b[<span class="number">1</span>] &lt;= a[n] + b[<span class="number">2</span>] &lt;= ... &lt;= a[n] + B[n]</span><br></pre></td></tr></table></figure>
<p>接下来,将这$n$个队列进行合并:</p>
<ul>
<li>将这$n$个队列中的第一个元素放入优先队列中；</li>
<li>每次取出优先队列中的最小值,若这个最小值来自于第$k$个队列,那么,就将第$k$个队列的下一个元素放入优先队列中。<br>我们可以使用一个结构体来记录队列中一个节点的值<code>val</code>,队列号<code>id</code>,下一个元素<code>nxt</code></li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id, nxt;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> v, <span class="keyword">int</span> i, <span class="keyword">int</span> n): <span class="built_in">val</span>(v), <span class="built_in">id</span>(i), <span class="built_in">nxt</span>(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], b[maxn];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">Node</span>( a[i] + b[<span class="number">0</span>], i, <span class="number">1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Node t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t.val);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">Node</span>( a[t.id] + b[t.nxt], t.id, t.nxt + <span class="number">1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 402ms 3196kB */</span></span><br></pre></td></tr></table></figure>


<h2 id="mathcal-「P2850」-虫洞"><a href="#mathcal-「P2850」-虫洞" class="headerlink" title="$\mathcal{「P2850」}$ 虫洞"></a>$\mathcal{「P2850」}$ <a href="https://www.luogu.org/problemnew/show/P2850">虫洞</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>判断__<em>负环</em>__的模板题</p>
<p>每条小路连接边权为正的无向边,每个虫洞连接边权为负的无向边<br>存在负环,则可以回到过去<br>使用$SPFA$算法判断负环($Floyd$也可以,但不开O2优化会$TLE$)</p>
<p>$SPFA$判断负环:<strong>如果任意一条边被修改大于$n$次,这个图内一定存在至少一个负环</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>使用<code>vector</code>建边,邻接表也可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">val</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[maxn], vis[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dist[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (dist[e.to] &gt; dist[u] + e.val) &#123;</span><br><span class="line">                dist[e.to] = dist[u] + e.val;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                    cnt[e.to]++;  <span class="comment">//统计修改次数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[e.to] &gt; n) &#123; <span class="comment">//修改大于n次</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">//存在负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn - <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x7f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); w = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(u, v, d); <span class="built_in">add</span>(v, u, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(u, v, -d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SPFA</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 164ms 1024kB */</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记-数论</title>
    <url>/p/da9a11f.html</url>
    <content><![CDATA[<p>模板地址: <a href="https://github.com/Tony031218/luogu/blob/master/Mathematics.cpp">GitHub</a></p>
<h2 id="欧几里得算法-Euclid-algorithm"><a href="#欧几里得算法-Euclid-algorithm" class="headerlink" title="欧几里得算法(Euclid algorithm)"></a>欧几里得算法(Euclid algorithm)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lcm(a, b) = a / gcd(a, b) * b</code></p>
<h3 id="扩展欧几里得算法-exGCD"><a href="#扩展欧几里得算法-exGCD" class="headerlink" title="扩展欧几里得算法(exGCD)"></a>扩展欧几里得算法(exGCD)</h3><p><strong><em>目标</em></strong>: 寻找一对整数$(x, y)$,使$ax+by=gcd(a,b)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123; d = a; x = <span class="number">1</span>; y = <span class="number">0</span>; &#125;  <span class="comment">//d为gcd(a, b)</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="built_in">exgcd</span>(b, a % b, d, y, x); y -= x * (a / b); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h4><p>$ax+by=c$且$x,y$全为正整数,则当且仅当$gcd(a, b)|c$</p>
<h2 id="素数相关"><a href="#素数相关" class="headerlink" title="素数相关"></a>素数相关</h2><h3 id="Eratosthenes筛法"><a href="#Eratosthenes筛法" class="headerlink" title="Eratosthenes筛法"></a>Eratosthenes筛法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>), num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        prime[++num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j += i) vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性筛"><a href="#欧拉线性筛" class="headerlink" title="欧拉线性筛"></a>欧拉线性筛</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i * prime[j];</span><br><span class="line">            <span class="keyword">if</span> (v &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h3><p>$$<br>\pi(x) \sim \frac{x}{\ln x}<br>$$</p>
<h3 id="Miller-Rabin-素数测试"><a href="#Miller-Rabin-素数测试" class="headerlink" title="$Miller-Rabin$素数测试"></a>$Miller-Rabin$素数测试</h3><p><strong><em>原理</em></strong>:费马小定理<br>若$a^{n-1}\equiv 1\pmod n$,$a$取值越多,可以近似认为$n$为质数<br>使用二次探测定理改进卡卡迈尔数(合数$n$对于任何正整数$b$,都满足$gcd(b, n)=1\ \ b^{n-1}\equiv 1\pmod n$)的bug</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Random</span><span class="params">(LL n)</span> </span>&#123; <span class="keyword">return</span> (LL)((<span class="keyword">double</span>)<span class="built_in">rand</span>() / RAND_MAX * n + <span class="number">0.5</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Witness</span><span class="params">(LL a, LL n)</span> </span>&#123;</span><br><span class="line">    LL m = n - <span class="number">1</span>; <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(m &amp; <span class="number">1</span>)) &#123; j++; m &gt;&gt;= <span class="number">1</span>; &#125;</span><br><span class="line">    LL x = <span class="built_in">pow_mod</span>(a, m, n);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123; x = x * x % n; <span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        LL a = <span class="built_in">Random</span>(n - <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Witness</span>(a, n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="模算术"><a href="#模算术" class="headerlink" title="模算术"></a>模算术</h2><p>$$<br>(a + b)\bmod n = ((a\bmod n) + (b\bmod n))\bmod n\\<br>(a - b)\bmod n = ((a\bmod n) - (b\bmod n) + n)\bmod n\\<br>ab\mod n = (a\bmod n)(b\bmod n)\bmod n<br>$$</p>
<h3 id="快速乘-ab-bmod-n"><a href="#快速乘-ab-bmod-n" class="headerlink" title="快速乘 $ab\bmod n$"></a>快速乘 $ab\bmod n$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul_mod</span><span class="params">(LL a, LL b, LL n)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = (res + a) % n;</span><br><span class="line">        a = (a + a) % n;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂-a-p-bmod-n"><a href="#快速幂-a-p-bmod-n" class="headerlink" title="快速幂 $a^p\bmod n$"></a>快速幂 $a^p\bmod n$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL a, LL p, LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL ans = <span class="built_in">pow_mod</span>(a, p / <span class="number">2</span>, n); ans = ans * ans % n;</span><br><span class="line">    <span class="keyword">if</span> (p % <span class="number">2</span> == <span class="number">1</span>) ans = ans * a % n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用位运算:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL a, LL p, LL n)</span> </span>&#123;</span><br><span class="line">    a %= n; LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>, a *= a, a %= n) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a % n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉-varphi-函数"><a href="#欧拉-varphi-函数" class="headerlink" title="欧拉$\varphi$函数"></a>欧拉$\varphi$函数</h2><p>$$\varphi(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})$$<br>$\varphi(n)$表示不超过$n$且与$n$互质的整数个数</p>
<h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>); <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛欧拉函数表"><a href="#筛欧拉函数表" class="headerlink" title="筛欧拉函数表"></a>筛欧拉函数表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) phi[i] = <span class="number">0</span>; phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!phi[i])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">            phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同余式定理"><a href="#同余式定理" class="headerlink" title="同余式定理"></a>同余式定理</h2><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若$gcd(a, n) = 1$,则$a^{\varphi(n)}\equiv 1\pmod n$</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若$p$为质数,则$a^{p-1}\equiv 1\pmod p$</p>
<h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><p>若$p$为质数,则$(p-1)!\equiv -1\pmod p$</p>
<h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><p>$$a\div b\bmod n = a\times b^{-1}\bmod n$$<br>$b^{-1}$称为$b$在模$n$意义下的逆元</p>
<h3 id="n-为质数"><a href="#n-为质数" class="headerlink" title="$n$为质数"></a>$n$为质数</h3><p>使用费马小定理, $a^{-1} = a^{n - 2}$</p>
<h3 id="n-不为质数"><a href="#n-不为质数" class="headerlink" title="$n$不为质数"></a>$n$不为质数</h3><p>递归求解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL n)</span> </span>&#123;</span><br><span class="line">    LL d, x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, n, d, x, y);</span><br><span class="line">    <span class="keyword">return</span> d == <span class="number">1</span> ? (x + n) % n : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛逆元表"><a href="#筛逆元表" class="headerlink" title="筛逆元表"></a>筛逆元表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> inv_table[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinv</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    inv_table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        inv_table[i] = (LL)(p - p / i) * inv_table[p % i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h2><p>$ax\equiv b\pmod n$可以化为$ax+ny=b$使用扩展欧拉定理解决</p>
<h3 id="中国剩余定理-China-Remainder-Theorem"><a href="#中国剩余定理-China-Remainder-Theorem" class="headerlink" title="中国剩余定理(China Remainder Theorem)"></a>中国剩余定理(China Remainder Theorem)</h3><p>求解$x\equiv a_i\pmod {m_i}$满足$m_i$两两互质</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">crt</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* a, <span class="keyword">int</span>* m)</span> </span>&#123;</span><br><span class="line">    LL M = <span class="number">1</span>, d, y, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) M *= m[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        LL w = M / m[i];</span><br><span class="line">        <span class="built_in">exgcd</span>(m[i], w, d, d, y);</span><br><span class="line">        x = (x + y * w * a[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展中国剩余定理-exCRT"><a href="#扩展中国剩余定理-exCRT" class="headerlink" title="扩展中国剩余定理(exCRT)"></a>扩展中国剩余定理(exCRT)</h4><p>$m_i$不一定两两互质</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">excrt</span><span class="params">(LL n, LL* a, LL* m)</span> </span>&#123;</span><br><span class="line">    LL x, y, k, M = m[<span class="number">0</span>], ans = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        LL A = M, B = m[i], C = (a[i] - ans % B + B) % B, gcd;</span><br><span class="line">        <span class="built_in">exgcd</span>(A, B, gcd, x, y);</span><br><span class="line">        LL bg = B / gcd;</span><br><span class="line">        <span class="keyword">if</span> (C % gcd != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x = <span class="built_in">mul_mod</span>(x, C / gcd, bg);</span><br><span class="line">        ans += x * M; M *= bg;</span><br><span class="line">        ans = (ans % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数-BSGS"><a href="#离散对数-BSGS" class="headerlink" title="离散对数(BSGS)"></a>离散对数(BSGS)</h3><p>求解$a^x\equiv b\pmod n$满足$n$为质数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_mod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, v, e = <span class="number">1</span>, i;</span><br><span class="line">    m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">    v = <span class="built_in">inv</span>(<span class="built_in">pow_mod</span>(a, m, n), n);</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x;</span><br><span class="line">    x[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        e = <span class="built_in">mul_mod</span>(e, a, n);</span><br><span class="line">        <span class="keyword">if</span> (!x.<span class="built_in">count</span>(e)) x[e] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.<span class="built_in">count</span>(b)) <span class="keyword">return</span> i * m + x[b];</span><br><span class="line">        b = <span class="built_in">mul_mod</span>(b, v, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h3><p>整除分块可以对后面的莫比乌斯反演提供很大的优化<br>通过<del>枚举</del>可以发现$\lfloor \frac{n}{i} \rfloor$的结果会出现分块现象<br>例如$n=10$时<br>$\ \ \ i\ \ \ \ 1\ \ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10\ 11\ 12\ 13\ …$<br>$\lfloor \frac{n}{i} \rfloor\ 10\ 5\ 3\ 2\ 2\ 1\ 1\ 1\ 1\ 1\ \ \ 0\ \ \ 0\ \ \ 0\ \ \ …$<br><del>不难发现</del>,每个块的右端点为$r=\lfloor \frac{n}{t}\rfloor (t=\lfloor \frac{n}{i}\rfloor)$</p>
<h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p>$$<br>\mu(n) =<br>\begin{cases}<br>1,  &amp; n=1 \\<br>(-1)^r, &amp; n=p_1p_2p_3…p_r(\text{$p_i$为互不相同的质数}) \\<br>0,  &amp; else<br>\end{cases}<br>$$<br><strong><em>性质</em></strong>:<br>$$\sum_{d|n}{\mu(d)}=[n=1]$$<br>$$\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\varphi(n)}{n}$$<br><strong><em>线性筛</em></strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn], vis[maxn];</span><br><span class="line"><span class="keyword">int</span> primes[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(mu, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mu));</span><br><span class="line">	cnt = <span class="number">0</span>; mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123; primes[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; primes[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">			vis[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">			mu[i * primes[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1516」青蛙的约会-题解</title>
    <url>/p/1f4bfad8.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P1516">「Luogu P1516」青蛙的约会</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>(规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴)<br>现有两只青蛙$A,B$<br>设青蛙$A$的出发点坐标是$x$，青蛙$B$的出发点坐标是$y$<br>青蛙$A$一次能跳$m$米，青蛙$B$一次能跳$n$米，两只青蛙跳一次所花费的时间相同<br>纬度线总长$l$米<br>求两只青蛙跳了几次以后才会碰面</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>__<em>同余方程</em>__模板题<br>求解$x + km\equiv y + kn \pmod l$</p>
<p>$Solve:$<br>$$<br>x+km−(y+kn)=lz,\ \ z\in Z\\<br>(x-y)+k(m-n)-lz=0\\<br>k(n-m)+lz=(x-y)<br>$$<br>令$a=x-y,b=n-m$<br>上式可化为:<br>$$<br>kb+lz=a<br>$$<br>求这个方程的最小整数解<br>化为求此不定方程最小整数解<br>$$k’b+lz’=gcd(b,l)$$<br>使用扩展欧几里得算法可得一组特解$(k’,b’)$<br>最小解为$k_{min} = k’\bmod \frac{l}{gcd(b,l)}$<br>以上解$k_{min}$的方程右边是$gcd(b,l)$而不是$a$<br>所以结果为<br>$$\boxed{ (k’\times \frac{a}{gcd(b,l)})\bmod \frac{l}{gcd(b,l)} }$$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123; d = a; x = <span class="number">1</span>; y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="built_in">exgcd</span>(b, a % b, d, y, x); y -= x * (a / b); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n, m, x, y, l, gcd, x1, y1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld %lld %lld&quot;</span>, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l);</span><br><span class="line">    LL b = n - m, a = x - y;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123; b = -b, a = -a; &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, l, gcd, x1, y1);</span><br><span class="line">    <span class="keyword">if</span> (a % gcd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LL ans = ((x1 * (a / gcd)) % (l / gcd) + (l / gcd)) % (l / gcd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 26ms 916kB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2016」题解</title>
    <url>/p/2a6e5fce.html</url>
    <content><![CDATA[<p>$???$就一道紫题$???$,还是$D1T2\ ???$</p>
<span id="more"></span>

<h2 id="D1T1-玩具迷题"><a href="#D1T1-玩具迷题" class="headerlink" title="$D1T1$ 玩具迷题"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P1563">玩具迷题</a></h2><p>简单的__<em>模拟</em>__,没的说</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> towards;</span><br><span class="line">    string name;</span><br><span class="line">&#125; a[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ai, si;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].towards &gt;&gt; a[i].name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> peo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ai &gt;&gt; si;</span><br><span class="line">        <span class="keyword">if</span> (ai == <span class="number">0</span> &amp;&amp; a[peo].towards == <span class="number">0</span>) peo = (peo + n - si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">0</span> &amp;&amp; a[peo].towards == <span class="number">1</span>) peo = (peo + si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">1</span> &amp;&amp; a[peo].towards == <span class="number">0</span>) peo = (peo + si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">1</span> &amp;&amp; a[peo].towards == <span class="number">1</span>) peo = (peo + n - si) % n;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; a[peo].name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* 430ms 4760kB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2017」题解</title>
    <url>/p/c5ac34f0.html</url>
    <content><![CDATA[<pre><code>NOIp2017的题比NOIp2018的题好做一点
</code></pre>
<span id="more"></span>

<h2 id="D1T1-小凯的疑惑"><a href="#D1T1-小凯的疑惑" class="headerlink" title="$D1T1$ 小凯的疑惑"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P3951">小凯的疑惑</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>推柿子(<del>正确性未知</del>)<br>设$a &lt; b$ 答案为$x$<br>所以:<br>$$x \equiv ma \pmod b (1 \leq m \leq b - 1)$$<br>即$x = ma + nb (1 \leq m \leq b - 1)$<br>显然当$ n \geq 0$时 $x$可以用$a, b$表示出来，不合题意<br>因此当$n = -1$时$x$取得最大值，此时$x = ma - b$<br>显然当$m$取得最大值$b - 1$时$x$最大，此时$x = (b - 1)a - b = ab - a - b$<br>因此$a, b$所表示不出的最大的数是<br>$$\boxed{ab - a - b}$$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, a * b - a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 60ms 948kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T2-时间复杂度"><a href="#D1T2-时间复杂度" class="headerlink" title="$D1T2$ 时间复杂度"></a>$D1T2$ <a href="https://www.luogu.org/problemnew/show/P3952">时间复杂度</a></h2><p><del>毒瘤</del>大模拟<br>没什么好说的,直接上代码</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str1, str2;      </span><br><span class="line"><span class="keyword">int</span> cal, O, NumOfLoop, vis[<span class="number">27</span>], var[<span class="number">27</span>], Onow, Kill, AddO[<span class="number">100</span>], Omax, WhereKill, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T--;</span><br><span class="line">        cal = <span class="number">0</span>; O = <span class="number">0</span>; Omax = <span class="number">0</span>; WhereKill = <span class="number">0</span>; NumOfLoop = <span class="number">0</span>; Onow = <span class="number">0</span>; Kill = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(AddO, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(AddO));</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            str1 = str2;</span><br><span class="line">            cin &gt;&gt; str2;</span><br><span class="line">        &#125; <span class="keyword">while</span>(str2[<span class="number">0</span>] != <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">length</span>(); i++) cal = cal * <span class="number">10</span> + str1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; str2.<span class="built_in">length</span>() - <span class="number">1</span>; i++) O = O * <span class="number">10</span> + str2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (cal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cal--;</span><br><span class="line">            cin &gt;&gt; str1;</span><br><span class="line">            <span class="keyword">if</span> (str1[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">                NumOfLoop++;</span><br><span class="line">                cin &gt;&gt; str1;</span><br><span class="line">                <span class="keyword">if</span> (vis[str1[<span class="number">0</span>] - <span class="number">96</span>]) &#123;</span><br><span class="line">                    NumOfLoop = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                	vis[str1[<span class="number">0</span>] - <span class="number">96</span>] = <span class="number">1</span>;</span><br><span class="line">                    var[NumOfLoop] = str1[<span class="number">0</span>] - <span class="number">96</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">                <span class="keyword">if</span> (str1[<span class="number">0</span>] != <span class="string">&#x27;n&#x27;</span> &amp;&amp; str2[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> &amp;&amp; Kill == <span class="number">0</span>) &#123;</span><br><span class="line">                    Onow++;</span><br><span class="line">                    AddO[NumOfLoop] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((str1.<span class="built_in">length</span>() == str2.<span class="built_in">length</span>() &amp;&amp; str1 &gt; str2) || (str1.<span class="built_in">length</span>() &gt; str2.<span class="built_in">length</span>()) || (str1[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> &amp;&amp; str2[<span class="number">0</span>] != <span class="string">&#x27;n&#x27;</span>)) &amp;&amp; Kill == <span class="number">0</span>) &#123;</span><br><span class="line">                    Kill = <span class="number">1</span>;</span><br><span class="line">                    WhereKill = NumOfLoop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                Omax = <span class="built_in">max</span>(Omax, Onow);</span><br><span class="line">                vis[var[NumOfLoop]] = <span class="number">0</span>; </span><br><span class="line">                <span class="keyword">if</span> (AddO[NumOfLoop] == <span class="number">1</span>) &#123;</span><br><span class="line">                    Onow--;</span><br><span class="line">                    AddO[NumOfLoop] = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                NumOfLoop--; </span><br><span class="line">                <span class="keyword">if</span> (WhereKill &gt; <span class="number">0</span> &amp;&amp; NumOfLoop &lt; WhereKill) &#123;</span><br><span class="line">                    Kill = <span class="number">0</span>; WhereKill = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(NumOfLoop == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">                cal = <span class="number">-1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERR\n&quot;</span>); </span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop == <span class="number">0</span> &amp;&amp; Omax == O) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop == <span class="number">0</span> &amp;&amp; Omax != O) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 34ms 756kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T3-逛公园"><a href="#D1T3-逛公园" class="headerlink" title="$D1T3$ 逛公园"></a>$D1T3$ <a href="https://www.luogu.org/problemnew/show/P3953">逛公园</a></h2><p>本题思路来自<a href="https://www.luogu.org/blog/Annie-007/ti-xie-p3953-guang-gong-yuan">安妮007的题解</a></p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ol>
<li>先SPFA求最短路</li>
<li>再反向SPFA排除无法到达的边</li>
<li>再记忆化搜索走冤枉路的最优方案</li>
</ol>
<p>详细见<a href="https://www.luogu.org/blog/Annie-007/ti-xie-p3953-guang-gong-yuan">安妮007的题解</a></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, p, T;</span><br><span class="line">vector&lt;Node&gt; v[maxn], s[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn], ans[maxn][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][<span class="number">60</span>], alive[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q, f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//a当前点,b允许走的冤枉路长度</span></span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[a][b] == <span class="number">1</span>) &#123;  <span class="comment">//又回来了</span></span><br><span class="line">        <span class="keyword">return</span> -inf;              <span class="comment">//无穷多种(-inf用于判断)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ans[a][b] != <span class="number">-1</span>) &#123; <span class="comment">//算过了</span></span><br><span class="line">        <span class="keyword">return</span> ans[a][b];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vis[a][b] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == n) &#123; <span class="comment">//到目的地</span></span><br><span class="line">            key++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[a].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = v[a][i].x, y = v[a][i].y; <span class="comment">//g本条边终点,y权值</span></span><br><span class="line">            <span class="keyword">int</span> u = d[g] - d[a];</span><br><span class="line">            <span class="keyword">if</span> (alive[g] == <span class="number">0</span>) &#123; <span class="comment">//不能到终点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="built_in">dfs</span>(g, b - (y - u));</span><br><span class="line">            <span class="keyword">if</span> (w == -inf) &#123;</span><br><span class="line">                <span class="keyword">return</span> -inf;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                key = (key + w) % p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[a][b] = key % p;</span><br><span class="line">        vis[a][b] = <span class="literal">false</span>; <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe</span><span class="params">()</span> </span>&#123; <span class="comment">//排除无法到终点的点(反向SPFA)</span></span><br><span class="line">    f.<span class="built_in">push</span>(n);</span><br><span class="line">    alive[n] = <span class="number">1</span>;  <span class="comment">//点n自身可以到达</span></span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = f.<span class="built_in">front</span>(); f.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[h].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = s[h][i].x;</span><br><span class="line">            <span class="keyword">if</span> (alive[g] == <span class="number">0</span>) &#123;</span><br><span class="line">                alive[g] = <span class="number">1</span>;</span><br><span class="line">                f.<span class="built_in">push</span>(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123; <span class="comment">//SPFA求最短路</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[h].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = v[h][i].x, y = v[h][i].y;</span><br><span class="line">            <span class="keyword">if</span> (d[h] + y &lt; d[g]) &#123;</span><br><span class="line">                d[g] = d[h] + y;</span><br><span class="line">                q.<span class="built_in">push</span>(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            v[i].<span class="built_in">clear</span>();</span><br><span class="line">            s[i].<span class="built_in">clear</span>();</span><br><span class="line">            alive[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                ans[i][j] = <span class="number">-1</span>;</span><br><span class="line">                vis[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            v[a].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(b, c));     <span class="comment">//正向边</span></span><br><span class="line">            s[b].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(a, c));     <span class="comment">//反向边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            d[i] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">spfa</span>();  <span class="comment">//SPFA求最短路</span></span><br><span class="line">        <span class="built_in">safe</span>();</span><br><span class="line">        <span class="keyword">int</span> z = <span class="built_in">dfs</span>(<span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">if</span> (z == -inf) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 6488ms 44632kB with O2 */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T1-奶酪"><a href="#D2T1-奶酪" class="headerlink" title="$D2T1$ 奶酪"></a>$D2T1$ <a href="https://www.luogu.org/problemnew/show/P3958">奶酪</a></h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>没什么好说的,直接__<em>搜索</em>__<br>存好每个点,排序,从下向上搜</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> fini = <span class="literal">false</span>, vis[maxn];</span><br><span class="line"><span class="keyword">int</span> T, n, h, r;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, z;</span><br><span class="line">&#125; node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &gt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>) + <span class="built_in">pow</span>(a.z - b.z, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node now, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now.z + r &gt;= h) &#123;</span><br><span class="line">        fini = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[num] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fini) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vis[i] &amp;&amp; <span class="built_in">dist</span>(node[i], now) &lt;= r * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(node[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        fini = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(node));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;h, &amp;r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;node[i].x, &amp;node[i].y, &amp;node[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(node + <span class="number">1</span>, node + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node[i].z - r &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(node[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(fini ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 157ms 832kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T2-宝藏"><a href="#D2T2-宝藏" class="headerlink" title="$D2T2$ 宝藏"></a>$D2T2$ <a href="https://www.luogu.org/problemnew/show/P3959">宝藏</a></h2><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>状压?? 模拟退火?? <del>不存在的</del> 蒟蒻不会<br>__<em>搜索+剪枝</em>__能很快AC掉这道紫题<br>不解释了</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">20</span>], dis[<span class="number">20</span>], num[<span class="number">20</span>]; <span class="comment">//已访问的点,距1的距离,可以到达的点数</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">20</span>][<span class="number">20</span>], G[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">//费用,图</span></span><br><span class="line"><span class="keyword">int</span> ans = inf, tmp, tot, cnt, n, m, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[p][a] &lt; c[p][b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot + tmp * dis[vis[i]] &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = node; j &lt;= num[vis[i]]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dis[G[vis[i]][j]]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[cnt] = G[vis[i]][j];</span><br><span class="line">                tmp -= c[vis[cnt]][G[vis[cnt]][<span class="number">1</span>]];</span><br><span class="line">                tot += c[vis[i]][vis[cnt]] * dis[vis[i]];</span><br><span class="line">                dis[vis[cnt]] = dis[vis[i]] + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j + <span class="number">1</span>);</span><br><span class="line">                tot -= c[vis[i]][vis[cnt]] * dis[vis[i]];</span><br><span class="line">                dis[vis[cnt]] = <span class="number">0</span>;</span><br><span class="line">                tmp += c[vis[cnt]][G[vis[cnt]][<span class="number">1</span>]];</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot &lt; ans) ans = tot;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            c[i][j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="keyword">if</span>(c[u][v] &lt; w) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[u][v] == inf) &#123;</span><br><span class="line">            G[u][++num[u]] = v;</span><br><span class="line">            G[v][++num[v]] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        c[u][v] = c[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = i;</span><br><span class="line">        <span class="built_in">sort</span>(G[i] + <span class="number">1</span>, G[i] + <span class="number">1</span> + num[i], cmp);</span><br><span class="line">        tmp += c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        tot = <span class="number">0</span>; cnt = <span class="number">1</span>;</span><br><span class="line">        vis[<span class="number">1</span>] = i;</span><br><span class="line">        tmp -= c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">        dis[i] = <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        dis[i] = <span class="number">0</span>;</span><br><span class="line">        tmp += c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 65ms 808kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T3-列队"><a href="#D2T3-列队" class="headerlink" title="$D2T3$ 列队"></a>$D2T3$ <a href="https://www.luogu.org/problemnew/show/P3960">列队</a></h2><p>平衡树?? $Splay$?? $FHQ\_Treap$?? <del>不会</del><br>模拟拿下$50$分,以后再说,<del>逃</del></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, q, tot;</span><br><span class="line">LL last[maxn], h[maxn], pos[<span class="number">510</span>][<span class="number">50010</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        a[i].x = <span class="built_in">read</span>();</span><br><span class="line">        a[i].y = <span class="built_in">read</span>();</span><br><span class="line">        h[i] = a[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        last[i] = last[i - <span class="number">1</span>] + m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(h + <span class="number">1</span>, h + q + <span class="number">1</span>);                 <span class="comment">//排序</span></span><br><span class="line">    tot = <span class="built_in">unique</span>(h + <span class="number">1</span>, h + q + <span class="number">1</span>) - h - <span class="number">1</span>; <span class="comment">//去重</span></span><br><span class="line">    LL t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123; <span class="comment">//编号</span></span><br><span class="line">        t = (LL)(h[i] - <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            pos[i][j] = ++t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> where; <span class="comment">//a[i].x在h数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123; <span class="comment">//模拟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[j] == a[i].x) &#123;</span><br><span class="line">                where = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i].y == m) &#123; <span class="comment">//在最后一列</span></span><br><span class="line">            ans = last[h[where]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = pos[where][a[i].y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">if</span> (a[i].y != m) &#123; <span class="comment">//向左看齐</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i].y; j &lt; m - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                pos[where][j] = pos[where][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            pos[where][m - <span class="number">1</span>] = last[h[where]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h[where]; j &lt; n; ++j) &#123; <span class="comment">//向前看齐</span></span><br><span class="line">            last[j] = last[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        last[n] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 50Points 13662ms 67344kB */</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」魔术球问题-题解</title>
    <url>/p/f2e850c0.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2765">「Luogu P2765」魔术球问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>输入柱子数$n$<br>满足如下规则</p>
<ul>
<li>每次只能在某根柱子的最上面放球。</li>
<li>在同一根柱子中，任何2个相邻球的编号之和为完全平方数。<br>输出在第$n$根柱子上最多能放多少球和放置方案</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>并不打算使用网络流,用贪心即可<br><em>贪心策略</em>: <strong>如果可以的话尽可能放在已有的柱子上</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> can[<span class="number">4010</span>];</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">1</span>, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= <span class="number">4000</span>; ++i) &#123;</span><br><span class="line">        can[i * i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can[ ans + a[ i ][ a[i].<span class="built_in">size</span>() - <span class="number">1</span> ] ]) &#123;</span><br><span class="line">                a[i].<span class="built_in">push_back</span>(ans++);</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; n) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            a[cnt].<span class="built_in">push_back</span>(ans++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最小路径覆盖问题-题解</title>
    <url>/p/7973b062.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2764">「Luogu P2764」最小路径覆盖问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>题目描述给的很直白,输入点数边数和有向边,输出最少路径数和路径</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>正常建图<br>如果一条路径的终点和另一条路径的起点有连边，那么这两条路径是可以合并的。<br>但是一个终点或起点只能使用一次。比如三条路径$1 \rightarrow 3, 2 \rightarrow 3, 3 \rightarrow 4$，你只能合并两条。<br>那么这道题就转化为了：最大化一个边集，使得边集中每个起点和终点都只使用过一次。即__最大独立边集__。<br>把每个点拆成入点$x$和出点$x’$,从源点到$x’$连一条容量为$1$的边，从$x$到汇点连一条容量为$1$的边。边权用来限制每个起点或终点的使用次数。<br>对于每条边$x \rightarrow y$，连接$x’ \rightarrow y$<br>答案是$n-最大流$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn], vst[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn], to[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="literal">true</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            to[x] = e.to;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    s = <span class="number">0</span>; t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v + n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(s, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(i + n, t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">maxflow</span>(s, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vst[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i; vst[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">            <span class="keyword">while</span> (to[x] &amp;&amp; to[x] != t) &#123;</span><br><span class="line">                x = to[x] - n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">                vst[x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」试题库问题-题解</title>
    <url>/p/5a8ce31f.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2763">「Luogu P2763」试题库问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>假设一个试题库中有$n$道试题,每道试题都标明了所属类别,同一道题可能有多个类别属性,现要从题库中抽取$m$道题组成试卷,并要求试卷包含指定类型的试题,输出出题方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>建图</strong>: 类型与汇点连容量为题目数的边;题目与源点连容量为$1$的边;题目与所属类型连容量为$1$的边<br><strong>结果</strong>: 如果满流则可以实现(沿满流输出即可),没有满流输出<code>No Solution!</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> k, n, s, t, sum, d[maxn], cur[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn], ansi;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">    s = <span class="number">0</span>; t = n + k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;type);</span><br><span class="line">        sum += type; <span class="built_in">add</span>(n + i, t, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> p, type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;type);</span><br><span class="line">            <span class="built_in">add</span>(i, type + n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">MaxFlow</span>(s, t);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == sum) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + k; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>, i - n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[i][j]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap == <span class="number">0</span> &amp;&amp; e.flow != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Solution!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P5020 P1621 P4942」小练习-题解</title>
    <url>/p/eb0c7a6c.html</url>
    <content><![CDATA[<h2 id="mathcal-「P5020」-货币系统"><a href="#mathcal-「P5020」-货币系统" class="headerlink" title="$\mathcal{「P5020」}$ 货币系统"></a>$\mathcal{「P5020」}$ <a href="https://www.luogu.org/problemnew/show/P5020">货币系统</a></h2><p>表面上是数论，其实就是个__<em>动态规划</em>__</p>
<p>首先设$A = (n, a) \ \ B = (m, b)$<br>可以证明$B \subseteq A$<br>$proof:$<br>    我们设$x\in A$且$x$不能被$A$集合内除它以外的元素组成。<br>    然后我们假设$x \notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。<br>    那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。<br>    综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内<br>$Q.E.D$</p>
<p>然后动态规划<br><code>dp[i]</code>表示$i$面值最多能被几张钱表示<br>则若其不能被表示<code>dp[i] = -inf</code><br>能表示且只有它自己则<code>dp[i] = 1</code><br>初始化<code>dp[] = -inf; dp[0] = 0</code><br>状态转移方程为<code>dp[j] = max(dp[j], dp[j - a[i]] + 1)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, ans, a[<span class="number">1010</span>], dp[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        ans = <span class="number">0</span>; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= <span class="number">25010</span>; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[a[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 862ms 944kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="mathcal-「P1621」-集合"><a href="#mathcal-「P1621」-集合" class="headerlink" title="$\mathcal{「P1621」}$ 集合"></a>$\mathcal{「P1621」}$ <a href="https://www.luogu.org/problemnew/show/P1621">集合</a></h2><p>使用__<em>并查集</em><strong>和</strong><em>埃氏筛法</em>__(埃拉托斯特尼筛法)即可<br>具体操作是边筛边合并集合</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ufs[maxn], a, b, p, ans;</span><br><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ufs[x] == x ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    ans = b - a + <span class="number">1</span>;               <span class="comment">//初始个数为区间内数的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= b; ++i) &#123; <span class="comment">//初始化</span></span><br><span class="line">        ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= b; ++i) &#123; <span class="comment">//埃氏筛</span></span><br><span class="line">        <span class="keyword">if</span> (!isprime[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p) &#123;          <span class="comment">//大于p才合并</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= b; j += i) &#123;</span><br><span class="line">                    isprime[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &gt;= a &amp;&amp; <span class="built_in">find</span>(j) != <span class="built_in">find</span>(j - i)) &#123; <span class="comment">//合并</span></span><br><span class="line">                        ufs[<span class="built_in">find</span>(j)] = <span class="built_in">find</span>(j - i);</span><br><span class="line">                        --ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;               <span class="comment">//不大于p但要标记</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= b; j += i) &#123;</span><br><span class="line">                    isprime[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 38ms 1312kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="mathcal-「P4942」-小凯的数字"><a href="#mathcal-「P4942」-小凯的数字" class="headerlink" title="$\mathcal{「P4942」}$ 小凯的数字"></a>$\mathcal{「P4942」}$ <a href="https://www.luogu.org/problemnew/show/P4942">小凯的数字</a></h2><p>类似于$NOIp2017\ D1T1$ <a href="https://www.luogu.org/problemnew/show/P3951">小凯的疑惑</a>,推柿子即可</p>
<p>首先$l(l+1)(l+2)…(r-1)r$可以表示为$l\times 10^? + (l + 1)\times 10^? + … + r\times 10^?$<br>同时我们知道$10$的若干次方除以$9$的余数__恒为__$1$<br>所以$l(l+1)(l+2)…(r-1)r$除以$9$的余数就等于$l + (l + 1) + … + (r - 1) + r$的余数<br>并且$l,l+1,…,r$为等差数列,公差为$1$<br>运用等差数列求和公式即可求解</p>
<p>$a_1 = l\ d = 1$<br>$n = r - l + 1$<br>$S_n = n\times a_1 + n\times (n - 1)\times \frac{d}{2}$<br>所以<br>$$<br>\boxed{Ans = n\times l + n\times (n - 1) \div 2}<br>$$</p>
<p>另外要边算边取模,除以$2$要变成乘模$9$下的逆元$5$<br>所以公式如下<br><code>ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l, r, n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        n = (r - l + <span class="number">1</span>) % <span class="number">9</span>;</span><br><span class="line">        ans = (n * (l % <span class="number">9</span>) % <span class="number">9</span> + n * (n - <span class="number">1</span>) % <span class="number">9</span> * <span class="number">5</span> % <span class="number">9</span>) % <span class="number">9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 32ms 888kB */</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」飞行员配对方案问题-题解</title>
    <url>/p/154ff24f.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2756">「Luogu P2756」飞行员配对方案数问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>输入两方飞行员个数$m,n$,再给定两方飞行员可以配合的人编号$i,j$(以$-1,-1$结束)<br>输出最多配对数和配对方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>主要在建图<br>皇家空军与源点$s$连容量$1$的边,外籍与汇点$t$连容量$1$的边,可配合的两点间连容量为$1$的边<br>输出最大流即可(要找配对方案)</p>
<p>也可以使用匈牙利算法(本文不给出)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">             Edge&amp; e = edges[G[x][i]];</span><br><span class="line">             <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                 vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                 d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                 Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v) == <span class="number">2</span> &amp;&amp; u != <span class="number">-1</span> &amp;&amp; v != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">add</span>(u, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, t, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="built_in">MaxFlow</span>(s, t);</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Solution!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, flow);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[i].from != s &amp;&amp; edges[i].to != t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[i].flow != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, edges[i].from, edges[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-网络流相关</title>
    <url>/p/c3cdab79.html</url>
    <content><![CDATA[<p>网络流算法相关模板,讲解__以后再说吧__,咕咕咕</p>
<span id="more"></span>

<p>注:本文使用<code>vector</code>建图</p>
<h2 id="网络最大流"><a href="#网络最大流" class="headerlink" title="网络最大流"></a>网络最大流</h2><h3 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, s, t, ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdmondsKarp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        a[s] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!a[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    p[e.to] = G[x][i];</span><br><span class="line">                    a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[t]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!a[t]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">            edges[p[u]].flow += a[t];</span><br><span class="line">            edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dinic算法-常用"><a href="#Dinic算法-常用" class="headerlink" title="Dinic算法(常用)"></a>Dinic算法(常用)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ISAP算法"><a href="#ISAP算法" class="headerlink" title="ISAP算法"></a>ISAP算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], p[maxn], num[maxn], cur[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(t);</span><br><span class="line">    d[t] = <span class="number">0</span>; vis[t] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.from] = <span class="number">1</span>;</span><br><span class="line">                d[e.from] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.from);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Augment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = t, a = inf;</span><br><span class="line">    <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">        Edge&amp; e = edges[p[x]];</span><br><span class="line">        a = <span class="built_in">min</span>(a, e.cap - e.flow);</span><br><span class="line">        x = edges[p[x]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    x = t;</span><br><span class="line">    <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">        edges[p[x]].flow += a;</span><br><span class="line">        edges[p[x] ^ <span class="number">1</span>].flow -= a;</span><br><span class="line">        x = edges[p[x]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) num[d[i]]++;</span><br><span class="line">    <span class="keyword">int</span> x = s;</span><br><span class="line">    <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">    <span class="keyword">while</span> (d[s] &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t) &#123;</span><br><span class="line">            flow += <span class="built_in">Augment</span>();</span><br><span class="line">            x = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + <span class="number">1</span>) &#123;</span><br><span class="line">                ok = <span class="number">1</span>;</span><br><span class="line">                p[e.to] = G[x][i];</span><br><span class="line">                cur[x] = i;</span><br><span class="line">                x = e.to;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="keyword">int</span> mm = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; e.flow) mm = <span class="built_in">min</span>(mm, d[e.to]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--num[d[x]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            num[d[x] = mm + <span class="number">1</span>]++;</span><br><span class="line">            cur[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (x != s) x = edges[p[x]].from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = inf;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">                d[e.to] = d[x] + e.cost;</span><br><span class="line">                p[e.to] = G[x][i];</span><br><span class="line">                a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    flow += a[t];</span><br><span class="line">    cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">        edges[p[u]].flow += a[t];</span><br><span class="line">        edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记-计算几何</title>
    <url>/p/1aba30fe.html</url>
    <content><![CDATA[<p>啥也不说了,直接上代码,每个函数功能已经以注释方式给出</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> *  &gt; Description      : 计算几何模板</span></span><br><span class="line"><span class="comment"> *  &gt; Copyright (C) 2019 Tony</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;     <span class="comment">//精度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI  = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点(向量)</span></span><br><span class="line"><span class="comment"> * @param x 横坐标</span></span><br><span class="line"><span class="comment"> * @param y 纵坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line">Vector <span class="keyword">operator</span> + (Vector a, Vector b) &#123; <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Vector a, Vector b) &#123; <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> * (Vector a, <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x * p, a.y * p); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> / (Vector a, <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x / p, a.y / p); &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 带精度比较(三态函数)</span></span><br><span class="line"><span class="comment"> * @param[in]  x  输入</span></span><br><span class="line"><span class="comment"> * @return 大小关系：等于0(0), 小于零(-1), 大于零(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(a.x - b.x) == <span class="number">0</span> &amp;&amp; <span class="built_in">dcmp</span>(a.y - b.y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.x + a.y * b.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span><span class="params">(Vector a)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Dot</span>(a, a)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">Dot</span>(a, b) / <span class="built_in">Length</span>(a) / <span class="built_in">Length</span>(b)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.y - a.y * b.x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Area2</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Cross</span>(b - a, c - a); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dist2</span><span class="params">(<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B)</span> </span>&#123; <span class="keyword">return</span> (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">angle</span><span class="params">(Vector v)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(v.y, v.x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向量旋转</span></span><br><span class="line"><span class="comment"> * @param[in]  a    向量</span></span><br><span class="line"><span class="comment"> * @param[in]  rad  旋转角度(逆时针)</span></span><br><span class="line"><span class="comment"> * @return 旋转后的向量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector a, <span class="keyword">double</span> rad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x * <span class="built_in">cos</span>(rad) - a.y * <span class="built_in">sin</span>(rad), a.x * <span class="built_in">sin</span>(rad) + a.y * <span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求单位向量</span></span><br><span class="line"><span class="comment"> * @param[in]  a  向量</span></span><br><span class="line"><span class="comment"> * @return 沿向量a的单位向量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Vector <span class="title">Normal</span><span class="params">(Vector a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> L = <span class="built_in">Length</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(-a.y / L, a.x / L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两条直线交点</span></span><br><span class="line"><span class="comment"> * @param[in]  p  第一条直线的起始点</span></span><br><span class="line"><span class="comment"> * @param[in]  v  第一条直线的方向向量</span></span><br><span class="line"><span class="comment"> * @param[in]  q  第二条直线的起始点</span></span><br><span class="line"><span class="comment"> * @param[in]  w  第二条直线的方向向量</span></span><br><span class="line"><span class="comment"> * @return 两条直线交点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Point p, Vector v, Point q, Vector w)</span> </span>&#123;</span><br><span class="line">    Vector u = p - q;</span><br><span class="line">    <span class="keyword">double</span> t = <span class="built_in">Cross</span>(w, u) / <span class="built_in">Cross</span>(v, w);</span><br><span class="line">    <span class="keyword">return</span> p + v * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点到直线距离</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  直线上两点</span></span><br><span class="line"><span class="comment"> * @return 点到直线距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToLine</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    Vector v1 = b - a, v2 = p - a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(v1, v2)) / <span class="built_in">Length</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点到线段距离</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  线段两端点</span></span><br><span class="line"><span class="comment"> * @return 点到线段距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToSegment</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="built_in">Length</span>(p - a);</span><br><span class="line">    Vector v1 = b - a, v2 = p - a, v3 = p - b;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(v1, v2)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Length</span>(v2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(v1, v3)) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Length</span>(v3);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(v1, v2)) / <span class="built_in">Length</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点在直线上投影点</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  直线上两点</span></span><br><span class="line"><span class="comment"> * @return 点在直线上投影点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineProjection</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    Vector v = b - a;</span><br><span class="line">    <span class="keyword">return</span> a + v * (<span class="built_in">Dot</span>(v, p - a) / <span class="built_in">Dot</span>(v, v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线段相交判定(不含端点)</span></span><br><span class="line"><span class="comment"> * @param[in]  a1,a2  第一条线段端点</span></span><br><span class="line"><span class="comment"> * @param[in]  b1,b2  第二条线段端点</span></span><br><span class="line"><span class="comment"> * @return 是否相交(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SegmentProperIntersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = <span class="built_in">Cross</span>(a2 - a1, b1 - a1), c2 = <span class="built_in">Cross</span>(a2 - a1, b2 - a1),</span><br><span class="line">           c3 = <span class="built_in">Cross</span>(b2 - b1, a1 - b1), c4 = <span class="built_in">Cross</span>(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(c1) * <span class="built_in">dcmp</span>(c2) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">dcmp</span>(c3) * <span class="built_in">dcmp</span>(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点在线段上判定(不包括端点)</span></span><br><span class="line"><span class="comment"> * @param[in]  p      点</span></span><br><span class="line"><span class="comment"> * @param[in]  a1,a2  线段两端点</span></span><br><span class="line"><span class="comment"> * @return 是否在线段上(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; <span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 多边形面积</span></span><br><span class="line"><span class="comment"> * @param[in]  *p  顶点数组</span></span><br><span class="line"><span class="comment"> * @param[in]</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolygonArea</span><span class="params">(Point* p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        area += <span class="built_in">Cross</span>(p[i] - p[<span class="number">0</span>], p[i + <span class="number">1</span>] - p[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 直线(参数式)</span></span><br><span class="line"><span class="comment"> * @param p   直线上的一点</span></span><br><span class="line"><span class="comment"> * @param v   方向向量</span></span><br><span class="line"><span class="comment"> * @param ang 方向向量极角</span></span><br><span class="line"><span class="comment"> * @function point(double t)</span></span><br><span class="line"><span class="comment"> *     @brief        直线上的点</span></span><br><span class="line"><span class="comment"> *     @param[in] t  横坐标</span></span><br><span class="line"><span class="comment"> *     @return       直线上的点</span></span><br><span class="line"><span class="comment"> * @function move(double d)</span></span><br><span class="line"><span class="comment"> *     @brief        沿直线移动</span></span><br><span class="line"><span class="comment"> *     @param[in] d  平移距离</span></span><br><span class="line"><span class="comment"> *     @return       平移后的直线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point p;</span><br><span class="line">    Vector v;</span><br><span class="line">    <span class="keyword">double</span> ang;</span><br><span class="line">    <span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Line</span>(Point p, Vector v): <span class="built_in">p</span>(p), <span class="built_in">v</span>(v) &#123; ang = <span class="built_in">atan2</span>(v.y, v.x); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Line&amp; L) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ang &lt; L.ang;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p + v * t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Line <span class="title">move</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Line</span>(p + <span class="built_in">Normal</span>(v) * d, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 是否在直线左侧</span></span><br><span class="line"><span class="comment"> * @param[in]  L  直线</span></span><br><span class="line"><span class="comment"> * @param[in]  p  点</span></span><br><span class="line"><span class="comment"> * @return 是否在点左侧(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnLeft</span><span class="params">(Line L, Point p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cross</span>(L.v, p - L.p) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两条直线交点(重载)</span></span><br><span class="line"><span class="comment"> * @param[in]  a  第一条直线</span></span><br><span class="line"><span class="comment"> * @param[in]  b  第二条直线</span></span><br><span class="line"><span class="comment"> * @return 两条直线交点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    Vector u = a.p - b.p;</span><br><span class="line">    <span class="keyword">double</span> t = <span class="built_in">Cross</span>(b.v, u) / <span class="built_in">Cross</span>(a.v, b.v);</span><br><span class="line">    <span class="keyword">return</span> a.p + a.v * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 圆</span></span><br><span class="line"><span class="comment"> * @param c   圆心</span></span><br><span class="line"><span class="comment"> * @param r   半径</span></span><br><span class="line"><span class="comment"> * @function point(double a)</span></span><br><span class="line"><span class="comment"> *     @brief         圆上的点</span></span><br><span class="line"><span class="comment"> *     @param[in]  a  横坐标</span></span><br><span class="line"><span class="comment"> *     @return        圆上的点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    Point c;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="built_in">Circle</span>(Point c, <span class="keyword">double</span> r): <span class="built_in">c</span>(c), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(c.x + <span class="built_in">cos</span>(a) * r, c.y + <span class="built_in">sin</span>(a) * r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 直线和圆交点</span></span><br><span class="line"><span class="comment"> * @param[in]   L      直线</span></span><br><span class="line"><span class="comment"> * @param[in]   C      圆</span></span><br><span class="line"><span class="comment"> * @param[out]  t1,t2  交点横坐标</span></span><br><span class="line"><span class="comment"> * @param[out]  sol    交点集(vector)</span></span><br><span class="line"><span class="comment"> * @return 交点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLineCircleIntersection</span><span class="params">(Line L, Circle C, <span class="keyword">double</span>&amp; t1, <span class="keyword">double</span>&amp; t2, vector&lt;Point&gt;&amp; sol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line">    <span class="keyword">double</span> e = a * a + c * c, f = <span class="number">2</span> * (a * b + c * d), g = b * b + d * d - C.r * C.r;</span><br><span class="line">    <span class="keyword">double</span> delta = f * f - <span class="number">4</span> * e * g;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(delta) &lt; <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(delta) == <span class="number">0</span>) &#123;</span><br><span class="line">        t1 = t2 = -f / (<span class="number">2</span> * e);</span><br><span class="line">        sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t1));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = (-f - <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span> * e); sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t1));</span><br><span class="line">    t2 = (-f + <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span> * e); sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 圆和圆交点</span></span><br><span class="line"><span class="comment"> * @param[in]   C1,C2  两圆</span></span><br><span class="line"><span class="comment"> * @param[out]  sol    交点集(vector)</span></span><br><span class="line"><span class="comment"> * @return 交点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCircleCircleIntersection</span><span class="params">(Circle C1, Circle C2, vector&lt;Point&gt;&amp; sol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="built_in">Length</span>(C1.c - C2.c);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(d) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dcmp</span>(C1.r - C2.r) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(C1.r + C2.r - d) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">fabs</span>(C1.r - C2.r) - d) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="built_in">angle</span>(C2.c - C1.c);</span><br><span class="line">    <span class="keyword">double</span> da = <span class="built_in">acos</span>((C1.r * C1.r + d * d - C2.r * C2.r) / (<span class="number">2</span> * C1.r * d));</span><br><span class="line">    Point p1 = C1.<span class="built_in">point</span>(a - da), p2 = C1.<span class="built_in">point</span>(a + da);</span><br><span class="line">    sol.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    sol.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求切线</span></span><br><span class="line"><span class="comment"> * @param[in]   p   点</span></span><br><span class="line"><span class="comment"> * @param[in]   C   圆</span></span><br><span class="line"><span class="comment"> * @param[out]  *v  切线</span></span><br><span class="line"><span class="comment"> * @return 切线条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Point p, Circle C, Vector* v)</span> </span>&#123;</span><br><span class="line">    Vector u = C.c - p;</span><br><span class="line">    <span class="keyword">double</span> dist = <span class="built_in">Length</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (dist &lt; C.r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">dcmp</span>(dist - C.r) == <span class="number">0</span>) &#123;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="built_in">Rotate</span>(u, PI / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">asin</span>(C.r / dist);</span><br><span class="line">        v[<span class="number">0</span>] = <span class="built_in">Rotate</span>(u, -ang);</span><br><span class="line">        v[<span class="number">1</span>] = <span class="built_in">Rotate</span>(u, +ang);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两圆公切线</span></span><br><span class="line"><span class="comment"> * @param[in]   A,B    两圆</span></span><br><span class="line"><span class="comment"> * @param[out]  *a,*b  切点</span></span><br><span class="line"><span class="comment"> * @return 公切线条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Circle A, Circle B, Point* a, Point* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (A.r - B.r) &#123; <span class="built_in">swap</span>(A, B); <span class="built_in">swap</span>(a, b); &#125;</span><br><span class="line">    <span class="keyword">int</span> d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y);</span><br><span class="line">    <span class="keyword">int</span> rdiff = A.r - B.r;</span><br><span class="line">    <span class="keyword">int</span> rsum  = A.r + B.r;</span><br><span class="line">    <span class="keyword">if</span> (d2 &lt; rdiff * rdiff) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> base = <span class="built_in">atan2</span>(B.c.y - A.c.y, B.c.x - A.c.x);</span><br><span class="line">    <span class="keyword">if</span> (d2 == <span class="number">0</span> &amp;&amp; A.r == B.r) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d2 == rdiff * rdiff) &#123;</span><br><span class="line">        a[cnt] = A.<span class="built_in">point</span>(base);</span><br><span class="line">        b[cnt] = B.<span class="built_in">point</span>(base);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r - B.r) / <span class="built_in">sqrt</span>(d2));</span><br><span class="line">    a[cnt] = A.<span class="built_in">point</span>(base + ang); b[cnt] = B.<span class="built_in">point</span>(base + ang); cnt++;</span><br><span class="line">    a[cnt] = A.<span class="built_in">point</span>(base - ang); b[cnt] = B.<span class="built_in">point</span>(base - ang); cnt++;</span><br><span class="line">    <span class="keyword">if</span> (d2 == rsum * rsum) &#123;</span><br><span class="line">        a[cnt] = A.<span class="built_in">point</span>(base);</span><br><span class="line">        b[cnt] = B.<span class="built_in">point</span>(PI + base);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d2 &gt; rsum * rsum) &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r + B.r) / <span class="built_in">sqrt</span>(d2));</span><br><span class="line">        a[cnt] = A.<span class="built_in">point</span>(base + ang); b[cnt] = B.<span class="built_in">point</span>(PI + base + ang); cnt++;</span><br><span class="line">        a[cnt] = A.<span class="built_in">point</span>(base - ang); b[cnt] = B.<span class="built_in">point</span>(PI + base - ang); cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;Point&gt; Polygon;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判定点在多边形内</span></span><br><span class="line"><span class="comment"> * @param[in]  p     点</span></span><br><span class="line"><span class="comment"> * @param[in]  poly  多边形</span></span><br><span class="line"><span class="comment"> * @return 是否在多边形内(在1,不在0,在边上-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, Polygon poly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = poly.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">OnSegment</span>(p, poly[i], poly[(i + <span class="number">1</span>) % n])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(poly[(i + <span class="number">1</span>) % n] - poly[i], p - poly[i]));</span><br><span class="line">        <span class="keyword">int</span> d1 = <span class="built_in">dcmp</span>(poly[i].y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = <span class="built_in">dcmp</span>(poly[(i + <span class="number">1</span>) % n].y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 凸包</span></span><br><span class="line"><span class="comment"> * @param[in]  p  点集</span></span><br><span class="line"><span class="comment"> * @return 凸包多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Polygon <span class="title">ConvexHull</span><span class="params">(vector&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">    p.<span class="built_in">erase</span>(<span class="built_in">unique</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()), p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Polygon <span class="title">ch</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Cross</span>(ch[m - <span class="number">1</span>] - ch[m - <span class="number">2</span>], p[i] - ch[m - <span class="number">2</span>]) &lt;= <span class="number">0</span>) m--;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; k &amp;&amp; <span class="built_in">Cross</span>(ch[m - <span class="number">1</span>] - ch[m - <span class="number">2</span>], p[i] - ch[m - <span class="number">2</span>]) &lt;= <span class="number">0</span>) m--;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) m--;</span><br><span class="line">    ch.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 旋转卡壳</span></span><br><span class="line"><span class="comment"> * @param[in]  points  点集</span></span><br><span class="line"><span class="comment"> * @return 直径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameter2</span><span class="params">(vector&lt;Point&gt;&amp; points)</span> </span>&#123; <span class="comment">//旋转卡壳</span></span><br><span class="line">    vector&lt;Point&gt; p = <span class="built_in">ConvexHull</span>(points);</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">Dist2</span>(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">    p.<span class="built_in">push_back</span>(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>, v = <span class="number">1</span>; u &lt; n; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="built_in">Cross</span>(p[u + <span class="number">1</span>] - p[u], p[v + <span class="number">1</span>] - p[v]);</span><br><span class="line">            <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (<span class="keyword">int</span>)<span class="built_in">Dist2</span>(p[u], p[v]));</span><br><span class="line">                <span class="keyword">if</span> (diff == <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, (<span class="keyword">int</span>)<span class="built_in">Dist2</span>(p[u], p[v + <span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v = (v + <span class="number">1</span>) % n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 切多边形</span></span><br><span class="line"><span class="comment"> * @param[in]  poly  多边形</span></span><br><span class="line"><span class="comment"> * @param[in]  A,B   直线上两点</span></span><br><span class="line"><span class="comment"> * @return 新多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Polygon <span class="title">CutPolygon</span><span class="params">(Polygon poly, Point A, Point B)</span> </span>&#123;</span><br><span class="line">    Polygon newpoly;</span><br><span class="line">    <span class="keyword">int</span> n = poly.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Point C = poly[i];</span><br><span class="line">        Point D = poly[(i + <span class="number">1</span>) % n];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(B - A, C - A)) &gt;= <span class="number">0</span>) newpoly.<span class="built_in">push_back</span>(C);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(B - A, C - D)) != <span class="number">0</span>) &#123;</span><br><span class="line">            Point ip = <span class="built_in">GetLineIntersection</span>(A, B - A, C, D - C);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OnSegment</span>(ip, C, D)) newpoly.<span class="built_in">push_back</span>(ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newpoly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 半平面交</span></span><br><span class="line"><span class="comment"> * @param[in]  L  直线集</span></span><br><span class="line"><span class="comment"> * @return 多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">HalfplaneIntersection</span><span class="params">(vector&lt;Line&gt; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = L.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> first, last;</span><br><span class="line">    <span class="function">vector&lt;Point&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;Line&gt;  <span class="title">q</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;Point&gt; ans;</span><br><span class="line">    q[first = last = <span class="number">0</span>] = L[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; !<span class="built_in">OnLeft</span>(L[i], p[last - <span class="number">1</span>])) last--;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; !<span class="built_in">OnLeft</span>(L[i], p[first]))   first++;</span><br><span class="line">        q[++last] = L[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">Cross</span>(q[last].v, q[last - <span class="number">1</span>].v)) &lt; eps) &#123;</span><br><span class="line">            last--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OnLeft</span>(q[last], L[i].p)) q[last] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first &lt; last) p[last - <span class="number">1</span>] = <span class="built_in">GetLineIntersection</span>(q[last - <span class="number">1</span>], q[last]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last &amp;&amp; !<span class="built_in">OnLeft</span>(q[first], p[last - <span class="number">1</span>])) last--;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt;= <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    p[last] = <span class="built_in">GetLineIntersection</span>(q[last], q[first]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) ans.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2018」题解</title>
    <url>/p/34a76f7d.html</url>
    <content><![CDATA[<pre><code>emmm，今天开始从2018向前做NOIp的真题，并写一些题解，太蒻了Orz
</code></pre>
<span id="more"></span>

<h2 id="D1T1-铺设道路"><a href="#D1T1-铺设道路" class="headerlink" title="$D1T1$ 铺设道路"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P5019">铺设道路</a></h2><p>嗯～13年原题，__<em>贪心AC</em>__</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对区间进行“填坑”<br>贪心策略：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (d[i] &gt; d[i - <span class="number">1</span>]) ans += d[i] - d[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>$proof:$<br>    假设现在有一个坑，旁边还有一个坑。<br>    那肯定会同时填上两个坑，所以__小的坑会被大的坑带着填上__，及__<em>小坑免费，大坑减少<code>a[i] - a[i - 1]</code></em>__<br>$Q.E.D$<br>结果还要加上<code>a[1]</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] &gt; d[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            ans += d[i] - d[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans + d[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 41ms 1220kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T2-货币系统"><a href="#D1T2-货币系统" class="headerlink" title="$D1T2$ 货币系统"></a>$D1T2$ <a href="https://www.luogu.org/problemnew/show/P5020">货币系统</a></h2><p>表面上是数论，其实就是个__<em>动态规划</em>__</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先设$A = (n, a) \ \ B = (m, b)$<br>可以证明$B \subseteq A$<br>$proof:$<br>    我们设$x\in A$且$x$不能被$A$集合内除它以外的元素组成。<br>    然后我们假设$x \notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。<br>    那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。<br>    综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内<br>$Q.E.D$</p>
<p>然后动态规划<br><code>dp[i]</code>表示$i$面值最多能被几张钱表示<br>则若其不能被表示<code>dp[i] = -inf</code><br>能表示且只有它自己则<code>dp[i] = 1</code><br>初始化<code>dp[] = -inf; dp[0] = 0</code><br>状态转移方程为<code>dp[j] = max(dp[j], dp[j - a[i]] + 1)</code></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, ans, a[<span class="number">1010</span>], dp[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        ans = <span class="number">0</span>; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= <span class="number">25010</span>; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[a[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 862ms 944kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T3-赛道修建"><a href="#D1T3-赛道修建" class="headerlink" title="$D1T3$ 赛道修建"></a>$D1T3$ <a href="https://www.luogu.org/problemnew/show/P5021">赛道修建</a></h2><p>这题比较复杂，先得部分分</p>
<h3 id="I-m-1-时"><a href="#I-m-1-时" class="headerlink" title="$I.$ $m = 1$ 时"></a>$I.$ $m = 1$ 时</h3><p>最简单的情况<br>求一条最长链，即求树的直径（记录一下最大值和次大值，每次把最大值传到它的父亲）<br>可以通过第$1,4,5,6$个点，$20$分</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Meq1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            res2 = <span class="built_in">max</span>(res2, <span class="built_in">dfs</span>(to, now) + edges[i].val);</span><br><span class="line">            <span class="keyword">if</span> (res2 &gt; res1) <span class="built_in">swap</span>(res1, res2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, res1 + res2);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="II-a-i-1-时"><a href="#II-a-i-1-时" class="headerlink" title="$II.$ $a_i = 1$ 时"></a>$II.$ $a_i = 1$ 时</h3><p>即一个菊花图<br>把所有边权记录下来，从大到小排序。设边权为$w$，答案即为$w_1+w_{2m-1},w_2+w_{2m-2},…,w_m+w_{m+1}$的最小值<br>可以通过$1,5,7,8$四个点，$20$分，加上$m = 1$的情况共$35$分</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Aeq1 &#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxn];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            arr[to - <span class="number">1</span>] = edges[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + n, cmp);</span><br><span class="line">        ans = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, arr[i] + arr[<span class="number">2</span> * m - i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="III-b-i-a-i-1-时"><a href="#III-b-i-a-i-1-时" class="headerlink" title="$III.$ $b_i = a_i + 1$ 时"></a>$III.$ $b_i = a_i + 1$ 时</h3><p>为一条链<br>把所有边权记录下来，这种情况等价于将序列分割成$m$段，使$m$段区间和的最小值最大<br>那么二分$m$段区间和的最小值，然后贪心扫一遍<br>可以通过$2,9,10,11$四个点，$20$分，加上一共$55$分</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BeqApl1 &#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxn], ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            res2 = <span class="built_in">max</span>(res2, <span class="built_in">Dfs</span>(to, now) + edges[i].val);</span><br><span class="line">            <span class="keyword">if</span> (res2 &gt; res1) <span class="built_in">swap</span>(res1, res2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, res1 + res2);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(to, now);</span><br><span class="line">            arr[now] = edges[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now + arr[i] &gt;= x) &#123;</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">                t++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                now += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">Dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = ans, mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>最小值最大，显然是二分这个最小值$lim$<br>对于一个节点$u$，我们可以记录一个连接到$u$的赛道的长度$val_i$，那么可以分成两种情况进行讨论：<br>$$\begin{cases} val_i+dis \geq lim \text{直接给答案+1} \\ val_i+dis&lt; lim \text{利用优先队列维护}\end{cases}$$</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, num, s[maxn], mid;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w) : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">val</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, w));</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; lh;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; sh;</span><br><span class="line">    <span class="keyword">int</span> ln = <span class="number">0</span>, sn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[u][i].to != fa) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = G[u][i].val + <span class="built_in">dfs</span>(G[u][i].to, u);</span><br><span class="line">            sh.<span class="built_in">push</span>(d); lh.<span class="built_in">push</span>(d);</span><br><span class="line">            ln++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ln &gt; <span class="number">0</span> &amp;&amp; lh.<span class="built_in">top</span>() &gt;= mid) &#123;num++; lh.<span class="built_in">pop</span>(); ln--;&#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ln &gt; sn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="number">1</span> &amp;&amp; lh.<span class="built_in">top</span>() + sh.<span class="built_in">top</span>() &gt;= mid) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ln &gt; sn &amp;&amp; lh.<span class="built_in">top</span>() + sh.<span class="built_in">top</span>() &gt;= mid) &#123;s[++cnt] = lh.<span class="built_in">top</span>(); lh.<span class="built_in">pop</span>(); ln--;&#125;</span><br><span class="line">            num++; sh.<span class="built_in">pop</span>(); sn++;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>) &#123;lh.<span class="built_in">push</span>(s[--cnt]); ln++;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == <span class="number">1</span> &amp;&amp; lh.<span class="built_in">top</span>() + sh.<span class="built_in">top</span>() &gt;= mid) &#123;</span><br><span class="line">            lh.<span class="built_in">pop</span>(); sh.<span class="built_in">pop</span>(); ln--; sn++; num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now = sh.<span class="built_in">top</span>(); sh.<span class="built_in">pop</span>(); sn++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= m) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ln &gt;= sn &amp;&amp; !lh.<span class="built_in">empty</span>()) <span class="keyword">return</span> lh.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(m); <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">read</span>(u); <span class="built_in">read</span>(v); <span class="built_in">read</span>(w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        all += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = all / m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>()) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1050ms 11964kB with O2 */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T1-旅行"><a href="#D2T1-旅行" class="headerlink" title="$D2T1$ 旅行"></a>$D2T1$ <a href="https://www.luogu.org/problemnew/show/P5022">旅行</a></h2><p>分两种情况讨论</p>
<h3 id="I-m-n-1"><a href="#I-m-n-1" class="headerlink" title="$I.$ $m = n - 1$"></a>$I.$ $m = n - 1$</h3><p>即无环，只要给一个点所能到达的点的编号进行一次从小到大的排序，在树上dfs一遍即可解决<br>样例1图示：<img src="/p/34a76f7d/P5022_1.png"></p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SolveOne &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        ans[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1050ms 11964kB with O2 */</span></span><br></pre></td></tr></table></figure>

<h3 id="II-m-n"><a href="#II-m-n" class="headerlink" title="$II.$ $m = n$"></a>$II.$ $m = n$</h3><p>存在一个环（基环树）<br>手算一下样例2可以发现，有且仅有一条边不会通过<br>逐个删边尝试即可，删边后和$m = n - 1$相同<br>样例2图示：<img src="/p/34a76f7d/P5022_2.png"></p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans[maxn], in[maxn][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SolveOne &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        ans[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SolveTwo &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, res[maxn], du, dv;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">notdel</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">//判断该边是否被删</span></span><br><span class="line">        <span class="keyword">if</span> ((u == du &amp;&amp; v == dv) || (u == dv &amp;&amp; v == du)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        res[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; <span class="built_in">notdel</span>(u, v)) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123; <span class="comment">//判断是否为更优情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i] != res[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans[i] &gt; res[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">            du = in[i][<span class="number">0</span>]; <span class="comment">//删边</span></span><br><span class="line">            dv = in[i][<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>() &amp;&amp; cnt == n) &#123; <span class="comment">//如果更优则更改ans[]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(ans, res, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        in[i][<span class="number">0</span>] = u;  <span class="comment">//存储输入信息</span></span><br><span class="line">        in[i][<span class="number">1</span>] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == n - <span class="number">1</span>) &#123;</span><br><span class="line">        SolveOne::<span class="built_in">solve</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SolveTwo::<span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2244ms 1276kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T2-填数游戏"><a href="#D2T2-填数游戏" class="headerlink" title="$D2T2$ 填数游戏"></a>$D2T2$ <a href="https://www.luogu.org/problemnew/show/P5023">填数游戏</a></h2><p><del>暴力推柿子</del><br>首先明确一个概念:本文的对角线指的是从左下方到右上方的有向线段<br><img src="/p/34a76f7d/d2t2_1.png" alt="Lemma I."><br>$\mathcal{Lemma}\ I.$ 对角线上的数只会相同或递减<br>$proof:$<br>由上图两条黑线和题目描述即可证明<br>$Q.E.D$</p>
<p><img src="/p/34a76f7d/d2t2_2.png" alt="Lemma II."><br>$\mathcal{Lemma}\ II.$ 若$(x-1, y)$与$(x, y-1)$的数相同,则以$(x,y)$为左上角,整个图形右下角的子矩阵的每条对角线(蓝)上填的数字相同<br>$proof:$<br>由图上两条橙线及题目描述即可证明<br>$Q.E.D$</p>
<p>$\mathcal{Lemma}\ III.$ $Ans(n,m)=Ans(m,n)$</p>
<p>正式推式子(默认$n \leq m$)</p>
<h3 id="I-n-1-时"><a href="#I-n-1-时" class="headerlink" title="$I.$ $n = 1$ 时"></a>$I.$ $n = 1$ 时</h3><p><img src="/p/34a76f7d/d2t2_3.png"><br>每个格内都有2种填法,故$\Ans(1,m)=2^{m}$</p>
<h3 id="II-n-2-时"><a href="#II-n-2-时" class="headerlink" title="$II.$ $n = 2$ 时"></a>$II.$ $n = 2$ 时</h3><p><img src="/p/34a76f7d/d2t2_4.png"><br>两个角上各两种,剩余$m-1$条对角线每条有3种(11,10,00)<br>故$Ans(2,m)=2\times 2\times 3^{m-1}=4\times 3^{m-1}$</p>
<h3 id="III-n-geq-4-时-只考虑-n-m-时"><a href="#III-n-geq-4-时-只考虑-n-m-时" class="headerlink" title="$III. $ $n \geq 4$ 时 (只考虑$n = m$时)"></a>$III. $ $n \geq 4$ 时 (只考虑$n = m$时)</h3><h4 id="case-I-左上角两数相同"><a href="#case-I-左上角两数相同" class="headerlink" title="$case I.$ 左上角两数相同"></a>$case I.$ 左上角两数相同</h4><p><img src="/p/34a76f7d/d2t2_5.png"><br>图中数字表示每条对角线方案数<br>可以得出$Ans(caseI.)=2\times 2\times 4^{n-2}\times 2^{n-1}=8^{n-1}$</p>
<h4 id="case-II-第三条对角线数字相同"><a href="#case-II-第三条对角线数字相同" class="headerlink" title="$case II.$ 第三条对角线数字相同"></a>$case II.$ 第三条对角线数字相同</h4><p><img src="/p/34a76f7d/d2t2_6.png"><br>图中红色数字表示方案数<br>可以得出$Ans(caseII.)=2\times 2\times 5\times 4^{n-4}\times 2^{n-1}=5\times 2^{3n-7}$</p>
<h4 id="case-III-第三条对角线上数字不同"><a href="#case-III-第三条对角线上数字不同" class="headerlink" title="$case III.$ 第三条对角线上数字不同"></a>$case III.$ 第三条对角线上数字不同</h4><p><img src="/p/34a76f7d/d2t2_7.png"><br>可以发现左侧两行只能填01,所以可能会再次出现对角数字相同的情况</p>
<h5 id="第一个出现"><a href="#第一个出现" class="headerlink" title="第一个出现"></a>第一个出现</h5><p><img src="/p/34a76f7d/d2t2_8.png" alt="红色表示方案数"></p>
<h5 id="最后一个出现"><a href="#最后一个出现" class="headerlink" title="最后一个出现"></a>最后一个出现</h5><p><img src="/p/34a76f7d/d2t2_9.png"></p>
<h5 id="倒数第二个出现"><a href="#倒数第二个出现" class="headerlink" title="倒数第二个出现"></a>倒数第二个出现</h5><p><img src="/p/34a76f7d/d2t2_10.png"></p>
<h5 id="没有出现"><a href="#没有出现" class="headerlink" title="没有出现"></a>没有出现</h5><p><img src="/p/34a76f7d/d2t2_11.png"></p>
<p>注意第三条对角线可能有100,110两种情况<br>所以$Ans(case III.)=2\times (2\times 4\times 5\times 2^{n-1}\times \sum_{i=0}^{n-5}{4^i} + 2\times 4\times 3\times 2^{n-2} + 2\times 3\times 2^{n-2})$</p>
<p>$Ans(n, n)=Ans(case I.) + Ans(case II.) + Ans(case III.)$<br>$$Ans(n,n)=\frac{83\times 8^n + 5\times 2^{n+7}}{384}$$</p>
<h3 id="IV-n-3"><a href="#IV-n-3" class="headerlink" title="$IV.$ $n = 3$"></a>$IV.$ $n = 3$</h3><p>证明与前类似<br>$$Ans(3,m)=112\times 3^{m-3}$$</p>
<h3 id="V-n-neq-m-时"><a href="#V-n-neq-m-时" class="headerlink" title="$V.$ $n \neq m$ 时"></a>$V.$ $n \neq m$ 时</h3><p>与前类似<br>$$Ans(n,n+1)=\frac{83\times 8^n + 2^{n+8}}{128}$$<br>同时易证得$Ans(n,m+1)=3\times Ans(n,m)$</p>
<p>于是就解决了</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">poww</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> ( ; b; a = a * a % mod, b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">poww</span>(<span class="number">2</span>, m));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">4</span> * <span class="built_in">poww</span>(<span class="number">3</span>, m - <span class="number">1</span>) % mod);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">112</span> * <span class="built_in">poww</span>(<span class="number">3</span>, m - <span class="number">3</span>) % mod);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((<span class="number">83</span> * <span class="built_in">poww</span>(<span class="number">8</span>, n) % mod + <span class="number">5</span> * <span class="built_in">poww</span>(<span class="number">2</span>, n + <span class="number">7</span>) % mod) * <span class="number">190104168</span> % mod));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((<span class="number">83</span> * <span class="built_in">poww</span>(<span class="number">8</span>, n) % mod + <span class="built_in">poww</span>(<span class="number">2</span>, n + <span class="number">8</span>)) * <span class="built_in">poww</span>(<span class="number">3</span>, m - n - <span class="number">1</span>) % mod * <span class="number">570312504</span> % mod ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 55ms 1048kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T3-保卫王国"><a href="#D2T3-保卫王国" class="headerlink" title="$D2T3$ 保卫王国"></a>$D2T3$ <a href="https://www.luogu.org/problemnew/show/P5024">保卫王国</a></h2><p>动态DP,树剖,<del>蒟蒻不会</del></p>
<p><del>逃</del></p>
<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/p/178c0d2c.html</url>
    <content><![CDATA[<p>由于<code>mkdocs</code>上有很多不足，例如没有标签，分类，评论，计数等等，故转至使用<code>Hexo</code>搭建博客，以下是我折腾的过程</p>
<span id="more"></span>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>我是用的是<code>Ubuntu16.04</code>系统，其他系统安装方法可到官网查询<br>在<a href="https://nodejs.org/">nodejs官网</a>下载<code>node.js</code>，并解压<br>添加环境变量<br><code>echo &quot;export PATH=$PATH:/home/tony/node-v8.11.4-linux-x64/bin&quot; &gt;&gt; ~/.zshrc</code>（如果使用的是bash，将最后一句改为<code>~/.bashrc</code>）<br><code>source ~/.zshrc</code>应用更改</p>
<p>下载hexo<br><code>npm install -g hexo-cli</code></p>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure>
<p>使用<code>hexo s</code>启动服务,在浏览器中输入<code>localhost:4000</code>便可看到预览网页</p>
<h3 id="部署到GitPages"><a href="#部署到GitPages" class="headerlink" title="部署到GitPages"></a>部署到GitPages</h3><p>创建<code>&lt;username&gt;.github.io</code>存储库<br>更改<code>_config.yml</code>文件中这一部分</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>使用<code>hexo d -g</code>发布</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>我当前使用的是<code>maupassant</code>主题<br>详细配置见<a href="https://www.haomwei.com/technology/maupassant-hexo.html">官方中文文档</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io/">Hexo官网</a><br><a href="https://afar5277.blog.luogu.org/post-zzq-hexoblog">zzq浅谈用Hexo+GitHub搭建自己的blog</a><br><a href="https://www.luogu.org/blog/0Umaru0/hexo-bo-ke-da-jian-shuo-ming-shu-zhi-bei-shu-post">Hexo博客搭建说明书（指北书）</a><br><a href="https://www.luogu.org/blog/Venus/build-hexo-github-blog">从零搭建 Hexo + Github 博客</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志</title>
    <url>/p/5a717bf0.html</url>
    <content><![CDATA[<p><a href="https://tony031218.github.io/">本博客</a>在<code>2019.3.10</code>更改至由<code>Hexo</code>驱动，并在<code>2019.3.12</code>完成更改。<br>原文章时间均改为<code>2019.1.9</code>，算法模板时间改为<code>2019.1.10</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>Cpp算法-并查集</title>
    <url>/p/9603fc0b.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, q</code>点数、边数、问题数<br><code>x, y</code>需要合并的两个数<br><code>ufs[]</code>并查集<br><code>find(int)</code>查找并查集中一个数的祖先<br><code>unionn(int, int)</code>合并两个数所在集合</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, x, y, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ufs[x] != x) <span class="keyword">return</span> ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ufs[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">unionn</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-STL标准库</title>
    <url>/p/ac108281.html</url>
    <content><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写函数/结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T x, y;</span><br><span class="line">    <span class="built_in">Point</span>(T x = <span class="number">0</span>, T y = <span class="number">0</span>):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Point&lt;T&gt; <span class="keyword">operator</span> + (<span class="keyword">const</span> Point&lt;T&gt;&amp; A, <span class="keyword">const</span> Point&lt;T&gt;&amp; B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Point&lt;T&gt;(A.x + B.x, A.y + B.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Point&lt;T&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector-不定长数组"><a href="#vector-不定长数组" class="headerlink" title="vector(不定长数组)"></a>vector(不定长数组)</h2><hr>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><code>vector&lt;数据类型&gt; 名;</code> 例 <code>vector&lt;int&gt; a;</code></p>
<h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p><code>a.size();</code>读取大小<br><br><code>a.resize();</code>改变大小<br><br><code>a.push_back(x);</code>尾部添加元素x<br><br><code>a.pop_back();</code>删除最后一个元素<br><br><code>a.clear();</code>清空<br><br><code>a.empty()</code>询问是否为空(bool类型)<br><br><code>a[]</code>访问元素(可修改)<br></p>
<h2 id="priority-queue-优先队列-堆"><a href="#priority-queue-优先队列-堆" class="headerlink" title="priority_queue(优先队列/堆)"></a>priority_queue(优先队列/堆)</h2><hr>
<h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p><strong>头文件</strong>: <code>#include &lt;queue&gt;</code><br><br><strong>参数</strong>: <code>priority_queue&lt;Type, Container, Functional&gt;</code><br><br>&emsp;<code>Type</code>数据类型 <em>不可省</em><br><br>&emsp;<code>Container</code>容器(vector,deque)默认vector<br><br>&emsp;<code>Functional</code>比较方式,默认<code>operator &lt;</code>大根堆</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>与queue类似<br></p>
<h4 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h4><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code>使用仿函数<code>greater&lt;&gt;</code><br></p>
<h4 id="自定义类型-struct"><a href="#自定义类型-struct" class="headerlink" title="自定义类型(struct)"></a>自定义类型(struct)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>):<span class="built_in">x</span>(a), <span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="重载operator-lt"><a href="#重载operator-lt" class="headerlink" title="重载operator &lt;"></a>重载operator &lt;</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br></pre></td></tr></table></figure>
<p>x值大的优先级低,排在队前<br><br>x相等,y大的优先级低</p>
<h5 id="重写仿函数"><a href="#重写仿函数" class="headerlink" title="重写仿函数"></a>重写仿函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-背包问题</title>
    <url>/p/990bbe9a.html</url>
    <content><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 $n$ 件物品，和一容积为 $V$ 的背包，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>由题意易知状态转移方程： $F_{i,j} = max(F_{i-1,j}\ , F_{i-1,j-w_i} + c_i)$</p>
<p>$F_{i, j}$ 为前 $i$ 件物品放入容量为 $V$ 的背包中最大价值<br><br>时间复杂度 $O(n\times V)$ ，空间复杂度 $O(n\times V)$</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>注意倒序，保证<code>f[n][V]</code>为结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n][V])</span><br></pre></td></tr></table></figure>

<h4 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h4><p>降至一维数组<br><br>时间复杂度 $O(n\times V)$ ，空间复杂度 $O(V)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[V]);</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有 $n$ 种物品（每种 <strong>无限件</strong> ），和一容积为 $V$ 的背包，第 $i$ 种物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几种物品取任意件装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>将<a href="../pack#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">01背包</a>第二个循环改为正序即可<br><br>状态转移方程：$F_j = max(F_j\ , F_{j-w_i}+c_i)$</p>
<h4 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= V; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[V]);</span><br></pre></td></tr></table></figure>

<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h3 id="解法-I-化为完全背包"><a href="#解法-I-化为完全背包" class="headerlink" title="解法 $I.$ 化为完全背包"></a>解法 $I.$ 化为完全背包</h3><p>状态转移方程：$F_{i,v} = max(F_{i-1,v-k\times w_i} + k\times c_i | 0\leqslant k\leqslant n_i)$<br><br>时间复杂度：$O(V\times \sum{n_i})$</p>
<h4 id="框架-2"><a href="#框架-2" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n[i]; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], [i - <span class="number">1</span>][j - k * w[i]] + k * c[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[N][V]);</span><br></pre></td></tr></table></figure>

<h3 id="解法-II-化为01背包"><a href="#解法-II-化为01背包" class="headerlink" title="解法 $II.$ 化为01背包"></a>解法 $II.$ 化为01背包</h3><p>把 $n_i$ 件一种物品化为单独的 $n_i$ 件物品即可<br><br>时间复杂度：$O(V\times \sum{n_i})$<br><br>框架略</p>
<h3 id="解法-III-二进制优化"><a href="#解法-III-二进制优化" class="headerlink" title="解法 $III.$ 二进制优化"></a>解法 $III.$ 二进制优化</h3><p>$$<br>n_i\to 1+2+4+\dots +2^{k-1}+\dots +(n_i-2^k+1)<br>$$<br>$$<br>\sum{n_i}\to \sum{\log_2{n_i}}<br>$$<br>时间复杂度：$O(V\times \sum{\log_2{n_i}})$</p>
<h4 id="框架-3"><a href="#框架-3" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> w, c, n, t = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;w, &amp;c, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n &gt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">        v[++N] = x * t;</span><br><span class="line">        w[N]   = y * t;</span><br><span class="line">        n -= t;</span><br><span class="line">        t *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v[++N] = x * n;</span><br><span class="line">    w[N]   = y * n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i]; --j)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[V]);</span><br></pre></td></tr></table></figure>

<h2 id="混合三种背包问题"><a href="#混合三种背包问题" class="headerlink" title="混合三种背包问题"></a>混合三种背包问题</h2><p>有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件或无穷件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h4 id="伪框架"><a href="#伪框架" class="headerlink" title="伪框架"></a>伪框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (第i件是有穷件)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//有无穷件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h2><p>有 $N$ 件物品，容积为 $V,U$ 的两个背包，每件物品有两种费用，选择物品需要付出两种代价，第 $i$ 件代价为 $a_i,b_i$，价值为 $c_i$。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>改为二维数组即可<br><br>状态转移方程：$F_{v,u} = max(F_{v,u}\ , F_{v-a_i,u-b_i} + c_i)$<br><br>$F_{v,u}$ 表示前面的物品付出代价分别为 $v,u$ 时的最大价值<br><br>框架略</p>
<p>循环顺序</p>
<ul>
<li>类01背包：<code>v = V..0  u = U..0</code><br></li>
<li>类完全背包：<code>v = 0..V  u = 0..U</code><br></li>
<li>类多重背包：拆分物品</li>
</ul>
<h2 id="分组的背包问题"><a href="#分组的背包问题" class="headerlink" title="分组的背包问题"></a>分组的背包问题</h2><p>有 $K$ 组物品， $V$ 的背包，第 $k$ 组有 $N_k$ 件物品，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ ，每组中只能选一件物品。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h4 id="框架-4"><a href="#框架-4" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = V; v &gt;= <span class="number">0</span>; --v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N[k]; ++i)</span><br><span class="line">            f[v] = <span class="built_in">max</span>(f[v], f[v - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题的方案数"><a href="#背包问题的方案数" class="headerlink" title="背包问题的方案数"></a>背包问题的方案数</h2><p>状态转移方程：$F_{i,v} = sum(F_{i-1,v}, F_{i-1,v-w_i})\ \ \ (F_{0,0} = 1)$</p>
<h4 id="框架-5"><a href="#框架-5" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= V; ++j)</span><br><span class="line">        f[j] += f[j - w[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[V]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-堆</title>
    <url>/p/bb233fbc.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>heap[]</code>堆<br><br><code>heap_size</code>堆大小<br><br><code>put(int)</code>压入一个数<br><br><code>get()</code>弹出堆顶</p>
<h4 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[maxn];</span><br><span class="line"><span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now, next;</span><br><span class="line">    heap[++heap_size] = d;</span><br><span class="line">    now = heap_size;</span><br><span class="line">    <span class="keyword">while</span> (now &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next = now &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (heap[now] &lt;= heap[next]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[now], heap[next]);</span><br><span class="line">        now = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now, next, res;</span><br><span class="line">    res = heap[<span class="number">1</span>];</span><br><span class="line">    heap[<span class="number">1</span>] = heap[heap_size--];</span><br><span class="line">    now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (now * <span class="number">2</span> &lt;= heap_size)</span><br><span class="line">    &#123;</span><br><span class="line">        next = now * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; heap_size &amp;&amp; heap[next + <span class="number">1</span>] &lt; heap[next]) next++;</span><br><span class="line">        <span class="keyword">if</span> (heap[now] &lt;= heap[next]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[now], heap[next]);</span><br><span class="line">        now = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="STL实现"><a href="#STL实现" class="headerlink" title="STL实现"></a>STL实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[maxn];</span><br><span class="line"><span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[++heap_size] = d;</span><br><span class="line">    <span class="built_in">push_heap</span>(heap + <span class="number">1</span>, heap + heap_size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//push_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pop_heap</span>(heap + <span class="number">1</span>, heap + heap_size + <span class="number">1</span>);                   </span><br><span class="line">    <span class="comment">//pop_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); </span></span><br><span class="line">    <span class="keyword">return</span> heap[heap_size--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-SPFA</title>
    <url>/p/8ed8c69a.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, s</code>点数、边数、源点<br><br><code>cnt, head[], edge[], add(int, int, int)</code>链式前向星<br><br><code>dist[]</code>各点到源点路径长<br><br><code>vis[]</code>记录</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, dist[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, dis;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next = head[from];</span><br><span class="line">    edge[cnt].to     = to;</span><br><span class="line">    edge[cnt].dis    = dis;</span><br><span class="line">    head[from]       = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dist[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(); vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[u] + edge[i].dis)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-链式前向星</title>
    <url>/p/dda660a4.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>cnt</code>记数<br><br><code>head[]</code>记录边的头<br><br><code>struct Edge&#123;int, int, int&#125;</code>边信息: 开始点、结束点、权值<br><br><code>add_edge(int, int, int)</code>添加边</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt, head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to, val;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++cnt].next = head[from];</span><br><span class="line">	edge[cnt].to     = to;</span><br><span class="line">	edge[cnt].val    = val;</span><br><span class="line">	head[from]       = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Prim</title>
    <url>/p/8760af74.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, _map[][]</code>点数、边数、邻接矩阵<br><br><code>dist[]</code>树根到各点路径长<br><br><code>pre[]</code>生成树路径 </p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dist[maxn], _map[maxn][maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">			_map[i][j] = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) _map[i][i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> from, to, w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">		_map[from][to] = w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">bool</span> p[maxn];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] = <span class="literal">false</span>;</span><br><span class="line">		dist[i] = _map[<span class="number">1</span>][i];</span><br><span class="line">		pre[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INT_MAX;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p[j] &amp;&amp; dist[j] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = dist[j]</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		p[k] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p[j] &amp;&amp; _map[k][j] != INT_MAX &amp;&amp; dist[j] &gt; _map[k][j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = _map[k][j];</span><br><span class="line">				pre[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Kruskal</title>
    <url>/p/c4fb1928.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>ufs[], find(int), unionn(int, int)</code>并查集结构<br><br><code>edge[]</code>链式前向星<br><br><code>cmp(Edge, Edge)</code>边排序方案</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ufs[x] != x) <span class="keyword">return</span> ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> select;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.w != b.w) <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    <span class="keyword">if</span> (a.a != b.a) <span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">    <span class="keyword">return</span> a.b &lt; b.b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, x, y;</span><br><span class="line">    <span class="built_in">sort</span>(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        x = <span class="built_in">find</span>(edge[i].a);</span><br><span class="line">        y = <span class="built_in">find</span>(edge[i].b);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unionn</span>(x, y);</span><br><span class="line">            k++;</span><br><span class="line">            edge[i].select = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-KMP</title>
    <url>/p/632c6631.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P3375">洛谷P3375</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>pre()</code>求前缀数组<br><br><code>kmp()</code>匹配字符串<br></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">1000010</span>], s2[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000010</span>], l1, l2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s2[j + <span class="number">1</span>] != s2[i + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s2[i + <span class="number">1</span>]) j++;</span><br><span class="line">        nxt[i + <span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s2[j + <span class="number">1</span>] != s1[i + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s1[i + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - l2 + <span class="number">2</span>);</span><br><span class="line">            j = nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s1 + <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; s2 + <span class="number">1</span>;</span><br><span class="line">    l1 = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">    l2 = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-哈希表</title>
    <url>/p/666f05c6.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P4305">洛谷P4305</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>hash[]</code>哈希表<br><br><code>find(int x)</code>查找哈希表中 $x$ 的位置<br><br><code>push(int x)</code>将 $x$ 插入到哈希表中<br><br><code>check(int x)</code>查找 $x$ 是否在哈希表中</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 100003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hash(a) a%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[p], t, n, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) y = <span class="built_in">hash</span>(-x);</span><br><span class="line">    <span class="keyword">else</span> y = <span class="built_in">hash</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (h[y] &amp;&amp; h[y] != x) y = <span class="built_in">hash</span>(++y);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[<span class="built_in">find</span>(x)] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[<span class="built_in">find</span>(x)] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(x))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">                <span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-字符串哈希</title>
    <url>/p/114af1e8.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P3370">洛谷P3370</a></p>
<h4 id="单哈希-自然溢出"><a href="#单哈希-自然溢出" class="headerlink" title="单哈希(自然溢出)"></a>单哈希(自然溢出)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = Ans * base + (ULL)s[i];</span><br><span class="line">    <span class="keyword">return</span> Ans &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单哈希-单模数"><a href="#单哈希-单模数" class="headerlink" title="单哈希(单模数)"></a>单哈希(单模数)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>], mod = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单哈希-大模数"><a href="#单哈希-大模数" class="headerlink" title="单哈希(大模数)"></a>单哈希(大模数)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>], mod = <span class="number">212370440130137957LL</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> prime = <span class="number">233317</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod + prime;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, mod1=<span class="number">19260817</span>, mod2=<span class="number">19660813</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULL x,y;</span><br><span class="line">&#125;a[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash1</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod1;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash2</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod2;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-数论-线性筛素数</title>
    <url>/p/cff9d95.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>p[]</code> 最终结果</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i * p[j];</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Floyd</title>
    <url>/p/ba77762f.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, G[][]</code>点数、边数、邻接矩阵<br><br><code>dist[][]</code>每对顶点间路径长度<br><br><code>pre[][]</code>每对顶点之间路径<br><br><code>make()</code>建图</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, G[maxn][maxn], dist[maxn][maxn], pre[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            G[i][j] = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        G[from][to] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i][j] = G[i][j];</span><br><span class="line">            pre[i][j]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                    pre[i][j]  = pre[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-欧拉回路</title>
    <url>/p/57662471.html</url>
    <content><![CDATA[<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>G[][]</code>邻接矩阵<br><br><code>deg[]</code>度<br><br><code>ans[]</code>欧拉回路<br><br><code>n, e</code>点数、边数</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> G[maxn][maxn], deg[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">int</span> n, e, x, y, ansi, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G[i][j])</span><br><span class="line">		&#123;</span><br><span class="line">			G[i][j] = G[j][i] = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">Euler</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[++ansi] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;e);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		G[x][y] = G[y][x] = <span class="number">1</span>;</span><br><span class="line">		deg[x]++;</span><br><span class="line">		deg[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">	s = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (deg[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">			s = i;</span><br><span class="line">	<span class="built_in">Euler</span>(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ansi; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p><code>n, m</code>点数、边数<br><br><code>head, edge[]</code>链式前向星<br><br><code>ans[], ansi</code>路径、数组大小<br><br><code>vis[]</code>记录<br><br><code>make()</code>建图</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line">		edge[k].to = i;</span><br><span class="line">		edge[k].next = head[i];</span><br><span class="line">		head[i] = k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxm];</span><br><span class="line"><span class="keyword">int</span> ansi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2</span> * maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">0</span>; k = edge[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[k])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[k] = <span class="literal">true</span>;</span><br><span class="line">            vis[k ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(edge[k].to);</span><br><span class="line">            ans[ansi++] = k;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-动态规划</title>
    <url>/p/8364d7e9.html</url>
    <content><![CDATA[<p><strong><em>待完成</em></strong></p>
<h2 id="多阶段过程决策的最优化问题"><a href="#多阶段过程决策的最优化问题" class="headerlink" title="多阶段过程决策的最优化问题"></a>多阶段过程决策的最优化问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A --5--&gt; B1</span><br><span class="line">    A --3--&gt; B2</span><br><span class="line">    B1 --1--&gt; C1</span><br><span class="line">    B1 --6--&gt; C2</span><br><span class="line">    B1 --3--&gt; C3</span><br><span class="line">    B2 --8--&gt; C2</span><br><span class="line">    B2 --4--&gt; C4</span><br><span class="line">    C1 --5--&gt; D1</span><br><span class="line">    C1 --6--&gt; D2</span><br><span class="line">    C2 --5--&gt; D1</span><br><span class="line">    C3 --8--&gt; D3</span><br><span class="line">    C4 --3--&gt; D3</span><br><span class="line">    D1 --3--&gt; E</span><br><span class="line">    D2 --4--&gt; E</span><br><span class="line">    D3 --3--&gt; E</span><br></pre></td></tr></table></figure>

<p>!!! tldr “题目及注解”<br>    求上图从 $A$ 到 $E$ 的最短距离<br><br><br>    $K$: 阶段<br><br>    $D(X_I, (X+1)_J)$: 从 $X_I$ 到 $(X+1)_J$ 的距离<br><br>    $F_K(X_I)$: $K$ 阶段下 $X_I$ 到终点 $E$ 的最短距离</p>
<p>倒推:<br>$$<br>K=4\qquad F_4(D_1)=3\qquad F_4(D_2)=4\qquad F_4(D_3)=3<br>$$<br>$$<br>K=5\qquad F_3(C_1)=min(D(C_1,D_1)+F_4(D_1),D(C_1,D_2)+F_4(D_2))=min(5+3,6+4)=8<br>F_3(C_2)<br>$$</p>
]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Dijkstra</title>
    <url>/p/982e7a01.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m</code>点数、边数<br><br><code>G[][]</code>邻接矩阵存图<br><br><code>dist[]</code>路径长度<br><br><code>pre[]</code>路径<br><br><code>make()</code>建图</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, G[maxn][maxn], dist[maxn], pre[maxn], s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            G[i][j] = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        G[from][to] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, min;</span><br><span class="line">    <span class="keyword">bool</span> p[maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != s)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i] = G[s][i];</span><br><span class="line">            pre[i]  = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s] = <span class="number">0</span>; p[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        min = INT_MAX; k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p[j] &amp;&amp; dist[j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        p[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p[j] &amp;&amp; G[k][j] != INT_MAX &amp;&amp; dist[j] &gt; dist[k] + G[k][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[k] + G[k][j];</span><br><span class="line">                pre[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆优化-链式前向星"><a href="#堆优化-链式前向星" class="headerlink" title="堆优化(链式前向星)"></a>堆优化(链式前向星)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, t;</span><br><span class="line">&#125;edge[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].to  = b;</span><br><span class="line">    edge[cnt].nxt = head[a];</span><br><span class="line">    edge[cnt].t   = t;</span><br><span class="line">    head[a]       = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> heap&amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;heap&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dist[i] = INF;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>((heap)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        heap top = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> tx = top.u;</span><br><span class="line">        <span class="keyword">int</span> td = top.d;</span><br><span class="line">        <span class="keyword">if</span> (td != dist[tx]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[tx]; i; i = edge[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[tx] + edge[i].t)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[tx] + edge[i].t;</span><br><span class="line">                dy[v] = i; </span><br><span class="line">                dx[v] = tx;    <span class="comment">//记录路径</span></span><br><span class="line">                q.<span class="built_in">push</span>((heap)&#123;v, dist[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q = n, p[maxm];</span><br><span class="line"><span class="keyword">while</span> (q != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p[++tot] = dy[q];</span><br><span class="line">    q = dx[q];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-树状数组</title>
    <url>/p/72c90980.html</url>
    <content><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>模板：<a href="https://www.luogu.org/problemnew/show/P3374">洛谷P3374</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>tree[]</code>树状数组<br><br><code>lowbit(int)</code>神奇的函数<br><br><code>add(int x, int k)</code>第 $x$ 个数加上 $k$ <br><br><code>sum(int x)</code>前 $x$ 个数的和</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tree[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-大整数类</title>
    <url>/p/b995b9d7.html</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">5000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) a&gt;b ? a : b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) a&lt;b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigInteger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> len, s[maxl];</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">BigInteger</span>();</span><br><span class="line">		<span class="built_in">BigInteger</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">		<span class="built_in">BigInteger</span>(<span class="keyword">int</span>);</span><br><span class="line">		<span class="keyword">bool</span> sign;</span><br><span class="line">		<span class="function">string <span class="title">toStr</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;, BigInteger&amp;);</span><br><span class="line">		<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, BigInteger&amp;);</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> string);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>++();</span><br><span class="line">		BigInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>--();</span><br><span class="line">		BigInteger <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> num) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>/=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">factorial</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">Sqrt</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">Pow</span><span class="params">(<span class="keyword">const</span> BigInteger&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>;</span><br><span class="line">		~BigInteger;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">	len = <span class="number">1</span>;</span><br><span class="line">	sign = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">const</span> <span class="keyword">char</span> *num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">BigInteger::toStr</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string res;</span><br><span class="line">	res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">		res = (<span class="keyword">char</span>)(s[i] + <span class="string">&#x27;0&#x27;</span>) + res;</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="string">&quot;&quot;</span>) res = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (!sign &amp;&amp; res != <span class="string">&quot;0&quot;</span>) res = <span class="string">&quot;-&quot;</span> + res;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	string str;</span><br><span class="line">	in&gt;&gt;str;</span><br><span class="line">	num = str;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	out&lt;&lt;num.<span class="built_in">toStr</span>();</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">	<span class="keyword">char</span> a[maxl] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (num[<span class="number">0</span>] != <span class="string">&quot;-&quot;</span>)</span><br><span class="line">		<span class="built_in">strcpy</span>(a, num);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(num); ++i)</span><br><span class="line">			a[i - <span class="number">1</span>] = num[i];</span><br><span class="line">	sign = !(num[<span class="number">0</span>] == <span class="string">&quot;-&quot;</span>);</span><br><span class="line">	len = <span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); ++i)</span><br><span class="line">		s[i] = a[len - i - <span class="number">1</span>] - <span class="number">48</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">		sign = <span class="number">0</span>, num = -num;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sign = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> temp[MAX_L];</span><br><span class="line">	<span class="built_in">sprintf</span>(temp, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">	*<span class="keyword">this</span> = temp;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> string num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* tmp;</span><br><span class="line">	tmp = num.<span class="built_in">c_str</span>();</span><br><span class="line">	*<span class="keyword">this</span> = tmp;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sign^num.sign)</span><br><span class="line">		<span class="keyword">return</span> num.sign;</span><br><span class="line">	<span class="keyword">if</span> (len != num.len)</span><br><span class="line">		<span class="keyword">return</span> len &lt; num.len;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">if</span> (s[i] != num.s[i])</span><br><span class="line">			<span class="keyword">return</span> sign ? (s[i] &lt; num.s[i]) : (s[i] &gt; num.s[i])</span><br><span class="line">	<span class="keyword">return</span> !sign;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> num &lt; *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span> &gt; num || *<span class="keyword">this</span> &lt; num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(num != *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">if</span> (sign^num.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 BigInteger tmp = sign ? num : *<span class="keyword">this</span>;</span><br><span class="line">		 tmp.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> sign ? *<span class="keyword">this</span> - tmp : num - tmp;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger result;</span><br><span class="line">	 result.len = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; temp || i &lt; (<span class="built_in">max</span>(len, num.len)); i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">int</span> t = s[i] + num.s[i] + temp;</span><br><span class="line">		 result.s[result.len++] = t % <span class="number">10</span>;</span><br><span class="line">		 temp = t / <span class="number">10</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 result.sign = sign;</span><br><span class="line">	 <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BigInteger old = *<span class="keyword">this</span>;</span><br><span class="line">	++(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> + num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 BigInteger b = num, a = *<span class="keyword">this</span>;</span><br><span class="line">	 <span class="keyword">if</span> (!num.sign &amp;&amp; !sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 b.sign = <span class="number">1</span>;</span><br><span class="line">		 a.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> b - a;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (!b.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 b.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> a + b;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (!a.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 a.sign = <span class="number">1</span>;</span><br><span class="line">		 b = <span class="built_in">BigInteger</span>(<span class="number">0</span>) - (a + b);</span><br><span class="line">		 <span class="keyword">return</span> b;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">	 &#123;</span><br><span class="line">		 BigInteger c = (b - a);</span><br><span class="line">		 c.sign = <span class="literal">false</span>;</span><br><span class="line">		 <span class="keyword">return</span> c;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger result;</span><br><span class="line">	 result.len = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, g = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">int</span> x = a.s[i] - g;</span><br><span class="line">		 <span class="keyword">if</span> (i &lt; b.len) x -= b.s[i];</span><br><span class="line">		 <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">else</span></span><br><span class="line">		 &#123;</span><br><span class="line">			 g = <span class="number">1</span>;</span><br><span class="line">			 x += <span class="number">10</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 result.s[result.len++] = x;</span><br><span class="line">	 &#125;</span><br><span class="line">	 result.<span class="built_in">clean</span>();</span><br><span class="line">	 <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BigInteger old = *<span class="keyword">this</span>;</span><br><span class="line">	--(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> - num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger result;</span><br><span class="line">	result.len = len + num.len;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.len; j++)</span><br><span class="line">			result.s[i + j] += s[i] * num.s[j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		 result.s[i + <span class="number">1</span>] += result.s[i] / <span class="number">10</span>;</span><br><span class="line">		 result.s[i] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	result.<span class="built_in">clean</span>();</span><br><span class="line">	result.sign = !(sign^num.sign);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger x = num;</span><br><span class="line">	BigInteger z = *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 BigInteger ans;</span><br><span class="line">	 ans.len = len - num.len + <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">if</span> (ans.len &lt; <span class="number">0</span>)</span><br><span class="line">	 &#123;</span><br><span class="line">		 ans.len = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> ans;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger divisor = *<span class="keyword">this</span>, divid = num;</span><br><span class="line">	 divisor.sign = divid.sign = <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">int</span> k = ans.len - <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">while</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">while</span> (divisor.s[j] == <span class="number">0</span>) j--;</span><br><span class="line">		 <span class="keyword">if</span> (k &gt; j) k = j;</span><br><span class="line">		 <span class="keyword">char</span> z[MAX_L];</span><br><span class="line">		 <span class="built_in">memset</span>(z, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(z));</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &gt;= k; i--)</span><br><span class="line">			 z[j - i] = divisor.s[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			 BigInteger dividend = z;</span><br><span class="line">			 <span class="keyword">if</span> (dividend &lt; divid) &#123; k--; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			 <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">			 <span class="keyword">while</span> (divid*key &lt;= dividend) key++;</span><br><span class="line">			 key--;</span><br><span class="line">			 ans.s[k] = key;</span><br><span class="line">			 BigInteger temp = divid*key;</span><br><span class="line">			 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">				 temp = temp * <span class="number">10</span>;</span><br><span class="line">				 divisor = divisor - temp;</span><br><span class="line">				 k--;</span><br><span class="line">	 &#125;</span><br><span class="line">	 ans.<span class="built_in">clean</span>();</span><br><span class="line">	 ans.sign = !(sign^num.sign);</span><br><span class="line">	 <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> / num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger a = *<span class="keyword">this</span>, b = num;</span><br><span class="line">	a.sign = b.sign = <span class="number">1</span>;</span><br><span class="line">	BigInteger result, temp = a / b*b;</span><br><span class="line">	result = a - temp;</span><br><span class="line">	result.sign = sign;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">BigInteger::Pow</span><span class="params">(<span class="keyword">const</span> BigInteger&amp; num)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BigInteger result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (BigInteger i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">		result = result * (*<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">BigInteger::factorial</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BigInteger result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (BigInteger i = <span class="number">1</span>; i &lt;= *<span class="keyword">this</span>; i++)</span><br><span class="line">		result *= i;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BigInteger::clean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) len++;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; s[len - <span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">BigInteger::Sqrt</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*<span class="keyword">this</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(*<span class="keyword">this</span> &lt;= <span class="number">1</span>)<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	BigInteger l = <span class="number">0</span>, r = *<span class="keyword">this</span>, mid;</span><br><span class="line">	<span class="keyword">while</span>(r - l &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid * mid &gt; *<span class="keyword">this</span>)</span><br><span class="line">			r = mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::~<span class="built_in">BigInteger</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-BFS</title>
    <url>/p/99890668.html</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文实现只是框架，应当灵活运用，bfs()函数内部根据情况灵活更改<br>广搜算法基于树、队列实现，具体思路: <code>将当前点的子节点入队，当前点出队，如果子节点满足条件则记录</code>并重复此过程</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    vis[start_x][start_y] = <span class="literal">true</span>;            <span class="comment">//标记起始点</span></span><br><span class="line">    que[head][<span class="number">0</span>] = start_x; </span><br><span class="line">    que[head][<span class="number">1</span>] = start_y;                  <span class="comment">//起始点入队</span></span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail)                       <span class="comment">//队不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que[head][<span class="number">0</span>], y = que[head][<span class="number">1</span>]  <span class="comment">//获取队首点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; 子节点数; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = x子节点, y2 = y子节点;</span><br><span class="line">            <span class="keyword">if</span> (x2, y2满足条件 &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                记录结果;</span><br><span class="line">                vis[x2][y2] = <span class="literal">true</span>;</span><br><span class="line">                que[tail][<span class="number">0</span>] = x2;</span><br><span class="line">                que[tail][<span class="number">0</span>] = y2;</span><br><span class="line">                tail++;                         <span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head++;                                 <span class="comment">//队首出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="STL-queue"><a href="#STL-queue" class="headerlink" title="STL-queue"></a>STL-queue</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;node, top;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    node.x = sx;</span><br><span class="line">    node.y = sy;</span><br><span class="line">    que.<span class="built_in">push</span>(node);</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        top = que.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = ..., y2 = ...;</span><br><span class="line">            <span class="keyword">if</span> (x2, y2满足条件 &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                记录结果;</span><br><span class="line">                vis[x2][y2] = <span class="literal">true</span>;</span><br><span class="line">                node.x = x2;</span><br><span class="line">                node.y = y2;</span><br><span class="line">                que.<span class="built_in">push</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><a href="https://www.luogu.org/problemnew/show/P1443">洛谷P1443</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy, vis[<span class="number">210</span>][<span class="number">210</span>], ans[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> gox[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> goy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">horse</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;node, top;</span><br><span class="line"></span><br><span class="line">queue&lt;horse&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    node.x = sx;</span><br><span class="line">    node.y = sy;</span><br><span class="line">    que.<span class="built_in">push</span>(node);</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        top = que.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = top.x + gox[i];</span><br><span class="line">            <span class="keyword">int</span> y2 = top.y + goy[i];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt;= <span class="number">1</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= <span class="number">1</span> &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[x2][y2] = ans[top.x][top.y] + <span class="number">1</span>;</span><br><span class="line">                vis[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                node.x = x2;</span><br><span class="line">                node.y = y2;</span><br><span class="line">                que.<span class="built_in">push</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;sx, &amp;sy);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy, vis[<span class="number">210</span>][<span class="number">210</span>], que[<span class="number">50000</span>][<span class="number">2</span>], ans[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> gox[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> goy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    que[head][<span class="number">0</span>] = sx;</span><br><span class="line">    que[head][<span class="number">1</span>] = sy;</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, x2, y, y2;</span><br><span class="line">        x = que[head][<span class="number">0</span>];</span><br><span class="line">        y = que[head][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x2 = x + gox[i];</span><br><span class="line">            y2 = y + goy[i];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt;= <span class="number">1</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= <span class="number">1</span> &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[x2][y2] = ans[x][y] + <span class="number">1</span>;</span><br><span class="line">                vis[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                que[tail][<span class="number">0</span>] = x2;</span><br><span class="line">                que[tail][<span class="number">1</span>] = y2;</span><br><span class="line">                tail++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;sx, &amp;sy);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-DFS</title>
    <url>/p/9d047ada.html</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文实现只是框架，应当灵活运用，dfs(…)函数返回值类型、参数列表根据情况灵活更改</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数列表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (到达目的地) 输出结果;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; 行动方法数; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (下一步可行)</span><br><span class="line">            &#123;</span><br><span class="line">                记录此步;</span><br><span class="line">                <span class="built_in">dfs</span>(改动后的参数列表);</span><br><span class="line">                取消记录此步;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><a href="https://www.luogu.org/problemnew/show/P1605">洛谷P1605</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, sx, sy, fx, fy, ans;</span><br><span class="line"><span class="keyword">int</span> mg[<span class="number">6</span>][<span class="number">6</span>], now[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x2, y2;</span><br><span class="line">    <span class="keyword">if</span> (x == fx &amp;&amp; y == fy) ans++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x2 = x + go[i][<span class="number">0</span>];</span><br><span class="line">            y2 = y + go[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt; <span class="number">0</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt; <span class="number">0</span> &amp;&amp; y2 &lt;= m &amp;&amp; mg[x2][y2] == <span class="number">0</span> &amp;&amp; now[x2][y2] == <span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">            &#123;</span><br><span class="line">                now[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(x2, y2);</span><br><span class="line">                now[x2][y2] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mg, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mg));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;sx, &amp;sy, &amp;fx, &amp;fy);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        mg[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    now[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(sx, sy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux美化方案</title>
    <url>/p/f2ddc0e6.html</url>
    <content><![CDATA[<h3 id="I-初步系统优化"><a href="#I-初步系统优化" class="headerlink" title="I. 初步系统优化"></a>I. 初步系统优化</h3><hr>
<ul>
<li>更改系统时间</li>
<li>安装python<br>  <code>sudo apt install python</code></li>
<li>安装git并添加ssh密钥<br>  <code>sudo apt install git</code><br>  <code>git config --global user.name &quot;your_name&quot;</code><br>  <code>git config --global user.email &quot;you@example.com&quot;</code><br>  <code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>一路回车<br>  <code>cat ~/.ssh/id_rsa.pub</code>并复制粘贴到github上<br>  <code>ssh -T git@github.com</code>测试<br>  <code>git clone https://github.com/Tony031218/Beautiful_Linux.git</code>克隆下本仓库</li>
<li>添加语言<pre>
  settings -> Region&Language -> manage installed language -> install/remove languages
                              -> input sources
</pre></li>
<li>软件更新<br>  <code>sudo apt update</code><br>  <code>sudo apt upgrade</code></li>
<li>安装GDebi<br>  <code>sudo apt install gdebi</code></li>
<li>卸载libreoffice 安装 WPS(可选)<br>  <code>sudo apt remove libreoffice-common</code><br>  从<a href="http://www.wps.cn/product/wpslinux/">http://www.wps.cn/product/wpslinux/</a> 上下载WPS<br>  <code>sudo dpkg -i wps-office_10.1.0.6757_amd64.deb</code></li>
<li>卸载firefox 安装 Chrome(可选)<br>  <code>sudo apt remove firefox</code><br>  <code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code><br>  <code>sudo dpkg -i google-chrome*</code><br>  <code>sudo apt -f install</code></li>
<li>更换更新源<br>  左下角 -&gt; all -&gt; Software&amp;Updates<br>  <code>sudo apt update</code></li>
<li>安装vim<br>  <code>sudo apt install vim</code></li>
<li>菜单栏位置<br>  <code>gsettings set com.canonical.Unity.Launcher launcher-position Bottom</code>底部<br>  <code>gsettings set com.canonical.Unity.Launcher launcher-position Left</code>左侧</li>
</ul>
<h3 id="II-主题配置"><a href="#II-主题配置" class="headerlink" title="II. 主题配置"></a>II. 主题配置</h3><hr>
<ul>
<li><p>安装 Unity-tweak-tool<br><code>sudo apt install unity-tweak-tool</code><br>如果出现报错需要安装缺失的包</p>
</li>
<li><p>安装 Flatabulous 主题<br><code>sudo add-apt-repository ppa:noobslab/themes</code><br><code>sudo apt update</code><br><code>sudo apt install flatabulous-theme</code>主题<br><code>sudo add-apt-repository ppa:noobslab/icons</code><br><code>sudo apt update</code><br><code>sudo apt install ultra-flat-icons</code>图标<br>unity-tweak-tool -&gt; 主题/图标</p>
</li>
<li><p>字体<br>Monaco Powerline 也可以选择其他字体,但一定要支持Powerline的,否则后文会出现乱码</p>
</li>
</ul>
<h3 id="III-终端Terminal美化"><a href="#III-终端Terminal美化" class="headerlink" title="III. 终端Terminal美化"></a>III. 终端Terminal美化</h3><hr>
<ul>
<li>Terminal zsh<br>  <code>sudo apt install zsh</code><br>  <code>git clone https://github.com/robbyrussell/oh-my-zsh.git</code><br>  <code>cd oh-my-zsh/tools</code><br>  <code>./install.sh</code></li>
<li>更换默认shell<br>  <code>chsh</code>按步骤来输入zsh地址</li>
<li>zsh插件<ul>
<li>自动补全<br>  <code>git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></li>
<li>快速跳转<br>  <code>git clone https://github.com/joelthelion/autojump.git</code><br>  <code>cd autojump</code><br>  <code>./install.py</code>按要求把代码填写到~/.zshrc文件尾</li>
<li>配置<br>  <code>vim ~/.zshrc</code><br>  修改60行左右的plugins<code>plugins=(git autojump zsh-suggestions)</code></li>
<li>修改皮肤<br>  <code>~/.zshrc</code>中的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>更改</li>
</ul>
</li>
</ul>
<h3 id="IV-vim美化"><a href="#IV-vim美化" class="headerlink" title="IV. vim美化"></a>IV. vim美化</h3><hr>
<ul>
<li>molokai<br>  <code>mkdir ~/.vim/colors</code><br>  将本仓库中的<code>molokai.vim</code>复制到<code>~/.vim/colors/</code>下</li>
<li>Powerline<br>  <code>sudo apt install python-pip</code><br>  <code>pip install git+git://github.com/powerline/powerline</code><br>  <code>pip show powerline-status</code><br>  按照具体位置更改<code>~/.vimrc</code>中的<code>set rtp+=...</code>一行(后文)</li>
<li>插件<ul>
<li>pathogen插件管理<br>  <code>mkdir -p ~/.vim/autoload ~/.vim/bundle</code><br>  <code>curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</code></li>
<li>nerdtree文件浏览器<br>  <code>cd ~/.vim/bundle</code><br>  <code>git clone https://github.com/scrooloose/nerdtree.git</code></li>
<li>taglist大纲界面<br><a href="https://www.vim.org/scripts/scripts.php?script_id=273">taglist官网</a><br>  下载后解压到<code>~/.vim/bundle/</code>下</li>
</ul>
</li>
<li>vimrc<br>  将本仓库中的<code>vimrc.txt</code>复制到<code>~/.vimrc</code>中<br>  内包含括号匹配,html标签匹配,powerline配置(可能需要改动),cpp.sh.java.py的文件头自动输入,插件的配置(F3打开nerdtree,F4打开taglist)</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="https://blog.csdn.net/qq_35208390/article/details/78441013">CSDN博客</a><br><a href="https://www.linuxprobe.com/use-powerline-for-bash.html">powerline</a><br><a href="https://blog.csdn.net/zcube/article/details/42525973">vim插件</a><br><a href="https://github.com/ocxo/monaco-powerline-vim">monaco powerline字体</a><br><a href="https://github.com/sickill/vim-monokai">monokai主题</a><br><a href="http://www.wps.cn/product/wpslinux/">WPS</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简单用法</title>
    <url>/p/e779c345.html</url>
    <content><![CDATA[<p><code>Git</code>是一款版本控制软件，配合<code>GitHub</code>可以更好的控制代码</p>
<span id="more"></span>

<h3 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">&quot;975062472@qq.com&quot;</span></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> id_rsa.pub</span><br><span class="line"><span class="variable">$</span> ssh <span class="literal">-T</span> git@github.com</span><br></pre></td></tr></table></figure>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> mkdir study_cpp</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> study_cpp/</span><br><span class="line"><span class="variable">$</span> <span class="built_in">echo</span> <span class="string">&quot;# test&quot;</span> &gt;&gt; README.md</span><br><span class="line"><span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">README.md</span><br><span class="line"><span class="variable">$</span> git init</span><br><span class="line"><span class="variable">$</span> git add README.md</span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;添加 README.md 文件&quot;</span></span><br><span class="line"><span class="variable">$</span> git remote add origin git@github.com:Tony031218/study_cpp.git</span><br><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br></pre></td></tr></table></figure>
<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:Tony031218/study_cpp</span><br></pre></td></tr></table></figure>
<h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git fetch origin</span><br><span class="line"><span class="variable">$ </span>git merge origin/master</span><br></pre></td></tr></table></figure>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git add &lt;filename&gt;</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">&quot;推送信息&quot;</span></span><br><span class="line"><span class="variable">$ </span>git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote add origin2 git<span class="variable">@github</span>.<span class="symbol">com:</span>Tony031218/study_cpp.git</span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line"><span class="variable">$ </span>git remote rm origin2</span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ git checkout -b graph  <span class="regexp">//</span>创建分支，并切换过去</span><br><span class="line">$ git checkout master    <span class="regexp">//</span>回到主分支</span><br><span class="line">$ git push origin graph  <span class="regexp">//</span>将分支推送到远程仓库</span><br><span class="line">$ git pull               <span class="regexp">//</span>将本地仓库更新</span><br><span class="line">$ git diff graph master  <span class="regexp">//</span>显示差别</span><br></pre></td></tr></table></figure>
<h3 id="克隆分支"><a href="#克隆分支" class="headerlink" title="克隆分支"></a>克隆分支</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">$ git clone -b <span class="params">&lt;branch_name&gt;</span> <span class="params">&lt;repo_url&gt;</span>   <span class="comment">//克隆单个分支</span></span><br><span class="line">$ cd <span class="params">&lt;repo&gt;</span></span><br><span class="line">$ git branch -a                           <span class="comment">//查看所有分支</span></span><br><span class="line">$ git checkout -b <span class="params">&lt;branch_name&gt;</span> origin/<span class="params">&lt;branch_name&gt;</span>  <span class="comment">//关联分支</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/p/3c50d03d.html</url>
    <content><![CDATA[<p><code>Markdown</code>是一款简洁实用的文本标记语言，可以在<code>mkdocs</code>,<code>hexo</code>中使用</p>
<span id="more"></span>

<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p>下划线</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">****</span></span><br><span class="line"><span class="string">----</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p><code>[TOC]</code></p>
<hr>
<h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p><strong><code>** **</code>加粗</strong><br><br><em><code>* *</code>倾斜</em><br><br><em><strong><code>*** ***</code>倾斜加粗</strong></em><br><br><code>~~ ~~</code><del>删除</del></p>
<hr>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><code>&gt;</code>一级 <code>&gt;&gt;</code>二级</p>
<blockquote>
<p>引用</p>
<blockquote>
<p>二级引用</p>
</blockquote>
</blockquote>
<blockquote>
<p>引用</p>
</blockquote>
<hr>
<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p><code>&amp;nbsp; 或 &lt;br/&gt;</code><br>&nbsp;<br><br></p>
<hr>
<h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p><code>&amp;emsp;</code><br><br>&emsp;&emsp;空格</p>
<hr>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><code>![图片名](图片地址 &quot;title&quot;)</code><br><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=d997317c11ce36d3b6098b625b9a51e2/00e93901213fb80ef9ceac7132d12f2eb938947d.jpg" alt="markdown"></p>
<p>或使用html标签<code>&lt;img src=&quot;...&quot; width=&quot;...&quot; height=&quot;...&quot; /&gt;</code></p>
<hr>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><code>[网页名](地址 &quot;title&quot;)</code><br><a href="http://www.baidu.com/" title="百度一下">百度</a></p>
<hr>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello markdown&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="序表"><a href="#序表" class="headerlink" title="序表"></a>序表</h4><ol>
<li>有序1</li>
<li>有序2</li>
<li>有序3</li>
</ol>
<hr>
<p><code>+ 或 - 或 *</code></p>
<ul>
<li>无序</li>
</ul>
<ul>
<li>无序</li>
</ul>
<ul>
<li>无序</li>
</ul>
<hr>
<ul>
<li>一级无序<ul>
<li>二级无序<ul>
<li>三级无序<ul>
<li>四级无序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><p><code>- [ ] ...</code><br><br><code>- [x] ...</code><br><br><code>mkdocs</code>需要<code>pymdown</code>中的<code>pymdownx</code>模块<br><br><code>GitHub</code>支持</p>
<hr>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">|<span class="symbol">:----------|</span><span class="symbol">:----------</span><span class="symbol">:|----------</span><span class="symbol">:|</span></span><br><span class="line">| 左对齐 |居中|右对齐|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">表头</th>
<th align="center">表头</th>
<th align="right">表头</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左对齐</td>
<td align="center">居中</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<hr>
<h4 id="内联CSS"><a href="#内联CSS" class="headerlink" title="内联CSS"></a>内联CSS</h4><p><code>&lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: &#39;Consolas&#39;;&quot;&gt;CSS&lt;/p&gt;</code></p>
<p style="color: #AD5D0F;font-size: 30px; font-family: 'Consolas';">CSS</p>

<hr>
<h4 id="语义标记"><a href="#语义标记" class="headerlink" title="语义标记"></a>语义标记</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>强调<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">上标： Z<span class="tag">&lt;<span class="name">sup</span>&gt;</span>a<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">下标： Z<span class="tag">&lt;<span class="name">sub</span>&gt;</span>a<span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span><br><span class="line">键盘文本： <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <i>斜体</i><br><br> <b>加粗</b><br><br> <em>强调</em><br><br> 上标： Z<sup>a</sup><br><br> 下标： Z<sub>a</sub><br><br> 键盘文本： <kbd>Ctrl</kbd><br></p>
<hr>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>文档末尾添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">MathJax.Hub.Config(&#123;</span></span><br><span class="line"><span class="javascript">	  <span class="attr">tex2jax</span>: &#123;<span class="attr">inlineMath</span>: [[<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>], [<span class="string">&#x27;\\(&#x27;</span>,<span class="string">&#x27;\\)&#x27;</span>]]&#125;</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用$\LaTeX$语法编写公式<br>$$<br>x \href{why-equal.html} {=} y^2 + 1<br>$$<br>$$<br>x = {-b \pm \sqrt{b^2-4ac} \over 2a}<br>$$</p>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MkDocs使用方法</title>
    <url>/p/ce42b873.html</url>
    <content><![CDATA[<p>mkdocs是一款基于python markdown的项目文档工具,可以用来编写一个网站</p>
<span id="more"></span>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="安装python3及pip"><a href="#安装python3及pip" class="headerlink" title="安装python3及pip"></a>安装python3及pip</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install python3        <span class="comment">#安装python</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install python3-pip    <span class="comment">#安装pip</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 --version               <span class="comment">#检查python是否安装成功</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 --version                  <span class="comment">#检查pip是否安装成功</span></span></span><br></pre></td></tr></table></figure>
<h4 id="安装mkdocs"><a href="#安装mkdocs" class="headerlink" title="安装mkdocs"></a>安装mkdocs</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip3 install mkdocs             <span class="comment">#注意以root权限安装</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdocs --version                <span class="comment">#检查是否安装成功</span></span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs new <span class="built_in">test</span>                 <span class="comment">#创建一个名为test的文件夹,存储代码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>此时的目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test/</span><br><span class="line"> ├── docs/                        #存放markdown文档</span><br><span class="line"> │     └── index.md               #主页</span><br><span class="line"> └── mkdocs.yml                   #配置文件</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs serve                    <span class="comment">#开启内建服务器</span></span></span><br></pre></td></tr></table></figure>
<p>在浏览器中输入<code>127.0.0.1:8000</code>预览,终端键入<code>Ctrl+C</code>关闭服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs build                    <span class="comment">#生成静态网页代码</span></span></span><br></pre></td></tr></table></figure>
<p>这时已经生成了<code>site/</code>文件夹,可以将里面的内容部署到网站上了</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>site_name: </code>  <strong><em>必须存在</em></strong>,文档主标题名称<br><code>site_favicon: </code>  图标,存放在<code>docs/</code>文件夹下<br><code>theme: </code>  主题样式例如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;material&#x27;</span>                <span class="comment">#使用material主题,需要pip安装mkdocs-material</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">&#x27;zh&#x27;</span>                  <span class="comment">#使用中文</span></span><br><span class="line">  <span class="attr">feature:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">true</span>                    <span class="comment">#使用上方tab栏（可改为false）</span></span><br></pre></td></tr></table></figure>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">&#x27;Index&#x27;:</span> <span class="string">index.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">&#x27;About&#x27;:</span> <span class="string">about.md</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>执行<code>$ pip3 install pymdown-extensions</code>安装扩展包</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown_extensions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">admonition</span>                    <span class="comment">#支持注解</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">codehilite:</span>                   <span class="comment">#代码块高亮</span></span><br><span class="line">      <span class="attr">linenums:</span> <span class="literal">true</span>              <span class="comment">#代码块显示行号</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.tasklist</span>             <span class="comment">#支持任务列表</span></span><br></pre></td></tr></table></figure>

<p>!!! warning “注意”<br>    一定要事先安装好扩展，否则不能出现预期效果</p>
<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://markdown-docs-zh.readthedocs.io/zh_CN/latest/">MkDocs中文文档</a><br><a href="https://www.mkdocs.org/">MkDocs官方文档</a><br><a href="https://cyent.github.io/markdown-with-mkdocs-material">cyent的教程</a></p>
]]></content>
      <tags>
        <tag>blog</tag>
        <tag>markdown</tag>
        <tag>mkdocs</tag>
      </tags>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[<style type="text/css">
.intro {
    text-align: center; 
    font-weight: bold
}
.intro a {
    color:var(--font-color)!important
}
.intro a:hover {
    text-decoration: underline
}
.intro p {
    line-height: 1.75
}
</style>

<div class="intro">

<p>(｡･∀･)ﾉﾞ<br>准大学生 | 哔哩哔哩up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a></p>
<p><a href="https://github.com/3b1b/manim">3b1b/manim</a>项目Collaborator<br><a href="https://github.com/manim-kindergarten">manim-kindergarten</a>组织Maintainer</p>
<p><a href="https://www.16personalities.com/ch/infj-%E4%BA%BA%E6%A0%BC">INFJ-A</a> | <a href="https://www.wizardingworld.com/">HUFFLEPUFF</a><br>VSCode 重度使用 | Python/C++<br>米粉<del>但中意MacBook</del> | 萌新刀客塔<br>YOASOBI | Orangestar | 诺兰 | 新海诚</p>
<br>

<p>咕咕咕～～～！！<br>这里应该也不常更新_(:з」∠)_<br>但希望你能喜欢(～￣▽￣)～</p>
</div>

<details>
<summary>历史记录</summary>
<br>

<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a>的个人博客<br>高考结束，hexo重新配置，恢复更新<br>主要记录一些学习过程中遇到的技术问题解决办法</p>
<div style="text-align: right">于`2021.6.12`</div>
</blockquote>
<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a>的个人博客<br>同时也是<a href="https://github.com/3b1b/manim">3b1b/manim</a>项目的Collaborator，<a href="https://github.com/manim-kindergarten">manim-kindergarten</a>组织的Maintainer<br><del>正在高考备考，没有更新</del><br><del>这段时间由于hexo环境的问题，博客没有更新</del></p>
<div style="text-align: right">于`2020.9.30`</div>
</blockquote>
<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a>的个人博客<br>目前已经信竞退役，在B站制作一些manim教程和科普视频<br><del>这段时间由于hexo环境的问题，博客没有更新</del></p>
<div style="text-align: right">于`2020.6.21`</div>
</blockquote>
<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a>的个人博客<br>现在还是一名$JL$的$OIer$,这个博客目前主要堆放了我学习$OI$算法时的笔记和一些题解<br>还可能有一些乱七八糟的文章(比如游记,做视频的经验之类的)‍ _(:3」∠)_<br>总之,非常感谢您能够来到这里,一起加油‍吧(〜￣△￣)〜</p>
<div style="text-align: right">于`2020.4.27`</div>
</blockquote>
<blockquote>
<p>本博客于 <code>2019.1.9</code> 首次开通<br>于 <code>2019.3.10</code> 更新至Hexo<br>本博客主要记载一些经验和算法模板(<code>C++</code>)</p>
<div style="text-align: right">于`2019.3.10`</div>
</blockquote>
</details>]]></content>
  </entry>
  <entry>
    <title>C++算法(OI)</title>
    <url>/algorithms/index.html</url>
    <content><![CDATA[<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-DFS">深度优先搜索</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-BFS">广度优先搜索</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>&emsp;<a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">背包问题</a></p>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA-%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0">欧拉线性筛</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%A4%A7%E6%95%B4%E6%95%B0%E7%B1%BB">大整数类</a></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%A0%86">堆</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-STL%E6%A0%87%E5%87%86%E5%BA%93">标准模板库STL</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">树状数组</a></p>
<h2 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h2><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C">字符串哈希</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95-KMP">KMP算法</a></p>
<h2 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h2><h3 id="链式前向星存储图"><a href="#链式前向星存储图" class="headerlink" title="链式前向星存储图"></a><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F">链式前向星存储图</a></h3><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF">欧拉回路</a></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-Prim">Prim</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-Kruskal">Kruskal</a></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-Dijkstra">Dijkstra</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-SPFA">SPFA</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-Floyd">Floyd</a></p>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>友链</title>
    <url>/friends/index.html</url>
    <content><![CDATA[<style type="text/css">
@media screen and (min-width: 1280px) {
    .column.is-6-widescreen {
        flex: none;
        width: 75%;
    }
}
.flink-list {
    overflow: auto;
    padding: 10px 10px 0;
    text-align: center;
}
.flink-list a {
    color: #4a4a4a;
}
.flink-list-item {
    position: relative;
    float: left;
    overflow: hidden;
    margin: 15px 7px;
    width: calc(100% / 3 - 15px);
    height: 90px;
    border-radius: 8px;
    line-height: 17px;
    -webkit-transform: translateZ(0);
    transition: 0.25s;
}
.flink-item-icon {
    float: left;
    overflow: hidden;
    margin: 15px 10px;
    width: 60px;
    height: 60px;
    border-radius: 35px;
}
.flink-item-name {
    padding: 16px 10px 0 0;
    height: 40px;
    font-weight: bold;
    font-size: 1.43em;
}
.flink-item-desc {
    padding: 16px 10px 16px 0;
    height: 50px;
    font-size: 0.93em;
}
.flink-list-item:hover {
    background-color: #81ACF9;
}
@media screen and (max-width: 1280px) {
    .flink-list-item {
        width: calc(50% - 15px) !important;
    }
}
@media screen and (max-width: 810px) {
    .flink-list-item {
        width: calc(100% - 15px) !important;
    }
}
</style>

<div class="flink-list">

<div class="flink-list-item">
    <a href="https://blog.gztime.cc/" title="GZTime" target="_blank">
        <div class="flink-item-icon">
            <img src="https://cdn.gztime.cc/avatar/GZTime_2021.png" alt="GZTime">
        </div>
        <div class="flink-item-name">GZTime</div>
        <div class="flink-item-desc">Walking on the Time Axis.</div>
    </a>
</div>

<div class="flink-list-item">
    <a href="https://cigar666.github.io/" title="Cigar666" target="_blank">
        <div class="flink-item-icon">
            <img src="https://cigar666.github.io/media/cigar.png" alt="Cigar666">
        </div>
        <div class="flink-item-name">Cigar666</div>
        <div class="flink-item-desc">_(:з」∠)_</div>
    </a>
</div>

<div class="flink-list-item">
    <a href="https://blog.flwfdd.xyz/" title="范滇东" target="_blank">
        <div class="flink-item-icon">
            <img src="https://z3.ax1x.com/2021/06/16/2LUYQA.jpg" alt="范滇东">
        </div>
        <div class="flink-item-name">范滇东</div>
        <div class="flink-item-desc">|･ω･｀)</div>
    </a>
</div>

<div class="flink-list-item">
    <a href="https://widcardw.github.io/" title="widcardw" target="_blank">
        <div class="flink-item-icon">
            <img src="https://widcardw.github.io/links/avatar.jpg" alt="widcardw">
        </div>
        <div class="flink-item-name">widcardw</div>
        <div class="flink-item-desc">不是多面手</div>
    </a>
</div>

<div class="flink-list-item">
    <a href="https://hk-shao.github.io" title="烧风" target="_blank">
        <div class="flink-item-icon">
            <img src="https://avatars2.githubusercontent.com/u/24982550" alt="烧风">
        </div>
        <div class="flink-item-name">烧风</div>
        <div class="flink-item-desc">A human.</div>
    </a>
</div>

<div class="flink-list-item">
    <a href="https://matheart.github.io/" title="數心" target="_blank">
        <div class="flink-item-icon">
            <img src="https://matheart.github.io/media/profile.jpg" alt="數心">
        </div>
        <div class="flink-item-name">數心</div>
        <div class="flink-item-desc">萬物皆數.</div>
    </a>
</div>

</div>

<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><div class="flink-list">

<div class="flink-list-item">
    <a href="https://manim.org.cn" title="MK官网" target="_blank">
        <div class="flink-item-icon">
            <img src="https://manim.org.cn/assets/mk.svg" alt="MK官网">
        </div>
        <div class="flink-item-name">MK官网</div>
        <div class="flink-item-desc">manim-kindergarten官网</div>
    </a>
</div>

</div>]]></content>
  </entry>
</search>
