<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「ACTF 2022」Broken QRCode Official Writeup</title>
    <url>/p/12a2afd2.html</url>
    <content><![CDATA[<p>6 月 25～27 号我们 AAA 战队承办了一场 ACTF 比赛，我出了 Broken QRCode 这一道题目，这里是 writeup</p>
<span id="more"></span>

<details>
<summary>English Writeup</summary>

<p>First of all, the challenge has no attachment. Obviously the primary goal is to get the picture. According to the picture uuid recorded by the mirai QQ robot and the official API of QQ images, we can get the url of that picture:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://gchat.qpic.cn/gchatpic_new/0-0-AA8F922E7A7C88CE82D73F614D8/0</span><br></pre></td></tr></table></figure>
<p>Then the picture:<br><img src="/p/12a2afd2/qq.jpg"><br>Then from the “Broken” in the title and the information “The QR code generator has bugs, the qrcode it generated can’t be scanned”, and after a simple analysis, you can see the four identifier bits at the beginning of the QR code, the size, and the padding bits in the middle. They are all exposed, so it can be speculated that there is no mask operation (you can also use the first hint “I broke this QR code by just missing a step” to be sure of this)</p>
<p>Load the picture into <a href="https://merricx.github.io/qrazybox/">qrazybox</a>. Then apply mask and scan it, you can get <a href="https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93">https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93</a> , which is a hex string of a zip pack. Unpack it, you can get 12 qr codes:</p>
<p><img src="/p/12a2afd2/qrcodes.png"></p>
<p>Scanning them, you will get:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We&#x27;re no strangers to love</span><br><span class="line">You know the rules and so do I</span><br><span class="line">A full commitment&#x27;s what I&#x27;m thinking of</span><br><span class="line">You wouldn&#x27;t get this from any other guy</span><br><span class="line">I just wanna tell you how I&#x27;m feeling</span><br><span class="line">Gotta make you understand</span><br><span class="line">Never gonna give you up</span><br><span class="line">Never gonna let you down</span><br><span class="line">Never gonna run around and desert you</span><br><span class="line">Never gonna make you cry</span><br><span class="line">Never gonna say goodbye</span><br><span class="line">Never gonna tell a lie and hurt you</span><br></pre></td></tr></table></figure>
<p>After analysis, it can be found that there is an additional data at the end of the first picture:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">410314c795f6b6e30775f5152436f64337d0ec187c229c4d4a44</span><br><span class="line"># to binary</span><br><span class="line">0100000100000011000101001100011110010101111101101011011011100011000001110111010111110101000101010010010000110110111101100100001100110111110100001110110000011000011111000010001010011100010011010100101001000100</span><br></pre></td></tr></table></figure>
<p>It is not difficult to find out that this is a bit sequence (including identifier, size, data, padding, ecc) of a qr code content. The data it contains is the last part of flag: <code>1Ly_kn0w_QRCod3&#125;</code></p>
<p>Then the first part of the flag will be obtained from these twelve qr codes</p>
<p>Through many tools, you can find errors in all of these qr codes. So you can guess that the ecc hide some changed bits. Then you can try to find out which bits are changed.</p>
<p>The most direct solution is to use the Reed-Solomon codes to find the position of the wrong bits, and then find its place in the qr code. But this is  too complicated.</p>
<p>Since the content of each QR code is known, the version, error correction level, mask, and encoding method are all known. Then the qr code is uniquely determined. So as long as a correct QR code is generated, then we can find the changed place by diffing them:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> qrcode <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageOps, ImageChops</span><br><span class="line"></span><br><span class="line">rick = [</span><br><span class="line">    <span class="string">&quot;We&#x27;re no strangers to love&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You know the rules and so do I&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A full commitment&#x27;s what I&#x27;m thinking of&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You wouldn&#x27;t get this from any other guy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;I just wanna tell you how I&#x27;m feeling&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gotta make you understand&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna give you up&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna let you down&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna run around and desert you&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna make you cry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna say goodbye&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna tell a lie and hurt you&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, content <span class="keyword">in</span> <span class="built_in">enumerate</span>(rick):</span><br><span class="line">    img1 = Image.<span class="built_in">open</span>(<span class="string">f&quot;qrcodes/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    img2 = make(content, version=<span class="number">5</span>, error_correction=ERROR_CORRECT_H).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    cropped_img1 = img1.crop(ImageOps.invert(img1).getbbox())</span><br><span class="line">    cropped_img2 = img2.crop(ImageOps.invert(img2).getbbox()).resize(cropped_img1.size)</span><br><span class="line">    ImageChops.difference(cropped_img1, cropped_img2).save(<span class="string">f&quot;diff/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/p/12a2afd2/diffs.png"></p>
<p>Now we get the first part of the flag. So the flag is <strong>ACTF{Y0u_Re41Ly_kn0w_QRCod3}</strong></p>
</details>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>翔鸽最近好像在筹备一个二维码的视频，在开发时不小心在群里泄露了题目，虽然及时撤回了，但还是从群里的 bot 日志翻到了以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-06-24 13:57:24 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 刚写完了二维码生成器，但是好像写出 bug 了，扫描不了，你们看看？</span><br><span class="line">2022-06-24 13:57:50 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; [mirai:image:&#123;AA8F922E-7A7C-886E-F54C-E82D73F614D8&#125;.jpg]</span><br><span class="line">2022-06-24 13:58:26 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 草</span><br><span class="line">2022-06-24 13:58:58 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 才反应过来，这可不兴看啊，里面是要给 ACTF 出的题来着（</span><br><span class="line">2022-06-24 13:59:06 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 撤了撤了（</span><br></pre></td></tr></table></figure>

<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>首先，题目只有这些文字内容，显然首要的目标是得到那个撤回了的图片，根据 mirai QQ 机器人记录下的图片 uuid 套入官方的接口就可以得到那张图片的 url：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://gchat.qpic.cn/gchatpic_new/0/0--AA8F922E7A7C886EF54CE82D73F614D8/0</span><br></pre></td></tr></table></figure>
<p>访问得到图片：<br><img src="/p/12a2afd2/qq.jpg"><br>再由题目中的 Broken 以及信息 “写的二维码生成器出 bug 了，扫不了”，并且经过简单的分析可以看到二维码开头四个 bit、紧跟着的大小，以及中间的 padding 都是裸露在外的，所以可以推测是没有进行掩码操作（也可以通过第一个 hint “I broke this QR code by just missing a step“ 确定这一点）</p>
<p>将图片载入 <a href="https://merricx.github.io/qrazybox/">qrazybox</a>，打上一层掩码就可以直接扫描了，得到 <a href="https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93">https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93</a> ，里面是一个压缩包十六进制的字符串，存下来解压，得到十二个二维码：</p>
<p><img src="/p/12a2afd2/qrcodes.png"></p>
<p>扫描得到的结果是 Rickroll 歌词，而且均是完全的纯文本，没有内容上的把戏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We&#x27;re no strangers to love</span><br><span class="line">You know the rules and so do I</span><br><span class="line">A full commitment&#x27;s what I&#x27;m thinking of</span><br><span class="line">You wouldn&#x27;t get this from any other guy</span><br><span class="line">I just wanna tell you how I&#x27;m feeling</span><br><span class="line">Gotta make you understand</span><br><span class="line">Never gonna give you up</span><br><span class="line">Never gonna let you down</span><br><span class="line">Never gonna run around and desert you</span><br><span class="line">Never gonna make you cry</span><br><span class="line">Never gonna say goodbye</span><br><span class="line">Never gonna tell a lie and hurt you</span><br></pre></td></tr></table></figure>
<p>经过分析可以发现第一张图片的结尾有附加数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">410314c795f6b6e30775f5152436f64337d0ec187c229c4d4a44</span><br><span class="line"># to binary</span><br><span class="line">0100000100000011000101001100011110010101111101101011011011100011000001110111010111110101000101010010010000110110111101100100001100110111110100001110110000011000011111000010001010011100010011010100101001000100</span><br></pre></td></tr></table></figure>
<p>再通过本题主要考点为二维码，所以不难推测这是一段二维码填充内容的比特序列（包括标识符、大小、序列、padding、纠错码），解析出来的结果是 <code>1Ly_kn0w_QRCod3&#125;</code>，即 flag 的后半段</p>
<p>那么前半段的 flag 就要从那十二个二维码中获得了</p>
<p>因为除了第一张图片以外，没有任何的图片隐写，所以问题应该就出在二维码自身上。通过很多工具都可以发现这些二维码中存在错误，扫描时都是靠纠错码来纠错得到的正确内容，所以便是通过纠错的特性隐藏了一些更改</p>
<p>最直接的解法是利用里的所罗门编码纠错，找到错误的比特，再反推到图上。但这样有些过于复杂</p>
<p>既然每个二维码的内容已知，版本号、纠错等级、掩码编号、编码方式都已知，那么最后的二维码是唯一确定的，所以只要生成一个正确的二维码再和题给的二维码逐个 diff 就可以找到被更改的点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> qrcode <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageOps, ImageChops</span><br><span class="line"></span><br><span class="line">rick = [</span><br><span class="line">    <span class="string">&quot;We&#x27;re no strangers to love&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You know the rules and so do I&quot;</span>,</span><br><span class="line">    <span class="string">&quot;A full commitment&#x27;s what I&#x27;m thinking of&quot;</span>,</span><br><span class="line">    <span class="string">&quot;You wouldn&#x27;t get this from any other guy&quot;</span>,</span><br><span class="line">    <span class="string">&quot;I just wanna tell you how I&#x27;m feeling&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Gotta make you understand&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna give you up&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna let you down&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna run around and desert you&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna make you cry&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna say goodbye&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Never gonna tell a lie and hurt you&quot;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, content <span class="keyword">in</span> <span class="built_in">enumerate</span>(rick):</span><br><span class="line">    img1 = Image.<span class="built_in">open</span>(<span class="string">f&quot;qrcodes/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    img2 = make(content, version=<span class="number">5</span>, error_correction=ERROR_CORRECT_H).convert(<span class="string">&quot;RGB&quot;</span>)</span><br><span class="line">    cropped_img1 = img1.crop(ImageOps.invert(img1).getbbox())</span><br><span class="line">    cropped_img2 = img2.crop(ImageOps.invert(img2).getbbox()).resize(cropped_img1.size)</span><br><span class="line">    ImageChops.difference(cropped_img1, cropped_img2).save(<span class="string">f&quot;diff/<span class="subst">&#123;i&#125;</span>.jpg&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/p/12a2afd2/diffs.png"></p>
<p>即得到 flag 的前半部分，所以 flag: <strong>ACTF{Y0u_Re41Ly_kn0w_QRCod3}</strong></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后十二个二维码的修改是我在 qrazybox 里手动盲点的，导致最后一个二维码改错了没发现。比赛前一天写了 exp 跑了下才发现最后一个图点错了，于是直接重新改了一次，也懒得改其它的了。导致最后一个图的大小、位置等都和前面不一样。后来放了 hint 说了这个没有关系，但是貌似还是有很多师傅在最后一张图上盯了好久，给各位师傅道歉了呜呜呜 Orz</p>
<p>这题我感觉出的不是很难，没有刁钻地考二维码的东西（外面的一层也只是少了个掩码而已，没有什么裁剪啊，乱序啊，打马赛克啊一系列的骚操作），看到反馈有些师傅卡在了前半段，有些卡在了后半段，感觉都挺奇妙（特别是后半段，本来应该再构造一下的，比如穿插段数字模式编码啊什么的，这次完全用了字节模式，导致做一些移位就可以直接暴露出中间的内容，并不需要了解到这也和二维码有关</p>
<p>也可能是做的人少的原因，最后只有 L3H 一个队解出来了，蛮巧的是我也是在 L3HCTF 那场比赛的 cropped 题目之后才详细地学习了二维码，给 L3H 的师傅跪了 OTZ</p>
<p>总之感谢各位师傅参与这场比赛，希望这道题你们能喜欢 (￣▽￣)</p>
]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>「QRCode 标准阅读」#0 总章</title>
    <url>/p/409d352d.html</url>
    <content><![CDATA[<p>最近几次比赛遇到过好几次二维码的题目，打算好好来读一读标准文档 <a href="https://gcore.jsdelivr.net/gh/tonycrane/tonycrane.github.io/p/409d352d/ISO_IEC18004-2015.pdf">ISO/IEC 18004:2015</a><br>文档 6.1 前面的内容不多，就从它后面开始记了</p>
<h2 id="Table-of-Content"><a href="#Table-of-Content" class="headerlink" title="Table of Content"></a>Table of Content</h2><ul>
<li><a href="/p/1c1e6bbc.html">「QRCode 标准阅读」#1 构成及数据编码</a><br>  对应文档中的 6.1~7.4 部分</li>
<li><a href="/p/f956b4.html">「QRCode 标准阅读」#2 纠错码编码与图像生成</a><br>  对应文档中的 7.5～7.10 部分</li>
<li><a href="/p/12ee036b.html">「QRCode 标准阅读」#3 解码纠错过程</a><br>  对应文档中的 11 部分以及补充了 PGZ 解码相关内容</li>
</ul>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>「生活」2022 寒假总结</title>
    <url>/p/78cef964.html</url>
    <content><![CDATA[<p>一个月的寒假这么快就过完了，闲来无聊，还是写点东西记录一下这个假期干的事情吧 _(:з」∠)_</p>
<p>手机里的待办一点点变多，然后又一点点变少（<del>不想干了/不会做了，所以删了，乐</del>），总归还是做了点东西的</p>
<span id="more"></span>

<h2 id="摸鱼方面"><a href="#摸鱼方面" class="headerlink" title="摸鱼方面"></a>摸鱼方面</h2><p>当然还是先写点轻松愉快的</p>
<p>这个假期玩<del>通</del>了两个游戏，很像，也很震撼，很能给我惊喜</p>
<h3 id="baba-is-you"><a href="#baba-is-you" class="headerlink" title="baba is you"></a>baba is you</h3><p>也算是经典游戏了（？<br>在几次 CTF 里都见到了以 baba 为背景的游戏，所以就打算来玩一玩原版了</p>
<p>直播打了好几次，关卡越来越多，又不断解锁新玩法，新的隐藏地图，在隐藏地图里又开启一个另一个隐藏的地图<br>烧脑，但是好玩，打通了又很有成就感<br><img src="/p/78cef964/baba.jpg"><br>打通之后才发现还有两个官方关卡包，还有更多新玩法，又要继续肝了（这游戏买的真的值2333</p>
<h3 id="文字游戏"><a href="#文字游戏" class="headerlink" title="文字游戏"></a>文字游戏</h3><p>在打 baba is you 的时候才听说的，打了预览版还挺有意思，就开始等发售了</p>
<p>发售当晚买了下来，从七点一直直播打到凌晨两点，打通了（其实没有）<br>玩法当然新奇又有趣，剧情也超赞，而且 be 后的反转也搞得我浑身鸡皮疙瘩（<del>是不是说太多了</del></p>
<p>之后隔了一天，又继续打了二周目，这回解锁了真结局，真的感动<br>然后去搞到了全成就<br>这个游戏就完结了<br><img src="/p/78cef964/wordgame.jpg"><br>说多了剧透，反正强推就完事了</p>
<h3 id="番-剧-电影"><a href="#番-剧-电影" class="headerlink" title="番/剧/电影"></a>番/剧/电影</h3><p>这个学期补完了 EVA TV 版和旧剧场版<br>怕影响考试周，就没再接着看新剧场版<br>这个假期又是看 B 站又是找资源，看完了 序、Q、破、终 新剧场版<br>虽然依旧一脸懵逼，但是回味一下，还是很好的</p>
<p>我是个从来不看剧的人，但是在 GZTime 和同学的推荐下还是去看了《开端》<br>算是颠覆了我对电视剧的认识（毕竟是网文改<br>第一晚上看了三集上头了，第二天直接从吃完晚饭看到凌晨两点多一口气看完了<br>剧情没得说，演技也全员在线（<del>除了准备药检2333</del>）<br>牛的</p>
<p>电影嘛，电影院新上映的一部也没看<br>在 B 站补了《烈日灼心》《我们的父辈》<br>都相当好了（嗯.jpg<br><del>语言能力尚未达到人类标准，不详细评价了</del></p>
<h2 id="技术方面"><a href="#技术方面" class="headerlink" title="技术方面"></a>技术方面</h2><h3 id="Notebook"><a href="#Notebook" class="headerlink" title="Notebook"></a>Notebook</h3><p>起因是看到了 <a href="https://github.com/zjuchenyuan">chenyuan</a> 大佬的 <a href="https://blog.chenyuan.me/">notebook</a>，群友 <a href="https://github.com/zmx0142857">fran (zmx0142857)</a> 的 <a href="https://zmx0142857.gitee.io/note/">note</a>，还有 <a href="https://github.com/widcardw">widcardw</a> 的个人笔记。<br>都很全、很震撼、很羡慕<br>而且感觉自己好像也缺一个这样的东西，好多学到的东西不进脑子，学完就忘，还要到原来的地方再查一遍<br>于是就也自己开始拿 mkdocs 搭了一个，链接在：<a href="https://note.tonycrane.cc/">https://note.tonycrane.cc/</a><br><img src="/p/78cef964/note.jpg"></p>
<p>在这个博客之前用的也是 mkdocs，所以还是比较熟悉的<br>但是这次又详细地看了 mkdocs、pymarkdown、material 的文档，感觉 pymarkdown 的特性要比 hexo 的渲染器多得多，功能也多，调整空间也很大<br>material 增加的特性也很多很好用，香的一批，写的也舒适</p>
<p>为了和这个博客的主题匹配，我花了很长时间来重写了字体样式和配色主题，然后又从 <a href="https://facelessuser.github.io/pymdown-extensions/">pymdown-extensions 的文档</a><del>抄</del>学来了暗色主题和按钮的配置（比我当时给这个博客瞎写的高到不知道哪里去了2333）</p>
<p>搭完了之后又补充了很多东西进去，把这个博客里曾经写过的一些系列文章和 writeup 丢了进去，现在看上去还是比较完善了</p>
<p>这个 mkdocs 的 repo 也公开了，在 <a href="https://github.com/TonyCrane/note/">TonyCrane/note</a>，<del>快去 Star</del></p>
<h3 id="Q-群机器人"><a href="#Q-群机器人" class="headerlink" title="Q 群机器人"></a>Q 群机器人</h3><p>mk 的闲聊群里有一个机器人喵呜，很好玩（很可爱），打算自己也写一个玩一玩</p>
<p>然后在 GitHub 上逛到了 <a href="https://github.com/djkcyl/ABot-Graia">djkcyl/ABot-Graia</a> 这个项目，就去看了看 mirai 和 girai-ariadne<br>随手写了写，加了点类似显示 B 站视频信息、复读、咕咕咕、生成图片表情包、查天气、渲染 LaTeX、查 cdecl 之类的功能，写了一坨屎山<br>然后跑了起来，加到班级群里反响还不错，同学玩得都挺有意思（</p>
<p>之后又去看了 girai-saya，整理了结构，又写了最近大火的 wordle、handle 两个游戏，都放到了服务器上跑了<br>（虽然但是，这也是第一次用 screen，第一次用 vsc ssh 远程连接服务器，<del>老火星人了</del>）</p>
<p>现在代码还很乱，或许以后收拾收拾也扔到 GitHub 上（？</p>
<h3 id="ManimGL"><a href="#ManimGL" class="headerlink" title="ManimGL"></a>ManimGL</h3><p>本来是打算这个假期用 manim 做视频来着，结果却变成了修 manim / 改 manim<br><img src="/p/78cef964/manimgl.jpg"><br>总共开了 7 个 pull request，review 了 13 个 pr，发了 3 个 release<br>鸽兰特也给力，基本上 review 之后的当晚十二点就会给 merge</p>
<p>主要干的事呢，有两个</p>
<ul>
<li>修 SVGMobject，之前也专门发过文章 <a href="/p/81940d35.html">修复 ManimGL 中的 SVGMobject</a>，学到的 SVG 也放到了 <a href="https://note.tonycrane.cc/cs/web/svg/">notebook</a> 里。基本上完善了基本的 SVG 需要，包括样式和复杂路径的处理（虽然之后<a href="https://github.com/YishiMichael">忆拾</a>用<a href="https://github.com/3b1b/manim/pull/1731">更好的方法</a>(指调库)来改进了 SVGMobject）</li>
<li>写类型注解，主要是为了方便用 vsc 的时候提示，以及方便后续写文档。就花了三天多时间爆肝，给 ManimGL 里的所有类方法、函数都添加了类型注解，在 <a href="https://github.com/3b1b/manim/pull/1736">#1736</a> 这个 pr 里，竟然写了 2791+ 1401-，我都觉得不可思议（</li>
</ul>
<p><img src="/p/78cef964/1736.png"><br>大概还需要很长时间来检查，然后再 merge<br>之后还打算给所有文件添加 __all__，然后规范一下代码格式，再根据一些网站改进一下代码质量<br>鸽了，有时间就搞 _(:з」∠)_</p>
<h2 id="任务方面"><a href="#任务方面" class="headerlink" title="任务方面"></a>任务方面</h2><h3 id="暖冬宣讲"><a href="#暖冬宣讲" class="headerlink" title="暖冬宣讲"></a>暖冬宣讲</h3><p>算是这个假期的一个主要任务（？<br>宣讲队一共六个人，也不是太打得起精神<br>就边摆边干活，糊弄糊弄过去了</p>
<p>虽然但是，效果看上去还是可以的，群里收了 350+ 人，宣讲线上会议也有 110+ 人在听<br>希望没有给浙大丢脸（笑</p>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><p>新的一期视频打算和 GZTime、NanoApe 一起讲二维码<br>然后刚考完试就去看了 QRCode 这个包<br>然后按照自己的习惯拿 manim 重写了一个二维码生成器<br>又改了改就成为了新视频的轮子</p>
<p>之后开始写文案<br>和 GZTime 讨论了一下整体的安排之后花了两天写完了全部的文案（“两天”，其中穿插了打 baba、打文字游戏、看开端，乐）<br>大概 260 条，5k+ 字左右</p>
<p>然后做了第一个场景之后<del>累了</del>，就鸽了，留着慢慢做</p>
<h3 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h3><p>假期也没打几场比赛，HGAME 没参加，RealWorldCTF 没起到什么作用</p>
<p>VNCTF 个人赛倒是打了打，太拉垮了，所以 writeup 就没往这里发，扔到 note 里留着了：<a href="https://note.tonycrane.cc/writeups/vnctf2022/">VNCTF 2022 Writeup</a></p>
<h2 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h2><p>正常过了个年（此处略去……）</p>
<p><del>作息还是没调整过来，天天一点多睡，早上十点多醒</del>（悲）</p>
<h2 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h2><p>？<br>？？<br>寒假学什么习<br>数分线代想重学，没学上<br>汇编语言也没完整看完一遍<br>下学期的数逻也一点也没看上<br>Rust 想重新学好久了，也没学上</p>
<p>我怎么这么弱啊.jpg</p>
<p>shya 次一定，shya 次一定</p>
<hr>
<p>这么一看这个假期做的事情还是挺多的？(´▽｀)<br>马上开学了，希望我能从一大堆硬课和南方的气候中活下来 _(´ཀ`」 ∠)__ </p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>修复 ManimGL 中的 SVGMobject</title>
    <url>/p/81940d35.html</url>
    <content><![CDATA[<p>今天一天都在修 ManimGL 里的 SVGMobject，还是比较有收获的，写篇文章记录一下<br>起因是 fran 给了一个在 ManimGL 里表现怪异的 svg 文件：<a href="/81940d35/formula.svg">formula.svg</a></p>
<span id="more"></span>
<p>它在 ManimGL 下表现的是：<br><img src="/p/81940d35/formula.png"><br>不难发现几个问题：</p>
<ul>
<li>整体上下翻转了</li>
<li>左边多了一条粗线</li>
<li>矩阵大括号中间断开了</li>
<li>角标没有缩放，不在正确位置上</li>
</ul>
<p>通过检查 svg 源码可以发现主要是两个问题，一个是直接从嵌套在内层的 svg 元素中提取出了物件，二是没有正确处理 svg 的 transform</p>
<h2 id="只从最外层-svg-提取物件"><a href="#只从最外层-svg-提取物件" class="headerlink" title="只从最外层 svg 提取物件"></a>只从最外层 svg 提取物件</h2><p>这个问题产生的原因是在 <code>SVGMobject.init_points</code> 这个方法中，原来的代码是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = minidom.parse(self.file_path)</span><br><span class="line">self.ref_to_element = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> svg <span class="keyword">in</span> doc.getElementsByTagName(<span class="string">&quot;svg&quot;</span>):</span><br><span class="line">    mobjects = self.get_mobjects_from(svg)</span><br><span class="line">    <span class="keyword">if</span> self.unpack_groups:</span><br><span class="line">        self.add(*mobjects)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.add(*mobjects[<span class="number">0</span>].submobjects)</span><br><span class="line">doc.unlink()</span><br></pre></td></tr></table></figure>

<p>很明显，这里的 for 循环提取了全部的 svg 标签，然后从中提取出 mobjects</p>
<p>但是这样的话如果有嵌套在 svg 内部的 svg 就也会从中提取 mobjects，但这时就没有了外层的约束，导致重复生成，而且生成的位置错误</p>
<blockquote>
<p>在上面那个 svg 中就是这样，大括号分为三个部分，其中中间的一段是复用了一个元素，并且使用的是 svg 标签</p>
</blockquote>
<p>解决方法也很直接，直接遍历 doc 的子节点 childNodes，并且判断其 tagName 是否是 “svg”，不是就跳过<br>但这样仍存在一个问题，doc 的子节点可能不是 Element，比如注释，就是 Comment，它并没有 tagName 属性，所以还需要先判断一下这个节点是不是 Element</p>
<p>最终的解决办法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> doc.childNodes:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(child, minidom.Element): <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> child.tagName != <span class="string">&#x27;svg&#x27;</span>: <span class="keyword">continue</span> </span><br><span class="line">    mobjects = self.get_mobjects_from(child)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h2 id="正确处理-transforms"><a href="#正确处理-transforms" class="headerlink" title="正确处理 transforms"></a>正确处理 transforms</h2><p>上面 svg 中，角标没有缩放、放到正确位置的原因是，这两个操作在这个 svg 中都使用了 transform 来达成，所以它的值是 “translate(…) scale(…)”，前者负责平移，后者负责缩放</p>
<p>但是 ManimGL 中原来的处理方法是直接使用 “matrix(…)” “translate(…)” “scale(…)” 进行匹配，将中间内容当作参数，如果中途任何环节出现报错，都直接忽略掉<br>但是这样它会将这个 transform 解析成参数为 “…) scale(…” 的一个 translate，这显然会在后面抛出异常</p>
<p>然后就尝试了使用空格分割<br>效果倒是出现了，但是还是有一点问题，角标距离元素的距离太近，对比发现，可能是因为缩放和平移的施加顺序不同导致的</p>
<p>svg 标准中也有说明，transform 应该从右向左依次施加，所以临时的修正写法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transforms = element.getAttribute(<span class="string">&#x27;transform&#x27;</span>).split(<span class="string">&quot; &quot;</span>)[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> transform <span class="keyword">in</span> transforms:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>但是这样也有问题，因为标准中对于 transform 串的规定很宽松，两个 transform 中间可以不加空格，也可以有任意多空格，名字和左括号中间也可以有空格……</p>
<p>然后参考了 ManimCE，发现了里面有一个链接，是一个 python 写的 svg 解析器：<a href="https://github.com/cjlano/svg">https://github.com/cjlano/svg</a></p>
<p>按照里面的写法，使用了正则表达式来匹配名称和参数，根据规范，svg 仅支持 css transform 中的 matrix translate scale rotate skewX skewY，但我顺手还加了 translateX/Y scaleX/Y<br>全部的正则和匹配方法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform_names = [</span><br><span class="line">    <span class="string">&quot;matrix&quot;</span>, </span><br><span class="line">    <span class="string">&quot;translate&quot;</span>, <span class="string">&quot;translateX&quot;</span>, <span class="string">&quot;translateY&quot;</span>, </span><br><span class="line">    <span class="string">&quot;scale&quot;</span>, <span class="string">&quot;scaleX&quot;</span>, <span class="string">&quot;scaleY&quot;</span>, </span><br><span class="line">    <span class="string">&quot;rotate&quot;</span>, </span><br><span class="line">    <span class="string">&quot;skewX&quot;</span>, <span class="string">&quot;skewY&quot;</span></span><br><span class="line">]</span><br><span class="line">transform_pattern = re.<span class="built_in">compile</span>(<span class="string">&quot;|&quot;</span>.join([x + <span class="string">r&quot;[^)]*\)&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> transform_names]))</span><br><span class="line">number_pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;[-+]?(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][-+]?\d+)?&quot;</span>)</span><br><span class="line">transforms = transform_pattern.findall(element.getAttribute(<span class="string">&#x27;transform&#x27;</span>))[::-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> transform <span class="keyword">in</span> transforms:</span><br><span class="line">    op_name, op_args = transform.split(<span class="string">&quot;(&quot;</span>)</span><br><span class="line">    op_name = op_name.strip()</span><br><span class="line">    op_args = [<span class="built_in">float</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> number_pattern.findall(op_args)]</span><br></pre></td></tr></table></figure>
<p>其中第一个正则表达式很显然，匹配每一个名称，后面接任意多个非右括号的字符，然后是右括号<br>第二个字符比较复杂，可视化后还是比较清晰的：<br><img src="/p/81940d35/regex.png"><br>然后根据标准依次解决就好了：</p>
<ul>
<li>matrix 直接保留原来写好的就可以</li>
<li>translate 平移，translateX 时 y=0，translateX 时 x=0</li>
<li>scale 缩放，注意可能有负的情况，但是 ManimGL 已经禁止 scale 的时候 factor 小于等于 0，所以需要先 flip 一下（这也是为什么上面的公式上下颠倒了，因为有一个 scale(1, -1) 没有施加）</li>
<li>rotate 旋转，和 css 里不一样，这里的角度单位都是 deg，并且省去了 deg，而且可能会接受 3 个参数，这时后两个会做为一个坐标，表示旋转的中心点</li>
<li>skewX skewY 倾斜，可以直接转为 matrix：<ul>
<li>skewX(a): [1., 0., tana, 1., 0., 0.]</li>
<li>skewY(a): [1., tana, 0., 1., 0., 0.]</li>
</ul>
</li>
</ul>
<p>这之后上面的 svg 就可以正确渲染了：<br><img src="/p/81940d35/formula_.png"></p>
<hr>
<p>但是这之后还是有 bug，其中一个是老问题，在 path 元素的 string 中，有些时候会省略掉空格，导致原来的 ManimGL 无法处理，另一个是当 M 指令后紧接着 S 指令时，会因为点集内只有一个点而引起错误</p>
<h2 id="正确解析-path-string"><a href="#正确解析-path-string" class="headerlink" title="正确解析 path string"></a>正确解析 path string</h2><p>这个问题使用上面的那个正则表达式可以解决一部分，但是还有一个神奇的情况：两个 0 连着出现，也就是 “00”<br>这时后上面的正则会认为这是一个 0.0，而实际上，这是两个 0.0 并在了一起</p>
<p>然后 fran 改了改正则，在前面加了 “0|” 解决了这个问题</p>
<p>但是另一个更神奇的情况出现了：<code>A1.098 1.098 0 11.777 1.875z</code><br>看到这个第一反应肯定是五个数对吧，但是 A 指令只接受七个数</p>
<p>看了浏览器解析的结果后发现，参数实际上是 1.098 1.098 0 1 1 0.777 1.875<br>而这个是 1 1 .777 三个数而不是 11.777 一个数的原因是，A 指令的第 4、5 个参数是 flag，一定是 0 或 1</p>
<p>这样的话使用正则就很复杂了<br>一顿查找后发现了另一个解析 svg path 的库：<a href="https://github.com/regebro/svg.path/">https://github.com/regebro/svg.path/</a></p>
<p>按照里面的思路，重新写了一个 path 的解析器，即按照规则一个一个读取需要的数据，并且随时删掉开头的空格/逗号<br>其中读取单个浮点数用的还是上边的正则表达式</p>
<p>在重写了 path 解析之后，就很少因为这里出问题了</p>
<h2 id="正确处理-S-指令"><a href="#正确处理-S-指令" class="headerlink" title="正确处理 S 指令"></a>正确处理 S 指令</h2><p>对于下一个问题，报错出现在 <code>VMobject.get_reflection_of_last_handle</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_smooth_cubic_curve_to</span>(<span class="params">self, handle, point</span>):</span></span><br><span class="line">    self.throw_error_if_no_points()</span><br><span class="line">    new_handle = self.get_reflection_of_last_handle()</span><br><span class="line">    self.add_cubic_bezier_curve_to(new_handle, handle, point)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_reflection_of_last_handle</span>(<span class="params">self</span>):</span></span><br><span class="line">    points = self.get_points()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * points[-<span class="number">1</span>] - points[-<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>这里这样做的原因是，S 指令会把前一个点的控制点关于前一个点中心对称，作为当前点的控制点。而这里仅有一个当前点 point[-1]，而没有控制点 point[-2]，导致了 IndexError</p>
<p>而标准里也说了，如果 S 指令前面没有其他生成路径的指令，直接把当前点当作控制点，所以改一下就好：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.get_num_points() == <span class="number">1</span>:</span><br><span class="line">    new_handle = self.get_points()[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    new_handle = self.get_reflection_of_last_handle()</span><br></pre></td></tr></table></figure>

<hr>
<p>至此 SVGMobject 的 bug 基本上没剩多少了，但是还有几个标签没有实现，以及没有处理样式</p>
<p>而在样式处理这方面，ManimCE 做的已经很好了，打算有时间去借鉴过来 _(:з」∠)_</p>
<p>今天修 bug 的全部更改详见：<a href="https://github.com/3b1b/manim/pull/1712">3b1b/manim#1712</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.w3.org/TR/SVG/">SVG Standard</a></li>
<li><a href="https://github.com/cjlano/svg">cjlano/svg</a></li>
<li><a href="https://github.com/regebro/svg.path/">regebro/svg.path</a></li>
<li><a href="https://github.com/3b1b/manim/pull/1712">3b1b/manim#1712</a></li>
</ul>
]]></content>
      <categories>
        <category>manim</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>笔记</tag>
        <tag>manim</tag>
        <tag>python</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>「QRCode 标准阅读」#3 解码纠错过程</title>
    <url>/p/12ee036b.html</url>
    <content><![CDATA[<p><a href="/p/f956b4.html">&lt; #2</a></p>
<h2 id="解码（11、Annex-B）"><a href="#解码（11、Annex-B）" class="headerlink" title="解码（11、Annex B）"></a>解码（11、Annex B）</h2><p>简要的解码过程：</p>
<ol>
<li>定位并获取图像中的二维码，并把图像中的黑白块提取为 1 和 0</li>
<li>读取格式信息<span id="more"></span>
<ul>
<li>释放掩码 <code>101010000010010</code></li>
<li>进行纠错</li>
<li>如果纠错失败则将二维码镜面对称再尝试</li>
</ul>
</li>
<li>读取版本信息（如果有的话）</li>
<li>读取格式信息中的掩码编号，并释放掩码</li>
<li>读取并恢复数据字和纠错字</li>
<li>纠错，如果检测到了错误就纠正</li>
<li>把数据字解码得到结果</li>
</ol>
<h3 id="纠错（Annex-B）"><a href="#纠错（Annex-B）" class="headerlink" title="纠错（Annex B）"></a>纠错（Annex B）</h3><p>Annex B 讲的纠错过程很简略，而且符号说明不全，很难看懂</p>
<p>去学了学 PGZ 解码：<a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Peterson%E2%80%93Gorenstein%E2%80%93Zierler_decoder">Reed–Solomon_error_correction#Peterson–Gorenstein–Zierler_decoder</a></p>
<p>设当前版本下每块中有 $n$ 个字，$k$ 个数据字，$n-k$ 个纠错字，纠错容量为 $\nu$</p>
<p>首先定义原来的完整数据（即数据字和纠错字）从高位到低位为 $c_{n-1},c_{n-2},\cdots,c_0$ ，对应多项式为：</p>
<p>$$s(x)=\sum_{i=0}^{n-1}c_ix^i=c_{n-1}x^{n-1}+c_{n-2}x^{n-2}+\cdots+c_0$$</p>
<p>而且根据纠错码生成原理，$s(x)$ 可以被生成多项式 $g(x)$ 整除，其中</p>
<p>$$g(x)=\prod_{i=0}^{n-k-1}(x-\alpha^i)$$</p>
<p>所以 $s(x)$ 也有根 $s(\alpha^i)=0, i=0,1,\dots n-k-1$</p>
<p>再设接收到的消息多项式（可能有错）为 $r(x)$ ，误差多项式为 $e(x)$ ，满足：</p>
<p>$$r(x)=s(x)+e(x),\quad e(x)=\sum_{i=0}^{n-1}e_ix^i$$</p>
<p>先设一共有 $\nu$ 个错误，且每个错误的位置为 $i_k,k=0,1,\dots \nu-1$，所以有：</p>
<p>$$e(x)=\sum_{k=0}^{\nu-1}e_{i_k}x^{i_k}$$</p>
<p>最终的目标就是找到错误个数 $\nu$，错误位置 $i_k$，以及错误大小 $e_{i_k}$</p>
<h4 id="计算典型值"><a href="#计算典型值" class="headerlink" title="计算典型值"></a>计算典型值</h4><p>首先定义典型值（syndromes）为把 $\alpha^j$ 传入 $r(x)$ 得到的值 $S_j$，有：</p>
<p>$$S_j=r(\alpha^j)=s(\alpha^j)+e(\alpha^j)=e(\alpha^j)=\sum_{k=0}^{\nu-1}e_{i_k}(\alpha^j)^{i_k},j=0,1,\dots,n-k-1$$</p>
<p>此时如果得到的典型值都为 0，那说明没有错误</p>
<p>为了方便，再令 $X_k=\alpha^{i_k},Y_k=e_{i_k}$，这样 $X_k$ 也能用来定位错误，同时也有：</p>
<p>$$S_j=\sum_{k=0}^{\nu-1}Y_kX_k^j$$</p>
<p>写成矩阵形式就是：</p>
<p>$$<br>\begin{bmatrix}<br>X_0^0 &amp;X_2^0 &amp;\cdots &amp;X_{\nu-1}^0\\<br>X_0^1 &amp;X_1^1 &amp;\cdots &amp;X_{\nu-1}^1\\<br>\vdots &amp;\vdots &amp; &amp;\vdots\\<br>X_0^{n-k-1} &amp;X_1^{n-k-1} &amp;\cdots &amp;X_{\nu-1}^{n-k-1}<br>\end{bmatrix}<br>\begin{bmatrix}<br>Y_0\\Y_1\\\vdots\\Y_{\nu-1}<br>\end{bmatrix}=<br>\begin{bmatrix}<br>S_0\\S_1\\\vdots\\S_{n-k-1}<br>\end{bmatrix}<br>$$</p>
<p>所以只要求得位置 $X_k$ 就能得到错误大小，但是此时并不是线性的</p>
<h4 id="错误定位多项式"><a href="#错误定位多项式" class="headerlink" title="错误定位多项式"></a>错误定位多项式</h4><p>定义一个错误定位多项式（error locator polynomial）$\Lambda(x)$：</p>
<p>$$\Lambda(x)=\prod_{k=0}^{\nu-1}(1-xX_k)=1+\Lambda_1x+\Lambda_2x^2+\cdots+\Lambda_\nu x^\nu$$</p>
<p>可以看出 $\Lambda(X_k^{-1})=0$，所以对于 $0\leq j\leq\nu-1$ 有：</p>
<p>$$<br>Y_kX_k^{j+\nu}\Lambda(X_k^{-1}) =0<br>$$</p>
<p>$$<br>Y_{k}X_{k}^{j+\nu }(1+\Lambda _{1}X_{k}^{-1}+\Lambda _{2}X_{k}^{-2}+\cdots +\Lambda _{\nu }X_{k}^{-\nu })=0<br>$$</p>
<p>$$<br>Y_{k}X_{k}^{j+\nu }+\Lambda _{1}Y_{k}X_{k}^{j+\nu }X_{k}^{-1}+\Lambda _{2}Y_{k}X_{k}^{j+\nu }X_{k}^{-2}+\cdots +\Lambda _{\nu }Y_{k}X_{k}^{j+\nu }X_{k}^{-\nu }=0<br>$$</p>
<p>$$<br>Y_{k}X_{k}^{j+\nu }+\Lambda _{1}Y_{k}X_{k}^{j+\nu -1}+\Lambda _{2}Y_{k}X_{k}^{j+\nu -2}+\cdots +\Lambda _{\nu }Y_{k}X_{k}^{j}=0<br>$$</p>
<p>所以把 $k$ 从 $0$ 到 $\nu-1$ 累加起来也为 0：</p>
<p>$$\sum_{k=0}^{\nu-1}\left(Y_{k}X_{k}^{j+\nu }+\Lambda _{1}Y_{k}X_{k}^{j+\nu -1}+\Lambda _{2}Y_{k}X_{k}^{j+\nu -2}+\cdots +\Lambda _{\nu }Y_{k}X_{k}^{j}\right)=0$$</p>
<p>然后转换为每项累加并提取出 $\Lambda_i$：</p>
<p>$$\left(\sum _{k=1}^{\nu }Y_{k}X_{k}^{j+\nu }\right)+\Lambda _{1}\left(\sum _{k=1}^{\nu }Y_{k}X_{k}^{j+\nu -1}\right)+\cdots +\Lambda _{\nu }\left(\sum _{k=1}^{\nu }Y_{k}X_{k}^{j}\right)=0$$</p>
<p>根据典型值的定义有：</p>
<p>$$S_{j+\nu}+\Lambda_1S_{j+\nu-1}+\cdots+\Lambda_\nu S_k=0$$</p>
<p>把 $S_{j+\nu}$ 移到右边，并展开所有 $j$ 可以得到矩阵形式：</p>
<p>$$<br>\begin{bmatrix}<br>S_{0}&amp;S_{1}&amp;\cdots &amp;S_{\nu-1}\\S_{1}&amp;S_{2}&amp;\cdots &amp;S_{\nu}\\\vdots &amp;\vdots &amp;&amp;\vdots \\S_{\nu-1}&amp;S_{\nu}&amp;\cdots &amp;S_{2\nu -2}<br>\end{bmatrix}<br>\begin{bmatrix}\Lambda _{\nu }\\\Lambda _{\nu -1}\\\vdots \\\Lambda _{1}<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>-S_{\nu}\\-S_{\nu +1}\\\vdots \\-S_{2\nu-1 }<br>\end{bmatrix}<br>$$</p>
<p>此时是一个线性方程组，而且 $S_i$ 全部已知，可以解得 $\Lambda_i$</p>
<h4 id="得到错误位置和大小"><a href="#得到错误位置和大小" class="headerlink" title="得到错误位置和大小"></a>得到错误位置和大小</h4><p>此时多项式 $\Lambda(x)$  已经完全已知，所以可以求得其根（用 Chien search 算法在伽罗瓦域上求根）</p>
<p>再算其倒数即可得到 $X_k$ ，然后可以寻找到错误位置 $i_k$</p>
<p>这时也就可以带入第一个方程组求得错误大小 $Y_k$（或者利用 Forney algorithm）</p>
<p>得到了 $e(x)$ 后就可以根据 $r(x)$ 算出原始信息 $s(x)$ 了</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>「QRCode 标准阅读」#2 纠错码编码与图像生成</title>
    <url>/p/f956b4.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/1c1e6bbc.html">&lt; #1</a></p>
<p><a href="/p/12ee036b.html">#3 &gt;</a></p>
</div>

<h2 id="纠错码编码（7-5）"><a href="#纠错码编码（7-5）" class="headerlink" title="纠错码编码（7.5）"></a>纠错码编码（7.5）</h2><h3 id="纠错容量（7-5-1）"><a href="#纠错容量（7-5-1）" class="headerlink" title="纠错容量（7.5.1）"></a>纠错容量（7.5.1）</h3><p>纠错字（error correction codewords）可以纠正两种错误，一种是比如无法扫描或无法解码的已知位置的错误字（erasures），一种是未知位置的错误字（errors），一个 erasures 可以由一个纠错字纠错，而一个 errors 需要两个纠错字来纠错</p>
<span id="more"></span>

<p>可以纠错的 erasures 和 errors 的数量满足：</p>
<p>$$e+2t\leq d-p$$</p>
<p>其中 $e$ 是 erasures 的数量，$t$ 是 errors 的数量，$d$ 是纠错字的数量，$p$ 是被错误解析的保护字数量</p>
<p>其中 $p$ 由版本决定：</p>
<ul>
<li>$p=3$：版本 1-L</li>
<li>$p=2$：版本 1-M、2-L</li>
<li>$p=1$：版本 1-Q、1-H、3-L</li>
<li>$p=0$：其他所有版本</li>
</ul>
<h4 id="分块编码纠错码"><a href="#分块编码纠错码" class="headerlink" title="分块编码纠错码"></a>分块编码纠错码</h4><p>根据版本号及纠错等级，数据序列需要被分成 1 个或多个块，每块内需要单独编码纠错码</p>
<p>如果需要补充的话一律全部补充 0 比特到需要的长度</p>
<p>具体不同版本的分块块数和每块中数量安排以及纠错容量都在文档中 P38-44（pdf 中 P46-52）的大表格 Table 9 中</p>
<h3 id="生成纠错码（7-5-2）"><a href="#生成纠错码（7-5-2）" class="headerlink" title="生成纠错码（7.5.2）"></a>生成纠错码（7.5.2）</h3><h4 id="伽罗瓦域"><a href="#伽罗瓦域" class="headerlink" title="伽罗瓦域"></a>伽罗瓦域</h4><p>生成纠错码之前要先将所有数据字转换成一个多项式，使其限制于伽罗瓦域 $GF(2^3)\bmod 100011101$ 中，而且后续的四则运算也都是该伽罗瓦域中的运算</p>
<p>具体伽罗瓦域的生成原理可以看：<a href="https://www.codenong.com/cs105738710/">https://www.codenong.com/cs105738710/</a></p>
<p>简单来说就是多项式的加减法都是异或，乘除法要每一个比特模 2，每一个字节模 100011101（即该伽罗瓦域中的本原多项式 $x^8+x^4+x^3+x^2+1$）</p>
<p>具体多项式 mod 运算的方法可以看：<a href="https://blog.csdn.net/yaongtime/article/details/17200401">https://blog.csdn.net/yaongtime/article/details/17200401</a></p>
<p>简单来说就是多项式的长除法取模，而且注意这里的加减都是伽罗瓦域中的加减，即异或</p>
<h4 id="生成多项式（Annex-A）"><a href="#生成多项式（Annex-A）" class="headerlink" title="生成多项式（Annex A）"></a>生成多项式（Annex A）</h4><p>纠错码生成多项式的一般表达形式是：</p>
<p>$$g(x)=(x-\alpha^0)(x-\alpha^1)\cdots(x-\alpha^{n-1})$$</p>
<p>其中 $n$ 为纠错码字的个数，其中 $\alpha=2$， $\alpha^k$ 的是在伽罗瓦域下的运算，即：</p>
<p>$\alpha^0 = 1;\ \alpha^1=2;\ \alpha^2=4;\ \cdots;\ \alpha^7=128$</p>
<p>$\alpha^8=256\bmod 285=256\oplus 285=29;\ \alpha^9=29\times2=58;\ \cdots$</p>
<p>具体计算 $\alpha^k$ 的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alpha</span>(<span class="params">k</span>):</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        res *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> res &gt;= <span class="number">256</span>:</span><br><span class="line">            res ^= <span class="number">285</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>文档附录 A 中已经展开了所有可能 $n$ 值下的36个生成多项式</p>
<h4 id="生成纠错码"><a href="#生成纠错码" class="headerlink" title="生成纠错码"></a>生成纠错码</h4><p>文档里给了一个感觉比较晦涩难懂的图来展示生成纠错码的过程：</p>
<p><img src="/p/f956b4/ecgen.png"></p>
<p>不是很容易理解，于是找了另一篇文章：<a href="https://blog.csdn.net/ljm1995/article/details/88819664">https://blog.csdn.net/ljm1995/article/details/88819664</a></p>
<p>举个例子，比如要编码 12345678 这八个数字</p>
<p>版本 1-L，查 Table 9 得到分为 1 块，且该块内总字数为 26，数据字数为 19，纠错字数为 26-19=7</p>
<p>根据前面所说，比特流应该是： <code>0001 0000001000 0001111011 0111001000 1001110 0000</code></p>
<p>补成 8 的倍数长度： <code>00010000 00100000 01111011 01110010 00100111 00000000</code></p>
<p>添加 padding bits（补到 19 个字节）： <code>00010000 00100000 01111011 01110010 00100111 00000000 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100</code></p>
<p>写成多项式形式，次数是 19 次，整体乘 $x^7$：</p>
<p>$$16x^{25}+32x^{24}+123x^{23}+114x^{22}+39x^{21}+236x^{19}+\\17x^{18}+236x^{17}+17x^{16}+236x^{15}+17x^{14}+236x^{13}+\\17x^{12}+236x^{11}+17x^{10}+236x^{9}+17x^{8}+236x^{7}$$</p>
<p>再查附录 A 得到次数为 7 的生成多项式，并整体乘 $x^{18}$：</p>
<p>$$x^{25}+\alpha^{87}x^{24}+\alpha^{229}x^{23}+\alpha^{146}x^{22}+\alpha^{149}x^{21}+\\\alpha^{238}x^{20}+\alpha^{102}x^{19}+\alpha^{21}x^{18}$$</p>
<p>然后把第一个多项式除第二个多项式取余数</p>
<p>可以这样计算，把第二个多项式整体乘 16 即 $\alpha^4$：</p>
<p>$$\alpha^4x^{25}+\alpha^{91}x^{24}+\alpha^{233}x^{23}+\alpha^{150}x^{22}+\alpha^{153}x^{21}+\\\alpha^{242}x^{20}+\alpha^{106}x^{19}+\alpha^{25}x^{18}$$</p>
<p>计算出系数的值：</p>
<p>$$16x^{25}+163x^{24}+243x^{23}+85x^{22}+146x^{21}+\\176x^{20}+52x^{19}+3x^{18}$$</p>
<p>之后与第一个多项式异或得到：</p>
<p>$$131x^{24}+136x^{23}+197x^{22}+181x^{21}+216x^{19}+18x^{18}+\\236x^{17}+17x^{16}+236x^{15}+17x^{14}+236x^{13}+\\17x^{12}+236x^{11}+17x^{10}+236x^{9}+17x^{8}+236x^{7}$$</p>
<p>这之后最高次就变成了 24 次，重复整个过程直到结果只剩下 7 项（即最高次为 6 次）时即可得到：</p>
<p>$$188x^6+247x^5+62x^4+248x^3+53x^2+170x+224$$</p>
<p>所以纠错码就是：<code>188 247 62 248 53 170 224</code></p>
<p>转为二进制： <code>10111100 11110111 00111110 11111000 00110101 10101010 11100000</code></p>
<blockquote>
<p>所以整个二维码的编码区域（除格式信息外）全部内容就是： <code>00010000 00100000 01111011 01110010 00100111 00000000 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 10111100 11110111 00111110 11111000 00110101 10101010 11100000</code></p>
</blockquote>
<p>纠错码可以直接用 python 的 reedsolo 包来求解：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> reedsolo <span class="keyword">import</span> RSCodec, ReedSolomonError</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rsc = RSCodec(<span class="number">7</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(rsc.encode([<span class="number">16</span>, <span class="number">32</span>, <span class="number">123</span>, <span class="number">114</span>, <span class="number">39</span>, <span class="number">0</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>]))</span><br><span class="line">[<span class="number">16</span>, <span class="number">32</span>, <span class="number">123</span>, <span class="number">114</span>, <span class="number">39</span>, <span class="number">0</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">188</span>, <span class="number">247</span>, <span class="number">62</span>, <span class="number">248</span>, <span class="number">53</span>, <span class="number">170</span>, <span class="number">224</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(rsc.encode([<span class="number">16</span>, <span class="number">32</span>, <span class="number">123</span>, <span class="number">114</span>, <span class="number">39</span>, <span class="number">0</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>, <span class="number">17</span>, <span class="number">236</span>]))[-<span class="number">7</span>:]</span><br><span class="line">[<span class="number">188</span>, <span class="number">247</span>, <span class="number">62</span>, <span class="number">248</span>, <span class="number">53</span>, <span class="number">170</span>, <span class="number">224</span>]</span><br></pre></td></tr></table></figure>


<h2 id="剩余步骤（7-6-7-10）"><a href="#剩余步骤（7-6-7-10）" class="headerlink" title="剩余步骤（7.6~7.10）"></a>剩余步骤（7.6~7.10）</h2><h3 id="合成序列（7-6）"><a href="#合成序列（7-6）" class="headerlink" title="合成序列（7.6）"></a>合成序列（7.6）</h3><p>首先按照 2 中所述给完整信息编码成数据序列，其中也包含 padding bits，且长度为 8 的倍数</p>
<p>然后根据 3.1.1 中所说对数据序列进行分块，然后对每块分别生成纠错码</p>
<p>最后把数据序列的所有块按照字节依次交错合成新的数据序列，然后把纠错码的所有块按照字节交错合成纠错码序列。把新的数据序列和纠错码序列连接在一起，如果总长度不够二维码的容量，则在后面补充 3/4/7 个 0 比特（需要补多少在 Table 1 中有定义）</p>
<p>而且这样也要保证最短的数据块在最前面（已经由 Table 9 定义）</p>
<p>比如 5-H 版本的序列，需要分为 4 块，前两块是 11 个数据字、22 个纠错字，后两块是 12 个数据字、22 个纠错字：</p>
<p><img src="/p/f956b4/a.png"></p>
<p>最后的序列就是 $D_1,D_{12},D_{23},D_{35},\cdots,D_{45},D_{34},D_{46},E_1,E_{23},\cdots,E_{88}$</p>
<h3 id="填充数据（7-7）"><a href="#填充数据（7-7）" class="headerlink" title="填充数据（7.7）"></a>填充数据（7.7）</h3><p>把前面合成的完整消息序列填到二维码中，首先要先填充功能图案，然后预留出格式信息、版本信息的位置</p>
<p>填充时以两列为单位，即每次交替填充两列。从最右下角开始是最高位的比特，然后从右向左从下向上交替填充，到了上界时左转向下继续填充，遇到对齐图案直接穿过，遇到对齐图案边界则变为一行</p>
<p>也可以按照字节来依次填充，如果是向上填充，则最高位在下端，反之在上段。每个字节块内的最高位尽量取最右侧的，但如果最下(上)端只有一个比特的位置，则选它作为最高比特的位置</p>
<p>反正按顺序正常填就行了，遇到东西就绕</p>
<p><img src="/p/f956b4/Untitled%206.png"></p>
<p><img src="/p/f956b4/Untitled%207.png"></p>
<p><img src="/p/f956b4/Untitled%208.png"></p>
<p><img src="/p/f956b4/Untitled%209.png"></p>
<p><img src="/p/f956b4/Untitled%2010.png"></p>
<h3 id="掩码遮盖（7-8）"><a href="#掩码遮盖（7-8）" class="headerlink" title="掩码遮盖（7.8）"></a>掩码遮盖（7.8）</h3><p>填充后的数据还要遮盖一层掩码（异或）来平衡黑白块的数量，以及减少容易产生扫描错误的大块和形似功能图案的部分出现</p>
<p>QR 码一共有 8 种掩码，每个掩码有一个 3 bits 的编号，和一个生成公式。这个公式用来生成掩码图样，以左上为原点，向右、下为正方向，坐标满足这个公式的点在图样中是黑色（1），不满足的是白色（0）。在版本 1 中的掩码图像表现为：</p>
<p><img src="/p/f956b4/Untitled%2011.png"></p>
<p>进行掩码操作就是把除去功能图案和版本信息、格式信息之外的数据部分每一块的值与掩码图样异或</p>
<p>整个操作需要生成分别使用不同掩码的 8 个图样，然后计算出损失分数（penalty points score），然后采用损失分数最小的掩码模式作为最终的掩码模式</p>
<h4 id="计算损失分数（7-8-3）"><a href="#计算损失分数（7-8-3）" class="headerlink" title="计算损失分数（7.8.3）"></a>计算损失分数（7.8.3）</h4><p>虽然进行掩码操作时仅对非功能图案、非版本信息格式信息的数据区域进行掩码，但是计算损失分数时按照整个二维码计算</p>
<p>计算损失分有四个规则：</p>
<ul>
<li>相邻一行或一列内出现连续五个相同颜色块时损失分 +3，之后连续块数每加一，损失分 +1</li>
<li>寻找内部颜色相同的 2*2 的块，每出现一个损失分 +3</li>
<li>在每行和每列中寻找 <code>10111010000</code> 和 <code>00001011101</code> ，每出现一个损失分 +40</li>
<li>评估黑色块占全部块数的比例，如果在 45%~55% 间则不增加损失分，在 40%~45%、55%~60% 间则损失分 +10，在 35%~40%、60%~65% 间则损失分 +10*2，以此类推</li>
</ul>
<p>更详细的例子可以看：<a href="https://www.thonky.com/qr-code-tutorial/data-masking">https://www.thonky.com/qr-code-tutorial/data-masking</a></p>
<p>然后对所有掩码结果计算损失分数后选择分数最低的一个作为最终结果</p>
<h3 id="格式信息（7-9）"><a href="#格式信息（7-9）" class="headerlink" title="格式信息（7.9）"></a>格式信息（7.9）</h3><p>QRCode 的格式信息是 15 bits 的序列，其中前 5 位是数据，后 10 位是针对格式信息的纠错码（由 (15, 5) BCH 码生成）</p>
<p>5 bits 的数据前 2 位是纠错等级标识符，分别是 L -&gt; <code>01</code> 、M -&gt; <code>00</code> 、Q -&gt; <code>11</code> 、H -&gt; <code>10</code></p>
<p>后 3 位是上面说到的掩码编号</p>
<p>然后后接 10 bits 纠错码，最后整体异或 <code>101010000010010</code> 防止产生全零数据序列</p>
<h4 id="生成纠错码（Annex-C）"><a href="#生成纠错码（Annex-C）" class="headerlink" title="生成纠错码（Annex C）"></a>生成纠错码（Annex C）</h4><p>先得到前 5 bits 的数据，然后化为多项式，整体乘 $x^{10}$，再除以生成多项式 $G(x)=x^{10}+x^8+x^5+x^4+x^2+x+1$ 得到余数转换为后 10 bits 的纠错码</p>
<ul>
<li><strong>例子</strong><ul>
<li>纠错等级 M，掩码编号 101</li>
<li>5 bits 数据： <code>00101</code></li>
<li>写为多项式： $x^2+1$</li>
<li>整体乘 $x^{10}$： $x^{12}+x^{10}$</li>
<li>除以 $G(x)$： 商 $x^2$，余数 $x^7+x^6+x^4+x^3+x^2$</li>
<li>余数转为 10 bits 纠错码： <code>0011011100</code></li>
<li>加上原数据： <code>001010011011100</code></li>
<li>异或 <code>101010000010010</code>： <code>100000011001110</code></li>
</ul>
</li>
</ul>
<p>因为 5 bits 的数据一共只有 32 种情况，所以附录 C 中直接给出了完整的表格：</p>
<p><img src="/p/f956b4/TableC1.png" alt="Table C.1 全部可能格式信息"></p>
<p><strong>纠错</strong>：最多可以纠正 3 bits 的错误，先把格式信息异或 <code>101010000010010</code> 得到原始序列，然后与 Table C.1 中的有效格式信息进行对比，如果找不到说明有错误。此时仅选择 Table C.1 中与错误格式信息相差比特最少的一个作为纠正后的格式信息即可，如果相差少于等于 3 个比特，则视为纠正成功</p>
<h4 id="填入二维码"><a href="#填入二维码" class="headerlink" title="填入二维码"></a>填入二维码</h4><p>左上角的格式信息区域填充一份完整的格式信息（最高位在左），左下角和右上角合起来是一份完整的格式信息（最高位在左下角的最下，最低位在右上角的最右）。并且左下角的格式信息上方（位置<code>(4V+9,8)</code>）有一块始终是黑色：</p>
<p><img src="/p/f956b4/Untitled%2018.png"></p>
<h3 id="版本信息（7-10）"><a href="#版本信息（7-10）" class="headerlink" title="版本信息（7.10）"></a>版本信息（7.10）</h3><p>在版本 7 及以上的二维码中需要填入版本信息来确保准确度</p>
<p>版本信息只储存了该二维码的版本号（7～40），一共 18 bits，前 6 bits 为版本号的二进制（从 <code>000111</code> 到 <code>101000</code>），后 12 bits 为由 (18, 6) Golay code 生成的纠错码</p>
<p>不同于格式信息，因为版本号不会出现全零，所以不需要进行掩码操作</p>
<h4 id="生成纠错码（Annex-D）"><a href="#生成纠错码（Annex-D）" class="headerlink" title="生成纠错码（Annex D）"></a>生成纠错码（Annex D）</h4><p>和格式信息的纠错码类似，先把前 6 bits 转为多项式，然后整体乘 $x^{12}$，得到的结果除以生成多项式 $G(x)=x^{12}+x^{11}+x^{10}+x^9+x^8+x^5+x^2+x^1$ ，把余数转为 12 bits 二进制就是纠错码了</p>
<p>因为只有 34 个版本有版本信息，所以也就只有 34 种有效的版本信息序列，附录 D 的 Table D.1 中给出了完整的 34 个版本信息序列</p>
<p><img src="/p/f956b4/TableD1.png" alt="Table D.1 全部有效版本信息序列"></p>
<p>和格式信息一样，纠错时对照表格选择相差比特数最小的即可。并且版本信息也只能纠正小于等于 3 个错误</p>
<h4 id="填入二维码-1"><a href="#填入二维码-1" class="headerlink" title="填入二维码"></a>填入二维码</h4><p>在版本 7 以上的二维码中已经预留出了两个 6*3 大小的区域，一个位于左下分割线的上方时序图案左侧，一个位于右上分割线左侧时序图案的上方</p>
<p>按照下图顺序填入即可：</p>
<p><img src="/p/f956b4/Untitled%2020.png"></p>
<hr>
<p>未完待续……<a href="/p/12ee036b.html">「QRCode 标准阅读」#3 解码纠错过程</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>「QRCode 标准阅读」#1 构成及数据编码</title>
    <url>/p/1c1e6bbc.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/409d352d.html">&lt; #0</a></p>
<p><a href="/p/f956b4.html">#2 &gt;</a></p>
</div>

<h2 id="基础描述及结构（6-1、6-3）"><a href="#基础描述及结构（6-1、6-3）" class="headerlink" title="基础描述及结构（6.1、6.3）"></a>基础描述及结构（6.1、6.3）</h2><h3 id="基础描述（5-3、6-1）"><a href="#基础描述（5-3、6-1）" class="headerlink" title="基础描述（5.3、6.1）"></a>基础描述（5.3、6.1）</h3><ul>
<li>块位置：左上角为原点 (0, 0) 向下x+，向右y+</li>
<li>版本表示：Version V-E（其中V是版本号，E是纠错等级）</li>
<li>数据表示：黑块-1 白块-0（可以带背景全部反色）</li>
<li>大小：从版本1到版本40依次是 21x21 ～ 177x177（每增加一个版本，边长增加4）<span id="more"></span></li>
<li>支持的最多字符数（版本40）<ul>
<li>数字模式：7089</li>
<li>字母模式：4296</li>
<li>字节模式：2953</li>
<li>日文模式：1817</li>
</ul>
</li>
<li>纠错等级允许的恢复比例<ul>
<li>L：7%</li>
<li>M：15%</li>
<li>Q：25%</li>
<li>H：30%</li>
</ul>
</li>
</ul>
<h3 id="二维码结构（6-3）"><a href="#二维码结构（6-3）" class="headerlink" title="二维码结构（6.3）"></a>二维码结构（6.3）</h3><ul>
<li>功能图案（function patterns）<ul>
<li>特征符（finder pattern）7x7黑圈 5x5白圈 3x3黑块</li>
<li>分割线（separator）在特征符周围的一圈全白区域</li>
<li>时序图案（timing patterns）第7行第7列的两条黑白条纹</li>
<li>对齐图案（alignment patterns）版本1无，版本2-6 1个，版本7-13 6个……（附录E）</li>
<li>静默区（quiet zone）至少4个单位宽</li>
</ul>
</li>
<li>编码区域（encoding region）<ul>
<li>格式信息（format information）左上角分割线外一圈，左下角分割线右侧，右上角分割线下侧</li>
<li>版本信息（version information）版本7后才有，在左下分割线上侧，右上分割线左侧</li>
<li>数据及纠错码区域</li>
</ul>
</li>
</ul>
<p><img src="/p/1c1e6bbc/structure.png"></p>
<h2 id="数据编码（7-4）"><a href="#数据编码（7-4）" class="headerlink" title="数据编码（7.4）"></a>数据编码（7.4）</h2><h3 id="数据序列（7-4-1）"><a href="#数据序列（7-4-1）" class="headerlink" title="数据序列（7.4.1）"></a>数据序列（7.4.1）</h3><p>默认的 ECI 模式下，比特流以模式标识符开始。如果不是默认 ECI 模式，则需要从 ECI 头开始：</p>
<ul>
<li>（4 bits）ECI 模式标识符</li>
<li>（8/16/24 bits）ECI Designator</li>
</ul>
<p>比特流的剩余部分由下面几部分组成：</p>
<ul>
<li>（4 bits）模式标识符</li>
<li>字符数量标识符（长度见下第二个表）</li>
<li>数据比特流</li>
</ul>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">标识符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ECI</td>
<td align="center">0111</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">数字模式</td>
<td align="center">0001</td>
<td align="left">只包含数字0-9，3个数字 10 bits</td>
</tr>
<tr>
<td align="center">字母数字模式</td>
<td align="center">0010</td>
<td align="left">45个字符，0-9A-Z 及9个符号 空格$%*+-./:，2个字符 11 bits</td>
</tr>
<tr>
<td align="center">字节模式</td>
<td align="center">0100</td>
<td align="left">每个字符 8 bits</td>
</tr>
<tr>
<td align="center">日本汉字模式</td>
<td align="center">1000</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">结构添加模式</td>
<td align="center">0011</td>
<td align="left"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">数字模式字符数量标识符长度</th>
<th align="center">字母模式……</th>
<th>字节模式……</th>
<th align="center">日文模式……</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1～9</td>
<td align="center">10</td>
<td align="center">9</td>
<td>8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">10～26</td>
<td align="center">12</td>
<td align="center">11</td>
<td>16</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">27～40</td>
<td align="center">14</td>
<td align="center">13</td>
<td>16</td>
<td align="center">12</td>
</tr>
</tbody></table>
<h3 id="ECI-模式（7-4-2）"><a href="#ECI-模式（7-4-2）" class="headerlink" title="ECI 模式（7.4.2）"></a>ECI 模式（7.4.2）</h3><p>ECI 模式即使用某些特定的字符映射来把字符转换为比特流</p>
<p>而且都使用字节模式来表示数据（即在 ECI 头后的模式标识符为字节模式的 0100）</p>
<p>每个 ECI 都有一个六位数编号（assignment value），可能占 1、2、3 个 codewords，具体标识方式见下表（占1个 codewords 时开头一定是0，占2个时开头一定是10，占3个时开头一定是110）表中 xxxxxxxx 表示编号的二进制</p>
<table>
<thead>
<tr>
<th align="center">ECI Assignment Value</th>
<th>Codewords values</th>
</tr>
</thead>
<tbody><tr>
<td align="center">000000 ～ 000127</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td align="center">000000 ～ 016383</td>
<td>10xxxxxx xxxxxxxx</td>
</tr>
<tr>
<td align="center">000000 ～ 999999</td>
<td>110xxxxx xxxxxxxx xxxxxxxx</td>
</tr>
</tbody></table>
<p>而且 ECI 模式下中途可以更换 ECI 指示器，一个 5C（01011100）表示换新的 ECI，后面要接6个 codewords 即6个数字（十六进制30～39）表示编号，而不是用上表中的表示方法。而 5C 正常情况下表示 \ ，所以表示 \ 这个原数据需要用两个 5C</p>
<ul>
<li><strong>例子 1</strong><ul>
<li>使用 ISO/IEC 8859-7（ECI 000009）来表示希腊字母ΑΒΓΔΕ（该 ECI 下表示为十六进制 A1 A2 A3 A4 A5）</li>
<li>比特流：<ul>
<li>ECI 标识符：<code>0111</code></li>
<li>ECI 编号：<code>00001001</code></li>
<li>字节模式标识符：<code>0100</code></li>
<li>字符数量：<code>00000101</code>（5个字符）</li>
<li>数据：<code>10100001 10100010 10100011 10100100 10100101</code></li>
</ul>
</li>
<li>所以最终的比特流：<code>0111 00001001 0100 00000101 10100001 10100010 10100011 10100100 10100101</code></li>
</ul>
</li>
<li><strong>例子 2（14.3）</strong><ul>
<li>需要编码的数据：ABC\123456<ul>
<li>数据流中十六进制（字节模式标识符0100后）：41 42 43 5C 5C 31 32 33 34 35 36</li>
</ul>
</li>
<li>需要编码的数据：ABC&lt;后接 ECI 123456 下的数据……&gt;<ul>
<li>数据流中十六进制（字节模式标识符0100后）：41 42 43 5C 31 32 33 34 35 36 ……</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数字模式（7-4-3）"><a href="#数字模式（7-4-3）" class="headerlink" title="数字模式（7.4.3）"></a>数字模式（7.4.3）</h3><p>输入的数字字符串（因为开头可以是0）要被分成3个一组，每组会转换为 10 bits 的二进制串（999 -&gt; <code>1111100111</code>）。剩余不到3个的部分，如果剩2个数字，则将其转换为 7 bits 的二进制串（99 -&gt; <code>1100011</code>）如果剩1个数字，则将其转换为 4 bits 的二进制串（9 -&gt; <code>1001</code>）</p>
<p>然后开头加上数字模式标识符 <code>0001</code> 和数量标识符（字符个数转为二进制，并开头补0至长度，长度由版本决定，见上 7.4.1 部分的第二个表）</p>
<ul>
<li><strong>例子</strong><ul>
<li>数据内容： <code>01234567</code>（保留开头0）</li>
<li>数据流部分：<ul>
<li>数字模式标识符： <code>0001</code></li>
<li>数量标识符： <code>0000001000</code>（8，且版本1下规定为 10 bits）</li>
<li>数据：<ul>
<li>012 -&gt; <code>0000001100</code></li>
<li>345 -&gt; <code>0101011001</code></li>
<li>67 -&gt; <code>1000011</code></li>
</ul>
</li>
</ul>
</li>
<li>完整数据比特流： <code>0001 0000001000 0000001100 0101011001 1000011</code></li>
</ul>
</li>
</ul>
<p>数字模式下的比特流长度为：</p>
<p>$$B=M+C+10\times\lfloor\frac{D}{3}\rfloor+R$$</p>
<p>其中 M 为 4，C 为数量标识符长度（版本1～9为 10，版本10～26为 12，版本27～40为 14），D为输入字符个数，R为剩余部分（若 D mod 3 = 0 则为 0，若 D mod 3 = 1 则为 4，若 D mod 3 = 2 则为 7）</p>
<h3 id="字母数字模式（7-4-4）"><a href="#字母数字模式（7-4-4）" class="headerlink" title="字母数字模式（7.4.4）"></a>字母数字模式（7.4.4）</h3><p>数字字母模式（Alphanumeric mode）下支持的编码字符有45个，把它们从0编号至44。其中 0-9 对应数字 0-9，10-35 对应字母 A-Z，36-44 对应9个符号：</p>
<p><img src="/p/1c1e6bbc/alnum.png"></p>
<p>输入的字符先按照上表转换为数值，然后分为两个一组，每一组内把 第一个数值 × 45 + 第二个数值，再转换为长度为 11 bits 的二进制串（最大为 44×45+44=2024 -&gt; <code>11111101000</code>）。如果字符长度为奇数，则会剩余出一个字符，需要将其值转换为长度为 6 bits 的二进制串（最大为 11 -&gt; <code>101100</code>）</p>
<p>然后开头加上字母数字模式标识符 <code>0010</code> 和数量标识符（长度由 7.4.1 第二个表规定）</p>
<ul>
<li><strong>例子</strong><ul>
<li>数据内容：AC-42</li>
<li>数据流部分：<ul>
<li>字母数字模式标识符： <code>0010</code></li>
<li>数量标识符： <code>000000101</code>（5，且版本1下规定长度为9）</li>
<li>数据：AC-42 -&gt; 10 12 41 4 2 -&gt; (10 12)(41 4)(2)<ul>
<li>10 12 -&gt; 10*45+12=462 -&gt; <code>00111001110</code></li>
<li>41 4 -&gt; 41*45+4=1849 -&gt; <code>11100111001</code></li>
<li>2 -&gt; 2 -&gt; <code>000010</code> </li>
</ul>
</li>
</ul>
</li>
<li>完整数据比特流： <code>0010 000000101 00111001110 11100111001 000010</code></li>
</ul>
</li>
</ul>
<p>字母数字模式下的比特流长度为：</p>
<p>$$B=M+C+11\times\lfloor\frac{D}{2}\rfloor+6\times(D\bmod 2)$$</p>
<p>其中 M 为 4，C 为数量标识符长度，D 为原数据长度</p>
<h3 id="字节模式（7-4-5）"><a href="#字节模式（7-4-5）" class="headerlink" title="字节模式（7.4.5）"></a>字节模式（7.4.5）</h3><p>字节模式（Byte mode）下把每个字符根据 Latin-1（ISO/IEC 8859-1）编码成 8 bits（1字节），直接接在字节模式标识符 <code>0100</code> 和数量标识符（长度由 7.4.1 第二个表规定）的后面。</p>
<p><img src="/p/1c1e6bbc/Latin-1.png" alt="Latin-1"></p>
<p>字节模式下的比特流长度：</p>
<p>$$B=M+C+8\times D$$</p>
<p>其中 M 为 4，C 为数量标识符长度，D 为原数据长度</p>
<h4 id="中文编码"><a href="#中文编码" class="headerlink" title="中文编码"></a>中文编码</h4><p>中文在转换成比特流的时候也使用字节模式，需要用 UTF-8 编码，每个字符会被编码成 3 个字节</p>
<h3 id="混合模式（7-4-7）"><a href="#混合模式（7-4-7）" class="headerlink" title="混合模式（7.4.7）"></a>混合模式（7.4.7）</h3><p>一个二维码的数据流中也可以使用多种模式，且不需要特别表示。更换新的模式时只需要正常添加 模式标识符+数量标识符+数据 即可</p>
<p><img src="/p/1c1e6bbc/multi.png"></p>
<ul>
<li><strong>例子</strong><ul>
<li>原始数据：123测试</li>
<li>数据流：<ul>
<li>数字模式：<ul>
<li>标识符： <code>0001</code></li>
<li>数量标识符： <code>0000000011</code>（3，长度10）</li>
<li>数据：123 -&gt; <code>0001111011</code></li>
</ul>
</li>
<li>字节模式：测试 -&gt; E6 B5 8B / E8 AF 95<ul>
<li>标识符： <code>0100</code></li>
<li>数量标识符： <code>00000110</code>（6，长度8）</li>
<li>数据：<ul>
<li>测 -&gt; <code>11100110 10110101 10001011</code></li>
<li>试 -&gt; <code>11101000 10101111 10010101</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>完整数据比特流： <code>0001 0000000011 0001111011 0100 00000110 11100110 10110101 10001011 11101000 10101111 10010101</code></li>
</ul>
</li>
</ul>
<h3 id="结束符（7-4-9）"><a href="#结束符（7-4-9）" class="headerlink" title="结束符（7.4.9）"></a>结束符（7.4.9）</h3><p>在数据的末尾要填充4个0作为结束符，如果容量不足的话可以缩短或省略<br>即能填下则加4个0，填不下则能加几个0就加几个0</p>
<h3 id="填充-padding-bits（7-4-10）"><a href="#填充-padding-bits（7-4-10）" class="headerlink" title="填充 padding bits（7.4.10）"></a>填充 padding bits（7.4.10）</h3><p>转换后的数据比特流还需要填充至二维码的数据容量</p>
<ol>
<li>首先先用 <code>0</code> 补充比特流长度到 8 的整数倍</li>
<li>然后用 <code>11101100</code> 和 <code>00010001</code> 交替填补到二维码数据容量</li>
</ol>
<p>具体的数据容量由版本号和纠错等级决定，且数据容量（比特）一定为8的倍数，完整数据见文档的 33～36 页（整个 pdf 的第 41～44 页）</p>
<p>注：这个地方 QRazyBox 网站存在 bug，有时无法正常识别填充的 0 比特和 padding bits（即可能把填充的 0 中前四个视为一个 terminator，把后面的 0 才视为属于 padding bits ）</p>
<hr>
<p>未完待续……<a href="/p/f956b4.html">「QRCode 标准阅读」#2 纠错码编码与图像生成</a></p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hackergame 2021」#4 Writup 持续破防篇 1</title>
    <url>/p/d11ec8ed.html</url>
    <content><![CDATA[<p><a href="/p/f152ab1f.html">&lt; #3</a></p>
<p>这里接<a href="/p/fd872e78.html">上一篇</a>，Writeup 的有：阵列恢复、马赛克、minecRaft、密码生成器<br>（其实 minecRaft 应该算“开局上分”篇，但是不好塞了，就放这里了）<br>剩下的就是做不上的了，看官方 Writeup 了（</p>
<span id="more"></span>
<h2 id="阵列恢复大师"><a href="#阵列恢复大师" class="headerlink" title="阵列恢复大师"></a>阵列恢复大师</h2><p>（这题整整做了我两天多，每天晚上都对着磁盘阵列……）</p>
<blockquote>
<p>以下是两个压缩包，分别是一个 RAID 0 阵列的磁盘压缩包，和一个 RAID 5 阵列的磁盘压缩包，对应本题的两小问。你需要解析得到正确完整的磁盘阵列，挂载第一个分区后在该分区根目录下使用 Python 3.7 或以上版本执行 getflag.py 脚本以获取 flag。磁盘数据保证无损坏。</p>
</blockquote>
<h3 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h3><p>虽然 RAID 5 是第二问，而且分数高，但是更好做，而且做出的人也多。<br>因为数据保证无损坏，所以要做的仅仅是找出五个磁盘的顺序和块大小</p>
<p>顺序可以先简单地看看 strings *.img 输出的内容<br>逐个文件看，可以发现每个文件比较靠前的地方会有一段是 git 历史记录的一部分:<br><img src="/p/d11ec8ed/raid5.png"><br>根据里面的时间可以推断出磁盘的顺序大致是：</p>
<p style="text-align: center;">Qj... -> 60... -> 3R... -> Ir... -> 3D...</p>
只是，这个顺序应该是一个环，谁在第一还没区分出来

<p>在看每个文件的头部，只有 60… 和 3R… 有 “EFI PART”:<br><img src="/p/d11ec8ed/raid5_.png"><br>所以应该是一个在开头，一个在结尾。所以最终的顺序是：</p>
<p style="text-align: center;">3R... -> Ir... -> 3D... -> Qj... -> 60...</p>

<p>然后需要找到块大小<br>直接丢到 DiskGenius 里组建虚拟 RAID，选左同步，然后可以试出来当块大小是 64k 的时候正好可以拼出完整磁盘<br>然后克隆磁盘生成 img 文件，再挂载，进入，执行 getflag.py 就得到了 flag </p>
<h3 id="RAID-0"><a href="#RAID-0" class="headerlink" title="RAID 0"></a>RAID 0</h3><p>在做 RAID 5 的时候还发现了一个叫 Raid Reconstructor 的软件，可以爆破 RAID 阵列顺序和块大小<br>所以这问也就懒得看了，直接丢给 Raid Reconstructor 来爆破，得到最推荐的顺序：</p>
<p style="text-align: center;">wl. -> jC. -> 1G. -> 5q. -> d3. -> eR. -> RA. -> ID.</p>
和块大小 128k

<p>然后直接用 Raid Reconstructor 的 Copy 导出 img 文件，提取后又得到一个新的 img 文件<br>通过 file 可以看到结果的文件系统是 XFS</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ file MyDisk.img</span><br><span class="line">MyDisk.img: SGI XFS filesystem data (blksz 4096, inosz 512, v2 <span class="built_in">dirs</span>)</span><br></pre></td></tr></table></figure>

<p>但是始终无法挂载（搞了一天）<br>可能是 Raid Reconstructor 的问题，所以又用 DiskGenius 试了下<br>因为 win 和 DiskGenius 读不了 XFS 文件系统，所以拼起来之后直接克隆出 img 文件<br>然后拖到 Kali Linux 里挂载，成功挂载后进入、运行 getflag.py 就得到了 flag </p>
<hr>
<h2 id="马赛克"><a href="#马赛克" class="headerlink" title="马赛克"></a>马赛克</h2><p>（这道题已经做破防了，本以为是个青铜，结果是个王者……）<br>我做的肯定不是正解，利用二维码纠错能力勉强拿到了 flag，所以就不详细写 writeup 了，主要还是要看官方 wp（逃</p>
<p>大概步骤就是：</p>
<ol>
<li>读图片</li>
<li>把已知的像素提取出来</li>
<li>把四个小定位块填上</li>
<li>挨个马赛克块寻找使还原的数据平均数与原马赛克值差的绝对值小于1的填补方法<ul>
<li>如果只有一种就填上，并且标注已经填好，以后不再搜寻</li>
<li>如果有多种就先放下不填</li>
</ul>
</li>
<li>重复4的过程，这是还会有唯一确定的填补方案。重复4次大概就不剩唯一解了</li>
<li>这时重复4，找出仅有2中填补方法的，选误差最小的填上</li>
<li>然后再重复4</li>
<li>然后重复6</li>
<li>然后重复4 </li>
<li>这时可以看到已经还原得差不多了，剩下的不管直接扫码也可以扫出 flag 了 <div style="text-align: center;"><img src="/p/d11ec8ed/msc.jpg" width="35%" height="35%"></div></li>
</ol>
<p><del>看，做法很烂对吧</del></p>
<hr>
<h2 id="minecRaft"><a href="#minecRaft" class="headerlink" title="minecRaft"></a>minecRaft</h2><blockquote>
<p>kk 同学很喜欢玩 Minecraft，他最近收到了一张 MC 地图，地图里面有三盏灯，还有很多奇奇怪怪的压力板。</p>
<p>但他发现这些灯好像不太符合 MC 电磁学（Red stone），你能帮他把灯全部点亮吗？</p>
<p>注：本题解法与原版 Minecraft 游戏无关。</p>
<p>补充说明：flag 花括号内为让三盏灯全部点亮的最短的输入序列。例如，如果踩踏压力板输入的最短的序列为 abc，则答案为 flag{abc}。</p>
</blockquote>
<p>还挺好玩的题，在网页中模拟了一个mc出来<br>看源码看到了引入了 flag.js 文件，所以可能就是要通过它来得到答案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;jsm/miscs/flag.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以看到，最终判断是否正确是通过调用 <code>gyflagh(input)</code> 是否为 true 来判断，而 gyflagh 也在 flag.js 中，所以还是要看 flag.js </p>
<p>但是 flag.js 是经过简单混淆过的，还是要费点时间读一下</p>
<p>其中有四个转换 Str4 Base16 和 Long 的函数可以略掉不管<br>注意到了 <code>_0x381b()</code> 这个函数里有一个列表，而且比较简单，其实它返回的就是这个列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;encrypt&#x27;, &#x27;33MGcQht&#x27;, &#x27;6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c&#x27;, &#x27;14021KbbewD&#x27;, &#x27;charCodeAt&#x27;, &#x27;808heYYJt&#x27;, &#x27;5DlyrGX&#x27;, &#x27;552oZzIQH&#x27;, &#x27;fromCharCode&#x27;, &#x27;356IjESGA&#x27;, &#x27;784713mdLTBv&#x27;, &#x27;2529060PvKScd&#x27;, &#x27;805548mjjthm&#x27;, &#x27;844848vFCypf&#x27;, &#x27;4bIkkcJ&#x27;, &#x27;1356853149054377&#x27;, &#x27;length&#x27;, &#x27;slice&#x27;, &#x27;1720848ZSQDkr&#x27;]</span><br></pre></td></tr></table></figure>
<p>但是在 Console 里面调用 _0x381b 得到的却是以 ‘slice’ 开头、’length’ 结尾的列表，将这个列表记为 lst 方便表述<br>而且源码中只有最开头的调用匿名函数里面有 <code>[&#39;push&#39;]</code> 和 <code>[&#39;shift&#39;]</code>，所以推测这个匿名函数就是将这个列表循环右移两个位置<br>那这个匿名函数也不用看了</p>
<p>再来看 <code>_0x2c9e()</code> 这个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_0x2c9e</span>(<span class="params">_0x49e6ff, _0x310d40</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _0x381b4c = _0x381b();</span><br><span class="line">    <span class="keyword">return</span> _0x2c9e = <span class="function"><span class="keyword">function</span>(<span class="params">_0x2c9ec6, _0x2ec3bd</span>) </span>&#123;</span><br><span class="line">        _0x2c9ec6 = _0x2c9ec6 - <span class="number">0x1a6</span>;</span><br><span class="line">        <span class="keyword">let</span> _0x4769df = _0x381b4c[_0x2c9ec6];</span><br><span class="line">        <span class="keyword">return</span> _0x4769df;</span><br><span class="line">    &#125;</span><br><span class="line">    ,</span><br><span class="line">    _0x2c9e(_0x49e6ff, _0x310d40);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>_0x381b4c</code> 是刚刚说的那个列表 lst。然后 return 里面重新定义了 <code>_0x2c9e</code>，但是新的定义里第二个参数并没有用，然后调用返回，所以整个函数就相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_0x2c9e</span>(<span class="params">_0x2c9ec6, ...</span>) </span>&#123;</span><br><span class="line">    _0x2c9ec6 = _0x2c9ec6 - <span class="number">0x1a6</span>;</span><br><span class="line">    <span class="keyword">return</span> lst[_0x2c9ec6];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x1a6 是 422，所以整个函数也就相当于 function(x) { return lst[x - 422]; }<br>同时根据第一行，程序中所有 <code>_0x22517d</code> 也是这个函数</p>
<p>然后看判断答案的 <code>gyflagh</code> 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gyflagh</span>(<span class="params">_0x111955</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> _0x50051f = _0x22517d;</span><br><span class="line">    <span class="keyword">let</span> _0x3b790d = _0x111955[_0x50051f(<span class="number">0x1a8</span>)](_0x50051f(<span class="number">0x1b7</span>));</span><br><span class="line">    <span class="keyword">if</span> (_0x3b790d === _0x50051f(<span class="number">0x1aa</span>))</span><br><span class="line">        <span class="keyword">return</span> !![];</span><br><span class="line">    <span class="keyword">return</span> ![];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥特别的，结合 lst 可以得到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gyflagh</span>(<span class="params">ans</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ans[<span class="string">&quot;encrypt&quot;</span>](<span class="string">&quot;1356853149054377&quot;</span>) === <span class="string">&quot;6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以结合 lst 中的值和索引，翻译出最重要的函数<br>再进行一些运算，用注释标注一下已知的值就可以得到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>[<span class="string">&quot;prototype&quot;</span>][<span class="string">&quot;encrypt&quot;</span>] = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123; <span class="comment">// key = &quot;1356853149054377&quot;</span></span><br><span class="line">    <span class="keyword">const</span> left = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> right = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    ans = <span class="built_in">escape</span>(<span class="built_in">this</span>); <span class="comment">// this := ans</span></span><br><span class="line">    right = [<span class="number">909456177</span>, <span class="number">825439544</span>, <span class="number">892352820</span>, <span class="number">926364468</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ans[<span class="string">&quot;length&quot;</span>]; i = i + <span class="number">8</span>) &#123;</span><br><span class="line">      left[<span class="number">0</span>] = Str4ToLong(ans[<span class="string">&quot;slice&quot;</span>](i, i + <span class="number">4</span>));</span><br><span class="line">      left[<span class="number">1</span>] = Str4ToLong(ans[<span class="string">&quot;slice&quot;</span>](i + <span class="number">4</span>, i + <span class="number">8</span>));</span><br><span class="line">      code(left, right);</span><br><span class="line">      res = res + (LongToBase16(left[<span class="number">0</span>]) + LongToBase16(left[<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;  <span class="comment">// 6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再来看 <code>code</code> 函数，根据 &lt;&lt; 4、 ^、 &gt;&gt;&gt; 5 可以大胆推测类似 TEA，然后解码就直接翻过来就好了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2654435769</span> * <span class="number">32</span>; i != <span class="number">0</span>;) &#123;</span><br><span class="line">        left[<span class="number">1</span>] -= ((left[<span class="number">0</span>] &lt;&lt; <span class="number">4</span> ^ left[<span class="number">0</span>] &gt;&gt;&gt; <span class="number">5</span>) + left[<span class="number">0</span>] ^ i + right[i &gt;&gt;&gt; <span class="number">11</span> &amp; <span class="number">3</span>]);</span><br><span class="line">        i -= <span class="number">2654435769</span>;</span><br><span class="line">        left[<span class="number">0</span>] -= ((left[<span class="number">1</span>] &lt;&lt; <span class="number">4</span> ^ left[<span class="number">1</span>] &gt;&gt;&gt; <span class="number">5</span>) + left[<span class="number">1</span>] ^ i + right[i &amp; <span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后把要得到的 res 分块，每 8 个一组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6fbde674 819a59bf a1209256 5b4ca2a7 a11dc670 c678681d af4afb67 04b82f0c</span><br></pre></td></tr></table></figure>
<p>然后从后往前，每两个执行 Base16ToLong，然后作为 left 传给 dec 函数解码，然后再 LongToStr4 得到四个字符:<br><img src="/p/d11ec8ed/minecRaft.jpg"><br>拼起来就是 flag 了：<code>flag&#123;McWebRE_inMlnCrA1t_3a5y_1cIuop9i&#125;</code></p>
<hr>
<h2 id="密码生成器"><a href="#密码生成器" class="headerlink" title="密码生成器"></a>密码生成器</h2><blockquote>
<p>小 T 最近又写了一个 web 应用。</p>
<p>他发现很多用户都喜欢设置弱密码，于是决定让所有用户的密码都必须是 16 位长，并且各种符号都要有。为了让大家可以方便生成这样的密码，他还写了一个密码生成器，让用户可以生成符合规则的密码。</p>
<p>但这样果真安全吗？</p>
</blockquote>
<p>（感觉这次 Hackergame 题的 tag 都很诡异。这题明明是 misc(general) 为什么打了 binary 的 tag）</p>
<p>看到 binary tag 直接先往 IDA 里面丢，然后报错了，大概是因为部分 winapi 导入不进去的问题（？）<br>然后就不会了…… 对着 IDA 干瞪眼</p>
<p>看题，题目给了一个网站，用来发布展板，看起来只有 admin 用户，而且没有注册系统，所以应该就是要搞到 admin 的密码了<br>再细看网站，特意提到 “网页显示<strong>时间</strong>”，而且展板后面都有发布时间，点进 admin 的用户页面发现也有注册时间，着实有些许诡异（<br>所以时间应该是一个提示</p>
<p>而写代码的时候设置随机数种子又常以当前时间作为种子，所以生成的密码可能是和时间有关系的<br>通过调系统时间，可以发现在同一秒点下生成，产生的密码是一样的<br>所以只需要把系统时间调到 admin 的注册时间左右，然后每秒生成密码，再挨个输进去爆破即可</p>
<p>最后得到 2021-09-22 23:10:53 时生成的密码 <code>$Z=CBDL7TjHu~mEX</code> 就是 admin 的密码<br>然后登录即可在“我的”里看到一条私密展板，内容是 flag</p>
<p>（其实这题搞得闹心的是每秒生成密码，像我这样的原始人只会反复调时间然后手动生成、复制粘贴，然后再复制粘贴检验密码）<br>（而且其实这个时间也试了很长时间，试了 23:11 的所有秒，15:11 的所有秒（考虑到了提到的时区问题））<br>（然后一共 120s 里也没有正确密码，就很闹心，最后的时间是 23:11 的前一分钟里的……我当时甚至想了，这些操作在一分钟之内都能完成，然后就没考虑前一分钟生成密码、后一分钟注册的问题……）<br>（于是就有了：</p>
<div style="text-align: center;"><img src="/p/d11ec8ed/generator.png" width="15%" height="15%"></div>

<hr>
<p>好了，我做上的题也就这些了，勉勉强强混了 4k2pt<br>没做上的题也好多：Amnesia2、赛博厨房23、灯、只读、一石二鸟、GPA、链上预言家、助记词2、Co-Program、外星人、befun、fzuu、wish、OI逆向<br>（草，好多qwq）<br>剩下的就看官方 Writeup 了（</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>RAID 相关的好多文章，没留作记录</li>
</ul>
]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hackergame 2021」#3 Writup 持续破防篇 0</title>
    <url>/p/f152ab1f.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/f54b44c.html">&lt; #2</a></p>
<p><a href="/p/d11ec8ed.html">#4 &gt;</a></p>
</div>

<p>完成了前面两篇说到的那些题后，剩下的就开始反复折磨我了qwq<br>每天基本都肝到一点左右，甚至四五个小时毫无成果_(´ཀ`」 ∠)__<br>其中有些题回过头来看其实很简单，但是做的时候就是死活想不出来（</p>
<p>这篇 Writeup 里面有：Amnesia1、RSA、LUKS、MicroWorld</p>
<span id="more"></span>

<hr>
<h2 id="Amnesia"><a href="#Amnesia" class="headerlink" title="Amnesia"></a>Amnesia</h2><h3 id="轻度失忆"><a href="#轻度失忆" class="headerlink" title="轻度失忆"></a>轻度失忆</h3><blockquote>
<p>你的程序只需要输出字符串 Hello, world!（结尾有无换行均可）并正常结束。</p>
<p>编译指令：<code>gcc -O file.c -m32</code></p>
<p>运行指令：<code>./a.out</code></p>
<p>编译后 ELF 文件的 .data 和 .rodata 段会被清零。</p>
</blockquote>
<p>ELF（Executable and Linkable Format）是 Linux 下常用的可执行文件格式，其中有很多不同的节：</p>
<ul>
<li><code>.text</code> 节：程序运行需要的代码</li>
<li><code>.data</code> 节：存放可修改的数据，一般是非 const 全局变量和静态变量</li>
<li><code>.rodata</code> 节：即 read only data，一般是常量或者字符串</li>
<li><code>.bss</code> 节：没有被初始化的变量</li>
<li>……</li>
</ul>
<p>而这道题目则是在编译生成可执行文件 a.out 后，清空 .data 和 .rodata<br>首先不妨正常编写一个输出 “Hello, world!” 的程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>然后编译，再拖到 IDA 里<br><img src="/p/f152ab1f/amn1.png"><br>可以发现，此时的 “Hello, world!” 被放到了 .rodata 节中，会被清除掉，所以这样写不行</p>
<p>直接使用字符串会被放到 .rodata 中清除，写成全局变量又会放到 .data 中<br>但是，如果写成局部变量呢：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br></pre></td></tr></table></figure>
<p>编译，拖到 IDA 里<br><img src="/p/f152ab1f/amn2.png"><br>可以看出，这次的字符串直接写到了 .text 节中，删掉了 .data .rodata 也没有影响<br>所以把这个代码交上去就可以输出 “Hello, world!“ 拿到 flag 了 </p>
<p>清除记忆直接把 .text 节全删掉了，想了很久也不知道咋搞，虽然可以 __attribute__ ((section (“…”))) 来把函数或变量塞到指定的节中。但还是不清楚要怎么解决段错误的问题qwq </p>
<hr>
<h2 id="Easy-RSA"><a href="#Easy-RSA" class="headerlink" title="Easy RSA"></a>Easy RSA</h2><blockquote>
<p>自从 Hackergame 2018 公然揭露了大整数可以被神童口算分解的事实，RSA 在 hackergame 中已经只能处于低分值的地位了。如果不在其名称前面加上 Easy 这个单词，似乎就会显得完全对不起其他题目。</p>
<p>更何况，在本题的附件中，你还获得了构造 p 和 q 的方式。数理基础扎实的你应该可以轻松解决这些问题吧。</p>
</blockquote>
<p><del>谢邀，没有数理基础</del></p>
<p>看代码！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">65537</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_p</span>():</span></span><br><span class="line">    x = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span></span><br><span class="line">    y = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span></span><br><span class="line">    value_p = sympy.nextprime((math.factorial(y)) % x)  <span class="comment"># Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征</span></span><br><span class="line">    <span class="keyword">return</span> value_p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_q</span>():</span></span><br><span class="line">    value = [getPrime(<span class="number">256</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        value.append(sympy.nextprime(value[i - <span class="number">1</span>]))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;value[-1] = &quot;</span>, value[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        n = n * value[i]</span><br><span class="line">    q = getPrime(<span class="number">512</span>)</span><br><span class="line">    value_q = <span class="built_in">pow</span>(q, e, n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;value_q = &quot;</span>, value_q)</span><br><span class="line">    <span class="comment"># value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819</span></span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(q)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this destroyes the rsa cryptosystem</span></span><br><span class="line">p = get_p()</span><br><span class="line">q = get_q()</span><br><span class="line"></span><br><span class="line">m = <span class="built_in">int</span>.from_bytes(<span class="built_in">open</span>(<span class="string">&quot;flag.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>).read(), <span class="string">&quot;big&quot;</span>)</span><br><span class="line">c = <span class="built_in">pow</span>(m, e, p * q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c = &quot;</span>, c)</span><br><span class="line"><span class="comment"># c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478</span></span><br></pre></td></tr></table></figure>
<p>可以看到，其中要解决的就是 <code>get_p()</code> 中 y! % x 溢出的问题，以及 <code>get_q()</code> 中 q 是哪个随机的512位质数的问题</p>
<h3 id="get-p"><a href="#get-p" class="headerlink" title="get_p"></a>get_p</h3><p>代码里也给了 Hint，观察 x 和 y 的特征。x 和 y 都很大，但是两个的差并不大；而且可以丢到 python 里验证出 x 是一个质数<br>所以可以使用<a href="https://en.wikipedia.org/wiki/Wilson's_theorem"><strong>威尔逊定理</strong></a><br>也查到了威尔逊定理在 RSA 题目中的应用：<a href="https://blog.csdn.net/xiao_han_a/article/details/118974504">BUU-RSA [RoarCTF2019]babyRSA</a></p>
<p>要求 y! % x（x是质数）<br>根据威尔逊定理，有</p>
<p>$$<br>(x - 1)! \equiv -1\pmod{x}<br>$$</p>
<p>所以：</p>
<p>$$<br>y!\times \frac{(x - 1)!}{y!}\equiv -1\pmod{x}<br>$$</p>
<p>令 $k = \dfrac{(x - 1)!}{y!} = (y+1)(y+2)…(x-1)x$ ，所以有：</p>
<p>$$<br>y!\equiv -\mathrm{inv}(k, x)\pmod{x}<br>$$</p>
<p>（其中 $\mathrm{inv}(k, x)$ 表示模 x 下 k 的逆元）<br>所以重写 get_p() 即可正确的得到 p：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_p</span>():</span></span><br><span class="line">    x = ...</span><br><span class="line">    y = ...</span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(y + <span class="number">1</span>, x):</span><br><span class="line">        k = (k * i) % x </span><br><span class="line">    res = (-gmpy2.invert(k, x)) % x </span><br><span class="line">    <span class="keyword">return</span> sympy.nextprime(res)</span><br></pre></td></tr></table></figure>

<h3 id="get-q"><a href="#get-q" class="headerlink" title="get_q"></a>get_q</h3><p>相比来说，get_q 就没那么需要技巧了<br>给出了 value[-1] 的值，所以可以直接用 <code>sympy.prevprime</code> 逆推出整个 value 数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = [<span class="number">80096058210213458444437404275177554701604739094679033012396452382975889905967</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    value.append(sympy.prevprime(value[i - <span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;value[-1] = &quot;</span>, value[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>后面计算 value_q 细看其实也是一个 RSA 算法：</p>
<ul>
<li>q：密文</li>
<li>e：私钥</li>
<li>value_q：明文</li>
<li>n：就是 n，只不过不是两个质数相乘，是十个质数相乘 </li>
</ul>
<p>十个质数相乘得到 n 的 RSA 算法也一样，因为 RSA 的正确性并没有要求 n 一定是两个大质数相乘，这样只是难以破解保证安全性<br>解决这个同样也是需要公钥 d，所以需要 phi(n)<br>根据<a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">欧拉函数</a>的性质，phi(n) 等于 n 的所有质因数减一的积<br>即 phi(n) = (value[0] - 1) * (value[1] - 1) * … * (value[9] - 1)</p>
<p>再解密即可得到密文 q，然后也就得到了 get_q 的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = phi = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    n = n * value[i]</span><br><span class="line">    phi *= (value[i] - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">value_q = ...</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, phi) </span><br><span class="line">q = <span class="built_in">pow</span>(value_q, d, n)</span><br><span class="line"><span class="keyword">return</span> sympy.nextprime(q)</span><br></pre></td></tr></table></figure>

<h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><p>搞定了 get_p 和 get_q 之后就可以直接解出 flag 了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = <span class="number">65537</span></span><br><span class="line">p = get_p()</span><br><span class="line">q = get_q()</span><br><span class="line"></span><br><span class="line">c = ...</span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, (p-<span class="number">1</span>) * (q-<span class="number">1</span>))</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, p * q)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>.to_bytes(m, <span class="number">30</span>, byteorder=<span class="string">&quot;big&quot;</span>))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="加密的-U-盘"><a href="#加密的-U-盘" class="headerlink" title="加密的 U 盘"></a>加密的 U 盘</h2><p>（本来挺好做的一道题，怎么题给的提示我就硬是没领会到）</p>
<blockquote>
<p>这是一个关于 LUKS (Linux Unified Key Setup) 的故事。</p>
<p>第一天<br>小 T：「你要的随机过程的课件我帮你拷好了，在这个 U 盘里，LUKS 加密的密码是 suijiguocheng123123。」<br>小 Z：「啊，你又搞了 Linux 文件系统加密，真拿你没办法。我现在不方便用 Linux，我直接把这块盘做成磁盘镜像文件再回去处理吧。」</p>
<p>第二天<br>小 Z：「谢谢你昨天帮我拷的课件。你每次都搞这个加密，它真的安全吗？」<br>小 T：「当然了！你看，你还给我之后，我已经把这块盘的弱密码改掉了，现在是随机生成的强密码，这样除了我自己，世界上任何人都无法解密它了。」<br>小 Z：「我可不信。」<br>小 T：「你不信？你看，我现在往 U 盘里放一个 flag 文件，然后这个 U 盘就给你了，你绝对解密不出来这个文件的内容。当初搞 LUKS 的时候我可研究了好几天，班上可没人比我更懂加密！」</p>
</blockquote>
<p>一共给了两个 img 文件，通过 file 可以看出都是 DOS/MBR boot sector</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ file *.img </span><br><span class="line">day1.img:      DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 40959 sectors, extended partition table (last)</span><br><span class="line">day2.img:      DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 40959 sectors, extended partition table (last)</span><br></pre></td></tr></table></figure>
<p>所以先直接 7z 提取，得到两个新的 img，再 file：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ file *.img </span><br><span class="line">My Disk.img:   LUKS encrypted file, ver 2 [, , sha256] UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998</span><br><span class="line">My Disk 2.img: LUKS encrypted file, ver 2 [, , sha256] UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998</span><br></pre></td></tr></table></figure>
<p>发现都是 LUKS encrypted file</p>
<p>在 Kali Linux 里尝试直接挂载第一个 img，要求输入密码，把题给的密码输入就可以看到 “课件”</p>
<p>以上都是已知的试验部分，真正要做的是解开第二个未知密码的 LUKS img<br>已知磁盘的加密使用的是 luks2，在网上查了破解 luks2 之类的都说 luks2 <strong>不可破解</strong>，或者是使用已知的密码字典来爆破<br>但是题里说了 “<strong>随机生成</strong>的强密码”，所以也是没有密码字典的</p>
<p>其实这道题的最大提示就在于它给了两个 img，既然第一个 img 打开后仅仅是一个课件，如果它的用处仅仅是用来试验 luks 怎么打开的话，根本它没必要给出<br>所以第一个 img 肯定还是有用的。</p>
<p>再看题目，反复说了 U 盘，所以这两个 img 应该是同一个 U 盘的镜像文件，只是更改了密码而已（file 看到的 uuid 也是一致的）<br>于是继续必应，发现同一个磁盘的 <code>master-key</code> 是一样的，而且可以用 master-key 来添加密码恢复磁盘（见：<a href="https://www.thegeekstuff.com/2016/03/cryptsetup-lukskey/">10 Linux cryptsetup Examples for LUKS Key Management</a>）</p>
<p>所以就跟着文章里的做法，从第一个 img 中提取出 master-key，然后用它来提供 AddKey 的权限。添加了新 passphrase 后就可以用新密码打开磁盘了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cryptsetup luksDump --dump-master-key MyDisk.img  <span class="comment"># 输出 master-key</span></span><br><span class="line">...</span><br><span class="line">MK dump:    be 97 db 91 5c 30 47 ce 1c 59 c5 c0 8c 75 3c 40 </span><br><span class="line">            72 35 85 9d fe 49 c0 52 c4 f5 26 60 af 3e d4 2c </span><br><span class="line">            ec a3 60 53 aa 96 70 4d f3 f2 ff 56 8f 49 a1 82 </span><br><span class="line">            60 18 7c 58 d7 6a ec e8 00 c1 90 c1 88 43 f8 9a</span><br><span class="line">$ cat <span class="string">&quot;be...9a&quot;</span> &gt; master_key.txt <span class="comment"># 存入文件</span></span><br><span class="line">$ xxd -r -p master_key.txt master_key.bin <span class="comment"># 转为二进制</span></span><br><span class="line">$ cryptsetup luksAddKey MyDisk2.img --master-key-file &lt;(cat master_key.bin) <span class="comment"># 添加密码</span></span><br><span class="line">Enter new passphrase <span class="keyword">for</span> key slot:    <span class="comment"># 输入新密码即可，因为master-key-file相当于提供了原始密码</span></span><br><span class="line">Verify passphrase: </span><br></pre></td></tr></table></figure>
<p>（一定要用 root 权限才可以加密码）<br>然后挂载、输入密码，就可以看到 flag.txt 了</p>
<hr>
<h2 id="Micro-World"><a href="#Micro-World" class="headerlink" title="Micro World"></a>Micro World</h2><blockquote>
<p>宇宙中某一片极其微小的区域里的粒子被一股神秘力量初始化设置成了 flag 的形状，程序忠实地记录了一段时间之后这片区域的粒子运动情况。</p>
</blockquote>
<p>拿到了 exe 文件，看起来挺精致，运行起来是一些点运动碰撞的场景<br>拖到 IDA 里看看，发现了 __main__ 以及 .rdata 里一些 py 有关的字符串：<br><img src="/p/f152ab1f/microworld.png"><br>所以推测是使用 python 编写的，然后用 pyinstaller 打包</p>
<p>这样的话试着用 <a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor</a> 解包 .exe，成功得到一个文件夹<br>里面是一堆 .pyc .pyd .dll 文件，从名字就可以看出大部分是 import 的包，只有一个特别的 2.pyc<br>所以这个应该就是编译后的源码了</p>
<p>接下来用 <a href="https://github.com/rocky/python-uncompyle6/">uncompyle6</a> 来反编译 pyc 文件，输出得到了源码 2.py<br>尝试运行，发现跑起来之后只有一个点在运动，应该是反编译时出了些问题<br>于是开始看源码 </p>
<p>基本上简单说就是，初始有一些数据，表示每个点的位置和速度，然后运行，每次运行都检测碰撞，然后获得新的点位置，再绘制出来<br>调试一下，输出每次的 pointlist，发现第一次是所有点，第二次变成2个，第三次往后就只有一个了<br>所以问题大概就出在了 next_pos_list 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_pos_list</span>(<span class="params">Pointlist</span>):</span></span><br><span class="line">    pointlist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Pointlist)):</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> Pointlist[i + <span class="number">1</span>:]:</span><br><span class="line">            times = checkcrush(Pointlist[i], point)</span><br><span class="line">            <span class="keyword">if</span> times != <span class="literal">None</span>:</span><br><span class="line">                a, b = get_new_point(times, Pointlist[i], point)</span><br><span class="line">                pointlist.extend([a, b])</span><br><span class="line">                Pointlist[i].flag = <span class="number">0</span></span><br><span class="line">                point.flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> Pointlist:</span><br><span class="line">                <span class="keyword">if</span> item.flag != <span class="number">0</span>:</span><br><span class="line">                    pointlist.append(Point((item.x + item.vx, item.y + item.vy), item.vx, item.vy))</span><br><span class="line">                <span class="keyword">for</span> poi <span class="keyword">in</span> pointlist:</span><br><span class="line">                    poi.x = poi.x % WIDTH</span><br><span class="line">                    poi.y = poi.y % HEIGHT</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> pointlist</span><br></pre></td></tr></table></figure>
<p>仔细读一读，可以发现这里面的 for-else 块很奇怪，导致循环结束和 return 都早了，所以根据函数的意思改一改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_pos_list</span>(<span class="params">Pointlist</span>):</span></span><br><span class="line">    pointlist = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Pointlist)):</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> Pointlist[i + <span class="number">1</span>:]:</span><br><span class="line">            ...</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> Pointlist:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">return</span> pointlist</span><br></pre></td></tr></table></figure>
<p>这样就可以成功运行了</p>
<p>但是画面仍然是杂乱的。因为题里说了 “记录了<strong>一段时间之后</strong>这片区域的粒子运动情况”<br>所以需要将轨迹往前推，最方便的方法就是更改每个点的速度方向：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Pointlist = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> list_:</span><br><span class="line">    Pointlist.append(Point((item[<span class="number">0</span>], item[<span class="number">1</span>]), -item[<span class="number">2</span>], -item[<span class="number">3</span>]))</span><br></pre></td></tr></table></figure>
<p>运行后等待一小会儿就可以看到点逐渐有序，在某一刻汇成了 flag：<br><img src="/p/f152ab1f/mwans.jpg"><br>虽然不太清晰，但是也可以猜个大概</p>
<hr>
<p>又写了蛮长的，剩下的放在<a href="/p/d11ec8ed.html">下一篇</a><em>(:з」∠)</em></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Wilson's_theorem">Wilson’s theorem - wikipedia</a></li>
<li><a href="https://blog.csdn.net/xiao_han_a/article/details/118974504">BUU-RSA [RoarCTF2019]babyRSA - CSDN</a></li>
<li><a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler’s totient function - wikipedia</a></li>
<li><a href="https://gitlab.com/cryptsetup/LUKS2-docs/blob/master/luks2_doc_wip.pdf">LUKS2 doc pdf</a></li>
<li><a href="https://www.thegeekstuff.com/2016/03/cryptsetup-lukskey/">10 Linux cryptsetup Examples for LUKS Key Management</a></li>
<li><a href="https://github.com/extremecoders-re/pyinstxtractor">pyinstxtractor</a></li>
<li><a href="https://github.com/rocky/python-uncompyle6/">uncompyle6</a></li>
</ul>
<div style="display: flex; justify-content: space-between;">

<p><a href="/p/f54b44c.html">&lt; #2</a></p>
<p><a href="/p/d11ec8ed.html">#4 &gt;</a></p>
</div>]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hackergame 2021」#2 Writup 开局上分篇 1</title>
    <url>/p/f54b44c.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/fd872e78.html">&lt; #1</a></p>
<p><a href="/p/f152ab1f.html">#3 &gt;</a></p>
</div>

<p>这里接<a href="/p/fd872e78.html">上一篇</a>，Writeup 的有：大砍刀、图之上、赛博厨房01、助记词1、p😭q<br>有些虽然偏后、分值高，但是总体并不难</p>
<span id="more"></span>
<hr>
<h2 id="FLAG-助力大红包"><a href="#FLAG-助力大红包" class="headerlink" title="FLAG 助力大红包"></a>FLAG 助力大红包</h2><blockquote>
<p>参与活动，助力抽奖！集满 1 个 flag，即可提取 1 个 flag。</p>
<p>恭喜你积攒到 0.5…… 个 flag，<br>剩余时间：10分00秒</p>
<p>已有 0 位好友为您助力。</p>
<p>将如下链接分享给好友，可以获得好友助力，获得更多 flag：……</p>
</blockquote>
<p><del>老并夕夕了</del>，经过一些测试和看规则可以知道，ip 在同一 /8 网段的用户被视为同一用户，即 ip 地址的第一个点前面的数字不一样才是不同用户<br>再用虚拟机和手机试一下，发现每个用户增加的 flag 数量很小<br>所以推测需要200+个 ip 地址，肯定不会要真的转发，而且也很难凑出很多不在同一 /8 网段的 ip</p>
<p>于是在 BurpSuite 里面抓包可以看到，每次点击“助力”都会发送一个到助力链接的 POST，内容为 ip 地址<br><img src="/p/f54b44c/burp.png"><br>然后将其发送到 Repeater 中，尝试更改 ip 地址，得到的 Response 中说 “失败！检测到前后端检测 IPv4 地址不匹配”</p>
<p>所以仅仅更改 POST 内容的 ip 是不够的，而提供给检测的内容也仅仅是一个 POST，所以可以更改 POST 头，添加 <strong>X-Forwarded-For</strong><br>然后使用 python 就可以循环发送 POST 并伪造 ip 地址得到256个助力了，刚好达到1个flag：<br>（要注意 sleep 一段时间，不然会出现操作过快拒绝的情况；也不要 sleep 过长，否则超过10分钟 flag 就无效了）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://202.38.93.111:10888/invite/...&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tqdm(total=<span class="number">256</span>) <span class="keyword">as</span> pbar:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        res = requests.post(url, data=&#123;<span class="string">&quot;ip&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>.0.0.0&quot;</span>&#125;, headers=&#123;<span class="string">&quot;X-Forwarded-For&quot;</span>: <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>.0.0.0&quot;</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;成功&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[x] 失败&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(res.text)</span><br><span class="line">        time.sleep(<span class="number">1.5</span>)</span><br><span class="line">        pbar.update(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="图之上的信息"><a href="#图之上的信息" class="headerlink" title="图之上的信息"></a>图之上的信息</h2><blockquote>
<p>小 T 听说 GraphQL 是一种特别的 API 设计模式，也是 RESTful API 的有力竞争者，所以他写了个小网站来实验这项技术。</p>
<p>你能通过这个全新的接口，获取到没有公开出来的管理员的邮箱地址吗？</p>
</blockquote>
<p>题目信息给的很充分，用的是 GraphQL，要用其得到 admin 的邮箱</p>
<p>没接触过 GraphQL，所以直接必应（逃<br>查到了很多有用的东西：</p>
<ul>
<li><a href="https://graphql.cn/">GraphQL官网</a>：了解一下 GraphQL 是干什么的，要怎么用</li>
<li><a href="https://www.electronjs.org/apps/graphiql">GraphiQL</a>：一个进行 GraphQL 查询的 GUI</li>
<li><a href="https://zhuanlan.zhihu.com/p/390876937">【安全记录】玩转GraphQL - DVGA靶场（上）- 知乎</a></li>
<li><a href="https://apis.guru/graphql-voyager/">GraphQL Voyager</a>：可视化现实 GraphQL 内省出的结构</li>
</ul>
<p>简而言之，GraphQL 就是一个可以通过一次 query 请求查询多个资源的 API 模式，只要 <code>网址/graphql?query=...</code> 就可以实现查询<br>有些使用 GraphQL 的网站可以直接通过访问 <code>网址/graphiql</code> 得到查询的 GUI<br>但是本题中禁止了，但可以使用 GraphiQL 软件来进行查询</p>
<p>在第三个链接中可以了解到，可以利用 GraphQL 的内省查询来泄露出内部的结构，把其中的查询语句丢到 GraphiQL 中可以得到结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">query IntrospectionQuery &#123; __schema &#123; queryType &#123; name &#125; mutationType &#123; name &#125; subscriptionType &#123; name &#125; types &#123; ...FullType &#125; directives &#123; name description locations args &#123; ...InputValue &#125; &#125; &#125;&#125;fragment FullType on __Type &#123; kind name description fields(includeDeprecated: true) &#123; name description args &#123; ...InputValue &#125; type &#123; ...TypeRef &#125; isDeprecated deprecationReason &#125; inputFields &#123; ...InputValue &#125; interfaces &#123; ...TypeRef &#125; enumValues(includeDeprecated: true) &#123; name description isDeprecated deprecationReason &#125; possibleTypes &#123; ...TypeRef &#125;&#125;fragment InputValue on __InputValue &#123; name description type &#123; ...TypeRef &#125; defaultValue&#125;fragment TypeRef on __Type &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name ofType &#123; kind name &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/p/f54b44c/graphiql.png"></p>
<p>然后把结果丢到 GraphQL Voyager 中就可以得到可视化的结构：<br><img src="/p/f54b44c/graphql.png"></p>
<p>所以只需要根据 id query 一下 user 就可以了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">query &#123; user(<span class="built_in">id</span>: <span class="number">1</span>) &#123; privateEmail, &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;privateEmail&quot;</span>: <span class="string">&quot;flag&#123;...&#125;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="赛博厨房"><a href="#赛博厨房" class="headerlink" title="赛博厨房"></a>赛博厨房</h2><blockquote>
<p>虽然这是你的餐厅，但只有机器人可以在厨房工作。机器人精确地按照程序工作，在厨房中移动，从物品源取出食材，按照菜谱的顺序把食材依次放入锅内。</p>
<p>机器人不需要休息，只需要一个晚上的时间来学习你教给它的程序，在此之后你就可以在任何时候让机器人执行这个程序，程序的每一步执行都会被记录下来，方便你检查机器人做菜的过程。</p>
<p>另外为了符合食品安全法的要求，赛博厨房中的机器人同一时间手里只能拿一种食物，每次做菜前都必须执行清理厨房的操作，把各处的食物残渣清理掉，然后回到厨房角落待命。</p>
<p>每天的菜谱可能不同，但也许也存在一些规律。</p>
<p>对机器人编程可以使用的指令有（n, m 为整数参数，程序的行号从 0 开始，注意指令中需要正确使用空格）：</p>
<blockquote>
<p>向上 n 步<br>向下 n 步<br>向左 n 步<br>向右 n 步<br>放下 n 个物品<br>拿起 n 个物品<br>放下盘子<br>拿起盘子<br>如果手上的物品大于等于 n 向上跳转 m 行<br>如果手上的物品大于等于 n 向下跳转 m 行</p>
</blockquote>
<p>赶紧进入赛博厨房开始做菜吧！</p>
</blockquote>
<p>刚看题还是挺懵的，想了好半天才明白<br>简单说来就是，每天可以编写新的程序，但是只能运行一个之前编写过的程序<br>每个程序只有几种指令可以使用，需要在其中满足菜谱的顺序要求</p>
<p>而问题在于，编写程序后的第二天的菜谱可能会不同，导致前面编写的程序无法使用<br>所以就需要<em>预测</em>第二天的菜谱</p>
<h3 id="Level-0"><a href="#Level-0" class="headerlink" title="Level 0"></a>Level 0</h3><p>可以看到第 0 天的菜谱是 1, 0，也就是要在同一个程序中依次向锅(1,0)中放入 1 号食物(0,2)和 0 号食物(0,1)<br>随便编写程序保存，直接到下一天，可以发现菜谱发生了变化<br>多次尝试之后发现菜谱<strong>只有 0,0 / 0,1 / 1,0 / 1,1 四种</strong></p>
<p>所以在第 0 天编写学习四个程序，到下一天就可以根据菜谱来执行了<br>例如程序 1,0 就可以编写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">向右 2 步</span><br><span class="line">拿起 1 个物品</span><br><span class="line">向左 2 步</span><br><span class="line">向下 1 步</span><br><span class="line">放下 1 个物品</span><br><span class="line">向上 1 步</span><br><span class="line">向右 1 步</span><br><span class="line">拿起 1 个物品</span><br><span class="line">向左 1 步</span><br><span class="line">向下 1 步</span><br><span class="line">放下 1 个物品</span><br><span class="line">向上 1 步</span><br></pre></td></tr></table></figure>
<p>只要正确了一天，就可以拿到 flag 了</p>
<h3 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h3><p>只有 1 个食物，菜谱是好多 0<br>同样随便编写程序保存进入下一天，发现菜谱<strong>没有变化</strong>，还是 73 个 0<br>所以这一关可能只是循环的教程<br>可用的指令中有一条 “如果手上的物品大于等于 n 向上跳转 m 行”<br>可以用它来达到<strong>循环</strong>的效果</p>
<p>只需要拿 73 个物品，然后循环放下直到手中没有了即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">向右 1 步</span><br><span class="line">拿起 73 个物品</span><br><span class="line">向左 1 步</span><br><span class="line">向下 1 步</span><br><span class="line">放下 1 个物品</span><br><span class="line">如果手上的物品大于等于 1 向上跳转 1 行</span><br></pre></td></tr></table></figure>
<p>同样保存下一天执行就可以拿到 flag 了 </p>
<p><del>剩下的两个看起来大概是通过源码来推测出菜谱的生成方法，然后编写相应的指令，太难了，不会qwq</del></p>
<hr>
<h2 id="助记词"><a href="#助记词" class="headerlink" title="助记词"></a>助记词</h2><p>题目有效内容：</p>
<blockquote>
<p>你的室友终于连夜赶完了他的 Java 语言程序设计的课程大作业。看起来他使用 Java 17 写了一个保存助记词的后端，当然还有配套的前端。助记词由四个英文单词组成，每个用户最多保存 32 条。</p>
<p>你从他充满激情却又夹杂不清的表述中得知，他似乎还为此专门在大作业里藏了两个 flag：当访问延迟达到两个特殊的阈值时，flag 便会打印出来，届时你便可以拿着 flag 让你的室友请你吃一顿大餐。</p>
</blockquote>
<p>下载到源码后翻一翻，有用的就只有 Phrase.java 和 Instance.java<br>其中 Phrase.java 定义了 Phrase，其中重载了 <code>equals</code> 方法，其中有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TimeUnit.MILLISECONDS.sleep(EQUALS_DURATION_MILLIS); <span class="comment">// 20ms</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> remove it since it is for debugging</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在每次比较相等的时候就会 sleep 20ms </p>
<p>而 Instance.java 的 post 方法中对于每次的输入，遍历输入的列表，然后逐个加进 HashMap 中<br>在加入 HashMap 的时候就涉及到判断是否相等<br>而最终会判断在完成前后的总的时间间隔是多少，如果大于 600ms 就提取出第一个 flag：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> modified = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> before = System.nanoTime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; input.length() &amp;&amp; i &lt; MAX_PHRASES &amp;&amp; phrases.size() &lt; MAX_PHRASES; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> text = input.optString(i, <span class="string">&quot;&quot;</span>).toLowerCase(Locale.ENGLISH);</span><br><span class="line">    modified += phrases.add(Phrase.create(<span class="keyword">this</span>.mnemonics, text, token)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里会 sleep</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> after = System.nanoTime();</span><br><span class="line"><span class="keyword">var</span> duration = TimeUnit.MILLISECONDS.convert(after - before, TimeUnit.NANOSECONDS);</span><br><span class="line"><span class="keyword">if</span> (duration &gt; FLAG1_DURATION_MILLIS) &#123; <span class="comment">// 600ms</span></span><br><span class="line">    token.addFlag(<span class="number">1</span>, flag -&gt; output.put(<span class="string">&quot;flag1&quot;</span>, flag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在网页中添加条目的时候，一次只能添加一条，也就是一个 POST 里面只有一个 Phrase<br>但是源码中有一个循环，遍历整个 input，所以一个 POST 里的内容其实是一个列表<br>所以可以用 BurpSuite 获取 POST 然后更改一下内容再发送出去（先 random 一个，然后 add）<br><img src="/p/f54b44c/mnemonic.png"><br>根据 flag 里的提示，正解（第二顿大餐）应该是使用哈希碰撞，<del>但是不会</del></p>
<hr>
<h2 id="p😭q"><a href="#p😭q" class="headerlink" title="p😭q"></a>p😭q</h2><blockquote>
<p>学会傅里叶的一瞬间，悔恨的泪水流了下来。</p>
<p>当我看到音频播放器中跳动的频谱动画，月明星稀的夜晚，深邃的银河，只有天使在浅吟低唱，复杂的情感于我眼中溢出，像是沉入了雾里朦胧的海一样的温柔。</p>
<p>这一刻我才知道，耳机音响也就图一乐，真听音乐还得靠眼睛。</p>
<p>（注意：flag 花括号内是一个 12 位整数，由 0-9 数位组成，没有其它字符。）</p>
</blockquote>
<p>虽然这题是在倒数第三题，还值 400pt，<del>但你一说傅里叶我可就不困了嗷</del></p>
<p>下载题目包，有一个生成 gif 的 py 代码和那个 gif 文件<br>正好前面的电波也有一段音频，可以用那个带入到 generate_sound_visualization.py 中生成一个 gif，然后用这个来测试</p>
<p>再仔细看一看 generate_sound_visualization.py 这个文件<br>主要使用了 <code>librosa</code>，于是就可以翻<a href="https://librosa.org/doc/latest/index.html">文档</a>来看懂这个程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y, sample_rate = librosa.load(<span class="string">&quot;flag.mp3&quot;</span>) <span class="comment"># 从mp3中读取数据和采样率</span></span><br><span class="line"></span><br><span class="line">spectrogram = numpy.around( <span class="comment"># 四舍五入，但会造成逆向的时候有少许误差导致杂音</span></span><br><span class="line">    librosa.power_to_db( <span class="comment"># 把以功率为单位的频谱图转换为以分贝为单位</span></span><br><span class="line">        librosa.feature.melspectrogram( <span class="comment"># 通过音频数据和采样率计算梅尔频谱</span></span><br><span class="line">            y, sample_rate, n_mels=num_freqs,</span><br><span class="line">            n_fft=fft_window_size, </span><br><span class="line">            hop_length=frame_step_size, </span><br><span class="line">            window=window_function_type</span><br><span class="line">        )</span><br><span class="line">    ) / quantize <span class="comment"># 除以2</span></span><br><span class="line">) * quantize <span class="comment"># 乘以2</span></span><br></pre></td></tr></table></figure>

<p>然后又通过一些 <code>numpy</code> 的骚操作来生成每一帧的数据，然后通过 <code>array2gif</code> 包的 write_gif 函数来生成 gif </p>
<p>所以主要思路就是把整个程序<strong>完整地逆过来</strong></p>
<p>由于必应没有查到 <code>gif2array</code> 的包，所以读取 gif 就用了经典 <code>PIL.Image</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">file = Image.<span class="built_in">open</span>(<span class="string">&quot;flag.gif&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        gif_data.append(np.array(file))</span><br><span class="line">        file.seek(file.tell() + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[+] Read gif file&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后是解决那一大段 numpy 骚操作的逆骚操作（<br>但是数理基础这么差的我当然是不想仔细研究了，所以直接用电波那题的 radio.mp3 带入，看一看要得到的 spectrogram 是什么样子<br>输出得到的 spectrogram 是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[-<span class="number">58.</span> -<span class="number">48.</span> -<span class="number">30.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">44.</span> -<span class="number">26.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">40.</span> -<span class="number">16.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> ...</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">42.</span> -<span class="number">30.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">44.</span> -<span class="number">32.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">46.</span> -<span class="number">34.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]]</span><br></pre></td></tr></table></figure>
<p>而转置过来是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[-<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">48.</span> -<span class="number">44.</span> -<span class="number">40.</span> ... -<span class="number">42.</span> -<span class="number">44.</span> -<span class="number">46.</span>]</span><br><span class="line"> [-<span class="number">30.</span> -<span class="number">26.</span> -<span class="number">16.</span> ... -<span class="number">30.</span> -<span class="number">32.</span> -<span class="number">34.</span>]</span><br><span class="line"> ...</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]</span><br><span class="line"> [-<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span> ... -<span class="number">58.</span> -<span class="number">58.</span> -<span class="number">58.</span>]]</span><br></pre></td></tr></table></figure>
<p>减去 min_db=-60 第一行正好是 2，第二行是 [12. 16. 20. … 18. 16. 14.]<br>再对应到生成的 gif 文件中，可以看出 gif 的第一帧每个矩形的高度都是 2<br>而第二帧每个矩形的高度也恰好是刚得出的那组数<br>所以要得到的 spectrogram 就是 <strong>gif 每一帧所有矩形的高度构成的矩阵的转置</strong></p>
<p>再结合源码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.array([</span><br><span class="line">    [</span><br><span class="line">        red_pixel <span class="keyword">if</span> freq % <span class="number">2</span> <span class="keyword">and</span> <span class="built_in">round</span>(frame[freq // <span class="number">2</span>]) &gt; threshold <span class="keyword">else</span> white_pixel </span><br><span class="line">        <span class="keyword">for</span> threshold <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(min_db, max_db + <span class="number">1</span>, quantize))[::-<span class="number">1</span>]</span><br><span class="line">    ] </span><br><span class="line">    <span class="keyword">for</span> freq <span class="keyword">in</span> <span class="built_in">range</span>(num_freqs * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>可以看出，每个矩形加上左边的空格正好是 4 个像素，所以每四列读取最后一列即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">spectrogramT = []</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> gif_data:</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> ind, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(data.transpose()): <span class="comment"># 将每一帧转置，方便计算</span></span><br><span class="line">        num = <span class="built_in">sum</span>(line) <span class="comment"># 计算每个矩形的高度（转置后是宽度）</span></span><br><span class="line">        <span class="keyword">if</span> ind % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">            res.append(num + min_db) <span class="comment"># 得到的数要加上-60才符合规矩</span></span><br><span class="line">    spectrogramT.append(res)</span><br><span class="line"></span><br><span class="line">spectrogram = np.array(spectrogramT).transpose() <span class="comment"># 得到的结果转置一下</span></span><br></pre></td></tr></table></figure>

<p>这样就得到了梅尔频谱图的数据，可以对 librosa 的部分进行逆过程了<br>翻 librosa 的文档，有 <code>power_to_db</code> 当然也就有 <code>db_to_power</code><br>而且类似于 melspectrogram 函数在 librosa.feature 中，可以专门看 <a href="https://librosa.org/doc/latest/feature.html">feature 部分的文档</a><br>翻到了 inverse 部分，可以看到有一个函数 <code>librosa.feature.inverse.mel_to_audio</code> 可以直接把梅尔频谱图专为音频数据，所以就用它了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = librosa.feature.inverse.mel_to_audio(</span><br><span class="line">    librosa.db_to_power(spectrogram), <span class="comment"># 乘二除二没什么大用，而且影响效果，就删了</span></span><br><span class="line">    sample_rate, n_iter=num_freqs, <span class="comment"># 采样率题目提供了，是 22050Hz</span></span><br><span class="line">    n_fft=fft_window_size,</span><br><span class="line">    hop_length=frame_step_size,</span><br><span class="line">    window=window_function_type,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这样就完成了还原，最后是输出，但是并没在 librosa 中找到音频输出的函数，所以就用了经典 <code>soundfile</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> soundfile <span class="keyword">as</span> sf</span><br><span class="line">sf.write(<span class="string">&quot;flag.wav&quot;</span>, y, sample_rate)</span><br></pre></td></tr></table></figure>

<p>然后打开听就行了，题目说了是个 12 位数，所以剩下的就是英语听力了，翻译过来的数字就是 flag 了 </p>
<hr>
<p>基本上我觉得比较简单的也就这些了，剩下的令我破防的放下一篇_(:з」∠)_</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://www.cnblogs.com/holdon521/p/4686849.html">伪造http请求ip地址 - 博客园</a></li>
<li><a href="https://graphql.cn/">GraphQL官网</a>、<a href="https://www.electronjs.org/apps/graphiql">GraphiQL</a>、<a href="https://apis.guru/graphql-voyager/">GraphQL Voyager</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/390876937">【安全记录】玩转GraphQL - DVGA靶场（上）- 知乎</a></li>
<li><a href="https://librosa.org/doc/latest/index.html">librosa文档</a></li>
<li><a href="https://pysoundfile.readthedocs.io/en/latest/">PySoundFile文档</a></li>
</ul>
<div style="display: flex; justify-content: space-between;">

<p><a href="/p/fd872e78.html">&lt; #1</a></p>
<p><a href="/p/f152ab1f.html">#3 &gt;</a></p>
</div>]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hackergame 2021」#1 Writup 开局上分篇 0</title>
    <url>/p/fd872e78.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/c05d7b7c.html">&lt; #0</a></p>
<p><a href="/p/f54b44c.html">#2 &gt;</a></p>
</div>

<p>这篇 Writeup 写一下 Hackergame 2021 里面比较好做的一些题目做法（<del>以及吐槽</del>）：<br>签到、十六进制、电波、猫咪问答、卖瓜、透明文件、旅行照片</p>
<p>开局基本上就靠这些上分了（逃<br>也都是看上去就知道该怎么做，只是实现的难度不同了（</p>
<span id="more"></span>

<hr>
<h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><blockquote>
<p>为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！</p>
</blockquote>
<p>很明确，进入网址后一直点 Next 翻到比赛时间就好了（误</p>
<p>看到了 URI 里有 <code>?page=...</code>，所以也懒得计算了，手动二分，大概 <code>?page=1635000000</code> 左右就可以看到 flag 了</p>
<p><del>赛后才反应过来原来是 UNIX 时间戳</del></p>
<hr>
<h2 id="进制十六——参上"><a href="#进制十六——参上" class="headerlink" title="进制十六——参上"></a>进制十六——参上</h2><p><img src="/p/fd872e78/hex_editor.png"><br>也很明确，直接把右侧挡住的 flag 部分对应左边的十六进制数换算成十进制，然后根据 ASCII 码转成字符。或者直接把左侧抄进 Hex Friend 也可以直接得到右侧的flag。</p>
<p>（**当时这题抄串行了两三次……）</p>
<hr>
<h2 id="去吧！追寻自由的电波"><a href="#去吧！追寻自由的电波" class="headerlink" title="去吧！追寻自由的电波"></a>去吧！追寻自由的电波</h2><blockquote>
<p>当然，如果只是这样还远远不够。遵依史称“老爹”的上古先贤的至理名言，必须要“用魔法打败魔法”。X 同学向上级申请到了科大西区同步辐射实验室设备的使用权限，以此打通次元空间，借助到另一个平行宇宙中 Z 同学的法力进行数据对冲，方才于乱中搏得一丝机会，将 flag 用无线电的形式发射了出去。</p>
<p>考虑到信息的鲁棒性，X 同学使用了无线电中惯用的方法来区分字符串中读音相近的字母。即使如此，打破次元的强大能量扭曲了时空，使得最终接受到的录音的速度有所改变。</p>
</blockquote>
<p>（这题在群里看起来好像卡了很多人，不知道为什么）<br>题目下载下来是一个听起来杂乱的音频</p>
<p>题里最后说了 “最终接受到的录音的<strong>速度</strong>有所改变”，所以考虑将音频时间拉长。<br>最开始使用了 Adobe Audition，但是效果不是很理想，大概是重新采样等一系列算法导致的<br>所以换了 Adobe Premier Pro 直接用比率拉伸工具拉长音频，还是可以听清的<br>不断尝试之后，大概放慢三倍左右就可以听出读的是英语单词了</p>
<p>题里说到了 “考虑到信息的鲁棒性，X 同学使用了<strong>无线电中惯用的方法</strong>来区分字符串中读音相近的字母”，所以就查到了<a href="https://zhuanlan.zhihu.com/p/101866561">国际航空无线电通讯26个英文字母读法</a><br>然后仔细听，辨别每个单词的第一个音就可以得到 flag 了</p>
<hr>
<h2 id="猫咪问答-Pro-Max"><a href="#猫咪问答-Pro-Max" class="headerlink" title="猫咪问答 Pro Max"></a>猫咪问答 Pro Max</h2><p>五道刁钻的题目，但是还是好查到的，题目里也说了“解出谜题不需要是科大在校学生”</p>
<blockquote>
<ol>
<li>2017 年，中科大信息安全俱乐部（SEC@USTC）并入中科大 Linux 用户协会（USTCLUG）。目前，信息安全俱乐部的域名（sec.ustc.edu.cn）已经无法访问，但你能找到信息安全俱乐部的社团章程在哪一天的会员代表大会上通过的吗？</li>
</ol>
</blockquote>
<p>看到了 “目前，已经无法访问” 说明这个域名曾经是可以访问的，直接通过<del>互联网的记忆</del>archive.org，查到这个域名的历史存档，随便找一天就可以看到他们官网中的<a href="https://web.archive.org/web/20170613090934/http://sec.ustc.edu.cn/doku.php/codes">信息安全俱乐部社团章程</a>。<br>其中第一行就写了 “本章程在 <em>2015 年 5 月 4 日</em>，经会员代表大会审议通过。”</p>
<p>所以答案就是 <strong>20150504</strong></p>
<blockquote>
<ol start="2">
<li>中国科学技术大学 Linux 用户协会在近五年多少次被评为校五星级社团？</li>
</ol>
</blockquote>
<p>直接去科大 LUG 官网的 <a href="https://lug.ustc.edu.cn/wiki/intro/">Intro 页面</a>，就可以看到 “于 2015 年 5 月、2017 年 7 月、2018 年 9 月、2019 年 8 月及 2020 年 9 月被评为中国科学技术大学五星级学生社团。”<br>所以是4次（x<br>但是怀疑一下为什么没有2021年，因为都是在9月份左右，所以可能是数据没更新，这题4和5都有可能</p>
<p>尝试后得到答案是 <strong>5</strong></p>
<blockquote>
<ol start="3">
<li>中国科学技术大学 Linux 用户协会位于西区图书馆的活动室门口的牌子上“LUG @ USTC”下方的小字是？</li>
</ol>
</blockquote>
<p>这题也简单，直接问科大同学就好了（x<br>翻了 LUG 的微信公众号和 QQ 官方号，都没啥收获，最后发现官网上有 <a href="https://lug.ustc.edu.cn/news/">News</a>。这样的话，如果新启用活动室的话，一定会有一篇新闻稿，搜索“图书馆”得到了<a href="https://lug.ustc.edu.cn/news/2016/06/new-activity-room-in-west-library/">「西区图书馆新活动室启用」</a>这篇文章，开篇第一张大图就是门口牌子的照片</p>
<p>所以答案是 <strong>Development Team of Library</strong> （注意大小写）</p>
<blockquote>
<ol start="4">
<li>在 SIGBOVIK 2021 的一篇关于二进制 Newcomb-Benford 定律的论文中，作者一共展示了多少个数据集对其理论结果进行验证？</li>
</ol>
</blockquote>
<p>应该没必要搜谷歌学术之类的，直接必应查 “SIGBOVIK Newcomb-Benford” 就可以找到 SIGBOVIK 的<a href="http://sigbovik.org/2021/proceedings.pdf">这一篇大文章合集</a>，再搜索 Newcomb 就可以看到题目里说的论文了。<br>全文也不长，只有四页，后两页全是数据的图，数一下，一共有13幅</p>
<p>所以答案是 <strong>13</strong></p>
<blockquote>
<ol start="5">
<li>不严格遵循协议规范的操作着实令人生厌，好在 IETF 于 2021 年成立了 Protocol Police 以监督并惩戒所有违背 RFC 文档的行为个体。假如你发现了某位同学可能违反了协议规范，根据 Protocol Police 相关文档中规定的举报方法，你应该将你的举报信发往何处？</li>
</ol>
</blockquote>
<p>没啥好说的，直接查，答案 <strong>/dev/null</strong></p>
<p>然后提交就可以得到flag</p>
<hr>
<h2 id="卖瓜"><a href="#卖瓜" class="headerlink" title="卖瓜"></a>卖瓜</h2><p>题目里比较重要的话就是：</p>
<blockquote>
<p>补充说明：当称的数字变为浮点数而不是整数时，HQ 不会认可最终的称重结果。</p>
</blockquote>
<p>题目的目的也很明确，用一堆9和一堆6加起来得到20。肯定不能<del>像华强一样</del>劈瓜，所以输入一定是整数<br>那就可以考虑溢出<br>但是经过尝试，给的数字太大，就会使结果溢出到浮点数，这不是想要的（因为即使凑到了20.0也不正确）</p>
<p>那如果数字再大呢，比如 2000000000000000000（18个0）个9斤的瓜，可以发现，这时直接溢出到了负整型 -446744073709551616<br>再补上 49638230412172000 个9斤的瓜就可以得到 -3616，加上20可以被6整除，所以再加上606个6斤的瓜就可以得到 20</p>
<p><del>恭喜你逃过一劫！华强～华强！</del></p>
<hr>
<h2 id="透明的文件"><a href="#透明的文件" class="headerlink" title="透明的文件"></a>透明的文件</h2><blockquote>
<p>一个透明的文件，用于在终端中展示一个五颜六色的 flag。</p>
<p>可能是在 cmd.exe 等劣质终端中被长期使用的原因，这个文件失去了一些重要成分，变成了一堆乱码，也不会再显示出 flag 了。</p>
<p>注意：flag 内部的字符全部为小写字母。</p>
</blockquote>
<p>拿到文件，看到里面好多 <code>[ ; m</code> 之类的，再结合终端中输出带颜色文字的 <code>\033[...m;</code> 之类的方法，以及题目中的 “失去了一些<strong>重要成分</strong>”<br>所以直接尝试把 <code>[</code> 全局替换为 <code>\033[</code>，然后复制到 python 中 print，就可以看到神奇的一幕了（其实并没完全做完，但是可以已经看了）<br><img src="/p/fd872e78/transparent.png"><br>然后读出 flag 即可（全是小写字母）</p>
<hr>
<h2 id="旅行照片"><a href="#旅行照片" class="headerlink" title="旅行照片"></a>旅行照片</h2><blockquote>
<p>你的学长决定来一场说走就走的旅行。通过他发给你的照片来看，他应该是在酒店住下了。</p>
<p>从照片来看，酒店似乎在小区的一栋高楼里，附近还有一家 KFC 分店。突然，你意识到照片里透露出来的信息比表面上看起来的要多。</p>
<p>请观察照片并答对全部 5 道题以获取 flag。注意：图片未在其他地方公开发布过，也未采取任何隐写措施（通过手机拍摄屏幕亦可答题）。<br><img src="/p/fd872e78/travel-photo.jpg"></p>
</blockquote>
<p>“手机拍摄屏幕亦可答题”，所以照片中没有任何地址的元信息，只能靠看图<br><strong>线索</strong>：海边、KFC、高楼、大石头、停车位</p>
<p>先看那个KFC，大概是个网红店，所以搜索 “网红 海边 KFC”，查到了秦皇岛，而且也是海边<br>再进一步看地图和街景地图就可以确定地点在 <strong>秦皇岛新澳海底世界</strong></p>
<p>然后是5个问题</p>
<blockquote>
<p>该照片拍摄者的面朝方向为：</p>
</blockquote>
<p>根据地图，对比一下就可以得到，面朝方向是 <strong>东南</strong></p>
<blockquote>
<p>该照片的拍摄时间大致为：</p>
</blockquote>
<p>根据选项里的时间，下午是两点半左右，而在东北的两点半左右其实和中午差不多，影子和光温也不太像这个样子，所以可以确定时间大致是 <strong>傍晚</strong></p>
<blockquote>
<p>该照片的拍摄者所在楼层为：</p>
</blockquote>
<p>不好确定，但是答案可以交很多次，所以从9层左右依次试就可以了，最后得到楼层是 <strong>14</strong></p>
<blockquote>
<p>该照片左上角 KFC 分店的电话号码是：</p>
</blockquote>
<p>直接用地图软件搜 “秦皇岛新澳 KFC” 就可以查到那家店铺，也给了电话，或者搜索 ”网红 海边 KFC“ 也可以直接得到电话：<strong>0335-7168800</strong></p>
<blockquote>
<p>该照片左上角 KFC 分店左侧建筑有三个水平排列的汉字，它们是：</p>
</blockquote>
<p>通过街景地图就可以看到 KFC 左边的建筑上写了 <strong>海豚馆</strong></p>
<hr>
<p>看来写了不少了，剩下的简单题放到下一篇里_(:з」∠)_</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://hack.lug.ustc.edu.cn/">Hackergame</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/101866561">国际航空无线电通讯26个英文字母读法 - 知乎</a></li>
<li><a href="https://lug.ustc.edu.cn/">LUG@USTC 官网</a></li>
<li><a href="https://archive.org/">Wayback Machine archive.org</a></li>
<li><a href="http://sigbovik.org/2021/proceedings.pdf">SIGBOVIK 2021</a></li>
<li><a href="http://quanjing.baidu.com/">百度全景地图</a></li>
</ul>
<div style="display: flex; justify-content: space-between;">

<p><a href="/p/c05d7b7c.html">&lt; #0</a></p>
<p><a href="/p/f54b44c.html">#2 &gt;</a></p>
</div>]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hackergame 2021」#0 赛后总结</title>
    <url>/p/c05d7b7c.html</url>
    <content><![CDATA[<p>七天紧张刺激<del>破防</del>的 Hackergame 2021 终于结束了_(:з」∠)_<br>在这丢一个总结和 Writeup 链接。</p>
<h2 id="Writeup"><a href="#Writeup" class="headerlink" title="Writeup"></a>Writeup</h2><ul>
<li><a href="/p/fd872e78.html">「Hackergame 2021」#1 Writup 开局上分篇 0</a><br>  签到、十六进制、电波、猫咪问答、卖瓜、透明文件、旅行照片</li>
<li><a href="/p/f54b44c.html">「Hackergame 2021」#2 Writup 开局上分篇 1</a><br>  大砍刀、图之上、赛博厨房01、助记词1、p😭q</li>
<li><a href="/p/f152ab1f.html">「Hackergame 2021」#3 Writup 持续破防篇 0</a><br>  Amnesia1、RSA、LUKS、MicroWorld</li>
<li><a href="/p/d11ec8ed.html">「Hackergame 2021」#4 Writup 持续破防篇 1</a><br>  阵列恢复、马赛克、minecRaft、密码生成器</li>
</ul>
<span id="more"></span>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>第一次参加 Hackergame，大概也算是第一次参加比较正式的 CTF 比赛。</p>
<p>这次的时间也比较难受，10月23日开始，然而当天有管乐团音乐会演出，要全天排练。24号去听了帝玖室内乐团的音乐会。剩下工作日的时间也要上课，还要复（预）习小测。<br>但还是抽出很长时间来打了 Hackergame。</p>
<p>经过七天，拿到了浙大组内第三、总排行第二十二的成绩<br><img src="/p/c05d7b7c/rank.jpg"><br>总之，非常感谢鼓励我（<del>拉入坑</del>）的 GZTime，感谢一直上分的 yyy 大佬和 Cage 学长督促我继续做题（<del>别卷啦</del>），感谢纳新群里活跃气氛的学长（不感谢膜），感谢容忍我凌晨一两点在寝室做题、第二天早上被一堆闹铃吵醒的室友，还要感谢没参加比赛来暴虐我的图灵大佬们（）</p>
<p>开赛的时候刚好乐团中午休息，于是在休息室做了几道题，接着一两天陆续把会的有思路的题做了。<br>然后就开始了破防阶段（）<br>一杯茶，一包烟，一道题目做一天（x<br>基本上每天除了上课写作业的所有时间都来打 hackergame 了（<del>中间做马赛克破防的夜晚出去闲逛了两个小时</del>）</p>
<p>总之我也才大一，刚接触 CTF 一个多月，这次打得也挺爽，不知道能不能借此混进 AAA（逃 </p>
<p>体验良好，但不完全良好，下次再来_(:з」∠)_</p>
<hr>
<p style="font-size: x-small; text-align: right;">声明：虽然总结和 Writeup 的创建时间在比赛结束前，但均在比赛结束后才发布到互联网</p>]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过AST解析的python沙箱逃逸方法</title>
    <url>/p/6dee32d5.html</url>
    <content><![CDATA[<p>这类题是在zjusec.com上 ACTF 2019 分组中chenyuan出的一系列python沙箱逃逸题目中看到的<br>在网上搜索貌似也只能搜到 <a href="https://infosecwriteups.com/tokyowesterns-ctf-4th-2018-writeup-part-5-6d699f07f71c">TokyoWesterns CTF 4th 2018</a> 这一次比赛中的题目</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这类题目不像普通的沙箱逃逸一样通过删除内置函数字典或者删除某些模块的内容来实现<br>而是在输入命令后即使用python的 ast 模块对其进行语法分析，只要使用了某些禁止的抽象语法，就抛出异常导致程序中断</p>
<span id="more"></span>

<p>因为它直接使用 ast.parse 分析了语法，所以很难蒙混过关骗过 ast，这时就需要寻找题目中遍历语法树的漏洞了</p>
<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>先来看看cy的pysandbox13，这个最终版的AST检查绕过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dbgprint = sys.stderr.write</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Traversal</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node)</span><br><span class="line"></span><br><span class="line">    depth = -<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv</span>(<span class="params">self, nodes</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(nodes, <span class="built_in">list</span>):</span><br><span class="line">            nodes = [nodes]</span><br><span class="line">        self.depth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            func = <span class="built_in">getattr</span>(self, <span class="string">&#x27;tisiv_&#x27;</span> + node.__class__.__name__, <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> func:</span><br><span class="line">                dbgprint(<span class="string">&quot; &quot;</span>*self.depth + <span class="string">&quot;tisiv&quot;</span>[::-<span class="number">1</span>] +<span class="string">&quot;\t&quot;</span>+ node.__class__.__name__+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> func(node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(node, ast.expr):</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed &quot;</span>+<span class="built_in">str</span>(node))</span><br><span class="line">        self.depth -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Call</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed&quot;</span>)</span><br><span class="line">        self.tisiv(node.func)</span><br><span class="line">        self.tisiv(node.args)</span><br><span class="line">        self.tisiv(node.keywords)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Attribute</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed&quot;</span>)</span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line">        self.tisiv(node.attr)</span><br><span class="line">        self.tisiv(node.ctx)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Import</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Module</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.body)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_BoolOp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_BinOp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.left)</span><br><span class="line">        self.tisiv(node.right)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_UnaryOp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.operand)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Lambda</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.body)</span><br><span class="line">        self.tisiv(node.args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_IfExp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.test)</span><br><span class="line">        self.tisiv(node.body)</span><br><span class="line">        self.tisiv(node.orelse)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Dict</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.keys)</span><br><span class="line">        self.tisiv(node.values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Set</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_ListComp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elt)</span><br><span class="line">        self.tisiv(node.generators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_SetComp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elt)</span><br><span class="line">        self.tisiv(node.generators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_DictComp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.key)</span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line">        self.tisiv(node.generators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_GeneratorExp</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elt)</span><br><span class="line">        self.tisiv(node.generators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Yield</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Compare</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.left)</span><br><span class="line">        self.tisiv(node.comparators)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Repr</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Subscript</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line">        self.tisiv(node.<span class="built_in">slice</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_List</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Tuple</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.elts)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_Expr</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_JoinedStr</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.tisiv(node.values)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tisiv_NameConstant</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Traversal(ast.parse(c))</span><br></pre></td></tr></table></figure>
<p>可以读出，它定义了一个 Traversal 类，在初始化的时候对传入的节点调用 tisiv 方法，即对其所有子节点继续逐层检查<br>如果 tisiv_{该节点类名} 已经有了存在的方法，就调用它，在那些方法中又分别对其子节点进行了检查<br>如果不存在这样的方法，就检测这个节点的语法类型是不是 ast.expr，如果不是就直接禁止</p>
<p>再看 TokyoWesterns CTF 4th 2018 这道题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, <span class="built_in">list</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">all</span>([check(n) <span class="keyword">for</span> n <span class="keyword">in</span> node])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        attributes = &#123;</span><br><span class="line">            <span class="string">&#x27;BoolOp&#x27;</span>: [<span class="string">&#x27;values&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;BinOp&#x27;</span>: [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;right&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;UnaryOp&#x27;</span>: [<span class="string">&#x27;operand&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Lambda&#x27;</span>: [<span class="string">&#x27;body&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;IfExp&#x27;</span>: [<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;body&#x27;</span>, <span class="string">&#x27;orelse&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Dict&#x27;</span>: [<span class="string">&#x27;keys&#x27;</span>, <span class="string">&#x27;values&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Set&#x27;</span>: [<span class="string">&#x27;elts&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;ListComp&#x27;</span>: [<span class="string">&#x27;elt&#x27;</span>, <span class="string">&#x27;generators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;SetComp&#x27;</span>: [<span class="string">&#x27;elt&#x27;</span>, <span class="string">&#x27;generators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;DictComp&#x27;</span>: [<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, <span class="string">&#x27;generators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;GeneratorExp&#x27;</span>: [<span class="string">&#x27;elt&#x27;</span>, <span class="string">&#x27;generators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Yield&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Compare&#x27;</span>: [<span class="string">&#x27;left&#x27;</span>, <span class="string">&#x27;comparators&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Call&#x27;</span>: <span class="literal">False</span>, <span class="comment"># call is not permitted</span></span><br><span class="line">            <span class="string">&#x27;Repr&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Num&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;Str&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;Attribute&#x27;</span>: <span class="literal">False</span>, <span class="comment"># attribute is also not permitted</span></span><br><span class="line">            <span class="string">&#x27;Subscript&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Name&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">&#x27;List&#x27;</span>: [<span class="string">&#x27;elts&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Tuple&#x27;</span>: [<span class="string">&#x27;elts&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;Expr&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>], <span class="comment"># root node </span></span><br><span class="line">            <span class="string">&#x27;comprehension&#x27;</span>: [<span class="string">&#x27;target&#x27;</span>, <span class="string">&#x27;iter&#x27;</span>, <span class="string">&#x27;ifs&#x27;</span>],</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> attributes.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(ast, k) <span class="keyword">and</span> <span class="built_in">isinstance</span>(node, <span class="built_in">getattr</span>(ast, k)):</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">isinstance</span>(v, <span class="built_in">bool</span>):</span><br><span class="line">                    <span class="keyword">return</span> v</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">all</span>([check(<span class="built_in">getattr</span>(node, attr)) <span class="keyword">for</span> attr <span class="keyword">in</span> v])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    expr = sys.stdin.readline()</span><br><span class="line">    body = ast.parse(expr).body</span><br></pre></td></tr></table></figure>
<p>这道题目的代码就更加明确了，道理是类似的</p>
<h2 id="绕过语法树检查"><a href="#绕过语法树检查" class="headerlink" title="绕过语法树检查"></a>绕过语法树检查</h2><p>正如前面说的，我们需要找检查程序中的漏洞</p>
<h3 id="寻找没有遍历到的子节点"><a href="#寻找没有遍历到的子节点" class="headerlink" title="寻找没有遍历到的子节点"></a>寻找没有遍历到的子节点</h3><p>我们发现，在题目的程序中，都是手动编写了对某个抽象语法的哪些部分进行检测，所以可能就会出现某个语法的某个部分没被检测到的情况。</p>
<p>这时候就可以去和 <a href="https://docs.python.org/3/library/ast.html#abstract-grammar">AST文档中抽象语法</a> 对比，文档中给出的 ast.expr 包含了：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">expr</span> = <span class="type">BoolOp</span>(boolop op, expr* values)</span><br><span class="line">     | <span class="type">NamedExpr</span>(expr target, expr value)</span><br><span class="line">     | <span class="type">BinOp</span>(expr left, operator op, expr right)</span><br><span class="line">     | <span class="type">UnaryOp</span>(unaryop op, expr operand)</span><br><span class="line">     | <span class="type">Lambda</span>(arguments args, expr body)</span><br><span class="line">     | <span class="type">IfExp</span>(expr test, expr body, expr orelse)</span><br><span class="line">     | <span class="type">Dict</span>(expr* keys, expr* values)</span><br><span class="line">     | <span class="type">Set</span>(expr* elts)</span><br><span class="line">     | <span class="type">ListComp</span>(expr elt, comprehension* generators)</span><br><span class="line">     | <span class="type">SetComp</span>(expr elt, comprehension* generators)</span><br><span class="line">     | <span class="type">DictComp</span>(expr key, expr value, comprehension* generators)</span><br><span class="line">     | <span class="type">GeneratorExp</span>(expr elt, comprehension* generators)</span><br><span class="line">     <span class="comment">-- the grammar constrains where yield expressions can occur</span></span><br><span class="line">     | <span class="type">Await</span>(expr value)</span><br><span class="line">     | <span class="type">Yield</span>(expr? value)</span><br><span class="line">     | <span class="type">YieldFrom</span>(expr value)</span><br><span class="line">     <span class="comment">-- need sequences for compare to distinguish between</span></span><br><span class="line">     <span class="comment">-- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3</span></span><br><span class="line">     | <span class="type">Compare</span>(expr left, cmpop* ops, expr* comparators)</span><br><span class="line">     | <span class="type">Call</span>(expr func, expr* args, keyword* keywords)</span><br><span class="line">     | <span class="type">FormattedValue</span>(expr value, int? conversion, expr? format_spec)</span><br><span class="line">     | <span class="type">JoinedStr</span>(expr* values)</span><br><span class="line">     | <span class="type">Constant</span>(constant value, string? kind)</span><br><span class="line"></span><br><span class="line">     <span class="comment">-- the following expression can appear in assignment context</span></span><br><span class="line">     | <span class="type">Attribute</span>(expr value, identifier attr, expr_context ctx)</span><br><span class="line">     | <span class="type">Subscript</span>(expr value, expr slice, expr_context ctx)</span><br><span class="line">     | <span class="type">Starred</span>(expr value, expr_context ctx)</span><br><span class="line">     | <span class="type">Name</span>(identifier id, expr_context ctx)</span><br><span class="line">     | <span class="type">List</span>(expr* elts, expr_context ctx)</span><br><span class="line">     | <span class="type">Tuple</span>(expr* elts, expr_context ctx)</span><br><span class="line"></span><br><span class="line">     <span class="comment">-- can appear only in Subscript</span></span><br><span class="line">     | <span class="type">Slice</span>(expr? lower, expr? upper, expr? step)</span><br></pre></td></tr></table></figure>
<p>比如，BinOp(expr left, operator op, expr right) 表示了二元运算这个语法，left 表示左侧的表达式，op 表示二元运算符，right 表示右侧表达式。<br>同理 ListComp(expr elt, comprehension* generators) 中 elt 表示其中列表推导的元素，而 generator 则表示生成器子句</p>
<p>再来看 TWCTF 这道题，它的检查中写了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Subscript&#x27;</span>: [<span class="string">&#x27;value&#x27;</span>],</span><br></pre></td></tr></table></figure>
<p>而文档中给的索引访问是 Subscript(expr value, expr slice, expr_context ctx)</p>
<p>因此可以发现程序并没有检测索引访问中的切片 slice，这样例如 a[…] 中的 … 部分就会被全部忽略<br>所以就可以在[]中藏一个eval执行我们想要的功能</p>
<h3 id="寻找没有检查的节点"><a href="#寻找没有检查的节点" class="headerlink" title="寻找没有检查的节点"></a>寻找没有检查的节点</h3><p>再来看 zjusec 这道题，通过对比可以发现所有检测的节点的子节点也都遍历了<br>但是再细看可以发现 FormattedValue 这个节点并没有在题目代码里出现</p>
<p>而且 ast.FormattedValue 属于 ast.expr，所以它既不会被检查，也不会抛出异常<br>看名字像是 f-string 相关，可以 dump 一下看看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(ast.parse(<span class="string">&quot;f&#x27;&#123;x&#125;&#x27;&quot;</span>))</span><br><span class="line"><span class="string">&quot;Module(body=[Expr(value=JoinedStr(values=[FormattedValue(value=Name(id=&#x27;x&#x27;, ctx=Load()), conversion=-1, format_spec=None)]))], type_ignores=[])&quot;</span></span><br></pre></td></tr></table></figure>
<p>可以发现，f-string 是 JoinedStr，而 FormattedValue 是其中被格式化的部分</p>
<p>所以就可以向 f-string 的 {} 部分藏 eval 来干坏事了</p>
<h3 id="其他漏洞"><a href="#其他漏洞" class="headerlink" title="其他漏洞"></a>其他漏洞</h3><p>这个是 pysandbox12 的一种解法<br>python中的语法不仅有 ast.expr 一种，而且很特别的是，列表推导 ListComp 的生成器子句并不是 ast.expr，而是 ast.comprehension</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ast.dump(ast.parse(<span class="string">&quot;[x for x in range(n)]&quot;</span>))</span><br><span class="line"><span class="string">&quot;Module(body=[Expr(value=ListComp(elt=Name(id=&#x27;x&#x27;, ctx=Load()), generators=[comprehension(target=Name(id=&#x27;x&#x27;, ctx=Store()), iter=Call(func=Name(id=&#x27;range&#x27;, ctx=Load()), args=[Name(id=&#x27;n&#x27;, ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], type_ignores=[])&quot;</span></span><br></pre></td></tr></table></figure>
<p>但是 pysandbox13 这样排除了 ast.expr ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(node, ast.expr):</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;not allowed &quot;</span>+<span class="built_in">str</span>(node))</span><br></pre></td></tr></table></figure>

<p>但是12题中并没有，所以 ast.comprehension 这个类型完全没有被检查<br>因此直接向生成器表达式中插入坏东西即可：</p>
<ul>
<li><code>[x for x in [eval(...)]]</code></li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://infosecwriteups.com/tokyowesterns-ctf-4th-2018-writeup-part-5-6d699f07f71c">TokyoWesterns CTF 4th 2018 Writeup — Part 5</a></li>
<li><a href="https://docs.python.org/3/library/ast.html">Documentation of ast</a></li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJUSec Writeup」cy的python沙箱逃逸系列</title>
    <url>/p/e8996288.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不对哦" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="0889be30459b34f401a9317495b5209b94e89def5220a8d49f372b0cd4144079">64cf36da832c32ee150f47182e85c12ad08e8fdc7585aba87e7caa43ef24ea022ddcd838c221edd44ce79d4382c4fb2a74a2a61c083a697ca366d8dabf906ff9cb977e2710eeea3b8665606c597245f9f66aaa8aa22b8d5b2d1684f09275090bd4b7d3188beb27c45725d276fcdcf3ae57bfa442335531788e63d75df4fcf1fcfd15e92f8112599c4866a6079026a5fa9152331f68e4abdf9025def0aa02a5b0e37c6daf00b3a2b203a9e9f2d7e9eea7f2b1dbc49486232143013cdaa01fd99c8805e6a12626f0e243fbeb22664d1a50421fca401b58c44b6886982e475810037f3e254e2dd27f0ddbe819e923f3d18b663455a9d8870cb5d49dacdcd4c4235e401da124c87617cd2e091e7d7cd1be23b33628afb1e5ea1d264473d5d9da6c36cb6bd9c3b66ffbf4dbf22f774d58451ce46a5b30390352a4e4ffa037305813298adf392ed06eccc3ad88c8381241d7e74dde7dd34270ab36bb0896f5739b9e16ce4b9b1618ce707ad0464491a72361640e3174f61d8ed93929e0747ba5ee39780bf4591c35351151103d2245eba2dfe47ee2091013013903b1e71a04a38c7e2df148c1014423b438b4ac4a77011d7f66265c25fe6323fe17aba66aede8e62406ad7419eebb351c55395a27e149c2dc0fbd3d0a1bb35e49cab3a1af15529c472c992d9cfbff7b3b3aa0f11f7c250eb6bf2af2501a0cc8fcbb2a8adf63438a959716dd2a0d42e56b87dbd4dd8fa504aa39a8f5ab0ed1402d2c9eb4b373afcea577e6a796daf15d894c7e1d358ea20b0cf15799b885472ae2e0e246bcf51932278fa4253d722610d13340f6b03e599fa8622312069f3db8f0302fc46a924f6b841364107a936c767434c9439e97e4e0b00c6fe2cb88e30c5a4fb92f8112f0fca9e321b84020a42ae30ce9d214fd30d166b0606d7db0adbb2032472d02103c1a2a6645ceeb41c7fedf420bc585c9afedbeab13edeecb4a7eecfc2dbbd672545a1b1bf6952812250a40840692d1c9d0a33e24280025191fb741711ade955dee0e2782dd0497ced9a8c288ee777ba9ae026c0558ef971458a5b6c3813f61b0d950e15bec2c955955be9379445b9a1a53f3837378cecb48d2c6e611bb7ba61343895d04e4f7604fc2e9ccb29a90777c563fdffce54329685c52e50da0dc57557b02a473cdfb64ad41e1685c1f78026f56633de036875ecb4c30d1299b9d6c9cc452909136fd146c2e240633c20abbff091923388d2fb5ad348e3bdf0c29659e37225784a463e3be36fc9c0645272edd36ee91cd71bf44016a756cf3bd0db0385743f3ef26edd1737e2220297ef9a373cbc2bb6a57f11f5e3f0abb20c14d630ec5f854d04884b5a709a77fdae8ff7d608d4f13d3ecd34d9415261d9ebceed5fe04a23e81169bc4006efa02f1322bd932c8a4a2c3fa0e7c56dc5eb41db5424648f8c7e4c81c3cc871fdbb24d292724616a00b8470fef023d148b027e0604070bcde2bfe1cf89b3c1ba242badd7f8f5932b5b961472bc5cb6ae66828462fa016f0e502f22ce878acb15ea8d164d088afd9eaa2771d4b3739cc990c4910e5e225796e1f3aceb5e280b686e960aa4f04a94b1fee8879d0d541e8ea5966ef4673bc18afdd45a28a3151bacc91a4d9c469cbaff8f570defa9357a8645c91da1565da741df9e724fe439ef456d8d485974f1bfcd17759784eb94f915fb7232dabd5f4dda27cf2949b1f1c2ce6b27f4f87b7c0d0ac89b524602d5584a2d86044302a95c0b254b044e9f50fb25592e92016c594298f15a127456811f70f370b1944545f60cca7018fbf74ba146a00c4ed58f13d3cb1ec02fd3d8a822bba47ee473bd06828848015caa8f344e4e55467bf45b938e045122d5633a5aba91020151d0446b7f17dfee313dd2c50c7694e71ab35a878b9561c893b0b128dcb54cb05307beb31c35440bddb1408e4ca5ef21c4ab6f2a8b5c1f4bee47fa39ef73b6e60f035abbd4bb498d0476bec408696975fc6f0181ecb564900f8502fb02668ab5ce427862cafe6c42d012294f8fb97158b571a44c0696edb342418af6cd9d189b7002b3a37b3aeb738ba800018c446af13a8d2da28f400293825695fdfca5e1d43217ed5ca445789bb022707fe24fb99aa07d8b4c122b21de532d610e8912161335d678d3998fba5307e3bdd24c32afb8e13eb4ab625ac48945deeeac71abf8d8c74525bb22d9832cc8f52c74829dbd8106e63a36efa52dd6470f0f13d2044c818cdbc5c01377a5b76ccbc0ae47caa036844fa3e511cede6da1fba4ccc38c46d3dc29d7e160ae43bd111f47570b875852ae8b771af6acf5ac79d7f165101f3c71768dfa73fe4a8a1f3341427b9b4170b6ea17696c93706500d7235b886c01672b421e7c238bf6216ef2ba9c77f3ae128136e4ba28662e2217cf9a6f68ff19fb73ad0b5256d8f09d8b29a80c7fb45b9f6ed859844ce0c186c64e812e59d5f84120c900d3f22c80ada37da9f5585b290c401621ac25db83be1aa574cedd74cf7ac95312376755e6045fedbca51634167f31f7780570aa5b7756e5402deb99ee3d07d8c1d26f2890bc4ca82b91933570195776ddbc75a2c1ab004111dde8ecc509bc377f446529fd5025aa320065b81f6237e68e7f2ee97ee03cb89c9b14f0458ac4834624947a08e157da874cb71e989e5403c0769e94f17e0d4b2b38a9938ec18af8d480e7d0c57badccebd4d9242f3092edf0690b6c47077a2b4797e42e4953c51d6b633a2e201e6b0a949eebc5e8d094e3a5761eac87cb3029376257080bccbfa63c360257432cb3afa31472b54d2aac7d26d4ed233783b3817add2fc1015d5019078e65148c5d363c4f52c1312c37553bde86c7bce48fc74b54e7832cca6f9971d944ecd346a9c3e8af08ed3bd0cee66c300040a8eea8c2e45c1c8ea9c98396a02cd0032af301771d10d9a828f6bd14b6b1f4e15c2d9fc767d218e5fc391946aefc11e25827284e54c478de248903908cca4ebfa4fcab0cbe8d764fab8ee6956f8648008bfc4fd0b924cf8cca7e6b01955031e8cd4391904164f5ead3e45018826d17916e521592bbc7fb150145c0450b7cb73a75f9b92a3fc3c62e31c6745c9b579244d5f731c719536016cb0f88328284d608f4f29f5612d66f985b990ee0aedf4607a7b835790cc8c13495d873abd6593c89027dc0f7c211120b1ec4933d70536c4562b5b3dafb196e5fb83422edb26628f42e283c1e2626b52bd40c6b55219e060239b667f4cb4dba5796e01db505511efe0fa597b76e82281901f11e61451d0a627cbeaec13065eef2256736032789c425d4fee058a0937e299afcb26351572a37710875e10e6d396bcff54e2286aabfda147213f75ae154a703f1be115c4f0f97c17810a4d818fb56e8ef7ae8afa7c02367bd71d24c13e3cdbb3c38da7624c4a47ba62ce5e5bcb7a0eaa9a2aa3399ab11e2becd696fdac2c23fd09e2bae8f6d658ad97be029018c5a766ed62a7e4a6405445e5135562bd143d349a765924b3a98aa02a382846d7c3620bfb8cd16a5594f47b28315b6e33a399ab88be1a2e64f9eea1031e96861b98d2bc7470450d852c86a1392a6cadfa03c91e298df8f025c2d857797a6c192bb47c6f5fdb459c58acbd4ec54b94d59131c221d39e6726c51932eadbf0c3d3d4273e5ce0648d4886fffbefcfbb8df2d07e3e2941ad1a8a24b0b89d5d7415aa0f4d06d36b1d000c37fc3ce2a2059aa67c26eada6d33b4675db37f74289750e834a513f569bfc602ebadbf21780790a2680a8ab4f878570eee3124e10e8dab2a58cd4ea88691877b3dc6f17cc9a71aedfac2d403c45688715c4fda9fb4c8895d315545adffa91e33681ed41070a9178cf958819dbe9cb2063dea92f54ff44e72f13ce2c3706f314643b13af0b7a36cd89c986a7aa1eada7567788cc0a7f563c6d20c11bfcc7d1e53c9079c21c14bebd909a7f293c1492310dc4b9f852573d8cf829c4f73dbb86d73c6c1ede361f6a4a2cb4bfd45460673c5ea258d762713d3bb2d250be1eada634203e06b68206a10878d032390e681744c13403b539855776bd5bd40bd28dac86ffcf8c6d23ecd205e615fd4d278479b5304455022bcbf77f7e795bc78b79d99e1cba24467ce2b5d6eb8967678abd7f1b39fa24e77ed53a0db55bab48db9cd1e1089d7c1e08270656dc5d6248bfd1ce85c0da80e5c291533d078d5f82f4324b1c0d203dd3daefb6d097c1532121aa740edd8e9877e9fa2c07c0048fc0f8811dbc26fbc0b986d11ec2fb581e6f2deee2203779f027c2465c34a48ea1f9195e9a84f3ad2fc7efa47aecc021360db7de6d694a33ff08f6af543668df2eb340ac91b8b8aac4a70829382d5d2a720038f4dadea12194f3c22145e0ffda57f287f60d0e17255d5e4f216b5270a58dc8a3ef216d93c4322e8020871d14bb46a8892612a7e8d0f81c42f736fc49cdd5194e85e2cf9b2b18fdc841e447aa8b7d9a1a2b942fd1a29b28ebd91cee582a51720c2785935b08b4398a6d521de619fb51905e4aa3174821d6ee6b225412526c8b196d498d576a51879d47184afac4feec7ffb1022298bacf0f3f26519ef379db70326f37e68b0b343967d3595660cf310614fcc077b573644e578ec2010c8a79b7832047361d55e699e0eb87503a1ceed840b9dd8c0b2a82eb0fba42564efe136ff3c98951885e655b1172d0cc68b376ba50c89b285b16b0a878aaca8b699617a0aa08af55173270648dae074363e790e7f9fe169613bc66296403231a84d97d428696c3fb10a14dbe42941463b144d3d7266fc69adb37c9923cf68b29301e101c547725ed068bdeb378027119bbb2f99a0fad44e6537b99309d0264016a89b77091314ae0486f30b88280679c7ecd4ae41424b0d4ecf482358bb2ecfa0f0739cde518df02d352d2e5f7b12229eecbbcf78e6523c8596f49faada419203361b34778261c2b99f0f2cbe0981080e86b1e150dbad65c43a8b0c19b7fe290dfde1fe647b6d148b89a7ce1ecb3206029a373cdf5075a415467f4b28d989cffe518517d11469775ed5088f34ab82ef6312babf892b5674f227f9cb7b0a692b0799ceb18f765074c35bfb489a01ddb3dfd40856e6fa7d14fe6d81aae5f4b053b2b13f7bb06e143fe148937438314b9e28369ef750ba9964face3426eacf25af301ebfc22dbd29e2a084a74c813acafa71bac015a2769deaa5dedce86f22a0c59a4ba72003e08087bc6e188a379d2bd4518b68dd0ec5654913ca8a5a014dd40b4a410d4f37e69a973343c7ee46bb1be5e856351b4decdc13d07e47b06b3c34ab3f808ab16dedd877b64bd95e2c9c414e8de0a1f3fa21f2af0657f5b3309bee876341fbcdbd36c7af97065df3efe2931ddc9e9552962759839c9ed6e25a51547019aa599c178a866bc2558f2ac83be1c01bf2174908fddd14559b871719065d101d4aeb7de3b0b4d5139037ad90e77cc349e0cfe8dfdf41d6842fd6b8ea1120c356f9fc7be1029054ef0d6ebaa69b3496473c12c0448fd471f07eacaf51fba7f7492f370ef7f2b083834f239aed640818406fcc7b0c3736716eac114369e9f30637fb1dea243c69ceffe680c17f9551c752f7c37638104dca0099d78f4b5ce6fa1737941fd5e86dc855ad18413ff071e0ff189e1d2cc571582080c6b79a1d2cff5c410c51d93b0c420f75eb174eb3193878012d32a88c1e7e31aeefd6bd531d0dfca26c2f5c28feb466b19826979d9f2003fc8b02b3d933b6c55cc964931ab719da7b5a40b7845080c3937f654a76a254108b0dd3236fda765425f1defe8681f85f4f1ca7a1cca7b3376cf209ed39cc816c6877de7b1735ac8d7720ab4b7306bdab173b054dea72a8d476917c42146bcc6cabda590845c4aaf9a8dd260c335ac4e131c2ebdf525c325c0441334d566b7043a19611174ecb4a9ad176da44c767bd721d0c711a28247bc0d239780a831e929d226e2221856e2cc95779416813fa4a5018376d0eb90d9ea6b18d74b49dbf6ffbb84cdd97006fdb2c737fbb2a9af1333e33f75dbf5d3d75bfc560dcdf33a0396448e2b02830eb12beb779c67f335450f81656ef918b31b0302ab36c351185cbeb58fc0fc407bf0f8dc52c493592c39759face76737532daccbb18740d2d7d00a59fee0c46ef14c91daf7da7a6dde41af5cb6f675593736b64c68701d2bef803aec42e7d6a85f7b9adc17b59707ea2d05907858e381c4ba61271a70be961958693dfcfd043d5b3ed8037b546180f9d1662c74b6dcdc447c4c9113a37e8088bd3e8cd21399d46430150b9b0aa8f5471f6fa5669bcbfdc7580d2e71522b03ee9d397e0bc7fd9ca72abb7ab55df725221135a04bb29222972dc5a8ae35d90b08def2b3c67b8f3b0192bdf6daed7fbd76a94410cc980cb4b2d2129ae81738323e360c81545d8e547157adada64a7499cf3f3c795d3d84a3efbfbd71d7529695c985dd66caa499824b124c6ca48f3e93cd50daaa0f578b14d45b3396328fdf0b1e3b8367244b625307bccbc7f4912c8185a46be1d5e7117fed40ef4f128033324d24e03457f01e4a32989fe06a2b88bf565a1937b32530dd93be7ddee230cae93ad5293278b74e50abd3997849ae6919077ad43338f72b0dbd1c9a47b87e854addc17ca4fbba4faa68444c6938a14f52386a47124720666eb6ad54eb18079b270c4ed3cb6c068aac39bd8fefec97abb5ebacef348dd9ed938ce1737f3e24ad1c2d6ee7e1ca152d3c215c6d3ec13cb6fa5ce849bb254fd3a48a7ab29d3aa987f8d8a66b628136dbb226901677b856d6e52145b52df4699f8c9954aa9d92a975e71a8b9bf2bdb5df577f7726f597c1c8d344ed118410afc774e87b5b424583e39b28d58eb407d1f55b294052918ed6f8d2b5726f4e5acc460e07174343329f649f50e95470d9e477882d44df5cf24afb262bcebe9859af7b666325c4e9d08db9104b31b4718d79cf92573d7afb3d967f669ccae89d6c8d4552cbdb08183f00fa6ffc8f9f2056da4bcf66cd0604d79693d878d071fec15a1575524e46cbd2ffa664cf2f89df38c59b2f1906018cdb6ad7b156644f4fd99ef9efafff57f38cc87abc89574dbd36f1607d7d3181f18dd6b3efdf633b866b9ecb9588710acfc60de6a5d204e734a7bdbebffe410fb8024f0af2a7037020ce6451c4ec78b3cea09c39dccd1df6e88c39208e5b92ac739cffdb3ccb2db497b08757a4a307a9a87e78d3a49d0ac1172d9f7f281f487f85415e7396c3266f9269aa69eefbd5018ba9b1664d014e1bc368ae34f340e100377eecef40ce75f5ad6effa8716e579c2487b4d4e31da02d9937f1dd577b021b629f9ff335b06e875988e5df3221f0168e6b133295325970cc1c3c6af6c551b4be96b1a1fbcc8897626a47a7c166765a18628807f734e928fb4a42972bdf0596ba5dc3f4b51dffd2005eaba5498d44808916d3fbb1694e3610e65b6eeaff10ed3889a08b7ad62ecdde84ecd2a3b744492e842452e75f849de5fbba6faf80e308af9bdfe40def2b24a9f3c63811b2de74703c7b7c9c5c51e743361d8627639209b98986e6f2e5b739c6c31a1286870427ec29a3e7b088f0295145d3bced9e470db2e74d5b463395aa3647e7f4623ff7a6753bebef8cf41a30f0849b9eca72a196423f8f8aadbd97ed8535107e02396ade40a221cb2fdbca6654fe9f768002e0f27e4e6cb8821a64065456e200c878f1db4d79e7860d36ae02e8a9cb08226f07ed49b44537496655cd928ca2662a506dd570b6ca73522ede562a4a1be04b906f686ff32d0ed50f1abff3b12b85a5bf00f9706845ecbde3523f0250e8b00d8cf276ac84578c31df9ff945db2a33afdedffe6845030b8eea95e78ebe8ee433264ec765a6451e83d8afef00046e0373d348518ce54d46e88669cc3bad2f10fd97a8ead3d3dc8cf80a9c1db43d92ddaa148bb06007fe1e6fb24a144c959b1ef083d3f3b4eaa2ec523a90a5521081f61a421b46074fde18f860671347c08533def30914de7bf29125b86bae9782ffe588581fcd7ad308475e709e1d0873ea0de9192ae46b2c4f5a5c26a109aa07fa5d7c5ce29183c12dbd6b5b1736f5fb25c7cd1390ab5ef017a433779a1ffc0472851e4a58963a6a5cd34614651384f3e04e49d3b2ef8d45d6dd7ca852cb3db9cf2bd3bd0f7da4643accca6f68848672de5810e53035fab6eba9be9b0f56d467a669eb1cdb7938fba77ea401a95166e8f45dcd8a23617dc42a47070d36bac5f243f3e04eb2c0b8e62d784cc5a40f45e6081de530726a724bcda48753632f303bedcca10ebcabe89ad2612ad7249275355ddc90d7420c6c76d028bc62155debf15a02b72f4cd7b114d4ceab59f93f58856ffee01ffd29d7e957ea3e4c929c33395a69f7e39f05010e93673ebfec203f97bb0f52cf28172a30d6c5010c8c655bacb40314e10da58ec3fc722651469772fd48a77b96be2b8683e56ece4c2105ba8a02366832303b0b49569cafa65510da2b0d98bb95dee0d3c19a1c339597aa1e91e559f8a6eeff43fdfad248b493cf1532669ed765044340a7c907f4bb28002323ee079eedf2b06aead5aa034de4b1834547d2b51909ba1700f2a0e367c5522a1605da5119c95edb8af56ccd8dcf6fe903ebba48ab4703bea682ef42835ce1f54f44f24e13861c2e82553f4460a8b00b4469a715d59fa4f7fb4a1b028766fcf4e48e985df8527b7735a8c98f609764f2d9b304fec6360a0a5bfda8424d48fbb25a4e0d56131879640484a77a7985bcd6475c861850397da50144eb5c0c1a9080212a99122b2ee68e337623b94f84b9056476fa4d64d549389a9467406650c09571b4d30f2e024eff9be35f006aa770d89df4ab5a5f54655673c654a02898a36bd1717a4cd06e77e01bb1fe67bb69d644b8e06b81685438d3a17c85ad29f42e4c85fbbd0f461fab0b854ddad4216a81cbaae93d64e0dc76f66b096b5fc0a89c766ec0afbb2b013b5f0c502517c9a1ae612a2f46db22fee046e0e16e317c7bf200572221f7deadc59f30595b75624ae5c54039f25e85761f2511f5695319a2fdf06832d1db76dda9b38f5ea8a3e5b493d83a1b76ef89b8c202573e71feb99b68d08860914ad47977184624c33ba6a756c92815e934a20a337c8d426949675d24b3c590aa915e7ef06bc66a8f31f0a6d0b9b20e715b275ac60dcd3f2aa3f1a09b366df2f264af6c7b5a7df46d47fe1cf4f77d391408bce000c4065f855ffc332c40feb01ade5fec84b41a7c0ae9233b4e024254592f8d8672c6072e049c5bf66b8a9640859ad96b6db46e85e9614c7562e051f36e614adea530d9fdf9e3beaf27c601c059a8d9e853cc67cc78fcd2390711fa4029d9100c992ea316bf65daf7fdc0397ea6065d3563258f7de0f8cd7a6df2da04e89aac320ae2733f5bb2671c985fa7b9d44ab18c4c7944c2208d59b15138022ab4f217b9fadaf5486f1950923dcd5628ad86be99cd0b90755e5bfbc9a612935feeb5983e58965c265304a7b45bead3bf9f16c0d919ff05a359570aa629a0b47bb925b278ebeaa87941842deb6ecb6b327c3f6878af78d5fbcc5ac94472d82dd28e5568bb6d29d3025125f222abc3e650f286e7d8043bc6f679647afeae345183a16411982749b4823382999ac97de9571c24bcad272797783d907d2dcc0211c155750bc96cdfde20a13278b3744271a1bd2facab1e23d9e1265423dd799f73729beef868ebf2a4e38c928fd83357a65880eb8caee847524cb4b54a39203588aa19525b9d73a0d5d3fb005e500d533051a5eb150308e0f4d9fde9730a7f637446f00553d0c10d129f1f37d93a022a89b3126ae882ee96d0b217d75ea445137c919d054121e6c339d3b583db38048fd0a214b24bcc5a3e5ebca07a594f21a8416a9c86fb14b2ab2df4ef99079745ea24dc4e0ecfb55f6b4f5ad817a6a1c10a586806ce5149bc1e489fca91ec34714c94b9468ff2b3de21fbdfebc1bf552666f9c26cdd502cc072b73a729e895df8c1e4b0820dab0cae57cebf340e98d778bcfcd077c434243dd0a83b17feafaeea641795eaeeb1395740fcba8b3f9b96bf54039b033e75150d8d68c1ceb24662fa210db816949d23f59291c97c30618de0d11a93a498116d1dba4e3453ad6afb7513f621439ad74f3dd2b3ead4b414c7d4edd1f305d8a02b0389c9c7dc757a32b6d6fa8794bc6144f571b151d9ce4eb18ec1939bf9cc0a687920cd0d61e9567be0045b3ff9e5914d67f286c1f09233ff1837676ccb3c319f8b47e940087bfe1aaf173dd7b04dd1ccb0b82effe2806db829052f8124ad895fecc53802f54c5d910ec970f24b38de8a6ce3f1fd9cd90628e92e59bef503117c0d0918231ba67d883fc198ce737fb57b1577112991178c8485c7a95ae5ed6bd1135d2062a2b78bf8849bd84f2cdbfaeb91e5962642b847aafe93cfdf62fe6f8b61dbac03cffabfebd564d7ff2c65ab47c8f4675aaa24c5bc41d046b767fc1a54a21ee08475b62b7bef42b069962ee4770ede4461012e7f1585cc84319a6bd89ac552946d59c2476de0cfebf8bbf433ea7cf61cf82b6e117c942eabe3572e1cd8b60b709d4f83fbce649a17164c0d7c2979002b0fedb85aa313aa97313b87116b5c03b713e8b725704288f6cc336a612e3acc9a734dedb6469dfe47ddb5434134f1cd45093ae0f3e84d2ab8a626c04f246414abb517bba1fcf18e0137047ee415f3917b061de17dd82217d53aa546853210b20cfedbb1285f4ea609e1d477084dac3c8725cd0c3a78ea482c1c87eff2c7ae445d820e2ce09cb611706eefa942b40e8d1b4289ab6a80d6ceb8ddc22c06646cca79567b974c9712ed563a2d4935a50fd51b9e149b863a3c9d1adb95ba4d4c5bd33b1907c7751db5807ecaf3b2b5a7c67783377402e4694320f18be03f45236c33d6af29321327c86cc8c0a171e831f5b61a62f39b6c3687b6db3704c1ee961e7e1199d33cc80309e5ebc4edfc737ad0ff7a2985fcbb86d2cf4efaea86e40a30b24e400868b09b867e2567f8f420d22f42a2105e81bfc5a9feef15fc09b1d16ce46b8cb3f1e2157c91f2c6224548cbf1d14b381f441824f262cb8a1c4a7f2694e59387becd0652ea11067eef0835d88e0c997202b4097f8ef958418937aab492b7ce61b8f5a463c25cff4f8e8bee3096d61a7e4d69fd7fa924e4bb6e5a3d64a9f3721ea823dba8ac81562c0111343b173cd0200eb54e1c991154ef88ea2bbaf52444600bb19c36ff3bd6fc4d50cd32c303a004745e8956d1c50abe1ec490de7baeb32a39e50f21e594e03c59779df7d0eda9cc30101b3b026327833ddda0899eeb6dd9a7e1d030d75590dece741fcb3cc7ca075b9185ab2941953a5be1d8c59384b758977b4cc87f45e434f72bcc707c6e55661a1c1a5ac7cac19da3d6c686ec5944509f87d0f33ebc3b93a7b98ff74ac1883369781dff2a03b0091913ed358a347cb9749f787b23cb215b4afb63377a36c0a42fe0c9b0b299f41984081dbe18cfe34e5fef914a9a83c9b69589d73520a28bc3838abe1c2aab06432cf2aa9af5c3f18d341c060cb51b54552af559ea3101c06c901e01ad4b4af91050b10d0a0ff8bf1754f71c291a06e51b86c1175bdc9acaef6e328d2d6269d9602db54c76876d13d6756911f4c4ecb019c5e373327786ecba91f0546d680c8b13b77cf645f5d563655c83d97b909cf49f7a43f8e7fa4f4b9af46c3ab0dd4cd8003cd3dd616c395aedabcdb1bfb43cce9f007db692d0f7b9ac6d46756d0c0a49b4c4bd2da22383df12b3d4a94d5005329e69d07e3c5713721499719c73ad78add9f1594d4381ce3872771423ebf83ced7860acde3d1254d001b11c1a0076ae28e29be12ef36c7da90317b90b50974ef9ab99fe1eacbaa92f7c5e9887df04540d0e6f00c080633c692cf2674d38a75b9defcf216119857abfcf1af0332018489f3a5108a3b376433edb62bf4db6f9a1b3029d2a677a2c200fa76ca922a8558e859fc06f04dfddf8e8f5e6dd7b5d84e55820cff8d6a7a565bcbd26ecb9508790d4015701c9fc7ef93dbf16f6835f107589c9cf059a7737bdb1dffa8519c31e73e95779e38a9da471c710de2d65be73435710d8c89dc1de96799d89e19e327e1c8561d1ef63804575a5b3766c6d81f10b65a8563db153d8267f03b003456e603bc063931d436ce828945d7e7df452523f78390360442e7c5dbec50b571e751aa79c863dd442f1c1a52900ed017405539c5e64deb7777d82d141fb95fdbd871dc6176fc0afa9bd423581c8a71613590a7368918f24e4ae51519af4dbdf1c5376091e5fe0b625053b9273d2e79034c0f451a6126a9dc72368a7b68c89cc2c8146e9cf89530363012fb337838bd400574056ab160737df2db01d8e347b70c2a546dc1427708e1ae2b79a983d8c358835d30e442da1f84d805827cea636cb0ecb75d4da9e8dc2963a527238334ce3bb3642999f61bfe63131271e00ba54aedc5caefb1cdfdf1cbb94cc6d957a3bd7bfbcbdad57cde087985bdaa3a7b14572be519afbb39e9fcd9f73704daf4257ca429403fff8f1f941d20a429aab82c039e8dfc12dccbf876e5e954029337ed9728c90b4675b0ae969143856ab734e963c24f4cd397e917d6026c6153349efbed924bd913ee5f640b0ec52e4cfa5163c9db553267993f73717c63c073681c26604e1d12912aee98a0ada677ab5b34944cc787cd994fadcc279e2fc688eeb34bfc4fda216e2e08032fb7ce1644c7275b0aeffd723c1582e8eee767564bae0c86fa1545fd10be5df337e143fc3ffa81c612bf963ade7e2c0a5c7f71d96c98f5fdbd84ab3ca57a920b220bdb0f0070145a758693a591748665190a8dc2d305fb62f8551c14920ea655509611ff55e208381032c23a824ef04d8657e4072a41a06f493552b0233059bfb98e69e0d9e6ce4b793318cab7cc89d3d8d04b560d370951c689c46e7e901eaf9af7ca3af2f3d1be39a302dc7c2ac9766be78d3cea9a9a4183074b109ec003fbc771abf8059e5b547962cea43da299457ea6d41bc2fc82e2b3a0687e81b0a65802b64bfb97c61181062cc24b8901f881987c882e34a02845ce91efd92e5cf41fc38f3530c5b4e80bc3b5ad67238c0946023810b6c87c2e378598a09dbeff9b9023c01197d947e676daa32253f6920fe6716b9bf8a777f3fcab9501c9b17f6feaee4252513a73794f8b06c0e121cc9dc4fdf3e06277180395c3832f776192d000543d46d00e40b452a1cb6c73958099310a44bb1e2e8fe119edebdd45621f64996904d3f15ef1b3dec2e1feabaf16b86f4a2f5237210a2936f2e9320ee7eec62f05dc262239a70b8f708044e5159815358bf863ed85abb54f00963d75d8ce5d7df8bb68400dc7b5a11c30376a9f7c04beca2626cf059f7973702d3add1c4e7c21b53805cc4306d0c9bcce0800e1ece0c015362b6c956f144e7eb44d0848b3dd2bfe13d7b1adbec82ef63a190d20d937c8a41c8ea9442d29bc4c1e57a2eb44590e76ea635d6128fa804ab00b033faaa64c72b8752e5b5b3d8b30728a98efc3b30a5e0701d8d3e7dd6226ff59fed2fe3fdd3e184577e0ffac4326b887b5e7d29458f3da2dc229e44f971816bd9fe317bcff919c7b1365afc9c5315557a7d946dce8f283180e8d4d72d1245dcaebb041f7454470e5f12a84ebf2563d83a2b5e9621d306f288d2fe5f218a7d5d701ae96d0ea422e1d28559b94d8affd3b2ea1467410fd45b618193823cbb717918cc9f57a2e7784e1223899bc25cffcc07a1e519409fc14f833367ac697bcf2ebb7ba13bde24363f85c08aa0b16a480161b33c802b659d5c37fc8383d487e797fb44441449a12c6e461369928ad1a595a258a936d2d2070c4c7b372725a8a554657271060ff429f5356ebc4371bf8e1b24208df6830f804fb1b5099f0b211669f80922c8adc29aeab23557402f2588709edb60181f17b2d1f22911e4bdb9d0cad209502b157254478728866b1d28507382e354f35a0af533845f7835fb69c194a15d8afa4d7a3410c2f8fe57cb12d5c74875bc390be53ee59de19df0f47a0a1345c73f9d762d65e3ca16b205b5f7281cb39c7a5d07f609249e823bd9e06c3f82765f715303ba29ba96945ae784ee8b21d57aab0372e98b5092e2dd1a017939375702eb71c075db7b86107298f62f597b2f54649a6721ff69364162d6e405e58ab30f7f0c7bb9d3197eade843409a0b1f1a5d15a10316edd0aeaa4271ed294f2e404d989332c018a03a263c96f2f84a441fefd749e8aefe0d3ef4d0e794546b96cdb04dd734f847674df6754941a72b10e941d26bc7dacd90d2b00e9a6d2db6c3c342b195b34b484cd21f78a29e98cbc14d1992761692bc29c6fd311009454b9065e55ec5925db7a740051df5a783df0361f442717544d1884ab6eaa8e150138f506198fafb1bec5fe75911a55a8cb0a3c22f30e4df999d3f4a312890c4205b4d0dc1f7d0cf71423f10cce263d021dffabd94c518287ed19a92cdda44bd5a1b9bff94b2f0555ce205819ce2e4eb9cc15d78d218b27305f2ecc49b9016403b668377ac95558461de5f0aa57a92e6382005886b89929a2977561720340fc10e002d76d80de877ff4a3caf7a5c0d5f930b773b1b55c4f5d6d16b149fc9c158f62c37484d0876ae9df841c96bd20edfa625e41415aadb54636caf4eaaaa512fbab59c94206ea37a985f382debb6dddbcd652cd5c35ac91810cf2759e1f788bf0fe94f77aa62c6218a82ee7d88ad156ca7d368f8f316cc017845c7d3f1652697e8b8691714e5dea4dba6504b194ef5f79810433a49bf63db602fb8ffefefbadf135154299a591194717a7fad2243fa35e32da4c7cb6405ad71000aced9bef12bc1ee8308ec84fecc34e17afd13bb3b00f317d52bc275888e8b80e1d7003a526078dc98dacf5c3a7687cd612d640b218388bbfa937d7fd36f7f103c60a5b04652c361009069d2a6ff0c671990163bb83ea2ae55a427e443dd7585a306b8541c163460091d9411a84e7c345b509a36f109f305e23e70f5874b334fc5d26888f52e2bb0295ebd6809ad28d8cfc012a5b3b5f412763113801abb2be8a5681e26f29349fec5b2fa281e76723d6fa35bd2fce395eac9cf58e2e85963971ad771465848ed243432ffe80cea3ae9f7a31d8eb04037e5e83613156605c12234535053fbe5244442d3d4ffc52e53f3e56cdfbb2f05a46f94269eac282613c818f7f0bbed7a03795ac689f041d35fcfb0dc5543be62c2916ddb47fd26033929429437d2d2628f4fef4d0e8a2aefb798b2296c4a997b2da736e8d078630908c3eeeb2648404429402918fda2c67003ee2fd02544ec72489a309d0b268d8b6dc153b8fa2fa1d8fa44161648fae57a883195a663025daa3dbacb7b660767151b72579bde6fa405cb8236018ad0fd5ba9f59e29773588fd9722dc43ed1be98d6f7fa33f80bc4572559f3e36436a502ee89aef69920b29d25e891d2f1a429a1ebce2ede0d7795b79c5e01385d596743447d239b2a79df92ac96c870ca9b2b9cf8de371d258aab6cfb40f5d0c11aaec9fa679753c5e63a331cc1e4f5ecea7b148627b4d9e4d1c75fda7f7763be9e5cbdf66d80b5fc7432b777d04f193fc6b4b176cf7570055159c541fc546a8501798762c0d87edf5e30a2188f63319f382fd836bd1a499843a7ac25fefba94be62facbbf819c828d32f868ab822cc27426e11c922052ba97ea5a696a6713dbccffe94a1455425c4cbf69b116f6f87536cb8fd30d6d41b9ae811a064a4af5904fc4ae72fa2ff24f48a5ae129564127e67e80226221e9d454f7206f919d735a5772d52db3bec482baf64be497cbb1c593a8e8b37a6e8d816ce999dc68397243fab6adc40cf9f2115e7d9f1e7f8de819d140971ebd8c30ea26a0712f30b1b4d6431b6e52405498d4a99fff7149a1ba16064e46bc49181e5a3866786bd6080ae651c2aa43c5ac6f5af86f1abbcd6f19dec9851015bf8abb76c2f73edbf1de5d61c7825c1d676b69addbf6d5ef6647cefc91b54220fccd1219db49d1b5d810f639d58c4b48cf61a21e72bb8bb9cf05b7cf072e82b268cc111936f2d5918016934ef596c2d71f308fbcb9c868c6b8f02fbcb1c184fcf957c32b7e4c8058313523460a13c1c51ee06d712b555d30c9ab7d77196016713bd5ca23b250121d793a3d64ad501b08b2621586823a40fac9b64aba8de60e455f2972f5d9ede6fb5dd5f938298262aa77eaaaf4f18fe875fb3b271d46d94216e63e9e0beb2a2810bbe0c43d0326b515c419c58d9c3d2f8a9da758145c8b542422a55d5d47590da372c88e98a305c3c179f13fbe9dca855517bf80dd34c481f60ee722f213bb7225b1b254052af111c472120ce12f66dac44f84bc26d729d58cea2ab4311aa07698a19b3a9fc88a8959210500d1e5b4c9562a5a5fb37205fef5d364be04b692abfae5d645c860e6c9ae32cf82912eb7f435270bea8f1461ac1e094846bc63c7aed019a85e7821dd428dd2696a88afd922024a7d93631dd7000e5e93f91b17146a540c277fa920d09aeafedab66ead05a79302e78c40ac74c9d6d8fde15f43704f7b3ce6bb60cc8ef79c4a5c3596ad28edc61271ea84194febd98da7b4f454137818b42de9c87020ff465d8fcd826d8cbf8d90b25673f92460654b81daf2b446b7a2d0db0b5c8fc4f774d14d3b6e2546d32392157dc958cf40a79c1c9a7f0bd950bf02923fb0f6f77c4184b37c0ef03e155fb033f73cc0a1da0d99e51f905abf8994dd75945fbb93b9d171cfaed7876f76ed3ec4c2b2cae5327651ed16effa9b29f58af023db29a682586e8438dbebc304a20ac51efd1a4f14966626e42a59e8d19d4b54703c4f80eabef9046e9b174aac080c291218a12fffe39a0e63a1093ef55523ebd5e49c3c246821d351b51e7b429a21b78e9c728157dbe86d5202e19f165416d4223d72f555d0399e3bf21832a6e92a92d29d68878be89762606769862980eb421250421034c4c0a023eaa5a997621eb683d6351e8cd8145b8b02afad584e99747c648b3547663caaebe009691b114d32375a54a64fc0f75c9b786f31e3e1515a1ed71dd5d20bbc807897d05b6baeec2ef98d7bee46a25f1aa639d95d1f179f74a65478e78b56e149d602d168d1213fc0257e98f43be4373c03af237dfbd75cb0dbcc6a991d59cda960824008a49f6192704486b0d429789133a46e9ab703d1d1336801eeda38bb253871fac0f9386485a93df3a8102127209d198113d4d92dca4993d9fc5d745c4611b1642b22ee1724747cf453a0a5bb083673106d54ce9ed19b010cf0207fde5fe3f9eacb5ecbe4e86b87fc5061e24fcc1f43992055289651b3c7ae94d9fd42a0156ad81509d17e2771ac5dd05f91f86054483af6284ada31b55e2ce9eebaeec7115ccdf9cd7aac15916e11010421b5ab070b8e2d1bd89296df07108f0b230165560e5708f8429496ef9086282b16b095c271022c7be2245170375a4ee1d70488ddb04ab96975375e6982c2ca45407630c57a7bc6752027d6dec003f250d467838cf04126f04dea1a58d5633b60bc12902e4f377cd051acba454a6e2290699491854ef40834f5ff8f5a08787fe1c3bd9ea35cb7673b79ce217c730b1cc07c349d5e8a13e1e8a87fb516e28790cfb892e2d957441e3bf8eedb8502a5612e650ff8468ccc1db27999a9b2e83f6fedb8ae060b7f744552b0788ae9054f7ccfa1cbd2181bf570dd186c04877284eb5350bb907d6363d6cc5e1e534ce044c0378c5df1535a0b65edefbd19acfda6eaa59552870462dc43c99a610899052e1c76e4be0bcf88b4ed2d5834b66d0e85f84d02dea7dac3425c5a7281b9b53b8decf68c077e046babea11a1fbdce73bd6454465d99394880bb20e732a3f0cc051d05d966046bc76bd831e71bb17fbfe358d0052d71c4e6025ec5dcba4f76ae5e7a099d48fee8d2545de3a3882001f8d467ac4f57c82dfc7bcb1798829fe7e5f83f0ac1caefa99e80d17792b407a14fb81b311d9df57f528b148a20284aad43b096cc61f48b50c07af3a2e1c6aca823f8aa7b16a239655832ef39d41f70e529d000a98e5aa94870d1c63a0f50ae687ac494715df461d0077f3df5dc5c29c5fbbe2a55916f7f878056e57d0a60f56d10fa775f926ff7de26fd137b1b913ea1f30c680e5c73ada1ac645934a5a91b858ca92bb3e3c19a2d81b8bccebd69f5e7d4f1ad53e651fb652bcf77e8d414950b0517cacec6272c9c76befa400dc8cd7668ed61f144f7a1046e681438b5c7ceaacef5a2d6b066736123f30421284b57afe140d74700f8a9a02a8564ef0125650a91bd82740835f42a2514892d58f57d93353c67da286628f92cc9e6a8fe4b22b24edf5a7eb9d3307a3bbe4c1bddb9e7a4058fcda097109a0faf61afe183fe89add20c8397e4274c9251013cb5724d2b81386948ca37be911ef4f995fafa89bdf2359bf5bdb875119aa85a0238644eb7f92a390a4e082b0207440d16bc2b0409b528e9c928580f16ca1508761fd2735e8cc9bec5299ca3bd2221c53f61d8a1559dd6dc71c1a78b35df13091faca89ecad846e6f973541c545bd14bfb0d57ab1906cb5be22591e9ee557ed99ad71cafdb01d46b92e7f46eb718c0a5c1a9f9d1e379576295d0c6178ba1c98742123eece8c56d336147d6c6ac1bbf1a9225bd30f6a2ae4aca91d4c22d44dc05ffdeb91796a56c459aeeb6feb1ea18c6ce4151e4ac59ff31ef0f420de1d247720ffaf2f2b3d8360b2a632500d4996a77e5e3c55b89c8192ada8d7b4fcc2e9e50421e3f169ae8515277532cac71c0d5b96632267490893f5e6300723f4bc7463772c05cbc9ad5ee43664e2271ea0d507906764f4ed166bcfefb38b27c7dab59a875b9c2217916a65cad570d3bfe5b4ed0fd0a415706bf6e8a3acc23b6ec5e26eeafbbd79aa2a6cf35d3372e57b1bc2fe0f84feeaf873162a794b3b391c76d464e28a7a3616aaaa05c540fcb2a557077d357e38695068d5dd96259a2277ab7c82586379d32a2a98fa86aabe0e7f2f46869bb3f4aa072a0ca32e23fcc1a13edbe1ea37c36281f5ee121a4299bbc3881ebca191fce9fd118726b5ad7a7190f06d03a949cae164073cfe265f44cda8641e5e13e5e7b2db7ac0bbc23b5aa5e632f170840de036c1a8b34e0de7f5298b057e457cf29ddfa5e65b0d2d6e117ae670c1a7d9d2a719187361150e7587a88cb454bf5044a83053943d8584de9d5fe123864344a9bdfbaecc97fba6209e2c349d4a5af97699ad026ae1eedcc4d3f92c4c3ff57fb7b7088610d0b874ca3745820c9b959665364e3e490bf5f21247202a10a08cca9c30f05c838fcde032014b559fa12e28966006f557ba0eff7e33d5bb95d16c0f5873a4c84249acfac5710e732b5f6aa9a91ffb04c53dba6a41e98498a71e898a288670141f3a859d25a3045664b883161416412e3f62a153797d1990d8f850f663c52ef0a2fb9cfb8e9dd1eb8380746d51c9cf66fd33e711f87c9cd6c72c59ef1801820d5d949c51b25528466189dbbf0b94f2e4076f7d22daebff7f272132da73a8f86c3baff27370cb8326dee1d053d6fe32da228fa4febdea07e45d93c13265f19a52f3d822ca832f05ce24ee6bea3f859376e8841b84df7ca65a55169a5333fd18781f53992fb028ca487d44586240f4a7bc34745539dea32d25824ff8b9d792495f5fa13be817f052ef2372481ace9dd3ebce5f30be20b83e406d23c3069a4a6fd19e969dc314078e077f1fc1e6e61755532619fadab81e1467203d4e03c9e2c917c1dbd800465b0945d65f980c47c1a74c8f1255c1461a2e41da84c59479c2f70c89e65503b71649b322fc0b3b299dbf43f4e08fbc96f5801f6de163f93f82685d34c6376de5360a6920c36ff88a832ac1827a955c6a9f79c150c3392ea42733df5131ca0ebcb4e8326163b22cb3555b3dd11e815a329042edf9beb311a7252ece5993bebab93c784974be61324b0b8345a46b8d9b30301104f22f9a33b96c24d1215aacd0775ff94b7b406a18c3aaf004fbdb1dc987a5ffc9f37e86ad0fdc0bf74d34ead84ada35b37a692dbf0aef003d9d571d20cf540e642a940f4f796055f678adbd38c675284bdae355e0b5c71aed274ae311b91a210a013fecb47b09a57b6de7a78d50cac12f55d1b1bfd702cd79f9fa6e01a8ef56f3d9522fee65af0460029078cddc22b9692e64f0304c7595d59a33a708e807ee388a9ad8e190834878e649d8b7e9533cdc1cb7f82d4522a12eb1c66ef11a62e0e1fd21079974340de6daa42ba3bfcec415b80ddf6f3c76d1dd116b31f2e187b036d3310dc202ee68637ca38aefb819980b7c254cbde14ced657c4c7322e82fcb39591b19f6b3502c84891ed8449de8045070f5d9171eb24012ffde20f1bdc6744482b72b159b059febcbddfb8eb074a4e6db6ae8bf3559bf358a13b2cbc6744b4de6b01426d923810f593355f4cb73f6d1c6f25ca8d14b04a99481bf76a5ac08b55d229ac586ed6ce86db2ceb0e77cfe8a9ee9502f5ca053452048ebec778933cf13ff272effe1811b96246e1d207b8b95d0efa3fc8e3e827c2c3f3db1a22e8b3b7e92eb7d93a9bfcba8dcd790fc8f5869c095701ae4d6aced62b2117d3b9daaea0c50c0abec97f4ba4b1609b78b6c2ce5a995f0608ca923fecb70955d4ad5c49bdab204e4fae5f83f343a3402a00e7c814e74097e0e7abb5079bc1737d4548b76e2fb51a91a354db40e6283c4c91b1bb8223ad79df0a93a6dfc130c8dfe90f8d5444f2bc65260c7d0aa363396d19791abc4b0295bb9df5b639ff6aecbdbb16b84be7a63994bccf61d1442b41a5c0fbb432a385010a3e81bed78b3ad05423cb0a7d517958dc099e09cf314917d7da8faa56feb9f272867c0dcf65c8516288cbb6ac1c2414c8ada0798f62e9c2a597208b728acef3cd6337368824925970f06f1dffdddf90c161b4c00c31827c2b0549dc19d572c5284b3a787a36ad0c09e021235209b31a0cee1414cfe112848fe76f40fb0e6eb3e4fd07d461e81c6d60fa9eb404a77e947d9a379e3bad0c91b8610a522d25c8f433ddfbbaaef704ba0c02d1e92550dcb1a158e1aaad52d971bc2d86e986d446ba072b7d88d4c30430478193ebcd11faf6f63391bdc5d6790eba81356eb275f1004de3ae6286a263d39089425041efa6554e227539ca4a6bfa95fddf66bde03c64a66207578c9f3f415982b4cc6fb44d81e4c3307db5285db79fa084fbfa96069ccf51fecabdbb22c99835872993c48dfadbd7ae4de12059011534cbfadcf3b8bada2a3aefd88eec8c3827c9aa843c815f14545501a08d2ca8596f6cee7b4ca84d00c781bd3b4568d821f61bc314fa7e1bbdd1e34721f8278b3ce9ee644e63fe2b1ed09a216036599278584671a6cf13ffecbb527906c5d2415fc6477e4d8273b0ea8ac1b7c32c4e79e7c3a857d89b55c9ebb7d1f498e30ef055bc5cb84947f4ac8f3e6735e3daae71e854450272db5a1c9101c203b9883a629ea24b612e92ee662a379c196135e95c60c20a709804139e96991d9dff3b8b1e245eae6fb9d24ebfb76c15bf8c1c6100cb632f221f58f669ac4066609c483ce10020d15b443b6759f87d20fc6c6173c274268bf03766db4e6bc30a5267055278619df9776e61a23b7fce1f55dcc8adfd5efac966eb66794bb2f12eb7198e835e806d48332834547dcadb11470f4a7ecd14bf43eb551e61cb7d499b06aeed91d5edcd445a5bc83884f82bb594be394ea590d5c4af584aa9518e843bf0a6c2d271a9550065a54cc608154d166670dbe9e58ed41b5e8ecabddccb7df5c6e3011f07123c23596edf5832a5f5a112b8a429a43e518b4ecd8925effcbd239624dda9ab0f2e64f752a15bd202bf29bd5bd5cb660dd281ab4af9c4b4c2c2225d20ebfc23ac86f095ff256302c71f3e8c1b61980cff244dd5b200b5401da206f490eefa7e6161e3ec676f045b27c2260b9231af0bb8b1d34204f04ca52297f8bbb19aa3e4fed8bffb52b79daf76bd63b0aafe084920e0826974400f8021672f8210da03c182fff624f9865fa85d3a664f3e38541825ac03dd902c26508ce36961152124b0b5f0c771efd641e047070841e091155085b0f85278496b3226633f0795b61bb8394cdf898cce7dd3f6f867a6bede031a9d41921564014ebc85d44b788895b3b333ab68a1623b7384f65320b8e7f0706f24a149f7a6efa9bd11dfaf0c171b3f258899533302838a0bbb7d50b2e056bceb1489086f43b57dabd290c0e8f1a46efbaeef254800ad2979d23c47a1557ba6d4b218650edea5e74baf8c813ce73aefcbc6a22d4d23d754d937f9ef40883d6e3fb00261d4edb5b0262b29b6f38d87ab4b5e8696a913e38ff806024c27d77a0e6c4b5a05fa04d7c5510c40f074e0340c790b998b1ab93e7792240f45b2327aac47ea2174dd208cba75afb030b336b68e1d14c60a76d7ed10c6b4cecaba1e16942d29937b8bf52edff47be37d24d1782268d99cf5886f4b2fe952064a18fcceb970d4a407559d70baddf61ba57162063e01b074bc72736ca49ab46b1a18a2add5d3adf5fdb17f7bbe3012eeea59a7e0f907fa671d092bd7daf4a33d0390e166df613c569fdf6dafa63712fc9ca835d6a7fc54125632b7c61cfc672c63730863b5ed178fc176d54e8b4e99d293b1b7cade79cc6a986f7baabdd1e7ec7c2b92ff258f9ad4a8de2c18eb5a32bf394a24482cbcbc6005f8ce75f8cfe9f813de0f29a99e5b0b5b407a884efa0b140fa4cc94da14272dd489c1ad82469afb016e7903a59dedd9d54b9f5b4f8bf6906eff82af05aa3d8d2c2153abba3d649e839b379d7482d57bde08fe10e16566f69b2e3429204bc79f178a46ebdbe331bbbf02196a95e864129d01ed2ac262b7e313466f9f4a4a75b55aeb9fcf9fe7fa5d71d6b7f912405930f0de6cd5ae91eee04f2cda611737c8bfb9ef3de50311116f207db42ca39d6d9a68d628e05380fceeac80e795076675f6b5cfbf4c6b4ef11719c1f6c951da743a0cd0abfcfb32faffbf63222fabf6aa8b88f1bdd1934f4fac3722a2a726e8e962f4a2433d2310111586fdaccf939c7b7c32196bd679eb5036a57b429f51671a1ae2f50d9a7b5b37b0f7b52870a6bef5562a4c84aace5adddd157b08572357cecd343ee203374cb200851a80ae1ffd88837952dbb7e30d0af72abaf04636a98505828fe7537751c59e3fc99b3f16333b99985fb0d9d7fef8182f8e93e36fe8bb7eb0e184f351bd3d09b775fc38b9f0b9ec4019c396c3309ef7b0fa09e2d6461d1e7c11f13a08808ea3a7c9295085755bac079c33c86fdc42a8436ae6f3597bcd838f9295cac67ae7f05eb7bcfa9dddd7a1d78034418dc7071dc5b5a9c44ce0af03eb997d33e088028f6a321cb192edda128fcce4d74e3e43943561f8ff9600ba465a844e5b92d2d57910f6d9b8cfb21c574b081daa18ca9b9d70048f6628a3a3bb8a533600f83ad030b2d8d7f41dfadc24c5dddbbd1b784d01c9ac4e3a5fc412bd53aa4672a202576bfcfd75dda848dd1cdee6c65afd704ea38b378e914af28dd5ad5882366f2ee563916f7a99c18dd61b86e1c4f9168c16a3119b1e66762c51557f27d10250641e4e91e43a0d1b9b10c2788675b59bf60634d300a32c82ff5a51ca2f6b69bcbc21ec27c36a75a0298595cc2d0fe282c9c5b8a95461b3fe95ad1ff527dd93c58c4caf0356709a5eb9e4d3874a7f33ea38c4ebd0b362f98ce867cc970eb0503f1a3a4c0891f0b95d1c0cd09de85326bbfbe490817bb8c12335165bcc3f120f3577ee9093bf55c8b1f1209e82370c5cf4d59154f0cf41b5aff8db8374ead9b99aa3bdba1d022eed6b0e26db83b4d86e73949c9684c5fafec46a461f2e606123550d8815bc79b68bcd2513f1f9c0cd3287bb0f1cb740927c9ea28178cf349fc0c629ffa5ce11dd00269576b23817f60df6a023ed895fa43296c41e556315dd5d7f9bfabb0d41842271c4ee4eb11b0b975309db443f18128ecd090238d667e33c804b2b85e05c86e28f6a48add8eedece4c2c8113d669a5bd739f0f8137efa6e58679a64a76be948fb7179f53978dab151927893c5fd74e8ea0a7b9822d96512681b71d7b455bf5cf30a54cce0cd631d4aec23af53901ce45289bb87e7d7b1a3d522067183134700cfe21a5d1e069dd313c32bdc1716b5fdf67ad72950aab5efe1e545fb30fe55dde282f74799d011257858aed3053c22c836be328bbac4f581a57d4b0739f3ed597fc69b7248223e72736c95de26d2edf167cd2c47a23ec7fc15f2ca1f22f13a3496d5a4843a091901c0bad5cd8e47d85923685c156c9c1c92724f9e8210dfd4f396ae3a318b2416c9732fd037f5502b30522cbee12cdef920232e19dfb4ea9a6f0601bf3627c40c87203a9b35d4e27066cd396611c8f149695538c06cc92b046c9deb0bcccf0d9fd3bb46ccfdfec1d1251afe4efc14ad5850ff10807fd1139398c16c24a838811c583b75d49a26a4acc10a30d89848bdad0a8c8eeea3318742ead0e3be77f39b5e79c3c20da7beccbff0942c2abcf73ae7ba21cd90c1ed91a4b8a9f96cf149b00a48e9db77f92e1f27740540f82cc87d41df5560b3c6ce6d055718b0bfdd3cce8c25b7e2441c8728d92a1f06748c8b25342bf5981785ad944184454c9e5d4ec259eb239635d95a69eff608cc85b5c6bc11cd7b7050fae3f437ba8c1c35ab473f5f488194cc80f94bd128550d1c5db6a23c4aa55bd0d80ab282652107f2ea73a8c074a5ba75dcc5a6830c28832633794637213d5eb377f5f91bee7ec5b33a26d9d0c4b625ba201d2891cab740d26e749d4174a91f6e48b53d74b273d29661045562584558bfaae16f1eb5a309b7c0ed03fdc2b7c89769ac8d55a5a094b29dea28b2d054361a5ebbeab99230b52310e381709ec75706e72c295ebf7b9a9fc5287aaf9cfb8600f2b3d5bf0b71643c44b198bf3311568718e92c51b8bac2892dc2500e6fa71b4ce2e9ac8a35ff86b91352dcfefbcc05ad8c3a36575e1269267b521c70cad6cf5cf5f046ffb4473d1ef1a512f1787105c99252099a34529da115b9a4b921fd95f61083897c42ba9b6d8a5ea8f5b2fa09be4c0f6d18d1502de70e780fe86486e0409f027fa02464f9bd64e15215815f41d151b5ad2ba636e34dc42d85db51abcd809677db12972c97b66441c8eb29cf0d334b9fb6cc905c9f136165e6c0b274b4bfd2635346a009f378d5edeefc11da2339b3cf401a0cfceba00253c34c698ac5446c88a3e06de03d6f7e62235d32c37c504e2f532c21a3c6afa259576cd2fc7aafac8fd8fc5503e860ac8fa43bd8e433ba37bf8f558658d5f75b576b3adc0120ac997c8169b754e742470f98ea0dd126f22949f77320af9a630a7d12ded02bdd105692fa697c58d65253f3db0e4b0267615c739178315ab9b86116a65e88e01666a2dfeb119a256561cc4b171746f2da0917d84c55511f81126b563a9c154bfcc7a56b6b2525bf8adf8d2f1fe36e1c763bff1cfcc38e7655b11e783af89d4666bf075e0a9615cad4f1cb6916b73133f29de12daed03daf4bc632bf1253a1220a9a8bf463b7ca84154d79865f58a954f6567110c387e82866bb37aa7b8aa3deba7eccf82cb95e777ef06af459ddd0c65b51dc20403e7fb88490d79a079fe6e802044ece4d41036e9f1c552558f470384ced53f73eb7af1a890ff28490c19b0fd2b9baafac1ef645a37c0af515603bd913de9e4339f9fe0a36b45c582d163998454f9a961560d7760e00440944563f9872afa502a70c847365a3c40fb656c631f8d454d50d76fc6caf952739f744d0e2bdb76fd2f3785ef3077e0d9e7aa5edca4dcf9551267ed63c844e7b452dfe50885600c14301ddd508486910b929b1fef7d8894999d9b5386f5c6f644bb5f8dd1ad26984c4ef743f54acb7b08bc548a7e29f669428603d901356cd9520eb47e1735cefba908642748f60d2975128352bbf68498c9d883657bcb1723ce1d187f75ad900f2ea85f65a0657b82cf4b01624805cc8cd8e552d473dcb5568e0059dca21f98374dea8fdabb1a6481602f50ea5377f6533f5f224a860ce68420870e9e7e6eea4c9928fd8193cfbba96cb176f9dae2443d64561d500a7de1e470c4b377e3a5851b9cde66ab82a4978e534f49b552bb2c506f2db0e5e65e2d3cec8e30fd80a502a451fdcafd1a669144eec7633cfd0a05d180e418768c5b9f0d61a5605487e7157c269b267cdff3419563b300e3fd78c4b6c2c94abd139d8c8b9f5ee05ed2d8d5669e70ef12d93a3d43f47878eee4437524ab9dbc1debe31e3e04b2fcd1edb01720c9a3355b636b485e462578db5ca3c9a24cc431cd2bdfbabd96f348856534d9995042ad09de57c981acb8eaa03dbd75fc1117efe1d3520e04af9baa4546ea971aa5d560efb86c99a5657182846d9e7d6fe28da532a1854a5ae58566f586849fecde3a57e65f893b640a95c94240ce5e320a68155f4af5e150b5a6b84e43d821db7206703d3bfbdd5a9d3fb3d6a5405504a3d09db643f28bde75114e1f914516a8b76b6f408f06ad35d3377c38e44da614aa56324fb5d3dca4e00623e09fd6f29cdd5d43d08106866b59e58d068987ce7d68ee0431dc6625a76f12b6e680faa60f31ef6e718207c14c18cd43b4860c5e24729377007a95371643a70e2a8ff81250aab96cc4536a0d8cd109a696a5a89031d84cdbabbfdb741dbb7adb192290122fd29493286dfc9521de694c97703f30389f96d80e6df92cda9266b1fe158ce43455da03813006f7efb015489fe5d2f6bf2468ac3693c6af96a67d4075dd9d8f806a51958be6a33da59e51bff852c049d8f92c03022681a21c7eb15c76a02080e0b26af92566e77a069379b8e75d691fec04120a28239a65044a758de0941a461645423eeb9ab16bc7d0c565530bbd00c423ff053add05068301695366f5f73ba558867320bf43e8974d4733d453ee973cd8ec5c6979aa03822e7a1a7e2e70d7107401f00bdd61c2035bfdcb74141b87834557910751289486b183fb7928dfe3ebd05914a081894c9955291e68cc813030a8694197d5d4d7bfbd5e383ec79a42c267c476e9897f8b63521c0f9b227238a3b6192f10c878ba6db36061eea48c31b15b00ef6cdfc351f9c0e1d9923cc8c9bca8598f2fb08af9846c2fafc067a718c35b6f1056939823bed5c74a948bab6480214c27a46acf120cf65d4fa94e4b1807eb78ef681e0ef40d27f02f62c1e2f134c6ea5b55155df0a31dead857c35f5e754aae410f90bfacbca54f4bf7f3f24bd69e5c0cd55fd32eb9c022b927b6ba30388e52f5709398f9d0c34ddcb42633c72b42b12fe98755e84da841a7d01ee9c3deedd2f85c8625fff3badf901326918bb45fb9c2881da48836bfb7142d2e5d87c13d413525d872ed645a838aeaf04f346811c30369e2ea607e922fdb0a3692f8c074950f14e78c5a355b3784571a9794b9a149d21eb4c80213c41d212958806388015140c38c68dd30b5b48989d00a689c53e2d3b33e63389f4b35ee9ad3a13b7944f7d7e77a3063d37b02b405d19ce44cd47bbf26a3f2c63842ec4be6874980824b46fc8486609ccff238b6a1264e1a02f2cb73346e16f07bad5c317d6928470490589ee184ff6f1be403a8c7bc27fca8f6d1188d652be09dae5cf56579f43e8c47c4d441d9a7ac97fa80036b5f96fecd260de14ea2bd4998e21b2d27a9e195d3a5d9a4ed0243b51f41932186dcf2c36e4c94d789ab4e86daa375f1b4dbffd8ac4cd40170e79ee3c45715477df534f23a93b3ddca6f6ce12f057508692989227c98b2afdf000b7f9f65158b820fde07eb2bb1d17f9a2d9e30b0450c538d46fbdaa4d8e44defbb28f13e66b2a83f8fa6b7cd298cfc68273ecfe2b5f63562c26b2ff8f53aee8185943bf3b2b55af26f3936d14119e9deb289e0173d0af575eb202553ad9faf31acee9df6111185af1735f3b9ccbba6ffd96233bdc2f049e78dad40fd90b64f3c43ce1d5eca03dee98f1d19744780022e669aae469e0269fba9d9c01bcbfa65558ccb5c2f4d4114d7bcacad8776b1f5b7d2b8cffc066878e55612e02693aa6e85c22f7b1fe79361fef07065606bacb1ee3200dafee73ee4d6da39194e20032ac29aa4c5f2016f0949f5fe0a88f3d40b7c1775df4ce8b70eda3a5ad94e9eab98d642e26fd35ff2ee0e755fa5d872c1bc629a05eec7009d9d7cb99f198ff7b18dc15bdf24b973927d8efcafb89cbaa63dd7bf58fd539d77c8bbf9b810b92ef2b36d42f988ebd497984b1e9600d703affcff3f8a3af8deee638e10eaaa0fa68787c93c19acc5fb4ac232c22d88d4e6c9422983de95d5f46cd9f5fd4952b935d90cf123bb8151b9a76f40a758fca8edbce8a57d76201b60cd9c6b824fbe6a6693a67790f4062061df084e73694a12f075c2e7c5dec2932a9681c72ce9539ea5990dc2b9ed3055e4b5a4b909ad46ac6dbd761378bc85bcb3dc6edca518bb456a4451427c455395bee311e913e3cdfebc2ba3875761cea4928412b9550dd05218d0f46f351ea7d4f1f346c728f10a462aa1e813e3eea154f189939997fe605a6f91c12c86da217261aeb01c81bbabc0e9996799b662fc687d9a0b7c22965c3460fbc26b267149a0b7bcfcb8a22013e0d80d2ef44c7f0c3e43a7cf6f64b7973354ee698d65f137c0bd49be87efbe7740a64f1c61c93b6314cc5609e58e442fc42631aac297b3ff7638e57dceadd75cda144ec59b31a1ec9588abba9bf744dfdc64ddd5f31ec6a6c4467ab25e660a672a467da611ae799f21dedb3dc9554d4c60d06ddccee6dceab4da382dd2525095b283af32e099d3a281089c306301d3b7e50b05fe859b80de8c41158dc396f414ad43bce0fcaa6d1ae1566ef5776b254583ebe11bbff5d6dd85f2fd7c60d37e38c906f21f3679f310d6f82de219ac601474d86237f5ec5579a954ebbb56d76fd206783ff779dc66d2597d759b0fc75d97569eed6388cf8d2f05163e934a1a09b385a452934d31c1047d5a8a34ec46ae1db62ec4836036a5bc56055f47f527c650c0ece3f29274dd129d943739723b129393e0380d4d3a341e61da5be4cb4a6099b5f04f448df9c7c61802ab09a49683eed546c7576620480edc6bc25afa9f495562430f19bb2c82c962548b4d6eef27df616c7a3411c7d415a8d0565016d5fcbd6a3f3ab575ecd2f39b6a0002a876050ae3803d50279a93976ce86800899d640c5cafd1a1ae93b40f9cd8dbe330f4a387db943574525a54d4c8cac0c770d1e225a94a3599997d0b511d8aa077285074b83a93ed4ed49aa8141f2107f933486d1b9976c3e96adce0c7e8d39d2ce1fc0cdca80e78d06d87eff63dc28aaab0488c4e10380bbb2c02d74d254dcac231b28e735d6adb8cc323e7ddcae27b3e8e78f64263caf4dd88c1b7bdbc1997e85ea0616d64a91efccf5117c2347dabf5c5346d9568ef5513062bdb869176a9621f9bdcf820112d72b4eef6bf49ba01fac56cf4ea0c9aa4cb01db544789c6fa5930a29ef69b68263dd8ace1c8020c22c20b39c4944a500a19c7b406ea9cf062f62e85087a3aefcc7f7c26bfc0db40d0a081eb49453ceb93725ab6b95a7a4c8879433ae07a6c9b43ace2cfbee9f83bbbbf44e9a1537bb60896583c067b8af82339fc443ef3b77ecc315dd0ef8b23ecd23528852a5fcfb6ad5dba0c5fc3e1c672d801a2db1407af1eee2b87635888663b33de51b421de44f7ca26b64fc2f8ea1663f1e9fdb7aa1e3a06944133ce5d57abbc325c31ed851d20141c0e7ed254c1879bcd302518a82c81a6b97d26b790dbf40294bb24563e1015b53db3d1ada9d92c42a2428caaeb426c050dfd86ff5576ef1a686bce5129d6d7fefe6da4b3fd549a9448331ec6978901bea31e9a9cb4a9722ea785400a012300fb61fd166296f315dc062d8de2696e781717ef0e1c1e9b8af5371e1559629c66619157b30b49eb56ec6f9aa1c794971bd967e7b7c6ff4e9530f9eb060ebda0c4cade9433cc329cf6a7146bb604551c0c24d32cc11e5ff2cc8e41d1154179289a43b629c6fd29c2f3ddc705dbb458911a3132ee9a3928d690b2fafbd3aff029ee0d28839837de9846725134975aa4053d7fb4c5e49c1899c52f6bc6ec701431e0d43e1af3ba4aeea2d8e3a4ac664b5fc7546d69ddeeabc9e54c9bf89d4d6407a6a78f81cb52b92199a00afbf72af071e8a3cb5b26364bdcfa4b96ccb4b2854d4713ce03b7d9912102c48f49db7a0818cdd4db243a2c53dbddd077289410679a67491aaf8e533655277c380399e51a61b24f141e7bc382de1b3886d93da0ef2269991edf52a42db33697193ae150b2b308b9dab799357d7968276455b4f3c3c7047e32aa94838cea89345d875462bd12c75dd415c924baee259f6c0874e5a31856d46f170d6b9117546ddd6d57d54ea8b17f5a6fcf410b40ccbcbf92a8031b763df8d13a78f6f1c9d50d42eb6f2546dcfa3d684f15bc6a8261f8a23c658227d317adeeb2008043101f3be89024bdcb6aeb2d9dc145946c8d6d171bbbc2c8c686c39d7c61a4554e91825f3f35e7ad2f3872d154de5b9f93569d558532877e3fe552a63f0ab2291e914a41736b6fcd349a4397787f396bfe92c9e3b758949742159cdc65a85f308e4f0c2a64903c1e415a18fd91e82e7eb1513d5616f495bf9fce2a525a52b431420e97c31a140c4ad70b678263aad0f88ed12dfdea638025350c0448dd3b1e0f012428d0a5b1ae8442349c30c7c10221f98d017195cb34c3a74f4d7212a5a008abadfc542338a474bb29f31298afdc89a71c303c6297426215c44412db7754445623647da60980a51e37dc61feb426cba4043e92e7de6a5a3e9cc9b837bf095ede72d170bb4f6693b65897c27c69f947ab5f00aeb8790f43b099fcc5965fcc8dc51d82d22657102d2d915b937bdcbf1f0b957788697b8405e4644a4e0bc6a523554a3c6025e7f0ec7d9d3bf191893c00667bd0060a44ea24db7267688ffba0f18546c1283bbb44f730722fcb7b9beb638125b9ed58a380f73eebbf78f707345c152ab60a8f5dfdd9ad78414f93b6f9e9fbac2b5b346edb70e78d79eea4bd8422d9db32a7f9f1f50c3aa31ce2a09763c5ff907b1814c0ff4d2f706dfa6895c4e7404d3f5b4de06e2ff7fe30fe69d3b2bca96d71d7ae44514c98c40d4881f1900005b770719f23bca1822ce61daf6a70f983803ab2a03ae0f65de8be07163039b2d732c0513423cd05069c2a8ca7ff3798d623e7b4522242025e1c90a2ea790cc39d384be6a183bf5572038260e3414cc70cd5a8bd293ffada4e0100b361fb0a424df5090f27cc5353e5d5a501cac9921f7c186866cb1c7497e976a8c681bf8bbb2cb4cee57a164ed52163def3dd03b70cf9c7e7dbcce3204627d2f2890857f319dd3cb23f91492d7223b184a31621811a3e779b3aa2fab05a07724ce523ac8aceafdfc27e00c8317baa7bd89727fdbefaef94c25b64824dc9f6cb450122c28db3807c3b0fefa4169e14093086ffbcd8c9b2e8a172f0d4083f0b73b10e1cd4866a81ebb3733e14fbe30e65a9c1e5e591f420a75f2bdb3043192e44c45fd9526f254dcaa141938262022d16bac01ae25e0c825533e72d7dbd86b3a9d1f3ec724782f0e3fda2c6ed11466b1519e1df825996d449eadf3b9126cdb33451fd2f9fcd5c106bf1da13c0d4846c390e4599eda6d8454593982e97c23bea1985bb8c5bf86831485e00833aaaa8fc97bf610bf1f5c631d9271fadfcc7b7096d7837fb7f04da672b17827c500a34a292189ee2eb210c6c6b42f4522aeac70b2535784cbe183c8e8e508e9f4f4af467a911580d226e82516a6ec105f2fe3d71af7d740353b70be4445745b43c8ff5456f7ed8092e51e87b22d77da2c88c9083a38d62e4fe6301a8d936a3c1e82760b7886078749d6636651af04a5123cb1b371d15b750c57a93516a72adafe184bd7f5524d9b538afcb85d1580c18f952bfb2723de6b432e244c1c3c917759eb88d797e2f7672d5a8eac100d1d788545259a8b33c2c510944eb79ab87218f64d7a0db04e595eb8e8f6ba7beab54fdc1aa33156fb5619202f7b9eee11b65da9753c306554f266557a1196176ca5e246e0f09c40076259d61f6b2b485d6f7ba23bed162624e786a6b5d36ea9f768299b22a5951e10e98ee09a95768c2230e0a7247c9afe449bf5cf2a52373ae119d481350fd149143434d724a7d129a9e0299dfc58b8f5cbeed07573277a449914909a5d7e5228b2775624592eb85041ef3a7136ad86a06851233ab4aa13b2d1d652d8fefbd093d0190c57c49a4fa6803689e67ff889331c0789105c1c622385545c0cc4210bffdb2bedf9f5121824d4957d878953cf1f107b50bdaf903073690df1f54f8f243d429024ad2a22c55e56ee93fbdd0345de14ba2b76a5aba7f34444d23647f339c37ddec0aa22525f9beb300296d37099a5823954e42536406b7feaddad5e7b5903c847d3ceb5f6ff6e368f8aa809c4272f721877b2135d8c2f67cd24fb7b1e0b8c0ffbdc611dad39267dce7ff642061f1d590881aef058960be5c7b3bb2b2ec40de1b4a65a51884403ec3f9b421d5afeba9014efc3af8d2eb707e34b11a8bd2aa865716e1f56c7d121548cf6660b860fa53555e6a23e4bb7fa00d1bcdf03ed2c27838922cdea99742ab47e98f874b5f89bfb5687e2dc6c85f074160f4c6a83cba2104ecb01076eef51d2864f6f90f747ee19316d454ce5ba0b8d1f67cb3936e45e874cab34061657fc978691a0eed0c120d8c1046784fb01cbb6f3bcd06f3e56afa7f53a86fe17a76dac920736e4549fb66f756917b025d4838e74ec0599083f1ee527cecbfbee993cd9407d8c744b7a0a6e918abdc1b9004bd1265f0de1b22736b6afec75a0aa0e6cc4bec91317edf00d471fc6a7c884551f549a07605a42298c3056cb32f5b3ec54b37fe1c439f98543add7731ea2d4aae6d1af34b184f24ed991952c06e149107194265ad588753daa7179aba88712042e59af67fd9dd0812352b3307f8a50b12a0c074f98155d45fad4a5fc0e56987da6fe6e321197a573a70e27bbc01a57f21e9bbec84ed32a884c137ddc61d6257256fdfd417093cf930ee841a91ac185c92a07aa3e8027c537bb3bcd4456ae44afe504a4dbd1694ef9223dcaea9e1ecfd260c47ee03943aaeb595ceecbc2a186749900f4e88a149426ac2f200cc4e7b7185cb6b118087bc07e192617afe37bdce8e67b79f24885923853d73c20b6306b339cdc964ea483500c8c2f661b7f8fb5a0c2be4efc5cded90c426916b9232bbd24d6330d218bd976b63f41ee8c445e082f3a41f69e3d0291b85ab782d5baabeec9156a5bc4deace32765f91c2304b221e1107c70fbbdcedca7f9967df96cd80030928c85d6f05a52852cb272b16d19d3f03f9465e58944c56200a3b6be853d71635f8ac7a77af9d981612792862824d63e0b29338208ac182cae9eb5dea007643d50aba610dc074402692f3372e52115eaabcf08936eb595c26132419bab762702602132e04431eae187e0976fdc5c2fc3ae4baae209b4b3fe57f794c33d48118845ceef063a2990f252b78b0f4625bd172d06973b577108611921cffe58960064e90bb9ff80d0eac618cfbf1b0440df81d6f4e28004edac40ccc2bfbcab4683b02dd88a455c50bfcd97c404d933ee0391b157d95e1148397a33b84d9f9b88048a938b16b772fd586e03ca4854cfc203c428fb2edc9872d05a3a533557b2a4bbe762bf5a734a7a9cca627505cbbf51fd56e81c46d4114891585a60c5839584c36e9ae635b87f8e9b3d349d83fa3b1fcd21f25eb6765dca8ce0c38e8811b3828d719079a4385f3159edbc6ef50f88ef739b9bb598cbd3be54bf64914b24b6920363f437db96c72a9f337e9770764fb320e8fadc67792b7999f8cf3fc635b40e3645ed4eee273aafef448956f36cff5b6a030f8fde47233b338e771d28ad02c45a80c20ef97d55129727cf3f963d22683fd08e9f2718cddf3859bc5fc544ba7bbfdc5f46241e397c441296931ee8711bcce412a7b2f40bedc150369d7c4356c75cca58312f9b6e48b45898808215d536d105527f8d2f865f7481960fcaa6b50d4e2f67bb711b2067ed2e0628bb6c28ed93c453fff4baed84a281bafec4fbc74efe01b5c3ed9822ee3ae9c5edf2be6355452963287b6d9079335d6caad178ad90fee598142ca618a1ea89362267d7cb3cc67f1ee5e049a683bd8e2ff190c7e9eca113582d31419381437b40ba9c192a40ce8210aa42620eb055e2ec2c8281b1092dfd3a50b0ab318a2ff0d9e8f783135d865831d26cd4f9601ec594e211582f8097fec5bc3833baa8badc63e95e5c5daeea8ed6ac6fbd10a48fbfe973001154f759ab2df121acad9cf0019e9ddc1163b0bb1c84cc95a3b9e948924299a0448ed8dfbaf1d1a358111f215c6a275188de20cb8c02d4f3c5b4041d6577ee7803fce75028494758a1230f201ae9dbd22399713a2f31b0d6da2adcb74d244837dd7922aeb095abfbb6671e1ae7a1095cc29386130847677a7ff684bb873f2c17079859e257f3ead280455ff038f2b4aca3e562a643597de92ffaaa11fe9b62e4c31a1f47e5c970ee03d2fff77be550f31e3e131287b9178d69f045463e49b82e27d4881fbf8bcb5e32f2b2624e9d4aa27079a5cdd72b4a4755c38478e034df09806bcdebf7bd0b70d536cd43dbf25e1c98278f25339ae2139e4806557730a192d352b15dfcfd4f3fce940cc8ec28e0caadd98a5827f3da0c364f0f7df6d996d609f517df339c66da23cf7ce88fb9a6b6005251814d2a5a16665962050481dc679f1afedefbfa16fe97bdd9b06197b80ce13083102d4e32c3fe0e41215e32466e0d757243773491e756e01d90e3eb192f7f940f562c857f968f3fe25f44e9ec78971000ec04dba4367654537c7fb090d65eace075277e3a6519d9b085f46de9929f87aa9b3b07492b4b4a9e2b58b712ec5c309d225aa6788635699ea52f3cea59ad1f2f588721c939a5e592811434bde5dc4a530f0187f7ec01aa92ea5dea6c43276258ba5f130195cd3eda74b83e77a7d31dbf379cd41d1d84a0443d9d77099b61ce5a94e66929d169dd9a7f081e64fca4805f4723192b511aff1289c11525cc078dd5b3e087b3c66f9839b843a46cc0e21b84389ea912d3990b72a10626bf566c753daba788af7927313fcd45ced02171d922b66c0443c99dd48889302aadf5a9dfcf913c64289d4dc6db9421c547dcfbc44c0c9c8d553f62fc8c917866df8a53f70fa55e74fa1b463217d1cf045bf654873761887f97327a4bef08f00777d4209386c510b39fc741393dcd22e6e1fe6ad176407af7e9d9daf21e819ca930b322b6b5b96b96691c2e85a78fb06b6bcea5c0489335227499876c875b84adca936663283e290eb6d16e9d25b83f0541760aba51f77b3616505da6bdcfe049f8da2c02db60bea65c6d2ad3ab196952b909e3baef37f5f19deeac5ad8db2e0f4d8498281f14f1c1317c5616f66285f71a679634ec47b262667c4e03ff9d78d619e1878adb0224dc703235ba50ef6c57c1c2bc8a7d77aa1acaebd1415b112ba297a540d2841089a8caa5d4d434b944c34d3db2ddd9cee689d6d0876adf517ad9c197e80682523ae0b9d1dd81fc03053e4d26b041f4d02b3438b03881ba0805cd0bbfaf23e1259ca34fd6c548d58f0ce74d64ff595cb6f1202e8a5bf529d12db40d6916f60c4de94d0e2f08b7587b5da999f71d5515d95e8ef2e8702f96c2bb5520b928021a1623179e3fbc078592991504a6a7b58f83519db84854a72608a4cb41be56afb048c156ffd84aae0016de7eef337f6eefbb24f827ea7e038a27395580c4f5ee9eca58f7476a831f15d8a6fb79e7df5e091916e1ea73a36e3e2ff9e7c41c49c1e7e1f50b3287c2e4942ef7075ec9d16b0249d9ebe8430e5a4ea38be65a6a11b31ec1aa0ae1e6758cb374b4193e6399c299b3f431e562284e15dfb2b406ab0ac962c6f0230e2200a4de6fda4bdfc5f41af2cb45bd06ed0bd6e28b47f8afdf982a970a6f59a172abb67a328e32112b0596f225d14bb4ee750d6a6cb15dc7a557d54afbf7f2536fbe2f546128c20fab243a31488f65d77c0078d5e1d3259f0e7dff5bba0b9c9c3dce60ab6be0c9306329440142adea92f6156b1eb2d0fbde1d5fe6caf002fb5b739277a18383f57f468dcf79ed1258692af520ddd32e49c044517d145da662593db6903d4304c81d728e66c612277f9c91b82a1468b65b650d26512d5e868982bd9a54fb6fd7f4f6ce1e69fe90c9720966fb303e5e3820e0201bb95c1e0cd3ffbff863d8533900e3674cc9d9e9b8a050d67ba7d08973e9d7c4afff7afa11c07bc1b83fb9702566819e51220872ac304adc403902aace55a4d740e7a1f79f01d729191ab29310a35bd8be134fb86690eb760fea2b311cb25855d9b405c5904b6cd3550a605babdde37d33343aad7d4cfb9c7b89ba3a47bb53689e595eb3b6ca157da1f8eaa04ddc96c7fb9d22c95e1bd2475b29e4f7d4720c5b47995dae19db8fda324b1c7275de7792a0cfb1e5df495414401df722228f2d7efea4f834a23360fb98a3d830678d229ac087361753a5af71dde630efa75d44a4d6f657c96ce9997ebf5f064f7e64705d2d23595c76d1663d86029acb988ba7a62bc3718323ebf8b2ec934da9f71f0fe4a79c69bda99ccd5231c6bb0f3c662d901d30865bce0758e9bbc08b56e46851255e284c6c6b0bcbb6ba5b431df97f10f4ef5015f49ab84fd446439c0087c4cd39625002a30430ae1b072121e539e42e293c6a89f810476ae6a303c7f3a0848ec1c74cced393260b336644fdc1fa1cb4dfabfd6e2f44bbf9862dee05e5dc36fdfb61fc30dae6caafdfe9c50323fec9ba856c3a754355f4fff46802a116b84a783f291ac3d9374e9bf1d4c836818aa9e773d2d74821d34a73058cb6bd5bbf9e579d83d4743200920fc0880527b8a020505461168a70ecd4d3a56d869e1b21f418dc6c3d6038b094717b76b30d05ca91c89dcad288d8593d66d1515f4f4e92e648ea88f02e26f429ea20131f0da70dde1c5954697309a1ad2c1412ada33d1c645aba6975c023d2e516f4807f77551340e7f1c4ed621f4fea61f8169f495bcd5d794e7b7a1cc449bf391f6c2cb324be4eb43bbc328b6ca3def75b76cd404ae66748d788e1cc8d97c0d9f11030e84cfd6de6709761b36e65448fb01484e45781e584f23d479e25a86c62c7f88233d5d3e9b9bc5e6044d5fe298b5c1e4e2aaf9a4daa90e11bb84d4b393d076a95f4d05fe241e05529220687fbab1d25c9c3fc7cc9d2d933ace82c127afa8cc895bc278a64c45cf07c332a4844564f84c262bfee7a58e764eef992ac7599d30ca36cd2c52732d9dd120965af58e71c5a8e2d2964249679bf36cc1f052632daa3c3b3e22c759332eb93b4cc3bf09b62164f6dc8f37a8524e96d9562fd3a02b5f83d29b466e6fa47ec97ca4696f85f4ff1f65f401aa052b17586d55055fbcee4b0a3e794fffda5fd78fb0d5eab52bb8157f97a87d97defe525e88becda274be3d62aa6876dc07162976ec781a737510a870bd83ad0bf2f9db27b82aa2c9e86d4996269ca719efb5efa5c79107fe82f4f6e6f2360080264fe2e2819238a9db9fbab89824b2e9792c792b04b6c6d2aeda67205e23e100c9d96414eba19ded5f9b9cf1cca1128301f767b8c1a2087d5beb2a3a1063776967aeb638ba7a22ecc298f85b0b70e01f0fced90e2325bcf689b68647b6a90c40c184404d045cf9e4169339e20018186df48d89bbf4eac0139a125b430fe11f7b9c917a2881a586273eb10fd381f6b3307750caae227304111efbcdad21241f607b8e9f9d7bdb3fbe7c3fe41f2f9cf9d83469cf642cdb7c3c1c2e534562728136bbd5bfe3ab3aa65f04b1b4b19ea4bc8532d14e232457d597a2819b61061020dbe8b17e2a6435a76d5662a6a3ef9e647c9ca6ddf423c898fc6816920dca7f85a580a08cc73e76c6dd31677e8be0355ecee74b67d6c50ad280b9753b7ef78c67dcf3aefccc2da98a1ebeae9b7ba2cd1434621f27809061423b3dea920d4d51838bbd72d642ee7c3aef154a0c458b1393613ee09e30a547bd0286068cc5bc9e71bfdff3e8f0fa96742d43bebf5994de2072018e142a956ca8a0ce0535db01e3d84dac0f175456863165242e3aa15a3cb6c449200f0332a62c4fa7d9781eb520805e0146ee4275e9f661f2e36a2fdb039c154464780e8fb54d8d4bd29808dd8946b98813498b18ba9205f5cac5e9e2ffb6856d8fde4379ff88aeb83d16530a1be94e74e05dde509bbd33f016dfe7b1b17d2c75cdf129b0059f4489788e6be80de1a7d53b132ca47d95e745750e8ec63d810bb41c612e5991b4062c3014c2f76173bb1c9495c46ca45fa5693011d033396680f5c35c1ec6a6dfdc2e09f75c81b619fc5ab6e05df9eceecc1b44156e3f7a07b34f363b7e37ba180d6b60b2b2ccc57bc17a74c6889238f6d106220462330fc0873286b55cb1d29ca3fe2a0b1a13bee094ac4eb2049307fb569ca458af66fbef330643d4d784a6eb20d3076421ef80ce1cd4df83c3e8a25442c96b9f62d27fd14bf8b0096909f29f97eb0a0308ae34f7086a64de71867dc345ff6c35decd2ff3fd87c29e045734f4f28e256f80be6f5d03d6930ff64bf14c528174160fd1b4545f9d56d61b719936dfa58ac3629015b1f35e94d6bdc2fd1a67c3bb87efd92c0d8fcd0eb58e9eacccfb2a87899656e6ad3c2e7715b0eee7efedd4441cd671d76f37dcc46939782ead41ce3154cce2a69eda4d8c7f327dd781274b7424dfc575d5c62995fe38936fcbbdca5d42a2f3394c24f2f6d55620272ac0da9ecbebc622e267df22616897c9bf658a625cb41b5c63ca508a3134e1052b300ff92fe7419f0a9040c6cfbe9b59bdfb1274df1251e64d7237cc247ac44564a18428e65479ae20f3af06b365d19a223b0e2403a17ac29ecbaf879bfe67db9279e29770a870a9278021c788c5069e89908e7d6edc0d5c214f9b808043dbae25a295576ab65ef7a3c79b7b3bdda087f3fcfd2105c4ed9ab2a9baf91fb123a3bb700ad867137de7137e469e6daebd19c7ccd5dfc5a70aa275439b57b07ad30b507f39fe69d66b6840c8c1c6756605d6a27772e117392ffc634675d37cfc3f1d267e2ca4b592229d1becb2e91041da95a17f9a97be9d48ae4b157351290e14f4027e3de916e7bef2c1d288fd07010691aa74f9088c90e60e29433bbf53e3722d7ada5c1d7728bccaba0dee2b9bd2c711ef1983237d10cc6aa766b60b7280c950cfeb04298637b7f2727377baccf457798d35008a6e97d430ca7d99e8343304e148ba7796b94c2c47877806ec1733b27b3f6f30456bab841d7e5e1e8906d9e3dd3b6d8c45e8f62a60c57b6487bc3b972ff35f822e521964b8488f60cc0df1d8e762e21605e104efa4601fa79ab555f35217195bbdd3606893e050ce93cb8bdafcbf4aab52e453ee83e03cc8cd6188c654d7a73ae565d76d1bf7c8dbb2c9412e00d21e52f8fc5391c92c6dc346802d96bc8b946d3fa5b4520df8afac0065ff00474bfd733d58e0d169087e235b96d6a45057c5bf472255c34a3558038d56dcccbb5fbec2e9900d9b88c97b488f12c1bb1d8a0eb0b5eaf74438f25764cb90be2cf509c497f133df7bddecfa3f1ca43e2da1b367eb2d0e21b2f985f1659dd38a9db4b59538d499f129f9af59e666cddb9d997c88beacbf77dbed60ccd7ee9460542d68147264f14be5f0e73e81f850cc043e83fff40b8c8ad88b2f73b012bd6cf776a16f533f96d8a16c1ab33a39e8369d87f340592e2944a63c5bc74b78e028f16efaff63e3076ca46919468e1a512d99b75e53150aed05c0be9474c60662c16920370dde7ba8c7cb3b7c2a9e60faccaa28432eab6cbd8de4279f405509be9a6d3cb34022e1b7c73e6e53eabd7232f767b3d721c787bb8c1fb8b9d61b9998f2541e00d0791202973a5ef5ace80850c7021635f24ef719c82ba9f6cde77f6151aa7cd310a40ef480a1d3731f942d4a3f70de93fd643db2e523bb17ac2a8cd0eb356771aaa95f053fd17916f84d835b3521f4a1132f5a573eaea9478998e1e866c87604552c5c1bd4ae05e52c790613d3f882bf3fd46f48b81aa742c69170359b87736406f80b2f70399d4485c113f92a1c639c75405da9ac3e072c3e785039d5ee2d18234c88638fbeec09be140279625e9a33c66061860ad892f7b59106dbae7827e170b7986aee7f8d39706f55a884f1f0ebca61e97cc79a22db39b1f171ef6879a465b2c48cff415632ecb89cde8cb142f0bafec220b717c6e2eb496ef64266713a1fcdb8218e05e3b2146bdbb48d24c9e72685606c6b4383eff22a15a19a13aad864b3634455c2f289adfc9c2fbcde5ded196c884df0a4979a141cac768cfea2d279119fe349e753e9690007b89b82b7a5143e353aed6545fecb1e9a00305f3f1dedc153506ce915f335fcbfbf38390c006ac97891f036f4ca37098f2c0872c369f68f71a1d45bfde0f8ec90aaa0e8517820292b35e493c169c5369e2ad75d5d957623f0e95456accbcb5f356ef7440526d05b1c367a454b99009c88fa3abf2bf49792429b02564e87e5c1bb4b704f03c7b6ecef8fa178b2d2d485a68aacbdd856c2d2e12aadf5ddec7ee672b58d18996bfca0487a38641320d365c86b220ee37d5ea93e69b0cca34cb4cd4e494ce44d2820be34d376d3f268ac1bfe8c7e6bf0eb9d19ea7f5161365050c44925b7d8ef702cff07f40921a4349fe617c88e3410373d600a0a1f1bb2dba778d6f4dd0a9045ebe9a7df59e079013f09ff7713e5981af0ab46ff4050b135a0863469be6f2d34c4439df5bbf195467d9bb74859f8f5e51b6f098c4ba6e328e12931846afcf74b25eb3429642b6d0081d9caeae66796aa5c8d4fa965524b416d839032ae02c5d38de15564249212c05f21ab2ec222296b58c0b2a68f2d28ec7399d55b200decb6bece4a0ca44d6ecf1980c9ac53811a8a09e176791e47637bbe6bb6b90edf47568cfff148ebe878dae554fb9dfed53f55b26106e1fe1286d35ae148d127be2e8379d13ee68685001ed85e42ea61680f707f8e6b0dc85bbcfb02388d5d1f00e20ead55ebdbddf5da7aa30b4a60626f5be64cd53ba35d25713670c89be0c7a4d44b4fd89a06330b4d86836e7ab6d12d8b21d3e4e557c4dc9d250cc286734b3773a092fdcfad5c5a49e615e0b51716d4a8fb39974e5e56198402931a78c0a8205569d5553c56a6f61ad6d65f97d532b4634cb024a2bb15b3f4ad08d43302c333b845c871e44c5c462256ba253681a6cb69fe577708ad6d92ce9da22de45196787029b44e3269dbaabd3b51157e447dc436d0312c0f64de2e9b6a9d23a66e7d82054159edf80a8591e18bc48e34f3c0e2762ae4bfda060416a28f14f205e74dffd8f71b1fc1d88ec4cec580b271006712f3e3b45f35c224f0b768848e97db390f485320d323093978dca8fca81e750d2e8839545ec2b304abfb176e2f5b0e8702f5452d2d59a2966156c230c73c7d21c5827135a3c0e2bf31d752bc25d0f7951cc5fdbd1f6aa9dddb885f89e8e129a9c09b122392e3635d9774efb7eb46b61f731411fd9130abf82b0a7c6ab77204f4f91bd5e6cb0ee3811e1a8b717606b6ab63fd29076d1987c9ef082a2103d009303e54253f5100f07e87787ca0c7ac4f76ea2f636d8b1dee8a150a0bcf228ba703e79187d19ab2d608d73903c1f7eacead6399de9e7250356756781d50b426672ecdbe558e4e46c749080e86cb92f0345fbac2ef287bdd3538e1cd498ff7a0e03dea46c730d60496210f7a3063eed64a4f71c8c715da8af59f916790580d4cf2acd92252a187c905cf4372fd886bf8aa9ff30afd37a955bb77532fd32ea9b95670b08d06afdb30aeed5e32d4170c9f806d8029813c87da6a93c0d93078ed212b8dfa824e23d0a8df253bae0117a8b3224f4118a68e0267a0474813e4eb75f7c400716a01f983d3079c50d66b59f2154ee8b72ba690c89e89793de9cde3271420099ef22862795f0434b48aac25cd679fda430f1ed676398ae134c1b5408f25641a593b0d25465c6fb49daff868ec017f9e69192e3f07730c48928e7dae97be3b3bb4da54d2f2136bb53a9d4f96ced4ba95353c007fe2e40257fbdd772d28916c231cd0e8b6ef1b9997add97d410fc9428c70c1b62e7f1c899cd70dadc49b9680cceb2d497fb2f63d5075aea81c6859e049950c6f82318659e6ea46c06fa1410fb73031a767d87296dfd2e6105c80ff8b1ba53b019525f4040e7624646014421c33e21351fc37ce671d2ec668207aac5a7959f4b91c3ae36c95eec9ba325c370f76f1f3db67754ff79656e3380c508d7737d8ee5b70fb56f5ac2089834d169c6695f73b1896ea2d946ceeb4fb2c0a2545f09355b6724fbc56fdbfce3e5735c041c36ac8b848d541f49d6a4b1f0d7bf730cd3309a2800f26946f87f678645de8d0248d63840d098fb81b819b67614d0184de681832850757739232c9bdb8e1a27f83ce1d011cf33ad989c201d53b593c0d8cbc7fedb685110c62dd0037c1834942b81d5341fd94c55e6eab21c6c1035d44ab72ca8bf5230e71d26bf24cb5a20815be69484a839a04df9b8c1bc11d968929cbea6906a81f280d6128cda31197450f2a084f1cfe253b215c7e686ae66a3f966c82ee9c81d975dc7f296077772c7ce422479174b73bbf5ae378c29d16a7db727edc83c19453425659a74d852befb15482b3c783beddd05650d59314309750077137854e1c544563b1783835d33524c265eb027b49a953594ba3b65a5e685e689e815e1bb7fe681ae79d3d496fdd8d00c52abca6048d42eb45f551f56061781c84104b706ef66c7b166424559c867b706516a7576aeb3b822dbed48d89ed5ec269c28d6749e1daf15b9446b3485790df119a7fa2d87371a6ac9b1c8e6ec20f1b06e47641175ce0fa18a589f53e0e12a5f9ae61bab1928d208f6e6ca99cf9a1174375d3c254490f1b41264865feaa2990b26e7687cc1b649a28200583898300a7421da42be6730309b6a61d19337333858fc7bf7fbdc8385ec8cc709308a88a01703c28f37e4848f2c8855c11c959b32ce349858932708a23a78bd34f0af98909e9d4f76aafca44cfddda434c85c962281bdc8d6caba8a437c13d13dffaa647d131799f8443dc13081e483da02dfef9f3207320b74cf07eaba17d466c68797d0692e1077c562242df55044b00a3743973d6d27f35f463f849fbfe98f41836b58d24a40b07aa082538b8f6a788042c2b7828cb5b37359a8272e17731f78c884bf199ad977c58137fd64bf0aaf9154ea69ee3cb2a440ea27fe84ddf2969010a4d69399fc4fa9cb1315673b5b038ea828b196ba7041664053c502bd75565e5197192749b4c84eeb12bd01c4a591393c26ef7dc8cd70773e9cfed4f1e14b136350fe41b6e3da9b5ba06397fe08a9dc48018916158faffd4626271fcab61498031f6dfed3a26dee7741134c8f7ce01af895654e5a6884b0a600a30aaed6974c40b5560f1af4875f5c243d863a23a0a62574ea86f2a880b0f7750b158baeb6e009e7f9a71c1f32384f333dbb9826aa5900b64c8255dfed71bb0b883c6b9129d8b50d489166d31ed4196e1f47f7adf0114eef2a154a2335a474d99250f58f39eb66140098ab6f7118d9eeeeed24f06c0932c3210f9bcf4c9098450f9c32c80a238a933e8651428fdaf5c3622ace27083b8862f92cf4abadc38aa7c5f1406e78189b67ce02d2263f1c5ade65e75dffd26efd3edf453247e5e1ca2aa044c0471e813e32abfe626fd43c4eb4d4bad6045e64e25fa70059c6e2e7f0aae6d64aa48102c888249e7185efc11409ad5d2ed5173b3282416e56fae1176f75989e096ab33d4702d8c9bfda089882594dd0a31eab10515ff2bb2d93c0ae3276728c2d389cd0529451eabc4ba0cd8c05ea9583be9280026274c9e3ef34b12f7c09dc4690633faacec67a4292b366e090f7d3e214f284f6475755839ced63066b74bcaad9da47ea9c699c2cca3702d276b4b886798dced0b43b4009b09a170e53e6ea694a49301fd3b75f430afe74005433238b7b84a0225b5e7d566fdc9ddea930a9248509c2542360ba5f9f30d93b2ea4956bebc56c932dceaeb3c02f876a899186d1b2a398712a560b608290985e9c667298172179326b37334d519f0abc83654306269154fec14bd53f06f50695e69b95305730a8ecbc58dbd3116ed6b1dbf94b84bd8f3fe85768f62d060f0ac916d67130f723c7fe7b248a749faaf74e44c37e197cf8119cb9c2713a2560286c68a57663c72b83baba4894c0cda05e88099e2acaff10db01d5b20a07980a0756ddbfa4de8e64d79f75c767163f3c1c24c95d8a3c033fe800658c3689f8775808db6c259e7e8636c226d2b482225740a1f85e1cc5196c78c7cb90576905d3d4396dfb8d4babcc0ec4c294b9c76fb8c6580a19878d376fa06329786f2999a95dbfe3c08619f5127edb642f04114e082c3bf2451d1608949637cd9fad4817b9a1426717fbe1048fba5abbf5755ddd2547c6246a5ec609446440f0bafbbe190e9a1ec4569d76ee9a8bd9e398f0e75d4e7d911c768bfec5dc85d58c8160c6ad99dd99d48771179b70c69d8117be09877e5b8ceade62800f037d449950a276265b1a459cd876485de15d6db9ac31929b75f64169a4483c22edffadb353e11757a13d5dd58241b04821fe2022b64d3cae91d38c6ff63b10343355cedf2113a0d045341cb1fdd62ee90b4d037c00d1dda3da71200a45d4042897963f78645e73f7205b6c59844c9b94f1206aea4b173478eb7eac2d697dd596ffd484f7f9615680725f9256d32ad8f517b8a5a38bf1ca0c752521055a20f5e43e36c37cc79d20ef62b4ba3bccac2b45512253bdb1a4423ce3c499750d732356c6d436bee3f637bc120b5f9894a6133dd04536984dd35f7e67f5f402a2adb7cb21874b234a19d9507189e4cd48f16b6d864a132308bf1c8fffebdbff193272db81be4dd7e11599283c958ce4c05c5c6a9677f24eb7b729494ec704045be3da113058b14778c6d8cec8cb3d54581eabe5102066ab85d9ba4e5f044f98060e46d8916004cf8f736915a7d3548bafbd20e3345ea00a2741e8f0959c8417fccc0cfa4ef1dffaf9c52e30230ab692b5db83883d503829274da4e66049452923b42a266fb7868e058488386bab00824d2051757bb74451a06b5ada870bc31248b81158fb79c733c4924904ed42f0b91ae7535a118eac68bfd4bc5ab1300b390e4b9741dea94be7d7ea4c77ad0de231717bf00fa493fbf42eb48398b63aa716fb626684f03ad6a118d70a2b6a5ce65fd90f50db5f390252ae7b2645f3e343d4e31891d1a74e72d32007ec40aa8f788796c4126ee7e9a4c7cd9918d707383a8dadff8f819dfd15a84bbf91af4af8f30d10072d9c9324f6b48c8a0228942c45f182b1163e040587086501eba7f91f92c76545d1665da5394c6f3619715ce2c2fa575fbf79ad2f32f99aac711e460cc152147cd07ac18b7e6a8a2491359c122e47f1991bd3aeacf7b78a1024b466c494e48b01fd2bc9f108fb3646582a6a684578a685766b8b6963a9735f0e522e0aee71f40adcad080707be2c0a5cde361bf13be997a660c4d8f9381a8d2f801a53b209365531f9312856a73f2d4af1d9453ee0a9e1284f8de0c64ebdfff1bb31b02e7491c281b2131299f5b9bd681b429dc108f3cb712c6024edb290f7feec54c19744549ea0f705ffb46489938a2dc2257560bd0fdadd14f2ff933bb7f9091303f814eb91d1d92efc3bd5ffd56c4fff3e189b90f7ab13a43bb13d4bc57baad51964ca7078654dbe3b2ed487fe68c97687fce1cb775926749116d0a15d9ee679937a460596c903d92fcd68ba673888b106465582ac0f1ac34ff75b984ddb069cca66e340466fe12a5c8304aaa664e83e0750367de45f5799f8108384d6b2214752ad945b57e5c6216cd99ab8ff8ad6143d620c71363bce48f6077f1341420900f2aab6fa7114ee99fd1e14cf83a1151378edc73f40749c27897a4a3718cfecc6dc362c40cde10053b2cf0f4a6eb5d696276a64061474c99003b254beafe19e49155380d1c1b003474d6c6b424a2402898479b08876229218e9c6c906847351cadc1764815c66b4fbdb9b5747e4b06b6934bfd36ba7b27672d0e47321ca6943430fb5b5e99c830dd807d88704722a3047092615a36073068d17058f0163bebdfda676d64d1588413435a80e61c6b0c96580b8e659e6ccb083e90cd1f9925f1097d65c07ac54a3943197735207c87d11ddbdfc366dfd69e4ebc6e90d015f2fe9fd3cfef644153e41d7a1e8c852621886db50c998da4c32c4d5fce06483c7cdf2fc782bf5ecd3642ccbeb6df0c7260d44993572d743d9ff67087439fe40ec2c06f2f0071dba3c0150b222ce053bc124d489dd0e4b4224509f3bf45bcac2c9bfbefafb1170ef63fc78a8fd7195ab3fd5b01cd78939bcb5645f1fd0cc9c2c0132e21f6f6eb03cbc807d08076a17e252024bf67168cc684af4c1e7525c15ba1bad230cf932f0d69efe2ff1d55aed7e8e09e6d25130741fe793014cbcb07b19edb13c875cd56a747dd54efbb0744bacf8df20ca5452d661aff7a48aff2521ad62bcf8976d04038bb329539b7823d99279140f54d141c5647f5bb7a708da61074b36d7d854345981a9c7fd67f6c8e093747a4392ddf94faef23d50686e21f24a9817c1fae3e4cbde2cc04535e41415bb16b8cfc5d1d796a253641abc83dfe232dcbada81a22ec3920d4b8cfebd3c54861dd99d24f46259ab3077e4abf2a53e16b484bc4686e8548277b02f7e05f2607a2cedc7155e9f6c2e1d542a5195e119c9a13720d5ceca8ce92ebd88e63436292676078eaec9621c57ed38e1be3b1ac08dfb12bbbb868b06380db8cf5a0a2dded1d3d90d3219174189334fca504a7db642076c868db5a57a2e3089b2ce127fb3a626ab751e65bffe8e06a36b1792cc5ce768f49a063eaa6eecd5206220a44571767b6785d7c0a7065584248df23b9d8302f0038c71d1d776c55aae4d02df30bc10a31ed018a29bac8bde7493bf6b49debf8d02e52299e951f52de75a32c161ead7113df27154dc62f9a3cd1a4e8deddc344d6ebd1b6a18f34ae38e5db1d891d88b7f259b0811b01abc13be80778df1f1c97b25924ed54a1066e28001bdd81102726e332fb14071d79b4e36ddb3fdf11cde7a383a2b4ea3dae77c0df25a9dc16d397d938ed6249f6d39797f252e6c011eaf2d8fcaa6fe487f19381e1c92cef0a48602a5abbd68ab0876fafab02e929bac1e2c1afbf89879eef7a72653191221a06b64371737a02726548b0c9fc1fcd687f6a09f7fd5916d05e7dffdc9f03245eda55eafdd253ed474a5640c37e7ba0b032e20e3e1cb7989329d0c771e0531a7a8d8dc4554995135c328926c8fe1704e27b9d154cc6b912b98a0296dd9eb021627a5cfdeb998aa65a6fc145a72a0e099cf76afbf3a8d856a40cb6a0b6cae2fa1340e6de441f4e166e10250d486369cace07670c005f1221e42c41796c3b04b2ae7c2872415d5a0ad31a318808c85a704c5187c5f503fdf3a030bbc3d5d39148212ffd27f1da34757a2d92bc310ead7f826fc19d140ca477adb389ae1ca38d891571ca442bdea9afe56a9f187b9c2480cdb0c0ae6a38ff4c92f2b3e4e20f6bcb2bb66e288160890dd9bd732b50d5feab52d973b3eb78adf29c8787a137537d70fd28f08b041989eb880b650167e182f95e918acd1834f408e9460387c5daea4804b831dcd8626a31f0051930ce2911c6df7b09dbc2d770749c285f7d01c5b0a85053f416620330ba658e9629b9e109d6ee3ad4079f49118c11fac9624f8dafaf526e70349d3a17dbb44d27a784a3c451f8f81d5d750ead8bacbdb804d6b28f244781b3cf58ae3ab345d8a9b06b0cfd0f39f8d475eb9de8d9b638c20416e877fc3576af431bef6e4c801b1e56ed44c33650e91587c01594da583589fc59d31c5651eddc2b94be4571ca02fb27a1bad74d2a459cffd7aba53487c9bbff5bb497c9ea55cb947d3ad54bd7d08a3efaf05d225373a611e2c072ceba37a14b33eb1ae22d54d4f3eb66280d8199cd3a5e2db41f38004231bd475a9e1e971515a8bff1834f8d3f5c8f287e0e8a239fcdba588ce62f4f6494108ea01bc403b57ac012e6f5c9734c69ad23ce3cd404a377412275a6f695f3cd95ec3bb714a54e1cbc603000a869a492ba6ee7a64b96f28c6229138aa2c8e7ea6b218473ef07c2922f0b2c2b5f287dc8fcfbf7149fd24bbf8a97f88d8e95d91f694b4fc92464279ec678cddc7c05e67ab4954237f138f43264fd9de7cd767e23e2e4aa7c408df1c375cd49e2f085e50b4f834e29115aa234e243ffe6547126a292461436d44bf3d00282f0cb79c55f0319c17c2e510d59072a69c2d75ed273691201af187f419df0a92b92d798d3d1f807dac8cf958c5675b349d6af5bff5bb29743941c12b04c07b86eac804e6b41e3f17c1010e4375424a8d8a0b5b7a0a45ce76cdfdf38c2f261e80485b54dac5371ae5b24d933bd0b96830e67bfd62f972299690b2636318ee20264fce5b37f72181a8410c0b212fbd9b519cb538276d7f28adbb6e73b5dd6c3262fd86cdd39b9bdc861831cb99494b6513354176f011787951efec9b0906222419ed3579180de12ddb3889f9130673dad898fada6700796654bbd77af1d30f5cf1e1dd10736bcbc3001998c7f7c02b1db7892ca7a220716cc01110c4795f01856763090c1440f9ca2cf4a506f804662635b71395e3d14202fc9331c3dffa5767be63628be6e15e307cc814e416dffd616bad81e1055294bbdefb79a8b9387897c512881554a28c6aa8d7576de3b3a86b91e9816ca570f4aaa123fec6b10de324c1a780847d13ceba60f4bf2547b3794f19085e8ee7696088fa4bad5eb6ddb9220281b22f25f2a6011a17d861dfa54ae10c42acf73d2042a36f42ef05e83c072bd0153f83c523f7d9926a9af303146cd10663d6746919f9e3c83db21521b964d9bdff57f747a656841d0a623acdb4dfafd2c9bef8728c4b1be450251e6b07c87b6b271b6fa9cd4e94187023f820151884f80d4d1241e25425f3b45fde1b72600f3232b544dd1c81a5dc5db124be9c00cf2f0cd21628c57d329822e667288151fdf847adf7895117bd7069b77b8949231391fa48f18e43aa93ca8c24a7d8bbe4382a0998e7394a97359b0345a239be2f9670629f04c2b88a055b1b9e0d941b40fba7f9b82ac0e2a8c5076f75460a7d00d8702d80057c9e9aaaf4f20750b806b5d5fb37ed46c9a3326eaf80b7d31d19544313ce2c43b3af7b870ecbee7ecbf5a3e45f6edf8fc721f1179074a319d186dcc05ad7e799c14e78ae5375e3c51c8d254fedab095baecf33833f152e88e7e7009fa7832c611b12d1dd01e40658b86fdc071af4b8c9b458f8aa246b42f266cd554f3714276bc45f936a8c7b2913a2a16913a3e9b32cfaf9e3cceb1fc5b6c538baefb81bb97c0a2cf52f8696ed5cdf55c24426d4e3dfa03ddb8827883d02e17b177b8b13c0e7e7f47932d3eb62b96124cb51b293ce02fe2ed562e2c66e6a92a94366daeaa5ac074298cbac3b4439eafbec15a3aa5ea9e9000b6749bacd21ad25cc3bb0fc4eddef4e2931fef59bb4ce9a9fd61efa7c06b6d661dfdb8d971e3608cd1df7bf3babd17d146c130078ba5712028a292feda3cabe806dd61b5385d51ad8e123e39e1bfba013f9555cb55ccb8b89acd70f313b3ad943e082e88234d865f780e3ad2736245d2c913435994a46c9d19deeeef30140199d6da8f0dd949f6f232f0167c0bb00e5136d6e432d1150fdc3007f98961402d7743d59fbc6378c4431b4e2f7fd03e0cc66ad698e450f9dcf221cf6b4e00cd333d4447346fc75828938c1c6ad8fc0d72e82d96ed62e452da08b160e536c3de33243773d62d2dee14f2951e00e4790736830320e1406f3c2c67a84010aebc35d9228178efb64f26e727da91551b4e3540b9b5ec85f511ad98665f24b951070aa831ca476fd7e84b403a6ac3a515cea819e446a735d19f4132a8a05f0ad4d3cc138e26426f49b8d733e40c43af699dcf7ebbc71ccc069abf946ea70f07f47ad919ea5bf2b8bcf9ae6e2de10c9424110ebdaf982a9f05ed61adf5882179b79d6fc2f01b4c198a738bca0fd7f8d456ca759fffa2ecd76e0e8aaeb129fb8686b0ecbafa0587246c49c00f3aa2c26c5703ee822bd146418241ce6033a26db4f5102e116b74c26c2d45ab7adb9a88e8e4d3cdf44857478ad4f07bbd6d140d738706ba5dee58a7cbd9bccbeb91d747d77c7fd72c6bc1e3d37c420b4e72660d5f7b85ad432e6a1b29797df64e3ac22650a6095231d7d7b4d7d91b060afe2fee3775aedc1c8db74ad7798a6d3699982419d50655aa70b228fdc7b012ac491a4f194c95874380b8c4a67cad056ec49b0ec2c4aa453d3bff03c48146f3d196fb1afdd351cbe393f5ebf803e60840014f8aa62c6263a71175ab1f1bc43632e473028a84b207eb039a68715134e5740c54a991011b4057d090fbb899b8dfaed1c8ca73f600e0d55869d8fbd53a906ec948491d3201eac6fc630a3e203898e0300d21a953d74fe68630e3cfbe36745a1bc851ee470fcadea77220f524df022c847bd6ff9e2af25b6e52324f1a5c08a6b527ac0748872bd917c55e32733bde1e37f3b5c1d99c729e0435191d9ce72f8f78c6a17460e86609c73568b48d8814322bddc3f2fdcde1df850368fc02da1884c3365bdfff2dfa94107afa23554c2c4f976b489557b1ac36d3e93778a39b98e83795ff738c22cf53a88dacd494d8a493456d40fa71b92bab373e8739580ae95f8be6f3c7b15c6a5822cc5cf700d645a6e50f9f5ff2eb5f8a26a9adb4402012ce6f7f9eca895bcabc09100ac802faacf750b0689e85d1e71b4dc3ee975f39573e86da72c70164b45a691d765af53768b933b477a12858a4a705d9eb0790079e53dc9173fa0bf47295cd9e99c42310beef0831d987389224700b8444d75935fa9941817c7e5e3959875c32a1f8a789fe1364f93e6b6ad27552e29317e6ba3a4b91f113e2cad851ba7bb9fbae7cce65bbbb91d3f0955b46d5a897dc17fd9b34fb8146e5e89d2f829966f8cb35b15524d22c04c3bcc4e4b8d8730b086f39c1384d2a392b4affe0e0065af927bcfe1320422a402d8ae5fa187dabe80724d2c056818271d43611b6babdb2690cb8df31e7305ea028ade53e1b95d82d023af6aa279d19a18aff92a8c0c982ed18b4807fc14ae51e3f6d7ecd162dc38a6b8cd787abadb1e405a7e42202dc02ab6c61e96af5a98e4ea6874fcb8fe3a85c6ad91224e60e2f792241d757654d960a0e24a85d7f2dc72b5786cb65ec0fd22cf724712f5fb45992501fbe6b9e1b1d62153a8e56fa3d3aabc7b99c3becbb2a7a48a0f8bdc91b11d5b0b02e479a172bf18a68920d5f5fa550b11a6e9541b074f3e3fc2a752d0ddc880a96696b1c1a699c5b622811d63629d604725fc2ea456b3b81d239ab57374d055dfd76dc6199da23d52e9877b734507f0c0959183f30fd47ad728a13ac4bde5a74eb261d2cad5495524b25395929b8122f8965c4ba8e0209ae4ef966278313258388b5d06ee49bb8f29b654bad8d2e8787c74cb099c1fdc018b3059e6fc7524d3ec359e5c01d0d3958798f916bf61e18d5689e3c3b55eba92d5bee49e2aa7043c3a6a5f831744447f7c5b08e1088dc2a09166cb98e56d2538c2c6d9a2c68c607c2a712bf2e55f36706b78afcd336a48e536ac7e8d08e2673e49a619f808dff7ef4c941b9132c6b9798fbf6a2859a251bef23a43966415f131fa4dddec86dc1ab6a641f61c08b199b307bd49379e997b27a272b4d544c06e3a8acbaae12ad6bd94e2b7dddbaf2e21d596fc1f8853a4059688c1baf8a4528bc4223960b0ff415af68b91554b9681b0749e5dd8d7836c27fedaba9bdc33118bcd8228b01ec77ed6a052b340655fdb08a9b9d178620d78aca1cca5c86149fc943c569a7fe8f820a18809006ec19ae0e7b3b2b59215ed1e9029cc0ef8f1cb49638a3d69d02cc3af2f10ab21f50e0da06a87217e6e3253a23b5de581e39f145fd16596cf6c8f75e492042be02c46816a87615c2da64</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码是pysandbox13的flag</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Writeup</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>python</tag>
        <tag>Writeup</tag>
      </tags>
  </entry>
  <entry>
    <title>与manim之间的往事</title>
    <url>/p/6222a56.html</url>
    <content><![CDATA[<p>最近刚到大学报到完，恰巧有些闲暇时间<br>闲来无事，来记录一下自己与一步一步推动我走到现在的manim之间的故事（<del>指流水账</del><br>这篇虽然叫「与manim之间的往事」，但是里面很多都和manim无关（逃</p>
<h2 id="一切的起点"><a href="#一切的起点" class="headerlink" title="一切的起点"></a>一切的起点</h2><span id="more"></span>

<p>现在的一切还要从初中开始说起（因为小学时期就是一直在玩，很少考虑学习的事情）<br>上了初中，关注了很多没营养的公众号 —— 初中数学、初中英语、初中物理 等等一整个系列<br>其中有一个很特别的公众号就是初中化学，总是会转载一些很有趣的实验视频<br>有一次它就转载了 <a href="https://space.bilibili.com/865267">@真·凤舞九天</a> 的<strong>疯狂化学</strong>两期视频<br>当时看得我大受震撼，于是就顺着链接爬到了贴吧</p>
<p>正好萌凤开始制作DEC（实验室的魔法日常）了，然后就在贴吧上每一期都找到来看<br>逐渐我发现这些视频发布的平台都是一个粉色小网站<br>“那我既然每期都从贴吧翻到哔哩哔哩来看这些视频，那我为什么不直接在这个网站上等待更新呢？”<br>凭着这个想法，我注册了B站</p>
<h2 id="初入B站"><a href="#初入B站" class="headerlink" title="初入B站"></a>初入B站</h2><p>所以真正带我来B站的，是大萌凤（<br>当时的入站考试还很严格，问题也都很有趣，极大地吸引了我的兴趣<br>起昵称的时候突然想到 <strong>凤舞</strong> 和我名字里的 <strong>鹤翔</strong> 还挺搭配的，所以就顺势补全起了个昵称“<strong>鹤翔万里</strong>”</p>
<p>刚入B站也只是每周看看更新的DEC<br>然后逐渐逛着逛着就发现了这里深藏着的一堆一堆宝藏，一点一点关注了很多up主</p>
<p>其中，在某个评论区，看到了有人推荐up主 <a href="https://space.bilibili.com/88461692">@3Blue1Brown</a>，就去看了一看<br>结果也是大受震撼，他可以将一个知识讲得直白易懂、又不缺乏严谨性，更重要的是<strong>动画</strong>也顺滑舒适好看</p>
<h2 id="初识manim"><a href="#初识manim" class="headerlink" title="初识manim"></a>初识manim</h2><p>在看了3b1b的视频后，就一直非常好奇这样的视频是怎么做的<br>在疑问了很久之后（已经到了初三），我终于看视频简介了（x<br>发现这是使用一个叫做manim的东西制作的<br>百度一搜索，结果搜到了 <a href="https://space.bilibili.com/3557916">@Solara570</a> 的<a href="https://www.bilibili.com/read/cv17444">专栏</a></p>
<p>一看发现，竟然是编写代码制作的，感觉很神奇<br>而且里面的代码看起来也好好看（其实就是Consolas等宽+普通高亮<br>所以也就很想学着做一做</p>
<p>所以就打算先跟着教程试着安装一遍，结果果然<br><strong>处 处 碰 壁</strong></p>
<p>安装什么都会卡住一下，特别是LaTeX，总是出问题，而且很难解决<br>当时正是初三中考复习，而且家里也限制用电脑，所以就只好先放下了<br>但当时就确立了我的一个目标：</p>
<p>“<strong>我要学会使用manim</strong>”</p>
<h2 id="踏上编程的不归路"><a href="#踏上编程的不归路" class="headerlink" title="踏上编程的不归路"></a>踏上编程的不归路</h2><p>当时在教程中了解到，这里面的代码是python语言，所以就决定要先放下manim好好学一学python（<del>注入怨念：这恰恰是不少人做不到的，很多零基础的人盲目只是要用manim，然后即使没有python基础也要硬着头皮安装，结果出现了各种问题，而且还到处问</del>）</p>
<p>在中考完的暑假中，我买了一本《Python编程：从入门到实践》，在极短的假期（因为高中创新班开学早）中不惜推掉部分衔接课程完整地刷了一遍书，甚至还做了一小本笔记<br>也凭借着部分网络资源，我学会了简单的python语法以及有关计算机的很多知识，也觉得这些东西确实挺有意思的<br>这时我又尝试安装了一遍manim，中途的错误少了很多，但还是卡在了安装LaTeX上<br>高中已经开学，所以我又不得不放下了manim</p>
<p>上了高中，因为是创新班，所以会推荐选择一两门竞赛来学习，为了学到更多的计算机知识，报名了<strong>信息竞赛</strong><br>发到了教材之后我就开始疯狂看，甚至自习晚自习，只要是有空闲时间了就拿出来看，这样一个多月学了C++的基础语法<br>（<del>当时班主任发现了还比较不高兴，要求我一直保持年级前二十，但是很显然这是保持不住的</del>）</p>
<p>在高一的NOIp2018后，我发现学长们都不太会使用Linux以及bash，而考试的系统还是NOI Linux<br>所以就决定干脆做几个视频放在B站上供大家参考（都是黑历史）<br>就这样，我成为了一名up主</p>
<p>在超前学了信息竞赛课的内容之后，我开始用那个时间来研究安装manim<br>为了解决LaTeX的报错问题，我试过很多方法，最后使用docker成功安装了环境（为此还花了一段时间了解docker）<br>在做出了第一个带有文字的动画之后很是激动</p>
<p>这样在2019年寒假的时候我抽了点时间来练习练习manim，制作了我的第一个manim视频<a href="https://www.bilibili.com/video/BV1Eb411r7dJ">「动态规划-01背包问题」</a><br>慢慢的，在每天自习的信息竞赛课上我又学了不少计算机方面的知识<br>当时想要做一个自己的博客，在学markdown时发现数学公式也是用LaTeX写的<br>而且了解到这个东西可以排出很好看的文档，所以就干脆又从零学了LaTeX<br>学了LaTeX之后manim安装就不再出现无法解决的问题了，也就可以顺利安装了</p>
<p>在高一下高二上，我也是凭着兴趣做了几个视频，从中也逐渐地发掘了manim的一些简单用法，也尝试看了一些manim源码<br>当时还觉得那些源码都还是很远的东西，觉得自己能看懂一部分就很好了</p>
<p>在2019年年末，我发现了同是使用manim的up主 <a href="https://space.bilibili.com/66806831/">@cigar666</a><br>一段时间后，他建立了manim的交流群，这个群也逐渐地发展壮大<br>在这个群里我也学到了很多知识，教了很多人入坑manim，也认识了好多好多全国各地的朋友</p>
<p>高二的寒假，我计划做了FFT算法那期视频，在那期间，我非常活跃地在群里回答各种问题<br>有一次我给出了一个很复杂的解决办法，而manim源码中其实是有轮子的<br>这时S570说了一句“还是源码看的不够”，我也就从此提高了目标：</p>
<p>“<strong>我要看懂manim源码</strong>”</p>
<h2 id="成立MK"><a href="#成立MK" class="headerlink" title="成立MK"></a>成立MK</h2><p>高二的寒假，疫情突如其来，假期也随之延长<br>而当时大部分人也都在假期中，为了更好地交流代码，我在GitHub上建立了组织，并且投票选举出了名称manim-kindergarten<br>之后在群友的合作之下又进行了很多资料的完善<br>为了方便回复一些常见的问题，我也编写了《manim常见问题》这个文档，在一年多的完善后，它已经迭代到了3.1版本</p>
<p>同时我也顺势做了很多比较短的视频，参加了一些活动，也被妈咪叔转发了，获得了不少粉丝，也拿到了知识领域优质up主的认证<br>而且MK内部也组织了几次联合投稿，共同完成了一些视频<br>其中我们突发奇想，尝试了使用manim来制作manim教程，结果还蛮不错<br>所以我也就单独在这个系列下完成了几个视频</p>
<p>在制作这个视频时，我也在逐渐深入地阅读源码，感觉没有那么晦涩难懂，代码思路还是很清晰<br>正好有MK成员开了一个文档的repo来汇总一些网上的文档，我也就正好把里面的内容归纳归纳，保留了一些有价值的内容，也补充了部分中文的文档字符串，就这样完成了一大半<a href="https://docs.manim.org.cn/">中文文档</a></p>
<p>疫情期间，我也加入了manim的discord频道，在里面也帮助了很多人解决了manim上的问题<br>我发现discord上manim channel的管理员是eulertour，而且他在GitHub上也是manim的collaborator，同时还做了很多项目<br>当时就在mk的QQ群里表达了一下对他的仰慕，然后就有一个群友说了句：</p>
<p>“其实你也可以”</p>
<h2 id="成为合作者"><a href="#成为合作者" class="headerlink" title="成为合作者"></a>成为合作者</h2><p>疫情期间在学校机房脱产的时候也经常会读一读manim，还顺便把一直容易出现的Text问题修复了一下<br>当时Grant正在开发基于OpenGL的manim，所以这些pull request一直是eulertour来merge的，但是在他加入了ManimCommunity之后就已经打算将3b1b/manim荒废掉，很少来管issue和pr，甚至有用的pr也只会让交到ManimCommunity里<br>但是我觉得这比较不好，毕竟还有很多人正在使用3b1b/manim，所以我就在暑假的时候抱着试一试的心态给Grant写了一封信来申请3b1b/manim存储库上的权限</p>
<p>结果几天后Grant真的回复了，他同意给我manim上的write权限，但是要先和eulertour沟通一下<br>几个月后的十一假期，我收到了Grant发来的成为collaborator的邀请（<del>其实中间一直没有回复是因为我的邮件跑到了Grant的垃圾信箱里</del>）</p>
<p>在成为collaborator后，我merge了一些有用的pull request，关掉了一些没用的/已解决的/老旧的issue<br>同时我也大致了解了新ManimGL的大致逻辑，也向Grant提了好几项改进的建议，他也采纳了很多部分</p>
<p>在开学了之后，为了复习高考，也基本放下了manim上的活动（还收到了来自Grant的祝福）<br>在2021年寒假，又因为疫情上了一段时间网课，我也又抽时间来玩一玩manim了<br>那时ManimGL已经基本完工，在一些准备之后，shaders分支被合并到了master分支成为了正式版本<br>我也为之写了全新的中英文文档（虽然还是很不完善）<br>在那之后我也对manim做了一些改善，关闭了一些过时的pull request，打开了disscussion，发布新的python包等等</p>
<p>嗯，然后就是开学-&gt;复习-&gt;高考</p>
<p>高考发挥的还算比较好，成功进入了ZJU-Turing<br>为了更好地汇总信息，在假期里我又为mk写了官方网站：<a href="https://manim.org.cn/">manim.org.cn</a><br>然后就是开学到现在了</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>是manim在一步一步推动着我前进<br>从想要用manim到想要看懂源码到想要为它做出点贡献<br>从一个什么都不会的初中生变成了manim的collaborator<br>这仅仅是三年啊（</p>
<p>所以，那么接下来继续努力吧</p>
<p><del>写的太水了，反正就随便写写，想到哪写到哪了，没想到你还真的看到这了_(:з」∠)_</del></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn LambdaCalculus」#0</title>
    <url>/p/92a6fc79.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，GZTime也跟我聊过一些关于lambda演算的东西<br>学Haskell的时候也总是能听说这个东西<br>看起来挺有意思，来学学_(:з」∠)_</p>
<span id="more"></span>

<p>那我也引用GZTime引用的知乎同学的一句话：</p>
<blockquote>
<p>在介绍λ演算之前，我们需要放空一下我们的大脑，忘掉C语言，忘掉冯·诺伊曼机，忘掉图灵机，甚至要忘掉0和1，加和减。我们来到一个只有符号的世界。在这个新的世界里，只需要几条简单的定义和规则，便可以构造出与图灵机完全等价的计算模型，即它是图灵完全（Turing Complete）的。和图灵机一样，这个计算模型可以解决任何一个可以机械计算的问题；与图灵机倾向于硬件实现不同，它更倾向于逻辑的推理。它就是λ演算（Lambda演算）。</p>
</blockquote>
<h2 id="lambda-term"><a href="#lambda-term" class="headerlink" title="lambda term"></a>lambda term</h2><p>一个合法的lambda表达式又被称为lambda项（lambda term），以下三个规律归纳性地定义了一个合法的lambda项：</p>
<ul>
<li><strong>Variable</strong>：一个变量 x 本身也是一个合法的lambda项</li>
<li><strong>Abstraction</strong>：如果 M 是一个合法的lambda项，x 是一个变量，那么 (λx.M) 也是一个合法的lambda项（这相当于定义了一个 x -&gt; M 的函数）</li>
<li><strong>Application</strong>：如果 M 和 N 都是合法lambda项，那么 (M N) 也是一个合法lambda项</li>
</ul>
<p>lambda表达式的组成有变量、抽象符号λ和一个点.、括号</p>
<p>所有lambda项构成$\Lambda$空间，通过上述合法lambda项的定义，$\Lambda$空间的正式定义是：</p>
<ul>
<li>如果$x$是一个变量，那么$x\in\Lambda$</li>
<li>如果$x$是一个变量且$M\in\Lambda$，那么$(\lambda x.M)\in\Lambda$</li>
<li>如果$M, N\in\Lambda$，那么$(M\ N)\in\Lambda$</li>
</ul>
<h3 id="notation"><a href="#notation" class="headerlink" title="notation"></a>notation</h3><p>为了使lambda表达式的记法更清晰，可以有以下简化：</p>
<ul>
<li>一个lambda项最外侧的括号可以省略。比如 (M N) 可以写成 M N </li>
<li>应用是左结合的。比如 M N P 表示的实际是 ((M N) P)<br>  这和Haskell中函数左结合是一样的</li>
<li>抽象是尽可能向右延伸的。比如 λx.M N 实际上表示的是 λx.(M N) 而不是 (λ. M) N<br>  这和Haskell中lambda表达式向右一直延伸是一致的，因此一般要为lambda表达式加上括号</li>
<li>嵌套的多个lambda表达式可以缩写成类似多元函数的样子。比如 λx.λy.λz.M 就可以缩写成 λxyz.M</li>
</ul>
<h3 id="Free-amp-bound-variables"><a href="#Free-amp-bound-variables" class="headerlink" title="Free &amp; bound variables"></a>Free &amp; bound variables</h3><p>在一个lambda表达式中，也有自由变量（free variables）和约束变量（bound variables）的概念。</p>
<p>在lambda项 λx.M 中，λx被称为binder，它将输入的x与M中的变量x绑定在一起，这时x就是约束变量，而其它的所有变量都是自由变量。</p>
<p>&emsp;比如在表达式 λx.x+y 中，x就是约束变量，y是自由变量。</p>
<p>对于一个lambda项M的自由变量构成的集合FV(M)，也有一些规律需要满足：</p>
<ul>
<li>如果 x 是一个变量，那么 FV(x) = {x} </li>
<li>FV(λx.M) = FV(M) \ {x} （M中除去x之外的变量都是自由变量）</li>
<li>FV(M N) = FV(M) ∪ FV(N) （M应用在N上得到的lambda项的自由变量是MN两个lambda项的自由变量的并集）</li>
</ul>
<h3 id="Substitution"><a href="#Substitution" class="headerlink" title="Substitution"></a>Substitution</h3><p>lambda项也有一种记法叫做替换（substitution），记法 t[x:=r] 表示将lambda项t中的自由变量x都替换成r。它满足以下规律：</p>
<ul>
<li>x[x:=r]=r （一个变量就是自由变量，将其替换成r就变为r）</li>
<li>y[x:=r]=y if x!=y （如果x和y不相等，那么）</li>
</ul>
]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Rust」#0 总章</title>
    <url>/p/db45bee5.html</url>
    <content><![CDATA[<p style="text-align: center;">学习一门新语言之Haskell</p>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Haskell学的差不多了，也没啥事想干了<br>GZTime之前也跟我推荐过Rust挺好玩的<br>这几天看一看<br>一样，没有教程，只是我的笔记而已</p>
<span id="more"></span>

<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><p>Mac上安装只需要安装rustup即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>

<p>然后更新、卸载、检查：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ rustup update</span><br><span class="line">$ rustup self uninstall</span><br><span class="line">$ rustc --version</span><br></pre></td></tr></table></figure>

<p>Rust代码的后缀名是<code>.rs</code>，通过<code>rustc code.rs</code>来编译出二进制文件<code>code</code>再运行</p>
<h2 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2><p>通过rustup安装后自带cargo，可以通过<code>cargo --version</code>检查</p>
<p>通过<code>cargo new project_name</code>来新建一个项目，这时会在当前目录下自动生成下面的目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project_name</span><br><span class="line">    ├── .git/</span><br><span class="line">    ├── .gitignore</span><br><span class="line">    ├── Cargo.toml</span><br><span class="line">    └── src</span><br><span class="line">        └── main.rs</span><br></pre></td></tr></table></figure>
<p>cargo会根据输入的项目名称新建一个文件夹，并且默认使用git进行版本控制（可以使用<code>cargo new ... --vcs none</code>取消版本控制）</p>
<p>其中main.rs文件中就是一个Hell World程序。Cargo.toml是这个项目的配置文件：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;project_name&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2018&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure>

<h3 id="构建、运行、发布"><a href="#构建、运行、发布" class="headerlink" title="构建、运行、发布"></a>构建、运行、发布</h3><ul>
<li>使用<code>cargo build</code>会构建这个项目，并且将可执行文件创建在<code>target/debug/</code>文件夹中</li>
<li>使用<code>cargo run</code>直接构建并运行这个项目</li>
<li>使用<code>cargo check</code>检查项目，但不生产可执行文件、也不输出结果</li>
<li>使用<code>cargo build --release</code>来发布，产生但可执行文件在<code>target/release/</code>文件夹中，不用于直接build，它会进行一些优化来使程序运行地更快</li>
</ul>
<h2 id="常见编程概念"><a href="#常见编程概念" class="headerlink" title="常见编程概念"></a>常见编程概念</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>let</code>语句会创建一个变量，但是默认都是不可变的（immutable）。即一旦使用let创建一个变量并为其赋值，那这个变量将不允许被改动，如果在代码中改动了这个变量，那么将不会通过编译</p>
<p>但是可以再使用let语句来创建一个同名变量：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这时，原来的x就被隐藏（shadowing）了（这种方式的前后两个x本质上还是两个变量，它们允许有着不同的数据类型）</p>
<p>在let后面加上mut也可以创建一个可变的变量：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">1</span>;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>但这时x不能更改数据类型</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量不同于变量，它一定是不可变的。常量通过<code>const</code>关键字创建，而且需要明确指定数据类型（Rust常量命名规范是用全大写）：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINT: <span class="built_in">u32</span> = <span class="number">100_000</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Rust是静态类型语言，编译器需要在编译时得到所有变量的类型，但是也可以自动推测类型。</p>
<p>Rust中的类型分为两种，标量（scalar）和复合（compound）</p>
<h4 id="scalar"><a href="#scalar" class="headerlink" title="scalar"></a>scalar</h4><p><strong>整型</strong>：</p>
<table>
<thead>
<tr>
<th align="center">长度</th>
<th align="center">有符号</th>
<th align="center">无符号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8-bit</td>
<td align="center">i8</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="center">16-bit</td>
<td align="center">i16</td>
<td align="center">u16</td>
</tr>
<tr>
<td align="center">32-bit</td>
<td align="center">i32</td>
<td align="center">u32</td>
</tr>
<tr>
<td align="center">64-bit</td>
<td align="center">i64</td>
<td align="center">u64</td>
</tr>
<tr>
<td align="center">128-bit</td>
<td align="center">i128</td>
<td align="center">u128</td>
</tr>
<tr>
<td align="center">arch</td>
<td align="center">isize</td>
<td align="center">usize</td>
</tr>
</tbody></table>
<p><code>isize</code>和<code>usize</code>是根据系统而定（32/64）</p>
<p>同时整型的值也可以用不同进制表示（十六进制<code>0x</code>开头，八进制<code>0o</code>开头，二进制<code>0b</code>开头，单字节字符<code>b</code>开头（b’A’）），在数值中间也可以增加<code>_</code>来增强可读性，在数值结尾也可以加上类型后缀来明确类型</p>
<p><strong>浮点型</strong>：<br>单精度浮点<code>f32</code>，双精度浮点<code>f64</code></p>
<p><strong>布尔型</strong>：<br><code>bool</code>，值是小写<code>true/false</code></p>
<p><strong>字符型</strong>：<br><code>char</code>，四字节（使用unicode）。字符是单引号而字符串是双引号</p>
<h4 id="compound"><a href="#compound" class="headerlink" title="compound"></a>compound</h4><p><strong>元组</strong>：<br>元素类型可以不同，但是整个元组的类型和各个元素的类型都有关，例如：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>可以通过<code>.</code>加索引来访问元素：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = tup.<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>列表</strong>：<br>不同于Python/Haskell，Rust中的列表的长度也是不可变的，而且列表中的所有元素的类型也必须一致。含有五个i32类型的元素的列表的类型就可以写成<code>[i32; 5]</code></p>
<p>同时<code>[3; 5]</code>这种写法也等价于<code>[3, 3, 3, 3, 3]</code></p>
<p>可以通过<code>[index]</code>来访问元素，如<code>lst[1]</code>。但如果索引超出列表元素个数，那么编译将不会报错，但运行时会报错</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>通过<code>fn</code>关键字来定义函数，参数的类型必须指定，如果有返回值，返回值的类型也要在()后面用-&gt; type指定。返回值可以在函数中途直接return返回，也可以在函数结尾直接写出要返回的值（不加分号，此时是表达式而不是语句），比如：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，用{}括上的代码块也是一个表达式，它也可以有返回值：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><p>常规的if语句，比如：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a == <span class="number">1</span> &#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> a == <span class="number">2</span> &#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同于Haskell，它可以没有else只有if</p>
<p>if语句也可以用在let上，这时{}中要是一个表达式而不是语句，即不带分号：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><strong>loop</strong>：<br>使用loop会将块一直循环直到遇到break，也可以从loop循环返回值，比如：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>while</strong>：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> condition &#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for</strong>：</p>
<figure class="highlight rs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> lst.iter() &#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>鸽了，明天再写</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn">Rust程序设计语言 简体中文版</a></li>
</ul>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#7 一些其它类型类</title>
    <url>/p/68ef8146.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/d4bb2633.html">&lt; #6</a></p>
<p><a href="/p/96c32eae.html">#A &gt;</a></p>
</div>

<h2 id="Foldable"><a href="#Foldable" class="headerlink" title="Foldable"></a>Foldable</h2><p>Foldable是表示可以折叠（fold）的类型类，在<code>Data.Foldable</code>中定义，这使得和fold相关的函数可以用在任意Foldable的实例类型上。它的定义是：</p>
<span id="more"></span>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Foldable</span> t <span class="keyword">where</span></span></span><br><span class="line">    fold     :: <span class="type">Monoid</span> m =&gt; t m -&gt; m</span><br><span class="line">    foldMap  :: <span class="type">Monoid</span> m =&gt; (a -&gt; m) -&gt; t a -&gt; m</span><br><span class="line">    foldMap&#x27; :: <span class="type">Monoid</span> m =&gt; (a -&gt; m) -&gt; t a -&gt; m</span><br><span class="line">    foldr    :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line">    foldr&#x27;   :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line">    foldl    :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line">    foldl&#x27;   :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line">    foldr1   :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a</span><br><span class="line">    foldl1   :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a</span><br><span class="line">    toList   :: t a -&gt; [a]</span><br><span class="line">    null     :: t a -&gt; <span class="type">Bool</span></span><br><span class="line">    length   :: t a -&gt; <span class="type">Int</span></span><br><span class="line">    elem     :: <span class="type">Eq</span> a =&gt; a -&gt; t a -&gt; <span class="type">Bool</span></span><br><span class="line">    maximum  :: <span class="type">Ord</span> a =&gt; t a -&gt; a</span><br><span class="line">    minimum  :: <span class="type">Ord</span> a =&gt; t a -&gt; a</span><br><span class="line">    sum      :: <span class="type">Num</span> a =&gt; t a -&gt; a</span><br><span class="line">    product  :: <span class="type">Num</span> a =&gt; t a -&gt; a</span><br><span class="line">    <span class="meta">&#123;-# MINIMAL foldMap | foldr #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>最少只要实现<code>foldr</code>和<code>foldMap</code>其中之一就可以使一个类型成为Foldable的实例，其它的函数都有由这两个函数提供的默认实现，而且这两个函数之间也有相互实现。因此只要实现foldr或foldMap一个函数就可以使用所有其它Foldable中的函数。foldr函数在前面已经有学过，foldMap的例子是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; foldMap <span class="type">Sum</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="type">Sum</span> &#123;getSum = <span class="number">9</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; foldMap <span class="type">Product</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="type">Product</span> &#123;getProduct = <span class="number">15</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; foldMap (replicate <span class="number">3</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Foldable实例"><a href="#Foldable实例" class="headerlink" title="Foldable实例"></a>Foldable实例</h3><p>[]、Maybe、Either a、(,) a都是Foldable的实例，标准容器库中的Map、Set等也都是Foldable的实例。也可以自定义二叉树类型，并使其成为Foldable的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Empty</span> | <span class="type">Leaf</span> a | <span class="type">Node</span> (<span class="type">Tree</span> <span class="title">a</span>) a (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Foldable</span> <span class="type">Tree</span> <span class="keyword">where</span></span> </span><br><span class="line">    foldMap :: <span class="type">Monoid</span> m =&gt; (a -&gt; m) -&gt; <span class="type">Tree</span> a -&gt; m</span><br><span class="line">    foldMap f <span class="type">Empty</span>        = mempty</span><br><span class="line">    foldMap f (<span class="type">Leaf</span> x)     = f x</span><br><span class="line">    foldMap f (<span class="type">Node</span> l k r) = foldMap f l `mappend` f k `mappend` foldMap f r</span><br></pre></td></tr></table></figure>

<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><ul>
<li><code>asum</code> :: (Alternative f, Foldable t) =&gt; t (f a) -&gt; f a，用&lt;|&gt;逐个连接所有元素</li>
<li><code>sequenceA_</code> :: (Applicative f, Foldable t) =&gt; t (f a) -&gt; f ()，由于丢弃结果，所以Foldable t就可以满足；因此不同于sequenceA需要Traversable</li>
<li><code>traverse_</code> :: (Applicative f, Foldable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f ()</li>
<li><code>for_</code> :: (Applicative f, Foldable t) =&gt; t a -&gt; (a -&gt; f b) -&gt; f ()</li>
</ul>
<h2 id="Traversable"><a href="#Traversable" class="headerlink" title="Traversable"></a>Traversable</h2><p>Traversable是表示可遍历的类型类，在<code>Data.Traversable</code>模块中定义，它是Foldable的升级版，同时也是一个Functor，它的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">t</span>, <span class="type">Foldable</span> <span class="title">t</span>) =&gt; <span class="type">Traversable</span> t <span class="keyword">where</span></span> </span><br><span class="line">    traverse  :: <span class="type">Applicative</span> f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</span><br><span class="line">    sequenceA :: <span class="type">Applicative</span> f =&gt; t (f a) -&gt; f (t a)</span><br><span class="line">    mapM      ::       <span class="type">Monad</span> m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)</span><br><span class="line">    sequence  ::       <span class="type">Monad</span> m =&gt; t (m a) -&gt; m (t a)</span><br><span class="line">    <span class="meta">&#123;-# MINIMAL traverse | sequenceA #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>最少只需要实现traverse函数或者sequenceA函数。其中各个函数的功能通过类型签名也都能推测出来。但是其中mapM就是traverse，sequence就是sequenceA，它们存在只是历史遗留（</p>
<h3 id="Traversable实例"><a href="#Traversable实例" class="headerlink" title="Traversable实例"></a>Traversable实例</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    traverse _ <span class="type">Nothing</span> = pure <span class="type">Nothing</span></span><br><span class="line">    traverse f (<span class="type">Just</span> x) = <span class="type">Just</span> &lt;$&gt; f x</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> [] <span class="keyword">where</span></span></span><br><span class="line">    <span class="meta">&#123;-# INLINE traverse #-&#125;</span></span><br><span class="line">    traverse f = foldr cons_f (pure [])</span><br><span class="line">      <span class="keyword">where</span> cons_f x ys = liftA2 (:) (f x) ys</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    traverse _ (<span class="type">Left</span> x) = pure (<span class="type">Left</span> x)</span><br><span class="line">    traverse f (<span class="type">Right</span> y) = <span class="type">Right</span> &lt;$&gt; f y</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> ((,) a) <span class="keyword">where</span></span></span><br><span class="line">    traverse f (x, y) = (,) x &lt;$&gt; f y</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面的Tree也可以成为Traversable的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Tree</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; <span class="type">Tree</span> a -&gt; <span class="type">Tree</span> b</span><br><span class="line">    fmap     g <span class="type">Empty</span>        = <span class="type">Empty</span></span><br><span class="line">    fmap     g (<span class="type">Leaf</span> x)     = <span class="type">Leaf</span> $ g x</span><br><span class="line">    fmap     g (<span class="type">Node</span> l x r) = <span class="type">Node</span> (fmap g l)</span><br><span class="line">                                   (g x)</span><br><span class="line">                                   (fmap g r)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> <span class="type">Tree</span> <span class="keyword">where</span></span></span><br><span class="line">    traverse :: <span class="type">Applicative</span> f =&gt; (a -&gt; f b) -&gt; <span class="type">Tree</span> a -&gt; f (<span class="type">Tree</span> b) </span><br><span class="line">    traverse g <span class="type">Empty</span>        = pure <span class="type">Empty</span></span><br><span class="line">    traverse g (<span class="type">Leaf</span> x)     = <span class="type">Leaf</span> &lt;$&gt; g x</span><br><span class="line">    traverse g (<span class="type">Node</span> l x r) = <span class="type">Node</span> &lt;$&gt; traverse g l</span><br><span class="line">                                   &lt;*&gt; g x</span><br><span class="line">                                   &lt;*&gt; traverse g r</span><br></pre></td></tr></table></figure>

<h3 id="Traversable-Laws"><a href="#Traversable-Laws" class="headerlink" title="Traversable Laws"></a>Traversable Laws</h3><p>Traversable也有两条定律：</p>
<ol>
<li>traverse Identity <code>=</code> Identity</li>
<li>traverse (Compose . fmap g . f) <code>=</code> Compose . fmap (traverse g) . traverse f </li>
</ol>
<p>其中Identity和Compose分别定义在<code>Data.Functor.Identity</code>和<code>Data.Functor.Compose</code>两个模块中：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Identity</span> a = <span class="type">Identity</span> &#123; <span class="title">runIdentity</span> :: <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Compose</span> f g a = <span class="type">Compose</span> &#123; <span class="title">getCompose</span> :: <span class="title">f</span> (<span class="title">g</span> <span class="title">a</span>) &#125; <span class="keyword">deriving</span> (...)</span></span><br></pre></td></tr></table></figure>

<h2 id="Bifunctor"><a href="#Bifunctor" class="headerlink" title="Bifunctor"></a>Bifunctor</h2><p>Functor的实例的kind都是* -&gt; *，因此fmap只能将一个函数映射到一个值上。而Bifunctor（在<code>Data.Bifunctor</code>模块中定义）的实例的kind是* -&gt; * -&gt; *，而且它的bimap可以同时将两个函数映射到两个值上：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Bifunctor</span> p <span class="keyword">where</span></span> </span><br><span class="line">    bimap  :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d </span><br><span class="line">    first  :: (a -&gt; b) -&gt; p a c -&gt; p b c </span><br><span class="line">    second :: (b -&gt; c) -&gt; p a b -&gt; p a c </span><br><span class="line">    <span class="meta">&#123;-# MINIMAL bimap | first, second #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>同时bimap和first,second之间也可以相互转换：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bimap</span> f g = first f . second g</span><br><span class="line"></span><br><span class="line"><span class="title">first</span>  f = bimap f id</span><br><span class="line"><span class="title">second</span> g = bimap id g</span><br></pre></td></tr></table></figure>
<p>对于Functor，((,) e)和Either e才是Functor的实例，因为他们是* -&gt; *。但是对于Bifunctor，(,)和Either就是Bifunctor的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; bimap (+<span class="number">1</span>) length (<span class="number">4</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">(<span class="number">5</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Bifunctor-Laws"><a href="#Bifunctor-Laws" class="headerlink" title="Bifunctor Laws"></a>Bifunctor Laws</h3><ol>
<li>bimap id id <code>=</code> id<br> first id <code>=</code> id<br> second id <code>=</code> id</li>
<li>bimap (f . g) (h . i) <code>=</code> bimap f h . bimap g i<br> first  (f . g) <code>=</code> first f  . first g<br> second (f . g) <code>=</code> second f . second g</li>
</ol>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>Haskell中的Category将一般的函数推广到了普遍的态射上，它在<code>Control.Category</code>模块中，定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Category</span> cat <span class="keyword">where</span></span> </span><br><span class="line">    id  :: cat a a </span><br><span class="line">    (.) :: cat b c -&gt; cat a b -&gt; cat a c</span><br></pre></td></tr></table></figure>
<p>它的实例有<code>(-&gt;)</code>和<code>Kleisli m</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Category</span> (-&gt;) <span class="keyword">where</span></span></span><br><span class="line">    id = <span class="type">GHC</span>.<span class="type">Base</span>.id</span><br><span class="line">    (.) = (<span class="type">GHC</span>.<span class="type">Base</span>..)</span><br></pre></td></tr></table></figure>
<p>Kleisli是一个范畴，用来表示函数a -&gt; m b，Haskell中，它在<code>Control.Arrow</code>模块中定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Kleisli</span> m a b = <span class="type">Kleisli</span> &#123; <span class="title">runKleisli</span> :: <span class="title">a</span> -&gt; <span class="title">m</span> <span class="title">b</span> &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">Category</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    id :: <span class="type">Kleisli</span> m a a</span><br><span class="line">    id = <span class="type">Kleisli</span> return</span><br><span class="line"></span><br><span class="line">    (.) :: <span class="type">Kleisli</span> m b c -&gt; <span class="type">Kleisli</span> m a b -&gt; <span class="type">Kleisli</span> m a c</span><br><span class="line">    <span class="type">Kleisli</span> g . <span class="type">Kleisli</span> h = <span class="type">Kleisli</span> (h &gt;=&gt; g)</span><br></pre></td></tr></table></figure>
<p>Category要满足的定律只有id是(.)操作的单位元，以及(.)操作是可结合的</p>
<p>同时Category还提供了两个函数<code>&lt;&lt;&lt;</code>和<code>&gt;&gt;&gt;</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(&lt;&lt;&lt;) :: <span class="type">Category</span> cat =&gt; cat b c -&gt; cat a b -&gt; cat a c</span><br><span class="line">(&lt;&lt;&lt;) = (.)</span><br><span class="line"></span><br><span class="line">(&gt;&gt;&gt;) :: <span class="type">Category</span> cat =&gt; cat a b -&gt; cat b c -&gt; cat a c </span><br><span class="line"><span class="title">f</span> &gt;&gt;&gt; g = g . f </span><br></pre></td></tr></table></figure>

<h2 id="Arrow"><a href="#Arrow" class="headerlink" title="Arrow"></a>Arrow</h2><p>Arrow将函数进一步抽象化，它定义在<code>Control.Arrow</code>模块中：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Category</span> a =&gt; <span class="type">Arrow</span> a <span class="keyword">where</span></span> </span><br><span class="line">    arr    :: (b -&gt; c) -&gt; a b c </span><br><span class="line">    first  :: a b c -&gt; a (b, d) (c, d)</span><br><span class="line">    second :: a b c -&gt; a (d, b) (d, c)</span><br><span class="line">    (***)  :: a b c -&gt; a b&#x27; c&#x27; -&gt; a (b, b&#x27;) (c, c&#x27;)</span><br><span class="line">    (&amp;&amp;&amp;)  :: a b c -&gt; a b c&#x27; -&gt; a b (c, c&#x27;)</span><br><span class="line">    <span class="meta">&#123;-# MINIMAL arr, (first | (***)) #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>arr</code>函数将一个函数变成一个Arrow</li>
<li><code>first</code>函数将一个Arrow变成一个二元组间的Arrow，且只会对一个元素进行操作，第二个元素保持不变</li>
<li><code>second</code>函数与first相反，第一个元素保持不变</li>
<li><code>***</code>函数是Arrow之间的parallel composition，对于函数: (g *** h) (x, y) = (g x, h y)</li>
<li><code>&amp;&amp;&amp;</code>函数是Arrow之间的fanout composition，对于函数: (g &amp;&amp;&amp; h) x = (g x, h x)</li>
</ul>
<p>它的实例也有(-&gt;)和Kleisli：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Arrow</span> (-&gt;) <span class="keyword">where</span></span></span><br><span class="line">  arr :: (b -&gt; c) -&gt; (b -&gt; c)</span><br><span class="line">  arr g = g</span><br><span class="line"></span><br><span class="line">  first :: (b -&gt; c) -&gt; ((b,d) -&gt; (c,d))</span><br><span class="line">  first g (x,y) = (g x, y)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">Arrow</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">  arr :: (b -&gt; c) -&gt; <span class="type">Kleisli</span> m b c</span><br><span class="line">  arr f = <span class="type">Kleisli</span> (return . f)</span><br><span class="line"></span><br><span class="line">  first :: <span class="type">Kleisli</span> m b c -&gt; <span class="type">Kleisli</span> m (b,d) (c,d)</span><br><span class="line">  first (<span class="type">Kleisli</span> f) = <span class="type">Kleisli</span> (\ ~(b,d) -&gt; <span class="keyword">do</span> c &lt;- f b</span><br><span class="line">                                              return (c,d) )</span><br></pre></td></tr></table></figure>
<p>常用函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">returnA</span> :: <span class="type">Arrow</span> a =&gt; a b b</span><br><span class="line"><span class="title">returnA</span> = arr id</span><br><span class="line"></span><br><span class="line">(^&gt;&gt;) :: <span class="type">Arrow</span> a =&gt; (b -&gt; c) -&gt; a c d -&gt; a b d</span><br><span class="line"><span class="title">f</span> ^&gt;&gt; a = arr f &gt;&gt;&gt; a</span><br><span class="line"></span><br><span class="line">(&gt;&gt;^) :: <span class="type">Arrow</span> a =&gt; a b c -&gt; (c -&gt; d) -&gt; a b d</span><br><span class="line"><span class="title">a</span> &gt;&gt;^ f = a &gt;&gt;&gt; arr f</span><br><span class="line"></span><br><span class="line">(&lt;&lt;^) :: <span class="type">Arrow</span> a =&gt; a c d -&gt; (b -&gt; c) -&gt; a b d</span><br><span class="line"><span class="title">a</span> &lt;&lt;^ f = a &lt;&lt;&lt; arr f</span><br><span class="line"></span><br><span class="line">(^&lt;&lt;) :: <span class="type">Arrow</span> a =&gt; (c -&gt; d) -&gt; a b c -&gt; a b d</span><br><span class="line"><span class="title">f</span> ^&lt;&lt; a = arr f &lt;&lt;&lt; a</span><br></pre></td></tr></table></figure>

<h3 id="Arrow-notation"><a href="#Arrow-notation" class="headerlink" title="Arrow notation"></a>Arrow notation</h3><p>类似do-notation，Arrow也提供了一套方便的语句：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">proc</span> x -&gt; <span class="keyword">do</span> </span><br><span class="line">    y &lt;- action1 -&lt; ... </span><br><span class="line">    z &lt;- action2 -&lt; ...</span><br><span class="line">    returnA -&lt; ...</span><br></pre></td></tr></table></figure>
<p>其中proc代替了lambda表达式中的斜杠\，-&lt;右边的为输入，左边的为接收输入的函数。比如，下面三种写法达成的效果是一样的：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">f</span> = \x -&gt;</span><br><span class="line">    <span class="keyword">let</span> y  = <span class="number">2</span> * x</span><br><span class="line">        z1 = y + <span class="number">3</span></span><br><span class="line">        z2 = y - <span class="number">5</span></span><br><span class="line">    <span class="keyword">in</span> (z1, z2) </span><br><span class="line"><span class="comment">-- ghci&gt; f 10 </span></span><br><span class="line"><span class="comment">-- (23,15)</span></span><br><span class="line"></span><br><span class="line"><span class="title">fM</span> :: <span class="type">Int</span> -&gt; <span class="type">Identity</span> (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">fM</span> = \x -&gt; <span class="keyword">do</span></span><br><span class="line">    y  &lt;- return (<span class="number">2</span> * x)</span><br><span class="line">    z1 &lt;- return (y + <span class="number">3</span>)</span><br><span class="line">    z2 &lt;- return (y - <span class="number">5</span>)</span><br><span class="line">    return (z1, z2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ghci&gt; runIdentity (fM 10)</span></span><br><span class="line"><span class="comment">-- (23,15)</span></span><br><span class="line"></span><br><span class="line"><span class="title">fA</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">fA</span> = <span class="keyword">proc</span> x -&gt; <span class="keyword">do</span></span><br><span class="line">    y  &lt;- (<span class="number">2</span> *) -&lt; x</span><br><span class="line">    z1 &lt;- (+ <span class="number">3</span>) -&lt; y</span><br><span class="line">    z2 &lt;- (subtract <span class="number">5</span>) -&lt; y</span><br><span class="line">    returnA -&lt; (z1, z2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ghci&gt; fA 10</span></span><br><span class="line"><span class="comment">-- (23,15)</span></span><br></pre></td></tr></table></figure>

<h3 id="ArrowChoice"><a href="#ArrowChoice" class="headerlink" title="ArrowChoice"></a>ArrowChoice</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Arrow</span> a =&gt; <span class="type">ArrowChoice</span> a <span class="keyword">where</span></span></span><br><span class="line">    left :: a b c -&gt; a (<span class="type">Either</span> b d) (<span class="type">Either</span> c d)</span><br><span class="line">    left = (+++ id)</span><br><span class="line"></span><br><span class="line">    right :: a b c -&gt; a (<span class="type">Either</span> d b) (<span class="type">Either</span> d c)</span><br><span class="line">    right = (id +++)</span><br><span class="line"></span><br><span class="line">    (+++) :: a b c -&gt; a b&#x27; c&#x27; -&gt; a (<span class="type">Either</span> b b&#x27;) (<span class="type">Either</span> c c&#x27;)</span><br><span class="line">    f +++ g = left f &gt;&gt;&gt; arr mirror &gt;&gt;&gt; left g &gt;&gt;&gt; arr mirror</span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">        mirror :: <span class="type">Either</span> x y -&gt; <span class="type">Either</span> y x</span><br><span class="line">        mirror (<span class="type">Left</span> x) = <span class="type">Right</span> x</span><br><span class="line">        mirror (<span class="type">Right</span> y) = <span class="type">Left</span> y</span><br><span class="line"></span><br><span class="line">    (|||) :: a b d -&gt; a c d -&gt; a (<span class="type">Either</span> b c) d</span><br><span class="line">    f ||| g = f +++ g &gt;&gt;&gt; arr untag</span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">        untag (<span class="type">Left</span> x) = x</span><br><span class="line">        untag (<span class="type">Right</span> y) = y</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">ArrowChoice</span> (-&gt;) <span class="keyword">where</span></span></span><br><span class="line">    left f = f +++ id</span><br><span class="line">    right f = id +++ f</span><br><span class="line">    f +++ g = (<span class="type">Left</span> . f) ||| (<span class="type">Right</span> . g)</span><br><span class="line">    (|||) = either</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">ArrowChoice</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    left f = f +++ arr id</span><br><span class="line">    right f = arr id +++ f</span><br><span class="line">    f +++ g = (f &gt;&gt;&gt; arr <span class="type">Left</span>) ||| (g &gt;&gt;&gt; arr <span class="type">Right</span>)</span><br><span class="line">    <span class="type">Kleisli</span> f ||| <span class="type">Kleisli</span> g = <span class="type">Kleisli</span> (either f g)</span><br></pre></td></tr></table></figure>

<h3 id="ArrowZero-amp-ArrowPlus"><a href="#ArrowZero-amp-ArrowPlus" class="headerlink" title="ArrowZero &amp; ArrowPlus"></a>ArrowZero &amp; ArrowPlus</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Arrow</span> a =&gt; <span class="type">ArrowZero</span> a <span class="keyword">where</span></span></span><br><span class="line">    zeroArrow :: a b c</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">ArrowZero</span> a =&gt; <span class="type">ArrowPlus</span> a <span class="keyword">where</span></span></span><br><span class="line">    (&lt;+&gt;) :: a b c -&gt; a b c -&gt; a b c</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> m =&gt; <span class="type">ArrowZero</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    zeroArrow = <span class="type">Kleisli</span> (\_ -&gt; mzero)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> m =&gt; <span class="type">ArrowPlus</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Kleisli</span> f &lt;+&gt; <span class="type">Kleisli</span> g = <span class="type">Kleisli</span> (\x -&gt; f x `mplus` g x)</span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) &lt;+&gt; (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) <span class="number">2</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">2</span>,<span class="number">-2</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; either (+<span class="number">2</span>) (*<span class="number">3</span>) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; either (+<span class="number">2</span>) (*<span class="number">3</span>) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">2</span>) ||| (*<span class="number">3</span>) $ (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">2</span>) +++ (*<span class="number">3</span>) $ (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">2</span>) ||| (*<span class="number">3</span>) $ (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">2</span>) +++ (*<span class="number">3</span>) $ (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; left (+<span class="number">2</span>) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; right (*<span class="number">3</span>) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; left (+<span class="number">2</span>) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; right (*<span class="number">3</span>) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) ||| (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line">[<span class="number">6</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) ||| (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">-3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) +++ (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line">[<span class="type">Left</span> <span class="number">6</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) +++ (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line">[<span class="type">Right</span> <span class="number">3</span>,<span class="type">Right</span> (<span class="number">-3</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia - Haskell wiki</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/78679542">Haskell语言学习笔记（40）Arrow（1） - zwvista</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-21-arrows.html">24 Days of GHC Extensions: Arrows - Tom Ellis</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/78690485">Haskell语言学习笔记（47）Arrow（2） - zwvista</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#A Haskell与范畴论</title>
    <url>/p/96c32eae.html</url>
    <content><![CDATA[<p>Haskell中的函子单子等都与范畴论（category theory）有很多联系，所以打算简单了解一下范畴论的相关内容。</p>
<blockquote>
<p><strong>范畴论</strong>是数学的一门学科，以抽象的方法处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。数学中许多重要的领域可以形式化为范畴。使用范畴论可以令这些领域中许多难理解、难捉摸的数学结论更容易叙述证明。</p>
<div style="text-align: right">———— 维基百科</div>
</blockquote>
<h2 id="范畴（Category）"><a href="#范畴（Category）" class="headerlink" title="范畴（Category）"></a>范畴（Category）</h2><p>范畴本质上是一个简单的集合，一个范畴$\mathbf{C}$包含三个组成成分：</p>
<span id="more"></span>
<ul>
<li>一个类$\mathrm{ob}(\mathbf{C})$：其中元素称为<strong>对象（objects）</strong></li>
<li>一个类$\mathrm{hom}(\mathbf{C})$：其中元素称为<strong>态射（morphisms）</strong>（或<strong>箭号（arrows）</strong>）：每个态射连接了两个对象：源对象（source object）、目标对象（target object）。如果$f$是从源对象$A$到目标对象$B$（$A, B\in \mathrm{ob}(\mathbf{C})$）的态射，那么记为$f : A\to B$</li>
<li>一个二元运算，称为态射<strong>复合（composition）</strong>：两个态射$g : A\to B$、$f : B\to C$的复合记为$f\circ g : A\to C$<br>在Haskell和大部分数学理论中都是从右向左计算，即$f\circ g$中是先计算$g : A\to B$再计算$f : B\to C$</li>
</ul>
<p>许多东西都可以组成范畴。比如:</p>
<p>&emsp;$\mathbf{Set}$是一个范畴，对象为所有集合，态射为集合之间的函数，复合即函数之间的复合</p>
<p>&emsp;$\mathbf{Grp}$是一个范畴，对象为所有群，态射为群同态（group homomorphisms），例如对于群$(G,*)$和$(H,\cdot )$，有群同态$h : (G,*)\to (H,\cdot )$，则需要对于$G$中的任意元素$u,v$满足<br>$$h(u*v)=h(u)\cdot h(v)$$</p>
<p><strong>注意</strong>：态射不必须为函数；而且可以存在源对象和目标对象都相同的不同态射</p>
<h3 id="范畴公理"><a href="#范畴公理" class="headerlink" title="范畴公理"></a>范畴公理</h3><p>每个范畴都需要满足三条定律：</p>
<ol>
<li>态射复合需要满足<strong>结合律（associativity）</strong>：<br>$$f\circ (g\circ h) = (f\circ g)\circ h$$</li>
<li>范畴在复合操作下是<strong>闭合的（closed）</strong>：<br>&emsp;&emsp;&emsp;如果范畴$\mathbf{C}$中存在态射$f : B\to C$、$g : A\to B$，那么范畴$\mathbf{C}$中也一定存在态射$h : A\to C$，且$h=f\circ g$</li>
<li>每个对象都需要有<strong>单位态射（identity morphisms）</strong>：<br>&emsp;&emsp;&emsp;对于范畴$\mathbf{C}$中的对象$A$，一定存在单位态射$\mathrm{id}_A : A\to A$，且对于每个态射$g : A\to B$，一定有：<br>$$g\circ\mathrm{id}_A = \mathrm{id}_B\circ g = g$$</li>
</ol>
<h3 id="mathbf-Hask-范畴"><a href="#mathbf-Hask-范畴" class="headerlink" title="$\mathbf{Hask}$范畴"></a>$\mathbf{Hask}$范畴</h3><p>范畴$\mathbf{Hask}$的对象为Haskell中的类型（types），态射是Haskell中的函数，复合运算是<code>(.)</code>。即从类型A到类型B的函数 f :: A -&gt; B 就是$\mathbf{Hask}$范畴中的一个态射。而函数 f :: B -&gt; C 、g :: A -&gt; B 的组合 f . g 就是一个新的函数 h :: A -&gt; C。</p>
<p>对于三条定律：</p>
<ol>
<li>第一条显然满足：f . (g . h) = (f . g) . h</li>
<li>第二条也显然满足，如果有函数 f :: B -&gt; C 、g :: A -&gt; B，一定有函数 h = (f . g) :: A -&gt; C </li>
<li>对于第三条定律，Haskell中存在单位函数 id ，但id是多态（polymorphic）的，要为其指定类型使其变成单态（monomorphic）的。比如态射$\mathrm{id}_A$在Haskell中就可以表示为 id :: A -&gt; A。并且显然满足第三条定律（其中 f :: A -&gt; B）：<p style="text-align: center;">(id :: B -> B) . f = f . (id :: A -> A) = f</p></li>
</ol>
<h2 id="函子（Functors）"><a href="#函子（Functors）" class="headerlink" title="函子（Functors）"></a>函子（Functors）</h2><p>一个范畴中的态射将两个对象联系起来，而函子则会将两个范畴联系起来。换句话说，函子就是从一个范畴到另一个范畴的变换。比如对于范畴$\mathbf{C}$、$\mathbf{D}$，定义函子$F : \mathbf{C}\to\mathbf{D}$满足：</p>
<ul>
<li>对于$\mathbf{C}$中的任意对象$A$，在$\mathbf{D}$中都有对象$F(A)$</li>
<li>对于$\mathbf{C}$中的任意态射$f : A\to B$，在$\mathbf{D}$中都有态射$F(f) : F(A)\to F(B)$</li>
</ul>
<p>比如：</p>
<p>&emsp;遗忘函子（forgetful functor）$U : \mathbf{Grp}\to\mathbf{Set}$，将一个群映射到一个集合中，将群同态映射到集合间的函数</p>
<p>&emsp;幂集函子（power set functor）$P : \mathbf{Set}\to\mathbf{Set}$，将一个集合映射到它的幂集，将原集合中的函数$f : A\to B$映射到函数$P(f) : \mathcal{P}(A)\to\mathcal{P}(B)$，即从$U\subseteq A$到值域$f(U)\subseteq B$的映射</p>
<p>&emsp;自函子（endofunctor）$1_{\mathbf{C}} : \mathbf{C}\to\mathbf{C}$，将一个范畴映射到它本身</p>
<h3 id="函子公理"><a href="#函子公理" class="headerlink" title="函子公理"></a>函子公理</h3><p>函子$F : \mathbf{C}\to\mathbf{D}$也需要满足两个公理：</p>
<ol>
<li>对于任意对象$X\in\mathbf{C}$，恒有$F(\mathrm{id}_X)=\mathrm{id}_{F(X)}$</li>
<li>对于态射$f : Y\to Z$、$g : X\to Y$，恒有$F(f\circ g) = F(f)\circ F(g)$</li>
</ol>
<h3 id="mathbf-Hask-范畴上的函子"><a href="#mathbf-Hask-范畴上的函子" class="headerlink" title="$\mathbf{Hask}$范畴上的函子"></a>$\mathbf{Hask}$范畴上的函子</h3><p>Haskell中的Functor定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> (<span class="title">f</span> :: * -&gt; *) <span class="keyword">where</span></span> </span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>对于Haskell中的Functor，它实际上是从$\mathbf{Hask}$范畴（types）到它子范畴的变换。比如列表函子$\mathtt{[]} : \mathbf{Hask}\to\mathbf{Lst}$（其中$\mathbf{Lst}$是所有Haskell中列表类型构成的范畴）</p>
<p>它也达成了范畴论中对于函子的要求。函子需要进行两个操作：将一个范畴中的对象映射到另一个范畴中、将一个范畴中的态射映射到另一个范畴中。以Maybe为例，它实现了函子的要求：</p>
<ol>
<li>Maybe是一个类型构造器，他可以将任意类型 T 变成新类型 Maybe T，相当于从$\mathbf{Hask}$范畴的对象变成了$\mathbf{Maybe}$范畴的对象 </li>
<li>fmap函数接收一个 a -&gt; b 类型的函数，返回一个 Maybe a -&gt; Maybe b 类型的函数，相当于将$\mathbf{Hask}$范畴中的态射$f : A\to B$映射成了$\mathbf{Maybe}$范畴中的态射$\mathbf{Maybe}(f) : \mathbf{Maybe}(A)\to\mathbf{Maybe}(B)$</li>
</ol>
<p><strong>注意</strong>：时刻记住这里研究的是$\mathbf{Hask}$范畴和它的子范畴，对象是类型而不是值，态射是函数也指的是从类型到类型</p>
<p>同时，Haskell中的Functor也满足函子公理：</p>
<ol>
<li>fmap id = id 即 fmap (id :: A -&gt; A) = (id :: f A -&gt; f A)</li>
<li>fmap (f . g) = fmap f . fmap g</li>
</ol>
<h2 id="单子（Monads）"><a href="#单子（Monads）" class="headerlink" title="单子（Monads）"></a>单子（Monads）</h2><blockquote>
<p>一个单子说白了不过就是自函子范畴上的一个幺半群而已 _(:з」∠)_</p>
</blockquote>
<p>自函子在前面说到过是从一个范畴到自身的一个函子，如范畴$\mathbf{C}$上的自函子是$F : \mathbf{C}\to\mathbf{C}$。自函子范畴就是对象都是自函子的范畴。幺半群和Haskell中学到的Monoid类型类一样，是一个有可结合二元运算和单位元的代数结构。因此单子就是一个自函子，而且它有可结合二元运算（Haskell中<code>&gt;=&gt;</code>）和单位元（Haskell中<code>return</code>）。</p>
<p>一个单子$M : \mathbf{C}\to\mathbf{C}$还包含两个态射（对于范畴$\mathbf{C}$中的所有对象$X$）：</p>
<ol>
<li>$\mathrm{unit}_X^M : X\to M(X)$</li>
<li>$\mathrm{join}_X^M : M(M(X))\to M(X)$</li>
</ol>
<p>（当式子中的单子明显是$M$时，可以省略上标${}^M$）</p>
<p>Haskell中Monad的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span> </span><br><span class="line">    return :: a -&gt; m a </span><br><span class="line">    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure>
<p>其中很显然多态函数<code>return</code>对应了定义中的$\mathrm{unit}$，但是<code>&gt;&gt;=</code>和$mathrm{join}$的对应关系并不明显。因此Haskell中有一个工具函数<code>join</code>，它的效果就是定义中的$\mathrm{join}$，而且它可以和<code>&gt;&gt;=</code>互相定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a</span><br><span class="line"><span class="title">join</span> x = x &gt;&gt;= id</span><br><span class="line"></span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b </span><br><span class="line"><span class="title">x</span> &gt;&gt;= f = join $ fmap f x</span><br></pre></td></tr></table></figure>
<p>所以Haskell中为Monad要求定义<code>&gt;&gt;=</code>就相当于定义了$\mathrm{join}$</p>
<p>例如，幂集函子$P : \mathbf{Set}\to\mathbf{Set}$也是一个单子，可以为它定义$\mathrm{unit}$和$\mathrm{join}$两个态射。Haskell中的列表也可以近似看作幂集函子。</p>
<p>&emsp;态射/函数的类型：</p>
<table>
<thead>
<tr>
<th align="center">幂集函子</th>
<th align="center">Haskell中列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一个集合$S$和一个态射$f : A\to B$</td>
<td align="center">一个类型 T 和一个函数 f :: A -&gt; B</td>
</tr>
<tr>
<td align="center">$P(f) : \mathcal{P}(A)\to\mathcal{P}(B)$</td>
<td align="center">fmap f :: [A] -&gt; [B]</td>
</tr>
<tr>
<td align="center">$\mathrm{unit}_S : S\to\mathcal{P}(S)$</td>
<td align="center">return :: T -&gt; [T]</td>
</tr>
<tr>
<td align="center">$\mathrm{join}_S : \mathcal{P}(\mathcal{P}(S))\to\mathcal{P}(S)$</td>
<td align="center">join :: [[T]] -&gt; [T]</td>
</tr>
</tbody></table>
<p>&emsp;态射/函数的定义：</p>
<table>
<thead>
<tr>
<th align="center">幂集函子</th>
<th align="center">Haskell中列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$(\mathcal{P}(f))(S) = \{f(a):a\in S\}$</td>
<td align="center">fmap f xs = [ f a | a &lt;- xs ]</td>
</tr>
<tr>
<td align="center">$\mathrm{unit}_S(x) = \{x\}$</td>
<td align="center">return x = [x]</td>
</tr>
<tr>
<td align="center">$\mathrm{join}_S(L) = \bigcup L$</td>
<td align="center">join xs = concat xs</td>
</tr>
</tbody></table>
<h3 id="单子公理"><a href="#单子公理" class="headerlink" title="单子公理"></a>单子公理</h3><p>给定一个单子$M : \mathbf{C}\to\mathbf{C}$，和一个态射$f : A\to B$（其中$A,B\in \mathbf{C}$），那么满足下面四条定律：</p>
<ol>
<li>$\mathrm{join}\circ M(\mathrm{join})=\mathrm{join}\circ\mathrm{join}$</li>
<li>$\mathrm{join}\circ M(\mathrm{unit})=\mathrm{join}\circ\mathrm{unit}=\mathrm{id}$</li>
<li>$\mathrm{unit}\circ f = M(f)\circ\mathrm{unit}$</li>
<li>$\mathrm{join}\circ M(M(f)) = M(f)\circ\mathrm{join}$</li>
</ol>
<p>也可以很自然地将其转化为Haskell中的表述：</p>
<ol>
<li>join . fmap join <code>=</code> join . join </li>
<li>join . fmap return <code>=</code> join . return <code>=</code> id </li>
<li>return . f <code>=</code> fmap f . return </li>
<li>join . fmap (fmap f) <code>=</code> fmap f . join</li>
</ol>
<p>在Haskell中，使用<code>&gt;&gt;=</code>也有三个定律和这四个定律是等价的：</p>
<ol>
<li>return x &gt;&gt;= f <code>=</code> f x <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  return x &gt;&gt;= f </span><br><span class="line">= join (fmap f (return x)) = join (fmap f . return $ x)</span><br><span class="line">= join (return (f x)) = join (return . f $ x)</span><br><span class="line">= join . return $ (f x)</span><br><span class="line">= id (f x)</span><br><span class="line">= f x</span><br></pre></td></tr></table></figure></li>
<li>m &gt;&gt;= return <code>=</code> m<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  m &gt;&gt;= return </span><br><span class="line">= join (fmap return m) = join . fmap return $ m </span><br><span class="line">= id m</span><br><span class="line">= m </span><br></pre></td></tr></table></figure></li>
<li>(m &gt;&gt;= f) &gt;&gt;= g <code>=</code> m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (m &gt;&gt;= f) &gt;&gt;= g </span><br><span class="line">= (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))</span><br><span class="line">= join . fmap g . join $ fmap f m </span><br><span class="line">= join . join . fmap (fmap g) $ fmap f m </span><br><span class="line">= join . join . fmap (fmap g) . fmap f $ m </span><br><span class="line">= join . join . fmap (fmap g . f) $ m </span><br><span class="line">= join . fmap join . fmap (fmap g . f) $ m </span><br><span class="line">= join . fmap (join . (fmap g . f)) $ m </span><br><span class="line">= join . fmap (\x -&gt; join (fmap g (f x))) $ m </span><br><span class="line">= join . fmap (\x -&gt; f x &gt;&gt;= g) $ m </span><br><span class="line">= join (fmap (\x -&gt; f x &gt;&gt;= g) m)</span><br><span class="line">= m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>（范畴论就先简单看这些，只是为了更好理解Haskell中概念而已）</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell/Category theory - wikibooks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Category_theory">Category theory - wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论 - 维基百科</a></li>
<li><a href="https://en.wikipedia.org/wiki/Monad_(category_theory)">Monad (category theory) - wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Functor">Functor - wikipedia</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>

]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
        <tag>范畴论</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#6 半群与幺半群</title>
    <url>/p/d4bb2633.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/290ecb74.html">&lt; #5</a></p>
<p><a href="/p/68ef8146.html">#7 &gt;</a></p>
</div>


<h2 id="Semigroup"><a href="#Semigroup" class="headerlink" title="Semigroup"></a>Semigroup</h2><p>半群（semigroup）是一个集合$S$，它需要指定一个二元运算符$\oplus$，并且满足</p>
<p>$$<br>a\oplus b \in S\quad a, b\in S<br>$$</p>
<p>以及结合（associative）律：</p>
<p>$$<br>(a\oplus b)\oplus c = a\oplus (b\oplus c)<br>$$</p>
<p>这个二元运算符在Haskell的Semigroup中被定义为<code>&lt;&gt;</code>函数：</p>
<span id="more"></span>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Semigroup</span> a <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) :: a -&gt; a -&gt; a </span><br><span class="line"></span><br><span class="line">    sconcat :: <span class="type">NonEmpty</span> a -&gt; a </span><br><span class="line">    sconcat (a :| <span class="keyword">as</span>) = go a <span class="keyword">as</span> <span class="keyword">where</span> </span><br><span class="line">        go b (c:cs) = b &lt;&gt; go c cs </span><br><span class="line">        go b []     = b</span><br><span class="line">    </span><br><span class="line">    stimes :: <span class="type">Integarl</span> b =&gt; b -&gt; a -&gt; a </span><br><span class="line">    stimes = ...</span><br></pre></td></tr></table></figure>
<p>除此之外还有<code>sconcat</code>和<code>stimes</code>函数，都给出了默认实现。对于列表，&lt;&gt;相当于(++)，stimes相当于concat . replicate：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; sconcat $ fromList [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; stimes <span class="number">3</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Semigroup-Law"><a href="#Semigroup-Law" class="headerlink" title="Semigroup Law"></a>Semigroup Law</h3><ul>
<li>(x &lt;&gt; y) &lt;&gt; z <code>=</code> x &lt;&gt; (y &lt;&gt; z)</li>
</ul>
<h3 id="补：NonEmpty"><a href="#补：NonEmpty" class="headerlink" title="补：NonEmpty"></a>补：NonEmpty</h3><p>NonEmpty表示非空列表，定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NonEmpty</span> a = a :| [a] <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>)</span></span><br></pre></td></tr></table></figure>
<p>使用一个元素和一个列表用<code>:|</code>连接就可以生成一个NonEmpty类型的列表</p>
<p><code>Data.List.NonEmpty</code>模块中实现了很多普通列表有的函数，需要qualified import后调用，使用fromList、toList函数可以在普通列表和非空列表之间转换</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">import</span> <span class="keyword">qualified</span> Data.List.NonEmpty <span class="keyword">as</span> NE</span><br><span class="line"><span class="title">ghci</span>&gt; arr = <span class="type">NE</span>.fromList [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; arr</span><br><span class="line"><span class="number">1</span> :| [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">NE</span>.head arr </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">NE</span>.tail arr </span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h2><p>幺半群（Monoid）是一个有单位元素$e$的半群，即$e$满足：</p>
<p>$$<br>e\oplus x = x\oplus e = x<br>$$</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Semigroup</span> a =&gt; <span class="type">Monoid</span> a <span class="keyword">where</span></span> </span><br><span class="line">    mempty  :: a </span><br><span class="line">    </span><br><span class="line">    mappend :: a -&gt; a -&gt; a </span><br><span class="line">    mappend = (&lt;&gt;)</span><br><span class="line"></span><br><span class="line">    mconcat :: [a] -&gt; a </span><br><span class="line">    mconcat = foldr mappend mempty </span><br></pre></td></tr></table></figure>
<p>可以看出Monoid要求了三个函数，其中最少只需要<code>mempty</code>，它直接返回一个值，表示单位元素。<code>mappend</code>即Semigroup中的&lt;&gt;运算符，<code>mconcat</code>也提供了默认实现</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="a"><a href="#a" class="headerlink" title="[a]"></a>[a]</h4><p>因为Monoid的实例是一个具体类型，而不是像Functor等一样等类型构造器，所以[]并不是Monoid的实例，但是具体类型[a]是一个幺半群：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> [a] <span class="keyword">where</span></span> </span><br><span class="line">    (&lt;&gt;) = (++)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> [a] <span class="keyword">where</span></span> </span><br><span class="line">    mempty = [] </span><br><span class="line">    mconcat xss = [x | xs &lt;- xss, x &lt;- xs]</span><br></pre></td></tr></table></figure>
<p>列表的单位元素(mempty)就是空列表[]，运算符就是合并列表(++)，mconcat也用列表推导重新实现提高效率</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mempty :: [<span class="type">Int</span>] </span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] `mappend` [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; mconcat [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">Ordering</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">LT</span> &lt;&gt; _ = <span class="type">LT</span></span><br><span class="line">    <span class="type">EQ</span> &lt;&gt; y = y</span><br><span class="line">    <span class="type">GT</span> &lt;&gt; _ = <span class="type">GT</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Ordering</span> <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">EQ</span></span><br></pre></td></tr></table></figure>
<p>主要可以用于比较字典序：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mconcat (zipWith compare <span class="string">&quot;abcd&quot;</span> <span class="string">&quot;acbd&quot;</span>)</span><br><span class="line"><span class="type">LT</span></span><br></pre></td></tr></table></figure>

<h4 id="Sum-amp-Product"><a href="#Sum-amp-Product" class="headerlink" title="Sum &amp; Product"></a>Sum &amp; Product</h4><p>对于数字，加法和乘法都满足结合律，所以对于Num，有两种实现Monoid的方式，但是不能为同一类型设置两种实例方式，所以<code>Data.Monoid</code>中提供了两个包装器————Sum和Product：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Sum</span> a = <span class="type">Sum</span> &#123;<span class="title">getSum</span> :: <span class="title">a</span>&#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Product</span> a = <span class="type">Product</span> &#123;<span class="title">getProduct</span> :: <span class="title">a</span>&#125; <span class="keyword">deriving</span> (...)</span></span><br></pre></td></tr></table></figure>
<p>它们使用Sum或Product来包装起一个数字，可以通过getSum或getProduct来获取其中的值</p>
<p>对于加法，二元操作为(+)，单位元素为0；对于乘法，二元操作为(*)，单位元素为1:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Sum</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Sum</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Sum</span> <span class="number">0</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Product</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Product</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Product</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Sum</span> <span class="number">5</span> &lt;&gt; <span class="type">Sum</span> <span class="number">6</span> &lt;&gt; <span class="type">Sum</span> <span class="number">10</span></span><br><span class="line"><span class="type">Sum</span> &#123;getSum = <span class="number">21</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; getSum . mconcat . fmap <span class="type">Sum</span> $ [<span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Product</span> <span class="number">5</span> &lt;&gt; <span class="type">Product</span> <span class="number">6</span> &lt;&gt; <span class="type">Product</span> <span class="number">10</span></span><br><span class="line"><span class="type">Product</span> &#123;getProduct = <span class="number">300</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; getProduct . mconcat . fmap <span class="type">Product</span> $ [<span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure>

<h4 id="All-amp-Any"><a href="#All-amp-Any" class="headerlink" title="All &amp; Any"></a>All &amp; Any</h4><p>和数字一样，布尔值也有两种实现Monoid的方式，因此<code>Data.Monoid</code>模块中也提供了两个包装器，分别实现了这两种Monoid：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">All</span> = <span class="type">All</span> &#123; <span class="title">getAll</span> :: <span class="type">Bool</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">All</span> <span class="keyword">where</span></span></span><br><span class="line">        (&lt;&gt;) = coerce (&amp;&amp;)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">All</span> <span class="keyword">where</span></span></span><br><span class="line">        mempty = <span class="type">All</span> <span class="type">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Any</span> = <span class="type">Any</span> &#123; <span class="title">getAny</span> :: <span class="type">Bool</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">Any</span> <span class="keyword">where</span></span></span><br><span class="line">        (&lt;&gt;) = coerce (||)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Any</span> <span class="keyword">where</span></span></span><br><span class="line">        mempty = <span class="type">Any</span> <span class="type">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getAll (<span class="type">All</span> <span class="type">True</span> &lt;&gt; mempty &lt;&gt; <span class="type">All</span> <span class="type">False</span>)</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="title">ghci</span>&gt; getAll (mconcat (map (\x -&gt; <span class="type">All</span> (even x)) [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]))</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="title">ghci</span>&gt; getAny (<span class="type">Any</span> <span class="type">True</span> &lt;&gt; mempty &lt;&gt; <span class="type">Any</span> <span class="type">False</span>)</span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span>&gt; getAny (mconcat (map (\x -&gt; <span class="type">Any</span> (even x)) [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]))</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>

<h4 id="Monoid-a-gt-Maybe-a"><a href="#Monoid-a-gt-Maybe-a" class="headerlink" title="Monoid a =&gt; Maybe a"></a>Monoid a =&gt; Maybe a</h4><p>如果a是一个(幺)半群，那么Maybe a也是一个幺半群，单位元就是Nothing：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Nothing</span> &lt;&gt; b       = b</span><br><span class="line">    a       &lt;&gt; <span class="type">Nothing</span> = a</span><br><span class="line">    <span class="type">Just</span> a  &lt;&gt; <span class="type">Just</span> b  = <span class="type">Just</span> (a &lt;&gt; b)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;&gt; <span class="type">Just</span> <span class="string">&quot;andy&quot;</span></span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;andy&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="type">LT</span> &lt;&gt; <span class="type">Nothing</span></span><br><span class="line"><span class="type">Just</span> <span class="type">LT</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (<span class="type">Sum</span> <span class="number">3</span>) &lt;&gt; <span class="type">Just</span> (<span class="type">Sum</span> <span class="number">4</span>) </span><br><span class="line"><span class="type">Just</span> (<span class="type">Sum</span> &#123;getSum = <span class="number">7</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="First-amp-Last"><a href="#First-amp-Last" class="headerlink" title="First &amp; Last"></a>First &amp; Last</h4><p>对于Maybe也有两种实现Monoid的方法，即&lt;&gt;操作每次恒取左边和每次恒取右边（在没有Nothing的情况下），所以<code>Data.Monoid</code>模块中也提供了两个新的包装器：First和Last：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">First</span> a = <span class="type">First</span> &#123; <span class="title">getFirst</span> :: <span class="type">Maybe</span> <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> (<span class="type">First</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">First</span> <span class="type">Nothing</span> &lt;&gt; b = b</span><br><span class="line">    a             &lt;&gt; _ = a</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> (<span class="type">First</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">First</span> <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Last</span> a = <span class="type">Last</span> &#123; <span class="title">getLast</span> :: <span class="type">Maybe</span> <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> (<span class="type">Last</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    a &lt;&gt; <span class="type">Last</span> <span class="type">Nothing</span> = a</span><br><span class="line">    _ &lt;&gt; b            = b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> (<span class="type">Last</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Last</span> <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getFirst (<span class="type">First</span> (<span class="type">Just</span> <span class="string">&quot;hello&quot;</span>) &lt;&gt; <span class="type">First</span> <span class="type">Nothing</span> &lt;&gt; <span class="type">First</span> (<span class="type">Just</span> <span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; getLast (<span class="type">Last</span> (<span class="type">Just</span> <span class="string">&quot;hello&quot;</span>) &lt;&gt; <span class="type">Last</span> <span class="type">Nothing</span> &lt;&gt; <span class="type">Last</span> (<span class="type">Just</span> <span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; getFirst . mconcat . map <span class="type">First</span> $ [<span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">9</span>, <span class="type">Just</span> <span class="number">10</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; getLast . mconcat . map <span class="type">Last</span> $ [<span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">9</span>, <span class="type">Just</span> <span class="number">10</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="Min-amp-Max"><a href="#Min-amp-Max" class="headerlink" title="Min &amp; Max"></a>Min &amp; Max</h4><p>对于有界的类型，也有两种实现Monoid的方式，每次二元操作都取最小或最大。<code>Data.Semigroup</code>模块中提供了两个包装其器：Min和Max：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Min</span> a = <span class="type">Min</span> &#123; <span class="title">getMin</span> :: <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Ord</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Min</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Ord</span> <span class="title">a</span>, <span class="type">Bounded</span> <span class="title">a</span>) =&gt; <span class="type">Monoid</span> (<span class="type">Min</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = maxBound</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Max</span> a = <span class="type">Max</span> &#123; <span class="title">getMax</span> :: <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Ord</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Max</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Ord</span> <span class="title">a</span>, <span class="type">Bounded</span> <span class="title">a</span>) =&gt; <span class="type">Monoid</span> (<span class="type">Max</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = minBound</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Min</span> <span class="number">3</span> &lt;&gt; <span class="type">Min</span> <span class="number">5</span></span><br><span class="line"><span class="type">Min</span> &#123;getMin = <span class="number">3</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Max</span> <span class="number">3</span> &lt;&gt; <span class="type">Max</span> <span class="number">5</span></span><br><span class="line"><span class="type">Max</span> &#123;getMax = <span class="number">5</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; getMin . mconcat . map <span class="type">Min</span> $ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] :: <span class="type">Int</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="title">ghci</span>&gt; getMax . mconcat . map <span class="type">Max</span> $ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] :: <span class="type">Int</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>当元组内的所有元素都是幺半群时，整个元组也是一个幺半群：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Semigroup</span> <span class="title">a</span>, <span class="type">Semigroup</span> <span class="title">b</span>) =&gt; <span class="type">Semigroup</span> (<span class="title">a</span>, <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">        (a,b) &lt;&gt; (a&#x27;,b&#x27;) = (a&lt;&gt;a&#x27;,b&lt;&gt;b&#x27;)</span><br><span class="line">        stimes n (a,b) = (stimes n a, stimes n b)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Monoid</span> <span class="title">a</span>, <span class="type">Monoid</span> <span class="title">b</span>) =&gt; <span class="type">Monoid</span> (<span class="title">a</span>,<span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">        mempty = (mempty, mempty)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mconcat $ map (\x -&gt; (<span class="type">Min</span> x, <span class="type">Max</span> x)) [<span class="number">1.</span><span class="number">.10</span>] :: (<span class="type">Min</span> <span class="type">Int</span>, <span class="type">Max</span> <span class="type">Int</span>)</span><br><span class="line">(<span class="type">Min</span> &#123;getMin = <span class="number">1</span>&#125;,<span class="type">Max</span> &#123;getMax = <span class="number">10</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Monoid-Laws"><a href="#Monoid-Laws" class="headerlink" title="Monoid Laws"></a>Monoid Laws</h3><ul>
<li>mempty &lt;&gt; x <code>=</code> x</li>
<li>x &lt;&gt; mempty <code>=</code> x</li>
<li>(x &lt;&gt; y) &lt;&gt; z <code>=</code> x &lt;&gt; (y &lt;&gt; z)</li>
</ul>
<h2 id="Monoidal-classes"><a href="#Monoidal-classes" class="headerlink" title="Monoidal classes"></a>Monoidal classes</h2><p>Applicative、Monad、Arrow都有有幺半群性质的子类型类，分别是Alternative、MonadPlus、ArrowPlus</p>
<h3 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> f =&gt; <span class="type">Alternative</span> f <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- | The identity of &#x27;&lt;|&gt;&#x27;</span></span><br><span class="line">    empty :: f a</span><br><span class="line">    <span class="comment">-- | An associative binary operation</span></span><br><span class="line">    (&lt;|&gt;) :: f a -&gt; f a -&gt; f a</span><br><span class="line"></span><br><span class="line">    some :: f a -&gt; f [a]</span><br><span class="line">    some v = (:) &lt;$&gt; v &lt;*&gt; many v</span><br><span class="line">    many :: f a -&gt; f [a]</span><br><span class="line">    many v = some v &lt;|&gt; pure []</span><br></pre></td></tr></table></figure>
<p>其中empty是幺半群中的单位元素，&lt;|&gt;是幺半群中的二元运算符。some和many是两个函数（<del>意义还不懂</del>）</p>
<h4 id="Alternative实例"><a href="#Alternative实例" class="headerlink" title="Alternative实例"></a>Alternative实例</h4><h5 id><a href="#" class="headerlink" title="[]"></a>[]</h5><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> [] <span class="keyword">where</span></span></span><br><span class="line">    empty = []</span><br><span class="line">    (&lt;|&gt;) = (++)</span><br></pre></td></tr></table></figure>
<p>和Monoid一样，单位元素是空列表，二元运算是列表合并</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &lt;|&gt; empty &lt;|&gt; [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; some []</span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; many []</span><br><span class="line">[[]]</span><br></pre></td></tr></table></figure>
<h5 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h5><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    empty = <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Nothing</span> &lt;|&gt; r = r</span><br><span class="line">    l       &lt;|&gt; _ = l</span><br></pre></td></tr></table></figure>
<p>Maybe作为Alternative的单位元素是Nothing，二元运算是始终取左边（当左边不为Nothing时）</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;|&gt; <span class="type">Just</span> <span class="number">1</span> &lt;|&gt; <span class="type">Just</span> <span class="number">2</span> </span><br><span class="line"><span class="type">Just</span> <span class="number">1</span> </span><br><span class="line"><span class="title">ghci</span>&gt; some <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span> </span><br><span class="line"><span class="title">ghci</span>&gt; many <span class="type">Nothing</span> </span><br><span class="line"><span class="type">Just</span> []</span><br></pre></td></tr></table></figure>
<h5 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h5><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> <span class="type">ZipList</span> <span class="keyword">where</span></span></span><br><span class="line">   empty = <span class="type">ZipList</span> []</span><br><span class="line">   <span class="type">ZipList</span> xs &lt;|&gt; <span class="type">ZipList</span> ys = <span class="type">ZipList</span> (xs ++ drop (length xs) ys)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&lt;&gt;getZipList $ <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>] &lt;|&gt; <span class="type">ZipList</span> [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&lt;&gt;getZipList $ <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] &lt;|&gt; <span class="type">ZipList</span> [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Alternative-Laws"><a href="#Alternative-Laws" class="headerlink" title="Alternative Laws"></a>Alternative Laws</h4><ul>
<li><code>Monoid laws</code>:  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">empty</span> &lt;|&gt; x = x </span><br><span class="line"><span class="title">x</span> &lt;|&gt; empty = x </span><br><span class="line">(x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z)</span><br></pre></td></tr></table></figure></li>
<li><code>Left zero law</code>：empty &lt;*&gt; f <code>=</code> empty<br>以上的定律是都满足都，下面的定律只有部分满足：</li>
<li><code>Right zero law</code>：f &lt;*&gt; empty <code>=</code> empty （大部分包括Maybe、[]满足，IO不满足）</li>
<li><code>Left distribution</code>：(a &lt;|&gt; b) &lt;*&gt; c <code>=</code> (a &lt;*&gt; c) &lt;|&gt; (b &lt;*&gt; c) （Maybe、[]满足，IO及大部分parsers不满足）</li>
<li><code>Right distribution</code>：a &lt;*&gt; (b &lt;|&gt; c) <code>=</code> (a &lt;*&gt; b) &lt;|&gt; (a &lt;*&gt; c) （大部分不满足，但Maybe满足）</li>
<li><code>Left catch</code>：(pure a) &lt;|&gt; x = pure a （Maybe、IO、parsers满足，但[]不满足）</li>
</ul>
<h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li><code>asum</code> :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a，相当于foldr (&lt;|&gt;) empty：  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; asum [<span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">5</span>, <span class="type">Just</span> <span class="number">3</span>]</span><br><span class="line"><span class="type">Just</span> <span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; asum [[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></li>
<li><code>guard</code> :: (Alternative f) =&gt; Bool -&gt; f ()：  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">guard</span> <span class="type">True</span>  = pure ()</span><br><span class="line"><span class="title">guard</span> <span class="type">False</span> = empty </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="MonadPlus"><a href="#MonadPlus" class="headerlink" title="MonadPlus"></a>MonadPlus</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Alternative</span> <span class="title">m</span>, <span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">MonadPlus</span> m <span class="keyword">where</span></span></span><br><span class="line">   mzero :: m a</span><br><span class="line">   mzero = empty</span><br><span class="line"></span><br><span class="line">   mplus :: m a -&gt; m a -&gt; m a</span><br><span class="line">   mplus = (&lt;|&gt;)</span><br></pre></td></tr></table></figure>

<h4 id="MonadPlus实例"><a href="#MonadPlus实例" class="headerlink" title="MonadPlus实例"></a>MonadPlus实例</h4><p>[]、Maybe都是MonadPlus的实例，mzero和mplus都由Alternative实现</p>
<h4 id="MonadPlus-Laws"><a href="#MonadPlus-Laws" class="headerlink" title="MonadPlus Laws"></a>MonadPlus Laws</h4><ul>
<li><code>Monoid laws</code></li>
<li><code>Left zero</code>：mzero &gt;&gt;= f <code>=</code> mzero</li>
<li><code>Right zero</code>：m &gt;&gt; mzero <code>=</code> mzero </li>
</ul>
<h4 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li><code>msum</code> = asum </li>
<li><code>mfilter</code>：  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">mfilter</span> p ma = <span class="keyword">do</span></span><br><span class="line">    a &lt;- ma</span><br><span class="line">    <span class="keyword">if</span> p a <span class="keyword">then</span> return a <span class="keyword">else</span> mzero</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ArrowPlus"><a href="#ArrowPlus" class="headerlink" title="ArrowPlus"></a>ArrowPlus</h3><p>ArrowZero和ArrowPlus分别为Arrow设置了Monoid中的单位元素和二元运算符，使之成为了一个幺半群：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Arrow</span> arr =&gt; <span class="type">ArrowZero</span> arr <span class="keyword">where</span></span></span><br><span class="line">    zeroArrow :: b `arr` c</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">ArrowZero</span> arr =&gt; <span class="type">ArrowPlus</span> arr <span class="keyword">where</span></span></span><br><span class="line">    (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c)</span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia - Haskell wiki</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/54863519">Haskell语言学习笔记（8）Monoid - zwvista</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/62238541">Haskell语言学习笔记（16）Alternative - zwvista</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#5 函子、应用函子与单子</title>
    <url>/p/290ecb74.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/a5bbe48a.html">&lt; #4</a></p>
<p><a href="/p/d4bb2633.html">#6 &gt;</a></p>
</div>

<h2 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h2><p>函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用<code>fmap</code> :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子</p>
<span id="more"></span>

<p>Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子</p>
<p>函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的<code>f a</code>和<code>f b</code>也是因为<code>f</code>是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中</p>
<p>Functor的定义是:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) :: a -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) = fmap . const</span><br></pre></td></tr></table></figure>
<p>可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>
<p>但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名：</p>
<p style="text-align: center;">const :: a -> b -> a</p>

<p>即接收两个参数，但始终只返回第一个参数</p>
<h3 id="Functor实例"><a href="#Functor实例" class="headerlink" title="Functor实例"></a>Functor实例</h3><h4 id><a href="#" class="headerlink" title="[]"></a>[]</h4><p>列表[]是一个函子，它通过map函数来实现fmap的功能：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">    fmap = map</span><br></pre></td></tr></table></figure>
<p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表</p>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe也具有kind * -&gt; *，它也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="Either-a"><a href="#Either-a" class="headerlink" title="Either a"></a>Either a</h4><p>Either的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Left</span> x) = <span class="type">Left</span> x</span><br><span class="line">    fmap f (<span class="type">Right</span> x) = <span class="type">Right</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Left</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Right</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在）</p>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>IO也是一个函子，使用fmap对IO中内容应用函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f action = <span class="keyword">do</span></span><br><span class="line">        result &lt;- action</span><br><span class="line">        return (f result)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (<span class="string">&quot;input: &quot;</span>++) getLine</span><br><span class="line"><span class="title">test</span></span><br><span class="line"><span class="string">&quot;input: test&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="a"><a href="#a" class="headerlink" title="(,) a"></a>(,) a</h4><p>(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,) a) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (x, y) = (x, f y)</span><br></pre></td></tr></table></figure>
<p>只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,) a b) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c) = (a, b, f c)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,,) a b c) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c, d) = (a, b, c, f d)</span><br></pre></td></tr></table></figure>

<h4 id="gt-r"><a href="#gt-r" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>-&gt;也是一个类型构造器，它的kind：</p>
<p style="text-align: center;">(->) :: * -> * -> *</p>

<p>一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中<code>r</code>是输入的类型）</p>
<p>规定的fmap的类型签名是：</p>
<p style="text-align: center;">fmap :: (a -> b) -> f a -> f b</p>

<p>其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b)</p>

<p>把其中的(-&gt;)换成中缀可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> (r -> a) -> (r -> b)</p>

<p>传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。<br>不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap f g = (\x -&gt; f (g x))</span><br></pre></td></tr></table></figure>
<p>所以(-&gt;) r的fmap其实就是函数复合(.)：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap = (.)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t fmap (*<span class="number">3</span>) (+<span class="number">100</span>)  </span><br><span class="line"><span class="title">fmap</span> (*<span class="number">3</span>) (+<span class="number">100</span>) :: (<span class="type">Num</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">3</span>) (+<span class="number">100</span>) <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) `fmap` (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) . (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span></span><br></pre></td></tr></table></figure>

<h3 id="Functor-Laws"><a href="#Functor-Laws" class="headerlink" title="Functor Laws"></a>Functor Laws</h3><p>所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律：</p>
<ol>
<li><code>fmap id = id</code>（其中id为函数<code>(\x -&gt; x)</code>）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap id [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; fmap id (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><code>fmap (f . g) = fmap f . fmap g</code>：即函子的fmap支持结合律<br> fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中<code>a</code>为一个函子<br> fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap ((*<span class="number">3</span>) . (+<span class="number">100</span>)) (<span class="type">Just</span> <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">303</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可</p>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h3><p>对于函子和fmap，有两种理解方法</p>
<ol>
<li>函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器</li>
<li>函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作<p style="text-align: center;">fmap :: (a -> b) -> (f a -> f b)</p>
接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数
<p style="text-align: center;">fmap g :: f a -> f b</p>
使普通的函数g可以在计算上下文<code>f</code>中使用，这种转换也被称为提升（lift）</li>
</ol>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;$&gt;"></a>&lt;$&gt;</h4><p><code>&lt;$&gt;</code>函数是<code>fmap</code>的中缀形式（它看着类似<code>$</code>，<code>f $ 3</code>将f应用在单个值3上，而<code>f &lt;$&gt; [1, 2, 3]</code>将f应用在一个函子上，也就是应用在一个函子内部的所有值上）：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">2</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="gt"><a href="#gt" class="headerlink" title="$&gt;"></a>$&gt;</h4><p><code>$&gt;</code>函数包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">($>) :: Functor f => f a -> b -> f b</p> 

<p>Functor定义时要求了<code>&lt;$</code>函数，将函子内部的元素全部替换为指定的某个值，而<code>$&gt;</code>正好将<code>&lt;$</code>函数的两个参数反了过来，相当于<code>flip (&lt;$)</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] $&gt; &#x27;a&#x27;</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p><code>void</code>函数也包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">void :: Functor f => f a -> f ()</p>

<p>void函数把一个函子内部的全部元素都变成空（<code>()</code>），<code>void x</code>相当于<code>() &lt;$ x</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; void [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[(), (), ()]</span><br><span class="line"><span class="title">ghci</span>&gt; void (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> ()</span><br></pre></td></tr></table></figure>

<h2 id="Applicative-Functor"><a href="#Applicative-Functor" class="headerlink" title="Applicative Functor"></a>Applicative Functor</h2><p>应用函子（Applicative Functor）是函子的升级版，它包含在<code>Control.Applicative</code>模块中。</p>
<p>fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">    pure :: a -&gt; f a</span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>应用函子要求实现两个函数：</p>
<ul>
<li><code>pure</code> :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just</li>
<li><code>&lt;*&gt;</code> :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。</li>
</ul>
<h3 id="Applicative-Functor实例"><a href="#Applicative-Functor实例" class="headerlink" title="Applicative Functor实例"></a>Applicative Functor实例</h3><h4 id="Maybe-1"><a href="#Maybe-1" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = <span class="type">Just</span></span><br><span class="line">    <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">    (<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x</li>
<li><code>&lt;*&gt;</code>函数：将装有函数的函子中的函数应用另一个函子中<ul>
<li>第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing</li>
<li>第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可</li>
</ul>
</li>
</ul>
<p>实际应用的例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">3</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12</p>
<p>第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了</p>
<p>而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>&lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (<span class="type">Just</span> (\y z -&gt; <span class="number">3</span> + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> (\z -&gt; <span class="number">3</span> + <span class="number">4</span> + z) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span> = <span class="type">Just</span> (+<span class="number">7</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。</p>
<p>而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是：</p>
<p style="text-align: center;">f <$> x <*> y <*> ...</*></*></$></p>

<h4 id="-1"><a href="#-1" class="headerlink" title="[]"></a>[]</h4><p>列表也是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">    pure x = [x]</span><br><span class="line">    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x]</li>
<li><code>&lt;*&gt;</code>函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表</li>
</ul>
<p>使用例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">3</span>), (*<span class="number">2</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [(+), (*)]  &lt;*&gt;  [<span class="number">1</span>, <span class="number">2</span>]  &lt;*&gt;  [<span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h4 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = return</span><br><span class="line">    a &lt;*&gt; b = <span class="keyword">do</span></span><br><span class="line">        f &lt;- a</span><br><span class="line">        x &lt;- b</span><br><span class="line">        return (f x)</span><br></pre></td></tr></table></figure>
<p>也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine</span><br><span class="line"><span class="type">Line1</span></span><br><span class="line"><span class="type">Line2</span></span><br><span class="line"><span class="string">&quot;Line1Line2&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="gt-r-1"><a href="#gt-r-1" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名：</p>
<p style="text-align: center;"><*> :: f (a -> b) -> f a -> f b</*></p>

<p>其中f为(-&gt;) r，将其代入并替换为中缀：</p>
<p style="text-align: center;"><*> :: (r -> a -> b) -> (r -> a) -> (r -> b)</*></p>

<p>可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b)</p>
<p>那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是：</p>
<p style="text-align: center;">\x -> f x (g x)</p>

<p>于是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    pure x = (\_ -&gt; x)</span><br><span class="line">    f &lt;*&gt; g = \x -&gt; f x (g x)</span><br></pre></td></tr></table></figure>
<p>将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x</p>
<p>应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line"><span class="number">508</span></span><br></pre></td></tr></table></figure>
<p>执行这句时发生了什么？：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) &lt;$&gt; (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) . (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span> = (\a -&gt; (+) ((+<span class="number">3</span>) a)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\a b -&gt; (a + <span class="number">3</span> + b)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + ((*<span class="number">100</span>) x)) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + x * <span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= <span class="number">5</span> + <span class="number">3</span> + <span class="number">5</span> * <span class="number">100</span> = <span class="number">508</span></span><br><span class="line">= (<span class="number">5</span> + <span class="number">3</span>) + (<span class="number">5</span> * <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+)</p>
<p>同样：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">2</span>) &lt;*&gt; (/<span class="number">2</span>) $ <span class="number">5</span>  </span><br><span class="line">[<span class="number">8.0</span>,<span class="number">10.0</span>,<span class="number">2.5</span>]  </span><br></pre></td></tr></table></figure>
<p>先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\x y z -&gt; [x,y,z])得到了最终的结果</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i</span><br><span class="line">= (\x -&gt; f (g x) (h x) (i x))</span><br></pre></td></tr></table></figure>

<h4 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h4><p>普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在<code>Control.Applicative</code>模块中</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">ZipList</span> <span class="keyword">where</span></span></span><br><span class="line">    pure x = <span class="type">ZipList</span> (repeat x)</span><br><span class="line">    <span class="type">ZipList</span> fs &lt;*&gt; <span class="type">ZipList</span> xs = <span class="type">ZipList</span> (zipWith ($) fs xs)</span><br></pre></td></tr></table></figure>
<p>但是ZipList并不是Show的实例，所以不能直接显示出来，要使用<code>getZipList</code>来获取它内部的列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getZipList $ (+) &lt;$&gt; <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &lt;*&gt; <span class="type">ZipList</span> [<span class="number">100</span>,<span class="number">100.</span>.]  </span><br><span class="line">[<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; getZipList $ (,,) &lt;$&gt; <span class="type">ZipList</span> <span class="string">&quot;dog&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;cat&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;rat&quot;</span>  </span><br><span class="line">[(&#x27;d&#x27;,&#x27;c&#x27;,&#x27;r&#x27;),(&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;),(&#x27;g&#x27;,&#x27;t&#x27;,&#x27;t&#x27;)]  </span><br></pre></td></tr></table></figure>

<h3 id="Applicative-Functor-Laws"><a href="#Applicative-Functor-Laws" class="headerlink" title="Applicative Functor Laws"></a>Applicative Functor Laws</h3><p>应用函子一般有四个定律，都是保证pure的正确性的：</p>
<ol>
<li><code>Identity law</code>：pure id &lt;*&gt; v = v</li>
<li><code>Homomorphism</code>：pure f &lt;*&gt; pure x = pure (f x)</li>
<li><code>Interchange</code>：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u</li>
<li><code>Composition</code>：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w</li>
</ol>
<h3 id="Intuition-1"><a href="#Intuition-1" class="headerlink" title="Intuition"></a>Intuition</h3><p>理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：<br>$$<br>[[\ \ g\ x_1\ x_2\ \cdots\ x_n\ \ ]]<br>$$</p>
<p>其中$x_i$的类型是$f\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是：</p>
<p>$$<br>t_1\to t_2\to\cdots\to t_n\to t<br>$$</p>
<p>所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\ x_1$结果的类型是：</p>
<p>$$<br>f\ \ (t_2\to t_3\to\cdots\to t_n\to t)<br>$$</p>
<p>但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\ g\ x_1\ x_2\ \cdots\ x_n\ ]]$，只需要：</p>
<p style="text-align: center;">g <$> x1 <*> x2 <*> ... <*> xn</*></*></*></$></p>

<p>而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算：</p>
<p style="text-align: center;">g <$> x1 <*> pure x2 <*> ... <*> xn</*></*></*></$></p>

<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="liftA-amp-liftA2-amp-liftA3"><a href="#liftA-amp-liftA2-amp-liftA3" class="headerlink" title="liftA &amp; liftA2 &amp; liftA3"></a>liftA &amp; liftA2 &amp; liftA3</h4><p style="text-align: center;">liftA :: Applicative f => (a -> b) -> f a -> f b</p>
<p style="text-align: center;">liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c</p>
<p style="text-align: center;">liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d</p>

<p>不难推测liftA就是fmap，<code>liftA2 f x1 x2</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2</code>，<code>liftA3 f x1 x2 x3</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3</code></p>
<h4 id="lt-amp-gt"><a href="#lt-amp-gt" class="headerlink" title="&lt;* &amp; *&gt;"></a>&lt;* &amp; *&gt;</h4><p>类型类似函子的<code>&lt;$</code>和<code>$&gt;</code>：</p>
<p style="text-align: center;">(&lt;*) :: Applicative f => f a -> f b -> f a</p>
<p style="text-align: center;">(*>) :: Applicative f => f a -> f b -> f b</p>

<p>&lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> &lt;* <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> *&gt; <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;* <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> *&gt; <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt;* [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] *&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [] &lt;* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; [] *&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h4 id="lt-gt-1"><a href="#lt-gt-1" class="headerlink" title="&lt;**&gt;"></a>&lt;**&gt;</h4><p style="text-align: center;">(**) :: Applicative f => f a -> f (a -> b) -> f b</p>

<p>接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;**&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; flip(&lt;*&gt;) [<span class="number">1</span>, <span class="number">2</span>] [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="when-amp-unless"><a href="#when-amp-unless" class="headerlink" title="when &amp; unless"></a>when &amp; unless</h4><p style="text-align: center;">when :: Applicative f => Bool -> f () -> f ()</p>

<p>传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过）</p>
<p>unless则与when相反，测试为True返回pure ()</p>
<h4 id="sequenceA"><a href="#sequenceA" class="headerlink" title="sequenceA"></a>sequenceA</h4><p style="text-align: center;">sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)</p>

<p>应用在列表上时，它的类型相当于：</p>
<p style="text-align: center;">[f a] -> f [a]</p>

<p>所以在列表上它的使用方法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Just</span> <span class="number">2</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Just</span> [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(+<span class="number">3</span>),(+<span class="number">2</span>),(+<span class="number">1</span>)] <span class="number">3</span>  </span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">6</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>],[]]  </span><br><span class="line">[]  </span><br></pre></td></tr></table></figure>
<p>它在对同一个参数应用不同函数时很有用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (\f -&gt; f <span class="number">7</span>) [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd]  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd] <span class="number">7</span>  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br></pre></td></tr></table></figure>

<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>单子（Monad）是对Applicative Functor的扩展（但是诞生比Applicative早），Functor的<code>&lt;$&gt;</code>函数实现了将普通函数应用在上下文值上，Applicative的<code>&lt;*&gt;</code>函数将上下文中函数应用在上下文值上。而Monad提供了一个函数<code>&gt;&gt;=</code>（bind），将一个接收普通值返回上下文值的函数应用在上下文值上：</p>
<!--more-->
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">    (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">    return :: a -&gt; m a</span><br><span class="line">    m &gt;&gt; n = m &gt;&gt;= \_ -&gt; n</span><br><span class="line">    return = pure</span><br></pre></td></tr></table></figure>
<ul>
<li><code>return</code>函数：和<code>pure</code>一样，只是有另一个名字</li>
<li><code>&gt;&gt;</code>函数：提供了默认的实现方法，它的作用和Applicative的*&gt;函数一样</li>
<li><code>&gt;&gt;=</code>函数（bind）：比Applicative升级的函数，第一个参数是一个单子，第二个参数是一个接收值返回单子的函数，将这个函数应用在第一个参数单子中的值上，并返回得到的新单子</li>
</ul>
<h3 id="Monad实例"><a href="#Monad实例" class="headerlink" title="Monad实例"></a>Monad实例</h3><h4 id="Maybe-2"><a href="#Maybe-2" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe是一个单子实例，Applicative已经为它实现了return，因此只需要&gt;&gt;=函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    (<span class="type">Just</span> x) &gt;&gt;= f = f x </span><br><span class="line">    <span class="type">Nothing</span>  &gt;&gt;= _ = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>根据定义就很容易实现Maybe的&gt;&gt;=函数了，而且也很好理解</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; return (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>) &gt;&gt; <span class="type">Nothing</span> &gt;&gt;= \y -&gt; <span class="type">Just</span> (y + <span class="number">1</span>)</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>最后一个例子中出现了&gt;&gt; Nothing，这时Nothing前的部分全都相当于没用，因为&gt;&gt;操作符的左右两边只要有一个出现Nothing，那整体就会是Nothing。这个特性可以用于在中途随时判断失误，只要有一处失误，结果就会是Nothing</p>
<h4 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h4><p>列表也是一个单子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span></span><br><span class="line">    xs &gt;&gt;= f = concat (map f xs)</span><br></pre></td></tr></table></figure>
<p>将这个函数应用在xs的每个值上，将返回的所有列表平铺成一个列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] &gt;&gt;= \x -&gt; [x,-x]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-4</span>,<span class="number">5</span>,<span class="number">-5</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>] &gt;&gt;= \n -&gt; [&#x27;a&#x27;,&#x27;b&#x27;] &gt;&gt;= \ch -&gt; return (n,ch)  </span><br><span class="line">[(<span class="number">1</span>,&#x27;a&#x27;),(<span class="number">1</span>,&#x27;b&#x27;),(<span class="number">2</span>,&#x27;a&#x27;),(<span class="number">2</span>,&#x27;b&#x27;)]  </span><br></pre></td></tr></table></figure>

<h4 id="IO-2"><a href="#IO-2" class="headerlink" title="IO"></a>IO</h4><p>IO也是一个单子，但是实现方法比较深奥（逃</p>
<h4 id="gt-r-2"><a href="#gt-r-2" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>(-&gt;) r也是一个单子，和Functor、Applicative一样，先分析它的&gt;&gt;=类型签名：</p>
<p style="text-align: center;">(>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b</p>
<p style="text-align: center;">(>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b)</p>

<p>也可以看出来，它接收两个函数f :: r -&gt; a、g :: a -&gt; r -&gt; b，然后返回一个新的函数h :: r -&gt; b</p>
<p>那么函数h接收一个类型为r的参数，返回一个类型为b的值。所以先对输入应用f得到类型为a的中间值，然后再将这个值和输入参数一起传入函数g得到结果。所以函数h的定义应该是：</p>
<p style="text-align: center;">\x -> g (f x) x</p>

<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    f &gt;&gt;= g = \x -&gt; g (f x) x</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">3</span>) &gt;&gt;= (+) $ <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; id $ <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="do-notation"><a href="#do-notation" class="headerlink" title="do-notation"></a>do-notation</h3><p>Haskell的do语句为链式的&gt;&gt;=应用提供了类似命令式（imperative style）的语法糖。比如<code>a &gt;&gt;= \x -&gt; b &gt;&gt; c &gt;&gt;= \y -&gt; d</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">a</span> &gt;&gt;= \x -&gt;</span><br><span class="line"><span class="title">b</span> &gt;&gt;</span><br><span class="line"><span class="title">c</span> &gt;&gt;= \y -&gt;</span><br><span class="line"><span class="title">d</span></span><br></pre></td></tr></table></figure>
<p>其中有abcd四个值，可以看出a中内容绑定到了x上，c中内容绑定到了y上。使用do语句来表示这个操作可以写成：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x &lt;- a </span><br><span class="line">   ;      b </span><br><span class="line">   ; y &lt;- c </span><br><span class="line">   ;      d </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中的大括号和分号可以省略不写（挤在一行时不能省略）。do语句也只是一个语法糖，它可以递归地转换成普通的Monad操作语句：</p>
<ul>
<li><code>do e</code>：e</li>
<li><code>do &#123; e; ... &#125;</code>：e &gt;&gt; do { … }</li>
<li><code>do &#123; v &lt;- e; ... &#125;</code>：e &gt;&gt;= \v -&gt; do { … }</li>
<li><code>do &#123; let ...; ... &#125;</code>：let … in do { … }</li>
</ul>
<h4 id="ApplicativeDo"><a href="#ApplicativeDo" class="headerlink" title="ApplicativeDo"></a>ApplicativeDo</h4><p>比如如下一个do语句：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> x &lt;- a </span><br><span class="line">   y &lt;- b </span><br><span class="line">   z &lt;- c </span><br><span class="line">   return (f x y z)</span><br></pre></td></tr></table></figure>
<p>它可以转化成：</p>
<p style="text-align: center;">a >>= \x -> b >>= \y -> c >>= \z -> return (f x y z)</p>

<p>但是经过观察可以发现，整个语句实际上将函数f应用在了三个上下文中的值上，所以仅用Applicative的&lt;$&gt;和&lt;*&gt;完全可以实现：</p>
<p style="text-align: center;">f <$> a <*> b <*> c</*></*></$></p>

<p>而且在运行的时候Applicative的效率会比Monad高，所以Haskell会将do语句尽可能优先转换为Applicative的表示方法然后再计算</p>
<h3 id="Monad-Laws"><a href="#Monad-Laws" class="headerlink" title="Monad Laws"></a>Monad Laws</h3><ol>
<li><code>Left identity</code>： return a &gt;&gt;= k      <code>=</code> k a</li>
<li><code>Right identity</code>：m        &gt;&gt;= return <code>=</code> m</li>
<li><code>Associativity</code>：(m &gt;&gt;= g) &gt;&gt;= h      <code>=</code> m &gt;&gt;= (\x -&gt; g x &gt;&gt;= h)</li>
</ol>
<p>前两个定律很好理解：</p>
<ul>
<li>将a注入上下文之后绑定（bind）给函数k(:: a -&gt; m a)，相当于直接将a直接传入函数k</li>
<li>将已经包含在上下文中的值绑定给return函数，相当于保持不变</li>
</ul>
<p>第三个定律是结合律，把它写成更像结合律的表示方法是：</p>
<p style="text-align: center;">(m >>= (\x -> g x)) >>= h <code>=</code> m >>= (\x -> g x >>= h)</p>

<h4 id="组合运算符（-gt-gt-）形式"><a href="#组合运算符（-gt-gt-）形式" class="headerlink" title="组合运算符（&gt;=&gt;）形式"></a>组合运算符（&gt;=&gt;）形式</h4><p><code>Control.Monad</code>模块中还定义了函数<code>&gt;=&gt;</code>（Kleisli-composition operator）：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infixr</span> <span class="number">1</span> &gt;=&gt;</span><br><span class="line">(&gt;=&gt;) :: <span class="type">Monad</span> m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</span><br><span class="line"><span class="title">f</span> &gt;=&gt; g = \x -&gt; f x &gt;&gt;= g</span><br></pre></td></tr></table></figure>
<p>使用&gt;=&gt;运算符可以将两个用于绑定的函数结合在一起。用它表示的Monad定律更加清晰直观：</p>
<ol>
<li><code>Left identity</code>：return &gt;=&gt; f <code>=</code> f</li>
<li><code>Right identity</code>：f &gt;=&gt; return <code>=</code> f</li>
<li><code>Associativity</code>：(f &gt;=&gt; g) &gt;=&gt; h <code>=</code> f &gt;=&gt; (g &gt;=&gt; h)</li>
</ol>
<h4 id="do-notation形式"><a href="#do-notation形式" class="headerlink" title="do-notation形式"></a>do-notation形式</h4><p>Monad的这三个定律还可以使用do语句来描述：</p>
<ol>
<li><code>Left identity</code>： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x&#x27; &lt;- return x;</span><br><span class="line">     f x&#x27;             =   <span class="keyword">do</span> &#123; f x &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Right identity</code>： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x &lt;- m; </span><br><span class="line">     return x         =   <span class="keyword">do</span> &#123; m &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Associativity</code>： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123; y &lt;- <span class="keyword">do</span> &#123; x &lt;- m;       <span class="keyword">do</span> &#123; x &lt;- m;              <span class="keyword">do</span> &#123; x &lt;- m;</span><br><span class="line">               f x                <span class="keyword">do</span> &#123; y &lt;- f x;            y &lt;- f x;</span><br><span class="line">             &#125;           =             g y         =        g y</span><br><span class="line">     g y                             &#125;                    &#125;</span><br><span class="line">   &#125;                            &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Intuition-2"><a href="#Intuition-2" class="headerlink" title="Intuition"></a>Intuition</h3><p>Monad也可以很自然地看成Applicative的升级版，比如Applicative的操作全部是固定的，而Monad的操作可以在中途突然改变</p>
<p>同时Monad也完成了Functor和Applicative无法完成的操作。比如要用fmap和实现&gt;&gt;=函数（即达成操作 m a -&gt; (a -&gt; m b) -&gt; m b），先假设 f :: a -&gt; m b，那么fmap f的类型就会是 m a -&gt; m (m b)，将m a应用在fmap f上会得到结果m (m b)，而不是m b。但是目前只可以使用pure将一个值装入上下文中（a -&gt; m a），而没有一个函数可以从上下文中提取值（m a -&gt; a）。那么就需要定义一个新的函数来实现这个操作的效果（m (m b) -&gt; m b）。因此Monad的另一个等效的定义方法是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad&#x27;</span> m <span class="keyword">where</span></span></span><br><span class="line">    join :: m (m a) -&gt; m a </span><br><span class="line">    </span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b </span><br><span class="line">    x &gt;&gt;= f = join $ fmap f x</span><br></pre></td></tr></table></figure>
<p>但是定义&gt;&gt;=函数会更为直观方便，所以Haskell采用了用&gt;&gt;=函数定义Monad的方法</p>
<p>同时Haskell还提供了join函数的定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a </span><br><span class="line"><span class="title">join</span> x = x &gt;&gt;= id</span><br></pre></td></tr></table></figure>

<h3 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="liftM-amp-ap"><a href="#liftM-amp-ap" class="headerlink" title="liftM &amp; ap"></a>liftM &amp; ap</h4><p style="text-align: center;">liftM :: Monad m => (a -> b) -> m a -> m b</p>
<p style="text-align: center;">ap :: Monad m => m (a -> b) -> m a -> m b</p>

<p>所以liftM其实就是fmap、ap就是&lt;*&gt;，但是老版本的GHC定义Monad并没有Functor、Applicative的约束，所以实现了liftM、ap，并且保留了这个名字</p>
<p>因此一个单子也可以通过<code>pure = return</code>、<code>(&lt;*&gt;) = ap</code>直接成为应用函子的实例</p>
<h4 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h4><p style="text-align: center;">sequence :: Monad m => [m a] -> m [a]</p>

<p>sequence的作用显而易见，而且在IO部分也使用到了。但是这个版本是在<code>GHC.Base</code>模块中定义的，还有一个更广泛的使用Traversable的定义在<code>Data.Traversable</code>模块中 </p>
<h4 id="replicateM"><a href="#replicateM" class="headerlink" title="replicateM"></a>replicateM</h4><p style="text-align: center;">replicateM :: Applicative m => Int -> m a -> m [a]</p>

<h4 id="mapM-amp-forM"><a href="#mapM-amp-forM" class="headerlink" title="mapM &amp; forM"></a>mapM &amp; forM</h4><p style="text-align: center;">mapM :: Monad m => (a -> m b) -> [a] -> m [b]</p>
<p style="text-align: center;">forM :: Monad m => [a] -> (a -> m b) -> m [b]</p>

<p>forM的用法在IO部分已经说过，mapM和forM都在<code>Data.Traversable</code>模块中有广泛版本</p>
<p>还有一些其他的函数：filterM、zipWithM、foldM、forever，通过名字就可以看出用法，是将原来仅使用与列表的函数提升至可以适用于所有单子</p>
<p>并且在函数名后加下划线，比如sequence_、mapM_，会忽略返回值（最终结果为<code>m ()</code>）</p>
<h4 id="lt-lt-amp-gt-gt-amp-lt-lt"><a href="#lt-lt-amp-gt-gt-amp-lt-lt" class="headerlink" title="=&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;"></a>=&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;</h4><p>（<code>&gt;=&gt;</code>操作符在上面<a href="#%E7%BB%84%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-gt-gt-%EF%BC%89%E5%BD%A2%E5%BC%8F">Monad Laws</a>部分已经给出了定义）</p>
<ul>
<li>x &gt;&gt;= f <code>=</code> f =&lt;&lt; x </li>
<li>f &gt;=&gt; g <code>=</code> g &lt;=&lt; f </li>
</ul>
<h2 id="MonadFail"><a href="#MonadFail" class="headerlink" title="MonadFail"></a>MonadFail</h2><p>MonadFail定义在<code>Control.Monad.Fail</code>模块中：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadFail</span> m <span class="keyword">where</span></span></span><br><span class="line">    fail :: <span class="type">String</span> -&gt; m a </span><br></pre></td></tr></table></figure>
<p>它只要求在Monad的基础上实现fail函数，接收一个字符串返回一个单子。这会使在do语句中产生错误时直接变为错误值（空值）使最终的返回值为错误值</p>
<h3 id="MonadFail实例"><a href="#MonadFail实例" class="headerlink" title="MonadFail实例"></a>MonadFail实例</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fail _ = <span class="type">Nothing</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> [] <span class="keyword">where</span></span></span><br><span class="line">    fail _ = []</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fail = failIO</span><br></pre></td></tr></table></figure>
<p>Maybe和[]的fail函数都与第一个参数无关，直接返回空值（Nothing、[]）；而IO的fail函数直接使用failIO，实现方法也是深奥（接着逃</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">exampleFail</span> :: <span class="type">Maybe</span> <span class="type">Char</span> </span><br><span class="line"><span class="title">exampleFail</span> = <span class="keyword">do</span></span><br><span class="line">    (x:xs) &lt;- <span class="type">Just</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    return x </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; exampleFail</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>在这个例子的do语句中，在提取Just “”中的值时用了模式匹配，但是因为其内容为空字符串，x:xs匹配会出现错误，这时就会触发fail函数直接返回Nothing</p>
<h3 id="MonadFail-Law"><a href="#MonadFail-Law" class="headerlink" title="MonadFail Law"></a>MonadFail Law</h3><ul>
<li>fail s &gt;&gt;= m <code>=</code> fail s </li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia - Haskell wiki</a></li>
<li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></li>
<li><a href="http://02s949.coding-pages.com/2018/08/15/haskellc/">Haskell学习 - functor</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#4 输入输出与文件</title>
    <url>/p/a5bbe48a.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/369b7e08.html">&lt; #3</a></p>
<p><a href="/p/290ecb74.html">#5 &gt;</a></p>
</div>

<h2 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h2><h3 id="运行Haskell程序"><a href="#运行Haskell程序" class="headerlink" title="运行Haskell程序"></a>运行Haskell程序</h3><p>不在GHCi中运行一个Haskell程序有两种方式：</p>
<span id="more"></span>
<ol>
<li>编译运行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ghc --make code</span><br><span class="line">$ ./code</span><br></pre></td></tr></table></figure></li>
<li>通过<code>runhaskell</code>命令直接运行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ runhaskell code.hs</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="输出文本"><a href="#输出文本" class="headerlink" title="输出文本"></a>输出文本</h3><p>在一个Haskell程序中输出文字需要定义一个main函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中putStrLn的类型是：</p>
<p style="text-align: center;">putStrLn :: String -> IO ()</p>

<p>putStrLn接收一个String类型，并返回一个结果为()类型的IO动作（I/O action）。所以main函数的类型为IO ()。（IO的Kind是* -&gt; *）</p>
<p>除此之外，还有其他默认提供的输出文本的函数：</p>
<ul>
<li><code>putStr</code>：输出文本，结尾不换行</li>
<li><code>putChar</code>：输出单个字符，结尾不换行。接收的参数为单个Char，不是String（用单引号不是双引号）</li>
<li><code>print</code>：可以接收任何Show的成员，先用show转化为字符串然后输出。等同于putStrLn . show</li>
</ul>
<h4 id="do-block"><a href="#do-block" class="headerlink" title="do block"></a>do block</h4><p>在main函数中使用多个putStrLn需要使用do语句：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    putStrLn <span class="string">&quot;Line1&quot;</span></span><br><span class="line">    putStrLn <span class="string">&quot;Line2&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中最后一行一定要返回IO ()类型的值</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>输入文字需要在do块中使用getLine：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    line &lt;- getLine</span><br><span class="line">    putStrLn line</span><br></pre></td></tr></table></figure>
<p>getLine的类型是：</p>
<p style="text-align: center;">getLine :: IO String</p>

<p>而&lt;-操作符将getLine中的String提取了出来给到了line，使line变成了String类型的一个字符串。</p>
<p>而且使用输入的字符串必须要经过一次&lt;-，不能直接使用getLine作为字符串，因为getLine不是String类型，而是IO String类型。</p>
<p>除此之外，还可以使用getChar来获取单个字符，但仍然需要使用&lt;-操作符来提取Char</p>
<h3 id="其他IO相关函数用法"><a href="#其他IO相关函数用法" class="headerlink" title="其他IO相关函数用法"></a>其他IO相关函数用法</h3><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>Haskell中的return和其他命令式语言中的return完全不同，它不会使函数直接结束并返回一个值。</p>
<p>main函数必须定义为类型为IO ()的函数，所以在main函数中使用if语句，如果不输出的话也不可以直接放下什么都不干，因为这时候main函数的类型不是IO ()。所以这时需要使用return ()来为main函数指定为IO ()类型，例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    line &lt;- getLine</span><br><span class="line">    <span class="keyword">if</span> null line</span><br><span class="line">        <span class="keyword">then</span> return () <span class="comment">-- &lt;-这里</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">do</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>使用&lt;-操作符也可以直接将return语句中的内容提取出来，比如a &lt;- return ‘A’，执行后a就是’A’。</p>
<h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p>when包含在<code>Control.Monad</code>模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会return ()。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad   </span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    when (c /= &#x27; &#x27;) $ <span class="keyword">do</span>  </span><br><span class="line">        putChar c  </span><br><span class="line">        main  </span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span>     </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    <span class="keyword">if</span> c /= &#x27; &#x27;  </span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">do</span>  </span><br><span class="line">            putChar c  </span><br><span class="line">            main  </span><br><span class="line">        <span class="keyword">else</span> return () </span><br></pre></td></tr></table></figure>

<h4 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h4><p>sequence在IO中使用时可以达成[IO a] -&gt; IO [a]的效果，所以可以用作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[a, b, c] &lt;- sequence [getLine, getLine, getLine]</span><br></pre></td></tr></table></figure>

<h4 id="mapM-amp-mapM"><a href="#mapM-amp-mapM" class="headerlink" title="mapM &amp; mapM_"></a>mapM &amp; mapM_</h4><p>在IO相关的地方使用map，可以使用mapM和mapM_，其中mapM有返回值而mapM_直接扔掉了返回值：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mapM print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line">[(),(),()]  </span><br><span class="line"><span class="title">ghci</span>&gt; mapM_ print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br></pre></td></tr></table></figure>

<h4 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h4><p>forever函数包含在<code>Control.Monad</code>模块中。在main函数开头加上forever函数可以使后面的do块一直重复执行直到程序被迫终止，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = forever $ <span class="keyword">do</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h4 id="forM"><a href="#forM" class="headerlink" title="forM"></a>forM</h4><p>forM函数包含在<code>Control.Monad</code>模块中，它的功能和mapM类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回IO a类型。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    colors &lt;- forM [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] (\a -&gt; <span class="keyword">do</span></span><br><span class="line">        putStrLn $ <span class="string">&quot;Which color do you associate with the number &quot;</span> ++ show a ++ <span class="string">&quot;?&quot;</span>  </span><br><span class="line">        color &lt;- getLine  </span><br><span class="line">        return color)</span><br><span class="line">    putStrLn <span class="string">&quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;</span>  </span><br><span class="line">    mapM putStrLn colors</span><br></pre></td></tr></table></figure>

<h4 id="getContents"><a href="#getContents" class="headerlink" title="getContents"></a>getContents</h4><p>getLine获取一整行，而getContents从标准输入中获取全部内容直到遇到EOF，并且它是lazy的，在执行了foo &lt;- getContents后，它并不会读取标准输入并且赋值到foo，而是等到需要使用foo的时候再从标准输入读取。</p>
<p>getContents在使用管道传入文字时很常用，可以代替forever+getLine使用，比如一个Haskell程序文件code.hs：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Char  </span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    contents &lt;- getContents  </span><br><span class="line">    putStr (map toUpper contents)  </span><br></pre></td></tr></table></figure>
<p>使用ghc –make code编译后，通过管道传入文字：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat text.txt | ./code</span><br></pre></td></tr></table></figure>
<p>会将text.txt中的所有字母转为大写并输出</p>
<h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>上述功能还可以转化为一个String -&gt; String的函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">upperStrings</span> = unlines . map (map toUpper) . lines</span><br></pre></td></tr></table></figure>
<p>而在main中使用这个函数就需要：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    contents &lt;- getContents</span><br><span class="line">    putStr (upperStrings contents)</span><br></pre></td></tr></table></figure>
<p>但是String -&gt; String类型的函数在输入输出中的使用太常见了，所以可以使用interact函数来简化。interact的类型是：</p>
<p style="text-align: center;">interact :: (String -> String) -> IO ()</p>

<p>可以看出它接收一个String -&gt; String的函数，并返回一个IO ()类型，所以可以直接用在main上。</p>
<p>于是整个转换为大写的程序就可以简化为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = interact $ unlines . map (map toUpper) . lines</span><br></pre></td></tr></table></figure>

<h2 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h2><p>以下与文件和流相关的函数都包含在<code>System.IO</code>模块中</p>
<h3 id="openFile"><a href="#openFile" class="headerlink" title="openFile"></a>openFile</h3><p>openFile函数可以用来打开一个文件，它的类型是：</p>
<p style="text-align: center;">openFile :: FilePath -> IOMode -> IO Handle</p>

<p>其中<code>FilePath</code>是String的type synonyms，用一个字符串来表示需要打开的文件的路径</p>
<p><code>IOMode</code>的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IOMode</span> = <span class="type">ReadMode</span> | <span class="type">WriteMode</span> | <span class="type">AppendMode</span> | <span class="type">ReadWriteMode</span></span></span><br></pre></td></tr></table></figure>
<p>所以它一共只有四个值，用来表示进行IO操作的模式</p>
<p>openFile返回一个IO Handle类型的值，将其用&lt;-操作符提取后会出现一个Handle的值。但不能从Handle中直接使用文字，还需要使用一系列函数：</p>
<ul>
<li><code>hGetContents</code> :: Handle -&gt; IO String ，从Handle中读取全部内容，返回一个IO String</li>
<li><code>hGetChar</code> :: Handle -&gt; IO Char ，从Handle中读取一个字符</li>
<li><code>hGetLine</code> :: Handle -&gt; IO String ，从Handle中读取一行，返回一个IO String</li>
<li><code>hPutStr</code> :: Handle -&gt; String -&gt; IO () ，向Handle中输出字符串</li>
<li><code>hPutStrLn</code> :: Handle -&gt; String -&gt; IO () ，同上</li>
</ul>
<p>在使用openFile进行文件操作后，需要使用hClose手动关闭Handle。hClose :: Handle -&gt; IO ()，接收一个Handle并返回IO ()，可以直接放在main函数末尾</p>
<p>所以使用openFile读取一个文件中的全部内容并输出的全部代码是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    handle &lt;- openFile <span class="string">&quot;text.txt&quot;</span> <span class="type">ReadMode</span></span><br><span class="line">    contents &lt;- hGetContents handle</span><br><span class="line">    putStrLn contents</span><br><span class="line">    hClose handle</span><br></pre></td></tr></table></figure>

<h3 id="withFile"><a href="#withFile" class="headerlink" title="withFile"></a>withFile</h3><p>withFile类似Python中的with open，它在读取文件使用之后不需要手动close文件。它的类型是：</p>
<p style="text-align: center;">withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a</p>

<p>可以看出，它接收三个参数：</p>
<ul>
<li><code>FilePath</code>：一个表示文件路径的String</li>
<li><code>IOMode</code>：打开文件的模式</li>
<li><code>(Handle -&gt; IO a)</code>：一个函数，表示对读取文件后的Handle索要进行的操作，需要返回一个I/O action；而这个返回值也将作为withFile的返回值</li>
</ul>
<p>现在使用withFile来改写上述代码：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = withFile <span class="string">&quot;text.txt&quot;</span> <span class="type">ReadMode</span> (\handle -&gt; <span class="keyword">do</span></span><br><span class="line">    contents &lt;- hGetContents handle</span><br><span class="line">    putStrLn contents)</span><br></pre></td></tr></table></figure>

<p>withFile的功能相当于以下函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">withFile&#x27;</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IOMode</span> -&gt; (<span class="type">Handle</span> -&gt; <span class="type">IO</span> a) -&gt; <span class="type">IO</span> a  </span><br><span class="line"><span class="title">withFile&#x27;</span> path mode f = <span class="keyword">do</span>  </span><br><span class="line">    handle &lt;- openFile path mode   </span><br><span class="line">    result &lt;- f handle  </span><br><span class="line">    hClose handle  </span><br><span class="line">    return result  </span><br></pre></td></tr></table></figure>

<h3 id="readFile"><a href="#readFile" class="headerlink" title="readFile"></a>readFile</h3><p>readFile可以更加简化读取文件内容的操作，它的类型：</p>
<p style="text-align: center;">readFile :: FilePath -> IO String</p>

<p>它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的I/O action：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    contents &lt;- readFile <span class="string">&quot;text.txt&quot;</span></span><br><span class="line">    putStrLn contents</span><br></pre></td></tr></table></figure>

<h3 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h3><p>writeFile简化了写入文件的操作，它的类型：</p>
<p style="text-align: center;">writeFile :: FilePath -> String -> IO ()</p>

<p>传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个IO ()</p>
<h3 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h3><p>appendFile类似writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾</p>
<h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。</p>
<p>也可以通过<code>hSetBuffering</code>函数来手动设置缓冲区大小，这个函数的类型：</p>
<p style="text-align: center;">hSetBuffering :: Handle -> BufferMode -> IO ()</p>

<p>它接收一个handle，和一个BufferMode，并返回IO ()。其中BufferMode有以下几种：</p>
<ul>
<li><code>NoBuffering</code>：没有缓冲区，一次读入一个字符</li>
<li><code>LineBuffering</code>：缓冲区大小是一行，即每次读入一行内容</li>
<li><code>BlockBuffering (Maybe Int)</code>：缓冲区大小是一块，块的大小由Maybe Int指定：<ul>
<li><code>BlockBuffering (Nothing)</code>：使用系统默认的块大小</li>
<li><code>BlockBuffering (Just 2048)</code>：一块的大小是2048字节，即每次读入2048bytes的内容</li>
</ul>
</li>
</ul>
<p>缓冲区的刷新是自动的，也可以通过<code>hFlush</code>来手动刷新</p>
<p style="text-align: center;">hFlush :: Handle -> IO ()</p>

<p>传入一个handle，返回IO ()，即刷新对应handle的缓冲区</p>
<h3 id="openTempFile"><a href="#openTempFile" class="headerlink" title="openTempFile"></a>openTempFile</h3><p>openTempFile可以新建一个临时文件：</p>
<p style="text-align: center;">openTempFile :: FilePath -> String -> IO (FilePath, Handle)</p>

<p><code>FilePath</code>指临时文件要创建的位置路径，<code>String</code>指临时文件名字的前缀，返回一个I/O action，其内容第一个<code>FilePath</code>是创建得到的临时文件的路径，<code>Handle</code>是临时文件的handle</p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    (tempFile, tempHandle) &lt;- openTempFile <span class="string">&quot;.&quot;</span> <span class="string">&quot;temp&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    hClose tempHandle</span><br></pre></td></tr></table></figure>
<p><code>&quot;.&quot;</code>指临时文件要在当前目录创建，<code>&quot;temp&quot;</code>指临时文件名字以temp开头。最终得到的tempFile就是./temp…….，temp后为随机数字，如<code>./temp43620-0</code></p>
<h2 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h2><p>相关函数都包含在<code>System.Directory</code>模块中，全部内容见<a href="https://hackage.haskell.org/package/directory-1.3.6.2/docs/System-Directory.html">System.Directory</a></p>
<h3 id="getCurrentDirectory"><a href="#getCurrentDirectory" class="headerlink" title="getCurrentDirectory"></a>getCurrentDirectory</h3><p style="text-align: center;">getCurrentDirectory :: IO FilePath</p>

<p>直接返回一个I/O action，其内容是一个字符串表示当前路径的绝对路径</p>
<h3 id="removeFile"><a href="#removeFile" class="headerlink" title="removeFile"></a>removeFile</h3><p style="text-align: center;">removeFile :: FilePath -> IO ()</p>

<p>输入一个文件路径，并删除掉它</p>
<h3 id="renameFile"><a href="#renameFile" class="headerlink" title="renameFile"></a>renameFile</h3><p style="text-align: center;">renameFile :: FilePath -> FilePath -> IO ()</p>

<p>输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名</p>
<h3 id="doesFileExist"><a href="#doesFileExist" class="headerlink" title="doesFileExist"></a>doesFileExist</h3><p style="text-align: center;">doesFileExist :: FilePath -> IO Bool</p>

<p>检查文件是否存在，返回一个包含布尔值的I/O action</p>
<h2 id="Command-line-arguments"><a href="#Command-line-arguments" class="headerlink" title="Command line arguments"></a>Command line arguments</h2><p><code>System.Environment</code>模块中提供了两个函数可以用来处理传入命令行的参数</p>
<h3 id="getArgs"><a href="#getArgs" class="headerlink" title="getArgs"></a>getArgs</h3><p style="text-align: center;">getArgs :: IO [String]</p>

<p>不需要输入参数，直接返回一个I/O action，内容为传入命令行的参数（一个由String组成的列表）。相当于C语言中的argv[1:]</p>
<h3 id="getProgName"><a href="#getProgName" class="headerlink" title="getProgName"></a>getProgName</h3><p style="text-align: center;">getProgName :: IO String</p>

<p>返回I/O action，内容为程序的名字，相当于C语言中的argv[0]</p>
<h2 id="Randomness"><a href="#Randomness" class="headerlink" title="Randomness"></a>Randomness</h2><p>和随机数有关的函数都包含在<code>System.Random</code>模块中。GHCi启动时可能不会包含System.Random的配置，导致无法找到模块。需要通过stack打开:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stack ghci --package random</span><br></pre></td></tr></table></figure>

<p>Haskell要求同样的程序需要运行出同样的结果，除了用到了I/O action，所有会造成不同结果的函数都要交给I/O action来完成</p>
<p>那要使随机数脱离IO存在，就要用到随机生成器（random generator）</p>
<p><code>System.Random</code>模块提供了几个生成随机数的函数：</p>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p style="text-align: center;">random :: (Random a, RandomGen g) => g -> (a, g)</p>

<p>其中又有两个新的typeclass，Random表示可以取随机，RandomGen表示随机数生成器。random函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器</p>
<p>获取随机数生成器可以使用<code>mkStdGen</code>函数：</p>
<p style="text-align: center;">mkStdGen :: Int -> StdGen</p>

<p>其中<code>StdGen</code>是一个RandomGen的实例</p>
<p>运用random生成随机数需要指定类型，不然程序无法确定<code>a</code>是什么类型。例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Int</span>, <span class="type">StdGen</span>)</span><br><span class="line">(<span class="number">9216477508314497915</span>,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Char</span>, <span class="type">StdGen</span>)</span><br><span class="line">(&#x27;\<span class="number">537310</span>&#x27;,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Bool</span>, <span class="type">StdGen</span>)</span><br><span class="line">(<span class="type">True</span>,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">threeCoins</span> :: <span class="type">StdGen</span> -&gt; (<span class="type">Bool</span>, <span class="type">Bool</span>, <span class="type">Bool</span>)  </span><br><span class="line"><span class="title">threeCoins</span> gen =   </span><br><span class="line">    <span class="keyword">let</span> (firstCoin, newGen) = random gen  </span><br><span class="line">        (secondCoin, newGen&#x27;) = random newGen  </span><br><span class="line">        (thirdCoin, newGen&#x27;&#x27;) = random newGen&#x27;  </span><br><span class="line">    <span class="keyword">in</span>  (firstCoin, secondCoin, thirdCoin) </span><br></pre></td></tr></table></figure>

<h3 id="randoms"><a href="#randoms" class="headerlink" title="randoms"></a>randoms</h3><p style="text-align: center;">randoms :: (Random a, RandomGen g) => g -> [a]</p>

<p>randoms接收一个RandomGen，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器</p>
<h3 id="randomR"><a href="#randomR" class="headerlink" title="randomR"></a>randomR</h3><p style="text-align: center;">randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)</p>

<p>可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围(闭区间)</p>
<h3 id="randomRs"><a href="#randomRs" class="headerlink" title="randomRs"></a>randomRs</h3><p style="text-align: center;">randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]</p>

<p>同上两个，生成有范围的无穷随机数列表</p>
<h3 id="getStdGen"><a href="#getStdGen" class="headerlink" title="getStdGen"></a>getStdGen</h3><p>如果想要让程序每次运行得到不同的随机结果，需要使用<code>getStdGen</code>来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个I/O action，而不是一个直接的StdGen</p>
<p style="text-align: center;">getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen</p>

<p>即可以看成getStdGen :: IO StdGen，需要使用&lt;-操作符将StdGen提取出来</p>
<p>但是在同一个程序中，getStdGen的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数newStdGen</p>
<h3 id="newStdGen"><a href="#newStdGen" class="headerlink" title="newStdGen"></a>newStdGen</h3><p style="text-align: center;">newStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen</p>

<p>执行newStdGen会进行两个操作：</p>
<ul>
<li>更新全局随机数生成器，下次执行getStdGen会获得不同的结果</li>
<li>返回一个I/O action，包含一个新的StdGen（但是这个生成器和全局生成器也不同）</li>
</ul>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><p>程序在运行失败时会抛出异常，可以通过<code>Control.Exception</code>模块中的<code>catch</code>函数来捕获异常：</p>
<p style="text-align: center;">catch :: Exception e => IO a -> (e -> IO a) -> IO a</p>

<p>第一个参数是要进行的操作，以IO a为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = main&#x27; `catch` handler</span><br><span class="line"></span><br><span class="line"><span class="title">main&#x27;</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main&#x27;</span> = <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="title">handler</span> :: <span class="type">Exception</span> e =&gt; e -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">handler</span> e =  putStrLn <span class="string">&quot;...&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以利用守卫（guard）语法和<code>System.IO.Error</code>中的函数来判断IO异常的类型来进行不同操作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> System.IO.Error</span><br><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = toTry `catch` handler</span><br><span class="line">              </span><br><span class="line"><span class="title">toTry</span> :: <span class="type">IO</span> ()  </span><br><span class="line"><span class="title">toTry</span> = <span class="keyword">do</span> (fileName:_) &lt;- getArgs  </span><br><span class="line">           contents &lt;- readFile fileName  </span><br><span class="line">           putStrLn $ <span class="string">&quot;The file has &quot;</span> ++ show (length (lines contents)) ++ <span class="string">&quot; lines!&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">handler</span> :: <span class="type">IOError</span> -&gt; <span class="type">IO</span> ()  </span><br><span class="line"><span class="title">handler</span> e  </span><br><span class="line">    | isDoesNotExistError e = putStrLn <span class="string">&quot;The file doesn&#x27;t exist!&quot;</span>  </span><br><span class="line">    | otherwise = ioError e  </span><br></pre></td></tr></table></figure>

<p>具体相关全部函数见文档：<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Error.html">System.IO.Error</a>、<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception-Base.html">Control.Exception</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#3 类型与类型类</title>
    <url>/p/369b7e08.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/53e482b7.html">&lt; #2</a></p>
<p><a href="/p/a5bbe48a.html">#4 &gt;</a></p>
</div>

<h2 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h2><p>Haskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。<br>Type的首字母全为大写，常用的有：</p>
<ul>
<li><code>Int</code>：整型，有上下界范围，-2147483647～2147483648<span id="more"></span></li>
<li><code>Integer</code>：整数，无界，但是效率比Int低</li>
<li><code>Float</code>：单精度浮点型</li>
<li><code>Double</code>：双精度浮点型</li>
<li><code>Bool</code>：布尔值</li>
<li><code>Char</code>：字符</li>
<li><code>String</code>：字符串，等同于<code>[Char]</code></li>
<li><code>Ordering</code>：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT</li>
</ul>
<p>列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加<code>[]</code>。</p>
<p>元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。</p>
<h2 id="Typeclasses"><a href="#Typeclasses" class="headerlink" title="Typeclasses"></a>Typeclasses</h2><p>类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个Typeclass<br>Typeclass的首字母也全为大写，常见的有：</p>
<ul>
<li><code>Eq</code>：可判断是否相等</li>
<li><code>Ord</code>：可比较大小</li>
<li><code>Show</code>：可展示成字符串</li>
<li><code>Read</code>：可从字符串转换成特定类型</li>
<li><code>Enum</code>：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀</li>
<li><code>Bounded</code>: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded</li>
<li><code>Integral</code>：是整数，包括Int和Integer</li>
<li><code>RealFloat</code>： 是实浮点数，包括Float和Double</li>
<li><code>RealFrac</code>：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中）</li>
<li><code>Floating</code>：是浮点数，包括Float、Double和Complex（在Data.Complex模块中）</li>
<li><code>Real</code>：是实数，包括Integral和RealFrac的成员</li>
<li><code>Fractional</code>：是分数，包括RealFrac和Floating的成员</li>
<li><code>Num</code>：是数字，包括上述所有数字相关的类型</li>
</ul>
<h2 id="Type-variables"><a href="#Type-variables" class="headerlink" title="Type variables"></a>Type variables</h2><p>如果查看一个函数的类型，比如<code>head</code>，那么将会返回以下类型：</p>
<p style="text-align: center;">head :: [a] -> a</p>

<p>其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。</p>
<p>在函数的类型表达式其实可以看作$\lambda$表达式，它适用于$\alpha$变换（$\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。</p>
<p>在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如<code>(==)</code>函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么<code>(==)</code>的类型就是：</p>
<p style="text-align: center;">(==) :: (Eq a) => a -> a -> Bool</p>

<p>其中<code>=&gt;</code>前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以<code>(==)</code>函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。</p>
<h2 id="定义新Type"><a href="#定义新Type" class="headerlink" title="定义新Type"></a>定义新Type</h2><p>定义一个新的Type需要使用<code>data</code>关键字，比如定义<code>Bool</code>需要使用：</p>
<p style="text-align: center;">data Bool = False | True</p>

<p>其中<code>=</code>左侧的部分定义了新类型的名称<code>Bool</code>，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。<br>并且名称和值构造器的首字母都需要大写。</p>
<p>另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span>   </span></span><br></pre></td></tr></table></figure>
<p>它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。<br>如果查看Circle的类型，将返回：</p>
<p style="text-align: center;">Circle :: Float -> Float -> Float -> Shape</p>

<p>如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上<code>deriving (Show)</code>:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>类型的名称和值构造器名称也可以相同，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="导出Type"><a href="#导出Type" class="headerlink" title="导出Type"></a>导出Type</h3><p>在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件<code>Shapes.hs</code>中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Shapes</span><br><span class="line">( <span class="type">Shape(..)</span></span><br><span class="line">, <span class="type">Point(..)</span></span><br><span class="line">, <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">) <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>Shape(..)</code>导出了Shape类型和它所有的值构造器，<code>..</code>代表了它的所有值构造器。因此，<code>Shape(..)</code>相当于<code>Shape (Circle, Rectangle)</code>。</p>
<p>如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将<code>Shape(..)</code>替换为<code>Shape</code>，这样就只导出了Shape类型，而不导出其值构造器。</p>
<h3 id="Record-Syntax"><a href="#Record-Syntax" class="headerlink" title="Record Syntax"></a>Record Syntax</h3><p>如果想要方便地取出类型实例中的参数，可以使用Record语法，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   , <span class="title">ycoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> point = <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; xcoord point</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; ycoord point</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>同时也可以通过下面方法来创建这个point：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">point</span> = <span class="type">Point</span> &#123;ycoord=<span class="number">2.0</span>, xcoord=<span class="number">1.0</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Type-parameters"><a href="#Type-parameters" class="headerlink" title="Type parameters"></a>Type parameters</h3><p>值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义：</p>
<p style="text-align: center;">data Maybe a = Nothing | Just a</p>

<p>它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。<br>他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">Nothing</span> :: <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> <span class="number">1</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> &#x27;a&#x27; :: <span class="type">Maybe</span> <span class="type">Char</span></span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;abc&quot;</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]</span><br></pre></td></tr></table></figure>

<p>可以用这种方法改写Point：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> x y = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="title">x</span></span></span><br><span class="line"><span class="class">                       , <span class="title">ycoord</span> :: <span class="title">y</span></span></span><br><span class="line"><span class="class">                       &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。</p>
<p>而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> (<span class="type">Ord</span> <span class="title">k</span>) =&gt; <span class="type">Map</span> k v = ... </span></span><br><span class="line"><span class="title">toList</span> :: (<span class="type">Ord</span> k) =&gt; <span class="type">Map</span> k a -&gt; [(k, a)]</span><br></pre></td></tr></table></figure>

<h4 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h4><p>Either是一个类型构造器，它有两个值构造器，定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Read</span>, <span class="type">Show</span>)  </span></span><br></pre></td></tr></table></figure>
<p>如果使用了Left，那它的a的类型就是具体的；如果使用了Right，那它的b的类型就是具体的：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Right</span> <span class="number">20</span>  </span><br><span class="line"><span class="type">Right</span> <span class="number">20</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Left</span> <span class="string">&quot;w00t&quot;</span>  </span><br><span class="line"><span class="type">Left</span> <span class="string">&quot;w00t&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Right</span> &#x27;a&#x27;  </span><br><span class="line"><span class="type">Right</span> &#x27;a&#x27; :: <span class="type">Either</span> a <span class="type">Char</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Left</span> <span class="type">True</span>  </span><br><span class="line"><span class="type">Left</span> <span class="type">True</span> :: <span class="type">Either</span> <span class="type">Bool</span> b  </span><br></pre></td></tr></table></figure>
<p>Either可以看作Maybe的补充，比如Maybe在使用时，出现异常可以返回Nothing，但只是一个Nothing，不包含任何信息；但Either包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Nothing</span></span><br><span class="line"><span class="title">safeDiv</span> x y = <span class="type">Just</span> (x `div` y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>而使用Either：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Either</span> <span class="type">String</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Left</span> <span class="string">&quot;Divided by zero&quot;</span></span><br><span class="line"><span class="title">safeDiv</span> x y = <span class="type">Right</span> (x `div` y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="type">Right</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="type">Left</span> <span class="string">&quot;Divided by zero&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Derived-instances"><a href="#Derived-instances" class="headerlink" title="Derived instances"></a>Derived instances</h3><p>想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span>   </span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)  </span><br></pre></td></tr></table></figure>
<p>这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右）</p>
<h3 id="Type-synonyms"><a href="#Type-synonyms" class="headerlink" title="Type synonyms"></a>Type synonyms</h3><p>为了阅读方便，书写简便，可以使用<code>type</code>关键字为已有类型创建别名（synonyms）。比如String的定义：</p>
<p style="text-align: center;">type String = [Char]</p>

<p>在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。<br>同时，类型别名也可以接收类型参数</p>
<h4 id="newtype-keyword"><a href="#newtype-keyword" class="headerlink" title="newtype keyword"></a>newtype keyword</h4><p>除了<code>data</code>、<code>type</code>关键字之外，还可以用<code>newtype</code>关键字来定义一个新的类型，比如<code>Control.Applicative</code>模块中的ZipList：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ZipList</span> a = &#123; <span class="title">getZipList</span> :: [<span class="title">a</span>] &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不同于type，它不是别名，可以使用record语法来直接定义取出值的函数</li>
<li>不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰</li>
</ul>
<h3 id="Recursive-data-structures"><a href="#Recursive-data-structures" class="headerlink" title="Recursive data structures"></a>Recursive data structures</h3><p>一个类型也可以递归定义，比如一颗二叉树：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">EmptyTree</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>)  </span></span><br></pre></td></tr></table></figure>

<h2 id="定义新Typeclass"><a href="#定义新Typeclass" class="headerlink" title="定义新Typeclass"></a>定义新Typeclass</h2><p>定义一个新的Typeclass需要使用class关键字，例如定义Eq类型类：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span>  </span><br><span class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span>  </span><br><span class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span>  </span><br><span class="line">    x == y = not (x /= y)  </span><br><span class="line">    x /= y = not (x == y)  </span><br></pre></td></tr></table></figure>
<p>其中<code>a</code>是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。</p>
<p>包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们（<code>(==) | (/=)</code>）成为这个类型类的最小完整定义（minimal complete definition）</p>
<p>查看一个类型类的成员需要实现的函数可以在GHCi中使用<code>:info</code>：</p>
<p style="text-align: center;">ghci> :info Eq</p>

<h3 id="手动创建实例"><a href="#手动创建实例" class="headerlink" title="手动创建实例"></a>手动创建实例</h3><p>使一个类型成为一个类型类的实例可以直接使用<code>deriving</code>来自动完成，也可以通过使用instance关键字来手动完成。比如使Point成为Show的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Point</span> <span class="keyword">where</span></span></span><br><span class="line">    show (<span class="type">Point</span> x y) = <span class="string">&quot;(&quot;</span> ++ show x ++ <span class="string">&quot;, &quot;</span> ++ show y ++ <span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- in ghci</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以自定义显示的内容，否则使用deriving的话只会直接将其转化为字符串。</p>
<p>同时也要注意类型和类型构造器的区别，传入给instance的第二个参数应该为类型而不是类型构造器，比如Maybe：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">Maybe</span> <span class="keyword">where</span></span>  </span><br><span class="line">    ...    </span><br><span class="line"><span class="comment">-- 错误用法，因为Maybe是类型构造器而不是类型</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    ...</span><br><span class="line"><span class="comment">-- 错误用法，因为m不一定是Eq的成员</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Eq</span> <span class="title">m</span>) =&gt; <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    <span class="type">Just</span> x == <span class="type">Just</span> y = x == y  </span><br><span class="line">    <span class="type">Nothing</span> == <span class="type">Nothing</span> = <span class="type">True</span>  </span><br><span class="line">    _ == _ = <span class="type">False</span>  </span><br></pre></td></tr></table></figure>

<h3 id="Functor-Typeclass"><a href="#Functor-Typeclass" class="headerlink" title="Functor Typeclass"></a>Functor Typeclass</h3><p>Functor也是一种类型类，它只规定了一个函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>其中<code>f</code>是一个类型构造器，而不是一个具体类型</p>
<h2 id="Kinds"><a href="#Kinds" class="headerlink" title="Kinds"></a>Kinds</h2><p>一个值的类型叫做类型（Type），而一个类型的类型叫做Kind。可以通过GHCi中<code>:k</code>来查看Kind：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Int</span></span><br><span class="line"><span class="type">Int</span> :: *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Maybe</span></span><br><span class="line"><span class="type">Maybe</span> :: * -&gt; *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="type">Maybe</span> <span class="type">Int</span> :: *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Either</span></span><br><span class="line"><span class="type">Either</span> :: * -&gt; * -&gt; *</span><br></pre></td></tr></table></figure>
<p>其中的星号<code>*</code>代表了一个具体类型（concrete type）。Int本身就是一个具体类型，所以Int的Kind是*。而Maybe是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以Maybe的Kind是* -&gt; *。如果给Maybe传入了一个Int，那么得到的Maybe Int就是一个具体的类型，它的Kind就是*。Either也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以Either的Kind是* -&gt; * -&gt; *。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#2 高阶函数与模块</title>
    <url>/p/53e482b7.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/d63b5b5f.html">&lt; #1</a></p>
<p><a href="/p/369b7e08.html">#3 &gt;</a></p>
</div>

<h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h2><h3 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h3><p>Haskell中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如max函数，它的类型签名是：</p>
<span id="more"></span>
<p style="text-align: center;">max :: Ord a => a -> a -> a</p>

<p>可以看成a -&gt; (a -&gt; a)，即接收一个参数，返回一个类型为a -&gt; a的函数。比如max 1的类型签名是：</p>
<p style="text-align: center;">max 1 :: (Ord a, Num a) => a -> a</p>

<p>因此max 1 2，也就等同于(max 1) 2，即将函数max 1应用在数字2上</p>
<p>同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions）</p>
<h3 id="一些高阶函数"><a href="#一些高阶函数" class="headerlink" title="一些高阶函数"></a>一些高阶函数</h3><h4 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h4><p style="text-align: center;">zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]</p>

<p>第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith max [<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]  </span><br></pre></td></tr></table></figure>

<h4 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h4><p style="text-align: center;">flip :: (a -> b -> c) -> b -> a -> c</p>

<p>flip函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">&quot;hello&quot;</span></span><br><span class="line">[(<span class="number">1</span>,&#x27;h&#x27;),(<span class="number">2</span>,&#x27;e&#x27;),(<span class="number">3</span>,&#x27;l&#x27;),(<span class="number">4</span>,&#x27;l&#x27;),(<span class="number">5</span>,&#x27;o&#x27;)]</span><br><span class="line"><span class="title">ghci</span>&gt; flip zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">&quot;hello&quot;</span>  </span><br><span class="line">[(&#x27;h&#x27;,<span class="number">1</span>),(&#x27;e&#x27;,<span class="number">2</span>),(&#x27;l&#x27;,<span class="number">3</span>),(&#x27;l&#x27;,<span class="number">4</span>),(&#x27;o&#x27;,<span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map函数接收一个函数f和一个列表a，将函数f应用在列表a的每个元素中，并返回得到的所有结果组成的列表b：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]  </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]  </span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p style="text-align: center;">filter :: (a -> Bool) -> [a] -> [a]</p>

<p>filter函数接收一个函数f和一个列表a，将列表a中的每个元素传入函数f中，如果结果为True就保留，结果为False就抛弃，返回所有保留的元素组成的新列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; filter even [<span class="number">1.</span><span class="number">.10</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] </span><br></pre></td></tr></table></figure>

<h4 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h4><p style="text-align: center;">takeWhile :: (a -> Bool) -> [a] -> [a]</p>

<p>takeWhile函数接收一个函数f和一个列表a，将列表a中从左向右每个元素传入函数f，直到结果为False停止，返回停止前传入的所有元素组成的新列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; takeWhile (/=&#x27; &#x27;) <span class="string">&quot;word1 word2&quot;</span></span><br><span class="line"><span class="string">&quot;word1&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-application"><a href="#Function-application" class="headerlink" title="Function application"></a>Function application</h3><p>函数应用可以使用<code>$</code>，<code>$</code>是一个函数，它的类型是：</p>
<p style="text-align: center;">($) :: (a -> b) -> a -> b</p>

<p>它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。</p>
<!--more-->
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f</span> $ g x</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="title">f</span> (g x)</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="title">f</span> g x</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line">(f g) x</span><br></pre></td></tr></table></figure>
<h3 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h3><p>函数复合可以使用<code>.</code>，<code>.</code>也是一个函数，它的类型是：</p>
<p style="text-align: center;">(.) :: (b -> c) -> (a -> b) -> a -> c</p>

<p>定义是：</p>
<p style="text-align: center;">f . g = \x -> f (g x)</p>

<p>但是函数复合的优先级要比函数执行低，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum</span> . replicate <span class="number">5</span> . max <span class="number">6.7</span> <span class="number">8.9</span></span><br></pre></td></tr></table></figure>
<p>会先执行max 6.7 8.9并返回8.9，然后将sum、replicate 5、8.9复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用<code>$</code>来规定先复合再执行：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum</span> . replicate <span class="number">5</span> . max <span class="number">6.7</span> $ <span class="number">8.9</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>Haskell语言中的lambda表达式是用<code>\</code>来表示的（因为看着像$\mathtt{\lambda}$？）<br>具体语法是</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">\para1 para2 ... -&gt; return</span><br></pre></td></tr></table></figure>
<p>“-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。</p>
<h3 id="fold和scan"><a href="#fold和scan" class="headerlink" title="fold和scan"></a>fold和scan</h3><p>fold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表<br>传入的二元函数<code>f :: a -&gt; b -&gt; b</code>将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数）</p>
<h4 id="foldl"><a href="#foldl" class="headerlink" title="foldl"></a>foldl</h4><p>左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldl</span> f a xs</span><br></pre></td></tr></table></figure>
<p>它的结果计算过程为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; foldl f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f a x1</span><br><span class="line">[<span class="number">2.</span>] a = f a x2 = f (f a x1) x2</span><br><span class="line">[<span class="number">3.</span>] a = f a x3 = f (f (f a x1) x2) x3</span><br></pre></td></tr></table></figure>
<p>可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]<br>而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表</p>
<h4 id="foldr"><a href="#foldr" class="headerlink" title="foldr"></a>foldr</h4><p>右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> f a xs</span><br></pre></td></tr></table></figure>
<p>它的结果计算过程为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; foldr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f x3 a</span><br><span class="line">[<span class="number">2.</span>] a = f x2 a = f x2 (f x3 a)</span><br><span class="line">[<span class="number">3.</span>] a = f x1 a = f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure>
<p>从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]<br>因此可以使用递归来写一个和foldr效果一样的函数:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">foldr&#x27;</span> _ x [] = x</span><br><span class="line"><span class="title">foldr&#x27;</span> f a (x:xs) = f x (foldr&#x27; f a xs)</span><br></pre></td></tr></table></figure>
<p>也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表</p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; foldr (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="type">True</span>    <span class="comment">-- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了</span></span><br><span class="line"><span class="title">ghci</span>&gt; foldl (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="comment">-- 这里什么都不会发生，直到电脑内存被爆掉</span></span><br><span class="line"><span class="comment">-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表</span></span><br></pre></td></tr></table></figure>

<h4 id="scanl和scanr"><a href="#scanl和scanr" class="headerlink" title="scanl和scanr"></a>scanl和scanr</h4><p>scan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表<br>scanl则向右延伸这个列表，scanr则向左延伸这个列表<br>但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; scanr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] 最右侧元素(<span class="number">-1</span> <span class="keyword">in</span> python) : a</span><br><span class="line">[<span class="number">2.</span>] 右侧第二个元素(<span class="number">-2</span>) : f x3 a</span><br><span class="line">[<span class="number">3.</span>] 右侧第三个元素(<span class="number">-3</span>) : f x2 (f x3 a)</span><br><span class="line">[<span class="number">4.</span>] 右侧第四个元素(<span class="number">-4</span>) : f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure>
<p>可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素<br>因此可以用递归来写一个和scanr效果一样的函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">scanr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanr&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="comment">-- scanr&#x27; f a (x:xs) = f x (foldr f a xs) : scanr&#x27; f a xs</span></span><br><span class="line"><span class="title">scanr&#x27;</span> f a (x:xs) = f x q : qs</span><br><span class="line">                    <span class="keyword">where</span> qs@(q:_) = scanr&#x27; f a xs</span><br></pre></td></tr></table></figure>
<p>scanl也是同理：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">scanl&#x27;</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanl&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="title">scanl&#x27;</span> f a (x:xs) = a : scanl&#x27; f (f a x) xs</span><br></pre></td></tr></table></figure>

<p>也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanl (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">28</span>,<span class="number">36</span>,<span class="number">45</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanr (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[*** <span class="type">Exception</span>: stack overflow</span><br></pre></td></tr></table></figure>

<h4 id="使用foldr编写foldl"><a href="#使用foldr编写foldl" class="headerlink" title="使用foldr编写foldl"></a>使用foldr编写foldl</h4><p>pdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldl&#x27;</span> f z xs = foldr (\x g y -&gt; g (f y x)) id xs z</span><br></pre></td></tr></table></figure>

<p>它利用 foldr (\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。</p>
<p>先来看一下foldr的类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> :: <span class="type">Foldable</span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line"><span class="comment">-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br></pre></td></tr></table></figure>
<p>但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。</p>
<p>所以这里foldr的类型可以写成：</p>
<p style="text-align: center;">(a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b)</p>

<p>对应于用法 foldr (\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）<br>而xs对应于[a]；id对应于(b -&gt; b)<br>所以 (\x g y -&gt; g (f y x)) 要对应于：</p>
<p style="text-align: center;">(a -> (b -> b) -> (b -> b))</p>

<p>因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。</p>
<p>再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b<br>所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为：</p>
<p style="text-align: center;">b -> (b -> b)</p>

<p>现在根据foldr的定义：</p>
<p style="text-align: center;">foldr f a (x:xs) = f x (foldr f a xs)</p>

<p>带入计算一下：</p>
<blockquote>
<p>xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn]</p>
<p>定义中的f即为(\x g y -&gt; g (f y x))，a即为id</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  foldr (\x g y -&gt; g (f y x)) id xs z</span><br><span class="line">= (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br></pre></td></tr></table></figure>
<p>写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br></pre></td></tr></table></figure>
<p>不难发现，原式 (foldr (…) id xs) z 等价于：</p>
<p style="text-align: center;">(foldr (...) id xs') (f z x1)</p>

<p>跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’<br>因此下一步：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;&#x27;) (f (f (f z x1) x2) x3)</span><br><span class="line">= ...</span><br></pre></td></tr></table></figure>
<p>可以发现，已经有了规律。那么最终停止时是什么样呢？</p>
<p>最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []<br>而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id</p>
<p>所以最后的结果：<br>(id的定义：id x = x)</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= ...</span><br><span class="line">= (foldr (...) id []) (f (.. (f z x1) ..) xn)</span><br><span class="line">= id (f (.. (f z x1) ..) xn)</span><br><span class="line">= f (.. (f z x1) ..) xn</span><br></pre></td></tr></table></figure>
<p>那么最后这个结果就很熟悉了，它就是 foldl f z xs。<br>所以我们推导出了这个用foldr表示foldl的写法是正确的。</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Haskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用<code>:m + ...</code>，比如加载Data.List模块：</p>
<p style="text-align: center;">Prelude> :m + Data.List</p>

<p>而在hs文件中引入模块，需要使用<code>import</code>语句，下面和python的对比可以便于理解：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="comment">-- from Data.List import *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">nub</span>, <span class="title">sort</span>)</span><br><span class="line"><span class="comment">-- from Data.List import nub, sort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List <span class="keyword">hiding</span> (<span class="title">nub</span>)</span><br><span class="line"><span class="comment">-- 从Data.List中引入所有，但不引入nub函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List</span><br><span class="line"><span class="comment">-- import Data.List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List <span class="keyword">as</span> Li</span><br><span class="line"><span class="comment">-- import Data.List as Li</span></span><br></pre></td></tr></table></figure>

<h3 id="编写Modules"><a href="#编写Modules" class="headerlink" title="编写Modules"></a>编写Modules</h3><p>模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫<code>ModuleA.hs</code>，那它的头部需要写：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleA</span><br><span class="line">( <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">, <span class="title">functionC</span></span><br><span class="line">) <span class="keyword">where</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="https://stackoverflow.com/questions/6172004/writing-foldl-using-foldr">Writing foldl using foldr - StackOverflow</a></li>
<li><a href="https://blog.csdn.net/WinterShiver/article/details/103308165">Haskell：用foldr定义foldl</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#1 基础语法与函数</title>
    <url>/p/d63b5b5f.html</url>
    <content><![CDATA[<div style="display: flex; justify-content: space-between;">

<p><a href="/p/b3ca5c18.html">&lt; #0</a></p>
<p><a href="/p/53e482b7.html">#2 &gt;</a></p>
</div>

<h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><ul>
<li><code>+ - * / ()</code>：加减乘除</li>
<li><code>div</code>：整除</li>
<li><code>mod</code>：取模</li>
<li><code>True False</code>：布尔值<span id="more"></span></li>
<li><code>|| &amp;&amp; not</code>：或且非</li>
<li><code>==</code>：条件判断，相等</li>
<li><code>/=</code>：条件判断，不等</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>Haskell中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; max <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>前缀（prefix）函数与中缀（infix）函数转换：</p>
<ul>
<li>对前缀函数加<code>``</code>使其变成中缀函数</li>
<li>对中缀函数加<code>()</code>使其变成前缀函数</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `div` <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">1</span> `max` <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; (||) <span class="type">True</span> <span class="type">False</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表是Haskell中很常见的数据类型，和Python中不同，Haskell中的列表中的所有元素必须是同一个类型。</p>
<p>以下是列表常用的函数：</p>
<!--more-->
<ul>
<li><code>(++)</code> :: [a] -&gt; [a] -&gt; [a]：合并两个列表</li>
<li><code>(:)</code> :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。[1, 2, 3]是1:2:3:[]的语法糖</li>
<li><code>(!!)</code> :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。a !! 1相当于Python中的a[1]</li>
<li><code>head</code> :: [a] -&gt; a：返回列表的第一个元素</li>
<li><code>tail</code> :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]）</li>
<li><code>last</code> :: [a] -&gt; a：返回列表中的最后一个元素</li>
<li><code>init</code> :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表</li>
<li><code>length</code> :: Foldable t =&gt; t a -&gt; Int：返回列表的长度</li>
<li><code>null</code> :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空</li>
<li><code>reverse</code> :: [a] -&gt; [a]：返回翻转后的列表</li>
<li><code>take</code> :: Int -&gt; [a] -&gt; [a]：返回列表a的前n个元素的列表(take n a)</li>
<li><code>drop</code> :: Int -&gt; [a] -&gt; [a]：返回列表a中除去前n个元素后的列表(drop n a)</li>
<li><code>maximum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值</li>
<li><code>minimum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值</li>
<li><code>sum</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和</li>
<li><code>product</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积</li>
<li><code>elem</code> :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值n是否在列表a中(  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">elem</span> n a</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="title">n</span> `elem` a <span class="comment">--用``包上可以变成中缀函数使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Texas-ranges"><a href="#Texas-ranges" class="headerlink" title="Texas ranges"></a>Texas ranges</h3><p>使用<code>..</code>可以表示出范围并自动推导：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span> .. <span class="number">10</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;a&#x27; .. &#x27;z&#x27;]  </span><br><span class="line"><span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;<span class="type">K&#x27;</span> .. &#x27;<span class="type">Z&#x27;</span>]  </span><br><span class="line"><span class="string">&quot;KLMNOPQRSTUVWXYZ&quot;</span> </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">2</span>, <span class="number">4</span> .. <span class="number">20</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>, <span class="number">6</span> .. <span class="number">20</span>]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">5</span>, <span class="number">4</span> .. <span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>也可以用来生成无穷列表，如[1..]、[1, 3..]。同时也有函数可以生成无穷列表：</p>
<ul>
<li><code>cycle</code> :: [a] -&gt; [a]：将原列表不断循环生成无穷列表</li>
<li><code>repeat</code> :: a -&gt; [a]：将传入的值不断重复生成无穷列表<ul>
<li><code>replicate</code> :: Int -&gt; a -&gt; [a]：将值a重复n次，返回生成的列表(replicate n a)</li>
</ul>
</li>
</ul>
<h3 id="List-comprehension"><a href="#List-comprehension" class="headerlink" title="List comprehension"></a>List comprehension</h3><p>Haskell中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x * <span class="number">2</span> | x &lt;- [<span class="number">1</span> .. <span class="number">10</span>]]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [x * <span class="number">2</span> | x &lt;- [<span class="number">1</span> .. <span class="number">10</span>], x * <span class="number">2</span> &gt;= <span class="number">12</span>]  </span><br><span class="line">[<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50</span> .. <span class="number">100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>]  </span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; [x * y | x &lt;- [<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>], y &lt;- [<span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>]]  </span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>Haskell中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数：</p>
<ul>
<li><code>fst</code> :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素</li>
<li><code>snd</code> :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素</li>
<li><code>zip</code> :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组</li>
</ul>
<h2 id="Syntax-in-Functions"><a href="#Syntax-in-Functions" class="headerlink" title="Syntax in Functions"></a>Syntax in Functions</h2><p>函数可以直接定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">plus</span> x y = x + y</span><br></pre></td></tr></table></figure>
<p>这时Haskell会自动推断函数的类型为(Num a) =&gt; a -&gt; a -&gt; a。但是最好在定义函数前声明函数的类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">plus</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">plus</span> x y = x + y</span><br></pre></td></tr></table></figure>

<h3 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h3><p>定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a  </span><br><span class="line"><span class="title">first</span> (x, _, _) = x  </span><br><span class="line">  </span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b  </span><br><span class="line"><span class="title">second</span> (_, y, _) = y  </span><br><span class="line">  </span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c  </span><br><span class="line"><span class="title">third</span> (_, _, z) = z  </span><br></pre></td></tr></table></figure>
<p>其中<code>_</code>表示任何值，且不关心它的内容，只是用来占位</p>
<p>列表的(:)操作也可以用来进行模式匹配：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x</span><br><span class="line"></span><br><span class="line"><span class="title">sum&#x27;</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">sum&#x27;</span> [] = <span class="number">0</span>  </span><br><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs  </span><br></pre></td></tr></table></figure>
<p>但(++)操作不可以用来模式匹配</p>
<p>在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用<code>xs@(q:qs)</code>。比如[1, 2, 3]通过<code>xs@(q:qs)</code>匹配后，xs为[1, 2, 3]，q为1，qs为[2, 3]</p>
<h3 id="Guard-syntax"><a href="#Guard-syntax" class="headerlink" title="Guard syntax"></a>Guard syntax</h3><p>在函数的定义中，也可以使用守卫（guard）语法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">max&#x27;</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">max&#x27;</span> a b   </span><br><span class="line">    | a &gt; b     = a  </span><br><span class="line">    | otherwise = b </span><br></pre></td></tr></table></figure>
<p>先给出传入的参数变量，然后下一行缩进后加|，|后面等号前表示进行的判断，如果为True则返回这个等号后面的值；如果为False则继续判断下一行，直到otherwise</p>
<h3 id="Case-expressions"><a href="#Case-expressions" class="headerlink" title="Case expressions"></a>Case expressions</h3><p>在函数的定义中，也可以使用case表达式来配合模式匹配使用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result  </span><br><span class="line">                   pattern -&gt; result</span><br><span class="line">                   ...  </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x  </span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line">                      (x:_) -&gt; x  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; <span class="string">&quot;empty.&quot;</span>  </span><br><span class="line">                                               [x] -&gt; <span class="string">&quot;a singleton list.&quot;</span>   </span><br><span class="line">                                               xs -&gt; <span class="string">&quot;a longer list.&quot;</span>  </span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ what xs  </span><br><span class="line">    <span class="keyword">where</span> what [] = <span class="string">&quot;empty.&quot;</span>  </span><br><span class="line">          what [x] = <span class="string">&quot;a singleton list.&quot;</span>  </span><br><span class="line">          what xs = <span class="string">&quot;a longer list.&quot;</span> </span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>声明在函数定义中要使用的局部变量，可以使用where关键字：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">initials</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">initials</span> firstname lastname = [f] ++ <span class="string">&quot;. &quot;</span> ++ [l] ++ <span class="string">&quot;.&quot;</span>  </span><br><span class="line">    <span class="keyword">where</span> (f:_) = firstname  </span><br><span class="line">          (l:_) = lastname  </span><br></pre></td></tr></table></figure>
<p>在where中，也可以使用上面的模式匹配</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let &lt;bindings&gt; in &lt;expression&gt;</code>语法可以在函数的定义中使用，也可以在普通算式或列表中使用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">cylinder</span> r h = </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h  </span><br><span class="line">        topArea = pi * r ^<span class="number">2</span>  </span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> * (<span class="keyword">let</span> a = <span class="number">9</span> <span class="keyword">in</span> a + <span class="number">1</span>) + <span class="number">2</span>  </span><br><span class="line"><span class="number">42</span> </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="keyword">let</span> square x = x * x <span class="keyword">in</span> (square <span class="number">5</span>, square <span class="number">3</span>, square <span class="number">2</span>)]  </span><br><span class="line">[(<span class="number">25</span>,<span class="number">9</span>,<span class="number">4</span>)] </span><br></pre></td></tr></table></figure>

<h3 id="if-statement"><a href="#if-statement" class="headerlink" title="if statement"></a>if statement</h3><p>Haskell中的if语句为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> ...</span><br><span class="line"><span class="comment">-- or if ... then ... else ...</span></span><br><span class="line"><span class="comment">-- or</span></span><br><span class="line"><span class="title">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> <span class="keyword">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> ...</span><br></pre></td></tr></table></figure>
<p>其中最后一个else无论如何也不可以省去</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>
]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>「Learn Haskell」#0 总章</title>
    <url>/p/b3ca5c18.html</url>
    <content><![CDATA[<p style="text-align: center;">学习一门新语言之Haskell</p>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前一直很好奇函数式编程，觉得Haskell挺有意思的，想学学<br>现在高考完放假了，可以有时间具体学一学了<br>这里没有Haskell的教程，只有我在学习Haskell时写下的笔记</p>
<span id="more"></span>

<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div>

<h2 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h2><ul>
<li><code>+ - * / ()</code>：加减乘除</li>
<li><code>div</code>：整除</li>
<li><code>mod</code>：取模</li>
<li><code>True False</code>：布尔值</li>
<li><code>|| &amp;&amp; not</code>：或且非</li>
<li><code>==</code>：条件判断，相等</li>
<li><code>/=</code>：条件判断，不等</li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>Haskell中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; max <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>前缀（prefix）函数与中缀（infix）函数转换：</p>
<ul>
<li>对前缀函数加<code>``</code>使其变成中缀函数</li>
<li>对中缀函数加<code>()</code>使其变成前缀函数</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> `div` <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="number">1</span> `max` <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+) <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; (||) <span class="type">True</span> <span class="type">False</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>列表是Haskell中很常见的数据类型，和Python中不同，Haskell中的列表中的所有元素必须是同一个类型。</p>
<p>以下是列表常用的函数：</p>
<ul>
<li><code>(++)</code> :: [a] -&gt; [a] -&gt; [a]：合并两个列表</li>
<li><code>(:)</code> :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。[1, 2, 3]是1:2:3:[]的语法糖</li>
<li><code>(!!)</code> :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。a !! 1相当于Python中的a[1]</li>
<li><code>head</code> :: [a] -&gt; a：返回列表的第一个元素</li>
<li><code>tail</code> :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]）</li>
<li><code>last</code> :: [a] -&gt; a：返回列表中的最后一个元素</li>
<li><code>init</code> :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表</li>
<li><code>length</code> :: Foldable t =&gt; t a -&gt; Int：返回列表的长度</li>
<li><code>null</code> :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空</li>
<li><code>reverse</code> :: [a] -&gt; [a]：返回翻转后的列表</li>
<li><code>take</code> :: Int -&gt; [a] -&gt; [a]：返回列表a的前n个元素的列表(take n a)</li>
<li><code>drop</code> :: Int -&gt; [a] -&gt; [a]：返回列表a中除去前n个元素后的列表(drop n a)</li>
<li><code>maximum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值</li>
<li><code>minimum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值</li>
<li><code>sum</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和</li>
<li><code>product</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积</li>
<li><code>elem</code> :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值n是否在列表a中(  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">elem</span> n a</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="title">n</span> `elem` a <span class="comment">--用``包上可以变成中缀函数使用</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Texas-ranges"><a href="#Texas-ranges" class="headerlink" title="Texas ranges"></a>Texas ranges</h3><p>使用<code>..</code>可以表示出范围并自动推导：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span> .. <span class="number">10</span>]  </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;a&#x27; .. &#x27;z&#x27;]  </span><br><span class="line"><span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; [&#x27;<span class="type">K&#x27;</span> .. &#x27;<span class="type">Z&#x27;</span>]  </span><br><span class="line"><span class="string">&quot;KLMNOPQRSTUVWXYZ&quot;</span> </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">2</span>, <span class="number">4</span> .. <span class="number">20</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>, <span class="number">6</span> .. <span class="number">20</span>]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">5</span>, <span class="number">4</span> .. <span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>也可以用来生成无穷列表，如[1..]、[1, 3..]。同时也有函数可以生成无穷列表：</p>
<ul>
<li><code>cycle</code> :: [a] -&gt; [a]：将原列表不断循环生成无穷列表</li>
<li><code>repeat</code> :: a -&gt; [a]：将传入的值不断重复生成无穷列表<ul>
<li><code>replicate</code> :: Int -&gt; a -&gt; [a]：将值a重复n次，返回生成的列表(replicate n a)</li>
</ul>
</li>
</ul>
<h3 id="List-comprehension"><a href="#List-comprehension" class="headerlink" title="List comprehension"></a>List comprehension</h3><p>Haskell中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x * <span class="number">2</span> | x &lt;- [<span class="number">1</span> .. <span class="number">10</span>]]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [x * <span class="number">2</span> | x &lt;- [<span class="number">1</span> .. <span class="number">10</span>], x * <span class="number">2</span> &gt;= <span class="number">12</span>]  </span><br><span class="line">[<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50</span> .. <span class="number">100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>]  </span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; [x * y | x &lt;- [<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>], y &lt;- [<span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>]]  </span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>Haskell中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数：</p>
<ul>
<li><code>fst</code> :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素</li>
<li><code>snd</code> :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素</li>
<li><code>zip</code> :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组</li>
</ul>
<h2 id="Syntax-in-Functions"><a href="#Syntax-in-Functions" class="headerlink" title="Syntax in Functions"></a>Syntax in Functions</h2><p>函数可以直接定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">plus</span> x y = x + y</span><br></pre></td></tr></table></figure>
<p>这时Haskell会自动推断函数的类型为(Num a) =&gt; a -&gt; a -&gt; a。但是最好在定义函数前声明函数的类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">plus</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">plus</span> x y = x + y</span><br></pre></td></tr></table></figure>

<h3 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h3><p>定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a  </span><br><span class="line"><span class="title">first</span> (x, _, _) = x  </span><br><span class="line">  </span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b  </span><br><span class="line"><span class="title">second</span> (_, y, _) = y  </span><br><span class="line">  </span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c  </span><br><span class="line"><span class="title">third</span> (_, _, z) = z  </span><br></pre></td></tr></table></figure>
<p>其中<code>_</code>表示任何值，且不关心它的内容，只是用来占位</p>
<p>列表的(:)操作也可以用来进行模式匹配：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x</span><br><span class="line"></span><br><span class="line"><span class="title">sum&#x27;</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a  </span><br><span class="line"><span class="title">sum&#x27;</span> [] = <span class="number">0</span>  </span><br><span class="line"><span class="title">sum&#x27;</span> (x:xs) = x + sum&#x27; xs  </span><br></pre></td></tr></table></figure>
<p>但(++)操作不可以用来模式匹配</p>
<p>在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用<code>xs@(q:qs)</code>。比如[1, 2, 3]通过<code>xs@(q:qs)</code>匹配后，xs为[1, 2, 3]，q为1，qs为[2, 3]</p>
<h3 id="Guard-syntax"><a href="#Guard-syntax" class="headerlink" title="Guard syntax"></a>Guard syntax</h3><p>在函数的定义中，也可以使用守卫（guard）语法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">max&#x27;</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">max&#x27;</span> a b   </span><br><span class="line">    | a &gt; b     = a  </span><br><span class="line">    | otherwise = b </span><br></pre></td></tr></table></figure>
<p>先给出传入的参数变量，然后下一行缩进后加|，|后面等号前表示进行的判断，如果为True则返回这个等号后面的值；如果为False则继续判断下一行，直到otherwise</p>
<h3 id="Case-expressions"><a href="#Case-expressions" class="headerlink" title="Case expressions"></a>Case expressions</h3><p>在函数的定义中，也可以使用case表达式来配合模式匹配使用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result  </span><br><span class="line">                   pattern -&gt; result</span><br><span class="line">                   ...  </span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x  </span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line">                      (x:_) -&gt; x  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; <span class="string">&quot;empty.&quot;</span>  </span><br><span class="line">                                               [x] -&gt; <span class="string">&quot;a singleton list.&quot;</span>   </span><br><span class="line">                                               xs -&gt; <span class="string">&quot;a longer list.&quot;</span>  </span><br><span class="line"><span class="comment">-- 等价于：</span></span><br><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">&quot;The list is &quot;</span> ++ what xs  </span><br><span class="line">    <span class="keyword">where</span> what [] = <span class="string">&quot;empty.&quot;</span>  </span><br><span class="line">          what [x] = <span class="string">&quot;a singleton list.&quot;</span>  </span><br><span class="line">          what xs = <span class="string">&quot;a longer list.&quot;</span> </span><br></pre></td></tr></table></figure>

<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>声明在函数定义中要使用的局部变量，可以使用where关键字：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">initials</span> :: <span class="type">String</span> -&gt; <span class="type">String</span> -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">initials</span> firstname lastname = [f] ++ <span class="string">&quot;. &quot;</span> ++ [l] ++ <span class="string">&quot;.&quot;</span>  </span><br><span class="line">    <span class="keyword">where</span> (f:_) = firstname  </span><br><span class="line">          (l:_) = lastname  </span><br></pre></td></tr></table></figure>
<p>在where中，也可以使用上面的模式匹配</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p><code>let &lt;bindings&gt; in &lt;expression&gt;</code>语法可以在函数的定义中使用，也可以在普通算式或列表中使用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a  </span><br><span class="line"><span class="title">cylinder</span> r h = </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h  </span><br><span class="line">        topArea = pi * r ^<span class="number">2</span>  </span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea  </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="number">4</span> * (<span class="keyword">let</span> a = <span class="number">9</span> <span class="keyword">in</span> a + <span class="number">1</span>) + <span class="number">2</span>  </span><br><span class="line"><span class="number">42</span> </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="keyword">let</span> square x = x * x <span class="keyword">in</span> (square <span class="number">5</span>, square <span class="number">3</span>, square <span class="number">2</span>)]  </span><br><span class="line">[(<span class="number">25</span>,<span class="number">9</span>,<span class="number">4</span>)] </span><br></pre></td></tr></table></figure>

<h3 id="if-statement"><a href="#if-statement" class="headerlink" title="if statement"></a>if statement</h3><p>Haskell中的if语句为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> ...</span><br><span class="line"><span class="comment">-- or if ... then ... else ...</span></span><br><span class="line"><span class="comment">-- or</span></span><br><span class="line"><span class="title">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> <span class="keyword">if</span> ... <span class="keyword">then</span> ...</span><br><span class="line"><span class="title">else</span> ...</span><br></pre></td></tr></table></figure>
<p>其中最后一个else无论如何也不可以省去</p>
<h2 id="Higher-Order-Functions"><a href="#Higher-Order-Functions" class="headerlink" title="Higher Order Functions"></a>Higher Order Functions</h2><h3 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h3><p>Haskell中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如max函数，它的类型签名是：</p>
<p style="text-align: center;">max :: Ord a => a -> a -> a</p>

<p>可以看成a -&gt; (a -&gt; a)，即接收一个参数，返回一个类型为a -&gt; a的函数。比如max 1的类型签名是：</p>
<p style="text-align: center;">max 1 :: (Ord a, Num a) => a -> a</p>

<p>因此max 1 2，也就等同于(max 1) 2，即将函数max 1应用在数字2上</p>
<p>同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions）</p>
<h3 id="一些高阶函数"><a href="#一些高阶函数" class="headerlink" title="一些高阶函数"></a>一些高阶函数</h3><h4 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h4><p style="text-align: center;">zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]</p>

<p>第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith max [<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]  </span><br></pre></td></tr></table></figure>

<h4 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h4><p style="text-align: center;">flip :: (a -> b -> c) -> b -> a -> c</p>

<p>flip函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">&quot;hello&quot;</span></span><br><span class="line">[(<span class="number">1</span>,&#x27;h&#x27;),(<span class="number">2</span>,&#x27;e&#x27;),(<span class="number">3</span>,&#x27;l&#x27;),(<span class="number">4</span>,&#x27;l&#x27;),(<span class="number">5</span>,&#x27;o&#x27;)]</span><br><span class="line"><span class="title">ghci</span>&gt; flip zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">&quot;hello&quot;</span>  </span><br><span class="line">[(&#x27;h&#x27;,<span class="number">1</span>),(&#x27;e&#x27;,<span class="number">2</span>),(&#x27;l&#x27;,<span class="number">3</span>),(&#x27;l&#x27;,<span class="number">4</span>),(&#x27;o&#x27;,<span class="number">5</span>)]</span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map函数接收一个函数f和一个列表a，将函数f应用在列表a的每个元素中，并返回得到的所有结果组成的列表b：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]  </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]  </span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p style="text-align: center;">filter :: (a -> Bool) -> [a] -> [a]</p>

<p>filter函数接收一个函数f和一个列表a，将列表a中的每个元素传入函数f中，如果结果为True就保留，结果为False就抛弃，返回所有保留的元素组成的新列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; filter even [<span class="number">1.</span><span class="number">.10</span>]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] </span><br></pre></td></tr></table></figure>

<h4 id="takeWhile"><a href="#takeWhile" class="headerlink" title="takeWhile"></a>takeWhile</h4><p style="text-align: center;">takeWhile :: (a -> Bool) -> [a] -> [a]</p>

<p>takeWhile函数接收一个函数f和一个列表a，将列表a中从左向右每个元素传入函数f，直到结果为False停止，返回停止前传入的所有元素组成的新列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; takeWhile (/=&#x27; &#x27;) <span class="string">&quot;word1 word2&quot;</span></span><br><span class="line"><span class="string">&quot;word1&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Function-application"><a href="#Function-application" class="headerlink" title="Function application"></a>Function application</h3><p>函数应用可以使用<code>$</code>，<code>$</code>是一个函数，它的类型是：</p>
<p style="text-align: center;">($) :: (a -> b) -> a -> b</p>

<p>它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f</span> $ g x</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line"><span class="title">f</span> (g x)</span><br><span class="line"><span class="comment">-----</span></span><br><span class="line"><span class="title">f</span> g x</span><br><span class="line"><span class="comment">-- 等价于</span></span><br><span class="line">(f g) x</span><br></pre></td></tr></table></figure>
<h3 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h3><p>函数复合可以使用<code>.</code>，<code>.</code>也是一个函数，它的类型是：</p>
<p style="text-align: center;">(.) :: (b -> c) -> (a -> b) -> a -> c</p>

<p>定义是：</p>
<p style="text-align: center;">f . g = \x -> f (g x)</p>

<p>但是函数复合的优先级要比函数执行低，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum</span> . replicate <span class="number">5</span> . max <span class="number">6.7</span> <span class="number">8.9</span></span><br></pre></td></tr></table></figure>
<p>会先执行max 6.7 8.9并返回8.9，然后将sum、replicate 5、8.9复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用<code>$</code>来规定先复合再执行：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sum</span> . replicate <span class="number">5</span> . max <span class="number">6.7</span> $ <span class="number">8.9</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>Haskell语言中的lambda表达式是用<code>\</code>来表示的（因为看着像$\mathtt{\lambda}$？）<br>具体语法是</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">\para1 para2 ... -&gt; return</span><br></pre></td></tr></table></figure>
<p>“-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。</p>
<h3 id="fold和scan"><a href="#fold和scan" class="headerlink" title="fold和scan"></a>fold和scan</h3><p>fold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表<br>传入的二元函数<code>f :: a -&gt; b -&gt; b</code>将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数）</p>
<h4 id="foldl"><a href="#foldl" class="headerlink" title="foldl"></a>foldl</h4><p>左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldl</span> f a xs</span><br></pre></td></tr></table></figure>
<p>它的结果计算过程为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; foldl f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f a x1</span><br><span class="line">[<span class="number">2.</span>] a = f a x2 = f (f a x1) x2</span><br><span class="line">[<span class="number">3.</span>] a = f a x3 = f (f (f a x1) x2) x3</span><br></pre></td></tr></table></figure>
<p>可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]<br>而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表</p>
<h4 id="foldr"><a href="#foldr" class="headerlink" title="foldr"></a>foldr</h4><p>右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> f a xs</span><br></pre></td></tr></table></figure>
<p>它的结果计算过程为</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; foldr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] a = f x3 a</span><br><span class="line">[<span class="number">2.</span>] a = f x2 a = f x2 (f x3 a)</span><br><span class="line">[<span class="number">3.</span>] a = f x1 a = f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure>
<p>从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]<br>因此可以使用递归来写一个和foldr效果一样的函数:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span><br><span class="line"><span class="title">foldr&#x27;</span> _ x [] = x</span><br><span class="line"><span class="title">foldr&#x27;</span> f a (x:xs) = f x (foldr&#x27; f a xs)</span><br></pre></td></tr></table></figure>
<p>也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表</p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; foldr (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="type">True</span>    <span class="comment">-- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了</span></span><br><span class="line"><span class="title">ghci</span>&gt; foldl (||) <span class="type">False</span> (repeat <span class="type">True</span>)</span><br><span class="line"><span class="comment">-- 这里什么都不会发生，直到电脑内存被爆掉</span></span><br><span class="line"><span class="comment">-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表</span></span><br></pre></td></tr></table></figure>

<h4 id="scanl和scanr"><a href="#scanl和scanr" class="headerlink" title="scanl和scanr"></a>scanl和scanr</h4><p>scan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表<br>scanl则向右延伸这个列表，scanr则向左延伸这个列表<br>但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&gt; scanr f a [x1, x2, x3]</span><br><span class="line">[<span class="number">1.</span>] 最右侧元素(<span class="number">-1</span> <span class="keyword">in</span> python) : a</span><br><span class="line">[<span class="number">2.</span>] 右侧第二个元素(<span class="number">-2</span>) : f x3 a</span><br><span class="line">[<span class="number">3.</span>] 右侧第三个元素(<span class="number">-3</span>) : f x2 (f x3 a)</span><br><span class="line">[<span class="number">4.</span>] 右侧第四个元素(<span class="number">-4</span>) : f x1 (f x2 (f x3 a))</span><br></pre></td></tr></table></figure>
<p>可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素<br>因此可以用递归来写一个和scanr效果一样的函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">scanr&#x27;</span> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanr&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="comment">-- scanr&#x27; f a (x:xs) = f x (foldr f a xs) : scanr&#x27; f a xs</span></span><br><span class="line"><span class="title">scanr&#x27;</span> f a (x:xs) = f x q : qs</span><br><span class="line">                    <span class="keyword">where</span> qs@(q:_) = scanr&#x27; f a xs</span><br></pre></td></tr></table></figure>
<p>scanl也是同理：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">scanl&#x27;</span> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]</span><br><span class="line"><span class="title">scanl&#x27;</span> _ x [] = [x]</span><br><span class="line"><span class="title">scanl&#x27;</span> f a (x:xs) = a : scanl&#x27; f (f a x) xs</span><br></pre></td></tr></table></figure>

<p>也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanl (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">21</span>,<span class="number">28</span>,<span class="number">36</span>,<span class="number">45</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (scanr (+) <span class="number">0</span> [<span class="number">1.</span>.])</span><br><span class="line">[*** <span class="type">Exception</span>: stack overflow</span><br></pre></td></tr></table></figure>

<h4 id="使用foldr编写foldl"><a href="#使用foldr编写foldl" class="headerlink" title="使用foldr编写foldl"></a>使用foldr编写foldl</h4><p>pdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldl&#x27;</span> f z xs = foldr (\x g y -&gt; g (f y x)) id xs z</span><br></pre></td></tr></table></figure>

<p>它利用 foldr (\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。</p>
<p>先来看一下foldr的类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">foldr</span> :: <span class="type">Foldable</span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line"><span class="comment">-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br></pre></td></tr></table></figure>
<p>但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。</p>
<p>所以这里foldr的类型可以写成：</p>
<p style="text-align: center;">(a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b)</p>

<p>对应于用法 foldr (\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）<br>而xs对应于[a]；id对应于(b -&gt; b)<br>所以 (\x g y -&gt; g (f y x)) 要对应于：</p>
<p style="text-align: center;">(a -> (b -> b) -> (b -> b))</p>

<p>因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。</p>
<p>再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b<br>所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为：</p>
<p style="text-align: center;">b -> (b -> b)</p>

<p>现在根据foldr的定义：</p>
<p style="text-align: center;">foldr f a (x:xs) = f x (foldr f a xs)</p>

<p>带入计算一下：</p>
<blockquote>
<p>xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn]</p>
<p>定义中的f即为(\x g y -&gt; g (f y x))，a即为id</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  foldr (\x g y -&gt; g (f y x)) id xs z</span><br><span class="line">= (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br></pre></td></tr></table></figure>
<p>写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br></pre></td></tr></table></figure>
<p>不难发现，原式 (foldr (…) id xs) z 等价于：</p>
<p style="text-align: center;">(foldr (...) id xs') (f z x1)</p>

<p>跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’<br>因此下一步：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs&#x27;) z</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;&#x27;) (f (f (f z x1) x2) x3)</span><br><span class="line">= ...</span><br></pre></td></tr></table></figure>
<p>可以发现，已经有了规律。那么最终停止时是什么样呢？</p>
<p>最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []<br>而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id</p>
<p>所以最后的结果：<br>(id的定义：id x = x)</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  ...</span><br><span class="line">= (foldr (...) id xs&#x27;) (f z x1)</span><br><span class="line">= (foldr (...) id xs&#x27;&#x27;) (f (f z x1) x2)</span><br><span class="line">= ...</span><br><span class="line">= (foldr (...) id []) (f (.. (f z x1) ..) xn)</span><br><span class="line">= id (f (.. (f z x1) ..) xn)</span><br><span class="line">= f (.. (f z x1) ..) xn</span><br></pre></td></tr></table></figure>
<p>那么最后这个结果就很熟悉了，它就是 foldl f z xs。<br>所以我们推导出了这个用foldr表示foldl的写法是正确的。</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Haskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用<code>:m + ...</code>，比如加载Data.List模块：</p>
<p style="text-align: center;">Prelude> :m + Data.List</p>

<p>而在hs文件中引入模块，需要使用<code>import</code>语句，下面和python的对比可以便于理解：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.List</span><br><span class="line"><span class="comment">-- from Data.List import *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">nub</span>, <span class="title">sort</span>)</span><br><span class="line"><span class="comment">-- from Data.List import nub, sort</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Data.List <span class="keyword">hiding</span> (<span class="title">nub</span>)</span><br><span class="line"><span class="comment">-- 从Data.List中引入所有，但不引入nub函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List</span><br><span class="line"><span class="comment">-- import Data.List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List <span class="keyword">as</span> Li</span><br><span class="line"><span class="comment">-- import Data.List as Li</span></span><br></pre></td></tr></table></figure>

<h3 id="编写Modules"><a href="#编写Modules" class="headerlink" title="编写Modules"></a>编写Modules</h3><p>模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫<code>ModuleA.hs</code>，那它的头部需要写：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ModuleA</span><br><span class="line">( <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">, <span class="title">functionC</span></span><br><span class="line">) <span class="keyword">where</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。</p>
<h2 id="Types-amp-Typeclasses"><a href="#Types-amp-Typeclasses" class="headerlink" title="Types &amp; Typeclasses"></a>Types &amp; Typeclasses</h2><h3 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h3><p>Haskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。<br>Type的首字母全为大写，常用的有：</p>
<ul>
<li><code>Int</code>：整型，有上下界范围，-2147483647～2147483648</li>
<li><code>Integer</code>：整数，无界，但是效率比Int低</li>
<li><code>Float</code>：单精度浮点型</li>
<li><code>Double</code>：双精度浮点型</li>
<li><code>Bool</code>：布尔值</li>
<li><code>Char</code>：字符</li>
<li><code>String</code>：字符串，等同于<code>[Char]</code></li>
<li><code>Ordering</code>：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT</li>
</ul>
<p>列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加<code>[]</code>。</p>
<p>元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。</p>
<h3 id="Typeclasses"><a href="#Typeclasses" class="headerlink" title="Typeclasses"></a>Typeclasses</h3><p>类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个Typeclass<br>Typeclass的首字母也全为大写，常见的有：</p>
<ul>
<li><code>Eq</code>：可判断是否相等</li>
<li><code>Ord</code>：可比较大小</li>
<li><code>Show</code>：可展示成字符串</li>
<li><code>Read</code>：可从字符串转换成特定类型</li>
<li><code>Enum</code>：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀</li>
<li><code>Bounded</code>: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded</li>
<li><code>Integral</code>：是整数，包括Int和Integer</li>
<li><code>RealFloat</code>： 是实浮点数，包括Float和Double</li>
<li><code>RealFrac</code>：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中）</li>
<li><code>Floating</code>：是浮点数，包括Float、Double和Complex（在Data.Complex模块中）</li>
<li><code>Real</code>：是实数，包括Integral和RealFrac的成员</li>
<li><code>Fractional</code>：是分数，包括RealFrac和Floating的成员</li>
<li><code>Num</code>：是数字，包括上述所有数字相关的类型</li>
</ul>
<h3 id="Type-variables"><a href="#Type-variables" class="headerlink" title="Type variables"></a>Type variables</h3><p>如果查看一个函数的类型，比如<code>head</code>，那么将会返回以下类型：</p>
<p style="text-align: center;">head :: [a] -> a</p>

<p>其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。</p>
<p>在函数的类型表达式其实可以看作$\lambda$表达式，它适用于$\alpha$变换（$\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。</p>
<p>在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如<code>(==)</code>函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么<code>(==)</code>的类型就是：</p>
<p style="text-align: center;">(==) :: (Eq a) => a -> a -> Bool</p>

<p>其中<code>=&gt;</code>前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以<code>(==)</code>函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。</p>
<h3 id="定义新Type"><a href="#定义新Type" class="headerlink" title="定义新Type"></a>定义新Type</h3><p>定义一个新的Type需要使用<code>data</code>关键字，比如定义<code>Bool</code>需要使用：</p>
<p style="text-align: center;">data Bool = False | True</p>

<p>其中<code>=</code>左侧的部分定义了新类型的名称<code>Bool</code>，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。<br>并且名称和值构造器的首字母都需要大写。</p>
<p>另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span>   </span></span><br></pre></td></tr></table></figure>
<p>它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。<br>如果查看Circle的类型，将返回：</p>
<p style="text-align: center;">Circle :: Float -> Float -> Float -> Shape</p>

<p>如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上<code>deriving (Show)</code>:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>类型的名称和值构造器名称也可以相同，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="导出Type"><a href="#导出Type" class="headerlink" title="导出Type"></a>导出Type</h4><p>在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件<code>Shapes.hs</code>中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Shapes</span><br><span class="line">( <span class="type">Shape(..)</span></span><br><span class="line">, <span class="type">Point(..)</span></span><br><span class="line">, <span class="title">functionA</span></span><br><span class="line">, <span class="title">functionB</span></span><br><span class="line">) <span class="keyword">where</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>Shape(..)</code>导出了Shape类型和它所有的值构造器，<code>..</code>代表了它的所有值构造器。因此，<code>Shape(..)</code>相当于<code>Shape (Circle, Rectangle)</code>。</p>
<p>如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将<code>Shape(..)</code>替换为<code>Shape</code>，这样就只导出了Shape类型，而不导出其值构造器。</p>
<h4 id="Record-Syntax"><a href="#Record-Syntax" class="headerlink" title="Record Syntax"></a>Record Syntax</h4><p>如果想要方便地取出类型实例中的参数，可以使用Record语法，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   , <span class="title">ycoord</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                   &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>
<p>在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> point = <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; xcoord point</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="title">ghci</span>&gt; ycoord point</span><br><span class="line"><span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>同时也可以通过下面方法来创建这个point：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">point</span> = <span class="type">Point</span> &#123;ycoord=<span class="number">2.0</span>, xcoord=<span class="number">1.0</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Type-parameters"><a href="#Type-parameters" class="headerlink" title="Type parameters"></a>Type parameters</h4><p>值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义：</p>
<p style="text-align: center;">data Maybe a = Nothing | Just a</p>

<p>它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。<br>他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="type">Nothing</span> :: <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> <span class="number">1</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Just</span> &#x27;a&#x27; :: <span class="type">Maybe</span> <span class="type">Char</span></span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;abc&quot;</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]</span><br></pre></td></tr></table></figure>

<p>可以用这种方法改写Point：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> x y = <span class="type">Point</span> &#123; <span class="title">xcoord</span> :: <span class="title">x</span></span></span><br><span class="line"><span class="class">                       , <span class="title">ycoord</span> :: <span class="title">y</span></span></span><br><span class="line"><span class="class">                       &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure>

<p>但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。</p>
<p>而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> (<span class="type">Ord</span> <span class="title">k</span>) =&gt; <span class="type">Map</span> k v = ... </span></span><br><span class="line"><span class="title">toList</span> :: (<span class="type">Ord</span> k) =&gt; <span class="type">Map</span> k a -&gt; [(k, a)]</span><br></pre></td></tr></table></figure>

<h4 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h4><p>Either是一个类型构造器，它有两个值构造器，定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Read</span>, <span class="type">Show</span>)  </span></span><br></pre></td></tr></table></figure>
<p>如果使用了Left，那它的a的类型就是具体的；如果使用了Right，那它的b的类型就是具体的：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Right</span> <span class="number">20</span>  </span><br><span class="line"><span class="type">Right</span> <span class="number">20</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Left</span> <span class="string">&quot;w00t&quot;</span>  </span><br><span class="line"><span class="type">Left</span> <span class="string">&quot;w00t&quot;</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Right</span> &#x27;a&#x27;  </span><br><span class="line"><span class="type">Right</span> &#x27;a&#x27; :: <span class="type">Either</span> a <span class="type">Char</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">Left</span> <span class="type">True</span>  </span><br><span class="line"><span class="type">Left</span> <span class="type">True</span> :: <span class="type">Either</span> <span class="type">Bool</span> b  </span><br></pre></td></tr></table></figure>
<p>Either可以看作Maybe的补充，比如Maybe在使用时，出现异常可以返回Nothing，但只是一个Nothing，不包含任何信息；但Either包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Nothing</span></span><br><span class="line"><span class="title">safeDiv</span> x y = <span class="type">Just</span> (x `div` y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>而使用Either：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Either</span> <span class="type">String</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Left</span> <span class="string">&quot;Divided by zero&quot;</span></span><br><span class="line"><span class="title">safeDiv</span> x y = <span class="type">Right</span> (x `div` y)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="type">Right</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; safeDiv <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="type">Left</span> <span class="string">&quot;Divided by zero&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="Derived-instances"><a href="#Derived-instances" class="headerlink" title="Derived instances"></a>Derived instances</h4><p>想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span>   </span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)  </span><br></pre></td></tr></table></figure>
<p>这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右）</p>
<h4 id="Type-synonyms"><a href="#Type-synonyms" class="headerlink" title="Type synonyms"></a>Type synonyms</h4><p>为了阅读方便，书写简便，可以使用<code>type</code>关键字为已有类型创建别名（synonyms）。比如String的定义：</p>
<p style="text-align: center;">type String = [Char]</p>

<p>在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。<br>同时，类型别名也可以接收类型参数</p>
<h4 id="newtype-keyword"><a href="#newtype-keyword" class="headerlink" title="newtype keyword"></a>newtype keyword</h4><p>除了<code>data</code>、<code>type</code>关键字之外，还可以用<code>newtype</code>关键字来定义一个新的类型，比如<code>Control.Applicative</code>模块中的ZipList：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">ZipList</span> a = &#123; <span class="title">getZipList</span> :: [<span class="title">a</span>] &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不同于type，它不是别名，可以使用record语法来直接定义取出值的函数</li>
<li>不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰</li>
</ul>
<h4 id="Recursive-data-structures"><a href="#Recursive-data-structures" class="headerlink" title="Recursive data structures"></a>Recursive data structures</h4><p>一个类型也可以递归定义，比如一颗二叉树：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">EmptyTree</span> | <span class="type">Node</span> a (<span class="type">Tree</span> <span class="title">a</span>) (<span class="type">Tree</span> <span class="title">a</span>) <span class="keyword">deriving</span> (<span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Eq</span>)  </span></span><br></pre></td></tr></table></figure>

<h3 id="定义新Typeclass"><a href="#定义新Typeclass" class="headerlink" title="定义新Typeclass"></a>定义新Typeclass</h3><p>定义一个新的Typeclass需要使用class关键字，例如定义Eq类型类：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Eq</span> a <span class="keyword">where</span></span>  </span><br><span class="line">    (==) :: a -&gt; a -&gt; <span class="type">Bool</span>  </span><br><span class="line">    (/=) :: a -&gt; a -&gt; <span class="type">Bool</span>  </span><br><span class="line">    x == y = not (x /= y)  </span><br><span class="line">    x /= y = not (x == y)  </span><br></pre></td></tr></table></figure>
<p>其中<code>a</code>是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。</p>
<p>包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们（<code>(==) | (/=)</code>）成为这个类型类的最小完整定义（minimal complete definition）</p>
<p>查看一个类型类的成员需要实现的函数可以在GHCi中使用<code>:info</code>：</p>
<p style="text-align: center;">ghci> :info Eq</p>

<h4 id="手动创建实例"><a href="#手动创建实例" class="headerlink" title="手动创建实例"></a>手动创建实例</h4><p>使一个类型成为一个类型类的实例可以直接使用<code>deriving</code>来自动完成，也可以通过使用instance关键字来手动完成。比如使Point成为Show的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Show</span> <span class="type">Point</span> <span class="keyword">where</span></span></span><br><span class="line">    show (<span class="type">Point</span> x y) = <span class="string">&quot;(&quot;</span> ++ show x ++ <span class="string">&quot;, &quot;</span> ++ show y ++ <span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- in ghci</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Point</span> <span class="number">1.0</span> <span class="number">2.0</span></span><br><span class="line">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>
<p>这样就可以自定义显示的内容，否则使用deriving的话只会直接将其转化为字符串。</p>
<p>同时也要注意类型和类型构造器的区别，传入给instance的第二个参数应该为类型而不是类型构造器，比如Maybe：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> <span class="type">Maybe</span> <span class="keyword">where</span></span>  </span><br><span class="line">    ...    </span><br><span class="line"><span class="comment">-- 错误用法，因为Maybe是类型构造器而不是类型</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    ...</span><br><span class="line"><span class="comment">-- 错误用法，因为m不一定是Eq的成员</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Eq</span> <span class="title">m</span>) =&gt; <span class="type">Eq</span> (<span class="type">Maybe</span> <span class="title">m</span>) <span class="keyword">where</span></span>  </span><br><span class="line">    <span class="type">Just</span> x == <span class="type">Just</span> y = x == y  </span><br><span class="line">    <span class="type">Nothing</span> == <span class="type">Nothing</span> = <span class="type">True</span>  </span><br><span class="line">    _ == _ = <span class="type">False</span>  </span><br></pre></td></tr></table></figure>

<h4 id="Functor-Typeclass"><a href="#Functor-Typeclass" class="headerlink" title="Functor Typeclass"></a>Functor Typeclass</h4><p>Functor也是一种类型类，它只规定了一个函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>其中<code>f</code>是一个类型构造器，而不是一个具体类型</p>
<h3 id="Kinds"><a href="#Kinds" class="headerlink" title="Kinds"></a>Kinds</h3><p>一个值的类型叫做类型（Type），而一个类型的类型叫做Kind。可以通过GHCi中<code>:k</code>来查看Kind：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Int</span></span><br><span class="line"><span class="type">Int</span> :: *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Maybe</span></span><br><span class="line"><span class="type">Maybe</span> :: * -&gt; *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="type">Maybe</span> <span class="type">Int</span> :: *</span><br><span class="line"><span class="title">ghci</span>&gt; :k <span class="type">Either</span></span><br><span class="line"><span class="type">Either</span> :: * -&gt; * -&gt; *</span><br></pre></td></tr></table></figure>
<p>其中的星号<code>*</code>代表了一个具体类型（concrete type）。Int本身就是一个具体类型，所以Int的Kind是*。而Maybe是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以Maybe的Kind是* -&gt; *。如果给Maybe传入了一个Int，那么得到的Maybe Int就是一个具体的类型，它的Kind就是*。Either也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以Either的Kind是* -&gt; * -&gt; *。</p>
<h2 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h2><h3 id="运行Haskell程序"><a href="#运行Haskell程序" class="headerlink" title="运行Haskell程序"></a>运行Haskell程序</h3><p>不在GHCi中运行一个Haskell程序有两种方式：</p>
<ol>
<li>编译运行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ghc --make code</span><br><span class="line">$ ./code</span><br></pre></td></tr></table></figure></li>
<li>通过<code>runhaskell</code>命令直接运行： <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ runhaskell code.hs</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="输出文本"><a href="#输出文本" class="headerlink" title="输出文本"></a>输出文本</h3><p>在一个Haskell程序中输出文字需要定义一个main函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中putStrLn的类型是：</p>
<p style="text-align: center;">putStrLn :: String -> IO ()</p>

<p>putStrLn接收一个String类型，并返回一个结果为()类型的IO动作（I/O action）。所以main函数的类型为IO ()。（IO的Kind是* -&gt; *）</p>
<p>除此之外，还有其他默认提供的输出文本的函数：</p>
<ul>
<li><code>putStr</code>：输出文本，结尾不换行</li>
<li><code>putChar</code>：输出单个字符，结尾不换行。接收的参数为单个Char，不是String（用单引号不是双引号）</li>
<li><code>print</code>：可以接收任何Show的成员，先用show转化为字符串然后输出。等同于putStrLn . show</li>
</ul>
<h4 id="do-block"><a href="#do-block" class="headerlink" title="do block"></a>do block</h4><p>在main函数中使用多个putStrLn需要使用do语句：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    putStrLn <span class="string">&quot;Line1&quot;</span></span><br><span class="line">    putStrLn <span class="string">&quot;Line2&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中最后一行一定要返回IO ()类型的值</p>
<h3 id="输入文本"><a href="#输入文本" class="headerlink" title="输入文本"></a>输入文本</h3><p>输入文字需要在do块中使用getLine：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    line &lt;- getLine</span><br><span class="line">    putStrLn line</span><br></pre></td></tr></table></figure>
<p>getLine的类型是：</p>
<p style="text-align: center;">getLine :: IO String</p>

<p>而&lt;-操作符将getLine中的String提取了出来给到了line，使line变成了String类型的一个字符串。</p>
<p>而且使用输入的字符串必须要经过一次&lt;-，不能直接使用getLine作为字符串，因为getLine不是String类型，而是IO String类型。</p>
<p>除此之外，还可以使用getChar来获取单个字符，但仍然需要使用&lt;-操作符来提取Char</p>
<h3 id="其他IO相关函数用法"><a href="#其他IO相关函数用法" class="headerlink" title="其他IO相关函数用法"></a>其他IO相关函数用法</h3><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4><p>Haskell中的return和其他命令式语言中的return完全不同，它不会使函数直接结束并返回一个值。</p>
<p>main函数必须定义为类型为IO ()的函数，所以在main函数中使用if语句，如果不输出的话也不可以直接放下什么都不干，因为这时候main函数的类型不是IO ()。所以这时需要使用return ()来为main函数指定为IO ()类型，例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    line &lt;- getLine</span><br><span class="line">    <span class="keyword">if</span> null line</span><br><span class="line">        <span class="keyword">then</span> return () <span class="comment">-- &lt;-这里</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">do</span></span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>使用&lt;-操作符也可以直接将return语句中的内容提取出来，比如a &lt;- return ‘A’，执行后a就是’A’。</p>
<h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><p>when包含在<code>Control.Monad</code>模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会return ()。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad   </span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    when (c /= &#x27; &#x27;) $ <span class="keyword">do</span>  </span><br><span class="line">        putChar c  </span><br><span class="line">        main  </span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span>     </span><br><span class="line">    c &lt;- getChar  </span><br><span class="line">    <span class="keyword">if</span> c /= &#x27; &#x27;  </span><br><span class="line">        <span class="keyword">then</span> <span class="keyword">do</span>  </span><br><span class="line">            putChar c  </span><br><span class="line">            main  </span><br><span class="line">        <span class="keyword">else</span> return () </span><br></pre></td></tr></table></figure>

<h4 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h4><p>sequence在IO中使用时可以达成[IO a] -&gt; IO [a]的效果，所以可以用作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">[a, b, c] &lt;- sequence [getLine, getLine, getLine]</span><br></pre></td></tr></table></figure>

<h4 id="mapM-amp-mapM"><a href="#mapM-amp-mapM" class="headerlink" title="mapM &amp; mapM_"></a>mapM &amp; mapM_</h4><p>在IO相关的地方使用map，可以使用mapM和mapM_，其中mapM有返回值而mapM_直接扔掉了返回值：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mapM print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line">[(),(),()]  </span><br><span class="line"><span class="title">ghci</span>&gt; mapM_ print [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br></pre></td></tr></table></figure>

<h4 id="forever"><a href="#forever" class="headerlink" title="forever"></a>forever</h4><p>forever函数包含在<code>Control.Monad</code>模块中。在main函数开头加上forever函数可以使后面的do块一直重复执行直到程序被迫终止，如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = forever $ <span class="keyword">do</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<h4 id="forM"><a href="#forM" class="headerlink" title="forM"></a>forM</h4><p>forM函数包含在<code>Control.Monad</code>模块中，它的功能和mapM类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回IO a类型。比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Monad</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span> </span><br><span class="line">    colors &lt;- forM [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] (\a -&gt; <span class="keyword">do</span></span><br><span class="line">        putStrLn $ <span class="string">&quot;Which color do you associate with the number &quot;</span> ++ show a ++ <span class="string">&quot;?&quot;</span>  </span><br><span class="line">        color &lt;- getLine  </span><br><span class="line">        return color)</span><br><span class="line">    putStrLn <span class="string">&quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;</span>  </span><br><span class="line">    mapM putStrLn colors</span><br></pre></td></tr></table></figure>

<h4 id="getContents"><a href="#getContents" class="headerlink" title="getContents"></a>getContents</h4><p>getLine获取一整行，而getContents从标准输入中获取全部内容直到遇到EOF，并且它是lazy的，在执行了foo &lt;- getContents后，它并不会读取标准输入并且赋值到foo，而是等到需要使用foo的时候再从标准输入读取。</p>
<p>getContents在使用管道传入文字时很常用，可以代替forever+getLine使用，比如一个Haskell程序文件code.hs：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Data.Char  </span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span>  </span><br><span class="line">    contents &lt;- getContents  </span><br><span class="line">    putStr (map toUpper contents)  </span><br></pre></td></tr></table></figure>
<p>使用ghc –make code编译后，通过管道传入文字：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat text.txt | ./code</span><br></pre></td></tr></table></figure>
<p>会将text.txt中的所有字母转为大写并输出</p>
<h4 id="interact"><a href="#interact" class="headerlink" title="interact"></a>interact</h4><p>上述功能还可以转化为一个String -&gt; String的函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">upperStrings</span> = unlines . map (map toUpper) . lines</span><br></pre></td></tr></table></figure>
<p>而在main中使用这个函数就需要：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    contents &lt;- getContents</span><br><span class="line">    putStr (upperStrings contents)</span><br></pre></td></tr></table></figure>
<p>但是String -&gt; String类型的函数在输入输出中的使用太常见了，所以可以使用interact函数来简化。interact的类型是：</p>
<p style="text-align: center;">interact :: (String -> String) -> IO ()</p>

<p>可以看出它接收一个String -&gt; String的函数，并返回一个IO ()类型，所以可以直接用在main上。</p>
<p>于是整个转换为大写的程序就可以简化为：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">main</span> = interact $ unlines . map (map toUpper) . lines</span><br></pre></td></tr></table></figure>

<h3 id="文件和流"><a href="#文件和流" class="headerlink" title="文件和流"></a>文件和流</h3><p>以下与文件和流相关的函数都包含在<code>System.IO</code>模块中</p>
<h4 id="openFile"><a href="#openFile" class="headerlink" title="openFile"></a>openFile</h4><p>openFile函数可以用来打开一个文件，它的类型是：</p>
<p style="text-align: center;">openFile :: FilePath -> IOMode -> IO Handle</p>

<p>其中<code>FilePath</code>是String的type synonyms，用一个字符串来表示需要打开的文件的路径</p>
<p><code>IOMode</code>的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">IOMode</span> = <span class="type">ReadMode</span> | <span class="type">WriteMode</span> | <span class="type">AppendMode</span> | <span class="type">ReadWriteMode</span></span></span><br></pre></td></tr></table></figure>
<p>所以它一共只有四个值，用来表示进行IO操作的模式</p>
<p>openFile返回一个IO Handle类型的值，将其用&lt;-操作符提取后会出现一个Handle的值。但不能从Handle中直接使用文字，还需要使用一系列函数：</p>
<ul>
<li><code>hGetContents</code> :: Handle -&gt; IO String ，从Handle中读取全部内容，返回一个IO String</li>
<li><code>hGetChar</code> :: Handle -&gt; IO Char ，从Handle中读取一个字符</li>
<li><code>hGetLine</code> :: Handle -&gt; IO String ，从Handle中读取一行，返回一个IO String</li>
<li><code>hPutStr</code> :: Handle -&gt; String -&gt; IO () ，向Handle中输出字符串</li>
<li><code>hPutStrLn</code> :: Handle -&gt; String -&gt; IO () ，同上</li>
</ul>
<p>在使用openFile进行文件操作后，需要使用hClose手动关闭Handle。hClose :: Handle -&gt; IO ()，接收一个Handle并返回IO ()，可以直接放在main函数末尾</p>
<p>所以使用openFile读取一个文件中的全部内容并输出的全部代码是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    handle &lt;- openFile <span class="string">&quot;text.txt&quot;</span> <span class="type">ReadMode</span></span><br><span class="line">    contents &lt;- hGetContents handle</span><br><span class="line">    putStrLn contents</span><br><span class="line">    hClose handle</span><br></pre></td></tr></table></figure>

<h4 id="withFile"><a href="#withFile" class="headerlink" title="withFile"></a>withFile</h4><p>withFile类似Python中的with open，它在读取文件使用之后不需要手动close文件。它的类型是：</p>
<p style="text-align: center;">withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a</p>

<p>可以看出，它接收三个参数：</p>
<ul>
<li><code>FilePath</code>：一个表示文件路径的String</li>
<li><code>IOMode</code>：打开文件的模式</li>
<li><code>(Handle -&gt; IO a)</code>：一个函数，表示对读取文件后的Handle索要进行的操作，需要返回一个I/O action；而这个返回值也将作为withFile的返回值</li>
</ul>
<p>现在使用withFile来改写上述代码：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = withFile <span class="string">&quot;text.txt&quot;</span> <span class="type">ReadMode</span> (\handle -&gt; <span class="keyword">do</span></span><br><span class="line">    contents &lt;- hGetContents handle</span><br><span class="line">    putStrLn contents)</span><br></pre></td></tr></table></figure>

<p>withFile的功能相当于以下函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">withFile&#x27;</span> :: <span class="type">FilePath</span> -&gt; <span class="type">IOMode</span> -&gt; (<span class="type">Handle</span> -&gt; <span class="type">IO</span> a) -&gt; <span class="type">IO</span> a  </span><br><span class="line"><span class="title">withFile&#x27;</span> path mode f = <span class="keyword">do</span>  </span><br><span class="line">    handle &lt;- openFile path mode   </span><br><span class="line">    result &lt;- f handle  </span><br><span class="line">    hClose handle  </span><br><span class="line">    return result  </span><br></pre></td></tr></table></figure>

<h4 id="readFile"><a href="#readFile" class="headerlink" title="readFile"></a>readFile</h4><p>readFile可以更加简化读取文件内容的操作，它的类型：</p>
<p style="text-align: center;">readFile :: FilePath -> IO String</p>

<p>它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的I/O action：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    contents &lt;- readFile <span class="string">&quot;text.txt&quot;</span></span><br><span class="line">    putStrLn contents</span><br></pre></td></tr></table></figure>

<h4 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h4><p>writeFile简化了写入文件的操作，它的类型：</p>
<p style="text-align: center;">writeFile :: FilePath -> String -> IO ()</p>

<p>传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个IO ()</p>
<h4 id="appendFile"><a href="#appendFile" class="headerlink" title="appendFile"></a>appendFile</h4><p>appendFile类似writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾</p>
<h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><p>文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。</p>
<p>也可以通过<code>hSetBuffering</code>函数来手动设置缓冲区大小，这个函数的类型：</p>
<p style="text-align: center;">hSetBuffering :: Handle -> BufferMode -> IO ()</p>

<p>它接收一个handle，和一个BufferMode，并返回IO ()。其中BufferMode有以下几种：</p>
<ul>
<li><code>NoBuffering</code>：没有缓冲区，一次读入一个字符</li>
<li><code>LineBuffering</code>：缓冲区大小是一行，即每次读入一行内容</li>
<li><code>BlockBuffering (Maybe Int)</code>：缓冲区大小是一块，块的大小由Maybe Int指定：<ul>
<li><code>BlockBuffering (Nothing)</code>：使用系统默认的块大小</li>
<li><code>BlockBuffering (Just 2048)</code>：一块的大小是2048字节，即每次读入2048bytes的内容</li>
</ul>
</li>
</ul>
<p>缓冲区的刷新是自动的，也可以通过<code>hFlush</code>来手动刷新</p>
<p style="text-align: center;">hFlush :: Handle -> IO ()</p>

<p>传入一个handle，返回IO ()，即刷新对应handle的缓冲区</p>
<h4 id="openTempFile"><a href="#openTempFile" class="headerlink" title="openTempFile"></a>openTempFile</h4><p>openTempFile可以新建一个临时文件：</p>
<p style="text-align: center;">openTempFile :: FilePath -> String -> IO (FilePath, Handle)</p>

<p><code>FilePath</code>指临时文件要创建的位置路径，<code>String</code>指临时文件名字的前缀，返回一个I/O action，其内容第一个<code>FilePath</code>是创建得到的临时文件的路径，<code>Handle</code>是临时文件的handle</p>
<p>例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.IO</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    (tempFile, tempHandle) &lt;- openTempFile <span class="string">&quot;.&quot;</span> <span class="string">&quot;temp&quot;</span></span><br><span class="line">    ...</span><br><span class="line">    hClose tempHandle</span><br></pre></td></tr></table></figure>
<p><code>&quot;.&quot;</code>指临时文件要在当前目录创建，<code>&quot;temp&quot;</code>指临时文件名字以temp开头。最终得到的tempFile就是./temp…….，temp后为随机数字，如<code>./temp43620-0</code></p>
<h3 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h3><p>相关函数都包含在<code>System.Directory</code>模块中，全部内容见<a href="https://hackage.haskell.org/package/directory-1.3.6.2/docs/System-Directory.html">System.Directory</a></p>
<h4 id="getCurrentDirectory"><a href="#getCurrentDirectory" class="headerlink" title="getCurrentDirectory"></a>getCurrentDirectory</h4><p style="text-align: center;">getCurrentDirectory :: IO FilePath</p>

<p>直接返回一个I/O action，其内容是一个字符串表示当前路径的绝对路径</p>
<h4 id="removeFile"><a href="#removeFile" class="headerlink" title="removeFile"></a>removeFile</h4><p style="text-align: center;">removeFile :: FilePath -> IO ()</p>

<p>输入一个文件路径，并删除掉它</p>
<h4 id="renameFile"><a href="#renameFile" class="headerlink" title="renameFile"></a>renameFile</h4><p style="text-align: center;">renameFile :: FilePath -> FilePath -> IO ()</p>

<p>输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名</p>
<h4 id="doesFileExist"><a href="#doesFileExist" class="headerlink" title="doesFileExist"></a>doesFileExist</h4><p style="text-align: center;">doesFileExist :: FilePath -> IO Bool</p>

<p>检查文件是否存在，返回一个包含布尔值的I/O action</p>
<h3 id="Command-line-arguments"><a href="#Command-line-arguments" class="headerlink" title="Command line arguments"></a>Command line arguments</h3><p><code>System.Environment</code>模块中提供了两个函数可以用来处理传入命令行的参数</p>
<h4 id="getArgs"><a href="#getArgs" class="headerlink" title="getArgs"></a>getArgs</h4><p style="text-align: center;">getArgs :: IO [String]</p>

<p>不需要输入参数，直接返回一个I/O action，内容为传入命令行的参数（一个由String组成的列表）。相当于C语言中的argv[1:]</p>
<h4 id="getProgName"><a href="#getProgName" class="headerlink" title="getProgName"></a>getProgName</h4><p style="text-align: center;">getProgName :: IO String</p>

<p>返回I/O action，内容为程序的名字，相当于C语言中的argv[0]</p>
<h3 id="Randomness"><a href="#Randomness" class="headerlink" title="Randomness"></a>Randomness</h3><p>和随机数有关的函数都包含在<code>System.Random</code>模块中。GHCi启动时可能不会包含System.Random的配置，导致无法找到模块。需要通过stack打开:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">stack ghci --package random</span><br></pre></td></tr></table></figure>

<p>Haskell要求同样的程序需要运行出同样的结果，除了用到了I/O action，所有会造成不同结果的函数都要交给I/O action来完成</p>
<p>那要使随机数脱离IO存在，就要用到随机生成器（random generator）</p>
<p><code>System.Random</code>模块提供了几个生成随机数的函数：</p>
<h4 id="random"><a href="#random" class="headerlink" title="random"></a>random</h4><p style="text-align: center;">random :: (Random a, RandomGen g) => g -> (a, g)</p>

<p>其中又有两个新的typeclass，Random表示可以取随机，RandomGen表示随机数生成器。random函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器</p>
<p>获取随机数生成器可以使用<code>mkStdGen</code>函数：</p>
<p style="text-align: center;">mkStdGen :: Int -> StdGen</p>

<p>其中<code>StdGen</code>是一个RandomGen的实例</p>
<p>运用random生成随机数需要指定类型，不然程序无法确定<code>a</code>是什么类型。例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Int</span>, <span class="type">StdGen</span>)</span><br><span class="line">(<span class="number">9216477508314497915</span>,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Char</span>, <span class="type">StdGen</span>)</span><br><span class="line">(&#x27;\<span class="number">537310</span>&#x27;,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br><span class="line"><span class="title">ghci</span>&gt; random (mkStdGen <span class="number">100</span>) :: (<span class="type">Bool</span>, <span class="type">StdGen</span>)</span><br><span class="line">(<span class="type">True</span>,<span class="type">StdGen</span> &#123;unStdGen = <span class="type">SMGen</span> <span class="number">712633246999323047</span> <span class="number">2532601429470541125</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">threeCoins</span> :: <span class="type">StdGen</span> -&gt; (<span class="type">Bool</span>, <span class="type">Bool</span>, <span class="type">Bool</span>)  </span><br><span class="line"><span class="title">threeCoins</span> gen =   </span><br><span class="line">    <span class="keyword">let</span> (firstCoin, newGen) = random gen  </span><br><span class="line">        (secondCoin, newGen&#x27;) = random newGen  </span><br><span class="line">        (thirdCoin, newGen&#x27;&#x27;) = random newGen&#x27;  </span><br><span class="line">    <span class="keyword">in</span>  (firstCoin, secondCoin, thirdCoin) </span><br></pre></td></tr></table></figure>

<h4 id="randoms"><a href="#randoms" class="headerlink" title="randoms"></a>randoms</h4><p style="text-align: center;">randoms :: (Random a, RandomGen g) => g -> [a]</p>

<p>randoms接收一个RandomGen，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器</p>
<h4 id="randomR"><a href="#randomR" class="headerlink" title="randomR"></a>randomR</h4><p style="text-align: center;">randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)</p>

<p>可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围(闭区间)</p>
<h4 id="randomRs"><a href="#randomRs" class="headerlink" title="randomRs"></a>randomRs</h4><p style="text-align: center;">randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]</p>

<p>同上两个，生成有范围的无穷随机数列表</p>
<h4 id="getStdGen"><a href="#getStdGen" class="headerlink" title="getStdGen"></a>getStdGen</h4><p>如果想要让程序每次运行得到不同的随机结果，需要使用<code>getStdGen</code>来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个I/O action，而不是一个直接的StdGen</p>
<p style="text-align: center;">getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen</p>

<p>即可以看成getStdGen :: IO StdGen，需要使用&lt;-操作符将StdGen提取出来</p>
<p>但是在同一个程序中，getStdGen的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数newStdGen</p>
<h4 id="newStdGen"><a href="#newStdGen" class="headerlink" title="newStdGen"></a>newStdGen</h4><p style="text-align: center;">newStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen</p>

<p>执行newStdGen会进行两个操作：</p>
<ul>
<li>更新全局随机数生成器，下次执行getStdGen会获得不同的结果</li>
<li>返回一个I/O action，包含一个新的StdGen（但是这个生成器和全局生成器也不同）</li>
</ul>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>程序在运行失败时会抛出异常，可以通过<code>Control.Exception</code>模块中的<code>catch</code>函数来捕获异常：</p>
<p style="text-align: center;">catch :: Exception e => IO a -> (e -> IO a) -> IO a</p>

<p>第一个参数是要进行的操作，以IO a为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line"></span><br><span class="line"><span class="title">main</span> = main&#x27; `catch` handler</span><br><span class="line"></span><br><span class="line"><span class="title">main&#x27;</span> :: <span class="type">IO</span> ()</span><br><span class="line"><span class="title">main&#x27;</span> = <span class="keyword">do</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="title">handler</span> :: <span class="type">Exception</span> e =&gt; e -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">handler</span> e =  putStrLn <span class="string">&quot;...&quot;</span></span><br></pre></td></tr></table></figure>

<p>也可以利用守卫（guard）语法和<code>System.IO.Error</code>中的函数来判断IO异常的类型来进行不同操作：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> System.Environment</span><br><span class="line"><span class="keyword">import</span> System.IO.Error</span><br><span class="line"><span class="keyword">import</span> Control.Exception</span><br><span class="line">  </span><br><span class="line"><span class="title">main</span> = toTry `catch` handler</span><br><span class="line">              </span><br><span class="line"><span class="title">toTry</span> :: <span class="type">IO</span> ()  </span><br><span class="line"><span class="title">toTry</span> = <span class="keyword">do</span> (fileName:_) &lt;- getArgs  </span><br><span class="line">           contents &lt;- readFile fileName  </span><br><span class="line">           putStrLn $ <span class="string">&quot;The file has &quot;</span> ++ show (length (lines contents)) ++ <span class="string">&quot; lines!&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="title">handler</span> :: <span class="type">IOError</span> -&gt; <span class="type">IO</span> ()  </span><br><span class="line"><span class="title">handler</span> e  </span><br><span class="line">    | isDoesNotExistError e = putStrLn <span class="string">&quot;The file doesn&#x27;t exist!&quot;</span>  </span><br><span class="line">    | otherwise = ioError e  </span><br></pre></td></tr></table></figure>

<p>具体相关全部函数见文档：<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Error.html">System.IO.Error</a>、<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception-Base.html">Control.Exception</a></p>
<h2 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h2><p>函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用<code>fmap</code> :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子</p>
<p>Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子</p>
<p>函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的<code>f a</code>和<code>f b</code>也是因为<code>f</code>是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中</p>
<p>Functor的定义是:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) :: a -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) = fmap . const</span><br></pre></td></tr></table></figure>
<p>可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>
<p>但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名：</p>
<p style="text-align: center;">const :: a -> b -> a</p>

<p>即接收两个参数，但始终只返回第一个参数</p>
<h3 id="Functor实例"><a href="#Functor实例" class="headerlink" title="Functor实例"></a>Functor实例</h3><h4 id><a href="#" class="headerlink" title="[]"></a>[]</h4><p>列表[]是一个函子，它通过map函数来实现fmap的功能：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">    fmap = map</span><br></pre></td></tr></table></figure>
<p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表</p>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe也具有kind * -&gt; *，它也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="Either-a"><a href="#Either-a" class="headerlink" title="Either a"></a>Either a</h4><p>Either的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Left</span> x) = <span class="type">Left</span> x</span><br><span class="line">    fmap f (<span class="type">Right</span> x) = <span class="type">Right</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Left</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Right</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在）</p>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>IO也是一个函子，使用fmap对IO中内容应用函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f action = <span class="keyword">do</span></span><br><span class="line">        result &lt;- action</span><br><span class="line">        return (f result)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (<span class="string">&quot;input: &quot;</span>++) getLine</span><br><span class="line"><span class="title">test</span></span><br><span class="line"><span class="string">&quot;input: test&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="a"><a href="#a" class="headerlink" title="(,) a"></a>(,) a</h4><p>(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,) a) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (x, y) = (x, f y)</span><br></pre></td></tr></table></figure>
<p>只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,) a b) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c) = (a, b, f c)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,,) a b c) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c, d) = (a, b, c, f d)</span><br></pre></td></tr></table></figure>

<h4 id="gt-r"><a href="#gt-r" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>-&gt;也是一个类型构造器，它的kind：</p>
<p style="text-align: center;">(->) :: * -> * -> *</p>

<p>一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中<code>r</code>是输入的类型）</p>
<p>规定的fmap的类型签名是：</p>
<p style="text-align: center;">fmap :: (a -> b) -> f a -> f b</p>

<p>其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b)</p>

<p>把其中的(-&gt;)换成中缀可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> (r -> a) -> (r -> b)</p>

<p>传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。<br>不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap f g = (\x -&gt; f (g x))</span><br></pre></td></tr></table></figure>
<p>所以(-&gt;) r的fmap其实就是函数复合(.)：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap = (.)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t fmap (*<span class="number">3</span>) (+<span class="number">100</span>)  </span><br><span class="line"><span class="title">fmap</span> (*<span class="number">3</span>) (+<span class="number">100</span>) :: (<span class="type">Num</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">3</span>) (+<span class="number">100</span>) <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) `fmap` (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) . (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span></span><br></pre></td></tr></table></figure>

<h3 id="Functor-Laws"><a href="#Functor-Laws" class="headerlink" title="Functor Laws"></a>Functor Laws</h3><p>所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律：</p>
<ol>
<li><code>fmap id = id</code>（其中id为函数<code>(\x -&gt; x)</code>）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap id [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; fmap id (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><code>fmap (f . g) = fmap f . fmap g</code>：即函子的fmap支持结合律<br> fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中<code>a</code>为一个函子<br> fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap ((*<span class="number">3</span>) . (+<span class="number">100</span>)) (<span class="type">Just</span> <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">303</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可</p>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h3><p>对于函子和fmap，有两种理解方法</p>
<ol>
<li>函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器</li>
<li>函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作<p style="text-align: center;">fmap :: (a -> b) -> (f a -> f b)</p>
接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数
<p style="text-align: center;">fmap g :: f a -> f b</p>
使普通的函数g可以在计算上下文<code>f</code>中使用，这种转换也被称为提升（lift）</li>
</ol>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;$&gt;"></a>&lt;$&gt;</h4><p><code>&lt;$&gt;</code>函数是<code>fmap</code>的中缀形式（它看着类似<code>$</code>，<code>f $ 3</code>将f应用在单个值3上，而<code>f &lt;$&gt; [1, 2, 3]</code>将f应用在一个函子上，也就是应用在一个函子内部的所有值上）：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">2</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="gt"><a href="#gt" class="headerlink" title="$&gt;"></a>$&gt;</h4><p><code>$&gt;</code>函数包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">($>) :: Functor f => f a -> b -> f b</p> 

<p>Functor定义时要求了<code>&lt;$</code>函数，将函子内部的元素全部替换为指定的某个值，而<code>$&gt;</code>正好将<code>&lt;$</code>函数的两个参数反了过来，相当于<code>flip (&lt;$)</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] $&gt; &#x27;a&#x27;</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p><code>void</code>函数也包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">void :: Functor f => f a -> f ()</p>

<p>void函数把一个函子内部的全部元素都变成空（<code>()</code>），<code>void x</code>相当于<code>() &lt;$ x</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; void [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[(), (), ()]</span><br><span class="line"><span class="title">ghci</span>&gt; void (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> ()</span><br></pre></td></tr></table></figure>

<h2 id="Applicative-Functor"><a href="#Applicative-Functor" class="headerlink" title="Applicative Functor"></a>Applicative Functor</h2><p>应用函子（Applicative Functor）是函子的升级版，它包含在<code>Control.Applicative</code>模块中。</p>
<p>fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">    pure :: a -&gt; f a</span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>应用函子要求实现两个函数：</p>
<ul>
<li><code>pure</code> :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just</li>
<li><code>&lt;*&gt;</code> :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。</li>
</ul>
<h3 id="Applicative-Functor实例"><a href="#Applicative-Functor实例" class="headerlink" title="Applicative Functor实例"></a>Applicative Functor实例</h3><h4 id="Maybe-1"><a href="#Maybe-1" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = <span class="type">Just</span></span><br><span class="line">    <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">    (<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x</li>
<li><code>&lt;*&gt;</code>函数：将装有函数的函子中的函数应用另一个函子中<ul>
<li>第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing</li>
<li>第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可</li>
</ul>
</li>
</ul>
<p>实际应用的例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">3</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12</p>
<p>第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了</p>
<p>而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>&lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (<span class="type">Just</span> (\y z -&gt; <span class="number">3</span> + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> (\z -&gt; <span class="number">3</span> + <span class="number">4</span> + z) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span> = <span class="type">Just</span> (+<span class="number">7</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。</p>
<p>而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是：</p>
<p style="text-align: center;">f <$> x <*> y <*> ...</*></*></$></p>

<h4 id="-1"><a href="#-1" class="headerlink" title="[]"></a>[]</h4><p>列表也是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">    pure x = [x]</span><br><span class="line">    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x]</li>
<li><code>&lt;*&gt;</code>函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表</li>
</ul>
<p>使用例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">3</span>), (*<span class="number">2</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [(+), (*)]  &lt;*&gt;  [<span class="number">1</span>, <span class="number">2</span>]  &lt;*&gt;  [<span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h4 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = return</span><br><span class="line">    a &lt;*&gt; b = <span class="keyword">do</span></span><br><span class="line">        f &lt;- a</span><br><span class="line">        x &lt;- b</span><br><span class="line">        return (f x)</span><br></pre></td></tr></table></figure>
<p>也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine</span><br><span class="line"><span class="type">Line1</span></span><br><span class="line"><span class="type">Line2</span></span><br><span class="line"><span class="string">&quot;Line1Line2&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="gt-r-1"><a href="#gt-r-1" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名：</p>
<p style="text-align: center;"><*> :: f (a -> b) -> f a -> f b</*></p>

<p>其中f为(-&gt;) r，将其代入并替换为中缀：</p>
<p style="text-align: center;"><*> :: (r -> a -> b) -> (r -> a) -> (r -> b)</*></p>

<p>可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b)</p>
<p>那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是：</p>
<p style="text-align: center;">\x -> f x (g x)</p>

<p>于是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    pure x = (\_ -&gt; x)</span><br><span class="line">    f &lt;*&gt; g = \x -&gt; f x (g x)</span><br></pre></td></tr></table></figure>
<p>将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x</p>
<p>应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line"><span class="number">508</span></span><br></pre></td></tr></table></figure>
<p>执行这句时发生了什么？：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) &lt;$&gt; (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) . (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span> = (\a -&gt; (+) ((+<span class="number">3</span>) a)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\a b -&gt; (a + <span class="number">3</span> + b)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + ((*<span class="number">100</span>) x)) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + x * <span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= <span class="number">5</span> + <span class="number">3</span> + <span class="number">5</span> * <span class="number">100</span> = <span class="number">508</span></span><br><span class="line">= (<span class="number">5</span> + <span class="number">3</span>) + (<span class="number">5</span> * <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+)</p>
<p>同样：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">2</span>) &lt;*&gt; (/<span class="number">2</span>) $ <span class="number">5</span>  </span><br><span class="line">[<span class="number">8.0</span>,<span class="number">10.0</span>,<span class="number">2.5</span>]  </span><br></pre></td></tr></table></figure>
<p>先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\x y z -&gt; [x,y,z])得到了最终的结果</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i</span><br><span class="line">= (\x -&gt; f (g x) (h x) (i x))</span><br></pre></td></tr></table></figure>

<h4 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h4><p>普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在<code>Control.Applicative</code>模块中</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">ZipList</span> <span class="keyword">where</span></span></span><br><span class="line">    pure x = <span class="type">ZipList</span> (repeat x)</span><br><span class="line">    <span class="type">ZipList</span> fs &lt;*&gt; <span class="type">ZipList</span> xs = <span class="type">ZipList</span> (zipWith ($) fs xs)</span><br></pre></td></tr></table></figure>
<p>但是ZipList并不是Show的实例，所以不能直接显示出来，要使用<code>getZipList</code>来获取它内部的列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getZipList $ (+) &lt;$&gt; <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &lt;*&gt; <span class="type">ZipList</span> [<span class="number">100</span>,<span class="number">100.</span>.]  </span><br><span class="line">[<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; getZipList $ (,,) &lt;$&gt; <span class="type">ZipList</span> <span class="string">&quot;dog&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;cat&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;rat&quot;</span>  </span><br><span class="line">[(&#x27;d&#x27;,&#x27;c&#x27;,&#x27;r&#x27;),(&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;),(&#x27;g&#x27;,&#x27;t&#x27;,&#x27;t&#x27;)]  </span><br></pre></td></tr></table></figure>

<h3 id="Applicative-Functor-Laws"><a href="#Applicative-Functor-Laws" class="headerlink" title="Applicative Functor Laws"></a>Applicative Functor Laws</h3><p>应用函子一般有四个定律，都是保证pure的正确性的：</p>
<ol>
<li><code>Identity law</code>：pure id &lt;*&gt; v = v</li>
<li><code>Homomorphism</code>：pure f &lt;*&gt; pure x = pure (f x)</li>
<li><code>Interchange</code>：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u</li>
<li><code>Composition</code>：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w</li>
</ol>
<h3 id="Intuition-1"><a href="#Intuition-1" class="headerlink" title="Intuition"></a>Intuition</h3><p>理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：<br>$$<br>[[\ \ g\ x_1\ x_2\ \cdots\ x_n\ \ ]]<br>$$</p>
<p>其中$x_i$的类型是$f\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是：</p>
<p>$$<br>t_1\to t_2\to\cdots\to t_n\to t<br>$$</p>
<p>所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\ x_1$结果的类型是：</p>
<p>$$<br>f\ \ (t_2\to t_3\to\cdots\to t_n\to t)<br>$$</p>
<p>但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\ g\ x_1\ x_2\ \cdots\ x_n\ ]]$，只需要：</p>
<p style="text-align: center;">g <$> x1 <*> x2 <*> ... <*> xn</*></*></*></$></p>

<p>而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算：</p>
<p style="text-align: center;">g <$> x1 <*> pure x2 <*> ... <*> xn</*></*></*></$></p>

<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="liftA-amp-liftA2-amp-liftA3"><a href="#liftA-amp-liftA2-amp-liftA3" class="headerlink" title="liftA &amp; liftA2 &amp; liftA3"></a>liftA &amp; liftA2 &amp; liftA3</h4><p style="text-align: center;">liftA :: Applicative f => (a -> b) -> f a -> f b</p>
<p style="text-align: center;">liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c</p>
<p style="text-align: center;">liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d</p>

<p>不难推测liftA就是fmap，<code>liftA2 f x1 x2</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2</code>，<code>liftA3 f x1 x2 x3</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3</code></p>
<h4 id="lt-amp-gt"><a href="#lt-amp-gt" class="headerlink" title="&lt;* &amp; *&gt;"></a>&lt;* &amp; *&gt;</h4><p>类型类似函子的<code>&lt;$</code>和<code>$&gt;</code>：</p>
<p style="text-align: center;">(&lt;*) :: Applicative f => f a -> f b -> f a</p>
<p style="text-align: center;">(*>) :: Applicative f => f a -> f b -> f b</p>

<p>&lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> &lt;* <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> *&gt; <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;* <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> *&gt; <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt;* [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] *&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [] &lt;* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; [] *&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h4 id="lt-gt-1"><a href="#lt-gt-1" class="headerlink" title="&lt;**&gt;"></a>&lt;**&gt;</h4><p style="text-align: center;">(**) :: Applicative f => f a -> f (a -> b) -> f b</p>

<p>接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;**&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; flip(&lt;*&gt;) [<span class="number">1</span>, <span class="number">2</span>] [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="when-amp-unless"><a href="#when-amp-unless" class="headerlink" title="when &amp; unless"></a>when &amp; unless</h4><p style="text-align: center;">when :: Applicative f => Bool -> f () -> f ()</p>

<p>传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过）</p>
<p>unless则与when相反，测试为True返回pure ()</p>
<h4 id="sequenceA"><a href="#sequenceA" class="headerlink" title="sequenceA"></a>sequenceA</h4><p style="text-align: center;">sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)</p>

<p>应用在列表上时，它的类型相当于：</p>
<p style="text-align: center;">[f a] -> f [a]</p>

<p>所以在列表上它的使用方法：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Just</span> <span class="number">2</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Just</span> [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(+<span class="number">3</span>),(+<span class="number">2</span>),(+<span class="number">1</span>)] <span class="number">3</span>  </span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">6</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>],[]]  </span><br><span class="line">[]  </span><br></pre></td></tr></table></figure>
<p>它在对同一个参数应用不同函数时很有用：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (\f -&gt; f <span class="number">7</span>) [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd]  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd] <span class="number">7</span>  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br></pre></td></tr></table></figure>

<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>单子（Monad）是对Applicative Functor的扩展（但是诞生比Applicative早），Functor的<code>&lt;$&gt;</code>函数实现了将普通函数应用在上下文值上，Applicative的<code>&lt;*&gt;</code>函数将上下文中函数应用在上下文值上。而Monad提供了一个函数<code>&gt;&gt;=</code>（bind），将一个接收普通值返回上下文值的函数应用在上下文值上：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">    (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">    return :: a -&gt; m a</span><br><span class="line">    m &gt;&gt; n = m &gt;&gt;= \_ -&gt; n</span><br><span class="line">    return = pure</span><br></pre></td></tr></table></figure>
<ul>
<li><code>return</code>函数：和<code>pure</code>一样，只是有另一个名字</li>
<li><code>&gt;&gt;</code>函数：提供了默认的实现方法，它的作用和Applicative的*&gt;函数一样</li>
<li><code>&gt;&gt;=</code>函数（bind）：比Applicative升级的函数，第一个参数是一个单子，第二个参数是一个接收值返回单子的函数，将这个函数应用在第一个参数单子中的值上，并返回得到的新单子</li>
</ul>
<h3 id="Monad实例"><a href="#Monad实例" class="headerlink" title="Monad实例"></a>Monad实例</h3><h4 id="Maybe-2"><a href="#Maybe-2" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe是一个单子实例，Applicative已经为它实现了return，因此只需要&gt;&gt;=函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    (<span class="type">Just</span> x) &gt;&gt;= f = f x </span><br><span class="line">    <span class="type">Nothing</span>  &gt;&gt;= _ = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>根据定义就很容易实现Maybe的&gt;&gt;=函数了，而且也很好理解</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; return (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>) &gt;&gt; <span class="type">Nothing</span> &gt;&gt;= \y -&gt; <span class="type">Just</span> (y + <span class="number">1</span>)</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>最后一个例子中出现了&gt;&gt; Nothing，这时Nothing前的部分全都相当于没用，因为&gt;&gt;操作符的左右两边只要有一个出现Nothing，那整体就会是Nothing。这个特性可以用于在中途随时判断失误，只要有一处失误，结果就会是Nothing</p>
<h4 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h4><p>列表也是一个单子：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span></span><br><span class="line">    xs &gt;&gt;= f = concat (map f xs)</span><br></pre></td></tr></table></figure>
<p>将这个函数应用在xs的每个值上，将返回的所有列表平铺成一个列表：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] &gt;&gt;= \x -&gt; [x,-x]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-4</span>,<span class="number">5</span>,<span class="number">-5</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>] &gt;&gt;= \n -&gt; [&#x27;a&#x27;,&#x27;b&#x27;] &gt;&gt;= \ch -&gt; return (n,ch)  </span><br><span class="line">[(<span class="number">1</span>,&#x27;a&#x27;),(<span class="number">1</span>,&#x27;b&#x27;),(<span class="number">2</span>,&#x27;a&#x27;),(<span class="number">2</span>,&#x27;b&#x27;)]  </span><br></pre></td></tr></table></figure>

<h4 id="IO-2"><a href="#IO-2" class="headerlink" title="IO"></a>IO</h4><p>IO也是一个单子，但是实现方法比较深奥（逃</p>
<h4 id="gt-r-2"><a href="#gt-r-2" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>(-&gt;) r也是一个单子，和Functor、Applicative一样，先分析它的&gt;&gt;=类型签名：</p>
<p style="text-align: center;">(>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b</p>
<p style="text-align: center;">(>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b)</p>

<p>也可以看出来，它接收两个函数f :: r -&gt; a、g :: a -&gt; r -&gt; b，然后返回一个新的函数h :: r -&gt; b</p>
<p>那么函数h接收一个类型为r的参数，返回一个类型为b的值。所以先对输入应用f得到类型为a的中间值，然后再将这个值和输入参数一起传入函数g得到结果。所以函数h的定义应该是：</p>
<p style="text-align: center;">\x -> g (f x) x</p>

<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    f &gt;&gt;= g = \x -&gt; g (f x) x</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">3</span>) &gt;&gt;= (+) $ <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; id $ <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="do-notation"><a href="#do-notation" class="headerlink" title="do-notation"></a>do-notation</h3><p>Haskell的do语句为链式的&gt;&gt;=应用提供了类似命令式（imperative style）的语法糖。比如<code>a &gt;&gt;= \x -&gt; b &gt;&gt; c &gt;&gt;= \y -&gt; d</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">a</span> &gt;&gt;= \x -&gt;</span><br><span class="line"><span class="title">b</span> &gt;&gt;</span><br><span class="line"><span class="title">c</span> &gt;&gt;= \y -&gt;</span><br><span class="line"><span class="title">d</span></span><br></pre></td></tr></table></figure>
<p>其中有abcd四个值，可以看出a中内容绑定到了x上，c中内容绑定到了y上。使用do语句来表示这个操作可以写成：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x &lt;- a </span><br><span class="line">   ;      b </span><br><span class="line">   ; y &lt;- c </span><br><span class="line">   ;      d </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中的大括号和分号可以省略不写（挤在一行时不能省略）。do语句也只是一个语法糖，它可以递归地转换成普通的Monad操作语句：</p>
<ul>
<li><code>do e</code>：e</li>
<li><code>do &#123; e; ... &#125;</code>：e &gt;&gt; do { … }</li>
<li><code>do &#123; v &lt;- e; ... &#125;</code>：e &gt;&gt;= \v -&gt; do { … }</li>
<li><code>do &#123; let ...; ... &#125;</code>：let … in do { … }</li>
</ul>
<h4 id="ApplicativeDo"><a href="#ApplicativeDo" class="headerlink" title="ApplicativeDo"></a>ApplicativeDo</h4><p>比如如下一个do语句：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> x &lt;- a </span><br><span class="line">   y &lt;- b </span><br><span class="line">   z &lt;- c </span><br><span class="line">   return (f x y z)</span><br></pre></td></tr></table></figure>
<p>它可以转化成：</p>
<p style="text-align: center;">a >>= \x -> b >>= \y -> c >>= \z -> return (f x y z)</p>

<p>但是经过观察可以发现，整个语句实际上将函数f应用在了三个上下文中的值上，所以仅用Applicative的&lt;$&gt;和&lt;*&gt;完全可以实现：</p>
<p style="text-align: center;">f <$> a <*> b <*> c</*></*></$></p>

<p>而且在运行的时候Applicative的效率会比Monad高，所以Haskell会将do语句尽可能优先转换为Applicative的表示方法然后再计算</p>
<h3 id="Monad-Laws"><a href="#Monad-Laws" class="headerlink" title="Monad Laws"></a>Monad Laws</h3><ol>
<li><code>Left identity</code>： return a &gt;&gt;= k      <code>=</code> k a</li>
<li><code>Right identity</code>：m        &gt;&gt;= return <code>=</code> m</li>
<li><code>Associativity</code>：(m &gt;&gt;= g) &gt;&gt;= h      <code>=</code> m &gt;&gt;= (\x -&gt; g x &gt;&gt;= h)</li>
</ol>
<p>前两个定律很好理解：</p>
<ul>
<li>将a注入上下文之后绑定（bind）给函数k(:: a -&gt; m a)，相当于直接将a直接传入函数k</li>
<li>将已经包含在上下文中的值绑定给return函数，相当于保持不变</li>
</ul>
<p>第三个定律是结合律，把它写成更像结合律的表示方法是：</p>
<p style="text-align: center;">(m >>= (\x -> g x)) >>= h <code>=</code> m >>= (\x -> g x >>= h)</p>

<h4 id="组合运算符（-gt-gt-）形式"><a href="#组合运算符（-gt-gt-）形式" class="headerlink" title="组合运算符（&gt;=&gt;）形式"></a>组合运算符（&gt;=&gt;）形式</h4><p><code>Control.Monad</code>模块中还定义了函数<code>&gt;=&gt;</code>（Kleisli-composition operator）：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infixr</span> <span class="number">1</span> &gt;=&gt;</span><br><span class="line">(&gt;=&gt;) :: <span class="type">Monad</span> m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</span><br><span class="line"><span class="title">f</span> &gt;=&gt; g = \x -&gt; f x &gt;&gt;= g</span><br></pre></td></tr></table></figure>
<p>使用&gt;=&gt;运算符可以将两个用于绑定的函数结合在一起。用它表示的Monad定律更加清晰直观：</p>
<ol>
<li><code>Left identity</code>：return &gt;=&gt; f <code>=</code> f</li>
<li><code>Right identity</code>：f &gt;=&gt; return <code>=</code> f</li>
<li><code>Associativity</code>：(f &gt;=&gt; g) &gt;=&gt; h <code>=</code> f &gt;=&gt; (g &gt;=&gt; h)</li>
</ol>
<h4 id="do-notation形式"><a href="#do-notation形式" class="headerlink" title="do-notation形式"></a>do-notation形式</h4><p>Monad的这三个定律还可以使用do语句来描述：</p>
<ol>
<li><code>Left identity</code>： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x&#x27; &lt;- return x;</span><br><span class="line">     f x&#x27;             =   <span class="keyword">do</span> &#123; f x &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Right identity</code>： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x &lt;- m; </span><br><span class="line">     return x         =   <span class="keyword">do</span> &#123; m &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Associativity</code>： <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">do</span> &#123; y &lt;- <span class="keyword">do</span> &#123; x &lt;- m;       <span class="keyword">do</span> &#123; x &lt;- m;              <span class="keyword">do</span> &#123; x &lt;- m;</span><br><span class="line">               f x                <span class="keyword">do</span> &#123; y &lt;- f x;            y &lt;- f x;</span><br><span class="line">             &#125;           =             g y         =        g y</span><br><span class="line">     g y                             &#125;                    &#125;</span><br><span class="line">   &#125;                            &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Intuition-2"><a href="#Intuition-2" class="headerlink" title="Intuition"></a>Intuition</h3><p>Monad也可以很自然地看成Applicative的升级版，比如Applicative的操作全部是固定的，而Monad的操作可以在中途突然改变</p>
<p>同时Monad也完成了Functor和Applicative无法完成的操作。比如要用fmap和实现&gt;&gt;=函数（即达成操作 m a -&gt; (a -&gt; m b) -&gt; m b），先假设 f :: a -&gt; m b，那么fmap f的类型就会是 m a -&gt; m (m b)，将m a应用在fmap f上会得到结果m (m b)，而不是m b。但是目前只可以使用pure将一个值装入上下文中（a -&gt; m a），而没有一个函数可以从上下文中提取值（m a -&gt; a）。那么就需要定义一个新的函数来实现这个操作的效果（m (m b) -&gt; m b）。因此Monad的另一个等效的定义方法是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad&#x27;</span> m <span class="keyword">where</span></span></span><br><span class="line">    join :: m (m a) -&gt; m a </span><br><span class="line">    </span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b </span><br><span class="line">    x &gt;&gt;= f = join $ fmap f x</span><br></pre></td></tr></table></figure>
<p>但是定义&gt;&gt;=函数会更为直观方便，所以Haskell采用了用&gt;&gt;=函数定义Monad的方法</p>
<p>同时Haskell还提供了join函数的定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a </span><br><span class="line"><span class="title">join</span> x = x &gt;&gt;= id</span><br></pre></td></tr></table></figure>

<h3 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="liftM-amp-ap"><a href="#liftM-amp-ap" class="headerlink" title="liftM &amp; ap"></a>liftM &amp; ap</h4><p style="text-align: center;">liftM :: Monad m => (a -> b) -> m a -> m b</p>
<p style="text-align: center;">ap :: Monad m => m (a -> b) -> m a -> m b</p>

<p>所以liftM其实就是fmap、ap就是&lt;*&gt;，但是老版本的GHC定义Monad并没有Functor、Applicative的约束，所以实现了liftM、ap，并且保留了这个名字</p>
<p>因此一个单子也可以通过<code>pure = return</code>、<code>(&lt;*&gt;) = ap</code>直接成为应用函子的实例</p>
<h4 id="sequence-1"><a href="#sequence-1" class="headerlink" title="sequence"></a>sequence</h4><p style="text-align: center;">sequence :: Monad m => [m a] -> m [a]</p>

<p>sequence的作用显而易见，而且在IO部分也使用到了。但是这个版本是在<code>GHC.Base</code>模块中定义的，还有一个更广泛的使用Traversable的定义在<code>Data.Traversable</code>模块中 </p>
<h4 id="replicateM"><a href="#replicateM" class="headerlink" title="replicateM"></a>replicateM</h4><p style="text-align: center;">replicateM :: Applicative m => Int -> m a -> m [a]</p>

<h4 id="mapM-amp-forM"><a href="#mapM-amp-forM" class="headerlink" title="mapM &amp; forM"></a>mapM &amp; forM</h4><p style="text-align: center;">mapM :: Monad m => (a -> m b) -> [a] -> m [b]</p>
<p style="text-align: center;">forM :: Monad m => [a] -> (a -> m b) -> m [b]</p>

<p>forM的用法在IO部分已经说过，mapM和forM都在<code>Data.Traversable</code>模块中有广泛版本</p>
<p>还有一些其他的函数：filterM、zipWithM、foldM、forever，通过名字就可以看出用法，是将原来仅使用与列表的函数提升至可以适用于所有单子</p>
<p>并且在函数名后加下划线，比如sequence_、mapM_，会忽略返回值（最终结果为<code>m ()</code>）</p>
<h4 id="lt-lt-amp-gt-gt-amp-lt-lt"><a href="#lt-lt-amp-gt-gt-amp-lt-lt" class="headerlink" title="=&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;"></a>=&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;</h4><p>（<code>&gt;=&gt;</code>操作符在上面<a href="#%E7%BB%84%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-gt-gt-%EF%BC%89%E5%BD%A2%E5%BC%8F">Monad Laws</a>部分已经给出了定义）</p>
<ul>
<li>x &gt;&gt;= f <code>=</code> f =&lt;&lt; x </li>
<li>f &gt;=&gt; g <code>=</code> g &lt;=&lt; f </li>
</ul>
<h2 id="MonadFail"><a href="#MonadFail" class="headerlink" title="MonadFail"></a>MonadFail</h2><p>MonadFail定义在<code>Control.Monad.Fail</code>模块中：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadFail</span> m <span class="keyword">where</span></span></span><br><span class="line">    fail :: <span class="type">String</span> -&gt; m a </span><br></pre></td></tr></table></figure>
<p>它只要求在Monad的基础上实现fail函数，接收一个字符串返回一个单子。这会使在do语句中产生错误时直接变为错误值（空值）使最终的返回值为错误值</p>
<h3 id="MonadFail实例"><a href="#MonadFail实例" class="headerlink" title="MonadFail实例"></a>MonadFail实例</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fail _ = <span class="type">Nothing</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> [] <span class="keyword">where</span></span></span><br><span class="line">    fail _ = []</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fail = failIO</span><br></pre></td></tr></table></figure>
<p>Maybe和[]的fail函数都与第一个参数无关，直接返回空值（Nothing、[]）；而IO的fail函数直接使用failIO，实现方法也是深奥（接着逃</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">exampleFail</span> :: <span class="type">Maybe</span> <span class="type">Char</span> </span><br><span class="line"><span class="title">exampleFail</span> = <span class="keyword">do</span></span><br><span class="line">    (x:xs) &lt;- <span class="type">Just</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    return x </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; exampleFail</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>在这个例子的do语句中，在提取Just “”中的值时用了模式匹配，但是因为其内容为空字符串，x:xs匹配会出现错误，这时就会触发fail函数直接返回Nothing</p>
<h3 id="MonadFail-Law"><a href="#MonadFail-Law" class="headerlink" title="MonadFail Law"></a>MonadFail Law</h3><ul>
<li>fail s &gt;&gt;= m <code>=</code> fail s </li>
</ul>
<h2 id="Semigroup"><a href="#Semigroup" class="headerlink" title="Semigroup"></a>Semigroup</h2><p>半群（semigroup）是一个集合$S$，它需要指定一个二元运算符$\oplus$，并且满足</p>
<p>$$<br>a\oplus b \in S\quad a, b\in S<br>$$</p>
<p>以及结合（associative）律：</p>
<p>$$<br>(a\oplus b)\oplus c = a\oplus (b\oplus c)<br>$$</p>
<p>这个二元运算符在Haskell的Semigroup中被定义为<code>&lt;&gt;</code>函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Semigroup</span> a <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) :: a -&gt; a -&gt; a </span><br><span class="line"></span><br><span class="line">    sconcat :: <span class="type">NonEmpty</span> a -&gt; a </span><br><span class="line">    sconcat (a :| <span class="keyword">as</span>) = go a <span class="keyword">as</span> <span class="keyword">where</span> </span><br><span class="line">        go b (c:cs) = b &lt;&gt; go c cs </span><br><span class="line">        go b []     = b</span><br><span class="line">    </span><br><span class="line">    stimes :: <span class="type">Integarl</span> b =&gt; b -&gt; a -&gt; a </span><br><span class="line">    stimes = ...</span><br></pre></td></tr></table></figure>
<p>除此之外还有<code>sconcat</code>和<code>stimes</code>函数，都给出了默认实现。对于列表，&lt;&gt;相当于(++)，stimes相当于concat . replicate：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; sconcat $ fromList [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; stimes <span class="number">3</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Semigroup-Law"><a href="#Semigroup-Law" class="headerlink" title="Semigroup Law"></a>Semigroup Law</h3><ul>
<li>(x &lt;&gt; y) &lt;&gt; z <code>=</code> x &lt;&gt; (y &lt;&gt; z)</li>
</ul>
<h3 id="补：NonEmpty"><a href="#补：NonEmpty" class="headerlink" title="补：NonEmpty"></a>补：NonEmpty</h3><p>NonEmpty表示非空列表，定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">NonEmpty</span> a = a :| [a] <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>)</span></span><br></pre></td></tr></table></figure>
<p>使用一个元素和一个列表用<code>:|</code>连接就可以生成一个NonEmpty类型的列表</p>
<p><code>Data.List.NonEmpty</code>模块中实现了很多普通列表有的函数，需要qualified import后调用，使用fromList、toList函数可以在普通列表和非空列表之间转换</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">import</span> <span class="keyword">qualified</span> Data.List.NonEmpty <span class="keyword">as</span> NE</span><br><span class="line"><span class="title">ghci</span>&gt; arr = <span class="type">NE</span>.fromList [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; arr</span><br><span class="line"><span class="number">1</span> :| [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">NE</span>.head arr </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">NE</span>.tail arr </span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h2><p>幺半群（Monoid）是一个有单位元素$e$的半群，即$e$满足：</p>
<p>$$<br>e\oplus x = x\oplus e = x<br>$$</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Semigroup</span> a =&gt; <span class="type">Monoid</span> a <span class="keyword">where</span></span> </span><br><span class="line">    mempty  :: a </span><br><span class="line">    </span><br><span class="line">    mappend :: a -&gt; a -&gt; a </span><br><span class="line">    mappend = (&lt;&gt;)</span><br><span class="line"></span><br><span class="line">    mconcat :: [a] -&gt; a </span><br><span class="line">    mconcat = foldr mappend mempty </span><br></pre></td></tr></table></figure>
<p>可以看出Monoid要求了三个函数，其中最少只需要<code>mempty</code>，它直接返回一个值，表示单位元素。<code>mappend</code>即Semigroup中的&lt;&gt;运算符，<code>mconcat</code>也提供了默认实现</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="a-1"><a href="#a-1" class="headerlink" title="[a]"></a>[a]</h4><p>因为Monoid的实例是一个具体类型，而不是像Functor等一样等类型构造器，所以[]并不是Monoid的实例，但是具体类型[a]是一个幺半群：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> [a] <span class="keyword">where</span></span> </span><br><span class="line">    (&lt;&gt;) = (++)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> [a] <span class="keyword">where</span></span> </span><br><span class="line">    mempty = [] </span><br><span class="line">    mconcat xss = [x | xs &lt;- xss, x &lt;- xs]</span><br></pre></td></tr></table></figure>
<p>列表的单位元素(mempty)就是空列表[]，运算符就是合并列表(++)，mconcat也用列表推导重新实现提高效率</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mempty :: [<span class="type">Int</span>] </span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] `mappend` [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; mconcat [[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">Ordering</span> <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">LT</span> &lt;&gt; _ = <span class="type">LT</span></span><br><span class="line">    <span class="type">EQ</span> &lt;&gt; y = y</span><br><span class="line">    <span class="type">GT</span> &lt;&gt; _ = <span class="type">GT</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Ordering</span> <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">EQ</span></span><br></pre></td></tr></table></figure>
<p>主要可以用于比较字典序：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mconcat (zipWith compare <span class="string">&quot;abcd&quot;</span> <span class="string">&quot;acbd&quot;</span>)</span><br><span class="line"><span class="type">LT</span></span><br></pre></td></tr></table></figure>

<h4 id="Sum-amp-Product"><a href="#Sum-amp-Product" class="headerlink" title="Sum &amp; Product"></a>Sum &amp; Product</h4><p>对于数字，加法和乘法都满足结合律，所以对于Num，有两种实现Monoid的方式，但是不能为同一类型设置两种实例方式，所以<code>Data.Monoid</code>中提供了两个包装器————Sum和Product：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Sum</span> a = <span class="type">Sum</span> &#123;<span class="title">getSum</span> :: <span class="title">a</span>&#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Product</span> a = <span class="type">Product</span> &#123;<span class="title">getProduct</span> :: <span class="title">a</span>&#125; <span class="keyword">deriving</span> (...)</span></span><br></pre></td></tr></table></figure>
<p>它们使用Sum或Product来包装起一个数字，可以通过getSum或getProduct来获取其中的值</p>
<p>对于加法，二元操作为(+)，单位元素为0；对于乘法，二元操作为(*)，单位元素为1:</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Sum</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Sum</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Sum</span> <span class="number">0</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Product</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Num</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Product</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Product</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Sum</span> <span class="number">5</span> &lt;&gt; <span class="type">Sum</span> <span class="number">6</span> &lt;&gt; <span class="type">Sum</span> <span class="number">10</span></span><br><span class="line"><span class="type">Sum</span> &#123;getSum = <span class="number">21</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; getSum . mconcat . fmap <span class="type">Sum</span> $ [<span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Product</span> <span class="number">5</span> &lt;&gt; <span class="type">Product</span> <span class="number">6</span> &lt;&gt; <span class="type">Product</span> <span class="number">10</span></span><br><span class="line"><span class="type">Product</span> &#123;getProduct = <span class="number">300</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; getProduct . mconcat . fmap <span class="type">Product</span> $ [<span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">300</span></span><br></pre></td></tr></table></figure>

<h4 id="All-amp-Any"><a href="#All-amp-Any" class="headerlink" title="All &amp; Any"></a>All &amp; Any</h4><p>和数字一样，布尔值也有两种实现Monoid的方式，因此<code>Data.Monoid</code>模块中也提供了两个包装器，分别实现了这两种Monoid：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">All</span> = <span class="type">All</span> &#123; <span class="title">getAll</span> :: <span class="type">Bool</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">All</span> <span class="keyword">where</span></span></span><br><span class="line">        (&lt;&gt;) = coerce (&amp;&amp;)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">All</span> <span class="keyword">where</span></span></span><br><span class="line">        mempty = <span class="type">All</span> <span class="type">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Any</span> = <span class="type">Any</span> &#123; <span class="title">getAny</span> :: <span class="type">Bool</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> <span class="type">Any</span> <span class="keyword">where</span></span></span><br><span class="line">        (&lt;&gt;) = coerce (||)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Any</span> <span class="keyword">where</span></span></span><br><span class="line">        mempty = <span class="type">Any</span> <span class="type">False</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getAll (<span class="type">All</span> <span class="type">True</span> &lt;&gt; mempty &lt;&gt; <span class="type">All</span> <span class="type">False</span>)</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="title">ghci</span>&gt; getAll (mconcat (map (\x -&gt; <span class="type">All</span> (even x)) [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]))</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="title">ghci</span>&gt; getAny (<span class="type">Any</span> <span class="type">True</span> &lt;&gt; mempty &lt;&gt; <span class="type">Any</span> <span class="type">False</span>)</span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="title">ghci</span>&gt; getAny (mconcat (map (\x -&gt; <span class="type">Any</span> (even x)) [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]))</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>

<h4 id="Monoid-a-gt-Maybe-a"><a href="#Monoid-a-gt-Maybe-a" class="headerlink" title="Monoid a =&gt; Maybe a"></a>Monoid a =&gt; Maybe a</h4><p>如果a是一个(幺)半群，那么Maybe a也是一个幺半群，单位元就是Nothing：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Nothing</span> &lt;&gt; b       = b</span><br><span class="line">    a       &lt;&gt; <span class="type">Nothing</span> = a</span><br><span class="line">    <span class="type">Just</span> a  &lt;&gt; <span class="type">Just</span> b  = <span class="type">Just</span> (a &lt;&gt; b)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> a =&gt; <span class="type">Monoid</span> (<span class="type">Maybe</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;&gt; <span class="type">Just</span> <span class="string">&quot;andy&quot;</span></span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;andy&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="type">LT</span> &lt;&gt; <span class="type">Nothing</span></span><br><span class="line"><span class="type">Just</span> <span class="type">LT</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (<span class="type">Sum</span> <span class="number">3</span>) &lt;&gt; <span class="type">Just</span> (<span class="type">Sum</span> <span class="number">4</span>) </span><br><span class="line"><span class="type">Just</span> (<span class="type">Sum</span> &#123;getSum = <span class="number">7</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="First-amp-Last"><a href="#First-amp-Last" class="headerlink" title="First &amp; Last"></a>First &amp; Last</h4><p>对于Maybe也有两种实现Monoid的方法，即&lt;&gt;操作每次恒取左边和每次恒取右边（在没有Nothing的情况下），所以<code>Data.Monoid</code>模块中也提供了两个新的包装器：First和Last：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">First</span> a = <span class="type">First</span> &#123; <span class="title">getFirst</span> :: <span class="type">Maybe</span> <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> (<span class="type">First</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">First</span> <span class="type">Nothing</span> &lt;&gt; b = b</span><br><span class="line">    a             &lt;&gt; _ = a</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> (<span class="type">First</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">First</span> <span class="type">Nothing</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Last</span> a = <span class="type">Last</span> &#123; <span class="title">getLast</span> :: <span class="type">Maybe</span> <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Semigroup</span> (<span class="type">Last</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    a &lt;&gt; <span class="type">Last</span> <span class="type">Nothing</span> = a</span><br><span class="line">    _ &lt;&gt; b            = b</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> (<span class="type">Last</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="type">Last</span> <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getFirst (<span class="type">First</span> (<span class="type">Just</span> <span class="string">&quot;hello&quot;</span>) &lt;&gt; <span class="type">First</span> <span class="type">Nothing</span> &lt;&gt; <span class="type">First</span> (<span class="type">Just</span> <span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; getLast (<span class="type">Last</span> (<span class="type">Just</span> <span class="string">&quot;hello&quot;</span>) &lt;&gt; <span class="type">Last</span> <span class="type">Nothing</span> &lt;&gt; <span class="type">Last</span> (<span class="type">Just</span> <span class="string">&quot;world&quot;</span>))</span><br><span class="line"><span class="type">Just</span> <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; getFirst . mconcat . map <span class="type">First</span> $ [<span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">9</span>, <span class="type">Just</span> <span class="number">10</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; getLast . mconcat . map <span class="type">Last</span> $ [<span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">9</span>, <span class="type">Just</span> <span class="number">10</span>]  </span><br><span class="line"><span class="type">Just</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="Min-amp-Max"><a href="#Min-amp-Max" class="headerlink" title="Min &amp; Max"></a>Min &amp; Max</h4><p>对于有界的类型，也有两种实现Monoid的方式，每次二元操作都取最小或最大。<code>Data.Semigroup</code>模块中提供了两个包装其器：Min和Max：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Min</span> a = <span class="type">Min</span> &#123; <span class="title">getMin</span> :: <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Ord</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Min</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Ord</span> <span class="title">a</span>, <span class="type">Bounded</span> <span class="title">a</span>) =&gt; <span class="type">Monoid</span> (<span class="type">Min</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = maxBound</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Max</span> a = <span class="type">Max</span> &#123; <span class="title">getMax</span> :: <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Ord</span> a =&gt; <span class="type">Semigroup</span> (<span class="type">Max</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Ord</span> <span class="title">a</span>, <span class="type">Bounded</span> <span class="title">a</span>) =&gt; <span class="type">Monoid</span> (<span class="type">Max</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    mempty = minBound</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Min</span> <span class="number">3</span> &lt;&gt; <span class="type">Min</span> <span class="number">5</span></span><br><span class="line"><span class="type">Min</span> &#123;getMin = <span class="number">3</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Max</span> <span class="number">3</span> &lt;&gt; <span class="type">Max</span> <span class="number">5</span></span><br><span class="line"><span class="type">Max</span> &#123;getMax = <span class="number">5</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; getMin . mconcat . map <span class="type">Min</span> $ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] :: <span class="type">Int</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="title">ghci</span>&gt; getMax . mconcat . map <span class="type">Max</span> $ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] :: <span class="type">Int</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>当元组内的所有元素都是幺半群时，整个元组也是一个幺半群：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Semigroup</span> <span class="title">a</span>, <span class="type">Semigroup</span> <span class="title">b</span>) =&gt; <span class="type">Semigroup</span> (<span class="title">a</span>, <span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">        (a,b) &lt;&gt; (a&#x27;,b&#x27;) = (a&lt;&gt;a&#x27;,b&lt;&gt;b&#x27;)</span><br><span class="line">        stimes n (a,b) = (stimes n a, stimes n b)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> (<span class="type">Monoid</span> <span class="title">a</span>, <span class="type">Monoid</span> <span class="title">b</span>) =&gt; <span class="type">Monoid</span> (<span class="title">a</span>,<span class="title">b</span>) <span class="keyword">where</span></span></span><br><span class="line">        mempty = (mempty, mempty)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; mconcat $ map (\x -&gt; (<span class="type">Min</span> x, <span class="type">Max</span> x)) [<span class="number">1.</span><span class="number">.10</span>] :: (<span class="type">Min</span> <span class="type">Int</span>, <span class="type">Max</span> <span class="type">Int</span>)</span><br><span class="line">(<span class="type">Min</span> &#123;getMin = <span class="number">1</span>&#125;,<span class="type">Max</span> &#123;getMax = <span class="number">10</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Monoid-Laws"><a href="#Monoid-Laws" class="headerlink" title="Monoid Laws"></a>Monoid Laws</h3><ul>
<li>mempty &lt;&gt; x <code>=</code> x</li>
<li>x &lt;&gt; mempty <code>=</code> x</li>
<li>(x &lt;&gt; y) &lt;&gt; z <code>=</code> x &lt;&gt; (y &lt;&gt; z)</li>
</ul>
<h2 id="Monoidal-classes"><a href="#Monoidal-classes" class="headerlink" title="Monoidal classes"></a>Monoidal classes</h2><p>Applicative、Monad、Arrow都有有幺半群性质的子类型类，分别是Alternative、MonadPlus、ArrowPlus</p>
<h3 id="Alternative"><a href="#Alternative" class="headerlink" title="Alternative"></a>Alternative</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> f =&gt; <span class="type">Alternative</span> f <span class="keyword">where</span></span></span><br><span class="line">    <span class="comment">-- | The identity of &#x27;&lt;|&gt;&#x27;</span></span><br><span class="line">    empty :: f a</span><br><span class="line">    <span class="comment">-- | An associative binary operation</span></span><br><span class="line">    (&lt;|&gt;) :: f a -&gt; f a -&gt; f a</span><br><span class="line"></span><br><span class="line">    some :: f a -&gt; f [a]</span><br><span class="line">    some v = (:) &lt;$&gt; v &lt;*&gt; many v</span><br><span class="line">    many :: f a -&gt; f [a]</span><br><span class="line">    many v = some v &lt;|&gt; pure []</span><br></pre></td></tr></table></figure>
<p>其中empty是幺半群中的单位元素，&lt;|&gt;是幺半群中的二元运算符。some和many是两个函数（<del>意义还不懂</del>）</p>
<h4 id="Alternative实例"><a href="#Alternative实例" class="headerlink" title="Alternative实例"></a>Alternative实例</h4><h5 id="-3"><a href="#-3" class="headerlink" title="[]"></a>[]</h5><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> [] <span class="keyword">where</span></span></span><br><span class="line">    empty = []</span><br><span class="line">    (&lt;|&gt;) = (++)</span><br></pre></td></tr></table></figure>
<p>和Monoid一样，单位元素是空列表，二元运算是列表合并</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &lt;|&gt; empty &lt;|&gt; [<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; some []</span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; many []</span><br><span class="line">[[]]</span><br></pre></td></tr></table></figure>
<h5 id="Maybe-3"><a href="#Maybe-3" class="headerlink" title="Maybe"></a>Maybe</h5><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    empty = <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Nothing</span> &lt;|&gt; r = r</span><br><span class="line">    l       &lt;|&gt; _ = l</span><br></pre></td></tr></table></figure>
<p>Maybe作为Alternative的单位元素是Nothing，二元运算是始终取左边（当左边不为Nothing时）</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;|&gt; <span class="type">Just</span> <span class="number">1</span> &lt;|&gt; <span class="type">Just</span> <span class="number">2</span> </span><br><span class="line"><span class="type">Just</span> <span class="number">1</span> </span><br><span class="line"><span class="title">ghci</span>&gt; some <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span> </span><br><span class="line"><span class="title">ghci</span>&gt; many <span class="type">Nothing</span> </span><br><span class="line"><span class="type">Just</span> []</span><br></pre></td></tr></table></figure>
<h5 id="ZipList-1"><a href="#ZipList-1" class="headerlink" title="ZipList"></a>ZipList</h5><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Alternative</span> <span class="type">ZipList</span> <span class="keyword">where</span></span></span><br><span class="line">   empty = <span class="type">ZipList</span> []</span><br><span class="line">   <span class="type">ZipList</span> xs &lt;|&gt; <span class="type">ZipList</span> ys = <span class="type">ZipList</span> (xs ++ drop (length xs) ys)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">&lt;&gt;getZipList $ <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>] &lt;|&gt; <span class="type">ZipList</span> [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&lt;&gt;getZipList $ <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] &lt;|&gt; <span class="type">ZipList</span> [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Alternative-Laws"><a href="#Alternative-Laws" class="headerlink" title="Alternative Laws"></a>Alternative Laws</h4><ul>
<li><code>Monoid laws</code>:  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">empty</span> &lt;|&gt; x = x </span><br><span class="line"><span class="title">x</span> &lt;|&gt; empty = x </span><br><span class="line">(x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z)</span><br></pre></td></tr></table></figure></li>
<li><code>Left zero law</code>：empty &lt;*&gt; f <code>=</code> empty<br>以上的定律是都满足都，下面的定律只有部分满足：</li>
<li><code>Right zero law</code>：f &lt;*&gt; empty <code>=</code> empty （大部分包括Maybe、[]满足，IO不满足）</li>
<li><code>Left distribution</code>：(a &lt;|&gt; b) &lt;*&gt; c <code>=</code> (a &lt;*&gt; c) &lt;|&gt; (b &lt;*&gt; c) （Maybe、[]满足，IO及大部分parsers不满足）</li>
<li><code>Right distribution</code>：a &lt;*&gt; (b &lt;|&gt; c) <code>=</code> (a &lt;*&gt; b) &lt;|&gt; (a &lt;*&gt; c) （大部分不满足，但Maybe满足）</li>
<li><code>Left catch</code>：(pure a) &lt;|&gt; x = pure a （Maybe、IO、parsers满足，但[]不满足）</li>
</ul>
<h4 id="常用函数-3"><a href="#常用函数-3" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li><code>asum</code> :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a，相当于foldr (&lt;|&gt;) empty：  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; asum [<span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">5</span>, <span class="type">Just</span> <span class="number">3</span>]</span><br><span class="line"><span class="type">Just</span> <span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; asum [[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></li>
<li><code>guard</code> :: (Alternative f) =&gt; Bool -&gt; f ()：  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">guard</span> <span class="type">True</span>  = pure ()</span><br><span class="line"><span class="title">guard</span> <span class="type">False</span> = empty </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="MonadPlus"><a href="#MonadPlus" class="headerlink" title="MonadPlus"></a>MonadPlus</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Alternative</span> <span class="title">m</span>, <span class="type">Monad</span> <span class="title">m</span>) =&gt; <span class="type">MonadPlus</span> m <span class="keyword">where</span></span></span><br><span class="line">   mzero :: m a</span><br><span class="line">   mzero = empty</span><br><span class="line"></span><br><span class="line">   mplus :: m a -&gt; m a -&gt; m a</span><br><span class="line">   mplus = (&lt;|&gt;)</span><br></pre></td></tr></table></figure>

<h4 id="MonadPlus实例"><a href="#MonadPlus实例" class="headerlink" title="MonadPlus实例"></a>MonadPlus实例</h4><p>[]、Maybe都是MonadPlus的实例，mzero和mplus都由Alternative实现</p>
<h4 id="MonadPlus-Laws"><a href="#MonadPlus-Laws" class="headerlink" title="MonadPlus Laws"></a>MonadPlus Laws</h4><ul>
<li><code>Monoid laws</code></li>
<li><code>Left zero</code>：mzero &gt;&gt;= f <code>=</code> mzero</li>
<li><code>Right zero</code>：m &gt;&gt; mzero <code>=</code> mzero </li>
</ul>
<h4 id="常用函数-4"><a href="#常用函数-4" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li><code>msum</code> = asum </li>
<li><code>mfilter</code>：  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">mfilter</span> p ma = <span class="keyword">do</span></span><br><span class="line">    a &lt;- ma</span><br><span class="line">    <span class="keyword">if</span> p a <span class="keyword">then</span> return a <span class="keyword">else</span> mzero</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ArrowPlus"><a href="#ArrowPlus" class="headerlink" title="ArrowPlus"></a>ArrowPlus</h3><p>ArrowZero和ArrowPlus分别为Arrow设置了Monoid中的单位元素和二元运算符，使之成为了一个幺半群：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Arrow</span> arr =&gt; <span class="type">ArrowZero</span> arr <span class="keyword">where</span></span></span><br><span class="line">    zeroArrow :: b `arr` c</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">ArrowZero</span> arr =&gt; <span class="type">ArrowPlus</span> arr <span class="keyword">where</span></span></span><br><span class="line">    (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c)</span><br></pre></td></tr></table></figure>

<h2 id="一些其它typeclasses"><a href="#一些其它typeclasses" class="headerlink" title="一些其它typeclasses"></a>一些其它typeclasses</h2><h3 id="Foldable"><a href="#Foldable" class="headerlink" title="Foldable"></a>Foldable</h3><p>Foldable是表示可以折叠（fold）的类型类，在<code>Data.Foldable</code>中定义，这使得和fold相关的函数可以用在任意Foldable的实例类型上。它的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Foldable</span> t <span class="keyword">where</span></span></span><br><span class="line">    fold     :: <span class="type">Monoid</span> m =&gt; t m -&gt; m</span><br><span class="line">    foldMap  :: <span class="type">Monoid</span> m =&gt; (a -&gt; m) -&gt; t a -&gt; m</span><br><span class="line">    foldMap&#x27; :: <span class="type">Monoid</span> m =&gt; (a -&gt; m) -&gt; t a -&gt; m</span><br><span class="line">    foldr    :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line">    foldr&#x27;   :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line">    foldl    :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line">    foldl&#x27;   :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b</span><br><span class="line">    foldr1   :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a</span><br><span class="line">    foldl1   :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a</span><br><span class="line">    toList   :: t a -&gt; [a]</span><br><span class="line">    null     :: t a -&gt; <span class="type">Bool</span></span><br><span class="line">    length   :: t a -&gt; <span class="type">Int</span></span><br><span class="line">    elem     :: <span class="type">Eq</span> a =&gt; a -&gt; t a -&gt; <span class="type">Bool</span></span><br><span class="line">    maximum  :: <span class="type">Ord</span> a =&gt; t a -&gt; a</span><br><span class="line">    minimum  :: <span class="type">Ord</span> a =&gt; t a -&gt; a</span><br><span class="line">    sum      :: <span class="type">Num</span> a =&gt; t a -&gt; a</span><br><span class="line">    product  :: <span class="type">Num</span> a =&gt; t a -&gt; a</span><br><span class="line">    <span class="meta">&#123;-# MINIMAL foldMap | foldr #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>最少只要实现<code>foldr</code>和<code>foldMap</code>其中之一就可以使一个类型成为Foldable的实例，其它的函数都有由这两个函数提供的默认实现，而且这两个函数之间也有相互实现。因此只要实现foldr或foldMap一个函数就可以使用所有其它Foldable中的函数。foldr函数在前面已经有学过，foldMap的例子是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; foldMap <span class="type">Sum</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="type">Sum</span> &#123;getSum = <span class="number">9</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; foldMap <span class="type">Product</span> [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="type">Product</span> &#123;getProduct = <span class="number">15</span>&#125;</span><br><span class="line"><span class="title">ghci</span>&gt; foldMap (replicate <span class="number">3</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h4 id="Foldable实例"><a href="#Foldable实例" class="headerlink" title="Foldable实例"></a>Foldable实例</h4><p>[]、Maybe、Either a、(,) a都是Foldable的实例，标准容器库中的Map、Set等也都是Foldable的实例。也可以自定义二叉树类型，并使其成为Foldable的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Tree</span> a = <span class="type">Empty</span> | <span class="type">Leaf</span> a | <span class="type">Node</span> (<span class="type">Tree</span> <span class="title">a</span>) a (<span class="type">Tree</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Foldable</span> <span class="type">Tree</span> <span class="keyword">where</span></span> </span><br><span class="line">    foldMap :: <span class="type">Monoid</span> m =&gt; (a -&gt; m) -&gt; <span class="type">Tree</span> a -&gt; m</span><br><span class="line">    foldMap f <span class="type">Empty</span>        = mempty</span><br><span class="line">    foldMap f (<span class="type">Leaf</span> x)     = f x</span><br><span class="line">    foldMap f (<span class="type">Node</span> l k r) = foldMap f l `mappend` f k `mappend` foldMap f r</span><br></pre></td></tr></table></figure>

<h4 id="常用函数-5"><a href="#常用函数-5" class="headerlink" title="常用函数"></a>常用函数</h4><ul>
<li><code>asum</code> :: (Alternative f, Foldable t) =&gt; t (f a) -&gt; f a，用&lt;|&gt;逐个连接所有元素</li>
<li><code>sequenceA_</code> :: (Applicative f, Foldable t) =&gt; t (f a) -&gt; f ()，由于丢弃结果，所以Foldable t就可以满足；因此不同于sequenceA需要Traversable</li>
<li><code>traverse_</code> :: (Applicative f, Foldable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f ()</li>
<li><code>for_</code> :: (Applicative f, Foldable t) =&gt; t a -&gt; (a -&gt; f b) -&gt; f ()</li>
</ul>
<h3 id="Traversable"><a href="#Traversable" class="headerlink" title="Traversable"></a>Traversable</h3><p>Traversable是表示可遍历的类型类，在<code>Data.Traversable</code>模块中定义，它是Foldable的升级版，同时也是一个Functor，它的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">t</span>, <span class="type">Foldable</span> <span class="title">t</span>) =&gt; <span class="type">Traversable</span> t <span class="keyword">where</span></span> </span><br><span class="line">    traverse  :: <span class="type">Applicative</span> f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</span><br><span class="line">    sequenceA :: <span class="type">Applicative</span> f =&gt; t (f a) -&gt; f (t a)</span><br><span class="line">    mapM      ::       <span class="type">Monad</span> m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)</span><br><span class="line">    sequence  ::       <span class="type">Monad</span> m =&gt; t (m a) -&gt; m (t a)</span><br><span class="line">    <span class="meta">&#123;-# MINIMAL traverse | sequenceA #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>最少只需要实现traverse函数或者sequenceA函数。其中各个函数的功能通过类型签名也都能推测出来。但是其中mapM就是traverse，sequence就是sequenceA，它们存在只是历史遗留（</p>
<h4 id="Traversable实例"><a href="#Traversable实例" class="headerlink" title="Traversable实例"></a>Traversable实例</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    traverse _ <span class="type">Nothing</span> = pure <span class="type">Nothing</span></span><br><span class="line">    traverse f (<span class="type">Just</span> x) = <span class="type">Just</span> &lt;$&gt; f x</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> [] <span class="keyword">where</span></span></span><br><span class="line">    <span class="meta">&#123;-# INLINE traverse #-&#125;</span></span><br><span class="line">    traverse f = foldr cons_f (pure [])</span><br><span class="line">      <span class="keyword">where</span> cons_f x ys = liftA2 (:) (f x) ys</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    traverse _ (<span class="type">Left</span> x) = pure (<span class="type">Left</span> x)</span><br><span class="line">    traverse f (<span class="type">Right</span> y) = <span class="type">Right</span> &lt;$&gt; f y</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> ((,) a) <span class="keyword">where</span></span></span><br><span class="line">    traverse f (x, y) = (,) x &lt;$&gt; f y</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面的Tree也可以成为Traversable的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Tree</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; <span class="type">Tree</span> a -&gt; <span class="type">Tree</span> b</span><br><span class="line">    fmap     g <span class="type">Empty</span>        = <span class="type">Empty</span></span><br><span class="line">    fmap     g (<span class="type">Leaf</span> x)     = <span class="type">Leaf</span> $ g x</span><br><span class="line">    fmap     g (<span class="type">Node</span> l x r) = <span class="type">Node</span> (fmap g l)</span><br><span class="line">                                   (g x)</span><br><span class="line">                                   (fmap g r)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Traversable</span> <span class="type">Tree</span> <span class="keyword">where</span></span></span><br><span class="line">    traverse :: <span class="type">Applicative</span> f =&gt; (a -&gt; f b) -&gt; <span class="type">Tree</span> a -&gt; f (<span class="type">Tree</span> b) </span><br><span class="line">    traverse g <span class="type">Empty</span>        = pure <span class="type">Empty</span></span><br><span class="line">    traverse g (<span class="type">Leaf</span> x)     = <span class="type">Leaf</span> &lt;$&gt; g x</span><br><span class="line">    traverse g (<span class="type">Node</span> l x r) = <span class="type">Node</span> &lt;$&gt; traverse g l</span><br><span class="line">                                   &lt;*&gt; g x</span><br><span class="line">                                   &lt;*&gt; traverse g r</span><br></pre></td></tr></table></figure>

<h4 id="Traversable-Laws"><a href="#Traversable-Laws" class="headerlink" title="Traversable Laws"></a>Traversable Laws</h4><p>Traversable也有两条定律：</p>
<ol>
<li>traverse Identity <code>=</code> Identity</li>
<li>traverse (Compose . fmap g . f) <code>=</code> Compose . fmap (traverse g) . traverse f </li>
</ol>
<p>其中Identity和Compose分别定义在<code>Data.Functor.Identity</code>和<code>Data.Functor.Compose</code>两个模块中：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Identity</span> a = <span class="type">Identity</span> &#123; <span class="title">runIdentity</span> :: <span class="title">a</span> &#125; <span class="keyword">deriving</span> (...)</span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Compose</span> f g a = <span class="type">Compose</span> &#123; <span class="title">getCompose</span> :: <span class="title">f</span> (<span class="title">g</span> <span class="title">a</span>) &#125; <span class="keyword">deriving</span> (...)</span></span><br></pre></td></tr></table></figure>

<h3 id="Bifunctor"><a href="#Bifunctor" class="headerlink" title="Bifunctor"></a>Bifunctor</h3><p>Functor的实例的kind都是* -&gt; *，因此fmap只能将一个函数映射到一个值上。而Bifunctor（在<code>Data.Bifunctor</code>模块中定义）的实例的kind是* -&gt; * -&gt; *，而且它的bimap可以同时将两个函数映射到两个值上：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Bifunctor</span> p <span class="keyword">where</span></span> </span><br><span class="line">    bimap  :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d </span><br><span class="line">    first  :: (a -&gt; b) -&gt; p a c -&gt; p b c </span><br><span class="line">    second :: (b -&gt; c) -&gt; p a b -&gt; p a c </span><br><span class="line">    <span class="meta">&#123;-# MINIMAL bimap | first, second #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>同时bimap和first,second之间也可以相互转换：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">bimap</span> f g = first f . second g</span><br><span class="line"></span><br><span class="line"><span class="title">first</span>  f = bimap f id</span><br><span class="line"><span class="title">second</span> g = bimap id g</span><br></pre></td></tr></table></figure>
<p>对于Functor，((,) e)和Either e才是Functor的实例，因为他们是* -&gt; *。但是对于Bifunctor，(,)和Either就是Bifunctor的实例：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; bimap (+<span class="number">1</span>) length (<span class="number">4</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">(<span class="number">5</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h4 id="Bifunctor-Laws"><a href="#Bifunctor-Laws" class="headerlink" title="Bifunctor Laws"></a>Bifunctor Laws</h4><ol>
<li>bimap id id <code>=</code> id<br> first id <code>=</code> id<br> second id <code>=</code> id</li>
<li>bimap (f . g) (h . i) <code>=</code> bimap f h . bimap g i<br> first  (f . g) <code>=</code> first f  . first g<br> second (f . g) <code>=</code> second f . second g</li>
</ol>
<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>Haskell中的Category将一般的函数推广到了普遍的态射上，它在<code>Control.Category</code>模块中，定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Category</span> cat <span class="keyword">where</span></span> </span><br><span class="line">    id  :: cat a a </span><br><span class="line">    (.) :: cat b c -&gt; cat a b -&gt; cat a c</span><br></pre></td></tr></table></figure>
<p>它的实例有<code>(-&gt;)</code>和<code>Kleisli m</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Category</span> (-&gt;) <span class="keyword">where</span></span></span><br><span class="line">    id = <span class="type">GHC</span>.<span class="type">Base</span>.id</span><br><span class="line">    (.) = (<span class="type">GHC</span>.<span class="type">Base</span>..)</span><br></pre></td></tr></table></figure>
<p>Kleisli是一个范畴，用来表示函数a -&gt; m b，Haskell中，它在<code>Control.Arrow</code>模块中定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Kleisli</span> m a b = <span class="type">Kleisli</span> &#123; <span class="title">runKleisli</span> :: <span class="title">a</span> -&gt; <span class="title">m</span> <span class="title">b</span> &#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">Category</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    id :: <span class="type">Kleisli</span> m a a</span><br><span class="line">    id = <span class="type">Kleisli</span> return</span><br><span class="line"></span><br><span class="line">    (.) :: <span class="type">Kleisli</span> m b c -&gt; <span class="type">Kleisli</span> m a b -&gt; <span class="type">Kleisli</span> m a c</span><br><span class="line">    <span class="type">Kleisli</span> g . <span class="type">Kleisli</span> h = <span class="type">Kleisli</span> (h &gt;=&gt; g)</span><br></pre></td></tr></table></figure>
<p>Category要满足的定律只有id是(.)操作的单位元，以及(.)操作是可结合的</p>
<p>同时Category还提供了两个函数<code>&lt;&lt;&lt;</code>和<code>&gt;&gt;&gt;</code>：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">(&lt;&lt;&lt;) :: <span class="type">Category</span> cat =&gt; cat b c -&gt; cat a b -&gt; cat a c</span><br><span class="line">(&lt;&lt;&lt;) = (.)</span><br><span class="line"></span><br><span class="line">(&gt;&gt;&gt;) :: <span class="type">Category</span> cat =&gt; cat a b -&gt; cat b c -&gt; cat a c </span><br><span class="line"><span class="title">f</span> &gt;&gt;&gt; g = g . f </span><br></pre></td></tr></table></figure>

<h3 id="Arrow"><a href="#Arrow" class="headerlink" title="Arrow"></a>Arrow</h3><p>Arrow将函数进一步抽象化，它定义在<code>Control.Arrow</code>模块中：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Category</span> a =&gt; <span class="type">Arrow</span> a <span class="keyword">where</span></span> </span><br><span class="line">    arr    :: (b -&gt; c) -&gt; a b c </span><br><span class="line">    first  :: a b c -&gt; a (b, d) (c, d)</span><br><span class="line">    second :: a b c -&gt; a (d, b) (d, c)</span><br><span class="line">    (***)  :: a b c -&gt; a b&#x27; c&#x27; -&gt; a (b, b&#x27;) (c, c&#x27;)</span><br><span class="line">    (&amp;&amp;&amp;)  :: a b c -&gt; a b c&#x27; -&gt; a b (c, c&#x27;)</span><br><span class="line">    <span class="meta">&#123;-# MINIMAL arr, (first | (***)) #-&#125;</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>arr</code>函数将一个函数变成一个Arrow</li>
<li><code>first</code>函数将一个Arrow变成一个二元组间的Arrow，且只会对一个元素进行操作，第二个元素保持不变</li>
<li><code>second</code>函数与first相反，第一个元素保持不变</li>
<li><code>***</code>函数是Arrow之间的parallel composition，对于函数: (g *** h) (x, y) = (g x, h y)</li>
<li><code>&amp;&amp;&amp;</code>函数是Arrow之间的fanout composition，对于函数: (g &amp;&amp;&amp; h) x = (g x, h x)</li>
</ul>
<p>它的实例也有(-&gt;)和Kleisli：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Arrow</span> (-&gt;) <span class="keyword">where</span></span></span><br><span class="line">  arr :: (b -&gt; c) -&gt; (b -&gt; c)</span><br><span class="line">  arr g = g</span><br><span class="line"></span><br><span class="line">  first :: (b -&gt; c) -&gt; ((b,d) -&gt; (c,d))</span><br><span class="line">  first g (x,y) = (g x, y)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">Arrow</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">  arr :: (b -&gt; c) -&gt; <span class="type">Kleisli</span> m b c</span><br><span class="line">  arr f = <span class="type">Kleisli</span> (return . f)</span><br><span class="line"></span><br><span class="line">  first :: <span class="type">Kleisli</span> m b c -&gt; <span class="type">Kleisli</span> m (b,d) (c,d)</span><br><span class="line">  first (<span class="type">Kleisli</span> f) = <span class="type">Kleisli</span> (\ ~(b,d) -&gt; <span class="keyword">do</span> c &lt;- f b</span><br><span class="line">                                              return (c,d) )</span><br></pre></td></tr></table></figure>
<p>常用函数：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">returnA</span> :: <span class="type">Arrow</span> a =&gt; a b b</span><br><span class="line"><span class="title">returnA</span> = arr id</span><br><span class="line"></span><br><span class="line">(^&gt;&gt;) :: <span class="type">Arrow</span> a =&gt; (b -&gt; c) -&gt; a c d -&gt; a b d</span><br><span class="line"><span class="title">f</span> ^&gt;&gt; a = arr f &gt;&gt;&gt; a</span><br><span class="line"></span><br><span class="line">(&gt;&gt;^) :: <span class="type">Arrow</span> a =&gt; a b c -&gt; (c -&gt; d) -&gt; a b d</span><br><span class="line"><span class="title">a</span> &gt;&gt;^ f = a &gt;&gt;&gt; arr f</span><br><span class="line"></span><br><span class="line">(&lt;&lt;^) :: <span class="type">Arrow</span> a =&gt; a c d -&gt; (b -&gt; c) -&gt; a b d</span><br><span class="line"><span class="title">a</span> &lt;&lt;^ f = a &lt;&lt;&lt; arr f</span><br><span class="line"></span><br><span class="line">(^&lt;&lt;) :: <span class="type">Arrow</span> a =&gt; (c -&gt; d) -&gt; a b c -&gt; a b d</span><br><span class="line"><span class="title">f</span> ^&lt;&lt; a = arr f &lt;&lt;&lt; a</span><br></pre></td></tr></table></figure>

<h4 id="Arrow-notation"><a href="#Arrow-notation" class="headerlink" title="Arrow notation"></a>Arrow notation</h4><p>类似do-notation，Arrow也提供了一套方便的语句：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">proc</span> x -&gt; <span class="keyword">do</span> </span><br><span class="line">    y &lt;- action1 -&lt; ... </span><br><span class="line">    z &lt;- action2 -&lt; ...</span><br><span class="line">    returnA -&lt; ...</span><br></pre></td></tr></table></figure>
<p>其中proc代替了lambda表达式中的斜杠\，-&lt;右边的为输入，左边的为接收输入的函数。比如，下面三种写法达成的效果是一样的：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">f</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">f</span> = \x -&gt;</span><br><span class="line">    <span class="keyword">let</span> y  = <span class="number">2</span> * x</span><br><span class="line">        z1 = y + <span class="number">3</span></span><br><span class="line">        z2 = y - <span class="number">5</span></span><br><span class="line">    <span class="keyword">in</span> (z1, z2) </span><br><span class="line"><span class="comment">-- ghci&gt; f 10 </span></span><br><span class="line"><span class="comment">-- (23,15)</span></span><br><span class="line"></span><br><span class="line"><span class="title">fM</span> :: <span class="type">Int</span> -&gt; <span class="type">Identity</span> (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">fM</span> = \x -&gt; <span class="keyword">do</span></span><br><span class="line">    y  &lt;- return (<span class="number">2</span> * x)</span><br><span class="line">    z1 &lt;- return (y + <span class="number">3</span>)</span><br><span class="line">    z2 &lt;- return (y - <span class="number">5</span>)</span><br><span class="line">    return (z1, z2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ghci&gt; runIdentity (fM 10)</span></span><br><span class="line"><span class="comment">-- (23,15)</span></span><br><span class="line"></span><br><span class="line"><span class="title">fA</span> :: <span class="type">Int</span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line"><span class="title">fA</span> = <span class="keyword">proc</span> x -&gt; <span class="keyword">do</span></span><br><span class="line">    y  &lt;- (<span class="number">2</span> *) -&lt; x</span><br><span class="line">    z1 &lt;- (+ <span class="number">3</span>) -&lt; y</span><br><span class="line">    z2 &lt;- (subtract <span class="number">5</span>) -&lt; y</span><br><span class="line">    returnA -&lt; (z1, z2)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ghci&gt; fA 10</span></span><br><span class="line"><span class="comment">-- (23,15)</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrowChoice"><a href="#ArrowChoice" class="headerlink" title="ArrowChoice"></a>ArrowChoice</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Arrow</span> a =&gt; <span class="type">ArrowChoice</span> a <span class="keyword">where</span></span></span><br><span class="line">    left :: a b c -&gt; a (<span class="type">Either</span> b d) (<span class="type">Either</span> c d)</span><br><span class="line">    left = (+++ id)</span><br><span class="line"></span><br><span class="line">    right :: a b c -&gt; a (<span class="type">Either</span> d b) (<span class="type">Either</span> d c)</span><br><span class="line">    right = (id +++)</span><br><span class="line"></span><br><span class="line">    (+++) :: a b c -&gt; a b&#x27; c&#x27; -&gt; a (<span class="type">Either</span> b b&#x27;) (<span class="type">Either</span> c c&#x27;)</span><br><span class="line">    f +++ g = left f &gt;&gt;&gt; arr mirror &gt;&gt;&gt; left g &gt;&gt;&gt; arr mirror</span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">        mirror :: <span class="type">Either</span> x y -&gt; <span class="type">Either</span> y x</span><br><span class="line">        mirror (<span class="type">Left</span> x) = <span class="type">Right</span> x</span><br><span class="line">        mirror (<span class="type">Right</span> y) = <span class="type">Left</span> y</span><br><span class="line"></span><br><span class="line">    (|||) :: a b d -&gt; a c d -&gt; a (<span class="type">Either</span> b c) d</span><br><span class="line">    f ||| g = f +++ g &gt;&gt;&gt; arr untag</span><br><span class="line">      <span class="keyword">where</span></span><br><span class="line">        untag (<span class="type">Left</span> x) = x</span><br><span class="line">        untag (<span class="type">Right</span> y) = y</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">ArrowChoice</span> (-&gt;) <span class="keyword">where</span></span></span><br><span class="line">    left f = f +++ id</span><br><span class="line">    right f = id +++ f</span><br><span class="line">    f +++ g = (<span class="type">Left</span> . f) ||| (<span class="type">Right</span> . g)</span><br><span class="line">    (|||) = either</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> m =&gt; <span class="type">ArrowChoice</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    left f = f +++ arr id</span><br><span class="line">    right f = arr id +++ f</span><br><span class="line">    f +++ g = (f &gt;&gt;&gt; arr <span class="type">Left</span>) ||| (g &gt;&gt;&gt; arr <span class="type">Right</span>)</span><br><span class="line">    <span class="type">Kleisli</span> f ||| <span class="type">Kleisli</span> g = <span class="type">Kleisli</span> (either f g)</span><br></pre></td></tr></table></figure>

<h4 id="ArrowZero-amp-ArrowPlus"><a href="#ArrowZero-amp-ArrowPlus" class="headerlink" title="ArrowZero &amp; ArrowPlus"></a>ArrowZero &amp; ArrowPlus</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Arrow</span> a =&gt; <span class="type">ArrowZero</span> a <span class="keyword">where</span></span></span><br><span class="line">    zeroArrow :: a b c</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">ArrowZero</span> a =&gt; <span class="type">ArrowPlus</span> a <span class="keyword">where</span></span></span><br><span class="line">    (&lt;+&gt;) :: a b c -&gt; a b c -&gt; a b c</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> m =&gt; <span class="type">ArrowZero</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    zeroArrow = <span class="type">Kleisli</span> (\_ -&gt; mzero)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadPlus</span> m =&gt; <span class="type">ArrowPlus</span> (<span class="type">Kleisli</span> <span class="title">m</span>) <span class="keyword">where</span></span></span><br><span class="line">    <span class="type">Kleisli</span> f &lt;+&gt; <span class="type">Kleisli</span> g = <span class="type">Kleisli</span> (\x -&gt; f x `mplus` g x)</span><br></pre></td></tr></table></figure>

<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) &lt;+&gt; (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) <span class="number">2</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">2</span>,<span class="number">-2</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; either (+<span class="number">2</span>) (*<span class="number">3</span>) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; either (+<span class="number">2</span>) (*<span class="number">3</span>) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">2</span>) ||| (*<span class="number">3</span>) $ (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">2</span>) +++ (*<span class="number">3</span>) $ (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">2</span>) ||| (*<span class="number">3</span>) $ (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">2</span>) +++ (*<span class="number">3</span>) $ (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; left (+<span class="number">2</span>) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; right (*<span class="number">3</span>) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">9</span></span><br><span class="line"><span class="title">ghci</span>&gt; left (+<span class="number">2</span>) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; right (*<span class="number">3</span>) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) ||| (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line">[<span class="number">6</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) ||| (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">-3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) +++ (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) (<span class="type">Left</span> <span class="number">3</span>)</span><br><span class="line">[<span class="type">Left</span> <span class="number">6</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; runKleisli ((<span class="type">Kleisli</span> (\x -&gt; [x * <span class="number">2</span>])) +++ (<span class="type">Kleisli</span> (\x -&gt; [x, -x]))) (<span class="type">Right</span> <span class="number">3</span>)</span><br><span class="line">[<span class="type">Right</span> <span class="number">3</span>,<span class="type">Right</span> (<span class="number">-3</span>)]</span><br></pre></td></tr></table></figure>


<h2 id="Haskell与范畴论"><a href="#Haskell与范畴论" class="headerlink" title="Haskell与范畴论"></a>Haskell与范畴论</h2><p>Haskell中的函子单子等都与范畴论（category theory）有很多联系，所以打算简单了解一下范畴论的相关内容。</p>
<blockquote>
<p><strong>范畴论</strong>是数学的一门学科，以抽象的方法处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。数学中许多重要的领域可以形式化为范畴。使用范畴论可以令这些领域中许多难理解、难捉摸的数学结论更容易叙述证明。</p>
<div style="text-align: right">———— 维基百科</div>
</blockquote>
<h3 id="范畴（Category）"><a href="#范畴（Category）" class="headerlink" title="范畴（Category）"></a>范畴（Category）</h3><p>范畴本质上是一个简单的集合，一个范畴$\mathbf{C}$包含三个组成成分：</p>
<!--more-->
<ul>
<li>一个类$\mathrm{ob}(\mathbf{C})$：其中元素称为<strong>对象（objects）</strong></li>
<li>一个类$\mathrm{hom}(\mathbf{C})$：其中元素称为<strong>态射（morphisms）</strong>（或<strong>箭号（arrows）</strong>）：每个态射连接了两个对象：源对象（source object）、目标对象（target object）。如果$f$是从源对象$A$到目标对象$B$（$A, B\in \mathrm{ob}(\mathbf{C})$）的态射，那么记为$f : A\to B$</li>
<li>一个二元运算，称为态射<strong>复合（composition）</strong>：两个态射$g : A\to B$、$f : B\to C$的复合记为$f\circ g : A\to C$<br>在Haskell和大部分数学理论中都是从右向左计算，即$f\circ g$中是先计算$g : A\to B$再计算$f : B\to C$</li>
</ul>
<p>许多东西都可以组成范畴。比如:</p>
<p>&emsp;$\mathbf{Set}$是一个范畴，对象为所有集合，态射为集合之间的函数，复合即函数之间的复合</p>
<p>&emsp;$\mathbf{Grp}$是一个范畴，对象为所有群，态射为群同态（group homomorphisms），例如对于群$(G,*)$和$(H,\cdot )$，有群同态$h : (G,*)\to (H,\cdot )$，则需要对于$G$中的任意元素$u,v$满足<br>$$h(u*v)=h(u)\cdot h(v)$$</p>
<p><strong>注意</strong>：态射不必须为函数；而且可以存在源对象和目标对象都相同的不同态射</p>
<h4 id="范畴公理"><a href="#范畴公理" class="headerlink" title="范畴公理"></a>范畴公理</h4><p>每个范畴都需要满足三条定律：</p>
<ol>
<li>态射复合需要满足<strong>结合律（associativity）</strong>：<br>$$f\circ (g\circ h) = (f\circ g)\circ h$$</li>
<li>范畴在复合操作下是<strong>闭合的（closed）</strong>：<br>&emsp;&emsp;&emsp;如果范畴$\mathbf{C}$中存在态射$f : B\to C$、$g : A\to B$，那么范畴$\mathbf{C}$中也一定存在态射$h : A\to C$，且$h=f\circ g$</li>
<li>每个对象都需要有<strong>单位态射（identity morphisms）</strong>：<br>&emsp;&emsp;&emsp;对于范畴$\mathbf{C}$中的对象$A$，一定存在单位态射$\mathrm{id}_A : A\to A$，且对于每个态射$g : A\to B$，一定有：<br>$$g\circ\mathrm{id}_A = \mathrm{id}_B\circ g = g$$</li>
</ol>
<h4 id="mathbf-Hask-范畴"><a href="#mathbf-Hask-范畴" class="headerlink" title="$\mathbf{Hask}$范畴"></a>$\mathbf{Hask}$范畴</h4><p>范畴$\mathbf{Hask}$的对象为Haskell中的类型（types），态射是Haskell中的函数，复合运算是<code>(.)</code>。即从类型A到类型B的函数 f :: A -&gt; B 就是$\mathbf{Hask}$范畴中的一个态射。而函数 f :: B -&gt; C 、g :: A -&gt; B 的组合 f . g 就是一个新的函数 h :: A -&gt; C。</p>
<p>对于三条定律：</p>
<ol>
<li>第一条显然满足：f . (g . h) = (f . g) . h</li>
<li>第二条也显然满足，如果有函数 f :: B -&gt; C 、g :: A -&gt; B，一定有函数 h = (f . g) :: A -&gt; C </li>
<li>对于第三条定律，Haskell中存在单位函数 id ，但id是多态（polymorphic）的，要为其指定类型使其变成单态（monomorphic）的。比如态射$\mathrm{id}_A$在Haskell中就可以表示为 id :: A -&gt; A。并且显然满足第三条定律（其中 f :: A -&gt; B）：<p style="text-align: center;">(id :: B -> B) . f = f . (id :: A -> A) = f</p></li>
</ol>
<h3 id="函子（Functors）"><a href="#函子（Functors）" class="headerlink" title="函子（Functors）"></a>函子（Functors）</h3><p>一个范畴中的态射将两个对象联系起来，而函子则会将两个范畴联系起来。换句话说，函子就是从一个范畴到另一个范畴的变换。比如对于范畴$\mathbf{C}$、$\mathbf{D}$，定义函子$F : \mathbf{C}\to\mathbf{D}$满足：</p>
<ul>
<li>对于$\mathbf{C}$中的任意对象$A$，在$\mathbf{D}$中都有对象$F(A)$</li>
<li>对于$\mathbf{C}$中的任意态射$f : A\to B$，在$\mathbf{D}$中都有态射$F(f) : F(A)\to F(B)$</li>
</ul>
<p>比如：</p>
<p>&emsp;遗忘函子（forgetful functor）$U : \mathbf{Grp}\to\mathbf{Set}$，将一个群映射到一个集合中，将群同态映射到集合间的函数</p>
<p>&emsp;幂集函子（power set functor）$P : \mathbf{Set}\to\mathbf{Set}$，将一个集合映射到它的幂集，将原集合中的函数$f : A\to B$映射到函数$P(f) : \mathcal{P}(A)\to\mathcal{P}(B)$，即从$U\subseteq A$到值域$f(U)\subseteq B$的映射</p>
<p>&emsp;自函子（endofunctor）$1_{\mathbf{C}} : \mathbf{C}\to\mathbf{C}$，将一个范畴映射到它本身</p>
<h4 id="函子公理"><a href="#函子公理" class="headerlink" title="函子公理"></a>函子公理</h4><p>函子$F : \mathbf{C}\to\mathbf{D}$也需要满足两个公理：</p>
<ol>
<li>对于任意对象$X\in\mathbf{C}$，恒有$F(\mathrm{id}_X)=\mathrm{id}_{F(X)}$</li>
<li>对于态射$f : Y\to Z$、$g : X\to Y$，恒有$F(f\circ g) = F(f)\circ F(g)$</li>
</ol>
<h4 id="mathbf-Hask-范畴上的函子"><a href="#mathbf-Hask-范畴上的函子" class="headerlink" title="$\mathbf{Hask}$范畴上的函子"></a>$\mathbf{Hask}$范畴上的函子</h4><p>Haskell中的Functor定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> (<span class="title">f</span> :: * -&gt; *) <span class="keyword">where</span></span> </span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>对于Haskell中的Functor，它实际上是从$\mathbf{Hask}$范畴（types）到它子范畴的变换。比如列表函子$\mathtt{[]} : \mathbf{Hask}\to\mathbf{Lst}$（其中$\mathbf{Lst}$是所有Haskell中列表类型构成的范畴）</p>
<p>它也达成了范畴论中对于函子的要求。函子需要进行两个操作：将一个范畴中的对象映射到另一个范畴中、将一个范畴中的态射映射到另一个范畴中。以Maybe为例，它实现了函子的要求：</p>
<ol>
<li>Maybe是一个类型构造器，他可以将任意类型 T 变成新类型 Maybe T，相当于从$\mathbf{Hask}$范畴的对象变成了$\mathbf{Maybe}$范畴的对象 </li>
<li>fmap函数接收一个 a -&gt; b 类型的函数，返回一个 Maybe a -&gt; Maybe b 类型的函数，相当于将$\mathbf{Hask}$范畴中的态射$f : A\to B$映射成了$\mathbf{Maybe}$范畴中的态射$\mathbf{Maybe}(f) : \mathbf{Maybe}(A)\to\mathbf{Maybe}(B)$</li>
</ol>
<p><strong>注意</strong>：时刻记住这里研究的是$\mathbf{Hask}$范畴和它的子范畴，对象是类型而不是值，态射是函数也指的是从类型到类型</p>
<p>同时，Haskell中的Functor也满足函子公理：</p>
<ol>
<li>fmap id = id 即 fmap (id :: A -&gt; A) = (id :: f A -&gt; f A)</li>
<li>fmap (f . g) = fmap f . fmap g</li>
</ol>
<h3 id="单子（Monads）"><a href="#单子（Monads）" class="headerlink" title="单子（Monads）"></a>单子（Monads）</h3><blockquote>
<p>一个单子说白了不过就是自函子范畴上的一个幺半群而已 _(:з」∠)_</p>
</blockquote>
<p>自函子在前面说到过是从一个范畴到自身的一个函子，如范畴$\mathbf{C}$上的自函子是$F : \mathbf{C}\to\mathbf{C}$。自函子范畴就是对象都是自函子的范畴。幺半群和Haskell中学到的Monoid类型类一样，是一个有可结合二元运算和单位元的代数结构。因此单子就是一个自函子，而且它有可结合二元运算（Haskell中<code>&gt;=&gt;</code>）和单位元（Haskell中<code>return</code>）。</p>
<p>一个单子$M : \mathbf{C}\to\mathbf{C}$还包含两个态射（对于范畴$\mathbf{C}$中的所有对象$X$）：</p>
<ol>
<li>$\mathrm{unit}_X^M : X\to M(X)$</li>
<li>$\mathrm{join}_X^M : M(M(X))\to M(X)$</li>
</ol>
<p>（当式子中的单子明显是$M$时，可以省略上标${}^M$）</p>
<p>Haskell中Monad的定义是：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span> </span><br><span class="line">    return :: a -&gt; m a </span><br><span class="line">    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure>
<p>其中很显然多态函数<code>return</code>对应了定义中的$\mathrm{unit}$，但是<code>&gt;&gt;=</code>和$mathrm{join}$的对应关系并不明显。因此Haskell中有一个工具函数<code>join</code>，它的效果就是定义中的$\mathrm{join}$，而且它可以和<code>&gt;&gt;=</code>互相定义：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a</span><br><span class="line"><span class="title">join</span> x = x &gt;&gt;= id</span><br><span class="line"></span><br><span class="line">(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b </span><br><span class="line"><span class="title">x</span> &gt;&gt;= f = join $ fmap f x</span><br></pre></td></tr></table></figure>
<p>所以Haskell中为Monad要求定义<code>&gt;&gt;=</code>就相当于定义了$\mathrm{join}$</p>
<p>例如，幂集函子$P : \mathbf{Set}\to\mathbf{Set}$也是一个单子，可以为它定义$\mathrm{unit}$和$\mathrm{join}$两个态射。Haskell中的列表也可以近似看作幂集函子。</p>
<p>&emsp;态射/函数的类型：</p>
<table>
<thead>
<tr>
<th align="center">幂集函子</th>
<th align="center">Haskell中列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一个集合$S$和一个态射$f : A\to B$</td>
<td align="center">一个类型 T 和一个函数 f :: A -&gt; B</td>
</tr>
<tr>
<td align="center">$P(f) : \mathcal{P}(A)\to\mathcal{P}(B)$</td>
<td align="center">fmap f :: [A] -&gt; [B]</td>
</tr>
<tr>
<td align="center">$\mathrm{unit}_S : S\to\mathcal{P}(S)$</td>
<td align="center">return :: T -&gt; [T]</td>
</tr>
<tr>
<td align="center">$\mathrm{join}_S : \mathcal{P}(\mathcal{P}(S))\to\mathcal{P}(S)$</td>
<td align="center">join :: [[T]] -&gt; [T]</td>
</tr>
</tbody></table>
<p>&emsp;态射/函数的定义：</p>
<table>
<thead>
<tr>
<th align="center">幂集函子</th>
<th align="center">Haskell中列表</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$(\mathcal{P}(f))(S) = \{f(a):a\in S\}$</td>
<td align="center">fmap f xs = [ f a | a &lt;- xs ]</td>
</tr>
<tr>
<td align="center">$\mathrm{unit}_S(x) = \{x\}$</td>
<td align="center">return x = [x]</td>
</tr>
<tr>
<td align="center">$\mathrm{join}_S(L) = \bigcup L$</td>
<td align="center">join xs = concat xs</td>
</tr>
</tbody></table>
<h4 id="单子公理"><a href="#单子公理" class="headerlink" title="单子公理"></a>单子公理</h4><p>给定一个单子$M : \mathbf{C}\to\mathbf{C}$，和一个态射$f : A\to B$（其中$A,B\in \mathbf{C}$），那么满足下面四条定律：</p>
<ol>
<li>$\mathrm{join}\circ M(\mathrm{join})=\mathrm{join}\circ\mathrm{join}$</li>
<li>$\mathrm{join}\circ M(\mathrm{unit})=\mathrm{join}\circ\mathrm{unit}=\mathrm{id}$</li>
<li>$\mathrm{unit}\circ f = M(f)\circ\mathrm{unit}$</li>
<li>$\mathrm{join}\circ M(M(f)) = M(f)\circ\mathrm{join}$</li>
</ol>
<p>也可以很自然地将其转化为Haskell中的表述：</p>
<ol>
<li>join . fmap join <code>=</code> join . join </li>
<li>join . fmap return <code>=</code> join . return <code>=</code> id </li>
<li>return . f <code>=</code> fmap f . return </li>
<li>join . fmap (fmap f) <code>=</code> fmap f . join</li>
</ol>
<p>在Haskell中，使用<code>&gt;&gt;=</code>也有三个定律和这四个定律是等价的：</p>
<ol>
<li>return x &gt;&gt;= f <code>=</code> f x <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  return x &gt;&gt;= f </span><br><span class="line">= join (fmap f (return x)) = join (fmap f . return $ x)</span><br><span class="line">= join (return (f x)) = join (return . f $ x)</span><br><span class="line">= join . return $ (f x)</span><br><span class="line">= id (f x)</span><br><span class="line">= f x</span><br></pre></td></tr></table></figure></li>
<li>m &gt;&gt;= return <code>=</code> m<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  m &gt;&gt;= return </span><br><span class="line">= join (fmap return m) = join . fmap return $ m </span><br><span class="line">= id m</span><br><span class="line">= m </span><br></pre></td></tr></table></figure></li>
<li>(m &gt;&gt;= f) &gt;&gt;= g <code>=</code> m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">  (m &gt;&gt;= f) &gt;&gt;= g </span><br><span class="line">= (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))</span><br><span class="line">= join . fmap g . join $ fmap f m </span><br><span class="line">= join . join . fmap (fmap g) $ fmap f m </span><br><span class="line">= join . join . fmap (fmap g) . fmap f $ m </span><br><span class="line">= join . join . fmap (fmap g . f) $ m </span><br><span class="line">= join . fmap join . fmap (fmap g . f) $ m </span><br><span class="line">= join . fmap (join . (fmap g . f)) $ m </span><br><span class="line">= join . fmap (\x -&gt; join (fmap g (f x))) $ m </span><br><span class="line">= join . fmap (\x -&gt; f x &gt;&gt;= g) $ m </span><br><span class="line">= join (fmap (\x -&gt; f x &gt;&gt;= g) m)</span><br><span class="line">= m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>有关do语句和<code>&gt;=&gt;</code>的公理表述在上文中已经说过</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>啃了将近一个月，算是把Haskell的主要内容都啃完了。主要就是前期看<a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a>，后期看<a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a>，都是pdcxs推荐给的教程。但是一堆视频一个都没有耐心看进去qwq</p>
<p>后面的部分的理解感觉也没到位，Category、Arrow等这些类型类也就是大致地看了一眼，甚至有什么用都不太清楚_(:з」∠)_</p>
<p>感觉Haskell这门语言确实很神奇，很多语法都很有意思，而且可以做到非常贴近数学、贴近数学概念。学的时候也是越学坑越多，先是函数式编程引申到了lambda演算，然后是函子等一系列概念引申到了范畴论，目前范畴论简单地看了一部分，lambda演算也没深入研究，以后有时间再说了（咕咕咕）</p>
<p>现在感觉我学到的Haskell简直是皮毛，还有一堆源码里的东西不知道是怎么回事（包括但不限于#，~），也还有一堆类型类和用法没有学到（包括但不限于Monad Transformer、Writer、Reader、State、Comonad、MonadFix、Lens、Parsec、……）<del>md，这么一看差的还真多</del>，以后有时间再慢慢学了，这个假期还有好多其它事要干呢，Haskell这边先摸了_(:з」∠)_</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="https://stackoverflow.com/questions/6172004/writing-foldl-using-foldr">Writing foldl using foldr - StackOverflow</a></li>
<li><a href="https://blog.csdn.net/WinterShiver/article/details/103308165">Haskell：用foldr定义foldl</a></li>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia - Haskell wiki</a></li>
<li><a href="https://hoogle.haskell.org/">Hoogle</a></li>
<li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></li>
<li><a href="http://02s949.coding-pages.com/2018/08/15/haskellc/">Haskell学习 - functor</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/54863519">Haskell语言学习笔记（8）Monoid - zwvista</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/62238541">Haskell语言学习笔记（16）Alternative - zwvista</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/78679542">Haskell语言学习笔记（40）Arrow（1） - zwvista</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-21-arrows.html">24 Days of GHC Extensions: Arrows - Tom Ellis</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/78690485">Haskell语言学习笔记（47）Arrow（2） - zwvista</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell/Category theory - wikibooks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Category_theory">Category theory - wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论 - 维基百科</a></li>
<li><a href="https://en.wikipedia.org/wiki/Monad_(category_theory)">Monad (category theory) - wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Functor">Functor - wikipedia</a></li>
</ul>
<p style="text-align: center; font-size: x-large; font-weight: bolder"> "The End?" </p>]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>修复manim中Text类的bug</title>
    <url>/p/b6815e8.html</url>
    <content><![CDATA[<p>在使用manim时,对于Text类,会有一些bug,我尝试修复了它们</p>
<ol>
<li>在<code>shaders</code>分支下无法使用Text类</li>
<li>Text文字的stroke边框不完整,导致显示stroke会非常难看</li>
<li>含有空格的Text的空格不在文字内部,而在<code>ORIGIN</code>的位置,导致<code>Transform</code>时会有字符在原位置和<code>ORIGIN</code>之间 <del>反复横跳</del></li>
<li>Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小</li>
</ol>
<p>这些问题已经通过<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>修复到了manim的master分支中</p>
<span id="more"></span>

<h2 id="mathcal-Bug-1"><a href="#mathcal-Bug-1" class="headerlink" title="$\mathcal{Bug\ 1.}$"></a>$\mathcal{Bug\ 1.}$</h2><p>当在<code>shaders</code>分支下使用Text类时会出现如下报错:<br><img src="../images/text_bug1.png"><br>其中最后一行让我发现此时的p0和p1的大小不相等,不能相加(broadcast),而p0和p1是通过贝赛尔曲线的次数(在shaders下是3)来拆分<code>self.points</code>的<br>所以可能是<code>self.points</code>的长度不为3的倍数,导致了错误.在<code>print(len(self.points))</code>后发现确实是这样<br>然后我又用了 <del>玄学</del> 手段,删掉了SVGMobject的最后一个点,发现可以正常渲染</p>
<p>此时我又去看了cairo自动生成的svg代码,根据我之前学svg的一点经验,发现每个<code>&lt;path/&gt;</code>的路径结尾都为<code>Z M ... ... /&quot;&gt;</code><br>而<code>Z</code>是将路径闭合,但闭合后又多出了一个<code>M</code>控制符,这会导致manim在处理svg时额外生成一个点<br>而删掉每个路径字符串的最后一个<code>M</code>控制符,可以直接使用正则表达式匹配出来,然后替换掉<br><img src="../images/text_bug1_svg.png"></p>
<p>我第一个想到的正则表达式是<code>Z M .*? /&quot;&gt;</code>,但是如果在路径的中间出现<code>Z M</code>,则会将其后面有用的部分一起删除<br>而有用的部分一定含有控制符,所以将控制符排除,就可以仅仅匹配掉最后一个<code>M</code>,正则表达式:<code>Z M [^A-Za-z]*? /&quot;&gt;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_last_M</span>(<span class="params">self, file_name</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fpr:</span><br><span class="line">        content = fpr.read()</span><br><span class="line">    content = re.sub(<span class="string">r&#x27;Z M [^[A-Za-z]*? &quot;\/&gt;&#x27;</span>, <span class="string">&#x27;Z &quot;/&gt;&#x27;</span>, content)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fpw:</span><br><span class="line">        fpw.write(content)</span><br></pre></td></tr></table></figure>

<h2 id="mathcal-Bug-2"><a href="#mathcal-Bug-2" class="headerlink" title="$\mathcal{Bug\ 2.}$"></a>$\mathcal{Bug\ 2.}$</h2><p>Text文字的stroke边框不完整,导致stroke显示不全,也会对<code>DrawBorderThenFill</code>造成影响,也有B站的观众向我提了这个问题</p>
<blockquote>
<p>– 话说，感觉每个Chapter之间的文字是不是先画出轮廓再填充上色，画完轮廓的时候停顿了一下。但是停顿的时候轮廓没有画完，有些地方有点断续的感觉<br>– Text类的bug，stroke日常乱套</p>
</blockquote>
<p>为了解决这个问题,我只显示了stroke,并且用<code>debugTeX</code>标出了构成每个字符的<code>self.points</code>的位置,比如”manim”如下:<br><img src="../images/text_bug2_before.png"><br>通过观察和与<a href="https://github.com/xy-23">@XiaoYoung</a>交流之后,确定了cairo生成的svg并不能使路径自动闭合<br>而在一般查看svg的软件(Chrome)中,svg图像只显示内部(fill),而stroke被忽略(很细),所以正常使用没问题<br>但是在manim中有时需要使用stroke,这时cairo生成的svg出现了bug,路径没有完全闭合</p>
<p>我最开始的想法是直接通过<code>.add_line_to()</code>方法将svg收尾相连,但是这显然只解决了m和n<br>而a和i是由两条路径复合而成的,其中的每条路径都没有闭合,所以都需要手动闭合,所以我决定遍历<code>self.points</code><br>这时我使用了一个<code>last</code>变量来记录遍历到当前位置所在的路径上的起点,并且如果到了下一条路径(索引为nppc的倍数,并且不与前一个点相重合),就将首尾连接上,并更新<code>last</code></p>
<p>而这样做还需要一个特判,当points为空时(空格)直接跳过,否则<code>points[0]</code>会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nppc = self.n_points_per_cubic_curve</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> self:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(each.points) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    points = each.points</span><br><span class="line">    last = points[<span class="number">0</span>]</span><br><span class="line">    each.clear_points()</span><br><span class="line">    <span class="keyword">for</span> index, point <span class="keyword">in</span> <span class="built_in">enumerate</span>(points):</span><br><span class="line">        each.append_points([point])</span><br><span class="line">        <span class="keyword">if</span> index != <span class="built_in">len</span>(points) - <span class="number">1</span> <span class="keyword">and</span> (index + <span class="number">1</span>) % nppc == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">any</span>(point != points[index+<span class="number">1</span>]):</span><br><span class="line">            each.add_line_to(last)</span><br><span class="line">            last = points[index + <span class="number">1</span>]</span><br><span class="line">    each.add_line_to(last)</span><br></pre></td></tr></table></figure>

<p>这样做之后,这个bug就完全解决了,而且中文也同时适用,对比如下,上为修复之前,下为修复之后(都为仅显示stroke)<br><img src="../images/text_bug2_after.png"><br><img src="../images/text_bug2_en.png"><br><img src="../images/text_bug2_cn.png"></p>
<h2 id="mathcal-Bug-3"><a href="#mathcal-Bug-3" class="headerlink" title="$\mathcal{Bug\ 3.}$"></a>$\mathcal{Bug\ 3.}$</h2><p>这个是非常常见的问题了,如下:<br><img src="../images/text_bug3_before.gif"><br>之前解决这个问题是通过’假空格’,即用一个不常用字符表示空格,并将其设为背景色,或者opacity改成0<br>通过debugTeX可以发现,Text的空格占字符而且位置在ORIGIN<br>而TextMobject中的空格直接不占位置.所以我直接在处理bug2的同时,将<code>len(each.points) == 0</code>的处理中加上了<code>self.remove(each)</code>,这样就暂时解决了<br><img src="../images/text_bug3.png"><br><img src="../images/text_bug3_after.gif"><br>而<a href="https://github.com/xy-23">@XiaoYoung</a>也提醒了我,这样的处理会干扰t2c的自动上色(下标改变了),在<a href="https://github.com/3b1b/manim/pull/1018">#1018</a>这里,他决定单开一个pr来修复这个bug,所以我就把这一个commit删除掉了</p>
<h2 id="mathcal-Bug-4"><a href="#mathcal-Bug-4" class="headerlink" title="$\mathcal{Bug\ 4.}$"></a>$\mathcal{Bug\ 4.}$</h2><p>Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小<br>通过阅读源码可以发现,TextMobject在<code>__init__()</code>的结尾,有一句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.height <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    self.scale(TEX_MOB_SCALE_FACTOR)</span><br></pre></td></tr></table></figure>
<p>而这个<code>TEX_MOB_SCALE_FACTOR</code>默认为<code>0.05</code>,即将默认的SVGMobject(高度为固定默认值)缩小为0.05倍<br>而Text类最后缩小了0.1倍,导致了大小不等,将其改为0.05后,就方便统一大小了<br><img src="../images/text_bug4.png"></p>
<h2 id="mathcal-Pull-Requests"><a href="#mathcal-Pull-Requests" class="headerlink" title="$\mathcal{Pull\ Requests}$"></a>$\mathcal{Pull\ Requests}$</h2><p>第一次提交pr,记录一下</p>
<ol>
<li>将原repo fork到自己的用户上</li>
<li>clone下来fork的repo</li>
<li>进行更改,add/commit/push,commit的注释要规范</li>
<li>在GitHub网页上,打开fork的repo,会有一个按钮<code>New Pull Request</code></li>
<li>比较,确认更改,然后<code>Create Pull Request</code>,表述出pr的必要性和验证,提交pr</li>
<li>等待repo管理员merge</li>
</ol>
<p>这次修复bug的pr在<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>和<a href="https://github.com/3b1b/manim/pull/1031">#1031</a><br>其中<a href="https://github.com/3b1b/manim/pull/1030">#1030</a>被merge了,而<a href="https://github.com/3b1b/manim/pull/1031">#1031</a>还在等待</p>
]]></content>
      <categories>
        <category>manim</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>笔记</tag>
        <tag>manim</tag>
        <tag>python</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>树上莫队-笔记  /「SPOJ 10707」COT2-题解</title>
    <url>/p/24f5ddbc.html</url>
    <content><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/SP10707">SPOJ 10707 COT2-Count on a tree II</a>这道题目来学习一下 <strong>树上莫队</strong><br>当需要离线查询 <strong>树上</strong> 的多区间问题时,可以使用 <strong>树上莫队</strong> 来解决</p>
<p>主要通过 <strong>欧拉序</strong> 将树转化为一条链,然后在链上执行普通莫队的操作</p>
<span id="more"></span>

<h2 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h2><h3 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h3><p>正常进行<code>dfs</code>,在入和出时各加入序列中<br>比如样例的树如下:<br><img src="/p/24f5ddbc/graph.png"><br>其欧拉序为<code>1 2 2 3 5 5 6 6 7 7 3 4 8 8 4 1</code><br>可以很好地呈现出子树的关系,即两个相同的数$x$之间的部分为$x$子树中的节点<br>其有一个性质:<strong>区间内出现两次的点不在其路径上</strong><br>根据这个性质,可以将树转化为链来求解了</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>除了将树转化为欧拉序之外,还需要求出左右端点的$LCA$,以及一个点$\texttt{u}$在欧拉序中第一次出现的位置$\texttt{fst[u]}$,第二次(最后一次)出现的位置$\texttt{lst[u]}$</p>
<p>在进行莫队操作时,如果第一次经过这个点,则<code>add</code>其贡献,第二次经过这个点,则说明这个点不在所求链上,<code>del</code>其贡献<br>这个用一个<code>vis</code>数组,反复进行异或操作就可以解决</p>
<p>再考虑询问的区间的$l,r$应该赋值为$\texttt{fst}$还是$\texttt{lst}$<br>设左端点的深度小于右端点</p>
<ol>
<li>如果$LCA$和左端点相等,则说明$[l,r]$在一条链上,$l$和$r$均取$\texttt{fst}$即可</li>
<li>否则是两条链$[l, LCA],[LCA,r]$, 防止左右端点被统计两次导致贡献被删除,需要$l$取$\texttt{lst}$,$r$取$\texttt{fst}$</li>
</ol>
<p>最后考虑贡献</p>
<ol>
<li>若是上面第一种情况,在一条链上,直接统计欧拉序区间内所有点即可,重复两次的根据前文的性质会直接删掉</li>
<li>若是上面第二种情况,由于左右端点都在$LCA$这颗子树内,所以区间中并不会出现$LCA$,但是却一定会经过,所以额外将$LCA$加入贡献,并且记录下当前结果之后,再将其贡献减去,防止影响下一个查询</li>
</ol>
<p><strong>注意:</strong> 转化为欧拉序之后的序列长度为$2n$</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol>
<li><code>dfs</code>: $O(n)$</li>
<li>求$LCA$:$O(n\log n)$</li>
<li>莫队: $O(n\sqrt{n})$</li>
</ol>
<p>综上,树上莫队的复杂度 <del>差不多</del> 也是$O(n\sqrt{n})$</p>
<h2 id="针对-mathcal-SP10707-的具体实现"><a href="#针对-mathcal-SP10707-的具体实现" class="headerlink" title="针对$\mathcal{SP10707}$的具体实现"></a>针对$\mathcal{SP10707}$的具体实现</h2><p>没啥说的,模板题,做法全在上面了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200020</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, Ans, len, ocnt;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn], fst[maxn], lst[maxn], vis[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">int</span> ord[maxn], val[maxn], dep[maxn], fa[maxn][<span class="number">25</span>], old[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, pos, lca;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">if</span> (a.pos &amp; <span class="number">1</span>) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    <span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> f, <span class="keyword">int</span> t): <span class="built_in">from</span>(f), <span class="built_in">to</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(f, t));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(t, f));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[t].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">    G[f].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    ord[++ocnt] = u; fst[u] = ocnt;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == f) <span class="keyword">continue</span>;</span><br><span class="line">        dep[e.to] = dep[u] + <span class="number">1</span>;</span><br><span class="line">        fa[e.to][<span class="number">0</span>] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j) &#123;</span><br><span class="line">            fa[e.to][j] = fa[fa[e.to][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(e.to, u);</span><br><span class="line">    &#125;</span><br><span class="line">    ord[++ocnt] = u; lst[u] = ocnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[fa[y][i]] &gt;= dep[x]) y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i]) &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">            y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[val[x]]--;</span><br><span class="line">    <span class="keyword">if</span> (!cnt[val[x]]) Ans--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[val[x]]++;</span><br><span class="line">    <span class="keyword">if</span> (cnt[val[x]] == <span class="number">1</span>) Ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x]) <span class="built_in">add</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">del</span>(x);</span><br><span class="line">    vis[x] ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(<span class="number">2</span> * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) old[i] = val[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n); <span class="keyword">int</span> len_ = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) val[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len_, val[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="built_in">add</span>(<span class="built_in">read</span>(), <span class="built_in">read</span>()); </span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> il = <span class="built_in">read</span>(), ir = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> LCA = <span class="built_in">lca</span>(il, ir);</span><br><span class="line">        <span class="keyword">if</span> (fst[il] &gt; fst[ir]) <span class="built_in">swap</span>(il, ir);</span><br><span class="line">        <span class="keyword">if</span> (il == LCA) &#123;</span><br><span class="line">            q[i].l = fst[il]; q[i].r = fst[ir];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            q[i].l = lst[il]; q[i].r = fst[ir]; q[i].lca = LCA;</span><br><span class="line">        &#125;</span><br><span class="line">        q[i].id = i; q[i].pos = (q[i].l - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">chg</span>(ord[l++]);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">chg</span>(ord[r--]);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">chg</span>(ord[--l]);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">chg</span>(ord[++r]);</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca) <span class="built_in">chg</span>(q[i].lca);</span><br><span class="line">        ans[q[i].id] = Ans;</span><br><span class="line">        <span class="keyword">if</span> (q[i].lca) <span class="built_in">chg</span>(q[i].lca);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>回滚莫队-笔记  /「AtCoder 1219」歴史の研究-题解</title>
    <url>/p/7d7b5548.html</url>
    <content><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/AT1219">AtCoder 1219 歴史の研究</a>这道题目来学习一下 <strong>回滚莫队</strong><br><strong>回滚莫队</strong> 适用于容易进行<code>add</code>操作,而不容易实现<code>del</code>的情况</p>
<p>通过莫队的分块,指针移动的思想,可以让左指针进行回滚操作, <em>近似</em> 达到<code>del</code>的效果</p>
<span id="more"></span>

<h2 id="回滚莫队"><a href="#回滚莫队" class="headerlink" title="回滚莫队"></a>回滚莫队</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>由于莫队对所有询问离线排序后,当左端点在同一个块内时,右端点递增<br>所以对于每个块,右指针直接向右依次执行<code>add</code>操作即可</p>
<p>对于左指针,在一个块内时,可以每次都从块的右边界向左进行<code>add</code>,由于不方便进行<code>del</code>操作,所以可以先记录下左指针在右边界时的<code>Ans</code>,然后每次向左移动到<code>q[i].l</code>时,将左指针再移回右边界,并且将<code>Ans</code>回滚到移动之前的值。由于分块,这样做的复杂度也不会很大</p>
<p>综上,对于每个块,<strong>右指针依次向右推进,左指针在右边界和查询的左端点之间反复横跳</strong><br>这样,执行的就只剩<code>add</code>操作,通过左指针的横跳,避免了<code>del</code>操作</p>
<p>注意,当左右端点都在同一个块时,只要暴力求出结果就可以了<br><strong>一定要注意</strong>: 不要使用奇偶排序,必须保证右端点的 <strong>单调递增</strong></p>
<p>对于每个块内的处理,大概如下图:<br><img src="/p/7d7b5548/RollBackMosAlgo.png" alt="橙色箭头:左指针的移动 蓝色箭头:右指针的移动"></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度由以下几个方面组成</p>
<ol>
<li>询问排序</li>
<li>同一个块内的暴力求解</li>
<li>左指针的移动(<del>横跳</del>)</li>
<li>右指针的顺次移动</li>
</ol>
<p>下面来 <del>不严谨</del> 简要地计算一下时间复杂度</p>
<ol>
<li><strong>排序</strong>:$O(n\log n)$</li>
<li><strong>暴力</strong>:暴力的区间最长为$\sqrt{n}$,所以单次暴力的复杂度为$O(\sqrt{n})$,$n$次暴力的复杂度为$O(n\sqrt{n})$<del>其实到不了n次</del></li>
<li><strong>左指针移动</strong>: 进行<code>add</code>操作的复杂度为$O(1)$,块长$\sqrt{n}$,每次左移最坏复杂度$O(\sqrt{n})$,回滚时仍需要$O(\sqrt{n})$清除贡献<br>所以对于所有块,一共要移动$q$次,总的复杂度为$O(2q\sqrt{n})$</li>
<li><strong>右指针移动</strong>: 对于每个块,最坏只要移动$n$次,一共$\sqrt{n}$个块,所以复杂度为$O(n\sqrt{n})$</li>
</ol>
<p>综上,总的复杂度为$O(n\log n)+O(2q\sqrt{n})+O(n\sqrt{n})\ \sim\ O(n\sqrt{n})$</p>
<h2 id="针对-mathcal-AT1219-的具体实现"><a href="#针对-mathcal-AT1219-的具体实现" class="headerlink" title="针对$\mathcal{AT1219}$的具体实现"></a>针对$\mathcal{AT1219}$的具体实现</h2><p>添加贡献的<code>add</code>操作很容易实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">    Ans = <span class="built_in">max</span>(Ans, <span class="number">1LL</span> * cnt[a[x]] * old[a[x]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同一块内的暴力也很容易实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) cnt2[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        cnt2[a[i]]++;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1LL</span> * cnt2[a[i]] * old[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余情况下根据前面所说,可以实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);  <span class="comment">// 右指针右移,添加贡献</span></span><br><span class="line">LL tmp = Ans;                 <span class="comment">// 记录左指针移动前的答案</span></span><br><span class="line"><span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);  <span class="comment">// 左指针左移,添加贡献</span></span><br><span class="line">ans[q[i].id] = Ans;</span><br><span class="line"><span class="keyword">while</span> (l &lt; rpos[k] + <span class="number">1</span>) cnt[a[l++]]--; <span class="comment">// 左指针移动回右边界,并途中删除对cnt的贡献</span></span><br><span class="line">Ans = tmp;                    <span class="comment">// 回滚到移动前的答案</span></span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, len, l, r;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[maxn], rpos[maxn], old[maxn], cnt2[maxn];</span><br><span class="line">LL Ans, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, id, pos;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) cnt2[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        cnt2[a[i]]++;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1LL</span> * cnt2[a[i]] * old[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">    Ans = <span class="built_in">max</span>(Ans, <span class="number">1LL</span> * cnt[a[x]] * old[a[x]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(n); <span class="keyword">int</span> num = <span class="built_in">ceil</span>((<span class="keyword">double</span>)n / len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; ++i) rpos[i] = len * i; rpos[num] = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) old[i] = a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> len_ = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len_, a[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(); q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i; q[i].pos = (q[i].l - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>, i = <span class="number">1</span>; k &lt;= num; ++k) &#123;</span><br><span class="line">        l = rpos[k] + <span class="number">1</span>, r = rpos[k], Ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">        <span class="keyword">while</span> (q[i].pos == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q[i].l / len == q[i].r / len) &#123;</span><br><span class="line">                ans[q[i].id] = <span class="built_in">solve</span>(q[i].l, q[i].r);</span><br><span class="line">                i++; <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">            LL tmp = Ans;</span><br><span class="line">            <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">            ans[q[i].id] = Ans;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; rpos[k] + <span class="number">1</span>) cnt[a[l++]]--;</span><br><span class="line">            Ans = tmp; i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>带修莫队-笔记  /「Luogu P1903」数颜色-题解</title>
    <url>/p/838c5e29.html</url>
    <content><![CDATA[<p>通过<a href="https://www.luogu.com.cn/problem/P1903">Luogu P1903 数颜色/维护序列</a>这道题目来学习一下 <strong>带修莫队</strong><br>顾名思义,<strong>带修莫队</strong> 不仅要支持普通莫队的查询操作,还要支持数据中途的修改</p>
<p>比如这道题目,需要实现以下目标</p>
<ol>
<li>查询$[L,R]$区间内不同颜色画笔的种数</li>
<li>将$pos$处的画笔替换为$color$颜色</li>
</ol>
<p>达到这个目标,可以在普通莫队的基础上加一个时间维度,实现 <strong>带修莫队</strong></p>
<span id="more"></span> 

<h2 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h2><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>这里的每个查询的时间戳规定为 <strong>最近修改操作的时间戳</strong>,即最近一次修改是第几次修改<br>修改操作会增加总时间戳,查询操作不会增加时间戳</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>在普通莫队的左右两个指针的基础之上 <em>增加</em> 一个 <strong>时间戳指针</strong><br>当左右端点及时间戳移动到均和当前查询的一致,就可以记录下当前答案</p>
<p>所以需要在普通莫队的基础之上加上修改时间戳的修改操作,并加上以下两个判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (t &lt; q[i].t) <span class="built_in">chg</span>(++t);</span><br><span class="line"><span class="keyword">while</span> (t &gt; q[i].t) <span class="built_in">chg</span>(t--);</span><br></pre></td></tr></table></figure>
<p>当当前时间小于询问时间时,先将当前时间$+1$,再修改<br>当当前时间大于询问时间时,先修改,再将当前时间$-1$</p>
<p>与普通莫队还有一点不同:<br>所有询问的排序方法,先按照左端点分块升序,再按照右端点 <strong>分块升序</strong>,最后按照时间戳升序<br>这样复杂度才会达到最优,节省了一系列不必要的操作</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>当分块的大小为$n^{\frac{2}{3}}$时,复杂度最小为$O(n^{\frac{5}{3}})$<br>具体分析见上一篇文章:<a href="681257d9.html">浅析莫队算法的时间复杂度</a></p>
<h2 id="针对-mathcal-P1903-的具体实现"><a href="#针对-mathcal-P1903-的具体实现" class="headerlink" title="针对$\mathcal{P1903}$的具体实现"></a>针对$\mathcal{P1903}$的具体实现</h2><p>在每个询问<code>Query</code>的结构体内加一个时间戳$t$,并且按照上文实现排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block[a.l] != block[b.l]) <span class="keyword">return</span> block[a.l] &lt; block[b.l];</span><br><span class="line">    <span class="keyword">if</span> (block[a.r] != block[b.r]) <span class="keyword">return</span> block[a.r] &lt; block[b.r];</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再建一个结构体<code>Change</code>,表示每次修改操作的数据,需要$pos$和$color$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, color;</span><br><span class="line">&#125;c[maxn];</span><br></pre></td></tr></table></figure>

<p>正常的<code>add/del</code>操作不再赘述<br>现在来看一下修改时间对应数据的操作</p>
<ol>
<li>当当前时间的操作的位置$pos$在当前区间$[l,r]$时,对答案有影响,需要调整当前答案<br>先将$pos$位置上的贡献删去,再将当前修改操作的$color$添加进去</li>
<li>将$pos$位置上的数与$color$交换,这样可以保证之后可以再换回来</li>
</ol>
<p>实现如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[a[c[t].pos]] == <span class="number">0</span>) Ans--; <span class="comment">// 删除贡献</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[c[t].color]++  == <span class="number">0</span>) Ans++; <span class="comment">// 添加贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].color); <span class="comment">// 交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外这题修改数据后严重卡常,手动开了O3,Ofast,inline才过</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">140000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, t, len, cntq, cntr, Ans;</span><br><span class="line"><span class="keyword">int</span> a[maxn], cnt[<span class="number">1000010</span>], ans[maxn], block[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, t, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (block[a.l] != block[b.l]) <span class="keyword">return</span> block[a.l] &lt; block[b.l];</span><br><span class="line">    <span class="keyword">if</span> (block[a.r] != block[b.r]) <span class="keyword">return</span> block[a.r] &lt; block[b.r];</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, color;</span><br><span class="line">&#125;c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == <span class="number">0</span>) Ans++;</span><br><span class="line">    cnt[a[x]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt[a[x]] == <span class="number">1</span>) Ans--;</span><br><span class="line">    cnt[a[x]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">chg</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) &#123;</span><br><span class="line">        <span class="built_in">del</span>(c[t].pos);</span><br><span class="line">        <span class="keyword">if</span> (cnt[c[t].color] == <span class="number">0</span>) Ans++;</span><br><span class="line">        cnt[c[t].color]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        block[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> opt[<span class="number">10</span>]; <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            q[++cntq].l = <span class="built_in">read</span>(); q[cntq].r = <span class="built_in">read</span>();</span><br><span class="line">            q[cntq].id = cntq; q[cntq].t = cntr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[++cntr].pos = <span class="built_in">read</span>();</span><br><span class="line">            c[cntr].color = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + cntq, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q[i].t) <span class="built_in">chg</span>(++t);</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q[i].t) <span class="built_in">chg</span>(t--);</span><br><span class="line">        ans[q[i].id] = Ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析莫队算法的时间复杂度</title>
    <url>/p/681257d9.html</url>
    <content><![CDATA[<p>这篇文章来记录一下莫队算法时间复杂度的简单(<del>不严谨</del>)计算</p>
<p>首先分析一下莫队算法的时间复杂度有哪些方面构成</p>
<ol>
<li>对询问<code>Query</code>数组的排序</li>
<li>区间左指针的移动</li>
<li>区间右指针的移动<span id="more"></span> </li>
</ol>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>每个<code>add/del</code>操作的复杂度为$O(1)$</p>
<ol>
<li><p>排序使用<code>sort</code>可以在$O(n\log n)$内完成</p>
</li>
<li><p>由于左指针在排序中被分块,所以又分为块内移动和块间移动</p>
<ul>
<li><strong>块内</strong>: 设每块中含左端点$x_i$个,由于每块大小为$\sqrt{n}$,所以在块内移动的最坏复杂度为$O(x_i\sqrt{n})$。<br>因此对于所有块,将复杂度求和,即为$O(\displaystyle\sum_ix_i\sqrt{n})=O(n\sqrt{n})$</li>
<li><strong>块间</strong>: 左指针在每个块内移动之后,需要移动到下一个块内的左端点处,块间跳转最坏跨两个整块需要$O(2\sqrt{n})$。<br>总共需要跨$\sqrt{n}-1$个块,所以复杂度为$O((\sqrt{n}-1)\times 2\sqrt{n})\sim O(n)$</li>
</ul>
</li>
</ol>
<p>综上,左指针移动的复杂度为$O(n\sqrt{n})$<br>3. 当左指针在同一个块内时,右指针是有序的,因此当左指针在同一个块内时,右指针移动的最坏复杂度为$O(n)$即全部移动一遍。而每个块长度为$\sqrt{n}$,总长为$n$,所以一共$\sqrt{n}$个块,所以最坏复杂度为$O(n\sqrt{n})$</p>
<p>综上,普通莫队算法的时间复杂度为<br>$$<br>O(n\log n)+O(n\sqrt{n})+O(n\sqrt{n})\ \sim\ O(n\sqrt{n})<br>$$</p>
<h2 id="玄学的奇偶排序优化"><a href="#玄学的奇偶排序优化" class="headerlink" title="玄学的奇偶排序优化"></a><del>玄学</del>的奇偶排序优化</h2><p>见图:<br><img src="/p/681257d9/MosAlgoCompare.png" alt="左:无奇偶排序,右:有奇偶排序&lt;/br&gt;图中灰色虚线表示分块的边界;带端点的线段表示需要询问的区间;红色箭头表示两种方法右指针移动相同长度的部分;蓝色箭头表示不同的部分。可以看出,有奇偶排序的蓝色箭头变短,避免了无意义的大幅度跳动,节省了一些常数复杂度"></p>
<h2 id="分块大小不为-sqrt-n"><a href="#分块大小不为-sqrt-n" class="headerlink" title="分块大小不为$\sqrt{n}$"></a>分块大小不为$\sqrt{n}$</h2><p>还是和前面一样推复杂度,设块大小为$a&gt;1$</p>
<ol>
<li><strong>排序</strong>: 需要$O(n\log n)$</li>
<li><strong>左指针移动</strong>: <ul>
<li><strong>块内</strong>: $O(\displaystyle\sum_ix_ia)=O(na)$</li>
<li><strong>块间</strong>: $O((\dfrac{n}{a}-1)\times 2a)=O(n)$</li>
</ul>
</li>
<li><strong>右指针移动</strong>: $O(n\times \dfrac{n}{a})=O(\dfrac{n^2}{a})$</li>
</ol>
<p>综上,总的复杂度为$O(n\log n)+O(na)+O(n)+O(\dfrac{n^2}{a})=O(na+\dfrac{n^2}{a})$<br>根据均值不等式,若让上式复杂度最小,则需要$na=\dfrac{n^2}{a}$,即$a=\sqrt{n}$<br>所以当含有左右两个指针时,分块大小为$\sqrt{n}$时总复杂度最小,为$O(n\sqrt{n})$</p>
<h2 id="带修莫队-三指针"><a href="#带修莫队-三指针" class="headerlink" title="带修莫队(三指针)"></a>带修莫队(三指针)</h2><p>还是设分块的大小为$a&gt;1$,注意带修莫队排序优先级:先左端点所在块,再右端点所在块,后时间戳大小</p>
<ol>
<li><strong>排序</strong>: $O(n\log n)$</li>
<li><strong>左指针移动</strong>: 同上推导,复杂度为$O(na)$</li>
<li><strong>右指针移动</strong>: 相同右端点的块的复杂度同上$O(na)$,还有换左端点决定的块时的复杂度约为$O(\dfrac{n^2}{a})$</li>
<li><strong>时间戳移动</strong>: 由排序优先级可见,只有当右端点所在块相同时才会移动时间戳,而每次移动最坏需要移动$\sum t \sim n$<br>对于每个左端点相同的块,右端点块数为$\dfrac{n}{a}$,左端点有$\dfrac{n}{a}$个,所以一共需要$O(\dfrac{n}{a}\times\dfrac{n}{a}\times n)=O(\dfrac{n^3}{a^2})$</li>
</ol>
<p>综上,总的复杂度为$O(n\log n)+O(na)+O(na)+O(\dfrac{n^2}{a})+O(\dfrac{n^3}{a^2})\ \sim\  O(na+\dfrac{n^2}{a}+\dfrac{n^3}{a^2})$</p>
<p>由于$1&lt;a&lt;n$,所以$\dfrac{\dfrac{n^2}{a}}{\dfrac{n^3}{a^2}}=\dfrac{a}{n}&lt;1 \Rightarrow \dfrac{n^2}{a}&lt;\dfrac{n^3}{a^2}$,所以原式可化为$O(na+\dfrac{n^3}{a^2})$</p>
<p>根据均值不等式,当$na=\dfrac{n^3}{a^2}$时上式最小,即$a=\sqrt[3]{n^2}=n^{\frac{2}{3}}$<br>所以含有三个指针时,分块大小为$n^{\frac{2}{3}}$时总复杂度最小,为$O(n^{\frac{5}{3}})=O(n\sqrt[3]{n^2})$</p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」总结及图示</title>
    <url>/p/dccbc6bb.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center">问题编号</th>
<th align="left">问题名称</th>
<th align="left">问题模型</th>
<th align="left">转化模型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2756">飞行员配对方案问题</a></td>
<td align="left">二分图最大匹配</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2762">太空飞行计划问题</a></td>
<td align="left">最大权闭合图</td>
<td align="left">网络最小割</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2764">最小路径覆盖问题</a></td>
<td align="left">有向无环图最小路径覆盖</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2765">魔术球问题</a></td>
<td align="left">有向无环图最小路径覆盖</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3254">圆桌问题</a></td>
<td align="left">二分图多重匹配</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2766">最长不下降子序列问题</a></td>
<td align="left">最多不相交路径</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">7</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2763">试题库问题</a></td>
<td align="left">二分图多重匹配</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">8</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2775">机器人路径规划问题</a></td>
<td align="left">$IDA*$</td>
<td align="left">$IDA*$</td>
</tr>
<tr>
<td align="center">9</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2774">方格取数问题</a></td>
<td align="left">二分图点权最大独立集</td>
<td align="left">网络最小割</td>
</tr>
<tr>
<td align="center">10</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P1251">餐巾计划问题</a></td>
<td align="left">线性规划网络优化</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">11</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2770">航空路线问题</a></td>
<td align="left">最长不相交路径</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">12</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2761">软件补丁问题</a></td>
<td align="left">最小转移代价</td>
<td align="left">最短路径</td>
</tr>
<tr>
<td align="center">13</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P2754">星际转移问题</a></td>
<td align="left">网络判定</td>
<td align="left">网络最大流</td>
</tr>
<tr>
<td align="center">14</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4011">孤岛营救问题</a></td>
<td align="left">分层图最短路径</td>
<td align="left">最短路径</td>
</tr>
<tr>
<td align="center">15</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4009">汽车加油行驶问题</a></td>
<td align="left">分层图最短路径</td>
<td align="left">最短路径</td>
</tr>
<tr>
<td align="center">16</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4013">数字梯形问题</a></td>
<td align="left">最大权不相交路径</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">17</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4015">运输问题</a></td>
<td align="left">网络费用流量</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">18</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4014">分配问题</a></td>
<td align="left">二分图最佳匹配</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">19</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4016">负载平衡问题</a></td>
<td align="left">最小代价供求</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">20</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P4012">深海机器人问题</a></td>
<td align="left">线性规划网络优化</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">21</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3358">最长k可重区间集问题</a></td>
<td align="left">最大权不相交路径</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">22</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3357">最长k可重线段集问题</a></td>
<td align="left">最大权不相交路径</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">23</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3356">火星探险问题</a></td>
<td align="left">线性规划网络优化</td>
<td align="left">最小费用最大流</td>
</tr>
<tr>
<td align="center">24</td>
<td align="left"><a href="https://www.luogu.com.cn/problem/P3355">骑士共存问题</a></td>
<td align="left">二分图最大独立集</td>
<td align="left">网络最小割</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><ul>
<li><strong>最大匹配</strong>: 匈牙利/最大流</li>
<li><strong>带权匹配</strong>: KM/费用流</li>
<li><strong>最小点覆盖</strong>: =最大匹配</li>
<li><strong>最小边覆盖</strong>: =总结点数-最大匹配</li>
<li><strong>最大独立集</strong>: =总结点数-最大匹配</li>
</ul>
<h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul>
<li>建立超级源点,超级汇点</li>
<li>点存在限制,拆成出入点,将出入点之间的边看做点,限制流量</li>
<li>建图考虑左右二部</li>
<li>超级源点向源点的边可以限制总流量</li>
<li>无源汇有容量下界:<code>s-下界-&gt;v  u-下界-&gt;t  u-上界减下界-&gt;v</code>,当满流时存在可行流</li>
<li>最小割中赋流量为inf则一定不会割去</li>
<li>一些求最大问题,可以用sum-最小割</li>
<li>最大权闭合图: 建图,最小割,仍和s相连的为最大权闭合图,权值和为sum-最小割</li>
</ul>
<h3 id="24题"><a href="#24题" class="headerlink" title="24题"></a>24题</h3><ol>
<li>直接建二分图,最大流求最大匹配</li>
<li>最大权闭合图,建边,实验和仪器之间保证不切割容量为inf,跑最小割,找与s相连的实验和仪器</li>
<li>最大独立集,总结点数-最大流</li>
<li>贪心</li>
<li>二分图多重匹配,s-&gt;左点集和右点集-&gt;t之间的边容量不为1(即可以选多次)</li>
<li>动态规划+按照动态规划的dp数组的意义建边求最大流</li>
<li>二分图多重匹配,类型-题目数-&gt;汇点,保证可选多个,存在满流则存在答案沿满流输出</li>
<li>$IDA*$爆搜,但洛谷数据应该有问题</li>
<li>抽象出两个点集,求最大独立集</li>
<li>按照题目说明建图,跑费用流</li>
<li>按照题目说明建图,跑费用流</li>
<li>将错误状态进行压缩,然后跑最短路</li>
<li>根据时间逐层建图,直到跑出可行流</li>
<li>将拥有钥匙进行压缩,跑最短路</li>
<li>建出分层图,跑最短路或者费用流</li>
<li>对三个规则分别建图,跑费用流</li>
<li>纯费用流</li>
<li>二分图最佳匹配,使用费用流</li>
<li>费用流,注意环形</li>
<li>按照题目要求建图,跑费用流</li>
<li>离散化,将区间转化为边,费用流</li>
<li>转化问题,变成21题,注意端点处理和垂直于x轴的线段</li>
<li>按照题目要求建图,跑费用流,方案dfs</li>
<li>将图上所有格点转化为两个点集,建二分图,求最大独立集</li>
</ol>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><strong><del>更新中</del></strong><br><img src="/p/dccbc6bb/NF24P2762.png" alt="2"><br><img src="/p/dccbc6bb/NF24P2754.png" alt="13"><br><img src="/p/dccbc6bb/NF24P3358.png" alt="21"><br><img src="/p/dccbc6bb/NF24P3357.png" alt="22"></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1494」小Z的袜子-题解</title>
    <url>/p/49548215.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P1494">「Luogu P1494」小Z的袜子</a><br>一道推公式，后使用莫队 <del>玄学</del> 优化的题目</p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n$个袜子,第$i$只袜子的颜色为$c_i$<br>有$m$个询问,用$L,R$表示<br>在区间$[L,R]$中随机取袜子,求取出两只袜子颜色相同的概率(最简分数)</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>考虑区间$[L,R]$,其中颜色为$A$的袜子有$a$只,颜色为$B$的袜子有$b$只$…$</p>
<p>取出两只袜子的总情况数为<br>$$C_{R-L+1}^2=\frac{(R-L+1)(R-L)}{2}$$<br>取出两只袜子颜色都为$A$的情况数为<br>$$C_a^2=\frac{a(a - 1)}{2}$$<br>所以,取出两只袜子颜色相同的情况数为<br>$$\sum_{i}C_i^2=C_a^2+C_b^2+…=\frac{a(a-1)}{2}+\frac{b(b-1)}{2}+…$$<br>所以最终的概率为<br>$$<br>\begin{aligned}<br>P&amp;=\frac{\displaystyle\sum_{i}C_i^2}{C_{R-L+1}^2}\\\\<br>&amp;=\dfrac{\dfrac{a(a-1)}{2}+\dfrac{b(b-1)}{2}+…}{ \dfrac{(R-L+1)(R-L)}{2} }\\\\<br>&amp;=\dfrac{a^2+b^2+…-a-b-…}{(R-L+1)(R-L)}\\\\<br>&amp;=\dfrac{\displaystyle\sum_ii^2-\displaystyle\sum_ii}{(R-L+1)(R-L)}\\\\<br>&amp;=\dfrac{\displaystyle\sum_ii^2-(R-L+1)}{(R-L+1)(R-L)}<br>\end{aligned}<br>$$<br>所以要求的就是$\displaystyle\sum_ii^2$,可以用莫队来维护区间平方和得到</p>
<p>对于最终结果的表达式,令$a=$分子,$b=$分母,求出$ab$的最大公约数,并除去<br>最终答案即为$a/b$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123; <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, pos, id;</span><br><span class="line">&#125;q[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Query a, Query b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.pos != b.pos) <span class="keyword">return</span> a.pos &lt; b.pos;</span><br><span class="line">    <span class="keyword">if</span> (a.pos &amp; <span class="number">1</span>) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    <span class="keyword">return</span> a.r &gt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span> &#123;</span></span><br><span class="line">    LL a, b;</span><br><span class="line">&#125;ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, l, r, Ans, len;</span><br><span class="line">LL c[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Ans -= cnt[c[x]] * cnt[c[x]];</span><br><span class="line">    cnt[c[x]]--;</span><br><span class="line">    Ans += cnt[c[x]] * cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Ans -= cnt[c[x]] * cnt[c[x]];</span><br><span class="line">    cnt[c[x]]++;</span><br><span class="line">    Ans += cnt[c[x]] * cnt[c[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) c[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        q[i].l = <span class="built_in">read</span>(); q[i].r = <span class="built_in">read</span>();</span><br><span class="line">        q[i].id = i; q[i].pos = q[i].l / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + <span class="number">1</span> + m, cmp); l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            ans[q[i].id].a = <span class="number">0</span>; ans[q[i].id].b = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL a = Ans - (r - l + <span class="number">1</span>);</span><br><span class="line">        LL b = <span class="number">1LL</span> * (r - l + <span class="number">1</span>) * (LL)(r - l);</span><br><span class="line">        LL g = <span class="built_in">gcd</span>(a, b);</span><br><span class="line">        ans[q[i].id].a = a / g;</span><br><span class="line">        ans[q[i].id].b = b / g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld/%lld\n&quot;</span>, ans[i].a, ans[i].b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>莫队</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」负载平衡问题-题解</title>
    <url>/p/b8624866.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4016">「Luogu P4016」负载平衡问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$个环形的仓库,每个仓库存储一定数量的货物<br>货物可以在相邻仓库之间搬运,最终达到每个仓货物数量一样的效果</p>
<p>求最少搬运次数</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>看题解说可以用数学方法推导,但是在24题里还是选择用费用流水过</p>
<p>先求出平均数,即目标<br>然后将每个仓库的货物数减去平均数,得出需要移动的数量</p>
<ol>
<li>如果大于$0$,则从 源点 向 该仓库 建一条 <strong>容量为差值,费用为$0$</strong> 的边(需要转移出,对答案无贡献)</li>
<li>如果小于$0$,则从 该仓库 向 汇点 建一条 <strong>容量为差值绝对值,费用为$0$</strong> 的边(吸收这些货物,对答案无贡献)</li>
<li>从 每个仓库 向 相邻两个仓库 建一条 <strong>容量为$inf$,费用为$1$</strong> 的边(转移货物的数量无要求,对答案贡献为$1$)</li>
</ol>
<p>注意建边3.需要考虑环形<br>求出最小费用最大流,最小费用即为结果</p>
<p>因为费用流大前提是满足最大流,而且此图中源点出发的与流入汇点的边的容量和相等,所以最大流情况下一定会全部流过,即达到仓库货物数量平衡</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最小费用最大流模板省去了</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">110</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        num[i] = <span class="built_in">read</span>(); tot += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tot /= n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] - tot &gt; <span class="number">0</span>) <span class="built_in">add</span>(s, i, num[i] - tot, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (num[i] - tot &lt; <span class="number">0</span>) <span class="built_in">add</span>(i, t, tot - num[i], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, i - <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(i - <span class="number">1</span>, i, inf, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">1</span>, n, inf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">add</span>(n, <span class="number">1</span>, inf, <span class="number">1</span>);</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」运输问题-题解</title>
    <url>/p/152673e9.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4015">「Luogu P4015」运输问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$m$个仓库,$n$个商店,每个仓库有$a_i$个货物,每个商店需要$b_i$个货物<br>需要从仓库运输货物到商店中,且第$i$个仓库运输到第$j$个商店费用为$c_{i,j}$</p>
<p>求最小费用和最大费用</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>和<a href="http://tony031218.github.io/p/11b1dcbd.html">P4015 分配问题</a>一样<br>将所有仓库和所有商店各分为一个点集</p>
<ol>
<li>从 源点 向 每个仓库 建一条 <strong>容量为货物个数$a_i$,费用为$0$</strong> 的边(有$a_i$个货物需要运出,且对答案无贡献)</li>
<li>从 每个商店 向 汇点 建一条 <strong>容量为货物个数$b_i$,费用为$0$</strong> 的边(需要$b_i$个货物,且对答案无贡献)</li>
<li>从 每个仓库 向 每个商店 建一条 <strong>容量为$inf$,费用为对应费用</strong> 的边(每个仓库可以运出的最多货物不限制,且对答案工作为对应费用)</li>
</ol>
<p>求出最小费用最大流和最大费用最大流即可</p>
<p>由于费用流的大前提是流量最大,所以一定满足题目中要求的供需平衡即$\sum\limits_{i=1}^{m}a_i=\sum\limits_{j=1}^{n}b_j$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 费用流模板省略,在P4015题解那里有</span></span><br><span class="line"><span class="comment">// 代码里为了方便把mn调换了</span></span><br><span class="line"><span class="keyword">int</span> input1[<span class="number">110</span>], input2[<span class="number">110</span>], input3[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n + m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>(); input1[i] = c;</span><br><span class="line">        <span class="built_in">add</span>(s, i, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>(); input2[i] = c;</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, c, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="built_in">read</span>(); input3[i][j] = c;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, inf, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(s, i, input1[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(i + n, t, input2[i], <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, inf, input3[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」分配问题-题解</title>
    <url>/p/11b1dcbd.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4014">「Luogu P4014」分配问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$件工作要分配给$n$个人做<br>给出每个人做每个工件的效益$c_{i,j}$</p>
<p>求最小效益和最大效益</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>裸的最小/大费用最大流<br>将所有人和所有工作各分为一个点集</p>
<ol>
<li>从 源点 向 所有人 建一条 <strong>容量为$1$,费用为$0$</strong> 的边(只能选一次,且对答案无贡献)</li>
<li>从 所有工作 向 汇点 建一条 <strong>容量为$1$,费用为$0$</strong> 的边(只能做一次,且对答案无贡献)</li>
<li>从 每个人 向 所有工作 建一条 <strong>容量为$1$,费用为对应效益</strong> 的边(只能做一种工作,且对答案工作为对应效益)</li>
</ol>
<p>求出最小费用最大流和最大费用最大流</p>
<p>两个问之间要清空图并重建(因为求最大流过程中会修改flow)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">0</span>) <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]]; <span class="keyword">bool</span> judge;</span><br><span class="line">            <span class="keyword">if</span> (opt) judge = d[e.to] &lt; d[x] + e.cost;</span><br><span class="line">            <span class="keyword">else</span> judge = d[e.to] &gt; d[x] + e.cost;</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; judge) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!opt &amp;&amp; d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (opt &amp;&amp; d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost, <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); s = <span class="number">0</span>; t = n * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = <span class="built_in">read</span>(); tmp[i][j] = c;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, <span class="number">1</span>, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, j + n, <span class="number">1</span>, tmp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i + n, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」数字梯形问题-题解</title>
    <url>/p/86b4c1f9.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4013">「Luogu P4013」数字梯形问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>梯形的第一行有$m$个数字<br>从梯形的顶部的$m$个数字开始,在每个数字处可以沿左下或右下方向移动,形成一条从梯形的顶至底的路径。</p>
<p>有三种规则:</p>
<ol>
<li>从梯形的顶至底的$m$条路径互不相交</li>
<li>从梯形的顶至底的$m$条路径仅在数字结点处相交</li>
<li>从梯形的顶至底的$m$条路径允许在数字结点相交或边相交</li>
</ol>
<p>求每种规则下经过数字的最大总和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>很明显是 <strong>最大费用最大流</strong></p>
<h4 id="规则1"><a href="#规则1" class="headerlink" title="规则1."></a>规则1.</h4><p>路径不相交,即没有公共点,也就是每个点只能经过一次<br>将每个点拆成入点和出点,就可以通过控制出入点之间的容量控制经过次数</p>
<ol>
<li>从 源点 向 第一行的$m$个点的入点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 最后一行每个点的出点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 每个点的入点 向 每个点的出点 接一条 <strong>容量为$1$,费用为该点数字</strong> 的边(对答案贡献为该点数字)</li>
<li>从 每个点的出点 向 左下右下两个点的入点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
</ol>
<h4 id="规则2"><a href="#规则2" class="headerlink" title="规则2."></a>规则2.</h4><p>每条路径仅在数字节点相交,也就是不能有重边<br>无需拆点控制每个点经过的次数,只需给每条向左下右下的边的容量设为$1$,即只能经过一次</p>
<ol>
<li>从 源点 向 第一行的$m$个点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 最后一行每个点 接一条 <strong>容量为$inf$,费用为该点数字</strong> 的边(每个点可以使用多次)</li>
<li>从 每个点的 向 左下右下两个点 接一条 <strong>容量为$1$,费用为该点数字</strong> 的边</li>
</ol>
<h4 id="规则3"><a href="#规则3" class="headerlink" title="规则3."></a>规则3.</h4><p>边也可以重合,也就相当于没有规则,可以随意向左下右下走<br>只需将规则2.中建边3.的容量改成$inf$即可</p>
<p>对于每种情况,求出最大费用最大流,最大费用即为答案<br>注意求解规则2.3.之前要清空建的图</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大费用最大流模板部分省去了</span></span><br><span class="line"><span class="keyword">int</span> in[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="keyword">int</span> point[<span class="number">45</span>][<span class="number">45</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">read</span>(); n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            point[i][j] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 1</span></span><br><span class="line">    s = <span class="number">0</span>; t = cnt * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i] + cnt, t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(point[i][j] + cnt, point[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">add</span>(point[i][j] + cnt, point[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) </span><br><span class="line">            <span class="built_in">add</span>(point[i][j], point[i][j] + cnt, <span class="number">1</span>, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 2</span></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i], t, inf, in[n][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j], <span class="number">1</span>, in[i][j]);</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 3</span></span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) G[i].<span class="built_in">clear</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = cnt + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">add</span>(s, point[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + m - <span class="number">1</span>; ++i) <span class="built_in">add</span>(point[n][i], t, inf, in[n][i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m + i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j], inf, in[i][j]);</span><br><span class="line">        <span class="built_in">add</span>(point[i][j], point[i + <span class="number">1</span>][j + <span class="number">1</span>], inf, in[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」深海机器人问题-题解</title>
    <url>/p/cfb1d422.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4012">「Luogu P4012」深海机器人问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>一个$P\times Q$网格,机器人可以向北/东走,西南为$(0, 0)$,东北为$(Q, P)$<br>每个网格边上有生物标本,和价值<br>有$a$个起点,每个起点有不同的机器人个数<br>有$b$个终点,每个终点有不同的机器人个数作为目的地</p>
<p>求采集到生物标本的最高总价值</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>最大费用最大流</p>
<ol>
<li>每两个节点之间建一条 <strong>容量为$1$,费用为标本价值</strong> 的边,和一条 <strong>容量为$inf$,费用为$0$</strong> 的边(标本只能采集一次)</li>
<li>从 源点 向 每个起点 建一条 <strong>容量为机器人个数,费用为$0$</strong> 的边</li>
<li>从 每个终点 向 汇点 建一条 <strong>容量为机器人个数,费用为$0$</strong> 的边</li>
</ol>
<p>跑出最大费用最大流,最大费用即为结果</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">410</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p_, q_;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * q_ + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a_ = <span class="built_in">read</span>(), b_ = <span class="built_in">read</span>();</span><br><span class="line">    p_ = <span class="built_in">read</span>() + <span class="number">1</span>; q_ = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">    s = <span class="number">0</span>, t = p_ * q_ + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p_; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; q_; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j + <span class="number">1</span>), <span class="number">1</span>, w);</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j + <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q_; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; p_; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(j, i), <span class="built_in">point</span>(j + <span class="number">1</span>, i), <span class="number">1</span>, w);</span><br><span class="line">            <span class="built_in">add</span>(<span class="built_in">point</span>(j, i), <span class="built_in">point</span>(j + <span class="number">1</span>, i), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">read</span>(), x = <span class="built_in">read</span>() + <span class="number">1</span>, y = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(s, <span class="built_in">point</span>(x, y), k, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">read</span>(), x = <span class="built_in">read</span>() + <span class="number">1</span>, y = <span class="built_in">read</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">point</span>(x, y), t, r, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」孤岛营救问题-题解</title>
    <url>/p/5c532c45.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4011">「Luogu P4011」孤岛营救问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>起点为$(1,1)$,终点为$(n,m)$<br>有些格子上有若干个钥匙，两个格子之间可能有一堵墙或者一扇可以用对应钥匙打开的门<br>每次移动需要$1$个单位时间，其他动作不需要时间</p>
<p>求最少需要多少时间能从起点到达终点。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对拥有的钥匙状态进行压缩<br>从起点到终点跑bfs即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p, k;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn][maxn], key[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][<span class="number">1</span> &lt;&lt; <span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> edge[maxn][maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> keys, times;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k, <span class="keyword">int</span> t): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">keys</span>(k), <span class="built_in">times</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> skey = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[<span class="number">1</span>][<span class="number">1</span>]; ++i) skey |= (<span class="number">1</span> &lt;&lt; (key[<span class="number">1</span>][<span class="number">1</span>][i] - <span class="number">1</span>));</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">1</span>, <span class="number">1</span>, skey, <span class="number">0</span>)); vis[<span class="number">1</span>][<span class="number">1</span>][skey] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (u.x == n &amp;&amp; u.y == m) <span class="keyword">return</span> u.times;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">int</span> vx = u.x + go[k][<span class="number">0</span>], vy = u.y + go[k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (vx &lt; <span class="number">1</span> || vx &gt; n || vy &lt; <span class="number">1</span> || vy &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> e = edge[u.x][u.y][vx][vy];</span><br><span class="line">            <span class="keyword">if</span> (e &lt; <span class="number">0</span> || (e &gt; <span class="number">0</span> &amp;&amp; !(<span class="number">1</span> &lt;&lt; (e - <span class="number">1</span>) &amp; u.keys))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> vkeys = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt[vx][vy]; ++i) vkeys |= (<span class="number">1</span> &lt;&lt; (key[vx][vy][i] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">int</span> nxtkeys = u.keys | vkeys;</span><br><span class="line">            <span class="keyword">if</span> (vis[vx][vy][nxtkeys]) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">Node</span>(vx, vy, nxtkeys, u.times + <span class="number">1</span>));</span><br><span class="line">            vis[vx][vy][nxtkeys] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); p = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), x2 = <span class="built_in">read</span>(), y2 = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">int</span> g = <span class="built_in">read</span>();</span><br><span class="line">        edge[x1][y1][x2][y2] = ((g == <span class="number">0</span>) ? <span class="number">-1</span> : g);</span><br><span class="line">        edge[x2][y2][x1][y1] = edge[x1][y1][x2][y2];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = <span class="built_in">read</span>(), y1 = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">        key[x1][y1][++cnt[x1][y1]] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>bfs</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」汽车加油行驶问题-题解</title>
    <url>/p/fab3e888.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P4009">「Luogu P4009」汽车加油行驶问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个$N\times N$的网格,表示有加油站的位置<br>汽车要从$(1, 1)$走到$(N, N)$,装满油可以行驶$K$条边,且只能沿边行驶<br>服从以下规则</p>
<ol>
<li>可以无费用向右或向下走,但耗1点油</li>
<li>向左走或者向上走时需要付费用$B$,并耗1点油</li>
<li>在加油站处,若油没满,则必须付费用$A$,加满油</li>
<li>可在没有加油站的位置开设加油站,费用$C$,并加满油,付费$A$</li>
<li>在起点处,油量为$K$</li>
</ol>
<p>求出最小费用</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>明显是最小费用最大流(其实分层图最短路也可以解决,因为每条边的容量都为1)<br>分层建图,每层表示油量,第$0$层表示满油($K$),第$1$层表示油量为$K-1$,第$2$层表示油量为$K-2$,$…$</p>
<ol>
<li>对于每层每个节点,如果不是加油站,则从 该点 向 下一层的右边和下边的节点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边(规则1.)</li>
<li>对于每层每个节点,如果不是加油站,则从 该点 向 下一层的左边和上边的节点 接一条 <strong>容量为$1$,费用为$B$</strong> 的边(规则2.)</li>
<li>对于每个节点,如果是加油站,则从 第$0$层的该点 按照上两条建边</li>
<li>对于每个节点,如果是加油站,则从 除$0$层外的每层节点 向 第$0$层的该点 接一条 <strong>容量为$1$,费用为$A$</strong> 的边(规则3.)</li>
<li>对于每个节点,如果不是加油站,则从 第$K$层的该点 向 第$0$层的该点 接一条 <strong>容量为$1$,费用为$A+C$</strong> 的边(规则4.)</li>
<li>从 源点 向 第$0$层的$(1, 1)$节点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边</li>
<li>从 每层的$(N, N)$节点 向 汇点 接一条 <strong>容量为$1$,费用为$0$</strong> 的边(到终点不考虑油量)</li>
</ol>
<p>求出最小费用最大流即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, A, B, C;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * N + y + dep * N * N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = <span class="built_in">read</span>(); K = <span class="built_in">read</span>(); A = <span class="built_in">read</span>(); B = <span class="built_in">read</span>(); C = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; n = (K + <span class="number">1</span>) * N * N; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (in[i][j]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j, <span class="number">0</span>), <span class="number">1</span>, A);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; K; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (in[i][j] &amp;&amp; k) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i + <span class="number">1</span>, j, k + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j + <span class="number">1</span>, k + <span class="number">1</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i - <span class="number">1</span>, j, k + <span class="number">1</span>), <span class="number">1</span>, B);</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, k), <span class="built_in">point</span>(i, j - <span class="number">1</span>, k + <span class="number">1</span>), <span class="number">1</span>, B);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in[i][j]) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j, K), <span class="built_in">point</span>(i, j, <span class="number">0</span>), <span class="number">1</span>, A + C);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="built_in">point</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= K; ++k) &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">point</span>(N, N, k), t, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长k可重线段集问题-题解</title>
    <url>/p/f48af49a.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3357">「Luogu P3357」最长k可重线段集问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个开线段的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开线段,组成集合$\mathbf{S}$<br>使对于任何一条直线$x=p$,满足$\mathbf{S}$中与$x=p$相交的线段数不超过$k$,且$\mathbf{S}$中开线段总长度最大</p>
<p>求最大的长度</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>和<a href="https://www.luogu.com.cn/problem/P3358">「Luogu P3358」最长k可重区间集问题</a>类似<br>仅修改一下区间的输入部分即可</p>
<p>将每条线段映射到x轴上,发现可能不对,因为可能会存在垂直于x轴的线段,像P3358一样建图会省略掉这条线段</p>
<p>所以要将每个点扩大一倍,将左右端点x坐标相同的区间$(x, x)$更改为$(2x, 2x+1)$,使得不存在与x轴垂直的线段<br>如果左右端点x坐标不相同,则将$(x_1, x_2)$更改为$(2x_1+1, 2x_2)$</p>
<p>大概就是这么个道理:<br><img src="/p/f48af49a/NF24P3357.png"></p>
<p>剩下的做法和<a href="https://www.luogu.com.cn/problem/P3358">P3358</a>一样,<a href="https://tony031218.github.io/2020/04/21/%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E6%9C%80%E9%95%BFk%E5%8F%AF%E9%87%8D%E5%8C%BA%E9%97%B4%E9%9B%86%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/">P3358题解</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;inter[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1020</span>], old[<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">long</span> <span class="keyword">long</span>)(a - c) * (a - c) + (<span class="keyword">long</span> <span class="keyword">long</span>)(b - d) * (b - d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_ = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">        inter[i].len = <span class="built_in">length</span>(a, b, c, d);</span><br><span class="line">        inter[i].l = a * <span class="number">2</span>;</span><br><span class="line">        inter[i].r = c * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == c) inter[i].r += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> inter[i].l += <span class="number">1</span>;</span><br><span class="line">        nums[i * <span class="number">2</span> - <span class="number">1</span>] = inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span>] = inter[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) old[i] = nums[i];</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) nums[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len, nums[i]) - old;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = nums[i * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        inter[i].r = nums[i * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; n = len + <span class="number">2</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(inter[i].l, inter[i].r, <span class="number">1</span>, inter[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长k可重区间集问题-题解</title>
    <url>/p/949e7ebf.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3358">「Luogu P3358」最长k可重区间集问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个开区间的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开区间,组成集合$\mathbf{S}$<br>使对于任何一个$x$,满足$\mathbf{S}$中包含$x$的区间数不超过$k$,且$\mathbf{S}$中开区间总长度最大</p>
<p>求最大的长度</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>如果两个区间没有重叠的话,则可以同时选择,在图上表现为串联<br>如果两个区间有重叠的话,则不能同时选择,在图上表现为并联(服从总流量的约束)<br>先对所有节点进行离散化,注意离散化前统计出区间的长</p>
<ol>
<li>从 源点 向 节点1 接一条 <strong>容量为$k$,费用为$0$</strong> 的边(最大容量为k,对答案无贡献)</li>
<li>从 每个节点$i$ 向 节点$i+1$ 接一条 <strong>容量为$inf$,费用为$0$</strong> 的边(可以随意通过,对答案无贡献)</li>
<li>从 最后一个节点 向 汇点 接一条 <strong>容量为$inf$,费用为$0$</strong> 的边(总流量有1.控制,对答案无贡献)(可以包含在2.里)</li>
<li>从 每个区间的左端点 向 其右端点 接一条 <strong>容量为$1$,费用为区间长</strong> 的边(只可用一次,对答案贡献为区间长度)</li>
</ol>
<p>求出最大费用最大流,最大费用即为最终的结果<br>样例的图如下:<br><img src="/p/949e7ebf/NF24P3358.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interval</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, len;</span><br><span class="line">&#125;inter[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">1020</span>], old[<span class="number">1020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_ = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = <span class="built_in">read</span>(); inter[i].r = <span class="built_in">read</span>();</span><br><span class="line">        inter[i].len = inter[i].r - inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span> - <span class="number">1</span>] = inter[i].l;</span><br><span class="line">        nums[i * <span class="number">2</span>] = inter[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) old[i] = nums[i];</span><br><span class="line">    <span class="built_in">sort</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">unique</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + n_ * <span class="number">2</span>) - old - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_ * <span class="number">2</span>; ++i) nums[i] = <span class="built_in">lower_bound</span>(old + <span class="number">1</span>, old + <span class="number">1</span> + len, nums[i]) - old;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        inter[i].l = nums[i * <span class="number">2</span> - <span class="number">1</span>];</span><br><span class="line">        inter[i].r = nums[i * <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    s = <span class="number">0</span>; n = len + <span class="number">2</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, i + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(inter[i].l, inter[i].r, <span class="number">1</span>, inter[i].len);</span><br><span class="line">    &#125;</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」火星探险问题-题解</title>
    <url>/p/e7256d1.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3356">「Luogu P3356」火星探险问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$n$辆车,$p\times q$的网格<br>为0可以通过,1有障碍不能通过,2为岩石可以采集<br>从(1, 1)开始到最右下角,只能向右或向下</p>
<p>求出使到达终点的车最多,而且采集的岩石最多的移动方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每个位置拆成入点和出点</p>
<ol>
<li>如果这个位置是$0$或$2$, 则从 入点 向 出点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
<li>如果这个位置是$2$, 则从 入点 向 出点 接一条 <strong>容量为$1$, 费用为$1$</strong> 的边</li>
<li>如果这个位置$u$的右边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
<li>如果这个位置$u$的下边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 <strong>容量为$inf$, 费用为$0$</strong> 的边</li>
</ol>
<p>跑最大费用最大流,最大流数即到达终点最多的车数<br>输出方案使用dfs,在流量网络中搜索输出路径</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], pre[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; pre[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				pre[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[pre[u]].from) &#123;</span><br><span class="line">		edges[pre[u]].flow += a[t];</span><br><span class="line">		edges[pre[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p, q;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">40</span>][<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * p + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> u, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        Edge&amp; ne = edges[G[u][i] ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (e.to == s || e.to == t || e.to == u - n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!e.flow) <span class="keyword">continue</span>;</span><br><span class="line">        e.flow--;</span><br><span class="line">        <span class="keyword">if</span> (e.to &gt; n) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(x, y, e.to, id);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nx, ny, dir;</span><br><span class="line">        <span class="keyword">if</span> (e.to == <span class="built_in">point</span>(x, y) + <span class="number">1</span>) &#123;</span><br><span class="line">            nx = x; ny = y + <span class="number">1</span>;</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nx = x + <span class="number">1</span>; ny = y;</span><br><span class="line">            dir = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id, dir);</span><br><span class="line">        <span class="built_in">dfs</span>(nx, ny, e.to + n, id);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">read</span>(); p = <span class="built_in">read</span>(); q = <span class="built_in">read</span>();</span><br><span class="line">    n = p * q; s = <span class="number">0</span>; t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            in[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">0</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, inf, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(i, j) + n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in[<span class="number">1</span>][<span class="number">1</span>] != <span class="number">1</span>) <span class="built_in">add</span>(s, <span class="number">1</span>, c, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (in[i][j + <span class="number">1</span>] != <span class="number">1</span> &amp;&amp; j + <span class="number">1</span> &lt;= p) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j) + n, <span class="built_in">point</span>(i, j + <span class="number">1</span>), inf, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (in[i + <span class="number">1</span>][j] != <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= q) <span class="built_in">add</span>(<span class="built_in">point</span>(i, j) + n, <span class="built_in">point</span>(i + <span class="number">1</span>, j), inf, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in[q][p] != <span class="number">1</span>) <span class="built_in">add</span>(<span class="built_in">point</span>(q, p) + n, t, c, <span class="number">0</span>);</span><br><span class="line">    ansflow = <span class="built_in">MaxCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="comment">// printf(&quot;%d %d\n&quot;, ansflow, anscost);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ansflow; ++i) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>manim教程系列-颜色 笔记</title>
    <url>/p/2e2c9a7.html</url>
    <content><![CDATA[<p>这篇文章是在写 <strong>manim教程系列视频</strong> 的 <em>颜色</em> 部分时做的一些笔记,包括 整个视频的结构 和 写代码时了解的一些用法的笔记<br>视频已经发布,地址:<a href="https://www.bilibili.com/video/BV1vZ4y1x7hT">BV1vZ4y1x7hT</a></p>
<span id="more"></span>

<h2 id="视频结构大纲"><a href="#视频结构大纲" class="headerlink" title="视频结构大纲"></a>视频结构大纲</h2><ol start="0">
<li><input checked disabled type="checkbox"> 开头<ul>
<li>开始,标题,展示所有要将的方法</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 颜色的表示<ul>
<li>所有<code>constants.py</code>中的颜色常量</li>
<li>使用hex表示颜色</li>
<li>使用rgb的ndarray表示颜色</li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 颜色之间的转换<ul>
<li><code>rgb_to_hex</code></li>
<li><code>hex_to_rgb</code></li>
<li><code>color_to_rgb</code></li>
<li><code>rgb_to_color</code></li>
<li><code>color_to_int_rgb</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 颜色的运算函数<ul>
<li><code>invert_color</code></li>
<li><code>color_gradient</code></li>
<li><code>interpolate_color</code></li>
<li><code>average_color</code></li>
<li><code>random_color</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 设置颜色<ul>
<li><code>Mobject</code>略,一般上色的都为<code>VMobject</code></li>
<li><code>color</code>分为<code>stroke_color</code>和<code>fill_color</code></li>
<li>传入<code>color</code>, <code>stroke_color</code>, <code>fill_color</code></li>
<li><code>set_color</code>, <code>set_stroke</code>, <code>set_fill</code>方法的<code>color</code>和<code>opacity</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 给子物体上色<ul>
<li><code>set_color</code></li>
<li><code>set_color_by_gradient</code></li>
<li><code>set_colors_by_radial_gradient</code></li>
</ul>
</li>
<li><input checked disabled type="checkbox"> 光泽与渐变色<ul>
<li><code>set_sheen</code></li>
<li><code>set_color</code>中使用列表达到渐变色</li>
</ul>
</li>
</ol>
<h2 id="一些码视频时的笔记"><a href="#一些码视频时的笔记" class="headerlink" title="一些码视频时的笔记"></a>一些码视频时的笔记</h2><ul>
<li><code>isinstance</code>函数检测对象的类型</li>
<li>对一个字符串进行format时,想要用空格补齐左边到一定个数,可以使用<code>str(...).rjust(num)</code></li>
<li>涉及到<code>Transform</code>Text的地方,在Text里面不可以有空格,需要用白色的<code>~</code>来做出伪空格</li>
<li>字符串中查找一个字符的下标可以用<code>.index(&quot; &quot;, beg=..., end=...)</code>方法来查找第一次出现的位置,第二次出现需要传入<code>beg</code>为第一次位置+1</li>
<li>manim的<code>rgb_to_color</code>函数传入的rgb的值为0<del>1,不是0</del>255</li>
<li>用for循环遍历字典键值对<code>for key, value in dic.items():</code>,遍历其中一部分<code>for key, value in list(dic.items())[1:3]</code>将键值对转化为列表,并用切片</li>
<li><code>Arrow</code>的箭头为<code>.tip</code></li>
<li><code>.keys(),.values()</code>不为列表,需要套在<code>list()</code>里面</li>
<li><code>set_colors_by_radial_gradient</code>利用中心与center的距离对颜色进行插值,radius外的所有子物体全为outer_color颜色</li>
<li>含有<code>sheen_factor</code>的物体设置渐变色后与sheen_factor无关</li>
</ul>
]]></content>
      <categories>
        <category>manim</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>manim</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」骑士共存问题-题解</title>
    <url>/p/11da5c27.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3355">「Luogu P3355」骑士共存问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$n\times n$的棋盘,$m$个障碍(骑士不能放置)<br>求最多可以放多少个骑士,不能互相攻击</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先对棋盘进行黑白二染色,$x+y$为奇数和偶数为黑和白,求二分图最大独立集</p>
<ol>
<li>从 源点 向 黑色节点 接一条 <strong>容量为1</strong> 的边</li>
<li>从 白色节点 向 汇点 接一条 <strong>容量为1</strong> 的边</li>
<li>从 每个黑色节点 向 其能攻击到的白色节点接一条 <strong>容量为$inf$</strong> 的边</li>
</ol>
<p>求出最小割即最大流,结果为$\mathtt{n\times n - m - maxflow}$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">40010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">8</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> valid[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        valid[x][y] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!valid[i][j]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(s, <span class="built_in">point</span>(i, j), <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!valid[i][j]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), t, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!((i + j) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> nx = i + go[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> ny = j + go[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;= nx &amp;&amp; nx &lt;= n &amp;&amp; <span class="number">1</span> &lt;= ny &amp;&amp; ny &lt;= n &amp;&amp; !valid[nx][ny]) &#123;</span><br><span class="line">                    <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(nx, ny), inf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n * n - m - maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」圆桌问题-题解</title>
    <url>/p/25e68a12.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P3254">「Luogu P3254」圆桌问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$m$个单位,$n$个餐桌<br>第$i$个单位的代表人数$r_i$, 第$i$张餐桌能容纳的人数$c_i$<br>同一个单位的代表不能在同一个餐桌</p>
<p>若有一种方案,输出$1$,并输出方案<br>若没有方案,输出$0$</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>二分图,左点集为单位,右点集为餐桌,求其 <strong>最大匹配</strong></p>
<ol>
<li>对于每个单位,从 这个点 向 所有餐桌 接一条 <strong>容量为1</strong> 的边(即每个餐桌只能容纳同一个单位的一个人)</li>
<li>从 源点 向 每个单位 接一条 <strong>容量为单位人数</strong> 的边(即每个单位所有人都要参加)</li>
<li>从 每个餐桌 向 汇点 接一条 <strong>容量为餐桌人数</strong> 的边</li>
</ol>
<p>如果最大流和所有单位总人数相等,则有可行方案<br>对于每个单位,输出出边满足$\mathtt{e.cap == e.flow}$的$\mathtt{e.to-m}$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">450</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">read</span>(); n = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = m + n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, j + m, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">read</span>(); tot += r;</span><br><span class="line">        <span class="built_in">add</span>(s, i, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(i + m, t, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == tot) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>; u &lt;= m; ++u) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[u][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.to != s &amp;&amp; e.cap == e.flow) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e.to - m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」方格取数问题-题解</title>
    <url>/p/40e04941.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2774">「Luogu P2774」方格取数问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$m$行$n$列的方格图,每个方格中有一个正整数<br>从方格中取数,任意两个数所在方格没有公共边<br>求取出的数的最大总和</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先选择所有方格,然后考虑删去一些方格<br>相邻$-&gt;$奇偶性不同,构成一个二分图,含有两个点集</p>
<ol>
<li>从 源点 向 点集$A$ 接一条 <strong>容量为点权</strong> 的边</li>
<li>从 点集$B$ 向 汇点 接一条 <strong>容量为点权</strong> 的边</li>
<li>从 点集$A$中每个点 向 与其相邻的在点集$B$中的点 接一条 <strong>容量为$inf$</strong> 的边(保证不被割)</li>
</ol>
<p>求出最小割即最大流即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * n + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="built_in">read</span>(); n = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n * m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">read</span>(); tot += a;</span><br><span class="line">            <span class="keyword">if</span> ((i + j) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">add</span>(s, <span class="built_in">point</span>(i, j), a);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = i + go[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = j + go[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">1</span> &lt;= nx &amp;&amp; nx &lt;= m &amp;&amp; <span class="number">1</span> &lt;= ny &amp;&amp; ny &lt;= n) &#123;</span><br><span class="line">                        <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), <span class="built_in">point</span>(nx, ny), inf);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">add</span>(<span class="built_in">point</span>(i, j), t, a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - maxflow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」航空路线问题-题解</title>
    <url>/p/6bb5462a.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2770">「Luogu P2770」航空路线问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出一个城市,$n$个点,$v$条边,每个城市有一个名字<br>从西向东按序给出名字<br>求从最西出发到达最东并返回最西(除起点外,每个城市只能访问一次)的路径</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每个城市拆成入点和出点</p>
<ol>
<li>源点为点1的入点,汇点为点n的出点</li>
<li>对于 <strong>除源点汇点</strong> 的每个点, 从 入点 向 出点 建一条 <strong>容量为1,费用为1</strong> 的边(只能经过一次,且对答案贡献为1)</li>
<li>从 点1的入点 向 点1的出点 建一条 <strong>容量为2,费用为1</strong> 的边(可以经过2次,且对答案贡献为1)</li>
<li>从 点n的入点 向 点n的出点 建一条 <strong>容量为2,费用为1</strong> 的边(可以经过2次,且对答案贡献为1)</li>
<li>对于边$&lt;u, v&gt;$, 从 u的出点 向 v的入点 建一条 <strong>容量为1,费用为0</strong> 的边(可经过1次,对答案无贡献)</li>
</ol>
<p>求 <strong>最大费用最大流</strong>, 最大流$maxflow\leq 2$</p>
<ol>
<li>若最大流为$2$, 则会有一条道路, 经过的城市数为最大费用$maxcost-2$(减去重复的源点和汇点的贡献)<br>求路径可以<ul>
<li>先一次dfs找到从1到n的所有残量为0的路径(满流$\mathtt{e.cap == e.flow}$),正序输出</li>
<li>再一次dfs找到另一条满流路径,并用vis确保没有重复城市,倒序输出(不重复输出n)</li>
</ul>
</li>
<li>若最大流为$1$, 则直接从源点到汇点有一条通路, 输出$2$, 路径为$1-&gt;n-&gt;1$</li>
<li>若最大流为$0$, 则无解$\texttt{No Solution!}$</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ninf = <span class="number">0xc0c0c0c0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0xc0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == ninf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string name[maxn];</span><br><span class="line">map&lt;string, <span class="keyword">int</span>&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    cout &lt;&lt; name[u - n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to &lt;= n &amp;&amp; e.cap == e.flow) &#123;</span><br><span class="line">            <span class="built_in">dfs1</span>(e.to + n);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[u][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to &lt;= n &amp;&amp; e.cap == e.flow &amp;&amp; !vis[e.to + n]) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(e.to + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; name[u - n] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">1</span>; t = <span class="number">2</span> * n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; name[i];</span><br><span class="line">        id[name[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        string str1, str2;</span><br><span class="line">        cin &gt;&gt; str1;</span><br><span class="line">        cin &gt;&gt; str2;</span><br><span class="line">        <span class="keyword">int</span> u = id[str1], v = id[str2];</span><br><span class="line">        <span class="keyword">if</span> (u &gt; v) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="built_in">add</span>(u + n, v, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, i + n, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(s, s + n, <span class="number">2</span>, <span class="number">1</span>); <span class="built_in">add</span>(n, t, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost - <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxflow == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">        cout &lt;&lt; name[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; name[n] &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; name[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Solution!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span> + n);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最长不下降子序列问题-题解</title>
    <url>/p/a66cf8af.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2766">「Luogu P2766」最长不下降子序列问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定正整数序列$x_1, x_2, …, x_n$ </p>
<ol>
<li>计算其 <strong>最长不下降子序列</strong> 的长度$S$</li>
<li>如果每个元素只允许使用一次,计算从给定的序列中最多可取出多少个长度为$S$的不下降子序列</li>
<li>如果允许在取出的序列中多次使用$x_1$和$x_n$,其他元素仍然只允许使用一次,则从给定序列中最多可取出多少个 <strong>不同</strong> 的长度为$S$的不下降子序列</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h4><p>动态规划<br><strong>状态转移方程</strong>:$\mathtt{f[i]=max_{1≤j&lt;i&amp;&amp;x_j≤x_i}\{f[j]+1\}}$<br><strong>初值</strong>: $\mathtt{f[0]=0}$<br><strong>结果</strong>: $\mathtt{max_{1\leq i\leq n}f[i]}$</p>
<h4 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h4><p>将每个点(索引)拆成两个点<br>应用了分层图的思想, 把图每个顶点$\mathtt{i}$按照$\mathtt{f[i]}$的不同分为了若干层<br>这样图中从$s$出发到$t$的任何一条路径都是一个满足条件的最长上升子序列<br>由于序列中每个点要不可重复地取出,需要把每个点拆分成两个点<br>单位网络的最大流就是增广路的条数,所以最大流量就是第二问结果。</p>
<ol>
<li>从 源点 向 每个$\mathtt{f[i]==1}$的点i的左点 建一条 <strong>容量为1</strong> 的边</li>
<li>从 每个点的左点 向 其右点 建一条 <strong>容量为1</strong> 的边</li>
<li>从 $\mathtt{f[i]==S}$的点i的右点 向 汇点 建一条 <strong>容量为1</strong> 的边</li>
<li>对于$j&lt;i$,若$\mathtt{x_j\leq x_i &amp;&amp; f[i] == f[j] + 1}$,则从 点j的右点 向 点i的左点 建一条 <strong>容量为1</strong> 的边</li>
</ol>
<h4 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h4><p>要求$x_1$和$x_n$可以重复使用,只需取消这两个点相关边的流量限制,求网络最大流即可</p>
<ol>
<li>从 源点 向 点1的左点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>从 点1的左点 向 点1的右点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>若$\mathtt{f[n]==S}$则从 点n的左点 向 点n的右点 建一条 <strong>容量为$inf$</strong> 的边</li>
<li>若$\mathtt{f[n]==S}$则从 点n的右点 向 汇点 建一条 <strong>容量为$inf$</strong> 的边</li>
</ol>
<p>注意判断当$n==1$时的情况(第三问答案会出现$inf$)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s, t, d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, num[<span class="number">510</span>], dp[<span class="number">510</span>], ans1, ans2, ans3; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        num[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt;= num[i] &amp;&amp; dp[j] &gt; dp[i]) dp[i] = dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i]++;</span><br><span class="line">        ans1 = <span class="built_in">max</span>(ans1, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 2</span></span><br><span class="line">    s = <span class="number">0</span>, t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dp[i] == <span class="number">1</span>) <span class="built_in">add</span>(s, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(i, i + n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dp[i] == ans1) <span class="built_in">add</span> (i + n, t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) </span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt;= num[i] &amp;&amp; dp[i] == dp[j] + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">add</span>(j + n, i, <span class="number">1</span>);</span><br><span class="line">    ans2 = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Question 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">add</span>(s, <span class="number">1</span>, inf); <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span> + n, inf);</span><br><span class="line">    <span class="keyword">if</span> (dp[n] == ans1) &#123;</span><br><span class="line">        <span class="built_in">add</span>(n, n + n, inf);</span><br><span class="line">        <span class="built_in">add</span>(n + n, t, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    ans3 = ans2 + <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」太空飞行计划问题-题解</title>
    <url>/p/f5a4cbbc.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2762">「Luogu P2762」太空飞行计划问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>有$m$个实验，每个实验只可以进行一次，但会获得相应的奖金<br>有$n$个仪器，每个实验都需要一定的仪器，每个仪器可以运用于多个实验，但需要一定的价值</p>
<p>问奖金与代价的差的最大值是多少？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><ol>
<li>从源点向每个实验建 <strong>容量为实验奖金</strong> 的边</li>
<li>从每个仪器向汇点建 <strong>容量为仪器费用</strong> 的边</li>
<li>实验向对应仪器建 <strong>容量为$inf$</strong> 的边(保证不被割)</li>
</ol>
<p>然后求最小割即最大流,只会割断 <strong>源-&gt;实验</strong> 或者 <strong>仪器-&gt;汇</strong> 的点<br>最后一次bfs后,仍和源相连的实验/仪器为要进行的实验/需要的仪器</p>
<p>最大收益为所有支付的费用之和减最大流</p>
<p>样例的建边见下图:<br><img src="/p/f5a4cbbc/NF24P2762.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> endr = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;\r&#x27;</span>) endr = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn], tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_ = <span class="built_in">read</span>(), n_ = <span class="built_in">read</span>();</span><br><span class="line">    n = m_ + n_ + <span class="number">2</span>; s = <span class="number">0</span>; t = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">read</span>(); tot += p;</span><br><span class="line">        <span class="built_in">add</span>(s, i, p);</span><br><span class="line">        <span class="keyword">char</span> tools[<span class="number">10000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(tools, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(tools));</span><br><span class="line">        cin.<span class="built_in">getline</span>(tools, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">int</span> ulen = <span class="number">0</span>, tool;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">sscanf</span>(tools + ulen, <span class="string">&quot;%d&quot;</span>, &amp;tool) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i, tool + m_, inf);</span><br><span class="line">            <span class="keyword">if</span> (tool == <span class="number">0</span>) </span><br><span class="line">                ulen++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (tool) &#123;</span><br><span class="line">                    tool /= <span class="number">10</span>;</span><br><span class="line">                    ulen++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ulen++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(i + m_, t, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">dinic</span>(s, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n_; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i + m_]) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tot - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」软件补丁问题-题解</title>
    <url>/p/2f9adffb.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2761">「Luogu P2761」软件补丁问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>$n$个错误,$m$个补丁</p>
<p>第$i$个补丁耗时$t_i$<br>使用该补丁需要软件中包含所有$B1_i$中的错误,并且不包含$B2_i$中的任何一个错误<br>该补丁可以修复错误$F1_i$,但会添加错误$F2_i$</p>
<p>找出修复所有错误的最短时间</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>错误较少,可以使用状态压缩,用2进制表示错误的修复情况(1表示未修复,0表示已修复)<br>起始状态$\texttt{111…1}$,结束状态$\texttt{000…0}$</p>
<p>每个状态当做图中的节点,即求起始状态到结束状态的最短路</p>
<p>由于补丁较少,不用连边,在最短路需要遍历边时,遍历所有补丁,并判断是否能够联通(即当前状态是否包含该补丁的$B1$,而不包含$B2$)<br>如果能够连接,则下一个状态为当前状态打上当前补丁(即修复$F1$,添加$F2$)<br>边权为当前补丁的耗时<br>使用SPFA跑最短路即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;+&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;-&#x27;</span> &amp;&amp; ch != <span class="string">&#x27;0&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLL</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> b1, b2;</span><br><span class="line">    <span class="keyword">int</span> f1, f2;</span><br><span class="line">&#125;node[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dis));</span><br><span class="line">    dis[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((u &amp; node[i].b1) == node[i].b1 &amp;&amp; (u &amp; node[i].b2) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = ((u | node[i].f1) | node[i].f2) ^ node[i].f1;</span><br><span class="line">                <span class="keyword">if</span> (dis[v] &gt; dis[u] + node[i].time) &#123;</span><br><span class="line">                    dis[v] = dis[u] + node[i].time;</span><br><span class="line">                    <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(v);</span><br><span class="line">                        vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    s = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        node[i].time = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sta = <span class="built_in">read_</span>();</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">1</span>) node[i].b1 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">2</span>) node[i].b2 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sta = <span class="built_in">read_</span>();</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">2</span>) node[i].f1 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            <span class="keyword">if</span> (sta == <span class="number">1</span>) node[i].f2 |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SPFA</span>(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[t] == inf ? <span class="number">0</span> : dis[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」家园/星际转移问题-题解</title>
    <url>/p/af442de1.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P2754">「Luogu P2754」家园/星际转移问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>1个地球,$n$个太空站,1个月球,$k$个人<br>$m$艘船,第$i$艘容纳$h_i$个人,停靠$r_i$站,分别为$S_{i,j}$,每次耗时1<br>初始人全在地球,结束人全在月球</p>
<p>求最短时间</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>先根据输入的停靠位置,建立并查集,若地月不连通,则无解,输出$0$</p>
<p>再根据时间建边,时间每增加1,增加一层,求一次最大流,添加进答案<br>当答案大于$k$时,即可全部到达月球</p>
<p>样例的建图是这样:<br><img src="/p/af442de1/NF24P2754.png"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], ans, cur[maxn];</span><br><span class="line"><span class="keyword">int</span> ufs[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ufs[x] == x) ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy) ufs[fx] = fy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> S[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); <span class="keyword">int</span> k = <span class="built_in">read</span>();</span><br><span class="line">    s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; ++i) ufs[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        S[<span class="number">0</span>][i] = <span class="built_in">read</span>(); S[i][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= S[i][<span class="number">0</span>]; ++j) &#123;</span><br><span class="line">            S[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (S[i][j] == <span class="number">-1</span>) S[i][j] = n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">1</span>) <span class="built_in">unionn</span>(S[i][j], S[i][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(s) != <span class="built_in">find</span>(t)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> time = <span class="number">1</span>; ; ++time) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">add</span>(i + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), i + time * (n + <span class="number">2</span>), inf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(n + <span class="number">1</span> + time * (n + <span class="number">2</span>), n + <span class="number">1</span> + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), inf);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (time - <span class="number">1</span>) % S[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">add</span>(S[i][tmp] + (time - <span class="number">1</span>) * (n + <span class="number">2</span>), S[i][time % S[i][<span class="number">0</span>] + <span class="number">1</span>] + time * (n + <span class="number">2</span>), S[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="built_in">dinic</span>(s, t);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= k) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」餐巾计划问题-题解</title>
    <url>/p/93562de2.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.com.cn/problem/P1251">「Luogu P1251」餐巾计划问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>在$N$天里,第$i$天需要$r_i$个餐巾</p>
<ol>
<li>可以购买餐巾,每张$p$元</li>
<li>可以将旧送快洗,$m$天,费用$f$元</li>
<li>可以将旧送慢洗,$n$天,费用$s$元</li>
<li>每天结束,可以送快洗,慢洗,保存</li>
</ol>
<p>设计最小花费</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>将每天拆成2个点(早晚),新建源点汇点(源点表示获得,汇点表示使用)</p>
<ol>
<li>每天早上的点,向汇点连 <strong>容量为$r_i$,费用为$0$</strong> 的边,表示当日需要使用</li>
<li>源点向每天晚上的点连 <strong>容量为$r_i$,费用为$0$</strong> 的边,每天晚上获得多少旧餐巾</li>
<li>源点向每天早上的点连 <strong>容量为$inf$,费用为$p$</strong> 的边,表示购买</li>
<li>每天晚上向$+m$天的早上连 <strong>容量为$inf$,费用为$f$</strong> 的边,表示快洗</li>
<li>每天晚上向$+n$天的早上连 <strong>容量为$inf$,费用为$s$</strong> 的边,表示快洗</li>
<li>每天晚上向第二天晚上连 <strong>容量为$inf$,费用为$0$</strong> 的边,表示保留</li>
</ol>
<p>跑最小费用最大流</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">4010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow, r[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">	<span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">	edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">	<span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">	G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">	G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = inf;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">	queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.<span class="built_in">push</span>(s);</span><br><span class="line">	<span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		vis[x] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			Edge&amp; e = edges[G[x][i]];</span><br><span class="line">			<span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">				d[e.to] = d[x] + e.cost;</span><br><span class="line">				p[e.to] = G[x][i];</span><br><span class="line">				a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">				<span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">					Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">					vis[e.to] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	flow += a[t];</span><br><span class="line">	cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">		edges[p[u]].flow += a[t];</span><br><span class="line">		edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">	<span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="built_in">read</span>(); s = <span class="number">0</span>; t = <span class="number">2</span> * N + <span class="number">1</span>;</span><br><span class="line">    n = t + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        r[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(s, i + N, r[i], <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">add</span>(i, t, r[i], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pr = <span class="built_in">read</span>(), t1 = <span class="built_in">read</span>(), c1 = <span class="built_in">read</span>(), t2 = <span class="built_in">read</span>(), c2 = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt;= N) <span class="built_in">add</span>(i + N, i + N + <span class="number">1</span>, inf, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i + t1 &lt;= N) <span class="built_in">add</span>(i + N, i + t1, inf, c1);</span><br><span class="line">        <span class="keyword">if</span> (i + t2 &lt;= N) <span class="built_in">add</span>(i + N, i + t2, inf, c2);</span><br><span class="line">        <span class="built_in">add</span>(s, i, inf, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MinCostMaxFlow</span>(anscost);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, anscost);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2019」题解</title>
    <url>/p/7d7252b1.html</url>
    <content><![CDATA[<pre><code>~~今年的题真是毒瘤~~,一个蒟蒻要来写题解了
</code></pre>
<p>校门外有两棵树,一棵叫括号树一棵叫树上的数,这两棵树要被一匹叫格雷的马划分开为Emiya做饭,这两棵树问:那你猜猜我们的重心在哪啊</p>
<span id="more"></span>

<h2 id="D1T1-格雷码"><a href="#D1T1-格雷码" class="headerlink" title="$D1T1$ 格雷码"></a>$D1T1$ <a href="https://www.luogu.org/problem/P5657">格雷码</a></h2><h3 id="沙雕暴力dfs-我的做法"><a href="#沙雕暴力dfs-我的做法" class="headerlink" title="沙雕暴力dfs(我的做法)"></a><del>沙雕</del>暴力<code>dfs</code>(我的做法)</h3><p>考场上真是脑残了,拿dfs模拟,忘了二分的事了,还传了四个参数<br>注意:<strong>一定要用<code>unsigned long long</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ull <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ull x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123; <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123; x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>(); &#125;</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">ull n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ull n, ull k, ull rev, ull from)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (k &lt;= (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)) - <span class="number">1LL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k, <span class="number">1LL</span>, <span class="number">0LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">1</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k - (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)), <span class="number">1LL</span>, <span class="number">1LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">1</span> &amp;&amp; from == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k - (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)), <span class="number">0LL</span>, <span class="number">1LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rev == <span class="number">0</span> &amp;&amp; from == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k - (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)), <span class="number">0LL</span>, <span class="number">1LL</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			<span class="built_in">dfs</span>(n - <span class="number">1LL</span>, k - (<span class="number">1LL</span> &lt;&lt; (n - <span class="number">1LL</span>)), <span class="number">1LL</span>, <span class="number">1LL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">dfs</span>(n, k, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 55ms 812kB */</span></span><br></pre></td></tr></table></figure>

<h3 id="二分模拟-lyd-巨佬的做法"><a href="#二分模拟-lyd-巨佬的做法" class="headerlink" title="二分模拟($lyd$巨佬的做法)"></a>二分模拟($lyd$巨佬的做法)</h3><p>考前做过一道类似的题,但可惜我忘了<br>$lyd$巨佬说他这题只做了15分钟</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> n,k;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> two[<span class="number">65</span>];</span><br><span class="line"><span class="keyword">int</span> change=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	two[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">63</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		two[i]=two[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(k&gt;=two[n<span class="number">-1</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!change)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">				change^=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			k-=two[n<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(change)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">				change^=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		n--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 57ms 928kB */</span></span><br></pre></td></tr></table></figure>

<h3 id="位运算正解"><a href="#位运算正解" class="headerlink" title="位运算正解"></a>位运算正解</h3><p>格雷码的规律就是<br>第$i$位为$k\ xor\ \lfloor\frac{k}{2}\rfloor$的第$i$位</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %llu&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    k ^= (k &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (k &gt;&gt; n &amp; <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 54ms 932kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T2-括号树"><a href="#D1T2-括号树" class="headerlink" title="$D1T2$ 括号树"></a>$D1T2$ <a href="https://www.luogu.org/problem/P5658">括号树</a></h2><p>后面的先咕着,等着补</p>
<h2 id="D1T3-树上的数"><a href="#D1T3-树上的数" class="headerlink" title="$D1T3$ 树上的数"></a>$D1T3$ <a href="https://www.luogu.org/problem/P5659">树上的数</a></h2><h2 id="D2T1-Emiya-家今天的饭"><a href="#D2T1-Emiya-家今天的饭" class="headerlink" title="$D2T1$ $Emiya$家今天的饭"></a>$D2T1$ <a href="https://www.luogu.org/problem/P5664">$Emiya$家今天的饭</a></h2><h2 id="D2T2-划分"><a href="#D2T2-划分" class="headerlink" title="$D2T2$ 划分"></a>$D2T2$ <a href="https://www.luogu.org/problem/P5665">划分</a></h2><h2 id="D2T3-树的重心"><a href="#D2T3-树的重心" class="headerlink" title="$D2T3$ 树的重心"></a>$D2T3$ <a href="https://www.luogu.org/problem/P5666">树的重心</a></h2>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>CSP-S</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2019」自闭游记</title>
    <url>/p/1901119c.html</url>
    <content><![CDATA[<p>这次大概是第二年参加信息竞赛了(<del>虽然去年什么也不会就摸了110分,省四</del>)<br>按照惯例,该写篇游记(<del>流水账</del>)了</p>
<span id="more"></span>

<h2 id="Day-7-sim-2"><a href="#Day-7-sim-2" class="headerlink" title="$Day\ \  -7\sim -2$"></a>$Day\ \  -7\sim -2$</h2><p>本来还是挺有信心的,校内几十次模拟赛考自闭了,想想复赛结束后周一周二就要期中考试(<del>其实是”贴心”的年级组特意为我们OIer调的</del>)更自闭了<br>晚饭回来后,几个沙雕朋友听说我自闭了,围了一圈给我来了一遍<a href="https://www.bilibili.com/video/av53058902?from=search&seid=3943401388874538351">奥利给</a>,真的感动<br>回家和父母商量好,签了个申请书脱了一周产,还说让我专心学信息,期中考试先放下</p>
<p>脱产的时光还是很快乐的<br>早上六点多到校就开始整理模板,刷模板题<br>老师到了之后花三个半小时做模拟题<br>下午自习和$zty$巨佬研究问题<br>四天就这么过去了,打了一本子模板带去省城复习</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="$Day\ \ -1$"></a>$Day\ \ -1$</h2><p>上午十一点和机房$wjh$,$mjc$,$lyd$(<del>lyd AK IOI</del>)出发去车站了<br>还是去年的时间,还是去年的$KFC$,还是去年的垃圾笔记本<br>看的是累积了一年的数千行模板和经验</p>
<p>中午到了去年同样的酒店,晚上去了去年同样的吉大日新楼吃饭<br>回到酒店,$lyd$巨佬给同学讲爆搜技巧,$zyc$学长像去年一样来探望<del>苦逼的</del>$yzOIer$<br>睡前敲了一堆板子:快读,vim配置,ST表,树状数组,Trie树,树的重心,树的直径</p>
<h2 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="$Day\ \ 1$"></a>$Day\ \ 1$</h2><p>还是在去年的等候室</p>
<p>进考场<br>$???$这防窥膜是什么鬼,什么都挡不了的好吧,看着还超难受<br>前排的灯也没有开,没开考眼睛就生疼</p>
<h3 id="Day1-T1"><a href="#Day1-T1" class="headerlink" title="$Day1\ T1$"></a>$Day1\ T1$</h3><p>看见题目,emmm怎么做都告诉你了,开个数组<code>reverse</code>模拟呗…<br>emmm不对,数组的话貌似要开$2^64$,不行不行<br>推规律,好像也就那么个意思,<code>dfs</code>模拟!!<br>然后一顿乱搞,dfs传值从2到3到4,写了好几十行<code>dfs</code><br>跑一边样例,没问题,大样例??好像爆了,改<code>long long</code>…照样爆<br>看一眼时间,艹一个小时了,得了得了,不改了</p>
<p>看完第二题,不行不行,得改完,$2^64$?不是<code>unsigned long long</code>吗<br>又加了常数的转换操作,大概可以了</p>
<p>此时一个半小时过去了…</p>
<h3 id="Day1-T2"><a href="#Day1-T2" class="headerlink" title="$Day1\ T2$"></a>$Day1\ T2$</h3><p>emmm括号匹配,靠前看过类似的,好像得用栈<br>一顿乱搞,发现审错题了…<br>树上??我应该不会,做链的小数据$35$分得了<br>自己出了几个样例(其实是没发现大样例有链上情况),用了$multiset,stack$乱搞,都过了,就扔下去看第三题了</p>
<h3 id="Day1-T3"><a href="#Day1-T3" class="headerlink" title="$Day1\ T3$"></a>$Day1\ T3$</h3><p>题目绕了十分多种,看了好几遍样例才明白题干<br>这咋做啊,正解肯定不会,链和菊花图想了半个多小时没想出来</p>
<p>最后剩二十分钟了,不还是有$n!$的暴力$10$分吗<br>飞速写完代码,编译…<code>vector</code>没有???不应该啊,改了好多遍也过不了,拉倒,随机数吧…随机数概率太小,从$1\sim n$依次输出..</p>
<p><del>其实编译没过是没有加<code>using namespace std;</code></del></p>
<p>中午老师请客去了去年同样的饭店,下午去了去年同样的欢乐城放松<del>自暴自弃</del><br>$day1$估分$135$,完了,明天得考一百多分才稳…</p>
<p>晚上睡前又看了看一天什么没用上的模板</p>
<h2 id="Day-2"><a href="#Day-2" class="headerlink" title="$Day\ \ 2$"></a>$Day\ \ 2$</h2><p>在等候室看了树的重心,树的直径的模板<br>我跟lyd说:昨天没考,今天肯定有</p>
<h3 id="Day2-T1"><a href="#Day2-T1" class="headerlink" title="$Day2\ T1$"></a>$Day2\ T1$</h3><p>认真的审了题,想要$AC$<br>画了样例的图,woc二分图,网络流???<br>完了完了,考前没看,扔下一个$32$分$n!$暴力溜了</p>
<p><del>其实已经花了一个小时了</del></p>
<h3 id="Day2-T3"><a href="#Day2-T3" class="headerlink" title="$Day2\ T3$"></a>$Day2\ T3$</h3><p>第二题没看懂题面,看到第三题题目我就来了<br>$???$这个重心定义和我复习的不一样,大体思想差不多,开写</p>
<p>改了模板,写了上去,发现分割树???以前没做过,只好重新建图,删一条边建一次图<del>辣鸡效率</del><br>跑完???重心全是$2$,查了半天发现两棵树的节点数没处理…<br>改过来之后前几个点$25$分应该是没问题了</p>
<p>简单推了下链和完美二叉树,没推出来,放弃…<br>考试结束前也没想出来</p>
<h3 id="Day2-T2"><a href="#Day2-T2" class="headerlink" title="$Day2\ T2$"></a>$Day2\ T2$</h3><p>照着样例看了十分钟才明白题目啥意思<br>感觉应该是$DP$,但蒟蒻不会$DP$啊<br>算了,瞎写个状态转移方程吧,乱搞…<br>发现不是最优解,然后处理分块还有贪心什么的<br>改了一个小时还是不对,心想算了,爆零了,1=无缘了,又回去推链的重心</p>
<p>考试结束前,准备提交代码,把这题中间几行没用的删了删(<del>删少了几行</del>),再跑一遍,奇迹般的对了<br>测了一下几个样例,$0\to 64\ \ ???$</p>
<p>估分$100+35+0+32+64+25=256$,有点悬</p>
<p>下午刷洛谷,<code>橙蓝黑紫黑紫</code>…炸了(<del>现在掉色了</del>)<br><img src="https://i0.hdslb.com/bfs/album/cc13d523f06cd8315aed8d91a83f36d030bd0b73.jpg" alt="橙蓝黑紫黑紫"><br>晚上从车站回家在大雪里打车半个小时,到家颓废,第二天的期中彻底放弃</p>
<h2 id="Day-3-sim-4"><a href="#Day-3-sim-4" class="headerlink" title="$Day\ \ 3\sim 4$"></a>$Day\ \ 3\sim 4$</h2><p>期中考试<br>第一天开幕雷击,语文古文没背过,作文主旋律,然后三科一个月没学的文科,还有什么都没复习的英语</p>
<p>回家,老师传了公示代码,去$luogu$民间数据自测<br>$Day1\ T2\ \ 35\to 0\ 256\to 221$ 1=没希望,彻底自闭了,要$AFO$了</p>
<h2 id="Day-5-sim-6"><a href="#Day-5-sim-6" class="headerlink" title="$Day\ \ 5\sim 6$"></a>$Day\ \ 5\sim 6$</h2><p>中午去机房把东西收拾到小屋里,$zty,lyd$巨佬已经开始准备省选<br>期中成绩陆续出来了,总体来说还可以</p>
<p>中午和$zty$用<a href="https://github.com/Sojiv/Project_lemon">lemon</a>把全省代码拿民间数据跑了一遍,排名还可以,貌似还有希望</p>
<h2 id="结"><a href="#结" class="headerlink" title="结"></a>结</h2><p>虽然考的很水,但学$OI$我绝不后悔<br>接下来要努力捡起文化课了</p>
<blockquote>
<p>文化课虽说恶心，但只有一年，一年完了就能读大学了，高考就与你无关了。 —$zcysky$</p>
</blockquote>
<p>加油!奥利给!!</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>游记</tag>
        <tag>CSP-S</tag>
      </tags>
  </entry>
  <entry>
    <title>「图论算法」树上并查集 dsu on tree</title>
    <url>/p/da7e0a9d.html</url>
    <content><![CDATA[<p>$dsu\ on\ tree$($disjoint\ set\ union\ \text{on tree}$)算法，也称 __树上并查集__。使用了并查集的<em>按秩合并</em>(<strong>启发式合并</strong>)的方法，结合 <em>树链剖分</em> 中的 <strong>轻重儿子划分</strong> ，对 <strong>树上暴力统计</strong> 进行了优化。使用这个算法需要满足以下两个条件：</p>
<span id="more"></span>

<ul>
<li>每次只对子树进行查询</li>
<li>过程中没有对树的修改</li>
</ul>
<p>可以将$O(n^2)$的暴力操作优化到$O(n\log_2n)$</p>
<h2 id="pre-树链剖分-轻重链划分"><a href="#pre-树链剖分-轻重链划分" class="headerlink" title="$pre.\ $树链剖分 - 轻重链划分"></a>$pre.\ $树链剖分 - 轻重链划分</h2><p>在$dsu\ on\ tree$算法中，只需要统计出每个节点的<em>轻重儿子</em>，而不需要划分轻重链，所以我们只需要树链剖分中的$\texttt{dfs1()}$，并且只保留和轻重儿子有关的操作即可</p>
<blockquote>
<p>关于 <strong>轻重儿子</strong> ：</p>
<ul>
<li>一个节点的所有子节点中，子树所含节点个数最多的子节点称为 <strong>重儿子</strong></li>
<li>除重儿子外，一个节点的其余儿子均为 <strong>轻儿子</strong></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>; <span class="comment">// 以x为根的子树大小初始化为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.to, x);</span><br><span class="line">        siz[x] += siz[e.to]; <span class="comment">// 加上子节点的大小</span></span><br><span class="line">        <span class="keyword">if</span> (siz[e.to] &gt; siz[son[x]]) &#123;</span><br><span class="line">            son[x] = e.to; <span class="comment">// 更新重儿子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="I-算法流程"><a href="#I-算法流程" class="headerlink" title="$I.\ $算法流程"></a>$I.\ $算法流程</h2><p>对于每一个节点$x$:</p>
<ul>
<li>遍历所有子节点<ul>
<li>递归计算所有轻儿子的子树，并删除其对答案的贡献</li>
</ul>
</li>
<li>递归计算重儿子，保留对答案的贡献</li>
<li>统计所有轻儿子对答案的贡献</li>
<li>更新节点答案</li>
</ul>
<p>伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (all edge from x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(e.to, x, <span class="number">0</span>); <span class="comment">// 暴力统计轻儿子的子树的贡献，并删除(opt=0)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) <span class="built_in">dfs</span>(son[x], x, <span class="number">1</span>); <span class="comment">// 统计重儿子的贡献，不删除</span></span><br><span class="line">    <span class="built_in">upd</span>(x); <span class="comment">// 暴力统计该节点所有轻儿子的贡献</span></span><br><span class="line">    ans[x] = now; <span class="comment">// 更新答案</span></span><br><span class="line">    <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">        <span class="built_in">del</span>(x); <span class="comment">// 删除需要删除的贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>(x); <span class="comment">// 计算当前答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == Son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">upd</span>(e.to, x, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于暴力统计的只是轻儿子，而每个节点的轻儿子不超过$\log_2n$个，所以整个算法复杂度保证在了$O(n\log_2n)$</p>
<h2 id="II-模板题"><a href="#II-模板题" class="headerlink" title="$II.\ $模板题"></a>$II.\ $模板题</h2><p><a href="https://www.luogu.org/problemnew/solution/CF600E">$CodeForces\ 600E\ \ Lomsat\ gelral$</a> </p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Mx, Son, col[maxn], son[maxn], siz[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>, ans[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.to, x);</span><br><span class="line">        siz[x] += siz[e.to];</span><br><span class="line">        <span class="keyword">if</span> (siz[e.to] &gt; siz[son[x]]) &#123;</span><br><span class="line">            son[x] = e.to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    cnt[col[x]] += val;</span><br><span class="line">    <span class="keyword">if</span> (cnt[col[x]] &gt; Mx) &#123;</span><br><span class="line">        Mx = cnt[col[x]];</span><br><span class="line">        sum = col[x];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[col[x]] == Mx) &#123;</span><br><span class="line">        sum += (<span class="keyword">long</span> <span class="keyword">long</span>)col[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa || e.to == Son) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Add</span>(e.to, x, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (e.to == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.to != son[x]) <span class="built_in">dfs2</span>(e.to, x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (son[x]) &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(son[x], x, <span class="number">1</span>);</span><br><span class="line">        Son = son[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Add</span>(x, fa, <span class="number">1</span>); Son = <span class="number">0</span>;</span><br><span class="line">    ans[x] = sum;</span><br><span class="line">    <span class="keyword">if</span> (!opt) &#123;</span><br><span class="line">        <span class="built_in">Add</span>(x, fa, <span class="number">-1</span>);</span><br><span class="line">        sum = <span class="number">0</span>, Mx = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        col[i] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(u, v); <span class="built_in">add</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>图论</tag>
        <tag>dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1993」小K的农场-题解 &amp; 差分约束系统</title>
    <url>/p/6dcf876e.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problem/P1993">「Luogu P1993」小K的农场</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给出$m$个约束条件,$n$个农场<br>有三种条件,其中$a,b$表示编号为$a,b$的农场的植物个数</p>
<ol>
<li>$a-b≥c$</li>
<li>$a-b≤c$</li>
<li>$a=b$<br>求是否存在一种方案,使农场中的植物数满足约束要求</li>
</ol>
<h3 id="I-差分约束系统"><a href="#I-差分约束系统" class="headerlink" title="$I.$ 差分约束系统"></a>$I.$ 差分约束系统</h3><p>以第$1$种约束为例:<br>$$a-b\ge c\Rightarrow b\le a+(-c)$$<br>与求最短路径中的三角形不等式$dis[e.to]\le dis[u] + e.val$类似<br>所以我们对于约束条件$a-b\ge c$,从$a$到$b$建一条边权为$-c$的边<br>同理三种约束条件依次为</p>
<ol>
<li>$a-b\ge c$, 从$a$到$b$建$-c$单向边</li>
<li>$a-b\le c$, 从$b$到$a$建$c$单向边</li>
<li>$a=b$, 从$a$到$b$建权值为$0$的双向边</li>
</ol>
<p>如果存在一组解${x_1, x_2, \ldots, x_n}$,则对任意常数$\Delta$, ${x_1+\Delta, x_2+\Delta, \ldots, x_n+\Delta}$也是一组解<br>不妨先求一组负数解,于是就有了条件$x_i-x_0\le 0$<br>即,从$0$向所有节点建一条边权为$0$的单向边</p>
<p>求解时,设$\mathtt{dis[0]=0}$,然后以$0$为源点求单源最短路<br>如果存在负环,则系统无解<br>不存在负环,则$\mathtt{dis[i]}$为系统的一组解</p>
<h3 id="II-负环"><a href="#II-负环" class="headerlink" title="$II.$ 负环"></a>$II.$ 负环</h3><p>如果任意一条边被修改大于$n$次(执行$n$次松弛操作),这个图内一定存在至少一个负环<br>我们可以使用一个数组$cnt$来记录每条边执行松弛操作的次数<br>当向队列中添加节点$\mathtt{e.to}$时,$\mathtt{cnt[e.to]++}$<br>然后再判断$\mathtt{cnt[e.to]&gt;n}$,如果返回$\mathtt{true}$则存在负环</p>
<h3 id="III-SPFA-的-SLF-优化"><a href="#III-SPFA-的-SLF-优化" class="headerlink" title="$III.$ $SPFA$的$SLF$优化"></a>$III.$ $SPFA$的$SLF$优化</h3><p>本题如果直接跑$SPFA$的话,会$TLE\ 3$个点,即使手动开了$O3$优化,还是会$TLE\ 1$个点<br>所以我们可以使用$SLF(Small\ Label\ First)$优化</p>
<p>$SLF:$<br>当加入一个新节点$v$的时候</p>
<ul>
<li>如果此时的$\mathtt{dis[v]}$比队首$\mathtt{dis[q.front()]}$小的话，就把$v$点加入到队首</li>
<li>否则把他加入到队尾</li>
</ul>
<p>因为先扩展最小的点可以尽量使程序尽早的结束</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>; <span class="keyword">int</span> f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">val</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn], vis[maxn], cnt[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; q; q.<span class="built_in">push_back</span>(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>(); vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (dis[e.to] &gt; dis[u] + e.val) &#123;</span><br><span class="line">                dis[e.to] = dis[u] + e.val;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    vis[e.to] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; dis[e.to] &lt; dis[q.<span class="built_in">front</span>()]) &#123;</span><br><span class="line">                        q.<span class="built_in">push_front</span>(e.to);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        q.<span class="built_in">push_back</span>(e.to);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt[e.to]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[e.to] &gt; n) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(a, b, -c);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), c = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(b, a, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(a, b, <span class="number">0</span>); <span class="built_in">add</span>(b, a, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="built_in">SPFA</span>(<span class="number">0</span>) ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1.94s 1.61MB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>图论</tag>
        <tag>差分约束</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」线段树</title>
    <url>/p/d1cf0d36.html</url>
    <content><![CDATA[<p>线段树($Segment\ Tree$)是一种基于分治思想的__二叉树__形数据结构，可以用于__区间__上的数据维护，它可以维护以下值</p>
<span id="more"></span>

<ul>
<li>$maxn\ minn$，区间上最大最小值</li>
<li>$sum$，区间和</li>
<li>$lmax$，每段上最大前缀和</li>
<li>$rmax$，每段上最大后缀和</li>
<li>$……$</li>
</ul>
<p>和以下操作</p>
<ul>
<li>$Add\ x\ y\ k$，把区间$[x,y]$内元素值全加$k$</li>
<li>$Query\ x\ y$，查询区间$[x,y]$内的某个值</li>
</ul>
<p>由于线段树会维护一种数据，其他也很好写，所以本篇以__区间和__为例</p>
<h2 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h2><p>在每次$Add$操作中，如果将相关区间的值全部更新，则会把时间复杂度提高到$O(n)$</p>
<p>所以我们可以采取一种__<em>延迟标记</em>__($lazy-tag$)的技巧，如果被标记，则说明本区间内的值被整体加上某个值了</p>
<p>详细方法见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SegmentTreeNode</span> &#123;</span> <span class="comment">//树上的节点</span></span><br><span class="line">        <span class="keyword">int</span> l, r;                   <span class="comment">//节点表示区间的左右端点</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum, add;         <span class="comment">//区间和和add的延迟标记</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> l(x) tree[x].l      <span class="comment">//方便访问</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> r(x) tree[x].r</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> sum(x) tree[x].sum</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> add(x) tree[x].add</span></span><br><span class="line">    &#125; tree[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> a[maxn], n, m;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//建树</span></span><br><span class="line">        <span class="built_in">l</span>(p) = l, <span class="built_in">r</span>(p) = r;           <span class="comment">//设置左右端点</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; <span class="built_in">sum</span>(p) = a[l]; <span class="keyword">return</span>; &#125; <span class="comment">//到达叶子节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(p * <span class="number">2</span>, l, mid);         <span class="comment">//递归构建左右树</span></span><br><span class="line">        <span class="built_in">build</span>(p * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) + <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>); <span class="comment">//更新数据，可改为需要维护的多个值的维护方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; <span class="comment">//下传延迟标记</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">add</span>(p)) &#123; <span class="comment">//如果有标记</span></span><br><span class="line">            <span class="built_in">sum</span>(p * <span class="number">2</span>) += <span class="built_in">add</span>(p) * (<span class="built_in">r</span>(p * <span class="number">2</span>) - <span class="built_in">l</span>(p * <span class="number">2</span>) + <span class="number">1</span>); <span class="comment">//sum传至左儿子</span></span><br><span class="line">            <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>) += <span class="built_in">add</span>(p) * (<span class="built_in">r</span>(p * <span class="number">2</span> + <span class="number">1</span>) - <span class="built_in">l</span>(p * <span class="number">2</span> + <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">//右儿子</span></span><br><span class="line">            <span class="built_in">add</span>(p * <span class="number">2</span>) += <span class="built_in">add</span>(p);      <span class="comment">//延迟标记传至左儿子</span></span><br><span class="line">            <span class="built_in">add</span>(p * <span class="number">2</span> + <span class="number">1</span>) += <span class="built_in">add</span>(p);  <span class="comment">//右儿子</span></span><br><span class="line">            <span class="built_in">add</span>(p) = <span class="number">0</span>; <span class="comment">//本节点延迟标记清零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123; <span class="comment">//更新区间内值</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p)) &#123; <span class="comment">//完全覆盖</span></span><br><span class="line">            <span class="built_in">sum</span>(p) += (<span class="keyword">long</span> <span class="keyword">long</span>)d * (<span class="built_in">r</span>(p) - <span class="built_in">l</span>(p) + <span class="number">1</span>); <span class="comment">//更新节点信息</span></span><br><span class="line">            <span class="built_in">add</span>(p) += d; <span class="comment">//打上延迟标记</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pushdown</span>(p); <span class="comment">//下传标记</span></span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">update</span>(p * <span class="number">2</span>, l, r, d);      <span class="comment">//递归更新左右</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;  mid) <span class="built_in">update</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="built_in">sum</span>(p) = <span class="built_in">sum</span>(p * <span class="number">2</span>) + <span class="built_in">sum</span>(p * <span class="number">2</span> + <span class="number">1</span>);      <span class="comment">//维护数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="comment">//查询操作</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt;= <span class="built_in">l</span>(p) &amp;&amp; r &gt;= <span class="built_in">r</span>(p)) <span class="keyword">return</span> <span class="built_in">sum</span>(p); <span class="comment">//完全覆盖</span></span><br><span class="line">        <span class="built_in">pushdown</span>(p); <span class="comment">//下传标记</span></span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="built_in">l</span>(p) + <span class="built_in">r</span>(p)) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) ans += <span class="built_in">query</span>(p * <span class="number">2</span>, l, r);     <span class="comment">//加上左右部分值</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt;  mid) ans += <span class="built_in">query</span>(p * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> add   <span class="comment">//防止后续使用add等出现错误</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> sum</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> l</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> r</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了使代码简洁，还可以宏定义一些名称</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lt p&lt;&lt;1     <span class="comment">//左孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rt p&lt;&lt;1|1   <span class="comment">//右孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson lt,l,mid    <span class="comment">//左子树</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson rt,mid+1,r  <span class="comment">//右子树</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3372">Luogu P3372 线段树1 (区间增加，区间查询和)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3373">Luogu P3373 线段树2 (区间增加，区间乘数，区间查询和)</a></p>
<p>$SPOJ$的$GSS$系列</p>
<ol>
<li><a href="https://www.luogu.org/problemnew/show/SP1043">SP1043 GSS1 - Can you answer these queries I</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP1557">SP1557 GSS2 - Can you answer these queries II</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP1716">SP1716 GSS3 - Can you answer these queries III</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP2713">SP2713 GSS4 - Can you answer these queries IV</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP2916">SP2916 GSS5 - Can you answer these queries V</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP4487">SP4487 GSS6 - Can you answer these queries VI</a></li>
<li><a href="https://www.luogu.org/problemnew/show/SP6779">SP6779 GSS7 - Can you answer these queries VII</a></li>
</ol>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」左偏树(可并堆)</title>
    <url>/p/7ab0d731.html</url>
    <content><![CDATA[<p>左偏树($Leftist\ Tree$)，是一种 __可以合并的堆状结构__，支持以下操作</p>
<span id="more"></span>

<ul>
<li>$Pop\ x$，删除节点$x$</li>
<li>$Merge\ x\ y$，合并两棵左偏树</li>
</ul>
<p>对于一个左偏树的节点，需要维护以下值</p>
<ul>
<li>$dist$，记录这个节点到它子树里面最近的叶子节点的距离</li>
<li>$value$，每个节点包含的值</li>
</ul>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li>一个节点的$value$大于(或小于)左右孩子的$value$<strong><em>(堆性质)</em></strong> </li>
<li>一个节点的左孩子的$dist$不小于右孩子的$dist$<strong><em>(左偏性质)</em></strong></li>
<li>一个节点的距离始终等于右孩子+1</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="Merge-操作"><a href="#Merge-操作" class="headerlink" title="$Merge$操作"></a>$Merge$操作</h3><p>首先我们设两个节点$x,y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了</p>
<p>合并了$x$的右子树和$y$后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护左偏性质，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x=dist_{rson(x)}+1$</p>
<h3 id="Pop-操作"><a href="#Pop-操作" class="headerlink" title="$Pop$操作"></a>$Pop$操作</h3><p>略$…$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LeftistTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LeftistTreeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> dis, val, rt;</span><br><span class="line">        <span class="keyword">int</span> ls, rs;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> ls(x)  tree[x].ls</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rs(x)  tree[x].rs</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> dis(x) tree[x].dis</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> val(x) tree[x].val</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> rt(x)  tree[x].rt</span></span><br><span class="line">    &#125;tree[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x + y;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">val</span>(x) &gt; <span class="built_in">val</span>(y) || (<span class="built_in">val</span>(x) == <span class="built_in">val</span>(y) &amp;&amp; x &gt; y)) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rs</span>(x) = <span class="built_in">merge</span>(<span class="built_in">rs</span>(x), y);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dis</span>(<span class="built_in">ls</span>(x)) &lt; <span class="built_in">dis</span>(<span class="built_in">rs</span>(x))) <span class="built_in">swap</span>(<span class="built_in">ls</span>(x), <span class="built_in">rs</span>(x));</span><br><span class="line">        <span class="built_in">rt</span>(<span class="built_in">ls</span>(x)) = <span class="built_in">rt</span>(<span class="built_in">rs</span>(x)) = <span class="built_in">rt</span>(x) = x;</span><br><span class="line">        <span class="built_in">dis</span>(x) = <span class="built_in">dis</span>(<span class="built_in">rs</span>(x)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rt</span>(x) == x ? x : <span class="built_in">rt</span>(x) = <span class="built_in">get</span>(<span class="built_in">rt</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">val</span>(x) = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">rt</span>(<span class="built_in">ls</span>(x)) = <span class="built_in">ls</span>(x); <span class="built_in">rt</span>(<span class="built_in">rs</span>(x)) = <span class="built_in">rs</span>(x);</span><br><span class="line">        <span class="built_in">rt</span>(x) = <span class="built_in">merge</span>(<span class="built_in">ls</span>(x), <span class="built_in">rs</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dis</span>(<span class="number">0</span>) = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">rt</span>(i) = i;</span><br><span class="line">            <span class="built_in">val</span>(i) = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SolveMerge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">val</span>(x) == <span class="number">-1</span> || <span class="built_in">val</span>(y) == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> fx = <span class="built_in">get</span>(x), fy = <span class="built_in">get</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            <span class="built_in">rt</span>(fx) = <span class="built_in">rt</span>(fy) = <span class="built_in">merge</span>(fx, fy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SolvePop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">val</span>(x) == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">val</span>(<span class="built_in">get</span>(x))), <span class="built_in">pop</span>(<span class="built_in">get</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3377">Luogu P3377 左偏树(可并堆)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」树状数组</title>
    <url>/p/8c13697e.html</url>
    <content><![CDATA[<p>树状数组($Binary\ Indexed\ Trees$)是一个维护__前缀和__的数据结构，需要支持以下操作</p>
<span id="more"></span>

<ul>
<li>$Add\ x\ y$，单点增加，<code>a[x] += y</code></li>
<li>$Query\ x$，查询前缀和</li>
</ul>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="lowbit-运算"><a href="#lowbit-运算" class="headerlink" title="$lowbit$运算"></a>$lowbit$运算</h3><p>$lowbit(n)$表示非负整数$n$在二进制表示下__最低位的1及其后边所有的0构成的数值__</p>
<p>为了实现$lowbit$运算，先把$n$取反，此时第$k$位变为$0$(设第$k$位是$1$，其后均为$0$)，第$0\sim k-1$位变为$1$，再整体加一，所以第$k$位变为$1$，其后为$0$，其前每位恰好与原数相反，再按位求与($&amp;$)即可得到。由于在补码下，$\sim n=-1-n$，所以</p>
<p>$$lowbit(n)=n\ &amp;\  (\sim n+1)=n\ &amp;\ -n$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="keyword">return</span> n &amp; -n; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>对于一个原序列$a[]$，可以建立一个数组$tree[]$，来保存$a$的区间$[x-lowbit(x)+1, x]$内值的和，即</p>
<p>$$tree[x] = \sum_{i=x-lowbit(x)+1}^x{a[i]}$$</p>
<p>同时$tree$数组可以看成一个树形结构，并满足以下性质</p>
<ul>
<li>每个节点$tree[x]$保存以$x$为根的子树中所有叶节点的和</li>
<li>每个节点$tree[x]$的子节点个数等于$lowbit(x)$的位数</li>
<li>除树根外，每个节点$tree[x]$的父亲节点为$tree[x+lowbit(x)]$</li>
<li>树的深度为$\log_2n$</li>
</ul>
<p>根据这些性质，就<del>很容易地</del>写出代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BIT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> tree[maxn], n, m;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123; <span class="keyword">return</span> k &amp; -k; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; x &lt;= maxn; x += x &amp; -x) tree[x] += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= x &amp; -x) ans += tree[x];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="built_in">add</span>(i, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，树状数组可以嵌套维护，来解决更多问题，例如区间修改</p>
<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3374">Luogu P3374 树状数组1 (单点修改，区间查询)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3368">Luogu P3368 树状数组2 (区间修改，单点查询)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P3372">Luogu P3372 线段树1 (区间修改，区间查询)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「数据结构」并查集</title>
    <url>/p/9c4b8ceb.html</url>
    <content><![CDATA[<p>并查集($union-find\ \ set$)是一种可以__动态维护__若干个不重叠的__集合__，并支持__合并与查询__的数据结构，支持以下两种基本操作：</p>
<span id="more"></span>

<ul>
<li>$Find$，查询一个元素属于哪个集合(即查找根)</li>
<li>$Union$，把两个集合合并成一个集合</li>
</ul>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>我们可以使用树形结构存储集合，树上每个点表示一个元素，树根可以代表这个集合</p>
<p>使用一个数组<code>ufs[]</code>来保存每个节点的父亲节点</p>
<p>则合并$x,y$所在的集合可以表示为$ufs[root_x]=root_y$</p>
<p>查找根节点可以一直沿着数组向上查找</p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>防止整棵树的链非常长，导致每次查询时间复杂度极高，可以在__每次执行$Find$操作时，把访问的节点指向根节点__，这种方法称为__<em>路径压缩</em>__，$Find$操作的时间复杂度为$O(log_2n)$</p>
<p>$Code\ Below:$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，每个点独立(自己是自己的根)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ufs[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == ufs[x] ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//union操作(注意union是C++关键字)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	ufs[<span class="built_in">get</span>(x)] = <span class="built_in">get</span>(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><p>有时，需要维护的每个节点到根节点的边权值，可以增加一个数组<code>d[]</code>来保存权值，对于两个操作也有所更改</p>
<p>再增加一个数组<code>size[]</code>记录每个树根上集合大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Find</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ufs[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">    d[x] += d[ufs[x]];</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = fx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//union</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">    ufs[fx] = fy; d[fx] = size[fy];</span><br><span class="line">    size[fy] += size[fx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可撤销并查集"><a href="#可撤销并查集" class="headerlink" title="可撤销并查集"></a>可撤销并查集</h2><p>可能需要维护一个并查集并要求可以__撤销__两节点的连接关系</p>
<p>我们可以对每个操作$(u, v)$执行前，把节点$u$换为树根(<del>不难发现</del>，$ufs[]$变化的只有从$u$到原节点的一条链上)</p>
<p>然后对于操作</p>
<ul>
<li>$Connect\ u\ v$，需要把$u$的父亲节点设为$v$</li>
<li>$Delete\ u\ v$，可以把$v$的父亲节点设为$0$</li>
<li>$Query\ u\ v$，直接暴力搜索$v$所在的链即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFindSet</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ufs[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            ufs[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sroot</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="comment">//换u为根</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, fa = ufs[u]; u; fa = ufs[u]) &#123;</span><br><span class="line">            ufs[u] = i; i = u; u = fa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ufs[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteuv</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        ufs[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; v != u &amp;&amp; v; v = ufs[v]);</span><br><span class="line">        <span class="built_in">puts</span>(v == u ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Luogu-模板题目"><a href="#Luogu-模板题目" class="headerlink" title="$Luogu$模板题目"></a>$Luogu$模板题目</h2><p><a href="https://www.luogu.org/problemnew/show/P3367">Luogu P3367 并查集 (普通并查集)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P1196">Luogu P1196 银河英雄传说 (带权并查集)</a></p>
<p><a href="https://www.luogu.org/problemnew/show/P2147">Luogu P2147 洞穴勘探 (可撤销并查集)</a></p>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P2723 P1631 P2850」小练习-题解</title>
    <url>/p/1faf5003.html</url>
    <content><![CDATA[<p>战神留的还有一道<a href="https://www.luogu.org/problemnew/show/P3378">「P3378」堆</a>,但是是模板,就不用多说了吧</p>
<span id="more"></span>

<h2 id="mathcal-「P2723」-丑数"><a href="#mathcal-「P2723」-丑数" class="headerlink" title="$\mathcal{「P2723」}$ 丑数"></a>$\mathcal{「P2723」}$ <a href="https://www.luogu.org/problemnew/show/P2723">丑数</a></h2><h3 id="92-分-STL-做法"><a href="#92-分-STL-做法" class="headerlink" title="$92$分$STL$做法"></a>$92$分$STL$做法</h3><p>思路很简单,每次弹出堆顶,依次乘$S$集合内的数,再压入优先队列($priority\_queue$)和集合($set$,目的是去重)中,输出最后一个堆顶即可<br>然而第$4$个点卡了十多秒,$92$分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, n, a[maxk], i, t;</span><br><span class="line">priority_queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>, vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; q;</span><br><span class="line">set&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>); s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt;= n) &#123;</span><br><span class="line">        t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> num = t * a[j];</span><br><span class="line">            <span class="keyword">if</span> (!s.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(num);</span><br><span class="line">                q.<span class="built_in">push</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 92points TLE with O2 */</span></span><br></pre></td></tr></table></figure>

<h3 id="100-分循环做法"><a href="#100-分循环做法" class="headerlink" title="$100$分循环做法"></a>$100$分循环做法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由题可知,当前产生的第$i$个丑数$s[i]$,是之前的某个丑数$\times a[j]$<br>某个丑数$\times a[j]$需要大于$s[i-1]$,而且要尽可能的小<br>于是我们可以枚举$j$,然后找到最小的一个丑数$minn$使$minn\times a[j]&gt;s[i-1]$</p>
<p><strong>但是..三重循环可能还会$TLE$</strong></p>
<p>很容易发现满足条件的丑数$x\times a[j]&gt;s[i-1]$,一定满足条件$x\times a[j]&gt;s[i-2]$<br>于是我们就可以从满足$x\times a[j]&gt;s[i-2]$的丑数$x$的位置往后枚举,找到满足条件$x\times a[j]&gt;s[i-1]$的丑数<br>代码里$b[j]$表示$a[j]$至少与第几小丑数相乘才能得到一个比$s[i-1]$大的丑数</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, n, a[maxk], i, t, s[maxn], b[maxk];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> minn = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span> &lt;&lt; <span class="number">61</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[j] * s[b[j]] &lt;= s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                b[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[j] * s[b[j]] &lt; minn) &#123;</span><br><span class="line">                minn = a[j] * s[b[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = minn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, s[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 101ms 1584kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="mathcal-「P1631」-序列合并"><a href="#mathcal-「P1631」-序列合并" class="headerlink" title="$\mathcal{「P1631」}$ 序列合并"></a>$\mathcal{「P1631」}$ <a href="https://www.luogu.org/problemnew/show/P1631">序列合并</a></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>参考<a href="https://www.luogu.org/blog/user23845/solution-p1631">Red_w1nE</a></p>
<p>把$A$和$B$两个序列分别从小到大排序<br>这样,从$A$和$B$中各任取一个数相加得到$n^2$个和,可以把这些和看成形成了$n$个队列:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[<span class="number">1</span>] + b[<span class="number">1</span>] &lt;= a[<span class="number">1</span>] + b[<span class="number">2</span>] &lt;= ... &lt;= a[<span class="number">1</span>] + B[n]</span><br><span class="line">a[<span class="number">2</span>] + b[<span class="number">1</span>] &lt;= a[<span class="number">2</span>] + b[<span class="number">2</span>] &lt;= ... &lt;= a[<span class="number">2</span>] + B[n]</span><br><span class="line">    ...            ...        ...        ...</span><br><span class="line">a[n] + b[<span class="number">1</span>] &lt;= a[n] + b[<span class="number">2</span>] &lt;= ... &lt;= a[n] + B[n]</span><br></pre></td></tr></table></figure>
<p>接下来,将这$n$个队列进行合并:</p>
<ul>
<li>将这$n$个队列中的第一个元素放入优先队列中；</li>
<li>每次取出优先队列中的最小值,若这个最小值来自于第$k$个队列,那么,就将第$k$个队列的下一个元素放入优先队列中。<br>我们可以使用一个结构体来记录队列中一个节点的值<code>val</code>,队列号<code>id</code>,下一个元素<code>nxt</code></li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, id, nxt;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> v, <span class="keyword">int</span> i, <span class="keyword">int</span> n): <span class="built_in">val</span>(v), <span class="built_in">id</span>(i), <span class="built_in">nxt</span>(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node&amp; a, <span class="keyword">const</span> Node&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[maxn], b[maxn];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">Node</span>( a[i] + b[<span class="number">0</span>], i, <span class="number">1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Node t = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, t.val);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">Node</span>( a[t.id] + b[t.nxt], t.id, t.nxt + <span class="number">1</span> ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 402ms 3196kB */</span></span><br></pre></td></tr></table></figure>


<h2 id="mathcal-「P2850」-虫洞"><a href="#mathcal-「P2850」-虫洞" class="headerlink" title="$\mathcal{「P2850」}$ 虫洞"></a>$\mathcal{「P2850」}$ <a href="https://www.luogu.org/problemnew/show/P2850">虫洞</a></h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>判断__<em>负环</em>__的模板题</p>
<p>每条小路连接边权为正的无向边,每个虫洞连接边权为负的无向边<br>存在负环,则可以回到过去<br>使用$SPFA$算法判断负环($Floyd$也可以,但不开O2优化会$TLE$)</p>
<p>$SPFA$判断负环:<strong>如果任意一条边被修改大于$n$次,这个图内一定存在至少一个负环</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>使用<code>vector</code>建边,邻接表也可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">val</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[maxn], vis[maxn], cnt[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, w;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dist[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[u][i]];</span><br><span class="line">            <span class="keyword">if</span> (dist[e.to] &gt; dist[u] + e.val) &#123;</span><br><span class="line">                dist[e.to] = dist[u] + e.val;</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                    cnt[e.to]++;  <span class="comment">//统计修改次数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[e.to] &gt; n) &#123; <span class="comment">//修改大于n次</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">//存在负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn - <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        G[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x7f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); w = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(u, v, d); <span class="built_in">add</span>(v, u, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>(), d = <span class="built_in">read</span>();</span><br><span class="line">            <span class="built_in">add</span>(u, v, -d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">SPFA</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 164ms 1024kB */</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记-数论</title>
    <url>/p/da9a11f.html</url>
    <content><![CDATA[<p>模板地址: <a href="https://github.com/Tony031218/luogu/blob/master/Mathematics.cpp">GitHub</a></p>
<h2 id="欧几里得算法-Euclid-algorithm"><a href="#欧几里得算法-Euclid-algorithm" class="headerlink" title="欧几里得算法(Euclid algorithm)"></a>欧几里得算法(Euclid algorithm)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lcm(a, b) = a / gcd(a, b) * b</code></p>
<h3 id="扩展欧几里得算法-exGCD"><a href="#扩展欧几里得算法-exGCD" class="headerlink" title="扩展欧几里得算法(exGCD)"></a>扩展欧几里得算法(exGCD)</h3><p><strong><em>目标</em></strong>: 寻找一对整数$(x, y)$,使$ax+by=gcd(a,b)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123; d = a; x = <span class="number">1</span>; y = <span class="number">0</span>; &#125;  <span class="comment">//d为gcd(a, b)</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="built_in">exgcd</span>(b, a % b, d, y, x); y -= x * (a / b); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h4><p>$ax+by=c$且$x,y$全为正整数,则当且仅当$gcd(a, b)|c$</p>
<h2 id="素数相关"><a href="#素数相关" class="headerlink" title="素数相关"></a>素数相关</h2><h3 id="Eratosthenes筛法"><a href="#Eratosthenes筛法" class="headerlink" title="Eratosthenes筛法"></a>Eratosthenes筛法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>), num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    vis[<span class="number">0</span>] = vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">        prime[++num] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j += i) vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="欧拉线性筛"><a href="#欧拉线性筛" class="headerlink" title="欧拉线性筛"></a>欧拉线性筛</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getprime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime[++cnt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i * prime[j];</span><br><span class="line">            <span class="keyword">if</span> (v &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="素数定理"><a href="#素数定理" class="headerlink" title="素数定理"></a>素数定理</h3><p>$$<br>\pi(x) \sim \frac{x}{\ln x}<br>$$</p>
<h3 id="Miller-Rabin-素数测试"><a href="#Miller-Rabin-素数测试" class="headerlink" title="$Miller-Rabin$素数测试"></a>$Miller-Rabin$素数测试</h3><p><strong><em>原理</em></strong>:费马小定理<br>若$a^{n-1}\equiv 1\pmod n$,$a$取值越多,可以近似认为$n$为质数<br>使用二次探测定理改进卡卡迈尔数(合数$n$对于任何正整数$b$,都满足$gcd(b, n)=1\ \ b^{n-1}\equiv 1\pmod n$)的bug</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">Random</span><span class="params">(LL n)</span> </span>&#123; <span class="keyword">return</span> (LL)((<span class="keyword">double</span>)<span class="built_in">rand</span>() / RAND_MAX * n + <span class="number">0.5</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Witness</span><span class="params">(LL a, LL n)</span> </span>&#123;</span><br><span class="line">    LL m = n - <span class="number">1</span>; <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!(m &amp; <span class="number">1</span>)) &#123; j++; m &gt;&gt;= <span class="number">1</span>; &#125;</span><br><span class="line">    LL x = <span class="built_in">pow_mod</span>(a, m, n);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123; x = x * x % n; <span class="keyword">if</span> (x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(n &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        LL a = <span class="built_in">Random</span>(n - <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Witness</span>(a, n)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="模算术"><a href="#模算术" class="headerlink" title="模算术"></a>模算术</h2><p>$$<br>(a + b)\bmod n = ((a\bmod n) + (b\bmod n))\bmod n\\<br>(a - b)\bmod n = ((a\bmod n) - (b\bmod n) + n)\bmod n\\<br>ab\mod n = (a\bmod n)(b\bmod n)\bmod n<br>$$</p>
<h3 id="快速乘-ab-bmod-n"><a href="#快速乘-ab-bmod-n" class="headerlink" title="快速乘 $ab\bmod n$"></a>快速乘 $ab\bmod n$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul_mod</span><span class="params">(LL a, LL b, LL n)</span></span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = (res + a) % n;</span><br><span class="line">        a = (a + a) % n;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速幂-a-p-bmod-n"><a href="#快速幂-a-p-bmod-n" class="headerlink" title="快速幂 $a^p\bmod n$"></a>快速幂 $a^p\bmod n$</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL a, LL p, LL n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span> &amp;&amp; n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    LL ans = <span class="built_in">pow_mod</span>(a, p / <span class="number">2</span>, n); ans = ans * ans % n;</span><br><span class="line">    <span class="keyword">if</span> (p % <span class="number">2</span> == <span class="number">1</span>) ans = ans * a % n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用位运算:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">pow_mod</span><span class="params">(LL a, LL p, LL n)</span> </span>&#123;</span><br><span class="line">    a %= n; LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>, a *= a, a %= n) <span class="keyword">if</span>(p &amp; <span class="number">1</span>) ans = ans * a % n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉-varphi-函数"><a href="#欧拉-varphi-函数" class="headerlink" title="欧拉$\varphi$函数"></a>欧拉$\varphi$函数</h2><p>$$\varphi(n)=n(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})$$<br>$\varphi(n)$表示不超过$n$且与$n$互质的整数个数</p>
<h3 id="求值"><a href="#求值" class="headerlink" title="求值"></a>求值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>); <span class="keyword">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; ++i) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">        ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛欧拉函数表"><a href="#筛欧拉函数表" class="headerlink" title="筛欧拉函数表"></a>筛欧拉函数表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_table</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) phi[i] = <span class="number">0</span>; phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) <span class="keyword">if</span> (!phi[i])</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!phi[j]) phi[j] = j;</span><br><span class="line">            phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同余式定理"><a href="#同余式定理" class="headerlink" title="同余式定理"></a>同余式定理</h2><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若$gcd(a, n) = 1$,则$a^{\varphi(n)}\equiv 1\pmod n$</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若$p$为质数,则$a^{p-1}\equiv 1\pmod p$</p>
<h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><p>若$p$为质数,则$(p-1)!\equiv -1\pmod p$</p>
<h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><p>$$a\div b\bmod n = a\times b^{-1}\bmod n$$<br>$b^{-1}$称为$b$在模$n$意义下的逆元</p>
<h3 id="n-为质数"><a href="#n-为质数" class="headerlink" title="$n$为质数"></a>$n$为质数</h3><p>使用费马小定理, $a^{-1} = a^{n - 2}$</p>
<h3 id="n-不为质数"><a href="#n-不为质数" class="headerlink" title="$n$不为质数"></a>$n$不为质数</h3><p>递归求解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL a, LL n)</span> </span>&#123;</span><br><span class="line">    LL d, x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, n, d, x, y);</span><br><span class="line">    <span class="keyword">return</span> d == <span class="number">1</span> ? (x + n) % n : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="筛逆元表"><a href="#筛逆元表" class="headerlink" title="筛逆元表"></a>筛逆元表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> inv_table[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getinv</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    inv_table[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        inv_table[i] = (LL)(p - p / i) * inv_table[p % i] % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h2><p>$ax\equiv b\pmod n$可以化为$ax+ny=b$使用扩展欧拉定理解决</p>
<h3 id="中国剩余定理-China-Remainder-Theorem"><a href="#中国剩余定理-China-Remainder-Theorem" class="headerlink" title="中国剩余定理(China Remainder Theorem)"></a>中国剩余定理(China Remainder Theorem)</h3><p>求解$x\equiv a_i\pmod {m_i}$满足$m_i$两两互质</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">crt</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* a, <span class="keyword">int</span>* m)</span> </span>&#123;</span><br><span class="line">    LL M = <span class="number">1</span>, d, y, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) M *= m[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        LL w = M / m[i];</span><br><span class="line">        <span class="built_in">exgcd</span>(m[i], w, d, d, y);</span><br><span class="line">        x = (x + y * w * a[i]) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (x + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展中国剩余定理-exCRT"><a href="#扩展中国剩余定理-exCRT" class="headerlink" title="扩展中国剩余定理(exCRT)"></a>扩展中国剩余定理(exCRT)</h4><p>$m_i$不一定两两互质</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">excrt</span><span class="params">(LL n, LL* a, LL* m)</span> </span>&#123;</span><br><span class="line">    LL x, y, k, M = m[<span class="number">0</span>], ans = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        LL A = M, B = m[i], C = (a[i] - ans % B + B) % B, gcd;</span><br><span class="line">        <span class="built_in">exgcd</span>(A, B, gcd, x, y);</span><br><span class="line">        LL bg = B / gcd;</span><br><span class="line">        <span class="keyword">if</span> (C % gcd != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x = <span class="built_in">mul_mod</span>(x, C / gcd, bg);</span><br><span class="line">        ans += x * M; M *= bg;</span><br><span class="line">        ans = (ans % M + M) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % M + M) % M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="离散对数-BSGS"><a href="#离散对数-BSGS" class="headerlink" title="离散对数(BSGS)"></a>离散对数(BSGS)</h3><p>求解$a^x\equiv b\pmod n$满足$n$为质数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_mod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, v, e = <span class="number">1</span>, i;</span><br><span class="line">    m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">    v = <span class="built_in">inv</span>(<span class="built_in">pow_mod</span>(a, m, n), n);</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x;</span><br><span class="line">    x[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        e = <span class="built_in">mul_mod</span>(e, a, n);</span><br><span class="line">        <span class="keyword">if</span> (!x.<span class="built_in">count</span>(e)) x[e] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.<span class="built_in">count</span>(b)) <span class="keyword">return</span> i * m + x[b];</span><br><span class="line">        b = <span class="built_in">mul_mod</span>(b, v, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h2><h3 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h3><p>整除分块可以对后面的莫比乌斯反演提供很大的优化<br>通过<del>枚举</del>可以发现$\lfloor \frac{n}{i} \rfloor$的结果会出现分块现象<br>例如$n=10$时<br>$\ \ \ i\ \ \ \ 1\ \ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10\ 11\ 12\ 13\ …$<br>$\lfloor \frac{n}{i} \rfloor\ 10\ 5\ 3\ 2\ 2\ 1\ 1\ 1\ 1\ 1\ \ \ 0\ \ \ 0\ \ \ 0\ \ \ …$<br><del>不难发现</del>,每个块的右端点为$r=\lfloor \frac{n}{t}\rfloor (t=\lfloor \frac{n}{i}\rfloor)$</p>
<h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p>$$<br>\mu(n) =<br>\begin{cases}<br>1,  &amp; n=1 \\<br>(-1)^r, &amp; n=p_1p_2p_3…p_r(\text{$p_i$为互不相同的质数}) \\<br>0,  &amp; else<br>\end{cases}<br>$$<br><strong><em>性质</em></strong>:<br>$$\sum_{d|n}{\mu(d)}=[n=1]$$<br>$$\sum_{d|n}{\frac{\mu(d)}{d}}=\frac{\varphi(n)}{n}$$<br><strong><em>线性筛</em></strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mu[maxn], vis[maxn];</span><br><span class="line"><span class="keyword">int</span> primes[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_mu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">	<span class="built_in">memset</span>(mu, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mu));</span><br><span class="line">	cnt = <span class="number">0</span>; mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!vis[i]) &#123; primes[cnt++] = i; mu[i] = <span class="number">-1</span>; &#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; primes[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">			vis[primes[j] * i] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">			mu[i * primes[j]] = -mu[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P1516」青蛙的约会-题解</title>
    <url>/p/1f4bfad8.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P1516">「Luogu P1516」青蛙的约会</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>(规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴)<br>现有两只青蛙$A,B$<br>设青蛙$A$的出发点坐标是$x$，青蛙$B$的出发点坐标是$y$<br>青蛙$A$一次能跳$m$米，青蛙$B$一次能跳$n$米，两只青蛙跳一次所花费的时间相同<br>纬度线总长$l$米<br>求两只青蛙跳了几次以后才会碰面</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>__<em>同余方程</em>__模板题<br>求解$x + km\equiv y + kn \pmod l$</p>
<p>$Solve:$<br>$$<br>x+km−(y+kn)=lz,\ \ z\in Z\\<br>(x-y)+k(m-n)-lz=0\\<br>k(n-m)+lz=(x-y)<br>$$<br>令$a=x-y,b=n-m$<br>上式可化为:<br>$$<br>kb+lz=a<br>$$<br>求这个方程的最小整数解<br>化为求此不定方程最小整数解<br>$$k’b+lz’=gcd(b,l)$$<br>使用扩展欧几里得算法可得一组特解$(k’,b’)$<br>最小解为$k_{min} = k’\bmod \frac{l}{gcd(b,l)}$<br>以上解$k_{min}$的方程右边是$gcd(b,l)$而不是$a$<br>所以结果为<br>$$\boxed{ (k’\times \frac{a}{gcd(b,l)})\bmod \frac{l}{gcd(b,l)} }$$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123; d = a; x = <span class="number">1</span>; y = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="built_in">exgcd</span>(b, a % b, d, y, x); y -= x * (a / b); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL n, m, x, y, l, gcd, x1, y1;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld %lld %lld&quot;</span>, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l);</span><br><span class="line">    LL b = n - m, a = x - y;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123; b = -b, a = -a; &#125;</span><br><span class="line">    <span class="built_in">exgcd</span>(b, l, gcd, x1, y1);</span><br><span class="line">    <span class="keyword">if</span> (a % gcd) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Impossible\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LL ans = ((x1 * (a / gcd)) % (l / gcd) + (l / gcd)) % (l / gcd);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 26ms 916kB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2016」题解</title>
    <url>/p/2a6e5fce.html</url>
    <content><![CDATA[<p>$???$就一道紫题$???$,还是$D1T2\ ???$</p>
<span id="more"></span>

<h2 id="D1T1-玩具迷题"><a href="#D1T1-玩具迷题" class="headerlink" title="$D1T1$ 玩具迷题"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P1563">玩具迷题</a></h2><p>简单的__<em>模拟</em>__,没的说</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> towards;</span><br><span class="line">    string name;</span><br><span class="line">&#125; a[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ai, si;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i].towards &gt;&gt; a[i].name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> peo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; ai &gt;&gt; si;</span><br><span class="line">        <span class="keyword">if</span> (ai == <span class="number">0</span> &amp;&amp; a[peo].towards == <span class="number">0</span>) peo = (peo + n - si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">0</span> &amp;&amp; a[peo].towards == <span class="number">1</span>) peo = (peo + si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">1</span> &amp;&amp; a[peo].towards == <span class="number">0</span>) peo = (peo + si) % n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ai == <span class="number">1</span> &amp;&amp; a[peo].towards == <span class="number">1</span>) peo = (peo + n - si) % n;</span><br><span class="line">    &#125; </span><br><span class="line">    cout &lt;&lt; a[peo].name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* 430ms 4760kB */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2017」题解</title>
    <url>/p/c5ac34f0.html</url>
    <content><![CDATA[<pre><code>NOIp2017的题比NOIp2018的题好做一点
</code></pre>
<span id="more"></span>

<h2 id="D1T1-小凯的疑惑"><a href="#D1T1-小凯的疑惑" class="headerlink" title="$D1T1$ 小凯的疑惑"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P3951">小凯的疑惑</a></h2><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>推柿子(<del>正确性未知</del>)<br>设$a &lt; b$ 答案为$x$<br>所以:<br>$$x \equiv ma \pmod b (1 \leq m \leq b - 1)$$<br>即$x = ma + nb (1 \leq m \leq b - 1)$<br>显然当$ n \geq 0$时 $x$可以用$a, b$表示出来，不合题意<br>因此当$n = -1$时$x$取得最大值，此时$x = ma - b$<br>显然当$m$取得最大值$b - 1$时$x$最大，此时$x = (b - 1)a - b = ab - a - b$<br>因此$a, b$所表示不出的最大的数是<br>$$\boxed{ab - a - b}$$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, a * b - a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 60ms 948kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T2-时间复杂度"><a href="#D1T2-时间复杂度" class="headerlink" title="$D1T2$ 时间复杂度"></a>$D1T2$ <a href="https://www.luogu.org/problemnew/show/P3952">时间复杂度</a></h2><p><del>毒瘤</del>大模拟<br>没什么好说的,直接上代码</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str1, str2;      </span><br><span class="line"><span class="keyword">int</span> cal, O, NumOfLoop, vis[<span class="number">27</span>], var[<span class="number">27</span>], Onow, Kill, AddO[<span class="number">100</span>], Omax, WhereKill, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        T--;</span><br><span class="line">        cal = <span class="number">0</span>; O = <span class="number">0</span>; Omax = <span class="number">0</span>; WhereKill = <span class="number">0</span>; NumOfLoop = <span class="number">0</span>; Onow = <span class="number">0</span>; Kill = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(AddO, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(AddO));</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            str1 = str2;</span><br><span class="line">            cin &gt;&gt; str2;</span><br><span class="line">        &#125; <span class="keyword">while</span>(str2[<span class="number">0</span>] != <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">length</span>(); i++) cal = cal * <span class="number">10</span> + str1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; str2.<span class="built_in">length</span>() - <span class="number">1</span>; i++) O = O * <span class="number">10</span> + str2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (cal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cal--;</span><br><span class="line">            cin &gt;&gt; str1;</span><br><span class="line">            <span class="keyword">if</span> (str1[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">                NumOfLoop++;</span><br><span class="line">                cin &gt;&gt; str1;</span><br><span class="line">                <span class="keyword">if</span> (vis[str1[<span class="number">0</span>] - <span class="number">96</span>]) &#123;</span><br><span class="line">                    NumOfLoop = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                	vis[str1[<span class="number">0</span>] - <span class="number">96</span>] = <span class="number">1</span>;</span><br><span class="line">                    var[NumOfLoop] = str1[<span class="number">0</span>] - <span class="number">96</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">                <span class="keyword">if</span> (str1[<span class="number">0</span>] != <span class="string">&#x27;n&#x27;</span> &amp;&amp; str2[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> &amp;&amp; Kill == <span class="number">0</span>) &#123;</span><br><span class="line">                    Onow++;</span><br><span class="line">                    AddO[NumOfLoop] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((str1.<span class="built_in">length</span>() == str2.<span class="built_in">length</span>() &amp;&amp; str1 &gt; str2) || (str1.<span class="built_in">length</span>() &gt; str2.<span class="built_in">length</span>()) || (str1[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> &amp;&amp; str2[<span class="number">0</span>] != <span class="string">&#x27;n&#x27;</span>)) &amp;&amp; Kill == <span class="number">0</span>) &#123;</span><br><span class="line">                    Kill = <span class="number">1</span>;</span><br><span class="line">                    WhereKill = NumOfLoop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                Omax = <span class="built_in">max</span>(Omax, Onow);</span><br><span class="line">                vis[var[NumOfLoop]] = <span class="number">0</span>; </span><br><span class="line">                <span class="keyword">if</span> (AddO[NumOfLoop] == <span class="number">1</span>) &#123;</span><br><span class="line">                    Onow--;</span><br><span class="line">                    AddO[NumOfLoop] = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                NumOfLoop--; </span><br><span class="line">                <span class="keyword">if</span> (WhereKill &gt; <span class="number">0</span> &amp;&amp; NumOfLoop &lt; WhereKill) &#123;</span><br><span class="line">                    Kill = <span class="number">0</span>; WhereKill = <span class="number">0</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(NumOfLoop == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ERR\n&quot;</span>);</span><br><span class="line">                cal = <span class="number">-1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;ERR\n&quot;</span>); </span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop == <span class="number">0</span> &amp;&amp; Omax == O) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (NumOfLoop == <span class="number">0</span> &amp;&amp; Omax != O) <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 34ms 756kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T3-逛公园"><a href="#D1T3-逛公园" class="headerlink" title="$D1T3$ 逛公园"></a>$D1T3$ <a href="https://www.luogu.org/problemnew/show/P3953">逛公园</a></h2><p>本题思路来自<a href="https://www.luogu.org/blog/Annie-007/ti-xie-p3953-guang-gong-yuan">安妮007的题解</a></p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><ol>
<li>先SPFA求最短路</li>
<li>再反向SPFA排除无法到达的边</li>
<li>再记忆化搜索走冤枉路的最优方案</li>
</ol>
<p>详细见<a href="https://www.luogu.org/blog/Annie-007/ti-xie-p3953-guang-gong-yuan">安妮007的题解</a></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, p, T;</span><br><span class="line">vector&lt;Node&gt; v[maxn], s[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn], ans[maxn][<span class="number">60</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][<span class="number">60</span>], alive[maxn];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q, f;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="comment">//a当前点,b允许走的冤枉路长度</span></span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vis[a][b] == <span class="number">1</span>) &#123;  <span class="comment">//又回来了</span></span><br><span class="line">        <span class="keyword">return</span> -inf;              <span class="comment">//无穷多种(-inf用于判断)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ans[a][b] != <span class="number">-1</span>) &#123; <span class="comment">//算过了</span></span><br><span class="line">        <span class="keyword">return</span> ans[a][b];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vis[a][b] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (a == n) &#123; <span class="comment">//到目的地</span></span><br><span class="line">            key++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[a].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = v[a][i].x, y = v[a][i].y; <span class="comment">//g本条边终点,y权值</span></span><br><span class="line">            <span class="keyword">int</span> u = d[g] - d[a];</span><br><span class="line">            <span class="keyword">if</span> (alive[g] == <span class="number">0</span>) &#123; <span class="comment">//不能到终点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> w = <span class="built_in">dfs</span>(g, b - (y - u));</span><br><span class="line">            <span class="keyword">if</span> (w == -inf) &#123;</span><br><span class="line">                <span class="keyword">return</span> -inf;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                key = (key + w) % p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[a][b] = key % p;</span><br><span class="line">        vis[a][b] = <span class="literal">false</span>; <span class="comment">//回溯</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe</span><span class="params">()</span> </span>&#123; <span class="comment">//排除无法到终点的点(反向SPFA)</span></span><br><span class="line">    f.<span class="built_in">push</span>(n);</span><br><span class="line">    alive[n] = <span class="number">1</span>;  <span class="comment">//点n自身可以到达</span></span><br><span class="line">    <span class="keyword">while</span> (!f.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = f.<span class="built_in">front</span>(); f.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[h].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = s[h][i].x;</span><br><span class="line">            <span class="keyword">if</span> (alive[g] == <span class="number">0</span>) &#123;</span><br><span class="line">                alive[g] = <span class="number">1</span>;</span><br><span class="line">                f.<span class="built_in">push</span>(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123; <span class="comment">//SPFA求最短路</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[h].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> g = v[h][i].x, y = v[h][i].y;</span><br><span class="line">            <span class="keyword">if</span> (d[h] + y &lt; d[g]) &#123;</span><br><span class="line">                d[g] = d[h] + y;</span><br><span class="line">                q.<span class="built_in">push</span>(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            v[i].<span class="built_in">clear</span>();</span><br><span class="line">            s[i].<span class="built_in">clear</span>();</span><br><span class="line">            alive[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                ans[i][j] = <span class="number">-1</span>;</span><br><span class="line">                vis[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            v[a].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(b, c));     <span class="comment">//正向边</span></span><br><span class="line">            s[b].<span class="built_in">push_back</span>(<span class="built_in">Node</span>(a, c));     <span class="comment">//反向边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            d[i] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">spfa</span>();  <span class="comment">//SPFA求最短路</span></span><br><span class="line">        <span class="built_in">safe</span>();</span><br><span class="line">        <span class="keyword">int</span> z = <span class="built_in">dfs</span>(<span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">if</span> (z == -inf) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 6488ms 44632kB with O2 */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T1-奶酪"><a href="#D2T1-奶酪" class="headerlink" title="$D2T1$ 奶酪"></a>$D2T1$ <a href="https://www.luogu.org/problemnew/show/P3958">奶酪</a></h2><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>没什么好说的,直接__<em>搜索</em>__<br>存好每个点,排序,从下向上搜</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> fini = <span class="literal">false</span>, vis[maxn];</span><br><span class="line"><span class="keyword">int</span> T, n, h, r;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y, z;</span><br><span class="line">&#125; node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.z &gt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.x - b.x, <span class="number">2</span>) + <span class="built_in">pow</span>(a.y - b.y, <span class="number">2</span>) + <span class="built_in">pow</span>(a.z - b.z, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node now, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now.z + r &gt;= h) &#123;</span><br><span class="line">        fini = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[num] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fini) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vis[i] &amp;&amp; <span class="built_in">dist</span>(node[i], now) &lt;= r * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(node[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        fini = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(node, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(node));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;h, &amp;r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf %lf&quot;</span>, &amp;node[i].x, &amp;node[i].y, &amp;node[i].z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(node + <span class="number">1</span>, node + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node[i].z - r &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(node[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(fini ? <span class="string">&quot;Yes\n&quot;</span> : <span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 157ms 832kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T2-宝藏"><a href="#D2T2-宝藏" class="headerlink" title="$D2T2$ 宝藏"></a>$D2T2$ <a href="https://www.luogu.org/problemnew/show/P3959">宝藏</a></h2><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>状压?? 模拟退火?? <del>不存在的</del> 蒟蒻不会<br>__<em>搜索+剪枝</em>__能很快AC掉这道紫题<br>不解释了</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">20</span>], dis[<span class="number">20</span>], num[<span class="number">20</span>]; <span class="comment">//已访问的点,距1的距离,可以到达的点数</span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">20</span>][<span class="number">20</span>], G[<span class="number">20</span>][<span class="number">20</span>]; <span class="comment">//费用,图</span></span><br><span class="line"><span class="keyword">int</span> ans = inf, tmp, tot, cnt, n, m, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c[p][a] &lt; c[p][b];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = u; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot + tmp * dis[vis[i]] &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = node; j &lt;= num[vis[i]]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dis[G[vis[i]][j]]) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                vis[cnt] = G[vis[i]][j];</span><br><span class="line">                tmp -= c[vis[cnt]][G[vis[cnt]][<span class="number">1</span>]];</span><br><span class="line">                tot += c[vis[i]][vis[cnt]] * dis[vis[i]];</span><br><span class="line">                dis[vis[cnt]] = dis[vis[i]] + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(i, j + <span class="number">1</span>);</span><br><span class="line">                tot -= c[vis[i]][vis[cnt]] * dis[vis[i]];</span><br><span class="line">                dis[vis[cnt]] = <span class="number">0</span>;</span><br><span class="line">                tmp += c[vis[cnt]][G[vis[cnt]][<span class="number">1</span>]];</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(tot &lt; ans) ans = tot;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            c[i][j] = inf;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        <span class="keyword">if</span>(c[u][v] &lt; w) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[u][v] == inf) &#123;</span><br><span class="line">            G[u][++num[u]] = v;</span><br><span class="line">            G[v][++num[v]] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        c[u][v] = c[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        p = i;</span><br><span class="line">        <span class="built_in">sort</span>(G[i] + <span class="number">1</span>, G[i] + <span class="number">1</span> + num[i], cmp);</span><br><span class="line">        tmp += c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        tot = <span class="number">0</span>; cnt = <span class="number">1</span>;</span><br><span class="line">        vis[<span class="number">1</span>] = i;</span><br><span class="line">        tmp -= c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">        dis[i] = <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        dis[i] = <span class="number">0</span>;</span><br><span class="line">        tmp += c[i][G[i][<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 65ms 808kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T3-列队"><a href="#D2T3-列队" class="headerlink" title="$D2T3$ 列队"></a>$D2T3$ <a href="https://www.luogu.org/problemnew/show/P3960">列队</a></h2><p>平衡树?? $Splay$?? $FHQ\_Treap$?? <del>不会</del><br>模拟拿下$50$分,以后再说,<del>逃</del></p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, q, tot;</span><br><span class="line">LL last[maxn], h[maxn], pos[<span class="number">510</span>][<span class="number">50010</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>(); q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        a[i].x = <span class="built_in">read</span>();</span><br><span class="line">        a[i].y = <span class="built_in">read</span>();</span><br><span class="line">        h[i] = a[i].x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        last[i] = last[i - <span class="number">1</span>] + m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(h + <span class="number">1</span>, h + q + <span class="number">1</span>);                 <span class="comment">//排序</span></span><br><span class="line">    tot = <span class="built_in">unique</span>(h + <span class="number">1</span>, h + q + <span class="number">1</span>) - h - <span class="number">1</span>; <span class="comment">//去重</span></span><br><span class="line">    LL t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i) &#123; <span class="comment">//编号</span></span><br><span class="line">        t = (LL)(h[i] - <span class="number">1</span>) * m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            pos[i][j] = ++t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> where; <span class="comment">//a[i].x在h数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123; <span class="comment">//模拟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[j] == a[i].x) &#123;</span><br><span class="line">                where = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i].y == m) &#123; <span class="comment">//在最后一列</span></span><br><span class="line">            ans = last[h[where]];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = pos[where][a[i].y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">if</span> (a[i].y != m) &#123; <span class="comment">//向左看齐</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i].y; j &lt; m - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                pos[where][j] = pos[where][j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            pos[where][m - <span class="number">1</span>] = last[h[where]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = h[where]; j &lt; n; ++j) &#123; <span class="comment">//向前看齐</span></span><br><span class="line">            last[j] = last[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        last[n] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 50Points 13662ms 67344kB */</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」魔术球问题-题解</title>
    <url>/p/f2e850c0.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2765">「Luogu P2765」魔术球问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>输入柱子数$n$<br>满足如下规则</p>
<ul>
<li>每次只能在某根柱子的最上面放球。</li>
<li>在同一根柱子中，任何2个相邻球的编号之和为完全平方数。<br>输出在第$n$根柱子上最多能放多少球和放置方案</li>
</ul>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>并不打算使用网络流,用贪心即可<br><em>贪心策略</em>: <strong>如果可以的话尽可能放在已有的柱子上</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> can[<span class="number">4010</span>];</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">1</span>, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= <span class="number">4000</span>; ++i) &#123;</span><br><span class="line">        can[i * i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can[ ans + a[ i ][ a[i].<span class="built_in">size</span>() - <span class="number">1</span> ] ]) &#123;</span><br><span class="line">                a[i].<span class="built_in">push_back</span>(ans++);</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt; n) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            a[cnt].<span class="built_in">push_back</span>(ans++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」最小路径覆盖问题-题解</title>
    <url>/p/7973b062.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2764">「Luogu P2764」最小路径覆盖问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>题目描述给的很直白,输入点数边数和有向边,输出最少路径数和路径</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>正常建图<br>如果一条路径的终点和另一条路径的起点有连边，那么这两条路径是可以合并的。<br>但是一个终点或起点只能使用一次。比如三条路径$1 \rightarrow 3, 2 \rightarrow 3, 3 \rightarrow 4$，你只能合并两条。<br>那么这道题就转化为了：最大化一个边集，使得边集中每个起点和终点都只使用过一次。即__最大独立边集__。<br>把每个点拆成入点$x$和出点$x’$,从源点到$x’$连一条容量为$1$的边，从$x$到汇点连一条容量为$1$的边。边权用来限制每个起点或终点的使用次数。<br>对于每条边$x \rightarrow y$，连接$x’ \rightarrow y$<br>答案是$n-最大流$</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn], vst[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn], to[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f) : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="literal">true</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            to[x] = e.to;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxflow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    s = <span class="number">0</span>; t = <span class="number">2</span> * n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">add</span>(u, v + n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(s, i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">add</span>(i + n, t, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">maxflow</span>(s, t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vst[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i; vst[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">            <span class="keyword">while</span> (to[x] &amp;&amp; to[x] != t) &#123;</span><br><span class="line">                x = to[x] - n;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">                vst[x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」试题库问题-题解</title>
    <url>/p/5a8ce31f.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2763">「Luogu P2763」试题库问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>假设一个试题库中有$n$道试题,每道试题都标明了所属类别,同一道题可能有多个类别属性,现要从题库中抽取$m$道题组成试卷,并要求试卷包含指定类型的试题,输出出题方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>建图</strong>: 类型与汇点连容量为题目数的边;题目与源点连容量为$1$的边;题目与所属类型连容量为$1$的边<br><strong>结果</strong>: 如果满流则可以实现(沿满流输出即可),没有满流输出<code>No Solution!</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> k, n, s, t, sum, d[maxn], cur[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn], ansi;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;k, &amp;n);</span><br><span class="line">    s = <span class="number">0</span>; t = n + k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;type);</span><br><span class="line">        sum += type; <span class="built_in">add</span>(n + i, t, type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> p, type;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;type);</span><br><span class="line">            <span class="built_in">add</span>(i, type + n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="built_in">MaxFlow</span>(s, t);</span><br><span class="line">    <span class="keyword">if</span> (maxflow == sum) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= n + k; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: &quot;</span>, i - n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; G[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[i][j]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap == <span class="number">0</span> &amp;&amp; e.flow != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Solution!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>「Luogu P5020 P1621 P4942」小练习-题解</title>
    <url>/p/eb0c7a6c.html</url>
    <content><![CDATA[<h2 id="mathcal-「P5020」-货币系统"><a href="#mathcal-「P5020」-货币系统" class="headerlink" title="$\mathcal{「P5020」}$ 货币系统"></a>$\mathcal{「P5020」}$ <a href="https://www.luogu.org/problemnew/show/P5020">货币系统</a></h2><p>表面上是数论，其实就是个__<em>动态规划</em>__</p>
<p>首先设$A = (n, a) \ \ B = (m, b)$<br>可以证明$B \subseteq A$<br>$proof:$<br>    我们设$x\in A$且$x$不能被$A$集合内除它以外的元素组成。<br>    然后我们假设$x \notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。<br>    那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。<br>    综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内<br>$Q.E.D$</p>
<p>然后动态规划<br><code>dp[i]</code>表示$i$面值最多能被几张钱表示<br>则若其不能被表示<code>dp[i] = -inf</code><br>能表示且只有它自己则<code>dp[i] = 1</code><br>初始化<code>dp[] = -inf; dp[0] = 0</code><br>状态转移方程为<code>dp[j] = max(dp[j], dp[j - a[i]] + 1)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, ans, a[<span class="number">1010</span>], dp[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        ans = <span class="number">0</span>; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= <span class="number">25010</span>; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[a[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 862ms 944kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="mathcal-「P1621」-集合"><a href="#mathcal-「P1621」-集合" class="headerlink" title="$\mathcal{「P1621」}$ 集合"></a>$\mathcal{「P1621」}$ <a href="https://www.luogu.org/problemnew/show/P1621">集合</a></h2><p>使用__<em>并查集</em><strong>和</strong><em>埃氏筛法</em>__(埃拉托斯特尼筛法)即可<br>具体操作是边筛边合并集合</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ufs[maxn], a, b, p, ans;</span><br><span class="line"><span class="keyword">bool</span> isprime[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ufs[x] == x ? x : ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;p);</span><br><span class="line">    ans = b - a + <span class="number">1</span>;               <span class="comment">//初始个数为区间内数的个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt;= b; ++i) &#123; <span class="comment">//初始化</span></span><br><span class="line">        ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= b; ++i) &#123; <span class="comment">//埃氏筛</span></span><br><span class="line">        <span class="keyword">if</span> (!isprime[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= p) &#123;          <span class="comment">//大于p才合并</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= b; j += i) &#123;</span><br><span class="line">                    isprime[j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &gt;= a &amp;&amp; <span class="built_in">find</span>(j) != <span class="built_in">find</span>(j - i)) &#123; <span class="comment">//合并</span></span><br><span class="line">                        ufs[<span class="built_in">find</span>(j)] = <span class="built_in">find</span>(j - i);</span><br><span class="line">                        --ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;               <span class="comment">//不大于p但要标记</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= b; j += i) &#123;</span><br><span class="line">                    isprime[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 38ms 1312kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="mathcal-「P4942」-小凯的数字"><a href="#mathcal-「P4942」-小凯的数字" class="headerlink" title="$\mathcal{「P4942」}$ 小凯的数字"></a>$\mathcal{「P4942」}$ <a href="https://www.luogu.org/problemnew/show/P4942">小凯的数字</a></h2><p>类似于$NOIp2017\ D1T1$ <a href="https://www.luogu.org/problemnew/show/P3951">小凯的疑惑</a>,推柿子即可</p>
<p>首先$l(l+1)(l+2)…(r-1)r$可以表示为$l\times 10^? + (l + 1)\times 10^? + … + r\times 10^?$<br>同时我们知道$10$的若干次方除以$9$的余数__恒为__$1$<br>所以$l(l+1)(l+2)…(r-1)r$除以$9$的余数就等于$l + (l + 1) + … + (r - 1) + r$的余数<br>并且$l,l+1,…,r$为等差数列,公差为$1$<br>运用等差数列求和公式即可求解</p>
<p>$a_1 = l\ d = 1$<br>$n = r - l + 1$<br>$S_n = n\times a_1 + n\times (n - 1)\times \frac{d}{2}$<br>所以<br>$$<br>\boxed{Ans = n\times l + n\times (n - 1) \div 2}<br>$$</p>
<p>另外要边算边取模,除以$2$要变成乘模$9$下的逆元$5$<br>所以公式如下<br><code>ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> l, r, n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        n = (r - l + <span class="number">1</span>) % <span class="number">9</span>;</span><br><span class="line">        ans = (n * (l % <span class="number">9</span>) % <span class="number">9</span> + n * (n - <span class="number">1</span>) % <span class="number">9</span> * <span class="number">5</span> % <span class="number">9</span>) % <span class="number">9</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 32ms 888kB */</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>题解</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title>「网络流24题」飞行员配对方案问题-题解</title>
    <url>/p/154ff24f.html</url>
    <content><![CDATA[<p>题目传送门: <a href="https://www.luogu.org/problemnew/show/P2756">「Luogu P2756」飞行员配对方案数问题</a></p>
<span id="more"></span>

<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>输入两方飞行员个数$m,n$,再给定两方飞行员可以配合的人编号$i,j$(以$-1,-1$结束)<br>输出最多配对数和配对方案</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>主要在建图<br>皇家空军与源点$s$连容量$1$的边,外籍与汇点$t$连容量$1$的边,可配合的两点间连容量为$1$的边<br>输出最大流即可(要找配对方案)</p>
<p>也可以使用匈牙利算法(本文不给出)</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], cur[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">             Edge&amp; e = edges[G[x][i]];</span><br><span class="line">             <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                 vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                 d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                 Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">dfs</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">dfs</span>(s, inf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    s = <span class="number">0</span>; t = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v) == <span class="number">2</span> &amp;&amp; u != <span class="number">-1</span> &amp;&amp; v != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">add</span>(u, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(s, i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, t, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="built_in">MaxFlow</span>(s, t);</span><br><span class="line">    <span class="keyword">if</span> (flow == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;No Solution!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, flow);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.<span class="built_in">size</span>(); i = i + <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edges[i].from != s &amp;&amp; edges[i].to != t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[i].flow != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, edges[i].from, edges[i].to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>网络流24题</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-网络流相关</title>
    <url>/p/c3cdab79.html</url>
    <content><![CDATA[<p>网络流算法相关模板,讲解__以后再说吧__,咕咕咕</p>
<span id="more"></span>

<p>注:本文使用<code>vector</code>建图</p>
<h2 id="网络最大流"><a href="#网络最大流" class="headerlink" title="网络最大流"></a>网络最大流</h2><h3 id="Edmonds-Karp算法"><a href="#Edmonds-Karp算法" class="headerlink" title="Edmonds-Karp算法"></a>Edmonds-Karp算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, s, t, ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EdmondsKarp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        Q.<span class="built_in">push</span>(s);</span><br><span class="line">        a[s] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (!a[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                    p[e.to] = G[x][i];</span><br><span class="line">                    a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[t]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!a[t]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">            edges[p[u]].flow += a[t];</span><br><span class="line">            edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">        &#125;</span><br><span class="line">        ans += a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dinic算法-常用"><a href="#Dinic算法-常用" class="headerlink" title="Dinic算法(常用)"></a>Dinic算法(常用)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, d[maxn], cur[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;from, to, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>((Edge) &#123;to, from, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                d[e.to] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == t || a == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>&amp; i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        Edge&amp; e = edges[G[x][i]];</span><br><span class="line">        <span class="keyword">if</span> (d[x] + <span class="number">1</span> == d[e.to] &amp;&amp; (f = <span class="built_in">DFS</span>(e.to, <span class="built_in">min</span>(a, e.cap - e.flow))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            e.flow += f;</span><br><span class="line">            edges[G[x][i] ^ <span class="number">1</span>].flow -= f;</span><br><span class="line">            flow += f;</span><br><span class="line">            a -= f;</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxFlow</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BFS</span>()) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">        flow += <span class="built_in">DFS</span>(s, <span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ISAP算法"><a href="#ISAP算法" class="headerlink" title="ISAP算法"></a>ISAP算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> d[maxn], p[maxn], num[maxn], cur[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(from, to, cap, <span class="number">0</span>));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(to, from, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[from].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[to].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(t);</span><br><span class="line">    d[t] = <span class="number">0</span>; vis[t] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) &#123;</span><br><span class="line">                vis[e.from] = <span class="number">1</span>;</span><br><span class="line">                d[e.from] = d[x] + <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span>(e.from);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Augment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = t, a = inf;</span><br><span class="line">    <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">        Edge&amp; e = edges[p[x]];</span><br><span class="line">        a = <span class="built_in">min</span>(a, e.cap - e.flow);</span><br><span class="line">        x = edges[p[x]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    x = t;</span><br><span class="line">    <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">        edges[p[x]].flow += a;</span><br><span class="line">        edges[p[x] ^ <span class="number">1</span>].flow -= a;</span><br><span class="line">        x = edges[p[x]].from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ISAP</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(num));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) num[d[i]]++;</span><br><span class="line">    <span class="keyword">int</span> x = s;</span><br><span class="line">    <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cur));</span><br><span class="line">    <span class="keyword">while</span> (d[s] &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == t) &#123;</span><br><span class="line">            flow += <span class="built_in">Augment</span>();</span><br><span class="line">            x = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ok = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = cur[x]; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + <span class="number">1</span>) &#123;</span><br><span class="line">                ok = <span class="number">1</span>;</span><br><span class="line">                p[e.to] = G[x][i];</span><br><span class="line">                cur[x] = i;</span><br><span class="line">                x = e.to;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            <span class="keyword">int</span> mm = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                Edge&amp; e = edges[G[x][i]];</span><br><span class="line">                <span class="keyword">if</span> (e.cap &gt; e.flow) mm = <span class="built_in">min</span>(mm, d[e.to]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (--num[d[x]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            num[d[x] = mm + <span class="number">1</span>]++;</span><br><span class="line">            cur[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (x != s) x = edges[p[x]].from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ansflow;</span><br><span class="line"><span class="keyword">int</span> vis[maxn], d[maxn], p[maxn], a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> anscost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, cap, flow, cost;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> f, <span class="keyword">int</span> w): <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">cap</span>(c), <span class="built_in">flow</span>(f), <span class="built_in">cost</span>(w)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, c, <span class="number">0</span>, w));</span><br><span class="line">    edges.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>,-w));</span><br><span class="line">    <span class="keyword">int</span> mm = edges.<span class="built_in">size</span>();</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(mm - <span class="number">2</span>);</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(mm - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(<span class="keyword">int</span>&amp; flow, <span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) d[i] = inf;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">    d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; p[s] = <span class="number">0</span>; a[s] = inf;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[x].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            Edge&amp; e = edges[G[x][i]];</span><br><span class="line">            <span class="keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) &#123;</span><br><span class="line">                d[e.to] = d[x] + e.cost;</span><br><span class="line">                p[e.to] = G[x][i];</span><br><span class="line">                a[e.to] = <span class="built_in">min</span>(a[x], e.cap - e.flow);</span><br><span class="line">                <span class="keyword">if</span> (!vis[e.to]) &#123;</span><br><span class="line">                    Q.<span class="built_in">push</span>(e.to);</span><br><span class="line">                    vis[e.to] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d[t] == inf) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    flow += a[t];</span><br><span class="line">    cost += (<span class="keyword">long</span> <span class="keyword">long</span>)d[t] * (<span class="keyword">long</span> <span class="keyword">long</span>)a[t];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = t; u != s; u = edges[p[u]].from) &#123;</span><br><span class="line">        edges[p[u]].flow += a[t];</span><br><span class="line">        edges[p[u] ^ <span class="number">1</span>].flow -= a[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinCostMaxFlow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span>&amp; cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flow = <span class="number">0</span>; cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">BellmanFord</span>(flow, cost));</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记-计算几何</title>
    <url>/p/1aba30fe.html</url>
    <content><![CDATA[<p>啥也不说了,直接上代码,每个函数功能已经以注释方式给出</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment"> *  &gt; Description      : 计算几何模板</span></span><br><span class="line"><span class="comment"> *  &gt; Copyright (C) 2019 Tony</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;     <span class="comment">//精度</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI  = <span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点(向量)</span></span><br><span class="line"><span class="comment"> * @param x 横坐标</span></span><br><span class="line"><span class="comment"> * @param y 纵坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">double</span> x = <span class="number">0</span>, <span class="keyword">double</span> y = <span class="number">0</span>): <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line">Vector <span class="keyword">operator</span> + (Vector a, Vector b) &#123; <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x + b.x, a.y + b.y); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> - (Vector a, Vector b) &#123; <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x - b.x, a.y - b.y); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> * (Vector a, <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x * p, a.y * p); &#125;</span><br><span class="line">Vector <span class="keyword">operator</span> / (Vector a, <span class="keyword">double</span> p) &#123; <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x / p, a.y / p); &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 带精度比较(三态函数)</span></span><br><span class="line"><span class="comment"> * @param[in]  x  输入</span></span><br><span class="line"><span class="comment"> * @return 大小关系：等于0(0), 小于零(-1), 大于零(1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(a.x - b.x) == <span class="number">0</span> &amp;&amp; <span class="built_in">dcmp</span>(a.y - b.y) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dot</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.x + a.y * b.y; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Length</span><span class="params">(Vector a)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">Dot</span>(a, a)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Angle</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">Dot</span>(a, b) / <span class="built_in">Length</span>(a) / <span class="built_in">Length</span>(b)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector a, Vector b)</span> </span>&#123; <span class="keyword">return</span> a.x * b.y - a.y * b.x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Area2</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Cross</span>(b - a, c - a); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Dist2</span><span class="params">(<span class="keyword">const</span> Point&amp; A, <span class="keyword">const</span> Point&amp; B)</span> </span>&#123; <span class="keyword">return</span> (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y); &#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">angle</span><span class="params">(Vector v)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(v.y, v.x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 向量旋转</span></span><br><span class="line"><span class="comment"> * @param[in]  a    向量</span></span><br><span class="line"><span class="comment"> * @param[in]  rad  旋转角度(逆时针)</span></span><br><span class="line"><span class="comment"> * @return 旋转后的向量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Vector <span class="title">Rotate</span><span class="params">(Vector a, <span class="keyword">double</span> rad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(a.x * <span class="built_in">cos</span>(rad) - a.y * <span class="built_in">sin</span>(rad), a.x * <span class="built_in">sin</span>(rad) + a.y * <span class="built_in">cos</span>(rad));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求单位向量</span></span><br><span class="line"><span class="comment"> * @param[in]  a  向量</span></span><br><span class="line"><span class="comment"> * @return 沿向量a的单位向量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Vector <span class="title">Normal</span><span class="params">(Vector a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> L = <span class="built_in">Length</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(-a.y / L, a.x / L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两条直线交点</span></span><br><span class="line"><span class="comment"> * @param[in]  p  第一条直线的起始点</span></span><br><span class="line"><span class="comment"> * @param[in]  v  第一条直线的方向向量</span></span><br><span class="line"><span class="comment"> * @param[in]  q  第二条直线的起始点</span></span><br><span class="line"><span class="comment"> * @param[in]  w  第二条直线的方向向量</span></span><br><span class="line"><span class="comment"> * @return 两条直线交点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Point p, Vector v, Point q, Vector w)</span> </span>&#123;</span><br><span class="line">    Vector u = p - q;</span><br><span class="line">    <span class="keyword">double</span> t = <span class="built_in">Cross</span>(w, u) / <span class="built_in">Cross</span>(v, w);</span><br><span class="line">    <span class="keyword">return</span> p + v * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点到直线距离</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  直线上两点</span></span><br><span class="line"><span class="comment"> * @return 点到直线距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToLine</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    Vector v1 = b - a, v2 = p - a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(v1, v2)) / <span class="built_in">Length</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点到线段距离</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  线段两端点</span></span><br><span class="line"><span class="comment"> * @return 点到线段距离</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">DistanceToSegment</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="built_in">Length</span>(p - a);</span><br><span class="line">    Vector v1 = b - a, v2 = p - a, v3 = p - b;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(v1, v2)) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Length</span>(v2);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(v1, v3)) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">Length</span>(v3);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">Cross</span>(v1, v2)) / <span class="built_in">Length</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点在直线上投影点</span></span><br><span class="line"><span class="comment"> * @param[in]  p    点</span></span><br><span class="line"><span class="comment"> * @param[in]  a,b  直线上两点</span></span><br><span class="line"><span class="comment"> * @return 点在直线上投影点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineProjection</span><span class="params">(Point p, Point a, Point b)</span> </span>&#123;</span><br><span class="line">    Vector v = b - a;</span><br><span class="line">    <span class="keyword">return</span> a + v * (<span class="built_in">Dot</span>(v, p - a) / <span class="built_in">Dot</span>(v, v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 线段相交判定(不含端点)</span></span><br><span class="line"><span class="comment"> * @param[in]  a1,a2  第一条线段端点</span></span><br><span class="line"><span class="comment"> * @param[in]  b1,b2  第二条线段端点</span></span><br><span class="line"><span class="comment"> * @return 是否相交(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SegmentProperIntersection</span><span class="params">(Point a1, Point a2, Point b1, Point b2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c1 = <span class="built_in">Cross</span>(a2 - a1, b1 - a1), c2 = <span class="built_in">Cross</span>(a2 - a1, b2 - a1),</span><br><span class="line">           c3 = <span class="built_in">Cross</span>(b2 - b1, a1 - b1), c4 = <span class="built_in">Cross</span>(b2 - b1, a2 - b1);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(c1) * <span class="built_in">dcmp</span>(c2) &lt; <span class="number">0</span> &amp;&amp; <span class="built_in">dcmp</span>(c3) * <span class="built_in">dcmp</span>(c4) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 点在线段上判定(不包括端点)</span></span><br><span class="line"><span class="comment"> * @param[in]  p      点</span></span><br><span class="line"><span class="comment"> * @param[in]  a1,a2  线段两端点</span></span><br><span class="line"><span class="comment"> * @return 是否在线段上(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnSegment</span><span class="params">(Point p, Point a1, Point a2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(a1 - p, a2 - p)) == <span class="number">0</span> &amp;&amp; <span class="built_in">dcmp</span>(<span class="built_in">Dot</span>(a1 - p, a2 - p)) &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 多边形面积</span></span><br><span class="line"><span class="comment"> * @param[in]  *p  顶点数组</span></span><br><span class="line"><span class="comment"> * @param[in]</span></span><br><span class="line"><span class="comment"> * @return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PolygonArea</span><span class="params">(Point* p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        area += <span class="built_in">Cross</span>(p[i] - p[<span class="number">0</span>], p[i + <span class="number">1</span>] - p[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 直线(参数式)</span></span><br><span class="line"><span class="comment"> * @param p   直线上的一点</span></span><br><span class="line"><span class="comment"> * @param v   方向向量</span></span><br><span class="line"><span class="comment"> * @param ang 方向向量极角</span></span><br><span class="line"><span class="comment"> * @function point(double t)</span></span><br><span class="line"><span class="comment"> *     @brief        直线上的点</span></span><br><span class="line"><span class="comment"> *     @param[in] t  横坐标</span></span><br><span class="line"><span class="comment"> *     @return       直线上的点</span></span><br><span class="line"><span class="comment"> * @function move(double d)</span></span><br><span class="line"><span class="comment"> *     @brief        沿直线移动</span></span><br><span class="line"><span class="comment"> *     @param[in] d  平移距离</span></span><br><span class="line"><span class="comment"> *     @return       平移后的直线</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    Point p;</span><br><span class="line">    Vector v;</span><br><span class="line">    <span class="keyword">double</span> ang;</span><br><span class="line">    <span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Line</span>(Point p, Vector v): <span class="built_in">p</span>(p), <span class="built_in">v</span>(v) &#123; ang = <span class="built_in">atan2</span>(v.y, v.x); &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Line&amp; L) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ang &lt; L.ang;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p + v * t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Line <span class="title">move</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Line</span>(p + <span class="built_in">Normal</span>(v) * d, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 是否在直线左侧</span></span><br><span class="line"><span class="comment"> * @param[in]  L  直线</span></span><br><span class="line"><span class="comment"> * @param[in]  p  点</span></span><br><span class="line"><span class="comment"> * @return 是否在点左侧(bool)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">OnLeft</span><span class="params">(Line L, Point p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Cross</span>(L.v, p - L.p) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两条直线交点(重载)</span></span><br><span class="line"><span class="comment"> * @param[in]  a  第一条直线</span></span><br><span class="line"><span class="comment"> * @param[in]  b  第二条直线</span></span><br><span class="line"><span class="comment"> * @return 两条直线交点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Point <span class="title">GetLineIntersection</span><span class="params">(Line a, Line b)</span> </span>&#123;</span><br><span class="line">    Vector u = a.p - b.p;</span><br><span class="line">    <span class="keyword">double</span> t = <span class="built_in">Cross</span>(b.v, u) / <span class="built_in">Cross</span>(a.v, b.v);</span><br><span class="line">    <span class="keyword">return</span> a.p + a.v * t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 圆</span></span><br><span class="line"><span class="comment"> * @param c   圆心</span></span><br><span class="line"><span class="comment"> * @param r   半径</span></span><br><span class="line"><span class="comment"> * @function point(double a)</span></span><br><span class="line"><span class="comment"> *     @brief         圆上的点</span></span><br><span class="line"><span class="comment"> *     @param[in]  a  横坐标</span></span><br><span class="line"><span class="comment"> *     @return        圆上的点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> &#123;</span></span><br><span class="line">    Point c;</span><br><span class="line">    <span class="keyword">double</span> r;</span><br><span class="line">    <span class="built_in">Circle</span>(Point c, <span class="keyword">double</span> r): <span class="built_in">c</span>(c), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Point</span>(c.x + <span class="built_in">cos</span>(a) * r, c.y + <span class="built_in">sin</span>(a) * r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 直线和圆交点</span></span><br><span class="line"><span class="comment"> * @param[in]   L      直线</span></span><br><span class="line"><span class="comment"> * @param[in]   C      圆</span></span><br><span class="line"><span class="comment"> * @param[out]  t1,t2  交点横坐标</span></span><br><span class="line"><span class="comment"> * @param[out]  sol    交点集(vector)</span></span><br><span class="line"><span class="comment"> * @return 交点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLineCircleIntersection</span><span class="params">(Line L, Circle C, <span class="keyword">double</span>&amp; t1, <span class="keyword">double</span>&amp; t2, vector&lt;Point&gt;&amp; sol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y;</span><br><span class="line">    <span class="keyword">double</span> e = a * a + c * c, f = <span class="number">2</span> * (a * b + c * d), g = b * b + d * d - C.r * C.r;</span><br><span class="line">    <span class="keyword">double</span> delta = f * f - <span class="number">4</span> * e * g;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(delta) &lt; <span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(delta) == <span class="number">0</span>) &#123;</span><br><span class="line">        t1 = t2 = -f / (<span class="number">2</span> * e);</span><br><span class="line">        sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t1));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = (-f - <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span> * e); sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t1));</span><br><span class="line">    t2 = (-f + <span class="built_in">sqrt</span>(delta)) / (<span class="number">2</span> * e); sol.<span class="built_in">push_back</span>(L.<span class="built_in">point</span>(t2));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 圆和圆交点</span></span><br><span class="line"><span class="comment"> * @param[in]   C1,C2  两圆</span></span><br><span class="line"><span class="comment"> * @param[out]  sol    交点集(vector)</span></span><br><span class="line"><span class="comment"> * @return 交点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCircleCircleIntersection</span><span class="params">(Circle C1, Circle C2, vector&lt;Point&gt;&amp; sol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="built_in">Length</span>(C1.c - C2.c);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(d) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dcmp</span>(C1.r - C2.r) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(C1.r + C2.r - d) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">fabs</span>(C1.r - C2.r) - d) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="built_in">angle</span>(C2.c - C1.c);</span><br><span class="line">    <span class="keyword">double</span> da = <span class="built_in">acos</span>((C1.r * C1.r + d * d - C2.r * C2.r) / (<span class="number">2</span> * C1.r * d));</span><br><span class="line">    Point p1 = C1.<span class="built_in">point</span>(a - da), p2 = C1.<span class="built_in">point</span>(a + da);</span><br><span class="line">    sol.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    <span class="keyword">if</span> (p1 == p2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    sol.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求切线</span></span><br><span class="line"><span class="comment"> * @param[in]   p   点</span></span><br><span class="line"><span class="comment"> * @param[in]   C   圆</span></span><br><span class="line"><span class="comment"> * @param[out]  *v  切线</span></span><br><span class="line"><span class="comment"> * @return 切线条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Point p, Circle C, Vector* v)</span> </span>&#123;</span><br><span class="line">    Vector u = C.c - p;</span><br><span class="line">    <span class="keyword">double</span> dist = <span class="built_in">Length</span>(u);</span><br><span class="line">    <span class="keyword">if</span> (dist &lt; C.r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">dcmp</span>(dist - C.r) == <span class="number">0</span>) &#123;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="built_in">Rotate</span>(u, PI / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">asin</span>(C.r / dist);</span><br><span class="line">        v[<span class="number">0</span>] = <span class="built_in">Rotate</span>(u, -ang);</span><br><span class="line">        v[<span class="number">1</span>] = <span class="built_in">Rotate</span>(u, +ang);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 两圆公切线</span></span><br><span class="line"><span class="comment"> * @param[in]   A,B    两圆</span></span><br><span class="line"><span class="comment"> * @param[out]  *a,*b  切点</span></span><br><span class="line"><span class="comment"> * @return 公切线条数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTangents</span><span class="params">(Circle A, Circle B, Point* a, Point* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (A.r - B.r) &#123; <span class="built_in">swap</span>(A, B); <span class="built_in">swap</span>(a, b); &#125;</span><br><span class="line">    <span class="keyword">int</span> d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y);</span><br><span class="line">    <span class="keyword">int</span> rdiff = A.r - B.r;</span><br><span class="line">    <span class="keyword">int</span> rsum  = A.r + B.r;</span><br><span class="line">    <span class="keyword">if</span> (d2 &lt; rdiff * rdiff) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> base = <span class="built_in">atan2</span>(B.c.y - A.c.y, B.c.x - A.c.x);</span><br><span class="line">    <span class="keyword">if</span> (d2 == <span class="number">0</span> &amp;&amp; A.r == B.r) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (d2 == rdiff * rdiff) &#123;</span><br><span class="line">        a[cnt] = A.<span class="built_in">point</span>(base);</span><br><span class="line">        b[cnt] = B.<span class="built_in">point</span>(base);</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r - B.r) / <span class="built_in">sqrt</span>(d2));</span><br><span class="line">    a[cnt] = A.<span class="built_in">point</span>(base + ang); b[cnt] = B.<span class="built_in">point</span>(base + ang); cnt++;</span><br><span class="line">    a[cnt] = A.<span class="built_in">point</span>(base - ang); b[cnt] = B.<span class="built_in">point</span>(base - ang); cnt++;</span><br><span class="line">    <span class="keyword">if</span> (d2 == rsum * rsum) &#123;</span><br><span class="line">        a[cnt] = A.<span class="built_in">point</span>(base);</span><br><span class="line">        b[cnt] = B.<span class="built_in">point</span>(PI + base);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d2 &gt; rsum * rsum) &#123;</span><br><span class="line">        <span class="keyword">double</span> ang = <span class="built_in">acos</span>((A.r + B.r) / <span class="built_in">sqrt</span>(d2));</span><br><span class="line">        a[cnt] = A.<span class="built_in">point</span>(base + ang); b[cnt] = B.<span class="built_in">point</span>(PI + base + ang); cnt++;</span><br><span class="line">        a[cnt] = A.<span class="built_in">point</span>(base - ang); b[cnt] = B.<span class="built_in">point</span>(PI + base - ang); cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;Point&gt; Polygon;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判定点在多边形内</span></span><br><span class="line"><span class="comment"> * @param[in]  p     点</span></span><br><span class="line"><span class="comment"> * @param[in]  poly  多边形</span></span><br><span class="line"><span class="comment"> * @return 是否在多边形内(在1,不在0,在边上-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPointInPolygon</span><span class="params">(Point p, Polygon poly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = poly.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">OnSegment</span>(p, poly[i], poly[(i + <span class="number">1</span>) % n])) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(poly[(i + <span class="number">1</span>) % n] - poly[i], p - poly[i]));</span><br><span class="line">        <span class="keyword">int</span> d1 = <span class="built_in">dcmp</span>(poly[i].y - p.y);</span><br><span class="line">        <span class="keyword">int</span> d2 = <span class="built_in">dcmp</span>(poly[(i + <span class="number">1</span>) % n].y - p.y);</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; d1 &lt;= <span class="number">0</span> &amp;&amp; d2 &gt; <span class="number">0</span>) wn++;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> &amp;&amp; d2 &lt;= <span class="number">0</span> &amp;&amp; d1 &gt; <span class="number">0</span>) wn--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wn != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 凸包</span></span><br><span class="line"><span class="comment"> * @param[in]  p  点集</span></span><br><span class="line"><span class="comment"> * @return 凸包多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Polygon <span class="title">ConvexHull</span><span class="params">(vector&lt;Point&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>());</span><br><span class="line">    p.<span class="built_in">erase</span>(<span class="built_in">unique</span>(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>()), p.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Polygon <span class="title">ch</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">Cross</span>(ch[m - <span class="number">1</span>] - ch[m - <span class="number">2</span>], p[i] - ch[m - <span class="number">2</span>]) &lt;= <span class="number">0</span>) m--;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (m &gt; k &amp;&amp; <span class="built_in">Cross</span>(ch[m - <span class="number">1</span>] - ch[m - <span class="number">2</span>], p[i] - ch[m - <span class="number">2</span>]) &lt;= <span class="number">0</span>) m--;</span><br><span class="line">        ch[m++] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) m--;</span><br><span class="line">    ch.<span class="built_in">resize</span>(m);</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 旋转卡壳</span></span><br><span class="line"><span class="comment"> * @param[in]  points  点集</span></span><br><span class="line"><span class="comment"> * @return 直径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">diameter2</span><span class="params">(vector&lt;Point&gt;&amp; points)</span> </span>&#123; <span class="comment">//旋转卡壳</span></span><br><span class="line">    vector&lt;Point&gt; p = <span class="built_in">ConvexHull</span>(points);</span><br><span class="line">    <span class="keyword">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">Dist2</span>(p[<span class="number">0</span>], p[<span class="number">1</span>]);</span><br><span class="line">    p.<span class="built_in">push_back</span>(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>, v = <span class="number">1</span>; u &lt; n; ++u) &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> diff = <span class="built_in">Cross</span>(p[u + <span class="number">1</span>] - p[u], p[v + <span class="number">1</span>] - p[v]);</span><br><span class="line">            <span class="keyword">if</span> (diff &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (<span class="keyword">int</span>)<span class="built_in">Dist2</span>(p[u], p[v]));</span><br><span class="line">                <span class="keyword">if</span> (diff == <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, (<span class="keyword">int</span>)<span class="built_in">Dist2</span>(p[u], p[v + <span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            v = (v + <span class="number">1</span>) % n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 切多边形</span></span><br><span class="line"><span class="comment"> * @param[in]  poly  多边形</span></span><br><span class="line"><span class="comment"> * @param[in]  A,B   直线上两点</span></span><br><span class="line"><span class="comment"> * @return 新多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Polygon <span class="title">CutPolygon</span><span class="params">(Polygon poly, Point A, Point B)</span> </span>&#123;</span><br><span class="line">    Polygon newpoly;</span><br><span class="line">    <span class="keyword">int</span> n = poly.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Point C = poly[i];</span><br><span class="line">        Point D = poly[(i + <span class="number">1</span>) % n];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(B - A, C - A)) &gt;= <span class="number">0</span>) newpoly.<span class="built_in">push_back</span>(C);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dcmp</span>(<span class="built_in">Cross</span>(B - A, C - D)) != <span class="number">0</span>) &#123;</span><br><span class="line">            Point ip = <span class="built_in">GetLineIntersection</span>(A, B - A, C, D - C);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OnSegment</span>(ip, C, D)) newpoly.<span class="built_in">push_back</span>(ip);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newpoly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 半平面交</span></span><br><span class="line"><span class="comment"> * @param[in]  L  直线集</span></span><br><span class="line"><span class="comment"> * @return 多边形</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">HalfplaneIntersection</span><span class="params">(vector&lt;Line&gt; L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = L.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> first, last;</span><br><span class="line">    <span class="function">vector&lt;Point&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;Line&gt;  <span class="title">q</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;Point&gt; ans;</span><br><span class="line">    q[first = last = <span class="number">0</span>] = L[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; !<span class="built_in">OnLeft</span>(L[i], p[last - <span class="number">1</span>])) last--;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last &amp;&amp; !<span class="built_in">OnLeft</span>(L[i], p[first]))   first++;</span><br><span class="line">        q[++last] = L[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(<span class="built_in">Cross</span>(q[last].v, q[last - <span class="number">1</span>].v)) &lt; eps) &#123;</span><br><span class="line">            last--;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">OnLeft</span>(q[last], L[i].p)) q[last] = L[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (first &lt; last) p[last - <span class="number">1</span>] = <span class="built_in">GetLineIntersection</span>(q[last - <span class="number">1</span>], q[last]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; last &amp;&amp; !<span class="built_in">OnLeft</span>(q[first], p[last - <span class="number">1</span>])) last--;</span><br><span class="line">    <span class="keyword">if</span> (last - first &lt;= <span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    p[last] = <span class="built_in">GetLineIntersection</span>(q[last], q[first]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) ans.<span class="built_in">push_back</span>(p[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++算法</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
        <tag>笔记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIp2018」题解</title>
    <url>/p/34a76f7d.html</url>
    <content><![CDATA[<pre><code>emmm，今天开始从2018向前做NOIp的真题，并写一些题解，太蒻了Orz
</code></pre>
<span id="more"></span>

<h2 id="D1T1-铺设道路"><a href="#D1T1-铺设道路" class="headerlink" title="$D1T1$ 铺设道路"></a>$D1T1$ <a href="https://www.luogu.org/problemnew/show/P5019">铺设道路</a></h2><p>嗯～13年原题，__<em>贪心AC</em>__</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对区间进行“填坑”<br>贪心策略：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (d[i] &gt; d[i - <span class="number">1</span>]) ans += d[i] - d[i - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>$proof:$<br>    假设现在有一个坑，旁边还有一个坑。<br>    那肯定会同时填上两个坑，所以__小的坑会被大的坑带着填上__，及__<em>小坑免费，大坑减少<code>a[i] - a[i - 1]</code></em>__<br>$Q.E.D$<br>结果还要加上<code>a[1]</code></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, d[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] &gt; d[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            ans += d[i] - d[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans + d[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 41ms 1220kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T2-货币系统"><a href="#D1T2-货币系统" class="headerlink" title="$D1T2$ 货币系统"></a>$D1T2$ <a href="https://www.luogu.org/problemnew/show/P5020">货币系统</a></h2><p>表面上是数论，其实就是个__<em>动态规划</em>__</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>首先设$A = (n, a) \ \ B = (m, b)$<br>可以证明$B \subseteq A$<br>$proof:$<br>    我们设$x\in A$且$x$不能被$A$集合内除它以外的元素组成。<br>    然后我们假设$x \notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。<br>    那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。<br>    综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内<br>$Q.E.D$</p>
<p>然后动态规划<br><code>dp[i]</code>表示$i$面值最多能被几张钱表示<br>则若其不能被表示<code>dp[i] = -inf</code><br>能表示且只有它自己则<code>dp[i] = 1</code><br>初始化<code>dp[] = -inf; dp[0] = 0</code><br>状态转移方程为<code>dp[j] = max(dp[j], dp[j - a[i]] + 1)</code></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, T, ans, a[<span class="number">1010</span>], dp[<span class="number">30010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">-0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        ans = <span class="number">0</span>; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = a[i]; j &lt;= <span class="number">25010</span>; ++j) &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[a[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 862ms 944kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D1T3-赛道修建"><a href="#D1T3-赛道修建" class="headerlink" title="$D1T3$ 赛道修建"></a>$D1T3$ <a href="https://www.luogu.org/problemnew/show/P5021">赛道修建</a></h2><p>这题比较复杂，先得部分分</p>
<h3 id="I-m-1-时"><a href="#I-m-1-时" class="headerlink" title="$I.$ $m = 1$ 时"></a>$I.$ $m = 1$ 时</h3><p>最简单的情况<br>求一条最长链，即求树的直径（记录一下最大值和次大值，每次把最大值传到它的父亲）<br>可以通过第$1,4,5,6$个点，$20$分</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Meq1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            res2 = <span class="built_in">max</span>(res2, <span class="built_in">dfs</span>(to, now) + edges[i].val);</span><br><span class="line">            <span class="keyword">if</span> (res2 &gt; res1) <span class="built_in">swap</span>(res1, res2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, res1 + res2);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="II-a-i-1-时"><a href="#II-a-i-1-时" class="headerlink" title="$II.$ $a_i = 1$ 时"></a>$II.$ $a_i = 1$ 时</h3><p>即一个菊花图<br>把所有边权记录下来，从大到小排序。设边权为$w$，答案即为$w_1+w_{2m-1},w_2+w_{2m-2},…,w_m+w_{m+1}$的最小值<br>可以通过$1,5,7,8$四个点，$20$分，加上$m = 1$的情况共$35$分</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Aeq1 &#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxn];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[<span class="number">1</span>]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            arr[to - <span class="number">1</span>] = edges[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr + <span class="number">1</span>, arr + n, cmp);</span><br><span class="line">        ans = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, arr[i] + arr[<span class="number">2</span> * m - i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="III-b-i-a-i-1-时"><a href="#III-b-i-a-i-1-时" class="headerlink" title="$III.$ $b_i = a_i + 1$ 时"></a>$III.$ $b_i = a_i + 1$ 时</h3><p>为一条链<br>把所有边权记录下来，这种情况等价于将序列分割成$m$段，使$m$段区间和的最小值最大<br>那么二分$m$段区间和的最小值，然后贪心扫一遍<br>可以通过$2,9,10,11$四个点，$20$分，加上一共$55$分</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BeqApl1 &#123;</span><br><span class="line">    <span class="keyword">int</span> arr[maxn], ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res1 = <span class="number">0</span>, res2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            res2 = <span class="built_in">max</span>(res2, <span class="built_in">Dfs</span>(to, now) + edges[i].val);</span><br><span class="line">            <span class="keyword">if</span> (res2 &gt; res1) <span class="built_in">swap</span>(res1, res2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, res1 + res2);</span><br><span class="line">        <span class="keyword">return</span> res1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = edges[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> to = edges[i].to;</span><br><span class="line">            <span class="keyword">if</span> (to == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(to, now);</span><br><span class="line">            arr[now] = edges[i].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now + arr[i] &gt;= x) &#123;</span><br><span class="line">                now = <span class="number">0</span>;</span><br><span class="line">                t++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                now += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">Dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = ans, mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>最小值最大，显然是二分这个最小值$lim$<br>对于一个节点$u$，我们可以记录一个连接到$u$的赛道的长度$val_i$，那么可以分成两种情况进行讨论：<br>$$\begin{cases} val_i+dis \geq lim \text{直接给答案+1} \\ val_i+dis&lt; lim \text{利用优先队列维护}\end{cases}$$</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt, num, s[maxn], mid;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> from, to, val;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w) : <span class="built_in">from</span>(u), <span class="built_in">to</span>(v), <span class="built_in">val</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; G[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    G[u].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v, w));</span><br><span class="line">    G[v].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; lh;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; sh;</span><br><span class="line">    <span class="keyword">int</span> ln = <span class="number">0</span>, sn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[u][i].to != fa) &#123;</span><br><span class="line">            <span class="keyword">int</span> d = G[u][i].val + <span class="built_in">dfs</span>(G[u][i].to, u);</span><br><span class="line">            sh.<span class="built_in">push</span>(d); lh.<span class="built_in">push</span>(d);</span><br><span class="line">            ln++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ln &gt; <span class="number">0</span> &amp;&amp; lh.<span class="built_in">top</span>() &gt;= mid) &#123;num++; lh.<span class="built_in">pop</span>(); ln--;&#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ln &gt; sn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u != <span class="number">1</span> &amp;&amp; lh.<span class="built_in">top</span>() + sh.<span class="built_in">top</span>() &gt;= mid) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (ln &gt; sn &amp;&amp; lh.<span class="built_in">top</span>() + sh.<span class="built_in">top</span>() &gt;= mid) &#123;s[++cnt] = lh.<span class="built_in">top</span>(); lh.<span class="built_in">pop</span>(); ln--;&#125;</span><br><span class="line">            num++; sh.<span class="built_in">pop</span>(); sn++;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">1</span>) &#123;lh.<span class="built_in">push</span>(s[--cnt]); ln++;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == <span class="number">1</span> &amp;&amp; lh.<span class="built_in">top</span>() + sh.<span class="built_in">top</span>() &gt;= mid) &#123;</span><br><span class="line">            lh.<span class="built_in">pop</span>(); sh.<span class="built_in">pop</span>(); ln--; sn++; num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now = sh.<span class="built_in">top</span>(); sh.<span class="built_in">pop</span>(); sn++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num &gt;= m) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ln &gt;= sn &amp;&amp; !lh.<span class="built_in">empty</span>()) <span class="keyword">return</span> lh.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>(n); <span class="built_in">read</span>(m); <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">read</span>(u); <span class="built_in">read</span>(v); <span class="built_in">read</span>(w);</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        all += w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = all / m, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>()) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1050ms 11964kB with O2 */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T1-旅行"><a href="#D2T1-旅行" class="headerlink" title="$D2T1$ 旅行"></a>$D2T1$ <a href="https://www.luogu.org/problemnew/show/P5022">旅行</a></h2><p>分两种情况讨论</p>
<h3 id="I-m-n-1"><a href="#I-m-n-1" class="headerlink" title="$I.$ $m = n - 1$"></a>$I.$ $m = n - 1$</h3><p>即无环，只要给一个点所能到达的点的编号进行一次从小到大的排序，在树上dfs一遍即可解决<br>样例1图示：<img src="/p/34a76f7d/P5022_1.png"></p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SolveOne &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        ans[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 1050ms 11964kB with O2 */</span></span><br></pre></td></tr></table></figure>

<h3 id="II-m-n"><a href="#II-m-n" class="headerlink" title="$II.$ $m = n$"></a>$II.$ $m = n$</h3><p>存在一个环（基环树）<br>手算一下样例2可以发现，有且仅有一条边不会通过<br>逐个删边尝试即可，删边后和$m = n - 1$相同<br>样例2图示：<img src="/p/34a76f7d/P5022_2.png"></p>
<h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))  &#123;x = x * <span class="number">10</span> + ch - <span class="number">48</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans[maxn], in[maxn][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SolveOne &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        ans[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SolveTwo &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, res[maxn], du, dv;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxn];</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">notdel</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123; <span class="comment">//判断该边是否被删</span></span><br><span class="line">        <span class="keyword">if</span> ((u == du &amp;&amp; v == dv) || (u == dv &amp;&amp; v == du)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        res[++cnt] = u;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; <span class="built_in">notdel</span>(u, v)) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span> </span>&#123; <span class="comment">//判断是否为更优情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i] != res[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans[i] &gt; res[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(G[i].<span class="built_in">begin</span>(), G[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">            du = in[i][<span class="number">0</span>]; <span class="comment">//删边</span></span><br><span class="line">            dv = in[i][<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">judge</span>() &amp;&amp; cnt == n) &#123; <span class="comment">//如果更优则更改ans[]</span></span><br><span class="line">                <span class="built_in">memcpy</span>(ans, res, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">read</span>(), v = <span class="built_in">read</span>();</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        in[i][<span class="number">0</span>] = u;  <span class="comment">//存储输入信息</span></span><br><span class="line">        in[i][<span class="number">1</span>] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m == n - <span class="number">1</span>) &#123;</span><br><span class="line">        SolveOne::<span class="built_in">solve</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SolveTwo::<span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2244ms 1276kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T2-填数游戏"><a href="#D2T2-填数游戏" class="headerlink" title="$D2T2$ 填数游戏"></a>$D2T2$ <a href="https://www.luogu.org/problemnew/show/P5023">填数游戏</a></h2><p><del>暴力推柿子</del><br>首先明确一个概念:本文的对角线指的是从左下方到右上方的有向线段<br><img src="/p/34a76f7d/d2t2_1.png" alt="Lemma I."><br>$\mathcal{Lemma}\ I.$ 对角线上的数只会相同或递减<br>$proof:$<br>由上图两条黑线和题目描述即可证明<br>$Q.E.D$</p>
<p><img src="/p/34a76f7d/d2t2_2.png" alt="Lemma II."><br>$\mathcal{Lemma}\ II.$ 若$(x-1, y)$与$(x, y-1)$的数相同,则以$(x,y)$为左上角,整个图形右下角的子矩阵的每条对角线(蓝)上填的数字相同<br>$proof:$<br>由图上两条橙线及题目描述即可证明<br>$Q.E.D$</p>
<p>$\mathcal{Lemma}\ III.$ $Ans(n,m)=Ans(m,n)$</p>
<p>正式推式子(默认$n \leq m$)</p>
<h3 id="I-n-1-时"><a href="#I-n-1-时" class="headerlink" title="$I.$ $n = 1$ 时"></a>$I.$ $n = 1$ 时</h3><p><img src="/p/34a76f7d/d2t2_3.png"><br>每个格内都有2种填法,故$\Ans(1,m)=2^{m}$</p>
<h3 id="II-n-2-时"><a href="#II-n-2-时" class="headerlink" title="$II.$ $n = 2$ 时"></a>$II.$ $n = 2$ 时</h3><p><img src="/p/34a76f7d/d2t2_4.png"><br>两个角上各两种,剩余$m-1$条对角线每条有3种(11,10,00)<br>故$Ans(2,m)=2\times 2\times 3^{m-1}=4\times 3^{m-1}$</p>
<h3 id="III-n-geq-4-时-只考虑-n-m-时"><a href="#III-n-geq-4-时-只考虑-n-m-时" class="headerlink" title="$III. $ $n \geq 4$ 时 (只考虑$n = m$时)"></a>$III. $ $n \geq 4$ 时 (只考虑$n = m$时)</h3><h4 id="case-I-左上角两数相同"><a href="#case-I-左上角两数相同" class="headerlink" title="$case I.$ 左上角两数相同"></a>$case I.$ 左上角两数相同</h4><p><img src="/p/34a76f7d/d2t2_5.png"><br>图中数字表示每条对角线方案数<br>可以得出$Ans(caseI.)=2\times 2\times 4^{n-2}\times 2^{n-1}=8^{n-1}$</p>
<h4 id="case-II-第三条对角线数字相同"><a href="#case-II-第三条对角线数字相同" class="headerlink" title="$case II.$ 第三条对角线数字相同"></a>$case II.$ 第三条对角线数字相同</h4><p><img src="/p/34a76f7d/d2t2_6.png"><br>图中红色数字表示方案数<br>可以得出$Ans(caseII.)=2\times 2\times 5\times 4^{n-4}\times 2^{n-1}=5\times 2^{3n-7}$</p>
<h4 id="case-III-第三条对角线上数字不同"><a href="#case-III-第三条对角线上数字不同" class="headerlink" title="$case III.$ 第三条对角线上数字不同"></a>$case III.$ 第三条对角线上数字不同</h4><p><img src="/p/34a76f7d/d2t2_7.png"><br>可以发现左侧两行只能填01,所以可能会再次出现对角数字相同的情况</p>
<h5 id="第一个出现"><a href="#第一个出现" class="headerlink" title="第一个出现"></a>第一个出现</h5><p><img src="/p/34a76f7d/d2t2_8.png" alt="红色表示方案数"></p>
<h5 id="最后一个出现"><a href="#最后一个出现" class="headerlink" title="最后一个出现"></a>最后一个出现</h5><p><img src="/p/34a76f7d/d2t2_9.png"></p>
<h5 id="倒数第二个出现"><a href="#倒数第二个出现" class="headerlink" title="倒数第二个出现"></a>倒数第二个出现</h5><p><img src="/p/34a76f7d/d2t2_10.png"></p>
<h5 id="没有出现"><a href="#没有出现" class="headerlink" title="没有出现"></a>没有出现</h5><p><img src="/p/34a76f7d/d2t2_11.png"></p>
<p>注意第三条对角线可能有100,110两种情况<br>所以$Ans(case III.)=2\times (2\times 4\times 5\times 2^{n-1}\times \sum_{i=0}^{n-5}{4^i} + 2\times 4\times 3\times 2^{n-2} + 2\times 3\times 2^{n-2})$</p>
<p>$Ans(n, n)=Ans(case I.) + Ans(case II.) + Ans(case III.)$<br>$$Ans(n,n)=\frac{83\times 8^n + 5\times 2^{n+7}}{384}$$</p>
<h3 id="IV-n-3"><a href="#IV-n-3" class="headerlink" title="$IV.$ $n = 3$"></a>$IV.$ $n = 3$</h3><p>证明与前类似<br>$$Ans(3,m)=112\times 3^{m-3}$$</p>
<h3 id="V-n-neq-m-时"><a href="#V-n-neq-m-时" class="headerlink" title="$V.$ $n \neq m$ 时"></a>$V.$ $n \neq m$ 时</h3><p>与前类似<br>$$Ans(n,n+1)=\frac{83\times 8^n + 2^{n+8}}{128}$$<br>同时易证得$Ans(n,m+1)=3\times Ans(n,m)$</p>
<p>于是就解决了</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">poww</span><span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span> ( ; b; a = a * a % mod, b &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            res = res * a % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">poww</span>(<span class="number">2</span>, m));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">4</span> * <span class="built_in">poww</span>(<span class="number">3</span>, m - <span class="number">1</span>) % mod);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="number">112</span> * <span class="built_in">poww</span>(<span class="number">3</span>, m - <span class="number">3</span>) % mod);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((<span class="number">83</span> * <span class="built_in">poww</span>(<span class="number">8</span>, n) % mod + <span class="number">5</span> * <span class="built_in">poww</span>(<span class="number">2</span>, n + <span class="number">7</span>) % mod) * <span class="number">190104168</span> % mod));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((<span class="number">83</span> * <span class="built_in">poww</span>(<span class="number">8</span>, n) % mod + <span class="built_in">poww</span>(<span class="number">2</span>, n + <span class="number">8</span>)) * <span class="built_in">poww</span>(<span class="number">3</span>, m - n - <span class="number">1</span>) % mod * <span class="number">570312504</span> % mod ));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 55ms 1048kB */</span></span><br></pre></td></tr></table></figure>

<h2 id="D2T3-保卫王国"><a href="#D2T3-保卫王国" class="headerlink" title="$D2T3$ 保卫王国"></a>$D2T3$ <a href="https://www.luogu.org/problemnew/show/P5024">保卫王国</a></h2><p>动态DP,树剖,<del>蒟蒻不会</del></p>
<p><del>逃</del></p>
<hr>
<p><strong><em>如有疑问,可以在下方评论区留言</em></strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>NOIp</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建博客</title>
    <url>/p/178c0d2c.html</url>
    <content><![CDATA[<p>由于<code>mkdocs</code>上有很多不足，例如没有标签，分类，评论，计数等等，故转至使用<code>Hexo</code>搭建博客，以下是我折腾的过程</p>
<span id="more"></span>

<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>我是用的是<code>Ubuntu16.04</code>系统，其他系统安装方法可到官网查询<br>在<a href="https://nodejs.org/">nodejs官网</a>下载<code>node.js</code>，并解压<br>添加环境变量<br><code>echo &quot;export PATH=$PATH:/home/tony/node-v8.11.4-linux-x64/bin&quot; &gt;&gt; ~/.zshrc</code>（如果使用的是bash，将最后一句改为<code>~/.bashrc</code>）<br><code>source ~/.zshrc</code>应用更改</p>
<p>下载hexo<br><code>npm install -g hexo-cli</code></p>
<h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blog</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init</span></span><br></pre></td></tr></table></figure>
<p>使用<code>hexo s</code>启动服务,在浏览器中输入<code>localhost:4000</code>便可看到预览网页</p>
<h3 id="部署到GitPages"><a href="#部署到GitPages" class="headerlink" title="部署到GitPages"></a>部署到GitPages</h3><p>创建<code>&lt;username&gt;.github.io</code>存储库<br>更改<code>_config.yml</code>文件中这一部分</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>使用<code>hexo d -g</code>发布</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>我当前使用的是<code>maupassant</code>主题<br>详细配置见<a href="https://www.haomwei.com/technology/maupassant-hexo.html">官方中文文档</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hexo.io/">Hexo官网</a><br><a href="https://afar5277.blog.luogu.org/post-zzq-hexoblog">zzq浅谈用Hexo+GitHub搭建自己的blog</a><br><a href="https://www.luogu.org/blog/0Umaru0/hexo-bo-ke-da-jian-shuo-ming-shu-zhi-bei-shu-post">Hexo博客搭建说明书（指北书）</a><br><a href="https://www.luogu.org/blog/Venus/build-hexo-github-blog">从零搭建 Hexo + Github 博客</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>更新日志</title>
    <url>/p/5a717bf0.html</url>
    <content><![CDATA[<p><a href="https://tony031218.github.io/">本博客</a>在<code>2019.3.10</code>更改至由<code>Hexo</code>驱动，并在<code>2019.3.12</code>完成更改。<br>原文章时间均改为<code>2019.1.9</code>，算法模板时间改为<code>2019.1.10</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>Cpp算法-并查集</title>
    <url>/p/9603fc0b.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, q</code>点数、边数、问题数<br><code>x, y</code>需要合并的两个数<br><code>ufs[]</code>并查集<br><code>find(int)</code>查找并查集中一个数的祖先<br><code>unionn(int, int)</code>合并两个数所在集合</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"><span class="keyword">int</span> n, m, x, y, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ufs[x] != x) <span class="keyword">return</span> ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> fy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (fx != fy)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ufs[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">unionn</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y)) <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-STL标准库</title>
    <url>/p/ac108281.html</url>
    <content><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 写函数/结构体</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T x, y;</span><br><span class="line">    <span class="built_in">Point</span>(T x = <span class="number">0</span>, T y = <span class="number">0</span>):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Point&lt;T&gt; <span class="keyword">operator</span> + (<span class="keyword">const</span> Point&lt;T&gt;&amp; A, <span class="keyword">const</span> Point&lt;T&gt;&amp; B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> Point&lt;T&gt;(A.x + B.x, A.y + B.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; out, <span class="keyword">const</span> Point&lt;T&gt;&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vector-不定长数组"><a href="#vector-不定长数组" class="headerlink" title="vector(不定长数组)"></a>vector(不定长数组)</h2><hr>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><code>vector&lt;数据类型&gt; 名;</code> 例 <code>vector&lt;int&gt; a;</code></p>
<h3 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h3><p><code>a.size();</code>读取大小<br><br><code>a.resize();</code>改变大小<br><br><code>a.push_back(x);</code>尾部添加元素x<br><br><code>a.pop_back();</code>删除最后一个元素<br><br><code>a.clear();</code>清空<br><br><code>a.empty()</code>询问是否为空(bool类型)<br><br><code>a[]</code>访问元素(可修改)<br></p>
<h2 id="priority-queue-优先队列-堆"><a href="#priority-queue-优先队列-堆" class="headerlink" title="priority_queue(优先队列/堆)"></a>priority_queue(优先队列/堆)</h2><hr>
<h3 id="声明-1"><a href="#声明-1" class="headerlink" title="声明"></a>声明</h3><p><strong>头文件</strong>: <code>#include &lt;queue&gt;</code><br><br><strong>参数</strong>: <code>priority_queue&lt;Type, Container, Functional&gt;</code><br><br>&emsp;<code>Type</code>数据类型 <em>不可省</em><br><br>&emsp;<code>Container</code>容器(vector,deque)默认vector<br><br>&emsp;<code>Functional</code>比较方式,默认<code>operator &lt;</code>大根堆</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>与queue类似<br></p>
<h4 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h4><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code>使用仿函数<code>greater&lt;&gt;</code><br></p>
<h4 id="自定义类型-struct"><a href="#自定义类型-struct" class="headerlink" title="自定义类型(struct)"></a>自定义类型(struct)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>):<span class="built_in">x</span>(a), <span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="重载operator-lt"><a href="#重载operator-lt" class="headerlink" title="重载operator &lt;"></a>重载operator &lt;</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node a, Node b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">    <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br></pre></td></tr></table></figure>
<p>x值大的优先级低,排在队前<br><br>x相等,y大的优先级低</p>
<h5 id="重写仿函数"><a href="#重写仿函数" class="headerlink" title="重写仿函数"></a>重写仿函数</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Node a, Node b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.x == b.x) <span class="keyword">return</span> a.y &gt; b.y;</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; q;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-背包问题</title>
    <url>/p/990bbe9a.html</url>
    <content><![CDATA[<h2 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h2><p>有 $n$ 件物品，和一容积为 $V$ 的背包，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>由题意易知状态转移方程： $F_{i,j} = max(F_{i-1,j}\ , F_{i-1,j-w_i} + c_i)$</p>
<p>$F_{i, j}$ 为前 $i$ 件物品放入容量为 $V$ 的背包中最大价值<br><br>时间复杂度 $O(n\times V)$ ，空间复杂度 $O(n\times V)$</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>注意倒序，保证<code>f[n][V]</code>为结果</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n][V])</span><br></pre></td></tr></table></figure>

<h4 id="空间复杂度优化"><a href="#空间复杂度优化" class="headerlink" title="空间复杂度优化"></a>空间复杂度优化</h4><p>降至一维数组<br><br>时间复杂度 $O(n\times V)$ ，空间复杂度 $O(V)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[V]);</span><br></pre></td></tr></table></figure>

<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>有 $n$ 种物品（每种 <strong>无限件</strong> ），和一容积为 $V$ 的背包，第 $i$ 种物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几种物品取任意件装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>将<a href="../pack#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">01背包</a>第二个循环改为正序即可<br><br>状态转移方程：$F_j = max(F_j\ , F_{j-w_i}+c_i)$</p>
<h4 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= V; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[V]);</span><br></pre></td></tr></table></figure>

<h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p>有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h3 id="解法-I-化为完全背包"><a href="#解法-I-化为完全背包" class="headerlink" title="解法 $I.$ 化为完全背包"></a>解法 $I.$ 化为完全背包</h3><p>状态转移方程：$F_{i,v} = max(F_{i-1,v-k\times w_i} + k\times c_i | 0\leqslant k\leqslant n_i)$<br><br>时间复杂度：$O(V\times \sum{n_i})$</p>
<h4 id="框架-2"><a href="#框架-2" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= n[i]; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], [i - <span class="number">1</span>][j - k * w[i]] + k * c[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[N][V]);</span><br></pre></td></tr></table></figure>

<h3 id="解法-II-化为01背包"><a href="#解法-II-化为01背包" class="headerlink" title="解法 $II.$ 化为01背包"></a>解法 $II.$ 化为01背包</h3><p>把 $n_i$ 件一种物品化为单独的 $n_i$ 件物品即可<br><br>时间复杂度：$O(V\times \sum{n_i})$<br><br>框架略</p>
<h3 id="解法-III-二进制优化"><a href="#解法-III-二进制优化" class="headerlink" title="解法 $III.$ 二进制优化"></a>解法 $III.$ 二进制优化</h3><p>$$<br>n_i\to 1+2+4+\dots +2^{k-1}+\dots +(n_i-2^k+1)<br>$$<br>$$<br>\sum{n_i}\to \sum{\log_2{n_i}}<br>$$<br>时间复杂度：$O(V\times \sum{\log_2{n_i}})$</p>
<h4 id="框架-3"><a href="#框架-3" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> w, c, n, t = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;w, &amp;c, &amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n &gt;= t)</span><br><span class="line">    &#123;</span><br><span class="line">        v[++N] = x * t;</span><br><span class="line">        w[N]   = y * t;</span><br><span class="line">        n -= t;</span><br><span class="line">        t *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v[++N] = x * n;</span><br><span class="line">    w[N]   = y * n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= v[i]; --j)</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[V]);</span><br></pre></td></tr></table></figure>

<h2 id="混合三种背包问题"><a href="#混合三种背包问题" class="headerlink" title="混合三种背包问题"></a>混合三种背包问题</h2><p>有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件或无穷件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h4 id="伪框架"><a href="#伪框架" class="headerlink" title="伪框架"></a>伪框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (第i件是有穷件)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//有无穷件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维费用的背包问题"><a href="#二维费用的背包问题" class="headerlink" title="二维费用的背包问题"></a>二维费用的背包问题</h2><p>有 $N$ 件物品，容积为 $V,U$ 的两个背包，每件物品有两种费用，选择物品需要付出两种代价，第 $i$ 件代价为 $a_i,b_i$，价值为 $c_i$。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<p>改为二维数组即可<br><br>状态转移方程：$F_{v,u} = max(F_{v,u}\ , F_{v-a_i,u-b_i} + c_i)$<br><br>$F_{v,u}$ 表示前面的物品付出代价分别为 $v,u$ 时的最大价值<br><br>框架略</p>
<p>循环顺序</p>
<ul>
<li>类01背包：<code>v = V..0  u = U..0</code><br></li>
<li>类完全背包：<code>v = 0..V  u = 0..U</code><br></li>
<li>类多重背包：拆分物品</li>
</ul>
<h2 id="分组的背包问题"><a href="#分组的背包问题" class="headerlink" title="分组的背包问题"></a>分组的背包问题</h2><p>有 $K$ 组物品， $V$ 的背包，第 $k$ 组有 $N_k$ 件物品，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ ，每组中只能选一件物品。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。</p>
<h4 id="框架-4"><a href="#框架-4" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K; ++k)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = V; v &gt;= <span class="number">0</span>; --v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N[k]; ++i)</span><br><span class="line">            f[v] = <span class="built_in">max</span>(f[v], f[v - w[i]] + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题的方案数"><a href="#背包问题的方案数" class="headerlink" title="背包问题的方案数"></a>背包问题的方案数</h2><p>状态转移方程：$F_{i,v} = sum(F_{i-1,v}, F_{i-1,v-w_i})\ \ \ (F_{0,0} = 1)$</p>
<h4 id="框架-5"><a href="#框架-5" class="headerlink" title="框架"></a>框架</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= V; ++j)</span><br><span class="line">        f[j] += f[j - w[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[V]);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-堆</title>
    <url>/p/bb233fbc.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>heap[]</code>堆<br><br><code>heap_size</code>堆大小<br><br><code>put(int)</code>压入一个数<br><br><code>get()</code>弹出堆顶</p>
<h4 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[maxn];</span><br><span class="line"><span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now, next;</span><br><span class="line">    heap[++heap_size] = d;</span><br><span class="line">    now = heap_size;</span><br><span class="line">    <span class="keyword">while</span> (now &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        next = now &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (heap[now] &lt;= heap[next]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[now], heap[next]);</span><br><span class="line">        now = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now, next, res;</span><br><span class="line">    res = heap[<span class="number">1</span>];</span><br><span class="line">    heap[<span class="number">1</span>] = heap[heap_size--];</span><br><span class="line">    now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (now * <span class="number">2</span> &lt;= heap_size)</span><br><span class="line">    &#123;</span><br><span class="line">        next = now * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; heap_size &amp;&amp; heap[next + <span class="number">1</span>] &lt; heap[next]) next++;</span><br><span class="line">        <span class="keyword">if</span> (heap[now] &lt;= heap[next]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(heap[now], heap[next]);</span><br><span class="line">        now = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="STL实现"><a href="#STL实现" class="headerlink" title="STL实现"></a>STL实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> heap[maxn];</span><br><span class="line"><span class="keyword">int</span> heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[++heap_size] = d;</span><br><span class="line">    <span class="built_in">push_heap</span>(heap + <span class="number">1</span>, heap + heap_size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//push_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pop_heap</span>(heap + <span class="number">1</span>, heap + heap_size + <span class="number">1</span>);                   </span><br><span class="line">    <span class="comment">//pop_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); </span></span><br><span class="line">    <span class="keyword">return</span> heap[heap_size--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-SPFA</title>
    <url>/p/8ed8c69a.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, s</code>点数、边数、源点<br><br><code>cnt, head[], edge[], add(int, int, int)</code>链式前向星<br><br><code>dist[]</code>各点到源点路径长<br><br><code>vis[]</code>记录</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, dist[maxn], vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to, dis;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].next = head[from];</span><br><span class="line">    edge[cnt].to     = to;</span><br><span class="line">    edge[cnt].dis    = dis;</span><br><span class="line">    head[from]       = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dist[i] = INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dist[s] = <span class="number">0</span>; vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(); vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = edge[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[u] + edge[i].dis)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[u] + edge[i].dis;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-链式前向星</title>
    <url>/p/dda660a4.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>cnt</code>记数<br><br><code>head[]</code>记录边的头<br><br><code>struct Edge&#123;int, int, int&#125;</code>边信息: 开始点、结束点、权值<br><br><code>add_edge(int, int, int)</code>添加边</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt, head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> next, to, val;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++cnt].next = head[from];</span><br><span class="line">	edge[cnt].to     = to;</span><br><span class="line">	edge[cnt].val    = val;</span><br><span class="line">	head[from]       = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Prim</title>
    <url>/p/8760af74.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, _map[][]</code>点数、边数、邻接矩阵<br><br><code>dist[]</code>树根到各点路径长<br><br><code>pre[]</code>生成树路径 </p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, dist[maxn], _map[maxn][maxn], pre[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">			_map[i][j] = INT_MAX;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) _map[i][i] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> from, to, w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">		_map[from][to] = w;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">int</span> min;</span><br><span class="line">	<span class="keyword">bool</span> p[maxn];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		p[i] = <span class="literal">false</span>;</span><br><span class="line">		dist[i] = _map[<span class="number">1</span>][i];</span><br><span class="line">		pre[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	p[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		min = INT_MAX;</span><br><span class="line">		k = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p[j] &amp;&amp; dist[j] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = dist[j]</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">		p[k] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!p[j] &amp;&amp; _map[k][j] != INT_MAX &amp;&amp; dist[j] &gt; _map[k][j])</span><br><span class="line">			&#123;</span><br><span class="line">				dist[j] = _map[k][j];</span><br><span class="line">				pre[j] = k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Kruskal</title>
    <url>/p/c4fb1928.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>ufs[], find(int), unionn(int, int)</code>并查集结构<br><br><code>edge[]</code>链式前向星<br><br><code>cmp(Edge, Edge)</code>边排序方案</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> ufs[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ufs[x] != x) <span class="keyword">return</span> ufs[x] = <span class="built_in">find</span>(ufs[x]);</span><br><span class="line">    <span class="keyword">return</span> ufs[x] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">int</span> b = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> select;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge a, Edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.w != b.w) <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">    <span class="keyword">if</span> (a.a != b.a) <span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">    <span class="keyword">return</span> a.b &lt; b.b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, x, y;</span><br><span class="line">    <span class="built_in">sort</span>(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        x = <span class="built_in">find</span>(edge[i].a);</span><br><span class="line">        y = <span class="built_in">find</span>(edge[i].b);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unionn</span>(x, y);</span><br><span class="line">            k++;</span><br><span class="line">            edge[i].select = <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-KMP</title>
    <url>/p/632c6631.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P3375">洛谷P3375</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>pre()</code>求前缀数组<br><br><code>kmp()</code>匹配字符串<br></p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">1000010</span>], s2[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">1000010</span>], l1, l2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nxt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; l2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s2[j + <span class="number">1</span>] != s2[i + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s2[i + <span class="number">1</span>]) j++;</span><br><span class="line">        nxt[i + <span class="number">1</span>] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s2[j + <span class="number">1</span>] != s1[i + <span class="number">1</span>]) j = nxt[j];</span><br><span class="line">        <span class="keyword">if</span> (s2[j + <span class="number">1</span>] == s1[i + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i - l2 + <span class="number">2</span>);</span><br><span class="line">            j = nxt[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; s1 + <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; s2 + <span class="number">1</span>;</span><br><span class="line">    l1 = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">    l2 = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pre</span>();</span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-哈希表</title>
    <url>/p/666f05c6.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P4305">洛谷P4305</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>hash[]</code>哈希表<br><br><code>find(int x)</code>查找哈希表中 $x$ 的位置<br><br><code>push(int x)</code>将 $x$ 插入到哈希表中<br><br><code>check(int x)</code>查找 $x$ 是否在哈希表中</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> p 100003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hash(a) a%p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[p], t, n, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) y = <span class="built_in">hash</span>(-x);</span><br><span class="line">    <span class="keyword">else</span> y = <span class="built_in">hash</span>(x);</span><br><span class="line">    <span class="keyword">while</span> (h[y] &amp;&amp; h[y] != x) y = <span class="built_in">hash</span>(++y);</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[<span class="built_in">find</span>(x)] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[<span class="built_in">find</span>(x)] == x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">check</span>(x))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">                <span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-字符串算法-字符串哈希</title>
    <url>/p/114af1e8.html</url>
    <content><![CDATA[<p>例：<a href="https://www.luogu.org/problemnew/show/P3370">洛谷P3370</a></p>
<h4 id="单哈希-自然溢出"><a href="#单哈希-自然溢出" class="headerlink" title="单哈希(自然溢出)"></a>单哈希(自然溢出)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = Ans * base + (ULL)s[i];</span><br><span class="line">    <span class="keyword">return</span> Ans &amp; <span class="number">0x7fffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单哈希-单模数"><a href="#单哈希-单模数" class="headerlink" title="单哈希(单模数)"></a>单哈希(单模数)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>], mod = <span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单哈希-大模数"><a href="#单哈希-大模数" class="headerlink" title="单哈希(大模数)"></a>单哈希(大模数)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, a[<span class="number">10010</span>], mod = <span class="number">212370440130137957LL</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> prime = <span class="number">233317</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod + prime;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL base = <span class="number">131</span>, mod1=<span class="number">19260817</span>, mod2=<span class="number">19660813</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ULL x,y;</span><br><span class="line">&#125;a[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash1</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod1;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">hash2</span><span class="params">(<span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    ULL Ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        Ans = (Ans * base + (ULL)s[i]) % mod2;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-数论-线性筛素数</title>
    <url>/p/cff9d95.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>p[]</code> 最终结果</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">int</span> p[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            p[++cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = i * p[j];</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= N) <span class="keyword">break</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p[j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Floyd</title>
    <url>/p/ba77762f.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m, G[][]</code>点数、边数、邻接矩阵<br><br><code>dist[][]</code>每对顶点间路径长度<br><br><code>pre[][]</code>每对顶点之间路径<br><br><code>make()</code>建图</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, G[maxn][maxn], dist[maxn][maxn], pre[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            G[i][j] = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        G[from][to] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i][j] = G[i][j];</span><br><span class="line">            pre[i][j]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                    pre[i][j]  = pre[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-欧拉回路</title>
    <url>/p/57662471.html</url>
    <content><![CDATA[<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>G[][]</code>邻接矩阵<br><br><code>deg[]</code>度<br><br><code>ans[]</code>欧拉回路<br><br><code>n, e</code>点数、边数</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> G[maxn][maxn], deg[maxn], ans[maxn];</span><br><span class="line"><span class="keyword">int</span> n, e, x, y, ansi, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Euler</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G[i][j])</span><br><span class="line">		&#123;</span><br><span class="line">			G[i][j] = G[j][i] = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">Euler</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[++ansi] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;e);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= e; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		G[x][y] = G[y][x] = <span class="number">1</span>;</span><br><span class="line">		deg[x]++;</span><br><span class="line">		deg[y]++;</span><br><span class="line">	&#125;</span><br><span class="line">	s = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (deg[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">			s = i;</span><br><span class="line">	<span class="built_in">Euler</span>(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= ansi; ++i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p><code>n, m</code>点数、边数<br><br><code>head, edge[]</code>链式前向星<br><br><code>ans[], ansi</code>路径、数组大小<br><br><code>vis[]</code>记录<br><br><code>make()</code>建图</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, next;</span><br><span class="line">&#125;edge[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i, j;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line">		edge[k].to = i;</span><br><span class="line">		edge[k].next = head[i];</span><br><span class="line">		head[i] = k;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[maxm];</span><br><span class="line"><span class="keyword">int</span> ansi = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2</span> * maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now]; k != <span class="number">0</span>; k = edge[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[k])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[k] = <span class="literal">true</span>;</span><br><span class="line">            vis[k ^ <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(edge[k].to);</span><br><span class="line">            ans[ansi++] = k;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-动态规划</title>
    <url>/p/8364d7e9.html</url>
    <content><![CDATA[<p><strong><em>待完成</em></strong></p>
<h2 id="多阶段过程决策的最优化问题"><a href="#多阶段过程决策的最优化问题" class="headerlink" title="多阶段过程决策的最优化问题"></a>多阶段过程决策的最优化问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A --5--&gt; B1</span><br><span class="line">    A --3--&gt; B2</span><br><span class="line">    B1 --1--&gt; C1</span><br><span class="line">    B1 --6--&gt; C2</span><br><span class="line">    B1 --3--&gt; C3</span><br><span class="line">    B2 --8--&gt; C2</span><br><span class="line">    B2 --4--&gt; C4</span><br><span class="line">    C1 --5--&gt; D1</span><br><span class="line">    C1 --6--&gt; D2</span><br><span class="line">    C2 --5--&gt; D1</span><br><span class="line">    C3 --8--&gt; D3</span><br><span class="line">    C4 --3--&gt; D3</span><br><span class="line">    D1 --3--&gt; E</span><br><span class="line">    D2 --4--&gt; E</span><br><span class="line">    D3 --3--&gt; E</span><br></pre></td></tr></table></figure>

<p>!!! tldr “题目及注解”<br>    求上图从 $A$ 到 $E$ 的最短距离<br><br><br>    $K$: 阶段<br><br>    $D(X_I, (X+1)_J)$: 从 $X_I$ 到 $(X+1)_J$ 的距离<br><br>    $F_K(X_I)$: $K$ 阶段下 $X_I$ 到终点 $E$ 的最短距离</p>
<p>倒推:<br>$$<br>K=4\qquad F_4(D_1)=3\qquad F_4(D_2)=4\qquad F_4(D_3)=3<br>$$<br>$$<br>K=5\qquad F_3(C_1)=min(D(C_1,D_1)+F_4(D_1),D(C_1,D_2)+F_4(D_2))=min(5+3,6+4)=8<br>F_3(C_2)<br>$$</p>
]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-图论-Dijkstra</title>
    <url>/p/982e7a01.html</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>n, m</code>点数、边数<br><br><code>G[][]</code>邻接矩阵存图<br><br><code>dist[]</code>路径长度<br><br><code>pre[]</code>路径<br><br><code>make()</code>建图</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, G[maxn][maxn], dist[maxn], pre[maxn], s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            G[i][j] = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) G[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> from, to, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;from, &amp;to, &amp;w);</span><br><span class="line">        G[from][to] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k, min;</span><br><span class="line">    <span class="keyword">bool</span> p[maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != s)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[i] = G[s][i];</span><br><span class="line">            pre[i]  = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[s] = <span class="number">0</span>; p[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        min = INT_MAX; k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p[j] &amp;&amp; dist[j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = dist[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        p[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p[j] &amp;&amp; G[k][j] != INT_MAX &amp;&amp; dist[j] &gt; dist[k] + G[k][j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[k] + G[k][j];</span><br><span class="line">                pre[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆优化-链式前向星"><a href="#堆优化-链式前向星" class="headerlink" title="堆优化(链式前向星)"></a>堆优化(链式前向星)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, t;</span><br><span class="line">&#125;edge[maxm &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].to  = b;</span><br><span class="line">    edge[cnt].nxt = head[a];</span><br><span class="line">    edge[cnt].t   = t;</span><br><span class="line">    head[a]       = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> heap&amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;heap&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dist[i] = INF;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>((heap)&#123;<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        heap top = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> tx = top.u;</span><br><span class="line">        <span class="keyword">int</span> td = top.d;</span><br><span class="line">        <span class="keyword">if</span> (td != dist[tx]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[tx]; i; i = edge[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = edge[i].to;</span><br><span class="line">            <span class="keyword">if</span> (dist[v] &gt; dist[tx] + edge[i].t)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v] = dist[tx] + edge[i].t;</span><br><span class="line">                dy[v] = i; </span><br><span class="line">                dx[v] = tx;    <span class="comment">//记录路径</span></span><br><span class="line">                q.<span class="built_in">push</span>((heap)&#123;v, dist[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> q = n, p[maxm];</span><br><span class="line"><span class="keyword">while</span> (q != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p[++tot] = dy[q];</span><br><span class="line">    q = dx[q];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-树状数组</title>
    <url>/p/72c90980.html</url>
    <content><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>模板：<a href="https://www.luogu.org/problemnew/show/P3374">洛谷P3374</a></p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p><code>tree[]</code>树状数组<br><br><code>lowbit(int)</code>神奇的函数<br><br><code>add(int x, int k)</code>第 $x$ 个数加上 $k$ <br><br><code>sum(int x)</code>前 $x$ 个数的和</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tree[<span class="number">2000010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k &amp; -k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x] += k;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-大整数类</title>
    <url>/p/b995b9d7.html</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl = <span class="number">5000</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) a&gt;b ? a : b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a, b) a&lt;b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigInteger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> len, s[maxl];</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">BigInteger</span>();</span><br><span class="line">		<span class="built_in">BigInteger</span>(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">		<span class="built_in">BigInteger</span>(<span class="keyword">int</span>);</span><br><span class="line">		<span class="keyword">bool</span> sign;</span><br><span class="line">		<span class="function">string <span class="title">toStr</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;, BigInteger&amp;);</span><br><span class="line">		<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, BigInteger&amp;);</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>*);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>=(<span class="keyword">const</span> string);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>++();</span><br><span class="line">		BigInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>--();</span><br><span class="line">		BigInteger <span class="keyword">operator</span>--(<span class="keyword">int</span>);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> num) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>*=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line">		BigInteger <span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		BigInteger <span class="keyword">operator</span>/=(<span class="keyword">const</span> BigInteger&amp;);</span><br><span class="line"></span><br><span class="line">		BigInteger <span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp;) <span class="keyword">const</span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">factorial</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">Sqrt</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">		<span class="function">BigInteger <span class="title">Pow</span><span class="params">(<span class="keyword">const</span> BigInteger&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>;</span><br><span class="line">		~BigInteger;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">	len = <span class="number">1</span>;</span><br><span class="line">	sign = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">const</span> <span class="keyword">char</span> *num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::<span class="built_in">BigInteger</span>(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">BigInteger::toStr</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string res;</span><br><span class="line">	res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">		res = (<span class="keyword">char</span>)(s[i] + <span class="string">&#x27;0&#x27;</span>) + res;</span><br><span class="line">	<span class="keyword">if</span> (res == <span class="string">&quot;&quot;</span>) res = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (!sign &amp;&amp; res != <span class="string">&quot;0&quot;</span>) res = <span class="string">&quot;-&quot;</span> + res;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; in, BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	string str;</span><br><span class="line">	in&gt;&gt;str;</span><br><span class="line">	num = str;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	out&lt;&lt;num.<span class="built_in">toStr</span>();</span><br><span class="line">	<span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span>* num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(s));</span><br><span class="line">	<span class="keyword">char</span> a[maxl] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (num[<span class="number">0</span>] != <span class="string">&quot;-&quot;</span>)</span><br><span class="line">		<span class="built_in">strcpy</span>(a, num);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">strlen</span>(num); ++i)</span><br><span class="line">			a[i - <span class="number">1</span>] = num[i];</span><br><span class="line">	sign = !(num[<span class="number">0</span>] == <span class="string">&quot;-&quot;</span>);</span><br><span class="line">	len = <span class="built_in">strlen</span>(a);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); ++i)</span><br><span class="line">		s[i] = a[len - i - <span class="number">1</span>] - <span class="number">48</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; <span class="number">0</span>)</span><br><span class="line">		sign = <span class="number">0</span>, num = -num;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		sign = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> temp[MAX_L];</span><br><span class="line">	<span class="built_in">sprintf</span>(temp, <span class="string">&quot;%d&quot;</span>, num);</span><br><span class="line">	*<span class="keyword">this</span> = temp;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>=(<span class="keyword">const</span> string num)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* tmp;</span><br><span class="line">	tmp = num.<span class="built_in">c_str</span>();</span><br><span class="line">	*<span class="keyword">this</span> = tmp;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (sign^num.sign)</span><br><span class="line">		<span class="keyword">return</span> num.sign;</span><br><span class="line">	<span class="keyword">if</span> (len != num.len)</span><br><span class="line">		<span class="keyword">return</span> len &lt; num.len;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">		<span class="keyword">if</span> (s[i] != num.s[i])</span><br><span class="line">			<span class="keyword">return</span> sign ? (s[i] &lt; num.s[i]) : (s[i] &gt; num.s[i])</span><br><span class="line">	<span class="keyword">return</span> !sign;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> num &lt; *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>!=(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span> &gt; num || *<span class="keyword">this</span> &lt; num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> BigInteger::<span class="keyword">operator</span>==(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> !(num != *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 <span class="keyword">if</span> (sign^num.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 BigInteger tmp = sign ? num : *<span class="keyword">this</span>;</span><br><span class="line">		 tmp.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> sign ? *<span class="keyword">this</span> - tmp : num - tmp;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger result;</span><br><span class="line">	 result.len = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; temp || i &lt; (<span class="built_in">max</span>(len, num.len)); i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">int</span> t = s[i] + num.s[i] + temp;</span><br><span class="line">		 result.s[result.len++] = t % <span class="number">10</span>;</span><br><span class="line">		 temp = t / <span class="number">10</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">	 result.sign = sign;</span><br><span class="line">	 <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BigInteger old = *<span class="keyword">this</span>;</span><br><span class="line">	++(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>+=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> + num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 BigInteger b = num, a = *<span class="keyword">this</span>;</span><br><span class="line">	 <span class="keyword">if</span> (!num.sign &amp;&amp; !sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 b.sign = <span class="number">1</span>;</span><br><span class="line">		 a.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> b - a;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (!b.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 b.sign = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> a + b;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (!a.sign)</span><br><span class="line">	 &#123;</span><br><span class="line">		 a.sign = <span class="number">1</span>;</span><br><span class="line">		 b = <span class="built_in">BigInteger</span>(<span class="number">0</span>) - (a + b);</span><br><span class="line">		 <span class="keyword">return</span> b;</span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">	 &#123;</span><br><span class="line">		 BigInteger c = (b - a);</span><br><span class="line">		 c.sign = <span class="literal">false</span>;</span><br><span class="line">		 <span class="keyword">return</span> c;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger result;</span><br><span class="line">	 result.len = <span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, g = <span class="number">0</span>; i &lt; a.len; i++)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">int</span> x = a.s[i] - g;</span><br><span class="line">		 <span class="keyword">if</span> (i &lt; b.len) x -= b.s[i];</span><br><span class="line">		 <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">		 <span class="keyword">else</span></span><br><span class="line">		 &#123;</span><br><span class="line">			 g = <span class="number">1</span>;</span><br><span class="line">			 x += <span class="number">10</span>;</span><br><span class="line">		 &#125;</span><br><span class="line">		 result.s[result.len++] = x;</span><br><span class="line">	 &#125;</span><br><span class="line">	 result.<span class="built_in">clean</span>();</span><br><span class="line">	 <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">	BigInteger old = *<span class="keyword">this</span>;</span><br><span class="line">	--(*<span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>-=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> - num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger result;</span><br><span class="line">	result.len = len + num.len;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num.len; j++)</span><br><span class="line">			result.s[i + j] += s[i] * num.s[j];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		 result.s[i + <span class="number">1</span>] += result.s[i] / <span class="number">10</span>;</span><br><span class="line">		 result.s[i] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	result.<span class="built_in">clean</span>();</span><br><span class="line">	result.sign = !(sign^num.sign);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">int</span> num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger x = num;</span><br><span class="line">	BigInteger z = *<span class="keyword">this</span>;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	 BigInteger ans;</span><br><span class="line">	 ans.len = len - num.len + <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">if</span> (ans.len &lt; <span class="number">0</span>)</span><br><span class="line">	 &#123;</span><br><span class="line">		 ans.len = <span class="number">1</span>;</span><br><span class="line">		 <span class="keyword">return</span> ans;</span><br><span class="line">	 &#125;</span><br><span class="line">	 BigInteger divisor = *<span class="keyword">this</span>, divid = num;</span><br><span class="line">	 divisor.sign = divid.sign = <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">int</span> k = ans.len - <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">while</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">while</span> (divisor.s[j] == <span class="number">0</span>) j--;</span><br><span class="line">		 <span class="keyword">if</span> (k &gt; j) k = j;</span><br><span class="line">		 <span class="keyword">char</span> z[MAX_L];</span><br><span class="line">		 <span class="built_in">memset</span>(z, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(z));</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = j; i &gt;= k; i--)</span><br><span class="line">			 z[j - i] = divisor.s[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			 BigInteger dividend = z;</span><br><span class="line">			 <span class="keyword">if</span> (dividend &lt; divid) &#123; k--; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			 <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">			 <span class="keyword">while</span> (divid*key &lt;= dividend) key++;</span><br><span class="line">			 key--;</span><br><span class="line">			 ans.s[k] = key;</span><br><span class="line">			 BigInteger temp = divid*key;</span><br><span class="line">			 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">				 temp = temp * <span class="number">10</span>;</span><br><span class="line">				 divisor = divisor - temp;</span><br><span class="line">				 k--;</span><br><span class="line">	 &#125;</span><br><span class="line">	 ans.<span class="built_in">clean</span>();</span><br><span class="line">	 ans.sign = !(sign^num.sign);</span><br><span class="line">	 <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>/=(<span class="keyword">const</span> BigInteger&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">	*<span class="keyword">this</span> = *<span class="keyword">this</span> / num;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger BigInteger::<span class="keyword">operator</span>%(<span class="keyword">const</span> BigInteger&amp; num) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	BigInteger a = *<span class="keyword">this</span>, b = num;</span><br><span class="line">	a.sign = b.sign = <span class="number">1</span>;</span><br><span class="line">	BigInteger result, temp = a / b*b;</span><br><span class="line">	result = a - temp;</span><br><span class="line">	result.sign = sign;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">BigInteger::Pow</span><span class="params">(<span class="keyword">const</span> BigInteger&amp; num)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BigInteger result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (BigInteger i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">		result = result * (*<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">BigInteger::factorial</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BigInteger result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (BigInteger i = <span class="number">1</span>; i &lt;= *<span class="keyword">this</span>; i++)</span><br><span class="line">		result *= i;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BigInteger::clean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) len++;</span><br><span class="line">	<span class="keyword">while</span> (len &gt; <span class="number">1</span> &amp;&amp; s[len - <span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">		len--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInteger <span class="title">BigInteger::Sqrt</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(*<span class="keyword">this</span> &lt; <span class="number">0</span>) <span class="keyword">return</span> - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(*<span class="keyword">this</span> &lt;= <span class="number">1</span>)<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	BigInteger l = <span class="number">0</span>, r = *<span class="keyword">this</span>, mid;</span><br><span class="line">	<span class="keyword">while</span>(r - l &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(mid * mid &gt; *<span class="keyword">this</span>)</span><br><span class="line">			r = mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			l = mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInteger::~<span class="built_in">BigInteger</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-BFS</title>
    <url>/p/99890668.html</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文实现只是框架，应当灵活运用，bfs()函数内部根据情况灵活更改<br>广搜算法基于树、队列实现，具体思路: <code>将当前点的子节点入队，当前点出队，如果子节点满足条件则记录</code>并重复此过程</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    vis[start_x][start_y] = <span class="literal">true</span>;            <span class="comment">//标记起始点</span></span><br><span class="line">    que[head][<span class="number">0</span>] = start_x; </span><br><span class="line">    que[head][<span class="number">1</span>] = start_y;                  <span class="comment">//起始点入队</span></span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail)                       <span class="comment">//队不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = que[head][<span class="number">0</span>], y = que[head][<span class="number">1</span>]  <span class="comment">//获取队首点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; 子节点数; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = x子节点, y2 = y子节点;</span><br><span class="line">            <span class="keyword">if</span> (x2, y2满足条件 &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                记录结果;</span><br><span class="line">                vis[x2][y2] = <span class="literal">true</span>;</span><br><span class="line">                que[tail][<span class="number">0</span>] = x2;</span><br><span class="line">                que[tail][<span class="number">0</span>] = y2;</span><br><span class="line">                tail++;                         <span class="comment">//入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head++;                                 <span class="comment">//队首出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="STL-queue"><a href="#STL-queue" class="headerlink" title="STL-queue"></a>STL-queue</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;node, top;</span><br><span class="line"></span><br><span class="line">queue&lt;Node&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[sx][sy] = <span class="literal">true</span>;</span><br><span class="line">    node.x = sx;</span><br><span class="line">    node.y = sy;</span><br><span class="line">    que.<span class="built_in">push</span>(node);</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        top = que.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = ..., y2 = ...;</span><br><span class="line">            <span class="keyword">if</span> (x2, y2满足条件 &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                记录结果;</span><br><span class="line">                vis[x2][y2] = <span class="literal">true</span>;</span><br><span class="line">                node.x = x2;</span><br><span class="line">                node.y = y2;</span><br><span class="line">                que.<span class="built_in">push</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><a href="https://www.luogu.org/problemnew/show/P1443">洛谷P1443</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy, vis[<span class="number">210</span>][<span class="number">210</span>], ans[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> gox[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> goy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">horse</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;node, top;</span><br><span class="line"></span><br><span class="line">queue&lt;horse&gt; que;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    node.x = sx;</span><br><span class="line">    node.y = sy;</span><br><span class="line">    que.<span class="built_in">push</span>(node);</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        top = que.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x2 = top.x + gox[i];</span><br><span class="line">            <span class="keyword">int</span> y2 = top.y + goy[i];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt;= <span class="number">1</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= <span class="number">1</span> &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[x2][y2] = ans[top.x][top.y] + <span class="number">1</span>;</span><br><span class="line">                vis[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                node.x = x2;</span><br><span class="line">                node.y = y2;</span><br><span class="line">                que.<span class="built_in">push</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;sx, &amp;sy);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sx, sy, vis[<span class="number">210</span>][<span class="number">210</span>], que[<span class="number">50000</span>][<span class="number">2</span>], ans[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="keyword">int</span> gox[<span class="number">8</span>] = &#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> goy[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">2</span>;</span><br><span class="line">    vis[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    que[head][<span class="number">0</span>] = sx;</span><br><span class="line">    que[head][<span class="number">1</span>] = sy;</span><br><span class="line">    ans[sx][sy] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, x2, y, y2;</span><br><span class="line">        x = que[head][<span class="number">0</span>];</span><br><span class="line">        y = que[head][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x2 = x + gox[i];</span><br><span class="line">            y2 = y + goy[i];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt;= <span class="number">1</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= <span class="number">1</span> &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[x2][y2] = ans[x][y] + <span class="number">1</span>;</span><br><span class="line">                vis[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                que[tail][<span class="number">0</span>] = x2;</span><br><span class="line">                que[tail][<span class="number">1</span>] = y2;</span><br><span class="line">                tail++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;sx, &amp;sy);</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(ans));</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%-5d&quot;</span>, ans[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp算法-DFS</title>
    <url>/p/9d047ada.html</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文实现只是框架，应当灵活运用，dfs(…)函数返回值类型、参数列表根据情况灵活更改</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数列表)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (到达目的地) 输出结果;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; 行动方法数; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (下一步可行)</span><br><span class="line">            &#123;</span><br><span class="line">                记录此步;</span><br><span class="line">                <span class="built_in">dfs</span>(改动后的参数列表);</span><br><span class="line">                取消记录此步;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p><a href="https://www.luogu.org/problemnew/show/P1605">洛谷P1605</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t, sx, sy, fx, fy, ans;</span><br><span class="line"><span class="keyword">int</span> mg[<span class="number">6</span>][<span class="number">6</span>], now[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> go[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x2, y2;</span><br><span class="line">    <span class="keyword">if</span> (x == fx &amp;&amp; y == fy) ans++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x2 = x + go[i][<span class="number">0</span>];</span><br><span class="line">            y2 = y + go[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x2 &gt; <span class="number">0</span> &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt; <span class="number">0</span> &amp;&amp; y2 &lt;= m &amp;&amp; mg[x2][y2] == <span class="number">0</span> &amp;&amp; now[x2][y2] == <span class="number">0</span>)</span><br><span class="line">                </span><br><span class="line">            &#123;</span><br><span class="line">                now[x2][y2] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(x2, y2);</span><br><span class="line">                now[x2][y2] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mg, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(mg));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;t);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;sx, &amp;sy, &amp;fx, &amp;fy);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        mg[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    now[sx][sy] = <span class="number">1</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(sx, sy);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++算法</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux美化方案</title>
    <url>/p/f2ddc0e6.html</url>
    <content><![CDATA[<h3 id="I-初步系统优化"><a href="#I-初步系统优化" class="headerlink" title="I. 初步系统优化"></a>I. 初步系统优化</h3><hr>
<ul>
<li>更改系统时间</li>
<li>安装python<br>  <code>sudo apt install python</code></li>
<li>安装git并添加ssh密钥<br>  <code>sudo apt install git</code><br>  <code>git config --global user.name &quot;your_name&quot;</code><br>  <code>git config --global user.email &quot;you@example.com&quot;</code><br>  <code>ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</code>一路回车<br>  <code>cat ~/.ssh/id_rsa.pub</code>并复制粘贴到github上<br>  <code>ssh -T git@github.com</code>测试<br>  <code>git clone https://github.com/Tony031218/Beautiful_Linux.git</code>克隆下本仓库</li>
<li>添加语言<pre>
  settings -> Region&Language -> manage installed language -> install/remove languages
                              -> input sources
</pre></li>
<li>软件更新<br>  <code>sudo apt update</code><br>  <code>sudo apt upgrade</code></li>
<li>安装GDebi<br>  <code>sudo apt install gdebi</code></li>
<li>卸载libreoffice 安装 WPS(可选)<br>  <code>sudo apt remove libreoffice-common</code><br>  从<a href="http://www.wps.cn/product/wpslinux/">http://www.wps.cn/product/wpslinux/</a> 上下载WPS<br>  <code>sudo dpkg -i wps-office_10.1.0.6757_amd64.deb</code></li>
<li>卸载firefox 安装 Chrome(可选)<br>  <code>sudo apt remove firefox</code><br>  <code>wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</code><br>  <code>sudo dpkg -i google-chrome*</code><br>  <code>sudo apt -f install</code></li>
<li>更换更新源<br>  左下角 -&gt; all -&gt; Software&amp;Updates<br>  <code>sudo apt update</code></li>
<li>安装vim<br>  <code>sudo apt install vim</code></li>
<li>菜单栏位置<br>  <code>gsettings set com.canonical.Unity.Launcher launcher-position Bottom</code>底部<br>  <code>gsettings set com.canonical.Unity.Launcher launcher-position Left</code>左侧</li>
</ul>
<h3 id="II-主题配置"><a href="#II-主题配置" class="headerlink" title="II. 主题配置"></a>II. 主题配置</h3><hr>
<ul>
<li><p>安装 Unity-tweak-tool<br><code>sudo apt install unity-tweak-tool</code><br>如果出现报错需要安装缺失的包</p>
</li>
<li><p>安装 Flatabulous 主题<br><code>sudo add-apt-repository ppa:noobslab/themes</code><br><code>sudo apt update</code><br><code>sudo apt install flatabulous-theme</code>主题<br><code>sudo add-apt-repository ppa:noobslab/icons</code><br><code>sudo apt update</code><br><code>sudo apt install ultra-flat-icons</code>图标<br>unity-tweak-tool -&gt; 主题/图标</p>
</li>
<li><p>字体<br>Monaco Powerline 也可以选择其他字体,但一定要支持Powerline的,否则后文会出现乱码</p>
</li>
</ul>
<h3 id="III-终端Terminal美化"><a href="#III-终端Terminal美化" class="headerlink" title="III. 终端Terminal美化"></a>III. 终端Terminal美化</h3><hr>
<ul>
<li>Terminal zsh<br>  <code>sudo apt install zsh</code><br>  <code>git clone https://github.com/robbyrussell/oh-my-zsh.git</code><br>  <code>cd oh-my-zsh/tools</code><br>  <code>./install.sh</code></li>
<li>更换默认shell<br>  <code>chsh</code>按步骤来输入zsh地址</li>
<li>zsh插件<ul>
<li>自动补全<br>  <code>git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></li>
<li>快速跳转<br>  <code>git clone https://github.com/joelthelion/autojump.git</code><br>  <code>cd autojump</code><br>  <code>./install.py</code>按要求把代码填写到~/.zshrc文件尾</li>
<li>配置<br>  <code>vim ~/.zshrc</code><br>  修改60行左右的plugins<code>plugins=(git autojump zsh-suggestions)</code></li>
<li>修改皮肤<br>  <code>~/.zshrc</code>中的<code>ZSH_THEME=&quot;robbyrussell&quot;</code>更改</li>
</ul>
</li>
</ul>
<h3 id="IV-vim美化"><a href="#IV-vim美化" class="headerlink" title="IV. vim美化"></a>IV. vim美化</h3><hr>
<ul>
<li>molokai<br>  <code>mkdir ~/.vim/colors</code><br>  将本仓库中的<code>molokai.vim</code>复制到<code>~/.vim/colors/</code>下</li>
<li>Powerline<br>  <code>sudo apt install python-pip</code><br>  <code>pip install git+git://github.com/powerline/powerline</code><br>  <code>pip show powerline-status</code><br>  按照具体位置更改<code>~/.vimrc</code>中的<code>set rtp+=...</code>一行(后文)</li>
<li>插件<ul>
<li>pathogen插件管理<br>  <code>mkdir -p ~/.vim/autoload ~/.vim/bundle</code><br>  <code>curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim</code></li>
<li>nerdtree文件浏览器<br>  <code>cd ~/.vim/bundle</code><br>  <code>git clone https://github.com/scrooloose/nerdtree.git</code></li>
<li>taglist大纲界面<br><a href="https://www.vim.org/scripts/scripts.php?script_id=273">taglist官网</a><br>  下载后解压到<code>~/.vim/bundle/</code>下</li>
</ul>
</li>
<li>vimrc<br>  将本仓库中的<code>vimrc.txt</code>复制到<code>~/.vimrc</code>中<br>  内包含括号匹配,html标签匹配,powerline配置(可能需要改动),cpp.sh.java.py的文件头自动输入,插件的配置(F3打开nerdtree,F4打开taglist)</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="https://blog.csdn.net/qq_35208390/article/details/78441013">CSDN博客</a><br><a href="https://www.linuxprobe.com/use-powerline-for-bash.html">powerline</a><br><a href="https://blog.csdn.net/zcube/article/details/42525973">vim插件</a><br><a href="https://github.com/ocxo/monaco-powerline-vim">monaco powerline字体</a><br><a href="https://github.com/sickill/vim-monokai">monokai主题</a><br><a href="http://www.wps.cn/product/wpslinux/">WPS</a></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Git简单用法</title>
    <url>/p/e779c345.html</url>
    <content><![CDATA[<p><code>Git</code>是一款版本控制软件，配合<code>GitHub</code>可以更好的控制代码</p>
<span id="more"></span>

<h3 id="SSH-Key"><a href="#SSH-Key" class="headerlink" title="SSH Key"></a>SSH Key</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">&quot;975062472@qq.com&quot;</span></span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> id_rsa.pub</span><br><span class="line"><span class="variable">$</span> ssh <span class="literal">-T</span> git@github.com</span><br></pre></td></tr></table></figure>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> mkdir study_cpp</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> study_cpp/</span><br><span class="line"><span class="variable">$</span> <span class="built_in">echo</span> <span class="string">&quot;# test&quot;</span> &gt;&gt; README.md</span><br><span class="line"><span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">README.md</span><br><span class="line"><span class="variable">$</span> git init</span><br><span class="line"><span class="variable">$</span> git add README.md</span><br><span class="line"><span class="variable">$</span> git commit <span class="literal">-m</span> <span class="string">&quot;添加 README.md 文件&quot;</span></span><br><span class="line"><span class="variable">$</span> git remote add origin git@github.com:Tony031218/study_cpp.git</span><br><span class="line"><span class="variable">$</span> git push <span class="literal">-u</span> origin master</span><br></pre></td></tr></table></figure>
<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">git</span>@github.com:Tony031218/study_cpp</span><br></pre></td></tr></table></figure>
<h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git fetch origin</span><br><span class="line"><span class="variable">$ </span>git merge origin/master</span><br></pre></td></tr></table></figure>
<h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git add &lt;filename&gt;</span><br><span class="line"><span class="variable">$ </span>git commit -m <span class="string">&quot;推送信息&quot;</span></span><br><span class="line"><span class="variable">$ </span>git push origin master</span><br></pre></td></tr></table></figure>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote add origin2 git<span class="variable">@github</span>.<span class="symbol">com:</span>Tony031218/study_cpp.git</span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br><span class="line"><span class="variable">$ </span>git remote rm origin2</span><br><span class="line"><span class="variable">$ </span>git remote -v</span><br></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ git checkout -b graph  <span class="regexp">//</span>创建分支，并切换过去</span><br><span class="line">$ git checkout master    <span class="regexp">//</span>回到主分支</span><br><span class="line">$ git push origin graph  <span class="regexp">//</span>将分支推送到远程仓库</span><br><span class="line">$ git pull               <span class="regexp">//</span>将本地仓库更新</span><br><span class="line">$ git diff graph master  <span class="regexp">//</span>显示差别</span><br></pre></td></tr></table></figure>
<h3 id="克隆分支"><a href="#克隆分支" class="headerlink" title="克隆分支"></a>克隆分支</h3><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">$ git clone -b <span class="params">&lt;branch_name&gt;</span> <span class="params">&lt;repo_url&gt;</span>   <span class="comment">//克隆单个分支</span></span><br><span class="line">$ cd <span class="params">&lt;repo&gt;</span></span><br><span class="line">$ git branch -a                           <span class="comment">//查看所有分支</span></span><br><span class="line">$ git checkout -b <span class="params">&lt;branch_name&gt;</span> origin/<span class="params">&lt;branch_name&gt;</span>  <span class="comment">//关联分支</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/p/3c50d03d.html</url>
    <content><![CDATA[<p><code>Markdown</code>是一款简洁实用的文本标记语言，可以在<code>mkdocs</code>,<code>hexo</code>中使用</p>
<span id="more"></span>

<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>

<p>下划线</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">****</span></span><br><span class="line"><span class="string">----</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p><code>[TOC]</code></p>
<hr>
<h4 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h4><p><strong><code>** **</code>加粗</strong><br><br><em><code>* *</code>倾斜</em><br><br><em><strong><code>*** ***</code>倾斜加粗</strong></em><br><br><code>~~ ~~</code><del>删除</del></p>
<hr>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p><code>&gt;</code>一级 <code>&gt;&gt;</code>二级</p>
<blockquote>
<p>引用</p>
<blockquote>
<p>二级引用</p>
</blockquote>
</blockquote>
<blockquote>
<p>引用</p>
</blockquote>
<hr>
<h4 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h4><p><code>&amp;nbsp; 或 &lt;br/&gt;</code><br>&nbsp;<br><br></p>
<hr>
<h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p><code>&amp;emsp;</code><br><br>&emsp;&emsp;空格</p>
<hr>
<h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><code>![图片名](图片地址 &quot;title&quot;)</code><br><img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=d997317c11ce36d3b6098b625b9a51e2/00e93901213fb80ef9ceac7132d12f2eb938947d.jpg" alt="markdown"></p>
<p>或使用html标签<code>&lt;img src=&quot;...&quot; width=&quot;...&quot; height=&quot;...&quot; /&gt;</code></p>
<hr>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><code>[网页名](地址 &quot;title&quot;)</code><br><a href="http://www.baidu.com/" title="百度一下">百度</a></p>
<hr>
<h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello markdown&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="序表"><a href="#序表" class="headerlink" title="序表"></a>序表</h4><ol>
<li>有序1</li>
<li>有序2</li>
<li>有序3</li>
</ol>
<hr>
<p><code>+ 或 - 或 *</code></p>
<ul>
<li>无序</li>
</ul>
<ul>
<li>无序</li>
</ul>
<ul>
<li>无序</li>
</ul>
<hr>
<ul>
<li>一级无序<ul>
<li>二级无序<ul>
<li>三级无序<ul>
<li>四级无序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><p><code>- [ ] ...</code><br><br><code>- [x] ...</code><br><br><code>mkdocs</code>需要<code>pymdown</code>中的<code>pymdownx</code>模块<br><br><code>GitHub</code>支持</p>
<hr>
<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">|<span class="symbol">:----------|</span><span class="symbol">:----------</span><span class="symbol">:|----------</span><span class="symbol">:|</span></span><br><span class="line">| 左对齐 |居中|右对齐|</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">表头</th>
<th align="center">表头</th>
<th align="right">表头</th>
</tr>
</thead>
<tbody><tr>
<td align="left">左对齐</td>
<td align="center">居中</td>
<td align="right">右对齐</td>
</tr>
<tr>
<td align="left"></td>
<td align="center"></td>
<td align="right"></td>
</tr>
</tbody></table>
<hr>
<h4 id="内联CSS"><a href="#内联CSS" class="headerlink" title="内联CSS"></a>内联CSS</h4><p><code>&lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: &#39;Consolas&#39;;&quot;&gt;CSS&lt;/p&gt;</code></p>
<p style="color: #AD5D0F;font-size: 30px; font-family: 'Consolas';">CSS</p>

<hr>
<h4 id="语义标记"><a href="#语义标记" class="headerlink" title="语义标记"></a>语义标记</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>加粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>强调<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line">上标： Z<span class="tag">&lt;<span class="name">sup</span>&gt;</span>a<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">下标： Z<span class="tag">&lt;<span class="name">sub</span>&gt;</span>a<span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span><br><span class="line">键盘文本： <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> <i>斜体</i><br><br> <b>加粗</b><br><br> <em>强调</em><br><br> 上标： Z<sup>a</sup><br><br> 下标： Z<sub>a</sub><br><br> 键盘文本： <kbd>Ctrl</kbd><br></p>
<hr>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>文档末尾添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-mathjax-config&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">MathJax.Hub.Config(&#123;</span></span><br><span class="line"><span class="javascript">	  <span class="attr">tex2jax</span>: &#123;<span class="attr">inlineMath</span>: [[<span class="string">&#x27;$&#x27;</span>,<span class="string">&#x27;$&#x27;</span>], [<span class="string">&#x27;\\(&#x27;</span>,<span class="string">&#x27;\\)&#x27;</span>]]&#125;</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用$\LaTeX$语法编写公式<br>$$<br>x \href{why-equal.html} {=} y^2 + 1<br>$$<br>$$<br>x = {-b \pm \sqrt{b^2-4ac} \over 2a}<br>$$</p>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>MkDocs使用方法</title>
    <url>/p/ce42b873.html</url>
    <content><![CDATA[<p>mkdocs是一款基于python markdown的项目文档工具,可以用来编写一个网站</p>
<span id="more"></span>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="安装python3及pip"><a href="#安装python3及pip" class="headerlink" title="安装python3及pip"></a>安装python3及pip</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install python3        <span class="comment">#安装python</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install python3-pip    <span class="comment">#安装pip</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 --version               <span class="comment">#检查python是否安装成功</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip3 --version                  <span class="comment">#检查pip是否安装成功</span></span></span><br></pre></td></tr></table></figure>
<h4 id="安装mkdocs"><a href="#安装mkdocs" class="headerlink" title="安装mkdocs"></a>安装mkdocs</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pip3 install mkdocs             <span class="comment">#注意以root权限安装</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkdocs --version                <span class="comment">#检查是否安装成功</span></span></span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs new <span class="built_in">test</span>                 <span class="comment">#创建一个名为test的文件夹,存储代码</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure>
<p>此时的目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test/</span><br><span class="line"> ├── docs/                        #存放markdown文档</span><br><span class="line"> │     └── index.md               #主页</span><br><span class="line"> └── mkdocs.yml                   #配置文件</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs serve                    <span class="comment">#开启内建服务器</span></span></span><br></pre></td></tr></table></figure>
<p>在浏览器中输入<code>127.0.0.1:8000</code>预览,终端键入<code>Ctrl+C</code>关闭服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdocs build                    <span class="comment">#生成静态网页代码</span></span></span><br></pre></td></tr></table></figure>
<p>这时已经生成了<code>site/</code>文件夹,可以将里面的内容部署到网站上了</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>site_name: </code>  <strong><em>必须存在</em></strong>,文档主标题名称<br><code>site_favicon: </code>  图标,存放在<code>docs/</code>文件夹下<br><code>theme: </code>  主题样式例如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> </span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;material&#x27;</span>                <span class="comment">#使用material主题,需要pip安装mkdocs-material</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">&#x27;zh&#x27;</span>                  <span class="comment">#使用中文</span></span><br><span class="line">  <span class="attr">feature:</span></span><br><span class="line">    <span class="attr">tabs:</span> <span class="literal">true</span>                    <span class="comment">#使用上方tab栏（可改为false）</span></span><br></pre></td></tr></table></figure>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">&#x27;Index&#x27;:</span> <span class="string">index.md</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">&#x27;About&#x27;:</span> <span class="string">about.md</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>执行<code>$ pip3 install pymdown-extensions</code>安装扩展包</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown_extensions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">admonition</span>                    <span class="comment">#支持注解</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">codehilite:</span>                   <span class="comment">#代码块高亮</span></span><br><span class="line">      <span class="attr">linenums:</span> <span class="literal">true</span>              <span class="comment">#代码块显示行号</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">pymdownx.tasklist</span>             <span class="comment">#支持任务列表</span></span><br></pre></td></tr></table></figure>

<p>!!! warning “注意”<br>    一定要事先安装好扩展，否则不能出现预期效果</p>
<hr>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://markdown-docs-zh.readthedocs.io/zh_CN/latest/">MkDocs中文文档</a><br><a href="https://www.mkdocs.org/">MkDocs官方文档</a><br><a href="https://cyent.github.io/markdown-with-mkdocs-material">cyent的教程</a></p>
]]></content>
      <tags>
        <tag>blog</tag>
        <tag>markdown</tag>
        <tag>mkdocs</tag>
      </tags>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[<style type="text/css">
.intro {
    text-align: center; 
    font-weight: bold
}
.intro a {
    color:var(--font-color)!important
}
.intro a:hover {
    text-decoration: underline
}
.intro p {
    line-height: 1.75
}
</style>

<div class="intro">

<p>(｡･∀･)ﾉﾞ<br>ZJUer | 哔哩哔哩up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a> | AAAer</p>
<p><a href="https://github.com/3b1b/manim">3b1b/manim</a>项目Collaborator<br><a href="https://github.com/manim-kindergarten">manim-kindergarten</a>组织Maintainer</p>
<p><a href="https://www.16personalities.com/ch/infj-%E4%BA%BA%E6%A0%BC">INFJ-T</a> | <a href="https://www.wizardingworld.com/">HUFFLEPUFF</a><br>VSCode 重度使用 | Python/C++<br>YOASOBI | 橙星 | 花谱 | 诺兰 | 新海诚</p>
<br>

<p>咕咕咕～～～！！<br>这里应该也不常更新_(:з」∠)_<br>但希望你能喜欢(～￣▽￣)～</p>
</div>

<details>
<summary>历史记录</summary>
<br>

<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a>的个人博客<br>高考结束，hexo重新配置，恢复更新<br>主要记录一些学习过程中遇到的技术问题解决办法</p>
<div style="text-align: right">于`2021.6.12`</div>
</blockquote>
<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a>的个人博客<br>同时也是<a href="https://github.com/3b1b/manim">3b1b/manim</a>项目的Collaborator，<a href="https://github.com/manim-kindergarten">manim-kindergarten</a>组织的Maintainer<br><del>正在高考备考，没有更新</del><br><del>这段时间由于hexo环境的问题，博客没有更新</del></p>
<div style="text-align: right">于`2020.9.30`</div>
</blockquote>
<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a>的个人博客<br>目前已经信竞退役，在B站制作一些manim教程和科普视频<br><del>这段时间由于hexo环境的问题，博客没有更新</del></p>
<div style="text-align: right">于`2020.6.21`</div>
</blockquote>
<blockquote>
<p>这里是B站up主<a href="https://space.bilibili.com/171431343">鹤翔万里</a>的个人博客<br>现在还是一名$JL$的$OIer$,这个博客目前主要堆放了我学习$OI$算法时的笔记和一些题解<br>还可能有一些乱七八糟的文章(比如游记,做视频的经验之类的)‍ _(:3」∠)_<br>总之,非常感谢您能够来到这里,一起加油‍吧(〜￣△￣)〜</p>
<div style="text-align: right">于`2020.4.27`</div>
</blockquote>
<blockquote>
<p>本博客于 <code>2019.1.9</code> 首次开通<br>于 <code>2019.3.10</code> 更新至Hexo<br>本博客主要记载一些经验和算法模板(<code>C++</code>)</p>
<div style="text-align: right">于`2019.3.10`</div>
</blockquote>
</details>]]></content>
  </entry>
  <entry>
    <title>C++算法(OI)</title>
    <url>/algorithms/index.html</url>
    <content><![CDATA[<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-DFS">深度优先搜索</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-BFS">广度优先搜索</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>&emsp;<a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">背包问题</a></p>
<h2 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h2><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E6%95%B0%E8%AE%BA-%E7%BA%BF%E6%80%A7%E7%AD%9B%E7%B4%A0%E6%95%B0">欧拉线性筛</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%A4%A7%E6%95%B4%E6%95%B0%E7%B1%BB">大整数类</a></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%A0%86">堆</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86">并查集</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-STL%E6%A0%87%E5%87%86%E5%BA%93">标准模板库STL</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">树状数组</a></p>
<h2 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h2><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C">字符串哈希</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95-KMP">KMP算法</a></p>
<h2 id="图论算法"><a href="#图论算法" class="headerlink" title="图论算法"></a>图论算法</h2><h3 id="链式前向星存储图"><a href="#链式前向星存储图" class="headerlink" title="链式前向星存储图"></a><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F">链式前向星存储图</a></h3><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF">欧拉回路</a></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-Prim">Prim</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-Kruskal">Kruskal</a></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-Dijkstra">Dijkstra</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-SPFA">SPFA</a><br><a href="/2019/01/10/Cpp%E7%AE%97%E6%B3%95-%E5%9B%BE%E8%AE%BA-Floyd">Floyd</a></p>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>友链</title>
    <url>/friends/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Oct, 2021</title>
    <url>/secret/21-oct.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不对哦" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="f8d2f5194b0473c088346152c37bcf96e4980742676cd4967692b09a491db0c0">e1fa201b2d31525bf9f1e5c19d32d0972c907596765b0eac77f58cdd3eed557c1458fc94dc9504ad0cd5bbf23c62bfbb95138f0e18782c3c668818ca370f300a7f70b9bb3e51de3c674a0e618dfe9a6141ca2d5927615430c498b998fa12d26101375fffe94ef9b701e4bc55febe75e4b99e28ea76f2853f627b77eb564a40b4071a38a614d631503107320530be978f6efc594360499cc3f89f0fd1aacf1dff8dd051c854146422d5e0da21d7a86686617e4599ff1129034789f7396545b64ea15204fcb6e17c5897ac939684ee95828d33d35001b9677ae7cdf82ee3cc501d4d9212263d0912c0219499f14c53b3017c8d457af112a08f15d78611255ed1597f07a170708a31942e1e8e751bbbae94c0e58322856772159e6a536947c8fef9d877465b8d268923c21b211ea1db04c1f96471d94231b18f5c2ecb3df1661c94db664eddcd132dd8ecab015cdd2e1f5b18e0c88176a22fa8c3e8c6be8cc813c06604c5ea071a19c8be210fabd54c8feb8a04dd0975752a9306863a9abdc6e989b03d83d69dc52b26b5e3023e37392d52379db3d16ee19c8229a8996ac1fccda696832988aeedf0a25901ee3866e32d138e2aae9943726e4272d7d0e654a1739a215dbbb3370c09ee30820f10c7e791c9da3ad64b414d5b0537fb6ff94d44b19c11aed9ec033fef3bc14e83864a674153af5ccf73e64cfc6201443a32e2a8b510bb9953dc6a5c0ede365238c354fdb313318100051e8d48a1505a3b1424bf03d7e4a1e51e1aee09a39c4fdc06599275d8ed2c022f5fe445c2e1daa9f20343c4defa471e3b16b43ceeee9fa5cfd38f1d7ba5f01cc8c2d1fbde7d2712633959199e09339878676ec561283ec92db96c61c8e8a0887c2c6a3f40c6bbe58ed8e4efdbd416ac6466b042405fdf2b7e708e589a4f39af6fbe346d17615a090dc53d070fe5a145024dd1f2d105fcf12d0cb509b69e0c02d14f3946b20a6e5da16adf7d3e82ce331ced11d5e10c160c1efbfc6c4e99c95fb0cc90d7a19fa6a2ae89c7021071ba1f386212a8d4648cb31e6a57ec14e8482e297b2a6948599555110e332f00c9981b7afeb04dac16d1043007018dc8b7e2c9764085e9e0a477d9a79fe1d9864a86e0b79edb8817b22a68d04c2938335e4a8b422b2de377dd3a4b44cab916bb8536c7a257153384da144398a55adc91507bc5ff0112b631a4a1a429ecbd749d0f92c9c48975c1fb4bcb493f89631e0995f42aa77bfa8014ecff3d0241d3162862b8553b935f0fa659cd1c2d22fde7f4372c727a6f7798e9232d1c08f3f0f7d34de0ffe22b51bb0461e18cf15e140f907f281b09d6cb6cf406300fcc6a2ff717e47227bd688cac3ec029152e56fe8b62a62b6ca037c6c835592e1e37df77a125c6ad34216cbdd7a4770f0bc4d37a81d09a2318f705d3757a65b6a9b07996acf5affa814ef3548d8055ffee1a8a4c3c9657b96a3b43f7a9e53b81f3a0bb942131987df362185279026fcf06c78bad548b8239ffb2cda4e880da3ccca648b147808834e39bcb5365365c4117468a1dc43e3dce1ed44dedfe9ef6eef225c112f7ee2dc1261c74fecaee7831e0618153fe09dbed85d547b8d0cf8733b201b3ed14731bdf3727325b12bf8721a0871bbb5cce3a0df6a5ea1b9e519ecf6126310dbf7d85f613812d2300294c721b04406b00c2b168b3b95a338973e009ed0445eb11deee13c07ac89f6d979623c5e8d862370b40f2b30ad5edfc022ef9df945aa8f69f46fc78c5e32ed7f2ec046d94e51e36a93d70b9630ebc12cd2b22023f19a740f0560de5fb169efca7a0b15ad0ef83920c0a70d1e62203c3c46a828c49b2c8bb08d3a0700b9ae3721b70b2f1a2f2c8feb0babf640ef4a874fd35128b46ede6f85fc1cf4c0c0f4842c3b2c24d6b453e92a8de82e67cde34d6c9c58d1c7ec168c82aa6dee565dcecd62134e7b9f38e0feb03c2670b2f1b367a59f34728142763b393c665f20dd35e264922db62af61c197f6e01c6f8a8f4e0cbd331990a3a65d9ba15b8accbfccca620605c5ed0f6a04fa2dd2fc729b43f77afc1c2b2b45ac56a3f6cad6b28c681d6678e6c7fd0504e6256b504d2f20ea9ec3e50d415e1029b75930f1edd01b2baff089f6efc7c794a0ef0b8467949a92415fc115c13f3341b90c09d8804847e57f0db20e9f3d29a787cdab95681900c26a3675146e468680901c0bc89f2a75c684be62ddfdd4506a89f3fc9cbd8837c6aef40e37b56899a4a129e4e15b2e1e55fdc928fc9f23eaf7a3063ce14d644b2552bb0d21e8acee3c535459ef87dab16acc86ff833cb20017f6033e8ee23c214a6b55bea01a764690e02bdf16882ec7971bd58121dc9dabd80708b27f1095d22d53758dbf54e2c423ce11382982dbc79041d971a8a712e58e5594b2cbf2edc2335e30eb27df6fda641af86e14a4adc6e2ff33d8752bb8b3744fa9383c2e8e2d7c101bb984f5f580d53c116797c05353d820c9b44e37cb30f762c5848de45674a8cd718b35183cb296a04f3195700d023e1c55c74429d46abfbcfd3b9adf4f6bb70838a271a8cc854df9e5a266fcb99d79b25d012577f9786822ad4b5d6401b75e67121b2d391cdb6e8b3096486110f4be065dfc1121cd676f5262a1985a05427da5b3b3a0e34b279743cbca06350ca29f9f2e819683d23c23d4453cfc4d9e9202be51960b717b5059347c2a61b91e69373f42364b1a234d99cee8bec030523d65a00eececd9f682b790d7e18bc2064cffab23322b8644e070299c7e1e69d4f6b4f999d8044ada0ab2452b6d020182e22ddeaddf9a0b0d71a8bc7751b7a785766549835130a70ced62d80811ce72f4c4d0b6232814a8dbb9433843b284db918543a088c0463872dc9cb539831a146450ce96ba348c8665180c50f82326ae8d5e2a553bf938ff80b8ae6b5ab0716c4af4f34944a4497a13f32c39b19f563ecee46d1a4ad069faffc4773de67a0c3abe3cf147c5a44fe9304fe49edf23c76ac41402ebcd56c6d77f14e6ba79a745d09186ffbd5a1579b60a176680ee28e1fa189e3c413b8f840a32efa40fd273ea8e5c415640691af118913d500655d154c888fed8681a7628c78a60e60b44c521d321d0f8b288cbaba273729d72cc548d29848b9ecad9e6b839a58f35c357d2a35d627590369591b27f3914a9dda4a5ff76dda3e10d74e20124cc2bfaafbec8b1be86dba37b00e4a684dfd4fa2276380838e3de6430dc9e46906b0ac2df0da398b9a45d7c2fd099b724d029c725086b48ce48f1a489ce89f213d4ac562d901e4a9607962132036c07209df1d5b65387a5ba88398ac34f0ce231220caef4e9d26c5be735e2a643a71370cc8289bc57bfcdb1e9bd234b24ebd1a7ffdb0d4d568b033e73b5e0c5464f5a7ac4d7801814209290869047b38361e527b8c399656ae62e586a80980a05c818477a7d13dc689df265ac1c32162871a568ecbd5f3631fa1f1a53d06ca8adcf19135defedeef3574355449ea065190e48d0e873a67db3b37f6a2fc9d914aa4b9af5adcc626df8da96d958160914b952b817636644b66e45368d479e303126058ad9bb4439870125fef273bdbbe1ad47e354c07fcd2a06cf7366a8eaacec7347668939f6ef6389b9ee2f2d2beb972b180fe1c1a29f8d6e15b749a9fa53a535be783dc9f6e3f7963d6477d612bb6a8ffb554dc069af3158a0c78fb51fe013bc390c4cfb07ae4da2858a33f44abfcf548d4b29b34314743155a03f355c78ced141f69e4d1de0936d68271a5ae292698fd59be4628df149a5f5b3bcea6133e908623670f1374062a25a719f91e72b13a8889f5d2ba14f336c0bdd08daf0c428032d4162a1a7694d4657f372854def8b3339aff203e7de02e7213e51a455a891122f6f534d906bd44c87626bbc322770a275d1dee6573207d96704213135e311ab28443ce0fd36c1805f93ad6566194e76b130ef2fb2f4213b527e4a841478d363c65e1a0b7456a8deafbee8e3aa1759bd175a659e592a4edd30200ade9ada9c16d892bd29617e8cf16420b36984467a22c951b1598c12e911c71ee3991bdef00c1953c4b4142d04373f375b436ddd614a9972f5e5899ee40286402c6f55bfb24a64cb39fbff9be040f60ed64f208aa33ae06ff1e38aed975d3ce2c7156e33554c0130db4dc6781fb186eeb88cdc2a903dd8e8dd876389e230362fe0aa605ce36d1ba108d948f49987745b43376e1764faa58d088086bf93df0ca5589670c6bb4da7532747cffa38386c53383ef8ce9f64d755cfe514615e843d76dd5aec0789775084b94b634a1c198b57bd6ed9ce5620c4470244e74631f4a9233fdcc214d8968553b3819134eac7124f9f048eb947b8490f76f3d70961b858bc3e26150c11848a9fc3cfb7e9f9cf74393e53b4cf74e412f0bb36e0ca38d6f8c7e8872f7973c66bd8b92526858a8bfa2412e2308d6f39d8be82c2a6fdc91c6e5441f78ed460119b499263831568e7cf7d052edc0fe12167c575cc317ccc98d750f804d9659c9929b3dd216646d3b0b6d91485a1a333cc304ef8d2ccbeed675f086275cc2f9cc651222c1aa9ba5c2cff7f52f09aee900b535c7af024fd9f009a848f993c5b4abe62286bded005f947fff83cff8627b32f1eddd15339fd2c55892b290de9d6759fb7f073ebb3c7b3bef0d3456a8452705445581e64412a13a0ca412f51c514553ee304a7224a73cacbf18095e4e4acba9f6c85a9459972b66533f36f06fca7573ac3453670cac11a68fd3728578345ae5411ce8e79c0e4b7d3973840175b75e6e88052f98d92f22e8fe4df88fe9d49b08484b83b0bb8ca772dd8135ecf4253f5aedcd81b92d9200926b993af3f5a6f08365621ce2dc4aa2476cf68313248a0a3fda0048e31e836f0886df3a04cee4482a1987fdc427bf1f2bf6463cac9f5ffcabf4d4751b7b7e60a404d2b758ea71616fb524fc15c0a9d5e4241cee150093036e8eca8a60821f5bce7d30075b1d1abf4ee69fbdb452152e9244fba9d36492b61ce5f3b5e6805ee90128e287e88dc70896d3c73f72cb2b6446faafc31655adfb7e7c0e1823f003c2d9d504d6233352cb44e6b655ff35a57ca9ffbb6b48a800675df73b8033c897023ec68b45084a030e99ee1bd35ce73034d6369bc45ecd9f0645e32542fe55f3268d48cfb4de31629ad4a39f770eb250475986272ced6158c00cb653ca594acaa7856e7c3e9a38367d2d2749f93a834f05c6f26237b983a738b19206fd783b5cab34b196644d2dcd7ae305b334601b51d6c39a37ad6ac995ddd003aa9e948a3f71e924838e43de834cdbd851b44b8286d625fb1368304bedef096990e420f66adbebdd4b153c2ed409cc1fcc786bf3d72176d7fe0d234603c3d1c0c8aa93fda5b6efecb97c3b1f76db811c2da9d6906d0d31d185cb131dc0a33e82f4af9fcc9a4fe6fff4044b96853654aaa0fe8c60421d2ff1ef1b5402ea23a30d4a45a846451baaaa618c51d8b6421933d48be1dde1ff8e2e8de8be81b4644beffa70fb62e149df443684a6896c44b7b771db914eaaf01c1e40f6a6cb5c843c1c599ef0e8311efa359413f941dad905c323a7d7486a159f919e080c97ca89f07a2ecd72587cb2dfa9555b001b08395f94e413fab2e88610cdf0f6917c2c84bf48a3a809da72781cff6c5a1c068f899d7ee8ff55cd241a9d9431ccb751322171932ca784548d6caee5b32bf9fee6eea10e3e055c386cd680f866b88f808aeee49e633b88ffac4458b2e15c3e34dc71a5630ffa2701cc62f66a42c2b24a2a638fa04e63be06755b09d26bdc617deb3b6acbcc8dcfb62cdd832d81538a6327969f81445326c65be15ec071ff9f539a9e01679a15d5e98636c15d017f3ea4ead3ba3eb1abff78bbd3712b6c5dbf4ffc793b9673b085a347c282cd630d416cc85b290571e9c9ca6655df6416328e68f4ba802998e676865420094192e8b3cda7f13c11330d1ae301f5eaf617372e6899f8a59e35e08e56577b69862bdd84388ae6226815df261ca5105d77d8e7745b0d3a23273350e120e58c17d6d8c623142dc3c80b8caf9a9f9f275937d1321ec9c261aa640597cad3171ca3a9492f886733fca37e8531c38d9b5fa9b689b1361801409524b838459b6d886289df67321d861c0fa8595bbef44252995f1b5cc8ba0683537ff5a9847dfd7102cfca358609d182535a974b850e789d1903efe2b2fb670e0d61ecd3596a44a47318dd66863fcd101772760f7d27516776bfdd6de3776a819c24185f81063b79fdbbc1898c0e3571019f72c53b4d0f033df6310615d897ca01cc26ee6c46855e8d261b3b8eaad426f536e888482c69674f4ba871d69ca8567bb30f19716d267fe753e43758c91c08820ae7796665033085308e6544c491e6ae6b709a7ad2a180942edd836e93378b79ae1dff6785f412217776a1ca65d9922db7442e463f0cb9dd40dbde430dd0bf54b6c83a74f950a092e87b0ad11f7fa1593d416f1fc56c32a01c1436e928fa0eef24544c649a203ec0488bf3c1c6eedafa35356849752cb09c0a57a895f281ed639a9a87bd8510741e633b40078ab39ad98979069e1ea586e6fc421093626f06fc3314a2b1b7f7c1f169049ecccc46097f218cb510a32a5e5ee9fa367d1fae79d3f74ffe4be94ff5a336179b593e4840783565e3708ecc264c69313e6749d559a6b4ce08745ce05ea8116467ed5437730f9c178fbde2483424be6fceaa49fc7bcd4b68fc18a63140dd0c1ca45bcf5d7a62dafade1950413b61cb94587756ea5362de32e387b29e613cdafe288651fe00a4dcb548335f8a35549c0ca472575f41e7ba196fa468bd6bf52f56115e8c5e37e6936736fa62f131dc0ed3295586122aa907d8510e047f8dbb18bf2a09876e4189bf61978896d41787ee7a221ae5525f7974163a00aeda509c6ab454f96e4fb9c257f1b59e7629badad54882991f5d363afb916aee0739123ede15a5290fc95f3dab28539e258caf9ebede416bc7792b4e36700ba44f187c86dbd1efa2aa33e042b827a0d5beabd0821c3023ec46763f809b12d5e28aafeb767efc572cdd6d25527f56adcc7c3d798ba903f448242117cd323ebd2a3fbeb1af52ee84b23d818450da7c4432cb337dbf94b15d70e1145193a464184bbcbeb5404fb4a7d925af2705fe21c6c68d6d95fbc79be5c933f4354201330285bade2cf536fbd316d6c3741bfbb67e32d924453485f3c18e77031f889b5b98be15d807f0ff429adf81dba9fc7a3c79f8b7d2e5dc1131d04222738ba253bc83991e3248cceb73b6669059de548c852c523cafea31b81c489ef77c0297cb6d75c0c62286430b7bf55ef9c22845f3e640fba891696a446df85cb3fbceb9e9d4354eb42595030174b42a99d9aa58de455126316f969bec2eb3c5d9d8be9be3c782adceea432f8bc63f2279aaf838b6136092455ef0c531b5d074391f662adc2726d8427af0b5ab760d77988d02940936f0ed5a1504126549717709fc7574dd82e8a202551d21a72b1ca2e13e67e30afdee4e3be21570df0935df9702beeb3e99afab1dda96827eba9b45203becb5310768ee5be713b91a6c83ac616283055719ae18971374db9550cdd263235faac2f212de6456869744a2bbc3fa24a1d8c7d21654cba08927a1cb1f4cbf1c50a8b356ad1d10c957da4acdbff70a0cbf995944ca52e6faec1fefdbdc3fa7b285edfa18328ee80468bd08d257c11aedfd2b3b38c7b36efb0244b5eb8cf7805603fc018c095575a72b62b812bda166c4a3d72e75c6e241a130d2b7e62395673994194dea85bcfe1ffd2fc75cc6461d36a6a3761d20a10d04ecf3a170e6989518f21789ff582490dee79aa154a989e436e7a49e0de5f7638a70e98bbd1551e2e9ad66592a2480575c2eded4c2d776c74336c6ca7b2fbe5ae43b18a5ecae9dd153298251608e617d16bd9f908cb0e726559111264e09644ff78bf1f32df9dd1cd5e976aa3b6f0443081504ff488e8263df3041f69572d58872b2b1e9bad22fc892bb919476fa5d25d85829595beb26a23342f383a39a417cd772844ee05fe7faf1a6080d35a65d2ba4d08164366143f55e61b5b7d83c7ce4732e21f5ef4e40111d08a8e477e156a0e199fce806d8bb343ca7d1324f80a5907abec2c09bd8b2568e4d4a5406dd3b328be95a27f3d0723f78a8b38c65144ca20d0be4522c96aca4e115f71af42144e0288b955cf908fdc9a356067c13bf1f5a1f21f0b316bfb42a5bacb4d952f4445e1db9732b9f8c8aa5ed1b64ba7da5403feeb163759d5c94fc9e243ceca4ab65f9650da00ee53afccabc323959316024d49180fc28c187e561c6797ee681a1d31ae5cdfbcaef2845e231c0df18ab9a5d52d359fb8faf44acb0e6ca09e0a38949401241dd0f134d86624cb829494c47f39e64497e2da9f32d21da6a389347b60d1c383117461bb5798aa2dfd5bb7de2887381971c22f7b9d15ee99f4d1b7f3a5f9a3a6954299a0b1f0f29d3ae71083fc90a5e5af8a48d45710f73066f6f7f9290a8bc826b70fe9a683515e55521a82d3212ba60e855cc9e19ff3d9f894c170bafbbd706152ba6b62ad0ed11ea28854ed5378da1c83229656e56ac8c37d65c9c30feeb5acedf9762560e2af9755ed604cb40cc3c37941b87098b29c728f11cb4e6e27a63935d6fa8b616fa62bd9c26a02d442e1f1b6df6b66a7861ec8f5faa59d2f941f847466bf561aef3ae4124a62e9f8394c83532b3840d54a3fa6e1e082cf799d62d7db7ad3fa3bbf26640b88afca31800f344505ba0886095f52066aa19e405acd7f3b1208791587ca2496bb2df269e978591444581224e6fae54ce3fc9b3a15eefbff40f51d623910fc274fe22a21bc20f3bf101764f520f58dece515f91c2e39395195bfba6e43fc7526e32f32d250f85952f25bfd3ebce4bac2f35e60d39cb94bbfc61598667d2f879d8be0f67b96703b161d49978ca730c6734e948dde3efcff2c9139c88d4abfe6d633eb13c8a434aa4dc780f1067615b4ef44f8960d90cc3ad0a8e2f2e150ed51d406f5f02ab41984a0870634ccb3c8d04cf7a9619677e43979a032b74b8716e772a308161823837b828cae1adbdd1799d628c580497022d536e23c202a8c8c29791d8c50b771616ef86671586c6cff2ae945167e4369262cda013a4b5637ed95f4b5aea3ca8b9b230892392123a717055c020804fd1ca059b57c2fca0106692bfc2faf233af5b3205dbbc13d14b567603cc122ae8bb1c245dc2ca145a19ba21a3ea218bfebe9c0052a84f9b5b6e9f9b133fff89e275a6197ecd8d210c74e012e4fb8091d9905852be27fd4b5125df271fdf6f7abb2ccb9023dd1176301d39cb87e0a007c54ab2ef9bb58eb06ef2076b7ffd69034dfb50b81f5cd1941690a9270aebc77397fd6dd8a7dd9538876fd1eb14cc32246bdc0102fa09e60d2418e34170b709b408373751dfd7b255c38102a60d0436f4340749b90afac787fed6304bac479434158ee47db8812ba0ffa1ceaf1655d1598fc7a15502ec240d35d06de860bad247a64eeaf935db1cef68fe3795f92a323c0d3278bec71827b007d523672c73853a8931ce0c25b9ee1963e9efa75b1ad1df1d5a65939503a0afcf7dd9785cc8412bf5f72cbb3f405f6990b74fcd865d63869f526018a33b957ee26bdcd341d8e7fc68370af301cc6b305f6bfb0cceca008aac85097721cb119c649e59cc6f01ebebc9c8c6fe33eaa433cc52fb2846cf1179ac2701247195115ffc8a4e77635660ebf278516798f66a313ae6e3f4419a0997eda2cec895b8c4966e208c66775b8881b73f2c113bd945cb208f65dbc41189a09b8b1c97a669908897be2865890af3270b4957c28fa2432e54bcc5d4a0f864436b48a5860af13a71d6485820125125c1738001f90f8b1168fd89f9db2fe24a5cdf5aae40c491d7d3f8360d81f9e378737a99fbb240e4f2f4d98663e4e54daae731ad671b2d66f371294cf56c8ccd4526db42145eaffaf92f35d472d4027afd7758fc59c2ef594f68ccea148564660ef87fe3d3e717e657ad24c2e2cec62f8e4bf28b89e3ec9021f87566dfadac69d111425afe9ac22418d79e60230fa9137cf832e15df21b1b9da9357743c6e92acc8ca7c2f6375ce07f27e79a583ec16c2ea6a5b5c93120de8f67b64f7a3f24c5968a647e2a222a15ff7f2877e184093e600c1a141ba08001497fce3888b168e98ba3eb27bd91df5440872157a25dc1378e4ac14c5ad3f649d7171bc85fdb7176bd3a1e0cffb6bb7fb3f0a675a647b9723e5f18491a5114a7d7cd3c04ce5fc5658ba1e9c914d04657112f2841e7d0142c803f52f2b918a773c3abe034b6cc5c3a6e95bf14a87236d5dda45c0014e1b9ada92a116e2a303ca7477200d68270f6be748c7c0312fe998a727074990b576a48d0f8ed9e8aed02b16bd360acb152ebde717d6a5e7d2e85b2e73439e7b6385a1892565465d173e5d48b383bf19ae233b4d70b62df0a10b66c9af577a39765bd8140465aa45339ca406507ebcbadc18992528ec41f40b4710f9035e769231ff2ccb08ac50df259f4c6d94a870aaa9b93d9a3099116be3ba26e55532933e6d63ee336019f80e7eb076ec102a9143e5045da5e08becefb72cb3601036863dc2f6779aabf10310b443ae9be3489b2cae3cdef3369ba84e908e121bb48694bd30b04edc8aab74ad5814ea1ff2043a9bf86f9ed0c0ec7356798ba4001e5e059a509aea085ec35dd57155cfcd18778bc499d49a4607dbd813d2833416c53180ac15508c5642d290861ebdf9d2c39bf845be723b156e5b752ab5f2c032936f7ef72e764671a1ca09c883186021f80ccbbad1f7dcd1a8d4b2af958ca618ec7db340602a18e37783221bd7f3978bbc4e8c36b0cd300cff162ad241da220c326ce6487ae5c14c23aad14dc4bbcb504e6c17d4fea3163c47f7a830a1f0f10e03e300e66a259aae8f52a3c9cfb9c75c20b4a88f3f961afe98612bf793da03ca1e4034a2a9020ccbb0dd9b11b53e3a119cda9517545b8199c09323bc7d66077382661a4aa22d5a6c8ce0729786f058fdef92f903b71d639d39546b668e54b30e25cd6eeec77106e26cf34b3995836c30a8c9df6d303af464d7f6b04a1126c1a74ae0c3e4bb27685b66680bc07df4154b5d5742342316faaa87f42e682e61e08cff8246a17711c05e26abdfb24701424fddddfe9aaaae48d25fd6c421d6008de9abb309c7541318effad58ba2879dfba75637f8cefc3609e1bb62ad393c619f6dfdb8b85c24480a8dbc6c2f9b2b3198a440adb36348788eb988d93f9a47cd41a389019dacac4524f3da6323ecd7771d260811ccf14a3ee3d80758a5a12e08db9440a5a954ec5d765f2d197b5a9c36d8b968c28ea2862602ad55357bfa84660d76fe7f075ffc0ac23e4d19f6427352b79676895e5dd870bad0aa4dd90daec68837979e884c497fcd948dc1e72504ca3cf8e034cf4e72a14690c4541ff181d54e19fadd60055af23e8250b1bb1d65c7a53339387c459e5dbfc6f6f92dff111f56cb524c0bd5f1c44686c20b8caa1fb106578c96da9045aa0e2ae239ac80bc8b48ec2406c432581fb081ebc55201d9c857665a4908240e2d64f488f24531536daf249c5c3ab36eb398c18a03c240233b7b30c3a4ad4d766f2c5e928a54ae94046a47f89f00baa57b6958e6145211363501636beadb6afba20003c9614047d38a050922c8bee7ae07289adec57cca9586df8a00b29f911e6630e0ae27e61d69c3506342a6f431042cb3a521dfd874022db486fafbe66aebbb27e38f6e16a0655d8362d44294769419b21bdade50c34cc39ea9830e48431300401d78eb9143c00aea40f351c9e05d823286829111c196c2e9e9c4bb1879e427f4dec67acf8c899e7bcd4e7361f1254641d14b5af314a283fc495f3d84fb21a6489bbc506cc539716e8023f4884e7fa227a97e5e0c4d1ca6c589be55c470344fb3a1b54982ae12caae14ec027ac9f5f721f544887d1f7760ed7fd6a569a808f652707f75a9e09bfc8bd303556178b667de63a494bd9943c242211564dd2d8d87ca1f2151bf5330311aafd6ab50a6e209dc327cb62be9cf63017a9cd65796eead7480c551a32883d2d3aed5989527515c1762d8cfb340ba1f4fa2e6dd8ebf4eb3e629a22987e55b6fb34aa896716b70e3284fa12ebe5e86c40aa63a5775ff0b7c705730f79f62f4276e0e48a34ca0fc481a17fdc3d91660a89447d1f9eb8d9412d3c669eb92e3615c7bf59dd121203e28b0606343ca3a131e512430a73d1dff617b0990f194329b3cbb0ec3d3e6d87d54a8bb77a5869a4eab56c17c83928814440d78a7b03f4c5747fd18de1c23d204ee649d034e0c999fe5c44b708e02c0dd938f9316b80f06801b30d982fa78aacbc97d5f968bdfd6a6af4eb7efb6ba650b770da5e5db9a3e2959b19a398e9cb5eaa9b3bf95904410db530617887bf39a9b641ec0220879be5465e5598fe98ce9b6b326388879cedb9f178871e0a30c72dfb7f0df3e3f1fb35c1cf17933c26df7caf287a15096f0cfb87505dca2efbae82236e2aecfbf94783ec84268b344e87fe6cdc9ad2ee3768a6340b097a2c24574162f0ed38343af6245d0ce3fcae36afa6e988b8a63a4615dc98126be451a729884e6f46d2c22b27d396c2c31954e0dc697a578a7ec3321a29afda6cb1a7bdb9bae5d2451fcc0f34cfa10fc2f2a9380bbec8b62eab0cd24d88406fed238e7b77fb7367406dc757ba43f024ee607cc8c58b82ce65f8cfe3570733c45694875037152a335d9f0d0fa4ccdf3ed1e9e7407e58a8b17c87704740c77be5273ac0246caee9f54679cc87b96beadfe3f4cf0280ddbd72e890d3ff8ef2ade416523daf3b61a068421c7eeb082d82e5b1a0971c1af3b9d54f18bb5d8dd95bff2e69e911d8cd49b0a69a10687f46b918b781bd0c57a39fb0fc87c8a56c58e9675694eac681ac3c94f6529575ab5f44cbf1b3a704bab54e0b3a328b3a589186cdb0b5cb62c0663de859a3847da46c79c0a8bb7566d8c33f9d91f29cb7da206831e0b20c56ec52a81c5bd471135582e5e7e56fa28f12d2d1f8a41a639ff7cd8d22bd6a61b3642742a4613e19421a21a9b39372ad558fac0d126fab1048c8911230410a5fcc9f0180595f993cdc92fe453aabf257391a407b768d12b050a1ea4ed190cc2d3ca36675095d9807f870d24f860b2d65a1fa7a39a46509372a59b308f3a86a11700b66c6da65607577aa7f407f17ebad87ceab77b082148cd59c105bfbc6479bd7b497dab232e6c7235cb0637fe173c61618b1a0f69379438990719623a2f2324ea18fff71f02d1f8dcdbd4a55068cf9afb83d5a752b0afa732e97a99ecfab6637668830a96afe4c44973b3b5a9f64c5391f53cc72db69268975468397395fe2546021c543fe9ee24a2e6320d8a2a194f054ace70dac66895b507a72e4ede45fbe507c0ae5569d608346b42b094b200658b84f7cc5ad7eba8a375c314e4ca695d40519308ac282fb7e732283c02e45a4b5ca27ae5994db6608cd32698670b0156352df0dd57d230535ec4c4598f2e5d17579ee1b658419513727d19e6181ce478fd9ecbdb569831c8f54bb1d7addb7c0adddf18d5729f569e462a37062215894ed788c49ee8231ff2477664537fa272053c83f54ab3b8fbde1ca3f1c700d3e9e0a1bd9a4da6696572976a6240b843e4366fcac25d236e02e4d2b1fe33c2b752931c216bff559d9b68cbc76c03f39c240ffbed046865c2fbb60bbcc56dbf76f2a99cd5e090db89bf2e0fa9899c4839dc74515958730da97f4c602b9bf8a79f0436d67e861cbab18170037421fc5be1f285efff66af4fd897871c324156f589c72e806123df8954aa78bfba1e644263ff44b5ca006f6f65ecc2bb10f696fa1e17295f320d5a3dfa19526910b452e71756169d73e74110551ab0bf980fed6c3f53ecdce005513027e7f3375c28a3e1c4d880d0732d6cd484a76ca1331536dd909f77d22372c548e656c22b7479345bf07f245d86a7f0c72e6d3c11ed088af1c8f0f268733743ceb924b53d9d8620a70344a460614dfd2f1117407b6e70c597d26ee4dbd6c964626affa0b0be0d3201c5974fbc2670f939cb9c74ed85043ff71193ad31b58809db1f6aee3550ac42403fe9bbb6f18d0fa1acdb6a6da6729385eac0106be375973ab51433bd408955cf59e827f096fee3ca38101ff2fecb9a0e7c8cea526367fb31b355aa947fdb03edcf0eb0e49a39fc1af50124397f03e0f3a09c12f833175a075fa2357eb224ec6e3f3e4ef081750e7a2c5684b90b5b64fd33aa69b4579ea792a6d5313388667bc5c787aa7872fd3ea0a656ff24ce3a256644cf02cbe0e57c3e6b5a39cd722ea79142aabd82cf22dd89ae682705f325b4a71a663207e34092c7647c2d714e997ad0edf0cfb0bcefabbe31a017954712536bd07028eb91d71c54381a304a722167e3aac3a724ffccbc27214c818ab7c946aff93c7b9abbad50c3577545c70bd36665b3a7b3d6a78d4510fedfc840aa58c2052a03464fd71ddbaafb6c6161698c506996d1826439e333704ee9e584b004f5664233e20c1e4f75eccd70b0957d1ebf1ac616f0aaec0a68d7769704dd7decac6d1f260a0e6f760f13915dbff9786280c45030f380f43e7a8276adcf075b3c3d16ac9647d2ce1bc206c65896252792d638000b6189d6df98f1d1948c7a31938d843715841236e44589a4431335a82867a343e11b890b0a5f7a8e19d2d0ad28a5991db69122c542366ffbd42e9acd769b2ef555adb2f720f38e0d69fb4473a0353a577b02db16167674503688501b3dd858a5ab330548f3c175501b0e8f7ddf611355cbf24184d4d04ab1d1a024fce11b62a6a429a3e618896fc15a0a6df591b428e9f951ee8d66c2a57970b0dd928f9ba5f467b451e07076c15ee22bb2675293088b4a969c7bf40fa80231753a3bbe891c2bd8d31a09f8d49067eba4048cb0ecafcb5b38107d1024f12fe7226267ee9640a54ceddcd955510a7281a989f0899572104383448c83195cd0b0e2b2acc5cdece0af831f8c4a1b42ea0af0658ed75c0f7e809e6ae0599296476d4b54bb0e56abb89833756a722e802bfab6461502100ce88e3402c811190b7f177d4e25988f4f961b4bc68d2860c16579dfbbb3d2e70a3b94daef870bf5a3d71a7787242e53342c7e003f37a5e56f1620840b4b411ae04de3286ad3a87259ffde31eb597cd5bbc52bc21b1e66568ffc4be1376086106bf07fffdd868bf4f1621582effbc809b064cea78fcad2085e63dd2d48c81e05985623dc79a424034cc5d7d36b8bc03047bd8aec1220e56c864984ab1233a250430fd9b3b776f68a47349fb3ee4dfccf5015905c09e8000fee13a16ce84764d168ffa8b187e32dcb9d60194e5acd6df048505950670eacf651d600c3e7b62a40fb97f039713942f9e341a3bf903da5c266bc34412e959aa230bc49e053d1d61cdea6d8b6dd624b33114f43537a0c2d701b538975017fc8e6397150370b2457b0ddc5e008048cf288db21c91d1c4fece18b60bddc840b370d7c14ba5032236cd3d0679f64f033b2fe1657e40d9136102d892cd9152e8f72f657b4dee5c7fe50dd3ad73c0646ef3450d3ac03abac0809f870fbb64a5cec6cdf29db8b9cc617a2b81254cb0afb460b3508bbc93e1d73dfaf2980e56f7380cad569343e64b58db6fb742f0551ea5443a4a4329af791318858c4d9ea0be4f0b4680ce32bac9becd672b3aeb4620852d48292894fbdd0aec672a2e64f8bf273a15be995edfb9a60e56f88920c815173c503373f4cf0030b15a25b8301649d3e6cf48f6c8c37e04424f453fcb2958aff2b2588743cc9d6f95024bf1c89308e174ceb2172f7585a89f5f01651b4c79c46a509853170fc1db13b435a47b2fba9c22ac4d81698a5b1c64af859e996b23d48959bc24d8f798e2c79dd5db532f48c0d53fd60582aa481efaf3e27b2125a6c124a24e7569def611cac099ddca8f497034ea1f77e215507714fd352134999fd3bc86777ed931b3592707c4ed5baa58567453d4a58c760c8f04aed79ef132dcb54b4c0f9e0892dda7e0f1e719646c5523b1fdfcfb8d12ece6a0ba59ea2f705069dedf3a678e9db37fa8aa0bc21c931c3f34c2e9bf4b53ed1d36e82727b461e43256c7c104235e481aa2123301efa5c1157a383d3a38021bf73c6fa70e3e5b481f99f78edb5475daaebaa2985e8c74450e47a615466c3f8e8792bc3120745c4b322e2ae7fbad0bd1f4c4a0e9d7b370087dfe79df58c5d49c4bf62d0a0013917ec7b82777742947ae8f0a18584732d6bf9c3247b23a34297c3048a054df4b5a94883563cdb55ad25fc7752aff52defd0e6168b96416b7b2854d4cd04569815ae8263f6b6f9db2d55c18d7d075d20058abef7c69f6b76b4d234ffc9de9b257890fc07ac517641526f9d88b6c3e13eaca202bd3fc4508a4046835546e68b30063e2f176a2c00a0c34c5d66371f69120ce0a12d81951b97286ca802ac3e77b5531d407de153fa51a04f296f0787a9e43fd940f8ded1247a2770f14f541bb0baf1271b1cd262c05b301199c86852060267ec4f7384821076dccecc6e38acb893703f742167a0afe340a9bdfa6ee31b465e18ba77d4b5144e74b96bb8fbe694d8c17ecd0868dfeb65f031f4217551a4c92e5f7f85dc26a4a2bdd93532d10bef90681009aee4cd0f9b46d5d2d34529fa4a0ef09c43dc12a1bf52010c5efc2c703a87d5e2ddaa1fe3ee39ae3067b6029be6b663b1636c875281dcbff5d73b27d620f7eeb2954dfc90286a3e1749cbb4285d90d728f9c13d56b2bf13fe8cff744db14006dd95685616d6d0808dbaab0e846824c51785df89cf84430fdefc78d42eb0dbec4e28c9170589a89df0307b99ebf831128e3ddeac6bcacad9b3ffe1fad2d797ecabc3cdab51fb8ddab04d77d8f4c9d045cf099d43e918b2ecf3564eb378c1047a7428eb5fc84125d1cd21194d7e7af3794132430168fdd22e7d459969154cf330a7dbfeb30a9d45aee3eea566c00da1568c460becf0be38cdbc24928a7ffa0d3f7c95896f112567d56dfc976849de72a6d0f35ba97e629203234e0673a257b30c2188cbf29d3bc7e12b1e7780ae6f1e9e44704027b4b1b5ee9e8b1828ea4caab5b04918e6ddffac3a0aa8fbf6d13495281f42000583c0f3047d94beb810be6585730b68600bab1c6c7e86fdfd6003fd5a14a77789e511677c9f84e10be00420d64b4a9d7d6860c15178afb233ed04e5a5f10b692a466c4ada962b957e156603f4c35e11a691c5f7688d40bfe1e7465b2bbf1bc8f05178607a10e79c8f065190073e3ca78678d6bcae4c8b988909769b710942b1e73cf520d08f79048d92d1e0b5bf6ecbea5082b84b5210eb1babac9bf3f07b27813e65f5008717998be5a2c3f625b4cd8f7a178fd3046ae4ab2c394b89ed516aace6968a51a09dc6996a98baa8b5da2224f5476c30e2280e95f49f3eda50d5a079333dddafd1988357b413aa097d84d3c2c954ef92e1719d570e06dd114f0d47eaa3b4d42de2427c2eca958c04f692084e2e9df13292b5af43189de971250040e276939049d0f6c91fbeedd7aa3356cdfc5d136375ce10f541b9177852da10c7045768fe406e1e5c53e626559579181d68efebd0b62a64dbde738f433bdf1338d509ece0d39dcaa09c4c67c6aff3bb4bc9c93d8045a7afbb9125bbbc74eee17451bed717af9dd95340955fe903c130b88dc790e8204407b1bd6b1ce17bf6d4aead4b498932164ca60936bb297549b2c6767924bd18ac2ae94f7f46667b1a329d346a8ee3811d0eaed06b9cce838c8ac66063af1de1e5b74fdb268a54e0e53b05b011bb5bb3c9e19d361d5289b8049fa572da476780df76328afca14de9581b8e3a4653e90546ad5fa71f0c40cba17428ab563ab269249eec82f749be0462ec32084bbe1d8eb2c21ebba6e6e8d174b40b4c9144449411b161f39f41f514f59476765b9a28f9042a1f6a17ecb801deae3300c1ded9b01b6e5abcbf1d3302e6a775c4d73bd9e7734a24b53af028a6869e3ff4f4aea4cca791758e34681e6548ddf1579b30d096445c3ab66dddf0564cc9e4ddac2b258a384a16e3355dfa7e344380086c98312bf78bfc5d1a3d3241937a90fa53481aa1d179382af84939b62d267486cd2dd97e537b842ccf3b5dcc6c8335515e51917bab13d67345b1cf9f5ecb7c49c851ed3cbd4d2594222e7c76421efbad0b15b07136a24047e1cdf903bce42fecd4d7cd3833040b70589e780d825d1cea2631143a848a894293264ed91ca07040d62acd9f09e5b5a1492b76f07065c71482830e58ce52b49d2becec04abaf6b28b34d3eddc551e1812fd20e3cdb987e512c8998b26b861ad2f92e41cfd49b1165335516ff4ae4bfc9f5cf289da4ed469f1481a837f9cd4099b815a68a92877c635b79d99e7b221030e706153062a5010089581c0cb8dee9adc5c534726cef2ea8a4ea66ec806345f5433d22057eab846ccc6e55b58a1de2aeae92e783f694ac02634cc9897d618b31275a190700d7c72f77a10aaa2b541e5b1c85198a80752025177be7eda9a65650ddbbc2ebc6f0ee9de4893cc821ce31f75c4136498d833a087f42d7ee172d00d6c9449a58f8df702e2edf9c90937a8794d6ac0caa1c0e754c6b625d6dc7461e7249bc7b648b6ba1a89733866d6aa54bf1c41e76c587ebab8b9480e9adc2639524fc9ffef196ae09b05d93f149474431cfb282266b50141a344ec8e73f944c07a25df31c4909142b696a6fbe371bb8374a74d461299a57b9d4eed2dc3128dc0541f7293c4a381b483a133c09f9818a009c6dd942582480f718927b1d834cc4ff60fb68df19e7031adb37989c29ff8348b00751bbaffb868856ab500570b4863043abc264bd9a873a18b0942af51b1440c4318bf46fb3184eb4b065e2c82bec769659e0468aa3f3eec8437337035e1cef85116541dbc37efbd0879a8dfcf98ddadf1938f05888b35bc33e14e1df8d902ceabaa52fab5814ca5698633e6e8ce1688887a8eb978447e9ba661632d54a3f7784c84fb9c7e773dc6d00d5b3d0e3d879f40709303ab32f5e59eccfb9aeb9841e1946dfa6687a32d89da9a14eed26ebc085d0c2ad3e326c0757e337fd211473aef6f1f52a297a7a2a2f898b57c05e2e811688a955cb043be6c582ec5cdb2a4aa920fba591906c857df2be8d8654644da1f4a5ba3225fe3464d72ee6156e3979f4275a5491bffea87f34d580ac388481dcb8c4a9adea19326614b280b06557cda8f0c7ae7b399443f1b993e00604879d0b10226af1160416e0669b8bbff1ccaf06725460ec2d090de9f22982da81c8cd114ca5a6e5b6269d19e94f84c554dc8ca6cafbce7432e3e62961d312e44fdda2a2194ce353090dd11618d55b2d9fa69a4f7fa5ddb56cfd57488e49e3a72129d3fe41cda8338f667595458c28d18429faaba8e17190280350fcb3fee72e8d1b6382c884bc5c5a734d2f4bc2881ec8786ee52761e8526b4e8f18ad95721dad92a288c6e9d109dee374edbfd0eb56f01b5712fc90109056b50da1f48daf95e9935f4e382832cd2f6044ecdb1c7c34274127395787b77576090eac3243bed620f9685c4972631b26e02d9254110fab5374cced1dcc6c8a6aa16813342e1b973d177271b476583e623d23982a6949b216fe1605089441c7b17614cf9c54f629ba241d26e5abea08375b2426eb4fd82024ec97e881eaecf00703803811d428a51b144aaf3f4ea059856b813a8818a9cf0121ca713bde00603f15a3b0a13398d9853764ec2bd19484b85f1bf85bf6073ba78e64f77154922ec8622aed3eb946c26ecec43918f3a703a00de38d843a332faa0b952a17773c4b53760a5f0b5f05c05246cf9851a9657c7683a6fc192c0378658d4c65041d41405bb627b2035fa683cd764070af0cfa4e48a9a0d8db3bef2efe76424732b1856ed407268aab564dfb2dfe434bcf22a0e0f4543c8a6b4e4b830df63cb5dd30f4df7125f7c1488c29c0ae200548a92e0454c009df0cce937aecbb3c18a66cb144ec8cfe943bdee1768872ff619d2ae80c6c136229424815dcdc6d58bfcac5d745b635e3fb80e9a31c6ea7a79b593e60409c0153cf1941bd5567dd0812cc6aaa1a9c607ee4ac3f08a6e593795edd7e65f70b6f2bddd808e414849729631434adef2cec9d6cc530282bb9773bd6996e6b44be42c08ebbcb5ec0a58400bce13253f70edcb23004c8a9386d662212ec049d01dcc3485c8498b7af395946af8f6e86dab6b7d00240de5e31fec2a9eadc0587db4b9eaabed34069338238983906ef411dc06fe7e209971e8c2dc1fd62ace8e9adf603cc772dea77ab7972bcbc1f2ae3ec8a6983d1503d42659e8ab59a966de8774b4bb7cfddd293fa9c9f76714d13d05591a14e3bea4c102bab1fd6c08fef75fdcbf277b83d56524cdbfc739835c7c7203df97eb271b6777a47c3710cccfe309862287020545e5d07e57540b0907b858dd7a67450db733c905f72186d40b1570b40b91af341d12e465fff0b1ac7336ad7601028be96b5104a623cf1b8c0f43e0f838a7d0eea51c18cd3eae5d79716dcebe66ac2e08262be98f62081ba4ebf98ecb91c270648ce608e9451e3d4670f13e27c5c9e85b02b56362baa667359b684ae1cf5031fb618e6b6bba2fc0ca30f435a06204a20f457d460b0b59b9fc7260621ec2276a77294a160f1e351b9618ff7d51b823687bf6aead92ff669413132bf095c6c37b519d58d730934a8b25d523da24d8a3d1e3e8774a81e975bf6282770b1a8d0bf1c1258131e5939c425128a0e396a191da946c1f3691fb99db33830334752f94bed83e52ba14161a7f102a9b53f594858b0475c63eebde380d625b84998937b4ac2c38ea8faecefdb17374cf217fbfa7ac5b685ff6ccb254feb2de5f6fd0e1b619f6148715442b234545ba2f1f67527fa204fcfcac4a229046e41054c8f0a810f1c771d8f013f32df4d51272d54ddf828399aed6106de2bb8bb8a441507fbeb4ac6fc7fe9af9da3440508f6f9a90a378d6cf86ccd5292c3315d9b5258919a179e38590d8f57c984808e703faaafa812e15b4ea102e48c496e86ef8d65e89ecc26fe07fa7715375c6a0235994bca34900345068b21d3555f7dc1b9ff51dabf56d7048d5b3a5f1ee4b6a1011bbfe7218cf0a6c88b3a893522b268cacf345b8fb62754b37a3fc5d5524dcaf4a44c93fb482f6a9a76e6ebd220d330f70bbefb37cfb43622a25c8d074d7e34628a0aa97b54bc74307006c856e4ad75a93ed2e45b70999470e210bdc725b9f3ae7e5016f1b15ac27ff7ee8eed7fb4cc28e2bc9fa820ad956794158b5e0250daf79cfbe16cc8fe6e0baa6c2a30948b980bcf4cf8e6144330d6fb5d6ca202d93482b8566103bcec3dc8c740073fba06e704d499b1efc4341ab3d724cd56651d9acee2357146be7dc1596d79d28ce9e72c48a4ba1f5baf538687fee82455f32acdaf826bcf14fa3affecb9dce3a7d26198779605db7991582ba345d7fe9c89749db54ae8994a7cfb4efc3ae3faf558fc30b0546f735280f3598cbcd91444715b8fa24cb11fc716fd0decc6cb89d5b71132454f8e7612616a410ef3bed0cd4f6ef310173573c17d56f154e5d05382a3d940b833938ee66dac8652de7e0827e6f69fd3fb49e1d3a4a057d22a9c703bdb7f5e5bde3ae7d4724e01dc1a3971eaa0ea40d4c43545bf142bf3ce36411a19234ab03be1dea542ee1e911554b1e30bfaff7eed2653dba826e4f40e60f1d2041bf3a578d3eabb780bb19336cc5d305161231c727d87a25196afee5bd1c1b6145d64808bfe4ac46f7c0edae254f923ca96a4c09f80e2bd6b419ccd8c7c9eb7d4d61b977ec5f9755e846e3bf7a1dd23a0b248d8b04912f9693e46c5ea3be7533ce983f48e1d7c6fe4c581d87e893e9d45bcc701bd970b7b717461eed1f16ffd911eb2ed90fdabf09e4e6739ed64370e7f99d7226661c21eb32e932cf6feb1bd605abe91cf8b4170c93b7f382aabecade3070157e5dc0f7b131bf62c5200b2d37d6d49e0711f6413cf5a10d6e291c3f8f68ad3857bd26fb6c43a530e0af3bb867d043bbfcd3fa2b595b26fdb2df906b07df1c0bff54b78871ac8c586b92d1a7012fbe740d0e13e3e5f86b427717c105dd4a2a608275d758153b66ccd430809a62f07f73276a473c4efe53eb70ae2ba46ced7222fe2ae6eb6d19fc3011e1d70b8063bf908d8c5b693bd78714a3ed97ac486c7e8ed1ed0317e04d9223edc7b2fe98e9f5647cc316c77b9f169e1babf2d7f52f01565e3b352616adfa54d79a242137e31e8ae26af789987f1caa58f3e31379b6520e2f4d6550167cf26eb534df4e638f368abf84d5d1e3346d5191929ac9cf6058026f761e46d4035789ca92a7a4bdc111f4a29037e6d50a3a0d538be9e6a35dc56cd89e7791fb279f6f2e4903ccec63a355f5e8aa4c68a8ae9b689c35f4875f371d5a344991f2e6622b8fae31e7439d77bcebc2c9d7d410231f863e1bdc59a5296b5235e62ef94ef0eaf9c4add8b0421a031a9ff892b935c99ca416b9b65cd3822135169d5f0c5b80f017e8e8724d484667a7c0a66049d643793d2be12da28196cc53ec0cfac06643c445336802bff9fdf2b890b08bbcc1b31b21f337c20c015b5ab9301ec712598d44f22b19a697c3f4550fe885e70778567d19f6acfcc1db4da109cffb2efc3dd4d6b04ba877a7aa76030ad809f71b9ad975a6e12f0bdfa782e785604e92dcf938cc3642f036f667bd47b560039b272a250e2db3cbcb09b025d6fc2b4562bb34704e350874ea5db61f8d523997181e85bcd416af0978b5295a025e4433783764fe715ce4f8cdef7cf2c8bbdc9fb508e01d68bc67081d3e27125768b81a9ec675c49bb3ac6a63ab055f51b2bbcb0c3450db8816211c72670a5c91283aa5e2c65c85075bc29f69fc7d63bb7dc2d3f89169b32072bd6b0533d6811b969fafeb178216b4f024a9205d685fc7cc8a948d4ffaf149568d511e166becbb0ca9528b99f55f61e81f2b78c1b59afa493a43e2db66bae55568eff827695bcced399092f821095a7286cf2fb20858544f5fd8f53ad2f33faf8054589041e7a306586a0b50c602c2daf49bc221fcba163860d3f8dfc10e5738d204dc84b2950946c33e7260ab92f8c0cf7ec6873b3489f53fff427747039bfe58b6ac0be9647401f35075323637390c27e902dc5dfefc9587db0c0ababb5c9eeb15c6477ba193439054860321ab6fc346180f4f80a404321c48e2bc7f9d59a9d4a15abdce15a74fb7944298089b0357d3e5cdb0da637be70a62050c127389db409689044775638211c5690bd4de40139c3f24a6445716f7e744ad507fcdd49f6e18a2cb5bce374821f520a90b8ff037260f9f86a08bc573d39231b09144b4aacd987cdeb1907f7e35000346234b5f85f639c6a7822cec27f7e3528d123db0fc744be7365d85e84566d74aec1241bc17c0bea97c23dbd7bbdbff93840d3c1bfc08cea295010e1b10616bbfc8afc969689cb169cfcfca7e684233f687adaa3ea429131589db980c69b169d28a76bbfd80fbdd30b71227f1af5fa5535be75a83679b8c3205bc060a6b39746a6b39ff9965e7c6b79f95f5264aa5fe209f9083a063746317b0ac122f1502153741bff53a114e70fece975e4fe87c19a24d46b064c6e6fb5f4b1d934079ea173482089528ecf383be284d86b43838e93bfe9a6f78f307c729573127116bd82dbf4729d70d9bcc20386857b163315de682dbe7ad18d515494ddff3b13b1b81a42d60629668fb530c600f1b4026fd2197790c13a9d0bf91100e4af57425a32f5c72e97a3f7fc3e2bf06f52d2b86cc51fd230c8910e49c8bb455fb4868a325b8bf0afcd5a6c86f110b839f51db8e33f850ac8b15d9772bd2a6837161c46facb7f7d97f0987e677ddd4edb5ec3a4513898d67b5652e6769033bb9000b2005c663ee6b9c562836b38f8b57bc799c3f3969e1dd4d67b302c855e036e0d5db9f501a22197d482595e83edb2c65f4679d8b9515a94feecd6d98e6b947f3f41c691278cc879f8712f6b1c072b937efe0613281570a6fef1335bf6663ac6158b49ac9b5c9c40ce5063f3bd87404f2c408865c0c0771b58bbb647594eaebe5bb062831ca8d2f064d4618201c00833a8997ffeb4f945e25c3982240684c47e66c3f290ce36d572c56da97f526ce7c5e0cf390bcb25deb0ecc600aad990286249d8f0f72ed4363643d75c608cec8f91ea72601335ef3895e89cf6732b8c696529e4bf89eb9033f92402b0c101370d28796b5ea65bc9c3c95146e9e3850e5ef98786ca00b65ece73ab52f9d3708167082bfa6c842b9f9299f744a624a686fa304c292886221cc490d6e91200abf71e42c8aab147993bba1b6083f99da77566fb4269cf59d12e6c1f7c7f0d002c1bc6a9ba0fcf131a59a72448b42147ff169838fa97f90ff5bf0f86f105f49566ff2fe1bf611a0c814eeff98db3a981bad5670e28559a017e31b9abedec4d29be0a1f5ea22c1e32522d5bf7e7e8d18a58961dad599b085d3d2b9f4630fd8d1ac4d293f7e947cac459d4b887a06297793bd121002a3217010a4d74caf5e93b0da11182239b1564feb815b1dc474b0a11b8c240a7e5b3f7ced006982524630240837c5a93f1d31297cc35275b4cb74ec36d8f98c131e7c8e91b761ad5ae6f5355aaa3d2e5593b522a6b2287f9683376c3edc39b1108342f1e3347d189095006096d3a11efb3f214533db95ca686b86d7d24be6428015d6f205c44e8cc5b99c0262539950c2cc9c5ee46537056f2efc64cc12f81f906636f2ad01a117c37507ecfc7468bcc721795a4a1f9f96a2f6ec04126f5404727231f9724413c6a6a46c39720a888e23189874e9bcd8486c7539c5e6c1849a931847ac2f8de5a6381ce65e5a657b58c8ba7921dff813b1ca52d2545bd6fd7375e18160ce497bff4a2feb9d6d4191c9c93e2b5d069cf88471164eedb78ef557529a8b97b2bea9ae05a9342330b8ecdd7d5f9f3b55e3b34d6f8e4f8832d15b4a3dcd424dee552393c77a412c297c4dcc93ec7bfd1629219d24a2b4c7e16353d61a0e2de0aa1b834054d67e7cf9e6e8e80e67779388aeb747066e0e7e97423262445d03e8e8e64998342cff14fc6d83fbed8423a577065db276bff48913e479b5c077fafed8ab156badde0fb318d7be9cbeac4533baa12dafabea04a7e7555eec27ef643ad3ab56aebe030c3233195d8a6e9362acd04c928741a3203f97349bbc11cf71a0f3a00062ea53ae672e626bf691e9e073d18a556274611eb2be4dc4ef20bf0160ac6e4a79303c3ce026fddd73a8c855ddff36f2ed74d0a74549f4e8fda5a938891ba559001997c1432c5d21164b2dd5db8e725a08eeeaa5472fea8e481ffa1791ec9fa47a076f0c8cf860c52d65db33a6f4b0bb1de035c5dfabc011fe3faa4cef764d6f6e9764aa33f1f1ffd9112998f562966197afc5b33f1efdc4c144b96a3e1949d61965f3230f04cbb8e6de2dfe2d24902e63100927c245e4b3311910922756fc4fe4b6c6cc7bd858d5af90c265a5dee6d5431d75acd909bcae0958acb7bfd30b3f44d8b5edb8a8fd98adfc92d77ee1522e27aebf2d6ca81dd7d8bf921707b8d7bedeacf936245c2d5a7b801e4dc0d3482d71fd79ecdbc054079760aa754274ee0f36b7bb3e752f13e48e8d20a49a4e1dc499ea82f931642524ee85bbfbb71924e36046c484c9f6547041b0f72c09cbc08af1508238c77f8bc55f6cd16177be4ce1092b77c5e7da861c823d57f859728759125b7ee8d27f9357b70b17936ec4f1d871678a6d1c91be924e7d8749e3d31af5e6cf71cb176c53bb6459d4d71f13f4769eefb1ab2a7f1343f3bf031f896f9f03651d066d7384ba2606387d32116d1a0ad8c88815f39ee587f1159d1e529c9b8bd8be3af952af7858f5d96da91f751b220a0605d0bf0f4e479cc795026775caeaebdbefd8d2c2d03865b85dcad497204974ef2e1fa7047512d74df656631c6921d113f8a376419d7fb4b4c5a7d18f65b21132ac9606308dbd2d1c4ca7d0966138e1a1e3c1593f9283534f30fdab826390a4dd29711b173faf08b5dcb6827e82bf80667e06c5e2d4830552e0e74fb19e6e065cb02d8d947cf73c821ec499f37644cf22f0616d17c4f02927e7e2c0872c02467632d0b19038d8e3d9db389e13f3faeaad0444b02d389374102d0cff59e8aae8182781d6f83535835506569f5a375dc4510878485a39cc74877b74b6524b3f44075b5fc048e37951604393675cff00a33f99449d8d735115f7e1e3c12e8b60e6a348209b6f716263ac837474bd48fe7ca88184c695e6a79939e9512387cb821605116d27eac98c6aaa46e08e4991245f78865ec7cd2b79eb8b461e6c65b1cf7f9edf222e6c98b8f72feccac503be53580b055acf4adb787e81ab7f37cf72068bb3b5b83cf144a3b73759b6e760dfe33028a8f29e1ef5e727b9bf24345bac2fd8d4f977f8607ec2e8a4bed7160afca320d0fb7e1a4544f31e92a96011387549bdc0cd3a38cb89bb0837d88596f1c44780929f8c5ac334c837d9da1e3791e81cf96f6d561b2cfcfa2845cd6450f5e1f701c9f01c1b5b3a79a21729849cd16a1b8b0cbf63ac443b44e82466530a78f37118defef32176aa333d7e29b8387eff06c3850d332e2246954dba534ac159b0da6d5506d7054f25645b06e4afa72e135af13c83a1331b34a4f4712c3b32afc9a3cfb797218a936ff84a336b9d50dc5122358a91cb82d34f55ca41e58cf61258d43a1c701ae6237ca181b25098a2cb1ee19bb8e7c51cd38c1bf14422daf9b38972b814cc952a70620621fea3f7faf66eb72a46285b69a9d018d3977bd0ce014e0fb827e5f872ee9f779ecbc87c3c5bc398a4014c7d1390004be60761c0da7780c74aa612faa779e42e21ea5bb26e92af4556903fa290f93498ef3ee60dac219d428d9e09acfee5af2e282493a4238be68b97e121e27cf3e3f26ab7e92d2d350d6fe2a46e61984d91af597d419b539ac21d5f32b1667c45d81e1a769979bf29b870a03d3abd78359a4173bd1c169fd637f8548ccd5b7a6e31711e6f1e0fdab35cef2696a85775a1e313df700cc70eda281067c8fd9c4777edf4937bbd6b9c0f54f033102007f72333bb86b3ac154aa30acef0690e7d77e60c6f85c7359db2e568bca75129b82d379b2fb5c1ab74d7ce5c8af94f1785e7a1d1b96b81bb0ac20f752ba240a85812efb610cc20208e9d76d8e1ce46243ba0ea320d7032dcb741d99113cfc989049e8837d970dd277ed4c09774f71d3549e36e4a514e07c7046d7e4128fb0b968d383b1c5302ef9403c5614f3f2640aa8bfcc42fc04e00fdf6c0223325717f10a596700d33e4492da0c069196df9b22d7378ea03744b07c85105446cdae2387a05117ddf4b4711b0eeef3caa674d09cfeb8954c31a29cb8776d73278e8e316e14dbed4c52bcd78683b82ee8418ed5563e7084ed5def5713fb0641211675981f7b29b01f31221e4958b23007133fbb062b8313d9f0517bfe222bf13189764df4d69859a3b9a887d306891caa5238f3b66c8b538010ad7bce058d34185a6e7b6c8d17cd754a75fa4903d4aaf360c8f5eaef550679403faf1ffbf33dc40a26e0985f04d6824451e653862bcc9ec8a1f42a0b1465da6bdafb8b75d7cc330c65a6a9c26d493470c85be8cde9b8e9ed289650c34cd05c78f6acb23cce855c3b4caf97a76efb5734db3ec3a10cacea746a00bcfaecddfcc0be35308d5034f42bd239432dd219008945c3fef1c919d90fc28e4f17082a2a5f6b984d31e9777124e5e9585e7351b254f9c233cde300e56f194cf3d8be196ca1f7319bdb6591133f12bd704370860b6460f7b70e44b9371b063923ef2238297e8242cafe1881d7a9923d2915709b7162686a743ed62af9e8035ca06f138ec45ca8d49c4b1c7100b06d7a53537ce78d233c9e8af1e8cbe43d9a14df673d5256072bd104504b8e0720142016224399e7b330cdd5add526684aa91533b6233eb4a83eb402b8460c788312bba938914caca96d1c7e43ca23a7ba50d17e9edd828ac07ec4a5dc348f0d5cde493f7ad3d387b359609f9c28612fc703ef56684752424557d0e9900f97d41a410f739c9382416b71251ab155cc455051c6058b475651f63a34b7c5c25e5ece84d446efefff00a2c2cb4a23072355898034d0fb4f7d2b69c0dfc1bf106e5b1b74c165cec90703f8601cd80e3dcf9c584464a17e46cd84db37974a01e49acdc7303c0f4a3efc1a44ecc41fff2a91acbf96f39aaa62615b7f8a213429322c012c340b01d0e7deb4ff8e2c932ce1a15c811ab50366b3616828d7be086407436a1b69b2fded5a6431199a771875a44f28c50ec1a5a5f5a5605d3b64219a4d66858d0cf7e3bc0ee574dcc4f7b11e4a54ff110e43c2a0dd1820caf4d0dc3596b0c77dd025ef92da59e081e4bde95ad3d77061388f28bf93f75d4fa3e9381b78b63c5b82c8401384f3361a6d6a641e49c28e8fcdb8531535773c2e98e4c5dde0ce23c88e927e01a1861c360331fc6758ad8c25c2803aa97be6d86f4da61c0e6e8bcf98ecaa3ff2ed0515d4a87d631ccbbe0ddacf85358569fb38e19653f77fc44d5576b71b68264addc525be55efc6bab4bcda47fe7c37e591f4fb329bc891099835fe751ab4dfa97268e399dc9421eb03e15f9994bb8ba260a4c3e0ba499d9ba65b2c897862654aab91c40c3dc33ee07e120f06019b374f6917f652c66b0382c5c97467fc8770bfc61bbc75477b871c879cf77bd79f7daa406806e75dc11d43902fdb3bee7a1ddc11d7e4498c0f5483b4322e0f93fe479c8ae8452e8f43f4e4c9c7d02e086add46ae2911d1ce67d39f6acca98677b2a85c7f93aaf14493fd485ad89336272679464827fdafb892289582fa1ae66577961631fefd84655544d00af6610267bc661ece0666a8858d192df847154aaa2729755558e2e5fb21ac9ebd1cc477a847d44a8585d9158d44777d30233843bd540dbbdd686745214f506ab67d58a7c201d2f60f64dac7f7bf8af85ea9fccba58557c0023d4dcd464f7139108529a658904ddc6ef4527b7b3ce81e14b831a325c7faa2f9fb9a12fde465e515427091a7cee6303a79f9119cccb4f68ee517898c00f987e1197844c5e923892fadc5dfb6f0596fecb289fe6a01f6f41834ab8c6f344e635284797d1dd8dd2af6b8871c9a9f3048904b393325d5cdae0d06bcb11551fbf65b7431ca7490901a11a1eee6661f2d3d90d3662c23faabf8726fe6ae11bffae4086498f8eda2566efbac499ded75a35f22b30e89acc4053d32a1d358413321da9f1cf5016491a8787eda3638c419c9cb535800f37fda418ba57418ed045f6e5396a43f5c75313ed20e9ae3a5eb0155e6e38e25b455d7ce81c5d142568df1e75db7fcb1e6bc200e4cdcd6cc22390f430d1be6e5df1681cf9b6881e60f86d27d284fd80a690deab92595cd39007a7d086ab8a1d49ef356755beb6b17f283c93e81d3f053aa1863a9cc425ea0f4fceb9df88ad0e76b0e11035c5517e0f3e37f301c8c8fd486904833ddb34696e0454ffa65b89096b343be04dd28aab17adcd9a4f01de944c6a342394d9d7bd363fdc41b0560b817e2c29cb2a7b6e9c4d21dca93d1b77db865bbcb3ab08763368a32cf78c0fd34950c68403f58a72aa39275ef119233405cd70d6e95ed3e40450f787f4bafa91c47eeae1c8ba2fdc02d85b4013bf8f11bfb6c3150c26c82094e53c12cae7a3ccd02287a979f0a992638181aac759ae9d2473768e23e968e98013abb7ca86812bf249d6b70e1d6e40eeb795e9d69736725f088e932448ec57c2252074db2158b22cd5292a3c10631f460cf1bc39add8219c4a1614d6a238ae86d5f472b9b7c29d33aac3eec46c4c4e5ddf542606fa31031b7eca30fa806aac6f1bf7e0d4078bc265f3902d8eadbe8a0f13d5292f3dcbce9c225ffd45568d5da96bb11de10cecb9502ded0449f5e5654217b82b568e0d2356e6705193b4735fca58eaa8b2e202177867e83b8b870790777996fd8bb906d5dd1e3f107f80141b9ad4bba2ce750dbce6f3c9cf024ce33ac83eb25275ab37c0f58ae1f020f02bf0250764e6679e91a98fb9ace86fd1ea43551a95fd478303b14361ed3ebd0097ef3e3781eee9e0d28d152ed5726c0fd3f58b9ec654fc5737b89bb5ee264cf9d1de05bc55cd90458395f4d74a6ff9d5d93df8edf608829e39dbff8bba53d013857d2cb5fa1739047f1714dfc1e7276e1844153918d6a25092354e94febe7d482a5f43788a450e3529689b77210cb191d037cb003a6a361dc30f66f3e44b82e3054bbda58a3cbe7da90181aed4d0a90baf7924cfdd0eebac4648f7aa17c3a9993539f7538fd6a2d3b08235f83d403ee0e76ce6dbc6294632d4464915c54eed96b3098f1135d1be52c3af207c0efe16759643a80f126f92606b63ec4278528677349e5c60b29818736be27c84d6124c44522e35c04ccc620ad6d672cc960dddcfc5f472da78962a75f197db910f54b52c62984a8ecfa9fe20a3a2f9039cc4de6f6fdf0c682e72f98ebc9ef90530a67bfa8f0ad6ac43277fee5a8076dba27811463c5fbae69a4d98a03e663c7c1971b44a3b69c21ae35239b9c6f7f61c3be647052e36dc25b939c1b5b4d542aaf7385880a21620a2895b8b0c891673448973a8776a0ceeff3e1c1c91df5350c389d81aba733be0f0459f8713dce2d1a8ea32ff3bbba024a86c6cf7e7db380449369764a3155feefce5ea4efd360352dcaf49d08efeb2e2b384dd8d3634382a67bb8f3ff0f9a62032e4fa4c9a01ff03d9c34b09078abdeb7ef68cefd1f57d26ae2dd954a556d98241a9bf810fe48650ebffb6be9c78751287760528f150fe1b5dc622fb42fcf922879cac231c25c6e92761cb42723a71ad7d00342692d13e11e044baaa376ab3ec7874f0703d753fc26ac786f77efd63e2ecfc603b65d9b2d8b91184072f9f2cad5cd2e7cc6693deb99eeaea1ca5a399671d56487e94bd873550e92e2e8d678d327362ff2b4d6b4dcca55a57ac83ff9566905a2b4596a2b0d052d98570debf9dd50710bfb8b18958fa6b6a7bbd6d1b917eaf5dc8559a2296144178cb2eded6e0c2132a3eacf327f4b55f4f453e76e51a7e90b5ececdabb03ea05500dde34568bafc457ef1f9637402a8d4759076d1deab3cb67ff64c28b53f2a0e9ff36b565abf86e35839038aee2443482db1dd692b5395c3280997d89622107b5b5fefdb70389260f73ac649c7b300a47fbb2de8e01a9e51d009e0cadf36be18acf734681ac15148f2762cebd4f148f3b42d6b2c9432cbe1671248ee5b2a73ee4349fd00586870b829f446173dc4fc89d004c4daf9b8ecd52cca3e083c868572384f68f22eab6a39326a3fa28c2630972941aaedf661f9d8ed45cf3e6b25f88c5a3ea34a8be5eae4c13a7441a176a772c12562cd3239baf0cd9098a044eb94f02db0df19e8066c9fe185a9113e681b3f40feb4520f23aaecad7912f0730a7a4aa57d929fcd2efb05b3eb0f533bb5485cb4f8df7414f992d76f07779aecf620bcb5e5810d92bd17de96e80421dd2be6c827b9c80b10596fe3ddbc51252ded1e1b0d579b63568046eaf1ad10010e8f7adbf0946c6ef71e18480183f87fb3e30f63b25df34ce2ab11e7e6ccc3004edcbcc32e6c506ef32f04541e83cb2cd3f6ddd49322358a002bbff5009b5e9c7ae49df35e077ac13c25255eba1ef4eadd26752fb32ce090b47f63014ba8c5be439b5b96e34a6ee61477f46cb0255c09894fb0e468b4190de6edd825e3911a8394d7f882ee3885e73d247a8bed0e8684f1854854da6ce246f3baf397cf5417309e857c82e8f3ae9374579ff3ed9b4f2af21e28b7be3f85d28c787a2878adfaed350d902113d1cddc79803cc8b3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">有密码的才可以看哦</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>2021 年度总结</title>
    <url>/secret/2dac7475.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码不对哦" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容">
  <script id="hbeData" type="hbeData" data-hmacdigest="3f5161a9a4ef84ea876ffb008301d59ac38d2728253186f1fad19f2430a74daf">82bcfb6ad35536ed66db7d5b2bb7b6ca9db8e326d4d45af47240cc0ff9ee5e1d16dcf15ea99d81a551af8e715dd8c820eb8872d7b1d1899cfa5d7608e264567060fd771cba5f4ba1594fd6fbff0755d73da6dbc283e832e6039cfaf93f26e20f7176c247512b98f555d5956bd8a4cbf4b2363d8f51c6946b5687b75d510c7a8f444790e67bb9436eeb281e6421751972fda89b32cdbc658be7cdb4620c3d8a291db1c7de3ff5def166bedf4c9192e6418c176fca9faeb9b12ab4c2c12fd8cb4395956dc3f16f353339889273def14aae179937f67c59b6fd927da06b689836db7f30dc1855ffdaaae8d271596503263dd6420141b9f08449be65f691f82d4029efdbac03b776a857569a8e61d4340b1ede43b36b078eb1bc1f1954320331ca9d5305379aee1a9ae87eed2014d6e3f7392812f2a37b35a9115e369dc6e8c70c1a87a57b4136e99a10ab359388cd97c8bebd9e1d78fcecbc4e709b7fa2dc5b8aa12e0ccf7d475b0d681a43d37049e7c9703042ee592beca3bd2b2838be8f848c37dc7b2675d461c9774f5f7e1e2fdb3b350a754e565ec4c1d31e49efbac32aabfbf940fe7de4554b474d2305842bd02b495aa49814b6ffb4ecb960d5456ab85fab594152fa00e16601ca496335338da582f78b5c1dda53455c88e698bd83c9fd4a68f4afcbe71eeb98c5f2a689f47f3c5295da9e4174a00e188d9913df1ecf017d5b2718cd9aacc053efd0c8a57e0a8900250830c182d159a8cc9760d263b9601b427d0a002086637a23e5df3ceec88f8ed741bbda2d94f411febdd49ce15ab5e50dfb9059df21e67ab726ed540af6397dac87b96963734ce387e684fca5f73e5e9ca14bcaa8b715e59ae4e5169dfc102944e742e8e9ea8cae9690c3a07633eec7a0d309a709649ecc822345f76cc5f2df97d8af020f4e859a39e7dd44dce47fe656f5a1c7960e3ee4e689c3782f7dc205934b71a61b2d36779ae8bfc8aae465fb2ae577a3debeccc20dd32fdadefd290d9f58b0c9d8cd70c8d8f094302e2bda3326237e40ace21b1e5ac018b1579d000473e0fe2b3170e9ccb1f105fd76df7e425a7ec87dcf9a798bbe1749a3af5536e8b0d0a8bde43e083753d6f34191079d28cb98b425bc167a00315fa47c7e2b83b3a4974e4aa027c25821526b8ec40b4ba327df9c7d00f9a22002a1e19f522eedccd904c068b4daa7b177e1102538247b8ef0fa9ff78c20156da35ed0ae4284138633510dad61b5376666f9b39d836c3ef9a1293478c12200f830471d8d9c204fefb8d09d6f8dcc9c6364aebb42a49675f6d75854b25eb57836b18288b56891a5257879cb5b664454737fba8406eb9ca6ecafb2939c581e5b288de73e5234579fd407f9117c180834e0a606ef5594105cb5e7e2e3d0d42e528a4db17c84c55fb1e6a2bf22774b7a13f02fb26f86d2596a7962568b9587afe2121e0e315715d343e6a09588633d6fe0286ece2862e9a96a5bba5c4502a1cc7c6a6be799d17174eb9b9362271be4c0df27be10309c86f1a77856fc2d2ad364732ef2f927ef19d04d0698b08b52470cd3d071ddf0a5c95a8462d61311e34a4948ac1d8b28b91b8d1b7fcd473663ce029ad2bc1c2b520303ce7ce16ad5413ce2635681cb0ab9505536bbf339243aab1807a00edf1d8b67a4ff05600da695af6fd2e01c30185239e2b0c768f4bc380cadafaa7e293f8f9ef9f4549fbe7c93d09c5236379e246471c4cd6c33efa276dd645f4d1d048d3aa2735ba8fed56be7124227841c2dfe7f01daae5a5f2e1c3229a5493b0fb6c83661a28adb8d0eef68ddeb12d99217d65be1a6420d9bc1acb8910b41332030ebfdae47cefdbebfb2f5cc173f84ba64878cd8d72dd65a42d5b78cb2a17a083d51955795a4816af9225f03dacba2a073f1ef90a9cc5025566539f55613263a3959b7fec2742f603661b0eeac6efdda1857c772bc011b1e6e93698e8f985729550262c5631376714bd943f9399e0c4fcaf1fb643e8fe0464655e8627a4f0b6215903bb21814965aa373ac209d8d4c52145fa3abbbd964bc5f37a8ca34ae0064cd0ddab5f67537ba9de01df860706c7ffd46c5f61bba8deca6b5b67f9d77c44aef95ae7824080d22e36403b461ed46b546c1802f32cf01500584028321a1d5f7f911c1e18a1636d0b66d3767f8be50ad560f3af363802fb70b4a41adaeb14d5af282043fc03215108ab014ac3e1bb353ce4c3a506c10b50c2c6c68c9cadb1731a88e8064634ad5c3e45f13eaa8f612e1f6ae3bb92b9ed18325d936005a999b5a2c2bbe241327f64aaf3f300fa3621dd570c1a37269e664550b0645a3d294b2f8de4dfcd08ca9efb62b5a09059c51014ae52e056a397c9e08e64dac4ef2bb6813d2fc859ccea3eaf2b4ec5451f8da718292113fe1a3cde972da7f9d8fdc5dcf9e20ea905ee08f57</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">有密码的才可以看哦</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Hidden Zone</title>
    <url>/secret/index.html</url>
    <content><![CDATA[<h2 id="Diary"><a href="#Diary" class="headerlink" title="Diary"></a>Diary</h2><ul>
<li><a href="21-oct.html">Oct, 2021</a></li>
</ul>
<h2 id="Articles"><a href="#Articles" class="headerlink" title="Articles"></a>Articles</h2><ul>
<li><a href="2dac7475.html">2021 年度总结</a></li>
</ul>
]]></content>
  </entry>
</search>
