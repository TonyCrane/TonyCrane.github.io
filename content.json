{"pages":[{"title":"关于","text":".intro { text-align: center; font-weight: bold } .intro a { color:var(--font-color)!important } .intro a:hover { text-decoration: underline } .intro p { line-height: 1.75 } (｡･∀･)ﾉﾞ准大学生 | 哔哩哔哩up主鹤翔万里 3b1b/manim项目Collaboratormanim-kindergarten组织Maintainer INFJ-A | HUFFLEPUFFVSCode 重度使用 | Python/C++米粉但中意MacBook | 萌新刀客塔YOASOBI | Orangestar | 诺兰 | 新海诚 咕咕咕～～～！！这里应该也不常更新_(:з」∠)_但希望你能喜欢(～￣▽￣)～ 历史记录 这里是B站up主鹤翔万里的个人博客高考结束，hexo重新配置，恢复更新主要记录一些学习过程中遇到的技术问题解决办法 于`2021.6.12` 这里是B站up主鹤翔万里的个人博客同时也是3b1b/manim项目的Collaborator，manim-kindergarten组织的Maintainer正在高考备考，没有更新这段时间由于hexo环境的问题，博客没有更新 于`2020.9.30` 这里是B站up主鹤翔万里的个人博客目前已经信竞退役，在B站制作一些manim教程和科普视频这段时间由于hexo环境的问题，博客没有更新 于`2020.6.21` 这里是B站up主鹤翔万里的个人博客现在还是一名$JL$的$OIer$,这个博客目前主要堆放了我学习$OI$算法时的笔记和一些题解还可能有一些乱七八糟的文章(比如游记,做视频的经验之类的)‍ _(:3」∠)_总之,非常感谢您能够来到这里,一起加油‍吧(〜￣△￣)〜 于`2020.4.27` 本博客于 2019.1.9 首次开通于 2019.3.10 更新至Hexo本博客主要记载一些经验和算法模板(C++) 于`2019.3.10`","link":"/about/index.html"},{"title":"C++算法(OI)","text":"基础算法深度优先搜索广度优先搜索动态规划&emsp;背包问题 数论欧拉线性筛大整数类 数据结构堆并查集标准模板库STL树状数组 字符串算法字符串哈希哈希表KMP算法 图论算法链式前向星存储图图的遍历欧拉回路 最小生成树PrimKruskal 最短路径DijkstraSPFAFloyd","link":"/algorithms/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"友链","text":"@media screen and (min-width: 1280px) { .column.is-6-widescreen { flex: none; width: 75%; } } .flink-list { overflow: auto; padding: 10px 10px 0; text-align: center; } .flink-list a { color: #4a4a4a; } .flink-list-item { position: relative; float: left; overflow: hidden; margin: 15px 7px; width: calc(100% / 3 - 15px); height: 90px; border-radius: 8px; line-height: 17px; -webkit-transform: translateZ(0); transition: 0.25s; } .flink-item-icon { float: left; overflow: hidden; margin: 15px 10px; width: 60px; height: 60px; border-radius: 35px; } .flink-item-name { padding: 16px 10px 0 0; height: 40px; font-weight: bold; font-size: 1.43em; } .flink-item-desc { padding: 16px 10px 16px 0; height: 50px; font-size: 0.93em; } .flink-list-item:hover { background-color: #81ACF9; } @media screen and (max-width: 1280px) { .flink-list-item { width: calc(50% - 15px) !important; } } @media screen and (max-width: 810px) { .flink-list-item { width: calc(100% - 15px) !important; } } GZTime Walking on the Time Axis. Cigar666 _(:з」∠)_ 范滇东 |･ω･｀) widcardw 不是多面手 烧风 A human. 數心 萬物皆數. 相关链接 MK官网 manim-kindergarten官网","link":"/friends/index.html"}],"posts":[{"title":"「Learn Haskell」#0 总章","text":"学习一门新语言之Haskell 前言之前一直很好奇函数式编程，觉得Haskell挺有意思的，想学学现在高考完放假了，可以有时间具体学一学了这里没有Haskell的教程，只有我在学习Haskell时写下的笔记 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp; 基础运算 + - * / ()：加减乘除 div：整除 mod：取模 True False：布尔值 || &amp;&amp; not：或且非 ==：条件判断，相等 /=：条件判断，不等 函数调用Haskell中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开： 12ghci&gt; max 1 22 前缀（prefix）函数与中缀（infix）函数转换： 对前缀函数加``使其变成中缀函数 对中缀函数加()使其变成前缀函数 12345678ghci&gt; 4 `div` 22ghci&gt; 1 `max` 22ghci&gt; (+) 1 23ghci&gt; (||) True FalseTrue List列表是Haskell中很常见的数据类型，和Python中不同，Haskell中的列表中的所有元素必须是同一个类型。 以下是列表常用的函数： (++) :: [a] -&gt; [a] -&gt; [a]：合并两个列表 (:) :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。[1, 2, 3]是1:2:3:[]的语法糖 (!!) :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。a !! 1相当于Python中的a[1] head :: [a] -&gt; a：返回列表的第一个元素 tail :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]） last :: [a] -&gt; a：返回列表中的最后一个元素 init :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表 length :: Foldable t =&gt; t a -&gt; Int：返回列表的长度 null :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空 reverse :: [a] -&gt; [a]：返回翻转后的列表 take :: Int -&gt; [a] -&gt; [a]：返回列表a的前n个元素的列表(take n a) drop :: Int -&gt; [a] -&gt; [a]：返回列表a中除去前n个元素后的列表(drop n a) maximum :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值 minimum :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值 sum :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和 product :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积 elem :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值n是否在列表a中( 123elem n a-- 或n `elem` a --用``包上可以变成中缀函数使用 Texas ranges使用..可以表示出范围并自动推导： 123456789101112ghci&gt; [1 .. 10] [1,2,3,4,5,6,7,8,9,10] ghci&gt; ['a' .. 'z'] &quot;abcdefghijklmnopqrstuvwxyz&quot; ghci&gt; ['K' .. 'Z'] &quot;KLMNOPQRSTUVWXYZ&quot; ghci&gt; [2, 4 .. 20] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [3, 6 .. 20] [3,6,9,12,15,18]ghci&gt; [5, 4 .. 1][5,4,3,2,1] 也可以用来生成无穷列表，如[1..]、[1, 3..]。同时也有函数可以生成无穷列表： cycle :: [a] -&gt; [a]：将原列表不断循环生成无穷列表 repeat :: a -&gt; [a]：将传入的值不断重复生成无穷列表 replicate :: Int -&gt; a -&gt; [a]：将值a重复n次，返回生成的列表(replicate n a) List comprehensionHaskell中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件 12345678ghci&gt; [x * 2 | x &lt;- [1 .. 10]] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [x * 2 | x &lt;- [1 .. 10], x * 2 &gt;= 12] [12,14,16,18,20]ghci&gt; [ x | x &lt;- [50 .. 100], x `mod` 7 == 3] [52,59,66,73,80,87,94] ghci&gt; [x * y | x &lt;- [2, 5, 10], y &lt;- [8, 10, 11]] [16,20,22,40,50,55,80,100,110] TupleHaskell中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数： fst :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素 snd :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素 zip :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组 Syntax in Functions函数可以直接定义： 1plus x y = x + y 这时Haskell会自动推断函数的类型为(Num a) =&gt; a -&gt; a -&gt; a。但是最好在定义函数前声明函数的类型： 12plus :: (Num a) =&gt; a -&gt; a -&gt; aplus x y = x + y Pattern matching定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如： 123factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial (n - 1) 12345678first :: (a, b, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z 其中_表示任何值，且不关心它的内容，只是用来占位 列表的(:)操作也可以用来进行模式匹配： 1234567head' :: [a] -&gt; a head' [] = error &quot;Can't call head on an empty list, dummy!&quot; head' (x:_) = xsum' :: (Num a) =&gt; [a] -&gt; a sum' [] = 0 sum' (x:xs) = x + sum' xs 但(++)操作不可以用来模式匹配 在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用xs@(q:qs)。比如[1, 2, 3]通过xs@(q:qs)匹配后，xs为[1, 2, 3]，q为1，qs为[2, 3] Guard syntax在函数的定义中，也可以使用守卫（guard）语法： 1234max' :: (Ord a) =&gt; a -&gt; a -&gt; a max' a b | a &gt; b = a | otherwise = b 先给出传入的参数变量，然后下一行缩进后加|，|后面等号前表示进行的判断，如果为True则返回这个等号后面的值；如果为False则继续判断下一行，直到otherwise Case expressions在函数的定义中，也可以使用case表达式来配合模式匹配使用： 123case expression of pattern -&gt; result pattern -&gt; result ... 例如： 1234567head' :: [a] -&gt; a head' [] = error &quot;No head for empty lists!&quot; head' (x:_) = x -- 等价于：head' :: [a] -&gt; a head' xs = case xs of [] -&gt; error &quot;No head for empty lists!&quot; (x:_) -&gt; x 12345678910describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot; [x] -&gt; &quot;a singleton list.&quot; xs -&gt; &quot;a longer list.&quot; -- 等价于：describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ what xs where what [] = &quot;empty.&quot; what [x] = &quot;a singleton list.&quot; what xs = &quot;a longer list.&quot; where声明在函数定义中要使用的局部变量，可以使用where关键字： 1234nitials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot; where (f:_) = firstname (l:_) = lastname 在where中，也可以使用上面的模式匹配 letlet &lt;bindings&gt; in &lt;expression&gt;语法可以在函数的定义中使用，也可以在普通算式或列表中使用： 12345cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r ^2 in sideArea + 2 * topArea 1234ghci&gt; 4 * (let a = 9 in a + 1) + 2 42 ghci&gt; [let square x = x * x in (square 5, square 3, square 2)] [(25,9,4)] if statementHaskell中的if语句为： 1234567if ... then ...else ...-- or if ... then ... else ...-- orif ... then ...else if ... then ...else ... 其中最后一个else无论如何也不可以省去 Higher Order FunctionsCurryingHaskell中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如max函数，它的类型签名是： max :: Ord a => a -> a -> a 可以看成a -&gt; (a -&gt; a)，即接收一个参数，返回一个类型为a -&gt; a的函数。比如max 1的类型签名是： max 1 :: (Ord a, Num a) => a -> a 因此max 1 2，也就等同于(max 1) 2，即将函数max 1应用在数字2上 同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions） 一些高阶函数zipWithzipWith :: (a -> b -> c) -> [a] -> [b] -> [c] 第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例： 1234ghci&gt; zipWith (+) [4,2,5,6] [2,6,2,3] [6,8,7,9] ghci&gt; zipWith max [6,3,2,1] [7,3,1,5] [7,3,2,5] flipflip :: (a -> b -> c) -> b -> a -> c flip函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来： 1234ghci&gt; zip [1,2,3,4,5] &quot;hello&quot;[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]ghci&gt; flip zip [1,2,3,4,5] &quot;hello&quot; [('h',1),('e',2),('l',3),('l',4),('o',5)] mapmap :: (a -> b) -> [a] -> [b] map函数接收一个函数f和一个列表a，将函数f应用在列表a的每个元素中，并返回得到的所有结果组成的列表b： 12ghci&gt; map (+3) [1,5,3,1,6] [4,8,6,4,9] filterfilter :: (a -> Bool) -> [a] -> [a] filter函数接收一个函数f和一个列表a，将列表a中的每个元素传入函数f中，如果结果为True就保留，结果为False就抛弃，返回所有保留的元素组成的新列表： 12ghci&gt; filter even [1..10] [2,4,6,8,10] takeWhiletakeWhile :: (a -> Bool) -> [a] -> [a] takeWhile函数接收一个函数f和一个列表a，将列表a中从左向右每个元素传入函数f，直到结果为False停止，返回停止前传入的所有元素组成的新列表： 12ghci&gt; takeWhile (/=' ') &quot;word1 word2&quot;&quot;word1&quot; Function application函数应用可以使用$，$是一个函数，它的类型是： ($) :: (a -> b) -> a -> b 它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。 1234567f $ g x-- 等价于f (g x)-----f g x-- 等价于(f g) x Function Composition函数复合可以使用.，.也是一个函数，它的类型是： (.) :: (b -> c) -> (a -> b) -> a -> c 定义是： f . g = \\x -> f (g x) 但是函数复合的优先级要比函数执行低，比如： 1sum . replicate 5 . max 6.7 8.9 会先执行max 6.7 8.9并返回8.9，然后将sum、replicate 5、8.9复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用$来规定先复合再执行： 1sum . replicate 5 . max 6.7 $ 8.9 lambdaHaskell语言中的lambda表达式是用\\来表示的（因为看着像$\\mathtt{\\lambda}$？）具体语法是 1\\para1 para2 ... -&gt; return “-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。 fold和scanfold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表传入的二元函数f :: a -&gt; b -&gt; b将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数） foldl左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如： 1foldl f a xs 它的结果计算过程为 1234&gt; foldl f a [x1, x2, x3][1.] a = f a x1[2.] a = f a x2 = f (f a x1) x2[3.] a = f a x3 = f (f (f a x1) x2) x3 可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表 foldr右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如： 1foldr f a xs 它的结果计算过程为 1234&gt; foldr f a [x1, x2, x3][1.] a = f x3 a[2.] a = f x2 a = f x2 (f x3 a)[3.] a = f x1 a = f x1 (f x2 (f x3 a)) 从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]因此可以使用递归来写一个和foldr效果一样的函数: 123foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' _ x [] = xfoldr' f a (x:xs) = f x (foldr' f a xs) 也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表 例如： 12345ghci&gt; foldr (||) False (repeat True)True -- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了ghci&gt; foldl (||) False (repeat True)-- 这里什么都不会发生，直到电脑内存被爆掉-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表 scanl和scanrscan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表scanl则向右延伸这个列表，scanr则向左延伸这个列表但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能 12345&gt; scanr f a [x1, x2, x3][1.] 最右侧元素(-1 in python) : a[2.] 右侧第二个元素(-2) : f x3 a[3.] 右侧第三个元素(-3) : f x2 (f x3 a)[4.] 右侧第四个元素(-4) : f x1 (f x2 (f x3 a)) 可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素因此可以用递归来写一个和scanr效果一样的函数： 12345scanr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanr' _ x [] = [x]-- scanr' f a (x:xs) = f x (foldr f a xs) : scanr' f a xsscanr' f a (x:xs) = f x q : qs where qs@(q:_) = scanr' f a xs scanl也是同理： 123scanl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanl' _ x [] = [x]scanl' f a (x:xs) = a : scanl' f (f a x) xs 也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果： 1234ghci&gt; take 10 (scanl (+) 0 [1..])[0,1,3,6,10,15,21,28,36,45]ghci&gt; take 10 (scanr (+) 0 [1..])[*** Exception: stack overflow 使用foldr编写foldlpdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr： 1foldl' f z xs = foldr (\\x g y -&gt; g (f y x)) id xs z 它利用 foldr (\\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。 先来看一下foldr的类型： 12foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b 但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。 所以这里foldr的类型可以写成： (a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b) 对应于用法 foldr (\\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）而xs对应于[a]；id对应于(b -&gt; b)所以 (\\x g y -&gt; g (f y x)) 要对应于： (a -> (b -> b) -> (b -> b)) 因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。 再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为： b -> (b -> b) 现在根据foldr的定义： foldr f a (x:xs) = f x (foldr f a xs) 带入计算一下： xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn] 定义中的f即为(\\x g y -&gt; g (f y x))，a即为id 12 foldr (\\x g y -&gt; g (f y x)) id xs z= (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z 写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开： 12 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1) 不难发现，原式 (foldr (…) id xs) z 等价于： (foldr (...) id xs') (f z x1) 跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’因此下一步： 12345 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= (foldr (...) id xs''') (f (f (f z x1) x2) x3)= ... 可以发现，已经有了规律。那么最终停止时是什么样呢？ 最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id 所以最后的结果：(id的定义：id x = x) 1234567 ...= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= ...= (foldr (...) id []) (f (.. (f z x1) ..) xn)= id (f (.. (f z x1) ..) xn)= f (.. (f z x1) ..) xn 那么最后这个结果就很熟悉了，它就是 foldl f z xs。所以我们推导出了这个用foldr表示foldl的写法是正确的。 ModulesHaskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用:m + ...，比如加载Data.List模块： Prelude> :m + Data.List 而在hs文件中引入模块，需要使用import语句，下面和python的对比可以便于理解： 1234567891011121314import Data.List-- from Data.List import *import Data.List (nub, sort)-- from Data.List import nub, sortimport Data.List hiding (nub)-- 从Data.List中引入所有，但不引入nub函数import qualified Data.List-- import Data.Listimport qualified Data.List as Li-- import Data.List as Li 编写Modules模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫ModuleA.hs，那它的头部需要写： 123456module ModuleA( functionA, functionB, functionC) where 而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。 Types &amp; TypeclassesTypesHaskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。Type的首字母全为大写，常用的有： Int：整型，有上下界范围，-2147483647～2147483648 Integer：整数，无界，但是效率比Int低 Float：单精度浮点型 Double：双精度浮点型 Bool：布尔值 Char：字符 String：字符串，等同于[Char] Ording：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT 列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加[]。 元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。 Typeclasses类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个TypeclassTypeclass的首字母也全为大写，常见的有： Eq：可判断是否相等 Ord：可比较大小 Show：可展示成字符串 Read：可从字符串转换成特定类型 Enum：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀 Bounded: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded Integral：是整数，包括Int和Integer RealFloat： 是实浮点数，包括Float和Double RealFrac：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中） Floating：是浮点数，包括Float、Double和Complex（在Data.Complex模块中） Real：是实数，包括Integral和RealFrac的成员 Fractional：是分数，包括RealFrac和Floating的成员 Num：是数字，包括上述所有数字相关的类型 Type variables如果查看一个函数的类型，比如head，那么将会返回以下类型： head :: [a] -> a 其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。 在函数的类型表达式其实可以看作$\\lambda$表达式，它适用于$\\alpha$变换（$\\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。 在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如(==)函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么(==)的类型就是： (==) :: (Eq a) => a -> a -> Bool 其中=&gt;前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以(==)函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。 定义新Type定义一个新的Type需要使用data关键字，比如定义Bool需要使用： data Bool = False | True 其中=左侧的部分定义了新类型的名称Bool，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。并且名称和值构造器的首字母都需要大写。 另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如： 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float 它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。如果查看Circle的类型，将返回： Circle :: Float -> Float -> Float -> Shape 如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上deriving (Show): 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) 类型的名称和值构造器名称也可以相同，比如： 1data Point = Point Float Float deriving (Show) 导出Type在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件Shapes.hs中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写： 123456module Shapes( Shape(..), Point(..), functionA, functionB) where 其中的Shape(..)导出了Shape类型和它所有的值构造器，..代表了它的所有值构造器。因此，Shape(..)相当于Shape (Circle, Rectangle)。 如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将Shape(..)替换为Shape，这样就只导出了Shape类型，而不导出其值构造器。 Record Syntax如果想要方便地取出类型实例中的参数，可以使用Record语法，如： 123data Point = Point { xcoord :: Float , ycoord :: Float } deriving (Show) 在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值： 12345ghci&gt; let point = Point 1.0 2.0ghci&gt; xcoord point1.0ghci&gt; ycoord point2.0 同时也可以通过下面方法来创建这个point： 1point = Point {ycoord=2.0, xcoord=1.0} Type parameters值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义： data Maybe a = Nothing | Just a 它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型： 1234Nothing :: Maybe aJust 1 :: Num a =&gt; Maybe aJust 'a' :: Maybe CharJust &quot;abc&quot; :: Maybe [Char] 可以用这种方法改写Point： 123data Point x y = Point { xcoord :: x , ycoord :: y } deriving (Show) 但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。 而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如： 12data (Ord k) =&gt; Map k v = ... toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] EitherEither是一个类型构造器，它有两个值构造器，定义是： 1data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) 如果使用了Left，那它的a的类型就是具体的；如果使用了Right，那它的b的类型就是具体的： 12345678ghci&gt; Right 20 Right 20 ghci&gt; Left &quot;w00t&quot; Left &quot;w00t&quot; ghci&gt; :t Right 'a' Right 'a' :: Either a Char ghci&gt; :t Left True Left True :: Either Bool b Either可以看作Maybe的补充，比如Maybe在使用时，出现异常可以返回Nothing，但只是一个Nothing，不包含任何信息；但Either包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法： 12345678safeDiv :: Int -&gt; Int -&gt; Maybe IntsafeDiv _ 0 = NothingsafeDiv x y = Just (x `div` y)ghci&gt; safeDiv 4 2Just 2ghci&gt; safeDiv 1 0Nothing 而使用Either： 12345678safeDiv :: Int -&gt; Int -&gt; Either String IntsafeDiv _ 0 = Left &quot;Divided by zero&quot;safeDiv x y = Right (x `div` y)ghci&gt; safeDiv 4 2Right 2ghci&gt; safeDiv 1 0Left &quot;Divided by zero&quot; Derived instances想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如： 12data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) 这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右） Type synonyms为了阅读方便，书写简便，可以使用type关键字为已有类型创建别名（synonyms）。比如String的定义： type String = [Char] 在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。同时，类型别名也可以接收类型参数 newtype keyword除了data、type关键字之外，还可以用newtype关键字来定义一个新的类型，比如Control.Applicative模块中的ZipList： 1newtype ZipList a = { getZipList :: [a] } 不同于type，它不是别名，可以使用record语法来直接定义取出值的函数 不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰 Recursive data structures一个类型也可以递归定义，比如一颗二叉树： 1data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) 定义新Typeclass定义一个新的Typeclass需要使用class关键字，例如定义Eq类型类： 12345class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) 其中a是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。 包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们（(==) | (/=)）成为这个类型类的最小完整定义（minimal complete definition） 查看一个类型类的成员需要实现的函数可以在GHCi中使用:info： ghci> :info Eq 手动创建实例使一个类型成为一个类型类的实例可以直接使用deriving来自动完成，也可以通过使用instance关键字来手动完成。比如使Point成为Show的实例： 123456instance Show Point where show (Point x y) = &quot;(&quot; ++ show x ++ &quot;, &quot; ++ show y ++ &quot;)&quot;-- in ghcighci&gt; Point 1.0 2.0(1.0, 2.0) 这样就可以自定义显示的内容，否则使用deriving的话只会直接将其转化为字符串。 同时也要注意类型和类型构造器的区别，传入给instance的第二个参数应该为类型而不是类型构造器，比如Maybe： 123456789101112instance Eq Maybe where ... -- 错误用法，因为Maybe是类型构造器而不是类型instance Eq (Maybe m) where ...-- 错误用法，因为m不一定是Eq的成员instance (Eq m) =&gt; Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False Functor TypeclassFunctor也是一种类型类，它只规定了一个函数： 12class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 其中f是一个类型构造器，而不是一个具体类型 Kinds一个值的类型叫做类型（Type），而一个类型的类型叫做Kind。可以通过GHCi中:k来查看Kind： 12345678ghci&gt; :k IntInt :: *ghci&gt; :k MaybeMaybe :: * -&gt; *ghci&gt; :k Maybe IntMaybe Int :: *ghci&gt; :k EitherEither :: * -&gt; * -&gt; * 其中的星号*代表了一个具体类型（concrete type）。Int本身就是一个具体类型，所以Int的Kind是*。而Maybe是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以Maybe的Kind是* -&gt; *。如果给Maybe传入了一个Int，那么得到的Maybe Int就是一个具体的类型，它的Kind就是*。Either也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以Either的Kind是* -&gt; * -&gt; *。 Input/Output运行Haskell程序不在GHCi中运行一个Haskell程序有两种方式： 编译运行： 12$ ghc --make code$ ./code 通过runhaskell命令直接运行： 1$ runhaskell code.hs 输出文本在一个Haskell程序中输出文字需要定义一个main函数： 1main = putStrLn &quot;Hello World&quot; 其中putStrLn的类型是： putStrLn :: String -> IO () putStrLn接收一个String类型，并返回一个结果为()类型的IO动作（I/O action）。所以main函数的类型为IO ()。（IO的Kind是* -&gt; *） 除此之外，还有其他默认提供的输出文本的函数： putStr：输出文本，结尾不换行 putChar：输出单个字符，结尾不换行。接收的参数为单个Char，不是String（用单引号不是双引号） print：可以接收任何Show的成员，先用show转化为字符串然后输出。等同于putStrLn . show do block在main函数中使用多个putStrLn需要使用do语句： 123main = do putStrLn &quot;Line1&quot; putStrLn &quot;Line2&quot; 其中最后一行一定要返回IO ()类型的值 输入文本输入文字需要在do块中使用getLine： 123main = do line &lt;- getLine putStrLn line getLine的类型是： getLine :: IO String 而&lt;-操作符将getLine中的String提取了出来给到了line，使line变成了String类型的一个字符串。 而且使用输入的字符串必须要经过一次&lt;-，不能直接使用getLine作为字符串，因为getLine不是String类型，而是IO String类型。 除此之外，还可以使用getChar来获取单个字符，但仍然需要使用&lt;-操作符来提取Char 其他IO相关函数用法returnHaskell中的return和其他命令式语言中的return完全不同，它不会使函数直接结束并返回一个值。 main函数必须定义为类型为IO ()的函数，所以在main函数中使用if语句，如果不输出的话也不可以直接放下什么都不干，因为这时候main函数的类型不是IO ()。所以这时需要使用return ()来为main函数指定为IO ()类型，例如： 123456main = do line &lt;- getLine if null line then return () -- &lt;-这里 else do ... 使用&lt;-操作符也可以直接将return语句中的内容提取出来，比如a &lt;- return ‘A’，执行后a就是’A’。 whenwhen包含在Control.Monad模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会return ()。比如： 1234567import Control.Monad main = do c &lt;- getChar when (c /= ' ') $ do putChar c main 等同于： 1234567main = do c &lt;- getChar if c /= ' ' then do putChar c main else return () sequencesequence在IO中使用时可以达成[IO a] -&gt; IO [a]的效果，所以可以用作： 1[a, b, c] &lt;- sequence [getLine, getLine, getLine] mapM &amp; mapM_在IO相关的地方使用map，可以使用mapM和mapM_，其中mapM有返回值而mapM_直接扔掉了返回值： 123456789ghci&gt; mapM print [1,2,3] 1 2 3 [(),(),()] ghci&gt; mapM_ print [1,2,3] 1 2 3 foreverforever函数包含在Control.Monad模块中。在main函数开头加上forever函数可以使后面的do块一直重复执行直到程序被迫终止，如： 1234import Control.Monad main = forever $ do ... forMforM函数包含在Control.Monad模块中，它的功能和mapM类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回IO a类型。比如： 123456789import Control.Monadmain = do colors &lt;- forM [1, 2, 3, 4] (\\a -&gt; do putStrLn $ &quot;Which color do you associate with the number &quot; ++ show a ++ &quot;?&quot; color &lt;- getLine return color) putStrLn &quot;The colors that you associate with 1, 2, 3 and 4 are: &quot; mapM putStrLn colors getContentsgetLine获取一整行，而getContents从标准输入中获取全部内容直到遇到EOF，并且它是lazy的，在执行了foo &lt;- getContents后，它并不会读取标准输入并且赋值到foo，而是等到需要使用foo的时候再从标准输入读取。 getContents在使用管道传入文字时很常用，可以代替forever+getLine使用，比如一个Haskell程序文件code.hs： 12345import Data.Char main = do contents &lt;- getContents putStr (map toUpper contents) 使用ghc –make code编译后，通过管道传入文字： 1cat text.txt | ./code 会将text.txt中的所有字母转为大写并输出 interact上述功能还可以转化为一个String -&gt; String的函数： 1upperStrings = unlines . map (map toUpper) . lines 而在main中使用这个函数就需要： 123main = do contents &lt;- getContents putStr (upperStrings contents) 但是String -&gt; String类型的函数在输入输出中的使用太常见了，所以可以使用interact函数来简化。interact的类型是： interact :: (String -> String) -> IO () 可以看出它接收一个String -&gt; String的函数，并返回一个IO ()类型，所以可以直接用在main上。 于是整个转换为大写的程序就可以简化为： 1main = interact $ unlines . map (map toUpper) . lines 文件和流以下与文件和流相关的函数都包含在System.IO模块中 openFileopenFile函数可以用来打开一个文件，它的类型是： openFile :: FilePath -> IOMode -> IO Handle 其中FilePath是String的type synonyms，用一个字符串来表示需要打开的文件的路径 IOMode的定义是： 1data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode 所以它一共只有四个值，用来表示进行IO操作的模式 openFile返回一个IO Handle类型的值，将其用&lt;-操作符提取后会出现一个Handle的值。但不能从Handle中直接使用文字，还需要使用一系列函数： hGetContents :: Handle -&gt; IO String ，从Handle中读取全部内容，返回一个IO String hGetChar :: Handle -&gt; IO Char ，从Handle中读取一个字符 hGetLine :: Handle -&gt; IO String ，从Handle中读取一行，返回一个IO String hPutStr :: Handle -&gt; String -&gt; IO () ，向Handle中输出字符串 hPutStrLn :: Handle -&gt; String -&gt; IO () ，同上 在使用openFile进行文件操作后，需要使用hClose手动关闭Handle。hClose :: Handle -&gt; IO ()，接收一个Handle并返回IO ()，可以直接放在main函数末尾 所以使用openFile读取一个文件中的全部内容并输出的全部代码是： 1234567import System.IOmain = do handle &lt;- openFile &quot;text.txt&quot; ReadMode contents &lt;- hGetContents handle putStrLn contents hClose handle withFilewithFile类似Python中的with open，它在读取文件使用之后不需要手动close文件。它的类型是： withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a 可以看出，它接收三个参数： FilePath：一个表示文件路径的String IOMode：打开文件的模式 (Handle -&gt; IO a)：一个函数，表示对读取文件后的Handle索要进行的操作，需要返回一个I/O action；而这个返回值也将作为withFile的返回值 现在使用withFile来改写上述代码： 12345import System.IOmain = withFile &quot;text.txt&quot; ReadMode (\\handle -&gt; do contents &lt;- hGetContents handle putStrLn contents) withFile的功能相当于以下函数： 123456withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a withFile' path mode f = do handle &lt;- openFile path mode result &lt;- f handle hClose handle return result readFilereadFile可以更加简化读取文件内容的操作，它的类型： readFile :: FilePath -> IO String 它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的I/O action： 12345import System.IOmain = do contents &lt;- readFile &quot;text.txt&quot; putStrLn contents writeFilewriteFile简化了写入文件的操作，它的类型： writeFile :: FilePath -> String -> IO () 传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个IO () appendFileappendFile类似writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾 buffer文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。 也可以通过hSetBuffering函数来手动设置缓冲区大小，这个函数的类型： hSetBuffering :: Handle -> BufferMode -> IO () 它接收一个handle，和一个BufferMode，并返回IO ()。其中BufferMode有以下几种： NoBuffering：没有缓冲区，一次读入一个字符 LineBuffering：缓冲区大小是一行，即每次读入一行内容 BlockBuffering (Maybe Int)：缓冲区大小是一块，块的大小由Maybe Int指定： BlockBuffering (Nothing)：使用系统默认的块大小 BlockBuffering (Just 2048)：一块的大小是2048字节，即每次读入2048bytes的内容 缓冲区的刷新是自动的，也可以通过hFlush来手动刷新 hFlush :: Handle -> IO () 传入一个handle，返回IO ()，即刷新对应handle的缓冲区 openTempFileopenTempFile可以新建一个临时文件： openTempFile :: FilePath -> String -> IO (FilePath, Handle) FilePath指临时文件要创建的位置路径，String指临时文件名字的前缀，返回一个I/O action，其内容第一个FilePath是创建得到的临时文件的路径，Handle是临时文件的handle 例如： 123456import System.IOmain = do (tempFile, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot; ... hClose tempHandle &quot;.&quot;指临时文件要在当前目录创建，&quot;temp&quot;指临时文件名字以temp开头。最终得到的tempFile就是./temp…….，temp后为随机数字，如./temp43620-0 路径操作相关函数都包含在System.Directory模块中，全部内容见System.Directory getCurrentDirectorygetCurrentDirectory :: IO FilePath 直接返回一个I/O action，其内容是一个字符串表示当前路径的绝对路径 removeFileremoveFile :: FilePath -> IO () 输入一个文件路径，并删除掉它 renameFilerenameFile :: FilePath -> FilePath -> IO () 输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名 doesFileExistdoesFileExist :: FilePath -> IO Bool 检查文件是否存在，返回一个包含布尔值的I/O action Command line argumentsSystem.Environment模块中提供了两个函数可以用来处理传入命令行的参数 getArgsgetArgs :: IO [String] 不需要输入参数，直接返回一个I/O action，内容为传入命令行的参数（一个由String组成的列表）。相当于C语言中的argv[1:] getProgNamegetProgName :: IO String 返回I/O action，内容为程序的名字，相当于C语言中的argv[0] Randomness和随机数有关的函数都包含在System.Random模块中。GHCi启动时可能不会包含System.Random的配置，导致无法找到模块。需要通过stack打开: 1stack ghci --package random Haskell要求同样的程序需要运行出同样的结果，除了用到了I/O action，所有会造成不同结果的函数都要交给I/O action来完成 那要使随机数脱离IO存在，就要用到随机生成器（random generator） System.Random模块提供了几个生成随机数的函数： randomrandom :: (Random a, RandomGen g) => g -> (a, g) 其中又有两个新的typeclass，Random表示可以取随机，RandomGen表示随机数生成器。random函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器 获取随机数生成器可以使用mkStdGen函数： mkStdGen :: Int -> StdGen 其中StdGen是一个RandomGen的实例 运用random生成随机数需要指定类型，不然程序无法确定a是什么类型。例如： 123456ghci&gt; random (mkStdGen 100) :: (Int, StdGen)(9216477508314497915,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Char, StdGen)('\\537310',StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Bool, StdGen)(True,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125}) 再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器： 123456threeCoins :: StdGen -&gt; (Bool, Bool, Bool) threeCoins gen = let (firstCoin, newGen) = random gen (secondCoin, newGen') = random newGen (thirdCoin, newGen'') = random newGen' in (firstCoin, secondCoin, thirdCoin) randomsrandoms :: (Random a, RandomGen g) => g -> [a] randoms接收一个RandomGen，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器 randomRrandomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g) 可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围(闭区间) randomRsrandomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a] 同上两个，生成有范围的无穷随机数列表 getStdGen如果想要让程序每次运行得到不同的随机结果，需要使用getStdGen来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个I/O action，而不是一个直接的StdGen getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen 即可以看成getStdGen :: IO StdGen，需要使用&lt;-操作符将StdGen提取出来 但是在同一个程序中，getStdGen的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数newStdGen newStdGennewStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen 执行newStdGen会进行两个操作： 更新全局随机数生成器，下次执行getStdGen会获得不同的结果 返回一个I/O action，包含一个新的StdGen（但是这个生成器和全局生成器也不同） Exceptions程序在运行失败时会抛出异常，可以通过Control.Exception模块中的catch函数来捕获异常： catch :: Exception e => IO a -> (e -> IO a) -> IO a 第一个参数是要进行的操作，以IO a为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如： 12345678910import Control.Exceptionmain = main' `catch` handlermain' :: IO ()main' = do ...handler :: Exception e =&gt; e -&gt; IO ()handler e = putStrLn &quot;...&quot; 也可以利用守卫（guard）语法和System.IO.Error中的函数来判断IO异常的类型来进行不同操作： 123456789101112131415import System.Environmentimport System.IO.Errorimport Control.Exception main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) &lt;- getArgs contents &lt;- readFile fileName putStrLn $ &quot;The file has &quot; ++ show (length (lines contents)) ++ &quot; lines!&quot; handler :: IOError -&gt; IO () handler e | isDoesNotExistError e = putStrLn &quot;The file doesn't exist!&quot; | otherwise = ioError e 具体相关全部函数见文档：System.IO.Error、Control.Exception Functors函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用fmap :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子 Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子 函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的f a和f b也是因为f是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中 Functor的定义是: 1234class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b (&lt;$) :: a -&gt; f a -&gt; f b (&lt;$) = fmap . const 可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如： 12ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot; 但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名： const :: a -> b -> a 即接收两个参数，但始终只返回第一个参数 Functor实例[]列表[]是一个函子，它通过map函数来实现fmap的功能： 12instance Functor [] where fmap = map map :: (a -> b) -> [a] -> [b] map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表 MaybeMaybe也具有kind * -&gt; *，它也是一个函子： 12345678instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x)ghci&gt; fmap (*2) NothingNothingghci&gt; fmap (*2) (Just 2)Just 4 Either aEither的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子： 12345678instance Functor (Either a) where fmap f (Left x) = Left x fmap f (Right x) = Right (f x)ghci&gt; fmap (*2) (Left 4)Left 4ghci&gt; fmap (*2) (Right 4)Right 8 因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在） IOIO也是一个函子，使用fmap对IO中内容应用函数： 12345678instance Functor IO where fmap f action = do result &lt;- action return (f result)ghci&gt; fmap (&quot;input: &quot;++) getLinetest&quot;input: test&quot; (,) a(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用： 12instance Functor ((,) a) where fmap f (x, y) = (x, f y) 只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用： 12345instance Functor ((,,) a b) where fmap f (a, b, c) = (a, b, f c)instance Functor ((,,,) a b c) where fmap f (a, b, c, d) = (a, b, c, f d) (-&gt;) r-&gt;也是一个类型构造器，它的kind： (->) :: * -> * -> * 一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中r是输入的类型） 规定的fmap的类型签名是： fmap :: (a -> b) -> f a -> f b 其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到： fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b) 把其中的(-&gt;)换成中缀可以得到： fmap :: (a -> b) -> (r -> a) -> (r -> b) 传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是： 12instance Functor ((-&gt;) r) where fmap f g = (\\x -&gt; f (g x)) 所以(-&gt;) r的fmap其实就是函数复合(.)： 12instance Functor ((-&gt;) r) where fmap = (.) 12345678ghci&gt; :t fmap (*3) (+100) fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a ghci&gt; fmap (*3) (+100) 1 303 ghci&gt; (*3) `fmap` (+100) $ 1 303 ghci&gt; (*3) . (+100) $ 1 303 Functor Laws所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律： fmap id = id（其中id为函数(\\x -&gt; x)）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： 1234ghci&gt; fmap id [1, 2, 3][1,2,3]ghci&gt; fmap id (Just 2)Just 2 fmap (f . g) = fmap f . fmap g：即函子的fmap支持结合律 fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中a为一个函子 fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) 12ghci&gt; fmap ((*3) . (+100)) (Just 1)Just 303 满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可 Intuition对于函子和fmap，有两种理解方法 函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器 函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作fmap :: (a -> b) -> (f a -> f b) 接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数 fmap g :: f a -> f b 使普通的函数g可以在计算上下文f中使用，这种转换也被称为提升（lift） 常用函数&lt;$&gt;&lt;$&gt;函数是fmap的中缀形式（它看着类似$，f $ 3将f应用在单个值3上，而f &lt;$&gt; [1, 2, 3]将f应用在一个函子上，也就是应用在一个函子内部的所有值上）： 1234ghci&gt; fmap (*2) (Just 2)4ghci&gt; (*2) &lt;$&gt; Just 24 $&gt;$&gt;函数包含在Data.Functor模块中 ($>) :: Functor f => f a -> b -> f b Functor定义时要求了&lt;$函数，将函子内部的元素全部替换为指定的某个值，而$&gt;正好将&lt;$函数的两个参数反了过来，相当于flip (&lt;$)： 1234ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot;ghci&gt; [1, 2, 3] $&gt; 'a'&quot;aaa&quot; voidvoid函数也包含在Data.Functor模块中 void :: Functor f => f a -> f () void函数把一个函子内部的全部元素都变成空（()），void x相当于() &lt;$ x： 1234ghci&gt; void [1, 2, 3][(), (), ()]ghci&gt; void (Just 2)Just () Applicative Functor应用函子（Applicative Functor）是函子的升级版，它包含在Control.Applicative模块中。 fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义： 123class Functor f =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b 应用函子要求实现两个函数： pure :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just &lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。 Applicative Functor实例MaybeMaybe是一个应用函子： 1234instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something pure函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x &lt;*&gt;函数：将装有函数的函子中的函数应用另一个函子中 第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing 第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可 实际应用的例子： 12345678ghci&gt; Just (+3) &lt;*&gt; Just 9Just 12ghci&gt; pure (+3) &lt;*&gt; Just 9Just 12ghci&gt; (+3) &lt;$&gt; Just 9Just 12ghci&gt; Nothing &lt;*&gt; Just 9Nothing 第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12 第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了 而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如： 1234ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9Just 12ghci&gt; pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5Just 12 &lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12: 12345 pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5= (pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3) &lt;*&gt; Just 4 &lt;*&gt; Just 5= (Just (\\y z -&gt; 3 + y + z) &lt;*&gt; Just 4) &lt;*&gt; Just 5= Just (\\z -&gt; 3 + 4 + z) &lt;*&gt; Just 5 = Just (+7) &lt;*&gt; Just 5= Just 12 所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。 而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是： f x y ... []列表也是一个应用函子： 123instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs] pure函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x] &lt;*&gt;函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表 使用例子： 1234ghci&gt; [(+3), (*2)] &lt;*&gt; [1, 2][4,5,2,4]ghci&gt; [(+), (*)] &lt;*&gt; [1, 2] &lt;*&gt; [3, 4] [4, 5, 5, 6, 3, 4, 6, 8] IO123456instance Applicative IO where pure = return a &lt;*&gt; b = do f &lt;- a x &lt;- b return (f x) 也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子 1234ghci&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLineLine1Line2&quot;Line1Line2&quot; (-&gt;) r(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名： :: f (a -> b) -> f a -> f b 其中f为(-&gt;) r，将其代入并替换为中缀： :: (r -> a -> b) -> (r -> a) -> (r -> b) 可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b) 那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是： \\x -> f x (g x) 于是： 123instance Applicative ((-&gt;) r) where pure x = (\\_ -&gt; x) f &lt;*&gt; g = \\x -&gt; f x (g x) 将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x 应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子： 12ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5508 执行这句时发生了什么？： 12345678 (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5= ((+) &lt;$&gt; (+3)) &lt;*&gt; (*100) $ 5= ((+) . (+3)) &lt;*&gt; (*100) $ 5 = (\\a -&gt; (+) ((+3) a)) &lt;*&gt; (*100) $ 5= (\\a b -&gt; (a + 3 + b)) &lt;*&gt; (*100) $ 5= (\\x -&gt; x + 3 + ((*100) x)) $ 5= (\\x -&gt; x + 3 + x * 100) $ 5= 5 + 3 + 5 * 100 = 508= (5 + 3) + (5 * 100) 所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+) 同样： 12ghci&gt; (\\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5 [8.0,10.0,2.5] 先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\\x y z -&gt; [x,y,z])得到了最终的结果 12 f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i= (\\x -&gt; f (g x) (h x) (i x)) ZipList普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在Control.Applicative模块中 123instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith ($) fs xs) 但是ZipList并不是Show的实例，所以不能直接显示出来，要使用getZipList来获取它内部的列表： 1234ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..] [101,102,103]ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList &quot;dog&quot; &lt;*&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot; [('d','c','r'),('o','a','a'),('g','t','t')] Applicative Functor Laws应用函子一般有四个定律，都是保证pure的正确性的： Identity law：pure id &lt;*&gt; v = v Homomorphism：pure f &lt;*&gt; pure x = pure (f x) Interchange：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u Composition：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w Intuition理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：$$[[\\ \\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ \\ ]]$$ 其中$x_i$的类型是$f\\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是： $$t_1\\to t_2\\to\\cdots\\to t_n\\to t$$ 所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\\ x_1$结果的类型是： $$f\\ \\ (t_2\\to t_3\\to\\cdots\\to t_n\\to t)$$ 但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ ]]$，只需要： g x1 x2 ... xn 而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算： g x1 pure x2 ... xn 常用函数liftA &amp; liftA2 &amp; liftA3liftA :: Applicative f => (a -> b) -> f a -> f b liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d 不难推测liftA就是fmap，liftA2 f x1 x2相当于f &lt;$&gt; x1 &lt;*&gt; x2，liftA3 f x1 x2 x3相当于f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3 &lt;* &amp; *&gt;类型类似函子的&lt;$和$&gt;： (&lt;*) :: Applicative f => f a -> f b -> f a (*>) :: Applicative f => f a -> f b -> f b &lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来 12345678910111213141516ghci&gt; Just 3 &lt;* Just 4Just 3ghci&gt; Just 3 *&gt; Just 4Just 4ghci&gt; Nothing &lt;* Just 3Nothingghci&gt; Nothing *&gt; Just 3Nothingghci&gt; [1, 2, 3] &lt;* [3, 4][1,1,2,2,3,3]ghci&gt; [1, 2, 3] *&gt; [3, 4][3,4,3,4,3,4]ghci&gt; [] &lt;* [1, 2, 3][]ghci&gt; [] *&gt; [1, 2, 3][] &lt;**&gt;(**) :: Applicative f => f a -> f (a -> b) -> f b 接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用： 123456ghci&gt; [(+1), (+2), (+3)] &lt;*&gt; [1, 2][2,3,3,4,4,5]ghci&gt; [1, 2] &lt;**&gt; [(+1), (+2), (+3)][2,3,4,3,4,5]ghci&gt; flip(&lt;*&gt;) [1, 2] [(+1), (+2), (+3)][2,3,3,4,4,5] when &amp; unlesswhen :: Applicative f => Bool -> f () -> f () 传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过） unless则与when相反，测试为True返回pure () sequenceAsequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) 应用在列表上时，它的类型相当于： [f a] -> f [a] 所以在列表上它的使用方法： 12345678910ghci&gt; sequenceA [Just 3, Just 2, Just 1] Just [3,2,1] ghci&gt; sequenceA [Just 3, Nothing, Just 1] Nothing ghci&gt; sequenceA [(+3),(+2),(+1)] 3 [6,5,4] ghci&gt; sequenceA [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]] ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]] [] 它在对同一个参数应用不同函数时很有用： 1234ghci&gt; map (\\f -&gt; f 7) [(&gt;4), (&lt;10), odd] [True,True,True] ghci&gt; sequenceA [(&gt;4), (&lt;10), odd] 7 [True,True,True] Monad单子（Monad）是对Applicative Functor的扩展（但是诞生比Applicative早），Functor的&lt;$&gt;函数实现了将普通函数应用在上下文值上，Applicative的&lt;*&gt;函数将上下文中函数应用在上下文值上。而Monad提供了一个函数&gt;&gt;=（bind），将一个接收普通值返回上下文值的函数应用在上下文值上： 123456class Applicative m =&gt; Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b return :: a -&gt; m a m &gt;&gt; n = m &gt;&gt;= \\_ -&gt; n return = pure return函数：和pure一样，只是有另一个名字 &gt;&gt;函数：提供了默认的实现方法，它的作用和Applicative的*&gt;函数一样 &gt;&gt;=函数（bind）：比Applicative升级的函数，第一个参数是一个单子，第二个参数是一个接收值返回单子的函数，将这个函数应用在第一个参数单子中的值上，并返回得到的新单子 Monad实例MaybeMaybe是一个单子实例，Applicative已经为它实现了return，因此只需要&gt;&gt;=函数： 123instance Monad Maybe where (Just x) &gt;&gt;= f = f x Nothing &gt;&gt;= _ = Nothing 根据定义就很容易实现Maybe的&gt;&gt;=函数了，而且也很好理解 12345678ghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1)Just 2ghci&gt; Just 1 &gt;&gt;= \\x -&gt; return (x + 1)Just 2ghci&gt; Nothing &gt;&gt;= \\x -&gt; Just (x + 1)Nothingghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1) &gt;&gt; Nothing &gt;&gt;= \\y -&gt; Just (y + 1)Nothing 最后一个例子中出现了&gt;&gt; Nothing，这时Nothing前的部分全都相当于没用，因为&gt;&gt;操作符的左右两边只要有一个出现Nothing，那整体就会是Nothing。这个特性可以用于在中途随时判断失误，只要有一处失误，结果就会是Nothing []列表也是一个单子： 12instance Monad [] where xs &gt;&gt;= f = concat (map f xs) 将这个函数应用在xs的每个值上，将返回的所有列表平铺成一个列表： 1234ghci&gt; [3,4,5] &gt;&gt;= \\x -&gt; [x,-x] [3,-3,4,-4,5,-5] ghci&gt; [1,2] &gt;&gt;= \\n -&gt; ['a','b'] &gt;&gt;= \\ch -&gt; return (n,ch) [(1,'a'),(1,'b'),(2,'a'),(2,'b')] IOIO也是一个单子，但是实现方法比较深奥（逃 (-&gt;) r(-&gt;) r也是一个单子，和Functor、Applicative一样，先分析它的&gt;&gt;=类型签名： (>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b) 也可以看出来，它接收两个函数f :: r -&gt; a、g :: a -&gt; r -&gt; b，然后返回一个新的函数h :: r -&gt; b 那么函数h接收一个类型为r的参数，返回一个类型为b的值。所以先对输入应用f得到类型为a的中间值，然后再将这个值和输入参数一起传入函数g得到结果。所以函数h的定义应该是： \\x -> g (f x) x 12instance Monad ((-&gt;) r) where f &gt;&gt;= g = \\x -&gt; g (f x) x 1234ghci&gt; (+3) &gt;&gt;= (+) $ 15ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; id $ 15 do-notationHaskell的do语句为链式的&gt;&gt;=应用提供了类似命令式（imperative style）的语法糖。比如a &gt;&gt;= \\x -&gt; b &gt;&gt; c &gt;&gt;= \\y -&gt; d： 1234a &gt;&gt;= \\x -&gt;b &gt;&gt;c &gt;&gt;= \\y -&gt;d 其中有abcd四个值，可以看出a中内容绑定到了x上，c中内容绑定到了y上。使用do语句来表示这个操作可以写成： 12345do { x &lt;- a ; b ; y &lt;- c ; d } 其中的大括号和分号可以省略不写（挤在一行时不能省略）。do语句也只是一个语法糖，它可以递归地转换成普通的Monad操作语句： do e：e do { e; ... }：e &gt;&gt; do { … } do { v &lt;- e; ... }：e &gt;&gt;= \\v -&gt; do { … } do { let ...; ... }：let … in do { … } ApplicativeDo比如如下一个do语句： 1234do x &lt;- a y &lt;- b z &lt;- c return (f x y z) 它可以转化成： a >>= \\x -> b >>= \\y -> c >>= \\z -> return (f x y z) 但是经过观察可以发现，整个语句实际上将函数f应用在了三个上下文中的值上，所以仅用Applicative的&lt;$&gt;和&lt;*&gt;完全可以实现： f a b c 而且在运行的时候Applicative的效率会比Monad高，所以Haskell会将do语句尽可能优先转换为Applicative的表示方法然后再计算 Monad Laws Left identity： return a &gt;&gt;= k = k a Right identity：m &gt;&gt;= return = m Associativity：(m &gt;&gt;= g) &gt;&gt;= h = m &gt;&gt;= (\\x -&gt; g x &gt;&gt;= h) 前两个定律很好理解： 将a注入上下文之后绑定（bind）给函数k(:: a -&gt; m a)，相当于直接将a直接传入函数k 将已经包含在上下文中的值绑定给return函数，相当于保持不变 第三个定律是结合律，把它写成更像结合律的表示方法是： (m >>= (\\x -> g x)) >>= h = m >>= (\\x -> g x >>= h) 组合运算符（&gt;=&gt;）形式Control.Monad模块中还定义了函数&gt;=&gt;（Kleisli-composition operator）： 123infixr 1 &gt;=&gt;(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)f &gt;=&gt; g = \\x -&gt; f x &gt;&gt;= g 使用&gt;=&gt;运算符可以将两个用于绑定的函数结合在一起。用它表示的Monad定律更加清晰直观： Left identity：return &gt;=&gt; f = f Right identity：f &gt;=&gt; return = f Associativity：(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h) do-notation形式Monad的这三个定律还可以使用do语句来描述： Left identity： 123do { x' &lt;- return x; f x' = do { f x } } Right identity： 123do { x &lt;- m; return x = do { m } } Associativity： 12345do { y &lt;- do { x &lt;- m; do { x &lt;- m; do { x &lt;- m; f x do { y &lt;- f x; y &lt;- f x; } = g y = g y g y } } } } IntuitionMonad也可以很自然地看成Applicative的升级版，比如Applicative的操作全部是固定的，而Monad的操作可以在中途突然改变 同时Monad也完成了Functor和Applicative无法完成的操作。比如要用fmap和实现&gt;&gt;=函数（即达成操作 m a -&gt; (a -&gt; m b) -&gt; m b），先假设 f :: a -&gt; m b，那么fmap f的类型就会是 m a -&gt; m (m b)，将m a应用在fmap f上会得到结果m (m b)，而不是m b。但是目前只可以使用pure将一个值装入上下文中（a -&gt; m a），而没有一个函数可以从上下文中提取值（m a -&gt; a）。那么就需要定义一个新的函数来实现这个操作的效果（m (m b) -&gt; m b）。因此Monad的另一个等效的定义方法是： 12345class Applicative m =&gt; Monad' m where join :: m (m a) -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x 但是\b定义&gt;&gt;=函数会更为直观方便，所以Haskell采用了用&gt;&gt;=函数定义Monad的方法 同时Haskell还提供了join函数的定义： 12join :: Monad m =&gt; m (m a) -&gt; m a join x = x &gt;&gt;= id 常用函数liftM &amp; apliftM :: Monad m => (a -> b) -> m a -> m b ap :: Monad m => m (a -> b) -> m a -> m b 所以liftM其实就是fmap、ap就是&lt;*&gt;，但是老版本的GHC定义Monad并没有Functor、Applicative的约束，所以实现了liftM、ap，并且保留了这个名字 因此一个单子也可以通过pure = return、(&lt;*&gt;) = ap直接成为应用函子的实例 sequencesequence :: Monad m => [m a] -> m [a] sequence的作用显而易见，而且在IO部分也使用到了。但是这个版本是在GHC.Base模块中定义的，还有一个更广泛的使用Traversable的定义在Data.Traversable模块中 replicateMreplicateM :: Applicative m => Int -> m a -> m [a] mapM &amp; forMmapM :: Monad m => (a -> m b) -> [a] -> m [b] forM :: Monad m => [a] -> (a -> m b) -> m [b] forM的用法在IO部分已经说过，mapM和forM都在Data.Traversable模块中有广泛版本 还有一些其他的函数：filterM、zipWithM、foldM、forever，通过名字就可以看出用法，是将原来仅使用与列表的函数提升至可以适用于所有单子 并且在函数名后加下划线，比如sequence_、mapM_，会忽略返回值（最终结果为m ()） =&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;（&gt;=&gt;操作符在上面Monad Laws部分已经给出了定义） x &gt;&gt;= f = f =&lt;&lt; x f &gt;=&gt; g = g &lt;=&lt; f MonadFailMonadFail定义在Control.Monad.Fail模块中： 12class Monad m =&gt; MonadFail m where fail :: String -&gt; m a 它只要求在Monad的基础上实现fail函数，接收一个字符串返回一个单子。这会使在do语句中产生错误时直接变为错误值（空值）使最终的返回值为错误值 MonadFail实例12345678instance MonadFail Maybe where fail _ = Nothinginstance MonadFail [] where fail _ = []instance MonadFail IO where fail = failIO Maybe和[]的fail函数都与第一个参数无关，直接返回空值（Nothing、[]）；而IO的fail函数直接使用failIO，实现方法也是深奥（接着逃 1234567exampleFail :: Maybe Char exampleFail = do (x:xs) &lt;- Just &quot;&quot; return x ghci&gt; exampleFailNothing 在这个例子的do语句中，在提取Just “”中的值时用了模式匹配，但是因为其内容为空字符串，x:xs匹配会出现错误，这时就会触发fail函数直接返回Nothing MonadFail Law fail s &gt;&gt;= m = fail s Semigroup半群（semigroup）是一个集合$S$，它需要指定一个二元运算符$\\oplus$，并且满足 $$a\\oplus b \\in S\\quad a, b\\in S$$ 以及结合（associative）律： $$(a\\oplus b)\\oplus c = a\\oplus (b\\oplus c)$$ 这个二元运算符在Haskell的Semigroup中被定义为&lt;&gt;函数： 12345678910class Semigroup a where (&lt;&gt;) :: a -&gt; a -&gt; a sconcat :: NonEmpty a -&gt; a sconcat (a :| as) = go a as where go b (c:cs) = b &lt;&gt; go c cs go b [] = b stimes :: Integarl b =&gt; b -&gt; a -&gt; a stimes = ... 除此之外还有sconcat和stimes函数，都给出了默认实现。对于列表，&lt;&gt;相当于(++)，stimes相当于concat . replicate： 123456ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; sconcat $ fromList [[1, 2], [3, 4]][1,2,3,4]ghci&gt; stimes 3 [1, 2][1,2,1,2,1,2] Semigroup Law (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) 补：NonEmptyNonEmpty表示非空列表，定义是： 1data NonEmpty a = a :| [a] deriving (Eq, Ord) 使用一个元素和一个列表用:|连接就可以生成一个NonEmpty类型的列表 Data.List.NonEmpty模块中实现了很多普通列表有的函数，需要qualified import后调用，使用fromList、toList函数可以在普通列表和非空列表之间转换 12345678ghci&gt; import qualified Data.List.NonEmpty as NEghci&gt; arr = NE.fromList [1, 2, 3]ghci&gt; arr1 :| [2,3]ghci&gt; NE.head arr 1ghci&gt; NE.tail arr [2,3] Monoid幺半群（Monoid）是一个有单位元素$e$的半群，即$e$满足： $$e\\oplus x = x\\oplus e = x$$ 12345678class Semigroup a =&gt; Monoid a where mempty :: a mappend :: a -&gt; a -&gt; a mappend = (&lt;&gt;) mconcat :: [a] -&gt; a mconcat = foldr mappend mempty 可以看出Monoid要求了三个函数，其中最少只需要mempty，它直接返回一个值，表示单位元素。mappend即Semigroup中的&lt;&gt;运算符，mconcat也提供了默认实现 实例[a]因为Monoid的实例是一个具体类型，而不是像Functor等一样等类型构造器，所以[]并不是Monoid的实例，但是具体类型[a]是一个幺半群： 123456instance Semigroup [a] where (&lt;&gt;) = (++)instance Monoid [a] where mempty = [] mconcat xss = [x | xs &lt;- xss, x &lt;- xs] 列表的单位元素(mempty)就是空列表[]，运算符就是合并列表(++)，mconcat也用列表推导重新实现提高效率 12345678ghci&gt; mempty :: [Int] []ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; [1, 2] `mappend` [3, 4][1,2,3,4]ghci&gt; mconcat [[1,2], [3,4]][1,2,3,4] Ordering1234567instance Semigroup Ordering where LT &lt;&gt; _ = LT EQ &lt;&gt; y = y GT &lt;&gt; _ = GTinstance Monoid Ordering where mempty = EQ 主要可以用于比较字典序： 12ghci&gt; mconcat (zipWith compare &quot;abcd&quot; &quot;acbd&quot;)LT Sum &amp; Product对于数字，加法和乘法都满足结合律，所以对于Num，有两种实现Monoid的方式，但是不能为同一类型设置两种实例方式，所以Data.Monoid中提供了两个包装器————Sum和Product： 12newtype Sum a = Sum {getSum :: a} deriving (...)newtype Product a = Product {getProduct :: a} deriving (...) 它们使用Sum或Product来包装起一个数字，可以通过getSum或getProduct来获取其中的值 对于加法，二元操作为(+)，单位元素为0；对于乘法，二元操作为(*)，单位元素为1: 1234567891011instance Num a =&gt; Semigroup (Sum a) where (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Sum a) where mempty = Sum 0instance Num a =&gt; Semigroup (Product a) where (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Product a) where mempty = Product 1 12345678ghci&gt; Sum 5 &lt;&gt; Sum 6 &lt;&gt; Sum 10Sum {getSum = 21}ghci&gt; getSum . mconcat . fmap Sum $ [5, 6, 10]21ghci&gt; Product 5 &lt;&gt; Product 6 &lt;&gt; Product 10Product {getProduct = 300}ghci&gt; getProduct . mconcat . fmap Product $ [5, 6, 10]300 All &amp; Any和数字一样，布尔值也有两种实现Monoid的方式，因此Data.Monoid模块中也提供了两个包装器，分别实现了这两种Monoid： 12345678910111213141516newtype All = All { getAll :: Bool } deriving (...)instance Semigroup All where (&lt;&gt;) = coerce (&amp;&amp;)instance Monoid All where mempty = All Truenewtype Any = Any { getAny :: Bool } deriving (...)instance Semigroup Any where (&lt;&gt;) = coerce (||)instance Monoid Any where mempty = Any False 12345678ghci&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)Falseghci&gt; getAll (mconcat (map (\\x -&gt; All (even x)) [2,4,6,7,8]))Falseghci&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)Trueghci&gt; getAny (mconcat (map (\\x -&gt; Any (even x)) [2,4,6,7,8]))True Monoid a =&gt; Maybe a如果a是一个(幺)半群，那么Maybe a也是一个幺半群，单位元就是Nothing： 1234567instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b a &lt;&gt; Nothing = a Just a &lt;&gt; Just b = Just (a &lt;&gt; b)instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing 123456ghci&gt; Nothing &lt;&gt; Just &quot;andy&quot;Just &quot;andy&quot;ghci&gt; Just LT &lt;&gt; NothingJust LTghci&gt; Just (Sum 3) &lt;&gt; Just (Sum 4) Just (Sum {getSum = 7}) First &amp; Last对于Maybe也有两种实现Monoid的方法，即&lt;&gt;操作每次恒取左边和每次恒取右边（在没有Nothing的情况下），所以Data.Monoid模块中也提供了两个新的包装器：First和Last： 12345678910111213141516171819newtype First a = First { getFirst :: Maybe a } deriving (...)instance Semigroup (First a) where First Nothing &lt;&gt; b = b a &lt;&gt; _ = ainstance Monoid (First a) where mempty = First Nothing-- &gt;&gt;&gt; getLast (Last (Just &quot;hello&quot;) &lt;&gt; Last Nothing &lt;&gt; Last (Just &quot;world&quot;))-- Just &quot;world&quot;newtype Last a = Last { getLast :: Maybe a } deriving (...)instance Semigroup (Last a) where a &lt;&gt; Last Nothing = a _ &lt;&gt; b = binstance Monoid (Last a) where mempty = Last Nothing 12345678ghci&gt; getFirst (First (Just &quot;hello&quot;) &lt;&gt; First Nothing &lt;&gt; First (Just &quot;world&quot;))Just &quot;hello&quot;ghci&gt; getLast (Last (Just &quot;hello&quot;) &lt;&gt; Last Nothing &lt;&gt; Last (Just &quot;world&quot;))Just &quot;world&quot;ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10] Just 9ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10] Just 10 Min &amp; Max对于有界的类型，也有两种实现Monoid的方式，每次二元操作都取最小或最大。Data.Semigroup模块中提供了两个包装其器：Min和Max： 12345678910111213141516newtype Min a = Min { getMin :: a } deriving (...)instance Ord a =&gt; Semigroup (Min a) where (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Min a) where mempty = maxBoundnewtype Max a = Max { getMax :: a } deriving (...)instance Ord a =&gt; Semigroup (Max a) where (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Max a) where mempty = minBound 12345678ghci&gt; Min 3 &lt;&gt; Min 5Min {getMin = 3}ghci&gt; Max 3 &lt;&gt; Max 5Max {getMax = 5}ghci&gt; getMin . mconcat . map Min $ [1,2,3] :: Int1ghci&gt; getMax . mconcat . map Max $ [1,2,3] :: Int3 元组当元组内的所有元素都是幺半群时，整个元组也是一个幺半群： 123456instance (Semigroup a, Semigroup b) =&gt; Semigroup (a, b) where (a,b) &lt;&gt; (a',b') = (a&lt;&gt;a',b&lt;&gt;b') stimes n (a,b) = (stimes n a, stimes n b)instance (Monoid a, Monoid b) =&gt; Monoid (a,b) where mempty = (mempty, mempty) 12ghci&gt; mconcat $ map (\\x -&gt; (Min x, Max x)) [1..10] :: (Min Int, Max Int)(Min {getMin = 1},Max {getMax = 10}) Monoid Laws mempty &lt;&gt; x = x x &lt;&gt; mempty = x (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) Monoidal classesApplicative、Monad、Arrow都有有幺半群性质的子类型类，分别是Alternative、MonadPlus、ArrowPlus Alternative12345678910class Applicative f =&gt; Alternative f where -- | The identity of '&lt;|&gt;' empty :: f a -- | An associative binary operation (&lt;|&gt;) :: f a -&gt; f a -&gt; f a some :: f a -&gt; f [a] some v = (:) &lt;$&gt; v &lt;*&gt; many v many :: f a -&gt; f [a] many v = some v &lt;|&gt; pure [] 其中empty是幺半群中的单位元素，&lt;|&gt;是幺半群中的二元运算符。some和many是两个函数（意义还不懂） Alternative实例[]123instance Alternative [] where empty = [] (&lt;|&gt;) = (++) 和Monoid一样，单位元素是空列表，二元运算是列表合并 123456ghci&gt; [1,2,3] &lt;|&gt; empty &lt;|&gt; [4,5][1,2,3,4,5]ghci&gt; some [][]ghci&gt; many [][[]] Maybe1234instance Alternative Maybe where empty = Nothing Nothing &lt;|&gt; r = r l &lt;|&gt; _ = l Maybe作为Alternative的单位元素是Nothing，二元运算是始终取左边（当左边不为Nothing时） 123456ghci&gt; Nothing &lt;|&gt; Just 1 &lt;|&gt; Just 2 Just 1 ghci&gt; some NothingNothing ghci&gt; many Nothing Just [] ZipList123instance Alternative ZipList where empty = ZipList [] ZipList xs &lt;|&gt; ZipList ys = ZipList (xs ++ drop (length xs) ys) 1234&lt;&gt;getZipList $ ZipList [1,2] &lt;|&gt; ZipList [3,4,5,6][1,2,5,6]&lt;&gt;getZipList $ ZipList [1,2,3,4] &lt;|&gt; ZipList [3,4,5,6][1,2,3,4] Alternative Laws Monoid laws: 123empty &lt;|&gt; x = x x &lt;|&gt; empty = x (x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z) Left zero law：empty &lt;*&gt; f = empty以上的定律是都满足都，下面的定律只有部分满足： Right zero law：f &lt;*&gt; empty = empty （大部分包括Maybe、[]满足，IO不满足） Left distribution：(a &lt;|&gt; b) &lt;*&gt; c = (a &lt;*&gt; c) &lt;|&gt; (b &lt;*&gt; c) （Maybe、[]满足，IO及大部分parsers不满足） Right distribution：a &lt;*&gt; (b &lt;|&gt; c) = (a &lt;*&gt; b) &lt;|&gt; (a &lt;*&gt; c) （大部分不满足，但Maybe满足） Left catch：(pure a) &lt;|&gt; x = pure a （Maybe、IO、parsers满足，但[]不满足） 常用函数 asum :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a，相当于foldr (&lt;|&gt;) empty： 1234ghci&gt; asum [Nothing, Just 5, Just 3]Just 5ghci&gt; asum [[2],[3],[4,5]][2,3,4,5] guard :: (Alternative f) =&gt; Bool -&gt; f ()： 12guard True = pure ()guard False = empty MonadPlus123456class (Alternative m, Monad m) =&gt; MonadPlus m where mzero :: m a mzero = empty mplus :: m a -&gt; m a -&gt; m a mplus = (&lt;|&gt;) MonadPlus实例[]、Maybe都是MonadPlus的实例，mzero和mplus都由Alternative实现 MonadPlus Laws Monoid laws Left zero：mzero &gt;&gt;= f = mzero Right zero：m &gt;&gt; mzero = mzero 常用函数 msum = asum mfilter： 123mfilter p ma = do a &lt;- ma if p a then return a else mzero ArrowPlusArrowZero和ArrowPlus分别为Arrow设置了Monoid中的单位元素和二元运算符，使之成为了一个幺半群： 12345class Arrow arr =&gt; ArrowZero arr where zeroArrow :: b `arr` cclass ArrowZero arr =&gt; ArrowPlus arr where (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c) Haskell与范畴论Haskell中的函子单子等都与范畴论（category theory）有很多联系，所以打算简单了解一下范畴论的相关内容。 范畴论是数学的一门学科，以抽象的方法处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。数学中许多重要的领域可以形式化为范畴。使用范畴论可以令这些领域中许多难理解、难捉摸的数学结论更容易叙述证明。 ———— 维基百科 范畴（Category）范畴本质上是一个简单的集合，一个范畴$\\mathbf{C}$包含三个组成成分： 一个类$\\mathrm{ob}(\\mathbf{C})$：其中元素称为对象（objects） 一个类$\\mathrm{hom}(\\mathbf{C})$：其中元素称为态射（morphisms）（或箭号（arrows））：每个态射连接了两个对象：源对象（source object）、目标对象（target object）。如果$f$是从源对象$A$到目标对象$B$（$A, B\\in \\mathrm{ob}(\\mathbf{C})$）的态射，那么记为$f : A\\to B$ 一个二元运算，称为态射复合（composition）：两个态射$g : A\\to B$、$f : B\\to C$的复合记为$f\\circ g : A\\to C$在Haskell和大部分数学理论中都是从右向左计算，即$f\\circ g$中是先计算$g : A\\to B$再计算$f : B\\to C$ 许多东西都可以组成范畴。比如: &emsp;$\\mathbf{Set}$是一个范畴，对象为所有集合，态射为集合之间的函数，复合即函数之间的复合 &emsp;$\\mathbf{Grp}$是一个范畴，对象为所有群，态射为群同态（group homomorphisms），例如对于群$(G,*)$和$(H,\\cdot )$，有群同态$h : (G,*)\\to (H,\\cdot )$，则需要对于$G$中的任意元素$u,v$满足$$h(u*v)=h(u)\\cdot h(v)$$ 注意：态射不必须为函数；而且可以存在源对象和目标对象都相同的不同态射 范畴公理每个范畴都需要满足三条定律： 态射复合需要满足结合律（associativity）：$$f\\circ (g\\circ h) = (f\\circ g)\\circ h$$ 范畴在复合操作下是闭合的（closed）：&emsp;&emsp;&emsp;如果范畴$\\mathbf{C}$中存在态射$f : B\\to C$、$g : A\\to B$，那么范畴$\\mathbf{C}$中也一定存在态射$h : A\\to C$，且$h=f\\circ g$ 每个对象都需要有单位态射（identity morphisms）：&emsp;&emsp;&emsp;对于范畴$\\mathbf{C}$中的对象$A$，一定存在单位态射$\\mathrm{id}_A : A\\to A$，且对于每个态射$g : A\\to B$，一定有：$$g\\circ\\mathrm{id}_A = \\mathrm{id}_B\\circ g = g$$ $\\mathbf{Hask}$范畴范畴$\\mathbf{Hask}$的对象为Haskell中的类型（types），态射是Haskell中的函数，复合运算是(.)。即从类型A到类型B的函数 f :: A -&gt; B 就是$\\mathbf{Hask}$范畴中的一个态射。而函数 f :: B -&gt; C 、g :: A -&gt; B 的组合 f . g 就是一个新的函数 h :: A -&gt; C。 对于三条定律： 第一条显然满足：f . (g . h) = (f . g) . h 第二条也显然满足，如果有函数 f :: B -&gt; C 、g :: A -&gt; B，一定有函数 h = (f . g) :: A -&gt; C 对于第三条定律，Haskell中存在单位函数 id ，但id是多态（polymorphic）的，要为其指定类型使其变成单态（monomorphic）的。比如态射$\\mathrm{id}_A$在Haskell中就可以表示为 id :: A -&gt; A。并且显然满足第三条定律（其中 f :: A -&gt; B）：(id :: B -> B) . f = f . (id :: A -> A) = f 函子（Functors）一个范畴中的态射将两个对象联系起来，而函子则会将两个范畴联系起来。换句话说，函子就是从一个范畴到另一个范畴的变换。比如对于范畴$\\mathbf{C}$、$\\mathbf{D}$，定义函子$F : \\mathbf{C}\\to\\mathbf{D}$满足： 对于$\\mathbf{C}$中的任意对象$A$，在$\\mathbf{D}$中都有对象$F(A)$ 对于$\\mathbf{C}$中的任意态射$f : A\\to B$，在$\\mathbf{D}$中都有态射$F(f) : F(A)\\to F(B)$ 比如： &emsp;遗忘函子（forgetful functor）$U : \\mathbf{Grp}\\to\\mathbf{Set}$，将一个群映射到一个集合中，将群同态映射到集合间的函数 &emsp;幂集函子（power set functor）$P : \\mathbf{Set}\\to\\mathbf{Set}$，将一个集合映射到它的幂集，将原集合中的函数$f : A\\to B$映射到函数$P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$，即从$U\\subseteq A$到值域$f(U)\\subseteq B$的映射 &emsp;自函子（endofunctor）$1_{\\mathbf{C}} : \\mathbf{C}\\to\\mathbf{C}$，将一个范畴映射到它本身 函子公理函子$F : \\mathbf{C}\\to\\mathbf{D}$也需要满足两个公理： 对于任意对象$X\\in\\mathbf{C}$，恒有$F(\\mathrm{id}_X)=\\mathrm{id}_{F(X)}$ 对于态射$f : Y\\to Z$、$g : X\\to Y$，恒有$F(f\\circ g) = F(f)\\circ F(g)$ $\\mathbf{Hask}$范畴上的函子Haskell中的Functor定义是： 12class Functor (f :: * -&gt; *) where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 对于Haskell中的Functor，它实际上是从$\\mathbf{Hask}$范畴（types）到它子范畴的变换。比如列表函子$\\mathtt{[]} : \\mathbf{Hask}\\to\\mathbf{Lst}$（其中$\\mathbf{Lst}$是所有Haskell中列表类型构成的范畴） 它也达成了范畴论中对于函子的要求。函子需要进行两个操作：将一个范畴中的对象映射到另一个范畴中、将一个范畴中的态射映射到另一个范畴中。以Maybe为例，它实现了函子的要求： Maybe是一个类型构造器，他可以将任意类型 T 变成新类型 Maybe T，相当于从$\\mathbf{Hask}$范畴的对象变成了$\\mathbf{Maybe}$范畴的对象 fmap函数接收一个 a -&gt; b 类型的函数，返回一个 Maybe a -&gt; Maybe b 类型的函数，相当于将$\\mathbf{Hask}$范畴中的态射$f : A\\to B$映射成了$\\mathbf{Maybe}$范畴中的态射$\\mathbf{Maybe}(f) : \\mathbf{Maybe}(A)\\to\\mathbf{Maybe}(B)$ 注意：时刻记住这里研究的是$\\mathbf{Hask}$范畴和它的子范畴，对象是类型而不是值，态射是函数也指的是从类型到类型 同时，Haskell中的Functor也满足函子公理： fmap id = id 即 fmap (id :: A -&gt; A) = (id :: f A -&gt; f A) fmap (f . g) = fmap f . fmap g 单子（Monads） 一个单子说白了不过就是自函子范畴上的一个幺半群而已 _(:з」∠)_ 自函子在前面说到过是从一个范畴到自身的一个函子，如范畴$\\mathbf{C}$上的自函子是$F : \\mathbf{C}\\to\\mathbf{C}$。自函子范畴就是对象都是自函子的范畴。幺半群和Haskell中学到的Monoid类型类一样，是一个有可结合二元运算和单位元的代数结构。因此单子就是一个自函子，而且它有可结合二元运算（Haskell中&gt;=&gt;）和单位元（Haskell中return）。 一个单子$M : \\mathbf{C}\\to\\mathbf{C}$还包含两个态射（对于范畴$\\mathbf{C}$中的所有对象$X$）： $\\mathrm{unit}_X^M : X\\to M(X)$ $\\mathrm{join}_X^M : M(M(X))\\to M(X)$ （当式子中的单子明显是$M$时，可以省略上标${}^M$） Haskell中Monad的定义是： 123class Functor m =&gt; Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b 其中很显然多态函数return对应了定义中的$\\mathrm{unit}$，但是&gt;&gt;=和$mathrm{join}$的对应关系并不明显。因此Haskell中有一个工具函数join，它的效果就是定义中的$\\mathrm{join}$，而且它可以和&gt;&gt;=互相定义： 12345join :: Monad m =&gt; m (m a) -&gt; m ajoin x = x &gt;&gt;= id(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x 所以Haskell中为Monad要求定义&gt;&gt;=就相当于定义了$\\mathrm{join}$ 例如，幂集函子$P : \\mathbf{Set}\\to\\mathbf{Set}$也是一个单子，可以为它定义$\\mathrm{unit}$和$\\mathrm{join}$两个态射。Haskell中的列表也可以近似看作幂集函子。 &emsp;态射/函数的类型： 幂集函子 Haskell中列表 一个集合$S$和一个态射$f : A\\to B$ 一个类型 T 和一个函数 f :: A -&gt; B $P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$ fmap f :: [A] -&gt; [B] $\\mathrm{unit}_S : S\\to\\mathcal{P}(S)$ return :: T -&gt; [T] $\\mathrm{join}_S : \\mathcal{P}(\\mathcal{P}(S))\\to\\mathcal{P}(S)$ join :: [[T]] -&gt; [T] &emsp;态射/函数的定义： 幂集函子 Haskell中列表 $(\\mathcal{P}(f))(S) = \\{f(a):a\\in S\\}$ fmap f xs = [ f a | a &lt;- xs ] $\\mathrm{unit}_S(x) = \\{x\\}$ return x = [x] $\\mathrm{join}_S(L) = \\bigcup L$ join xs = concat xs 单子公理给定一个单子$M : \\mathbf{C}\\to\\mathbf{C}$，和一个态射$f : A\\to B$（其中$A,B\\in \\mathbf{C}$），那么满足下面四条定律： $\\mathrm{join}\\circ M(\\mathrm{join})=\\mathrm{join}\\circ\\mathrm{join}$ $\\mathrm{join}\\circ M(\\mathrm{unit})=\\mathrm{join}\\circ\\mathrm{unit}=\\mathrm{id}$ $\\mathrm{unit}\\circ f = M(f)\\circ\\mathrm{unit}$ $\\mathrm{join}\\circ M(M(f)) = M(f)\\circ\\mathrm{join}$ 也可以很自然地将其转化为Haskell中的表述： join . fmap join = join . join join . fmap return = join . return = id return . f = fmap f . return join . fmap (fmap f) = fmap f . join 在Haskell中，使用&gt;&gt;=也有三个定律和这四个定律是等价的： return x &gt;&gt;= f = f x 123456 return x &gt;&gt;= f = join (fmap f (return x)) = join (fmap f . return $ x)= join (return (f x)) = join (return . f $ x)= join . return $ (f x)= id (f x)= f x m &gt;&gt;= return = m1234 m &gt;&gt;= return = join (fmap return m) = join . fmap return $ m = id m= m (m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)123456789101112 (m &gt;&gt;= f) &gt;&gt;= g = (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))= join . fmap g . join $ fmap f m = join . join . fmap (fmap g) $ fmap f m = join . join . fmap (fmap g) . fmap f $ m = join . join . fmap (fmap g . f) $ m = join . fmap join . fmap (fmap g . f) $ m = join . fmap (join . (fmap g . f)) $ m = join . fmap (\\x -&gt; join (fmap g (f x))) $ m = join . fmap (\\x -&gt; f x &gt;&gt;= g) $ m = join (fmap (\\x -&gt; f x &gt;&gt;= g) m)= m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g) 有关do语句和&gt;=&gt;的公理表述在上文中已经说过 后记Reference Learn You a Haskell Writing foldl using foldr - StackOverflow Haskell：用foldr定义foldl Haskell wiki - Typeclassopedia Functors, Applicatives, And Monads In Pictures Haskell学习 - functor Haskell语言学习笔记（8）Monoid - zwvista Haskell语言学习笔记（16）Alternative - zwvista 未完待续","link":"/p/b3ca5c18.html"},{"title":"「Learn Haskell」#A Haskell与范畴论","text":"Haskell中的函子单子等都与范畴论（category theory）有很多联系，所以打算简单了解一下范畴论的相关内容。 范畴论是数学的一门学科，以抽象的方法处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。数学中许多重要的领域可以形式化为范畴。使用范畴论可以令这些领域中许多难理解、难捉摸的数学结论更容易叙述证明。 ———— 维基百科 范畴（Category）范畴本质上是一个简单的集合，一个范畴$\\mathbf{C}$包含三个组成成分： 一个类$\\mathrm{ob}(\\mathbf{C})$：其中元素称为对象（objects） 一个类$\\mathrm{hom}(\\mathbf{C})$：其中元素称为态射（morphisms）（或箭号（arrows））：每个态射连接了两个对象：源对象（source object）、目标对象（target object）。如果$f$是从源对象$A$到目标对象$B$（$A, B\\in \\mathrm{ob}(\\mathbf{C})$）的态射，那么记为$f : A\\to B$ 一个二元运算，称为态射复合（composition）：两个态射$g : A\\to B$、$f : B\\to C$的复合记为$f\\circ g : A\\to C$在Haskell和大部分数学理论中都是从右向左计算，即$f\\circ g$中是先计算$g : A\\to B$再计算$f : B\\to C$ 许多东西都可以组成范畴。比如: &emsp;$\\mathbf{Set}$是一个范畴，对象为所有集合，态射为集合之间的函数，复合即函数之间的复合 &emsp;$\\mathbf{Grp}$是一个范畴，对象为所有群，态射为群同态（group homomorphisms），例如对于群$(G,*)$和$(H,\\cdot )$，有群同态$h : (G,*)\\to (H,\\cdot )$，则需要对于$G$中的任意元素$u,v$满足$$h(u*v)=h(u)\\cdot h(v)$$ 注意：态射不必须为函数；而且可以存在源对象和目标对象都相同的不同态射 范畴公理每个范畴都需要满足三条定律： 态射复合需要满足结合律（associativity）：$$f\\circ (g\\circ h) = (f\\circ g)\\circ h$$ 范畴在复合操作下是闭合的（closed）：&emsp;&emsp;&emsp;如果范畴$\\mathbf{C}$中存在态射$f : B\\to C$、$g : A\\to B$，那么范畴$\\mathbf{C}$中也一定存在态射$h : A\\to C$，且$h=f\\circ g$ 每个对象都需要有单位态射（identity morphisms）：&emsp;&emsp;&emsp;对于范畴$\\mathbf{C}$中的对象$A$，一定存在单位态射$\\mathrm{id}_A : A\\to A$，且对于每个态射$g : A\\to B$，一定有：$$g\\circ\\mathrm{id}_A = \\mathrm{id}_B\\circ g = g$$ $\\mathbf{Hask}$范畴范畴$\\mathbf{Hask}$的对象为Haskell中的类型（types），态射是Haskell中的函数，复合运算是(.)。即从类型A到类型B的函数 f :: A -&gt; B 就是$\\mathbf{Hask}$范畴中的一个态射。而函数 f :: B -&gt; C 、g :: A -&gt; B 的组合 f . g 就是一个新的函数 h :: A -&gt; C。 对于三条定律： 第一条显然满足：f . (g . h) = (f . g) . h 第二条也显然满足，如果有函数 f :: B -&gt; C 、g :: A -&gt; B，一定有函数 h = (f . g) :: A -&gt; C 对于第三条定律，Haskell中存在单位函数 id ，但id是多态（polymorphic）的，要为其指定类型使其变成单态（monomorphic）的。比如态射$\\mathrm{id}_A$在Haskell中就可以表示为 id :: A -&gt; A。并且显然满足第三条定律（其中 f :: A -&gt; B）：(id :: B -> B) . f = f . (id :: A -> A) = f 函子（Functors）一个范畴中的态射将两个对象联系起来，而函子则会将两个范畴联系起来。换句话说，函子就是从一个范畴到另一个范畴的变换。比如对于范畴$\\mathbf{C}$、$\\mathbf{D}$，定义函子$F : \\mathbf{C}\\to\\mathbf{D}$满足： 对于$\\mathbf{C}$中的任意对象$A$，在$\\mathbf{D}$中都有对象$F(A)$ 对于$\\mathbf{C}$中的任意态射$f : A\\to B$，在$\\mathbf{D}$中都有态射$F(f) : F(A)\\to F(B)$ 比如： &emsp;遗忘函子（forgetful functor）$U : \\mathbf{Grp}\\to\\mathbf{Set}$，将一个群映射到一个集合中，将群同态映射到集合间的函数 &emsp;幂集函子（power set functor）$P : \\mathbf{Set}\\to\\mathbf{Set}$，将一个集合映射到它的幂集，将原集合中的函数$f : A\\to B$映射到函数$P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$，即从$U\\subseteq A$到值域$f(U)\\subseteq B$的映射 &emsp;自函子（endofunctor）$1_{\\mathbf{C}} : \\mathbf{C}\\to\\mathbf{C}$，将一个范畴映射到它本身 函子公理函子$F : \\mathbf{C}\\to\\mathbf{D}$也需要满足两个公理： 对于任意对象$X\\in\\mathbf{C}$，恒有$F(\\mathrm{id}_X)=\\mathrm{id}_{F(X)}$ 对于态射$f : Y\\to Z$、$g : X\\to Y$，恒有$F(f\\circ g) = F(f)\\circ F(g)$ $\\mathbf{Hask}$范畴上的函子Haskell中的Functor定义是： 12class Functor (f :: * -&gt; *) where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 对于Haskell中的Functor，它实际上是从$\\mathbf{Hask}$范畴（types）到它子范畴的变换。比如列表函子$\\mathtt{[]} : \\mathbf{Hask}\\to\\mathbf{Lst}$（其中$\\mathbf{Lst}$是所有Haskell中列表类型构成的范畴） 它也达成了范畴论中对于函子的要求。函子需要进行两个操作：将一个范畴中的对象映射到另一个范畴中、将一个范畴中的态射映射到另一个范畴中。以Maybe为例，它实现了函子的要求： Maybe是一个类型构造器，他可以将任意类型 T 变成新类型 Maybe T，相当于从$\\mathbf{Hask}$范畴的对象变成了$\\mathbf{Maybe}$范畴的对象 fmap函数接收一个 a -&gt; b 类型的函数，返回一个 Maybe a -&gt; Maybe b 类型的函数，相当于将$\\mathbf{Hask}$范畴中的态射$f : A\\to B$映射成了$\\mathbf{Maybe}$范畴中的态射$\\mathbf{Maybe}(f) : \\mathbf{Maybe}(A)\\to\\mathbf{Maybe}(B)$ 注意：时刻记住这里研究的是$\\mathbf{Hask}$范畴和它的子范畴，对象是类型而不是值，态射是函数也指的是从类型到类型 同时，Haskell中的Functor也满足函子公理： fmap id = id 即 fmap (id :: A -&gt; A) = (id :: f A -&gt; f A) fmap (f . g) = fmap f . fmap g 单子（Monads） 一个单子说白了不过就是自函子范畴上的一个幺半群而已 _(:з」∠)_ 自函子在前面说到过是从一个范畴到自身的一个函子，如范畴$\\mathbf{C}$上的自函子是$F : \\mathbf{C}\\to\\mathbf{C}$。自函子范畴就是对象都是自函子的范畴。幺半群和Haskell中学到的Monoid类型类一样，是一个有可结合二元运算和单位元的代数结构。因此单子就是一个自函子，而且它有可结合二元运算（Haskell中&gt;=&gt;）和单位元（Haskell中return）。 一个单子$M : \\mathbf{C}\\to\\mathbf{C}$还包含两个态射（对于范畴$\\mathbf{C}$中的所有对象$X$）： $\\mathrm{unit}_X^M : X\\to M(X)$ $\\mathrm{join}_X^M : M(M(X))\\to M(X)$ （当式子中的单子明显是$M$时，可以省略上标${}^M$） Haskell中Monad的定义是： 123class Functor m =&gt; Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b 其中很显然多态函数return对应了定义中的$\\mathrm{unit}$，但是&gt;&gt;=和$mathrm{join}$的对应关系并不明显。因此Haskell中有一个工具函数join，它的效果就是定义中的$\\mathrm{join}$，而且它可以和&gt;&gt;=互相定义： 12345join :: Monad m =&gt; m (m a) -&gt; m ajoin x = x &gt;&gt;= id(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x 所以Haskell中为Monad要求定义&gt;&gt;=就相当于定义了$\\mathrm{join}$ 例如，幂集函子$P : \\mathbf{Set}\\to\\mathbf{Set}$也是一个单子，可以为它定义$\\mathrm{unit}$和$\\mathrm{join}$两个态射。Haskell中的列表也可以近似看作幂集函子。 &emsp;态射/函数的类型： 幂集函子 Haskell中列表 一个集合$S$和一个态射$f : A\\to B$ 一个类型 T 和一个函数 f :: A -&gt; B $P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$ fmap f :: [A] -&gt; [B] $\\mathrm{unit}_S : S\\to\\mathcal{P}(S)$ return :: T -&gt; [T] $\\mathrm{join}_S : \\mathcal{P}(\\mathcal{P}(S))\\to\\mathcal{P}(S)$ join :: [[T]] -&gt; [T] &emsp;态射/函数的定义： 幂集函子 Haskell中列表 $(\\mathcal{P}(f))(S) = \\{f(a):a\\in S\\}$ fmap f xs = [ f a | a &lt;- xs ] $\\mathrm{unit}_S(x) = \\{x\\}$ return x = [x] $\\mathrm{join}_S(L) = \\bigcup L$ join xs = concat xs 单子公理给定一个单子$M : \\mathbf{C}\\to\\mathbf{C}$，和一个态射$f : A\\to B$（其中$A,B\\in \\mathbf{C}$），那么满足下面四条定律： $\\mathrm{join}\\circ M(\\mathrm{join})=\\mathrm{join}\\circ\\mathrm{join}$ $\\mathrm{join}\\circ M(\\mathrm{unit})=\\mathrm{join}\\circ\\mathrm{unit}=\\mathrm{id}$ $\\mathrm{unit}\\circ f = M(f)\\circ\\mathrm{unit}$ $\\mathrm{join}\\circ M(M(f)) = M(f)\\circ\\mathrm{join}$ 也可以很自然地将其转化为Haskell中的表述： join . fmap join = join . join join . fmap return = join . return = id return . f = fmap f . return join . fmap (fmap f) = fmap f . join 在Haskell中，使用&gt;&gt;=也有三个定律和这四个定律是等价的： return x &gt;&gt;= f = f x 123456 return x &gt;&gt;= f = join (fmap f (return x)) = join (fmap f . return $ x)= join (return (f x)) = join (return . f $ x)= join . return $ (f x)= id (f x)= f x m &gt;&gt;= return = m1234 m &gt;&gt;= return = join (fmap return m) = join . fmap return $ m = id m= m (m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)123456789101112 (m &gt;&gt;= f) &gt;&gt;= g = (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))= join . fmap g . join $ fmap f m = join . join . fmap (fmap g) $ fmap f m = join . join . fmap (fmap g) . fmap f $ m = join . join . fmap (fmap g . f) $ m = join . fmap join . fmap (fmap g . f) $ m = join . fmap (join . (fmap g . f)) $ m = join . fmap (\\x -&gt; join (fmap g (f x))) $ m = join . fmap (\\x -&gt; f x &gt;&gt;= g) $ m = join (fmap (\\x -&gt; f x &gt;&gt;= g) m)= m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g) （范畴论就先简单看这些，只是为了更好理解Haskell中概念而已） Reference Haskell/Category theory - wikibooks Category theory - wikipedia 范畴论 - 维基百科 Monad (category theory) - wikipedia Functor - wikipedia 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/96c32eae.html"},{"title":"「Learn Haskell」#6 半群与幺半群","text":"&lt; #5 未完待续 &gt; Semigroup半群（semigroup）是一个集合$S$，它需要指定一个二元运算符$\\oplus$，并且满足 $$a\\oplus b \\in S\\quad a, b\\in S$$ 以及结合（associative）律： $$(a\\oplus b)\\oplus c = a\\oplus (b\\oplus c)$$ 这个二元运算符在Haskell的Semigroup中被定义为&lt;&gt;函数： 12345678910class Semigroup a where (&lt;&gt;) :: a -&gt; a -&gt; a sconcat :: NonEmpty a -&gt; a sconcat (a :| as) = go a as where go b (c:cs) = b &lt;&gt; go c cs go b [] = b stimes :: Integarl b =&gt; b -&gt; a -&gt; a stimes = ... 除此之外还有sconcat和stimes函数，都给出了默认实现。对于列表，&lt;&gt;相当于(++)，stimes相当于concat . replicate： 123456ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; sconcat $ fromList [[1, 2], [3, 4]][1,2,3,4]ghci&gt; stimes 3 [1, 2][1,2,1,2,1,2] Semigroup Law (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) 补：NonEmptyNonEmpty表示非空列表，定义是： 1data NonEmpty a = a :| [a] deriving (Eq, Ord) 使用一个元素和一个列表用:|连接就可以生成一个NonEmpty类型的列表 Data.List.NonEmpty模块中实现了很多普通列表有的函数，需要qualified import后调用，使用fromList、toList函数可以在普通列表和非空列表之间转换 12345678ghci&gt; import qualified Data.List.NonEmpty as NEghci&gt; arr = NE.fromList [1, 2, 3]ghci&gt; arr1 :| [2,3]ghci&gt; NE.head arr 1ghci&gt; NE.tail arr [2,3] Monoid幺半群（Monoid）是一个有单位元素$e$的半群，即$e$满足： $$e\\oplus x = x\\oplus e = x$$ 12345678class Semigroup a =&gt; Monoid a where mempty :: a mappend :: a -&gt; a -&gt; a mappend = (&lt;&gt;) mconcat :: [a] -&gt; a mconcat = foldr mappend mempty 可以看出Monoid要求了三个函数，其中最少只需要mempty，它直接返回一个值，表示单位元素。mappend即Semigroup中的&lt;&gt;运算符，mconcat也提供了默认实现 实例[a]因为Monoid的实例是一个具体类型，而不是像Functor等一样等类型构造器，所以[]并不是Monoid的实例，但是具体类型[a]是一个幺半群： 123456instance Semigroup [a] where (&lt;&gt;) = (++)instance Monoid [a] where mempty = [] mconcat xss = [x | xs &lt;- xss, x &lt;- xs] 列表的单位元素(mempty)就是空列表[]，运算符就是合并列表(++)，mconcat也用列表推导重新实现提高效率 12345678ghci&gt; mempty :: [Int] []ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; [1, 2] `mappend` [3, 4][1,2,3,4]ghci&gt; mconcat [[1,2], [3,4]][1,2,3,4] Ordering1234567instance Semigroup Ordering where LT &lt;&gt; _ = LT EQ &lt;&gt; y = y GT &lt;&gt; _ = GTinstance Monoid Ordering where mempty = EQ 主要可以用于比较字典序： 12ghci&gt; mconcat (zipWith compare &quot;abcd&quot; &quot;acbd&quot;)LT Sum &amp; Product对于数字，加法和乘法都满足结合律，所以对于Num，有两种实现Monoid的方式，但是不能为同一类型设置两种实例方式，所以Data.Monoid中提供了两个包装器————Sum和Product： 12newtype Sum a = Sum {getSum :: a} deriving (...)newtype Product a = Product {getProduct :: a} deriving (...) 它们使用Sum或Product来包装起一个数字，可以通过getSum或getProduct来获取其中的值 对于加法，二元操作为(+)，单位元素为0；对于乘法，二元操作为(*)，单位元素为1: 1234567891011instance Num a =&gt; Semigroup (Sum a) where (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Sum a) where mempty = Sum 0instance Num a =&gt; Semigroup (Product a) where (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Product a) where mempty = Product 1 12345678ghci&gt; Sum 5 &lt;&gt; Sum 6 &lt;&gt; Sum 10Sum {getSum = 21}ghci&gt; getSum . mconcat . fmap Sum $ [5, 6, 10]21ghci&gt; Product 5 &lt;&gt; Product 6 &lt;&gt; Product 10Product {getProduct = 300}ghci&gt; getProduct . mconcat . fmap Product $ [5, 6, 10]300 All &amp; Any和数字一样，布尔值也有两种实现Monoid的方式，因此Data.Monoid模块中也提供了两个包装器，分别实现了这两种Monoid： 12345678910111213141516newtype All = All { getAll :: Bool } deriving (...)instance Semigroup All where (&lt;&gt;) = coerce (&amp;&amp;)instance Monoid All where mempty = All Truenewtype Any = Any { getAny :: Bool } deriving (...)instance Semigroup Any where (&lt;&gt;) = coerce (||)instance Monoid Any where mempty = Any False 12345678ghci&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)Falseghci&gt; getAll (mconcat (map (\\x -&gt; All (even x)) [2,4,6,7,8]))Falseghci&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)Trueghci&gt; getAny (mconcat (map (\\x -&gt; Any (even x)) [2,4,6,7,8]))True Monoid a =&gt; Maybe a如果a是一个(幺)半群，那么Maybe a也是一个幺半群，单位元就是Nothing： 1234567instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b a &lt;&gt; Nothing = a Just a &lt;&gt; Just b = Just (a &lt;&gt; b)instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing 123456ghci&gt; Nothing &lt;&gt; Just &quot;andy&quot;Just &quot;andy&quot;ghci&gt; Just LT &lt;&gt; NothingJust LTghci&gt; Just (Sum 3) &lt;&gt; Just (Sum 4) Just (Sum {getSum = 7}) First &amp; Last对于Maybe也有两种实现Monoid的方法，即&lt;&gt;操作每次恒取左边和每次恒取右边（在没有Nothing的情况下），所以Data.Monoid模块中也提供了两个新的包装器：First和Last： 12345678910111213141516171819newtype First a = First { getFirst :: Maybe a } deriving (...)instance Semigroup (First a) where First Nothing &lt;&gt; b = b a &lt;&gt; _ = ainstance Monoid (First a) where mempty = First Nothing-- &gt;&gt;&gt; getLast (Last (Just &quot;hello&quot;) &lt;&gt; Last Nothing &lt;&gt; Last (Just &quot;world&quot;))-- Just &quot;world&quot;newtype Last a = Last { getLast :: Maybe a } deriving (...)instance Semigroup (Last a) where a &lt;&gt; Last Nothing = a _ &lt;&gt; b = binstance Monoid (Last a) where mempty = Last Nothing 12345678ghci&gt; getFirst (First (Just &quot;hello&quot;) &lt;&gt; First Nothing &lt;&gt; First (Just &quot;world&quot;))Just &quot;hello&quot;ghci&gt; getLast (Last (Just &quot;hello&quot;) &lt;&gt; Last Nothing &lt;&gt; Last (Just &quot;world&quot;))Just &quot;world&quot;ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10] Just 9ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10] Just 10 Min &amp; Max对于有界的类型，也有两种实现Monoid的方式，每次二元操作都取最小或最大。Data.Semigroup模块中提供了两个包装其器：Min和Max： 12345678910111213141516newtype Min a = Min { getMin :: a } deriving (...)instance Ord a =&gt; Semigroup (Min a) where (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Min a) where mempty = maxBoundnewtype Max a = Max { getMax :: a } deriving (...)instance Ord a =&gt; Semigroup (Max a) where (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Max a) where mempty = minBound 12345678ghci&gt; Min 3 &lt;&gt; Min 5Min {getMin = 3}ghci&gt; Max 3 &lt;&gt; Max 5Max {getMax = 5}ghci&gt; getMin . mconcat . map Min $ [1,2,3] :: Int1ghci&gt; getMax . mconcat . map Max $ [1,2,3] :: Int3 元组当元组内的所有元素都是幺半群时，整个元组也是一个幺半群： 123456instance (Semigroup a, Semigroup b) =&gt; Semigroup (a, b) where (a,b) &lt;&gt; (a',b') = (a&lt;&gt;a',b&lt;&gt;b') stimes n (a,b) = (stimes n a, stimes n b)instance (Monoid a, Monoid b) =&gt; Monoid (a,b) where mempty = (mempty, mempty) 12ghci&gt; mconcat $ map (\\x -&gt; (Min x, Max x)) [1..10] :: (Min Int, Max Int)(Min {getMin = 1},Max {getMax = 10}) Monoid Laws mempty &lt;&gt; x = x x &lt;&gt; mempty = x (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) Monoidal classesApplicative、Monad、Arrow都有有幺半群性质的子类型类，分别是Alternative、MonadPlus、ArrowPlus Alternative12345678910class Applicative f =&gt; Alternative f where -- | The identity of '&lt;|&gt;' empty :: f a -- | An associative binary operation (&lt;|&gt;) :: f a -&gt; f a -&gt; f a some :: f a -&gt; f [a] some v = (:) &lt;$&gt; v &lt;*&gt; many v many :: f a -&gt; f [a] many v = some v &lt;|&gt; pure [] 其中empty是幺半群中的单位元素，&lt;|&gt;是幺半群中的二元运算符。some和many是两个函数（意义还不懂） Alternative实例[]123instance Alternative [] where empty = [] (&lt;|&gt;) = (++) 和Monoid一样，单位元素是空列表，二元运算是列表合并 123456ghci&gt; [1,2,3] &lt;|&gt; empty &lt;|&gt; [4,5][1,2,3,4,5]ghci&gt; some [][]ghci&gt; many [][[]] Maybe1234instance Alternative Maybe where empty = Nothing Nothing &lt;|&gt; r = r l &lt;|&gt; _ = l Maybe作为Alternative的单位元素是Nothing，二元运算是始终取左边（当左边不为Nothing时） 123456ghci&gt; Nothing &lt;|&gt; Just 1 &lt;|&gt; Just 2 Just 1 ghci&gt; some NothingNothing ghci&gt; many Nothing Just [] ZipList123instance Alternative ZipList where empty = ZipList [] ZipList xs &lt;|&gt; ZipList ys = ZipList (xs ++ drop (length xs) ys) 1234&lt;&gt;getZipList $ ZipList [1,2] &lt;|&gt; ZipList [3,4,5,6][1,2,5,6]&lt;&gt;getZipList $ ZipList [1,2,3,4] &lt;|&gt; ZipList [3,4,5,6][1,2,3,4] Alternative Laws Monoid laws: 123empty &lt;|&gt; x = x x &lt;|&gt; empty = x (x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z) Left zero law：empty &lt;*&gt; f = empty以上的定律是都满足都，下面的定律只有部分满足： Right zero law：f &lt;*&gt; empty = empty （大部分包括Maybe、[]满足，IO不满足） Left distribution：(a &lt;|&gt; b) &lt;*&gt; c = (a &lt;*&gt; c) &lt;|&gt; (b &lt;*&gt; c) （Maybe、[]满足，IO及大部分parsers不满足） Right distribution：a &lt;*&gt; (b &lt;|&gt; c) = (a &lt;*&gt; b) &lt;|&gt; (a &lt;*&gt; c) （大部分不满足，但Maybe满足） Left catch：(pure a) &lt;|&gt; x = pure a （Maybe、IO、parsers满足，但[]不满足） 常用函数 asum :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a，相当于foldr (&lt;|&gt;) empty： 1234ghci&gt; asum [Nothing, Just 5, Just 3]Just 5ghci&gt; asum [[2],[3],[4,5]][2,3,4,5] guard :: (Alternative f) =&gt; Bool -&gt; f ()： 12guard True = pure ()guard False = empty MonadPlus123456class (Alternative m, Monad m) =&gt; MonadPlus m where mzero :: m a mzero = empty mplus :: m a -&gt; m a -&gt; m a mplus = (&lt;|&gt;) MonadPlus实例[]、Maybe都是MonadPlus的实例，mzero和mplus都由Alternative实现 MonadPlus Laws Monoid laws Left zero：mzero &gt;&gt;= f = mzero Right zero：m &gt;&gt; mzero = mzero 常用函数 msum = asum mfilter： 123mfilter p ma = do a &lt;- ma if p a then return a else mzero ArrowPlusArrowZero和ArrowPlus分别为Arrow设置了Monoid中的单位元素和二元运算符，使之成为了一个幺半群： 12345class Arrow arr =&gt; ArrowZero arr where zeroArrow :: b `arr` cclass ArrowZero arr =&gt; ArrowPlus arr where (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c) Reference Haskell wiki - Typeclassopedia Haskell语言学习笔记（8）Monoid - zwvista Haskell语言学习笔记（16）Alternative - zwvista 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/d4bb2633.html"},{"title":"「Learn Haskell」#5 函子、应用函子与单子","text":"&lt; #4 #6 &gt; Functors函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用fmap :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子 Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子 函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的f a和f b也是因为f是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中 Functor的定义是: 1234class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b (&lt;$) :: a -&gt; f a -&gt; f b (&lt;$) = fmap . const 可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如： 12ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot; 但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名： const :: a -> b -> a 即接收两个参数，但始终只返回第一个参数 Functor实例[]列表[]是一个函子，它通过map函数来实现fmap的功能： 12instance Functor [] where fmap = map map :: (a -> b) -> [a] -> [b] map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表 MaybeMaybe也具有kind * -&gt; *，它也是一个函子： 12345678instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x)ghci&gt; fmap (*2) NothingNothingghci&gt; fmap (*2) (Just 2)Just 4 Either aEither的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子： 12345678instance Functor (Either a) where fmap f (Left x) = Left x fmap f (Right x) = Right (f x)ghci&gt; fmap (*2) (Left 4)Left 4ghci&gt; fmap (*2) (Right 4)Right 8 因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在） IOIO也是一个函子，使用fmap对IO中内容应用函数： 12345678instance Functor IO where fmap f action = do result &lt;- action return (f result)ghci&gt; fmap (&quot;input: &quot;++) getLinetest&quot;input: test&quot; (,) a(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用： 12instance Functor ((,) a) where fmap f (x, y) = (x, f y) 只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用： 12345instance Functor ((,,) a b) where fmap f (a, b, c) = (a, b, f c)instance Functor ((,,,) a b c) where fmap f (a, b, c, d) = (a, b, c, f d) (-&gt;) r-&gt;也是一个类型构造器，它的kind： (->) :: * -> * -> * 一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中r是输入的类型） 规定的fmap的类型签名是： fmap :: (a -> b) -> f a -> f b 其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到： fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b) 把其中的(-&gt;)换成中缀可以得到： fmap :: (a -> b) -> (r -> a) -> (r -> b) 传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是： 12instance Functor ((-&gt;) r) where fmap f g = (\\x -&gt; f (g x)) 所以(-&gt;) r的fmap其实就是函数复合(.)： 12instance Functor ((-&gt;) r) where fmap = (.) 12345678ghci&gt; :t fmap (*3) (+100) fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a ghci&gt; fmap (*3) (+100) 1 303 ghci&gt; (*3) `fmap` (+100) $ 1 303 ghci&gt; (*3) . (+100) $ 1 303 Functor Laws所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律： fmap id = id（其中id为函数(\\x -&gt; x)）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： 1234ghci&gt; fmap id [1, 2, 3][1,2,3]ghci&gt; fmap id (Just 2)Just 2 fmap (f . g) = fmap f . fmap g：即函子的fmap支持结合律 fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中a为一个函子 fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) 12ghci&gt; fmap ((*3) . (+100)) (Just 1)Just 303 满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可 Intuition对于函子和fmap，有两种理解方法 函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器 函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作fmap :: (a -> b) -> (f a -> f b) 接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数 fmap g :: f a -> f b 使普通的函数g可以在计算上下文f中使用，这种转换也被称为提升（lift） 常用函数&lt;$&gt;&lt;$&gt;函数是fmap的中缀形式（它看着类似$，f $ 3将f应用在单个值3上，而f &lt;$&gt; [1, 2, 3]将f应用在一个函子上，也就是应用在一个函子内部的所有值上）： 1234ghci&gt; fmap (*2) (Just 2)4ghci&gt; (*2) &lt;$&gt; Just 24 $&gt;$&gt;函数包含在Data.Functor模块中 ($>) :: Functor f => f a -> b -> f b Functor定义时要求了&lt;$函数，将函子内部的元素全部替换为指定的某个值，而$&gt;正好将&lt;$函数的两个参数反了过来，相当于flip (&lt;$)： 1234ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot;ghci&gt; [1, 2, 3] $&gt; 'a'&quot;aaa&quot; voidvoid函数也包含在Data.Functor模块中 void :: Functor f => f a -> f () void函数把一个函子内部的全部元素都变成空（()），void x相当于() &lt;$ x： 1234ghci&gt; void [1, 2, 3][(), (), ()]ghci&gt; void (Just 2)Just () Applicative Functor应用函子（Applicative Functor）是函子的升级版，它包含在Control.Applicative模块中。 fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义： 123class Functor f =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b 应用函子要求实现两个函数： pure :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just &lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。 Applicative Functor实例MaybeMaybe是一个应用函子： 1234instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something pure函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x &lt;*&gt;函数：将装有函数的函子中的函数应用另一个函子中 第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing 第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可 实际应用的例子： 12345678ghci&gt; Just (+3) &lt;*&gt; Just 9Just 12ghci&gt; pure (+3) &lt;*&gt; Just 9Just 12ghci&gt; (+3) &lt;$&gt; Just 9Just 12ghci&gt; Nothing &lt;*&gt; Just 9Nothing 第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12 第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了 而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如： 1234ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9Just 12ghci&gt; pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5Just 12 &lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12: 12345 pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5= (pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3) &lt;*&gt; Just 4 &lt;*&gt; Just 5= (Just (\\y z -&gt; 3 + y + z) &lt;*&gt; Just 4) &lt;*&gt; Just 5= Just (\\z -&gt; 3 + 4 + z) &lt;*&gt; Just 5 = Just (+7) &lt;*&gt; Just 5= Just 12 所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。 而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是： f x y ... []列表也是一个应用函子： 123instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs] pure函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x] &lt;*&gt;函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表 使用例子： 1234ghci&gt; [(+3), (*2)] &lt;*&gt; [1, 2][4,5,2,4]ghci&gt; [(+), (*)] &lt;*&gt; [1, 2] &lt;*&gt; [3, 4] [4, 5, 5, 6, 3, 4, 6, 8] IO123456instance Applicative IO where pure = return a &lt;*&gt; b = do f &lt;- a x &lt;- b return (f x) 也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子 1234ghci&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLineLine1Line2&quot;Line1Line2&quot; (-&gt;) r(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名： :: f (a -> b) -> f a -> f b 其中f为(-&gt;) r，将其代入并替换为中缀： :: (r -> a -> b) -> (r -> a) -> (r -> b) 可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b) 那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是： \\x -> f x (g x) 于是： 123instance Applicative ((-&gt;) r) where pure x = (\\_ -&gt; x) f &lt;*&gt; g = \\x -&gt; f x (g x) 将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x 应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子： 12ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5508 执行这句时发生了什么？： 12345678 (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5= ((+) &lt;$&gt; (+3)) &lt;*&gt; (*100) $ 5= ((+) . (+3)) &lt;*&gt; (*100) $ 5 = (\\a -&gt; (+) ((+3) a)) &lt;*&gt; (*100) $ 5= (\\a b -&gt; (a + 3 + b)) &lt;*&gt; (*100) $ 5= (\\x -&gt; x + 3 + ((*100) x)) $ 5= (\\x -&gt; x + 3 + x * 100) $ 5= 5 + 3 + 5 * 100 = 508= (5 + 3) + (5 * 100) 所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+) 同样： 12ghci&gt; (\\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5 [8.0,10.0,2.5] 先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\\x y z -&gt; [x,y,z])得到了最终的结果 12 f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i= (\\x -&gt; f (g x) (h x) (i x)) ZipList普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在Control.Applicative模块中 123instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith ($) fs xs) 但是ZipList并不是Show的实例，所以不能直接显示出来，要使用getZipList来获取它内部的列表： 1234ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..] [101,102,103]ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList &quot;dog&quot; &lt;*&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot; [('d','c','r'),('o','a','a'),('g','t','t')] Applicative Functor Laws应用函子一般有四个定律，都是保证pure的正确性的： Identity law：pure id &lt;*&gt; v = v Homomorphism：pure f &lt;*&gt; pure x = pure (f x) Interchange：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u Composition：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w Intuition理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：$$[[\\ \\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ \\ ]]$$ 其中$x_i$的类型是$f\\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是： $$t_1\\to t_2\\to\\cdots\\to t_n\\to t$$ 所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\\ x_1$结果的类型是： $$f\\ \\ (t_2\\to t_3\\to\\cdots\\to t_n\\to t)$$ 但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ ]]$，只需要： g x1 x2 ... xn 而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算： g x1 pure x2 ... xn 常用函数liftA &amp; liftA2 &amp; liftA3liftA :: Applicative f => (a -> b) -> f a -> f b liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d 不难推测liftA就是fmap，liftA2 f x1 x2相当于f &lt;$&gt; x1 &lt;*&gt; x2，liftA3 f x1 x2 x3相当于f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3 &lt;* &amp; *&gt;类型类似函子的&lt;$和$&gt;： (&lt;*) :: Applicative f => f a -> f b -> f a (*>) :: Applicative f => f a -> f b -> f b &lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来 12345678910111213141516ghci&gt; Just 3 &lt;* Just 4Just 3ghci&gt; Just 3 *&gt; Just 4Just 4ghci&gt; Nothing &lt;* Just 3Nothingghci&gt; Nothing *&gt; Just 3Nothingghci&gt; [1, 2, 3] &lt;* [3, 4][1,1,2,2,3,3]ghci&gt; [1, 2, 3] *&gt; [3, 4][3,4,3,4,3,4]ghci&gt; [] &lt;* [1, 2, 3][]ghci&gt; [] *&gt; [1, 2, 3][] &lt;**&gt;(**) :: Applicative f => f a -> f (a -> b) -> f b 接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用： 123456ghci&gt; [(+1), (+2), (+3)] &lt;*&gt; [1, 2][2,3,3,4,4,5]ghci&gt; [1, 2] &lt;**&gt; [(+1), (+2), (+3)][2,3,4,3,4,5]ghci&gt; flip(&lt;*&gt;) [1, 2] [(+1), (+2), (+3)][2,3,3,4,4,5] when &amp; unlesswhen :: Applicative f => Bool -> f () -> f () 传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过） unless则与when相反，测试为True返回pure () sequenceAsequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) 应用在列表上时，它的类型相当于： [f a] -> f [a] 所以在列表上它的使用方法： 12345678910ghci&gt; sequenceA [Just 3, Just 2, Just 1] Just [3,2,1] ghci&gt; sequenceA [Just 3, Nothing, Just 1] Nothing ghci&gt; sequenceA [(+3),(+2),(+1)] 3 [6,5,4] ghci&gt; sequenceA [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]] ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]] [] 它在对同一个参数应用不同函数时很有用： 1234ghci&gt; map (\\f -&gt; f 7) [(&gt;4), (&lt;10), odd] [True,True,True] ghci&gt; sequenceA [(&gt;4), (&lt;10), odd] 7 [True,True,True] Monad单子（Monad）是对Applicative Functor的扩展（但是诞生比Applicative早），Functor的&lt;$&gt;函数实现了将普通函数应用在上下文值上，Applicative的&lt;*&gt;函数将上下文中函数应用在上下文值上。而Monad提供了一个函数&gt;&gt;=（bind），将一个接收普通值返回上下文值的函数应用在上下文值上： 123456class Applicative m =&gt; Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b return :: a -&gt; m a m &gt;&gt; n = m &gt;&gt;= \\_ -&gt; n return = pure return函数：和pure一样，只是有另一个名字 &gt;&gt;函数：提供了默认的实现方法，它的作用和Applicative的*&gt;函数一样 &gt;&gt;=函数（bind）：比Applicative升级的函数，第一个参数是一个单子，第二个参数是一个接收值返回单子的函数，将这个函数应用在第一个参数单子中的值上，并返回得到的新单子 Monad实例MaybeMaybe是一个单子实例，Applicative已经为它实现了return，因此只需要&gt;&gt;=函数： 123instance Monad Maybe where (Just x) &gt;&gt;= f = f x Nothing &gt;&gt;= _ = Nothing 根据定义就很容易实现Maybe的&gt;&gt;=函数了，而且也很好理解 12345678ghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1)Just 2ghci&gt; Just 1 &gt;&gt;= \\x -&gt; return (x + 1)Just 2ghci&gt; Nothing &gt;&gt;= \\x -&gt; Just (x + 1)Nothingghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1) &gt;&gt; Nothing &gt;&gt;= \\y -&gt; Just (y + 1)Nothing 最后一个例子中出现了&gt;&gt; Nothing，这时Nothing前的部分全都相当于没用，因为&gt;&gt;操作符的左右两边只要有一个出现Nothing，那整体就会是Nothing。这个特性可以用于在中途随时判断失误，只要有一处失误，结果就会是Nothing []列表也是一个单子： 12instance Monad [] where xs &gt;&gt;= f = concat (map f xs) 将这个函数应用在xs的每个值上，将返回的所有列表平铺成一个列表： 1234ghci&gt; [3,4,5] &gt;&gt;= \\x -&gt; [x,-x] [3,-3,4,-4,5,-5] ghci&gt; [1,2] &gt;&gt;= \\n -&gt; ['a','b'] &gt;&gt;= \\ch -&gt; return (n,ch) [(1,'a'),(1,'b'),(2,'a'),(2,'b')] IOIO也是一个单子，但是实现方法比较深奥（逃 (-&gt;) r(-&gt;) r也是一个单子，和Functor、Applicative一样，先分析它的&gt;&gt;=类型签名： (>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b) 也可以看出来，它接收两个函数f :: r -&gt; a、g :: a -&gt; r -&gt; b，然后返回一个新的函数h :: r -&gt; b 那么函数h接收一个类型为r的参数，返回一个类型为b的值。所以先对输入应用f得到类型为a的中间值，然后再将这个值和输入参数一起传入函数g得到结果。所以函数h的定义应该是： \\x -> g (f x) x 12instance Monad ((-&gt;) r) where f &gt;&gt;= g = \\x -&gt; g (f x) x 1234ghci&gt; (+3) &gt;&gt;= (+) $ 15ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; id $ 15 do-notationHaskell的do语句为链式的&gt;&gt;=应用提供了类似命令式（imperative style）的语法糖。比如a &gt;&gt;= \\x -&gt; b &gt;&gt; c &gt;&gt;= \\y -&gt; d： 1234a &gt;&gt;= \\x -&gt;b &gt;&gt;c &gt;&gt;= \\y -&gt;d 其中有abcd四个值，可以看出a中内容绑定到了x上，c中内容绑定到了y上。使用do语句来表示这个操作可以写成： 12345do { x &lt;- a ; b ; y &lt;- c ; d } 其中的大括号和分号可以省略不写（挤在一行时不能省略）。do语句也只是一个语法糖，它可以递归地转换成普通的Monad操作语句： do e：e do { e; ... }：e &gt;&gt; do { … } do { v &lt;- e; ... }：e &gt;&gt;= \\v -&gt; do { … } do { let ...; ... }：let … in do { … } ApplicativeDo比如如下一个do语句： 1234do x &lt;- a y &lt;- b z &lt;- c return (f x y z) 它可以转化成： a >>= \\x -> b >>= \\y -> c >>= \\z -> return (f x y z) 但是经过观察可以发现，整个语句实际上将函数f应用在了三个上下文中的值上，所以仅用Applicative的&lt;$&gt;和&lt;*&gt;完全可以实现： f a b c 而且在运行的时候Applicative的效率会比Monad高，所以Haskell会将do语句尽可能优先转换为Applicative的表示方法然后再计算 Monad Laws Left identity： return a &gt;&gt;= k = k a Right identity：m &gt;&gt;= return = m Associativity：(m &gt;&gt;= g) &gt;&gt;= h = m &gt;&gt;= (\\x -&gt; g x &gt;&gt;= h) 前两个定律很好理解： 将a注入上下文之后绑定（bind）给函数k(:: a -&gt; m a)，相当于直接将a直接传入函数k 将已经包含在上下文中的值绑定给return函数，相当于保持不变 第三个定律是结合律，把它写成更像结合律的表示方法是： (m >>= (\\x -> g x)) >>= h = m >>= (\\x -> g x >>= h) 组合运算符（&gt;=&gt;）形式Control.Monad模块中还定义了函数&gt;=&gt;（Kleisli-composition operator）： 123infixr 1 &gt;=&gt;(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)f &gt;=&gt; g = \\x -&gt; f x &gt;&gt;= g 使用&gt;=&gt;运算符可以将两个用于绑定的函数结合在一起。用它表示的Monad定律更加清晰直观： Left identity：return &gt;=&gt; f = f Right identity：f &gt;=&gt; return = f Associativity：(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h) do-notation形式Monad的这三个定律还可以使用do语句来描述： Left identity： 123do { x' &lt;- return x; f x' = do { f x } } Right identity： 123do { x &lt;- m; return x = do { m } } Associativity： 12345do { y &lt;- do { x &lt;- m; do { x &lt;- m; do { x &lt;- m; f x do { y &lt;- f x; y &lt;- f x; } = g y = g y g y } } } } IntuitionMonad也可以很自然地看成Applicative的升级版，比如Applicative的操作全部是固定的，而Monad的操作可以在中途突然改变 同时Monad也完成了Functor和Applicative无法完成的操作。比如要用fmap和实现&gt;&gt;=函数（即达成操作 m a -&gt; (a -&gt; m b) -&gt; m b），先假设 f :: a -&gt; m b，那么fmap f的类型就会是 m a -&gt; m (m b)，将m a应用在fmap f上会得到结果m (m b)，而不是m b。但是目前只可以使用pure将一个值装入上下文中（a -&gt; m a），而没有一个函数可以从上下文中提取值（m a -&gt; a）。那么就需要定义一个新的函数来实现这个操作的效果（m (m b) -&gt; m b）。因此Monad的另一个等效的定义方法是： 12345class Applicative m =&gt; Monad' m where join :: m (m a) -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x 但是\b定义&gt;&gt;=函数会更为直观方便，所以Haskell采用了用&gt;&gt;=函数定义Monad的方法 同时Haskell还提供了join函数的定义： 12join :: Monad m =&gt; m (m a) -&gt; m a join x = x &gt;&gt;= id 常用函数liftM &amp; apliftM :: Monad m => (a -> b) -> m a -> m b ap :: Monad m => m (a -> b) -> m a -> m b 所以liftM其实就是fmap、ap就是&lt;*&gt;，但是老版本的GHC定义Monad并没有Functor、Applicative的约束，所以实现了liftM、ap，并且保留了这个名字 因此一个单子也可以通过pure = return、(&lt;*&gt;) = ap直接成为应用函子的实例 sequencesequence :: Monad m => [m a] -> m [a] sequence的作用显而易见，而且在IO部分也使用到了。但是这个版本是在GHC.Base模块中定义的，还有一个更广泛的使用Traversable的定义在Data.Traversable模块中 replicateMreplicateM :: Applicative m => Int -> m a -> m [a] mapM &amp; forMmapM :: Monad m => (a -> m b) -> [a] -> m [b] forM :: Monad m => [a] -> (a -> m b) -> m [b] forM的用法在IO部分已经说过，mapM和forM都在Data.Traversable模块中有广泛版本 还有一些其他的函数：filterM、zipWithM、foldM、forever，通过名字就可以看出用法，是将原来仅使用与列表的函数提升至可以适用于所有单子 并且在函数名后加下划线，比如sequence_、mapM_，会忽略返回值（最终结果为m ()） =&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;（&gt;=&gt;操作符在上面Monad Laws部分已经给出了定义） x &gt;&gt;= f = f =&lt;&lt; x f &gt;=&gt; g = g &lt;=&lt; f MonadFailMonadFail定义在Control.Monad.Fail模块中： 12class Monad m =&gt; MonadFail m where fail :: String -&gt; m a 它只要求在Monad的基础上实现fail函数，接收一个字符串返回一个单子。这会使在do语句中产生错误时直接变为错误值（空值）使最终的返回值为错误值 MonadFail实例12345678instance MonadFail Maybe where fail _ = Nothinginstance MonadFail [] where fail _ = []instance MonadFail IO where fail = failIO Maybe和[]的fail函数都与第一个参数无关，直接返回空值（Nothing、[]）；而IO的fail函数直接使用failIO，实现方法也是深奥（接着逃 1234567exampleFail :: Maybe Char exampleFail = do (x:xs) &lt;- Just &quot;&quot; return x ghci&gt; exampleFailNothing 在这个例子的do语句中，在提取Just “”中的值时用了模式匹配，但是因为其内容为空字符串，x:xs匹配会出现错误，这时就会触发fail函数直接返回Nothing MonadFail Law fail s &gt;&gt;= m = fail s Reference Learn You a Haskell Haskell wiki - Typeclassopedia Functors, Applicatives, And Monads In Pictures Haskell学习 - functor 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/290ecb74.html"},{"title":"「Learn Haskell」#4 输入输出与文件","text":"&lt; #3 #5 &gt; Input/Output运行Haskell程序不在GHCi中运行一个Haskell程序有两种方式： 编译运行： 12$ ghc --make code$ ./code 通过runhaskell命令直接运行： 1$ runhaskell code.hs 输出文本在一个Haskell程序中输出文字需要定义一个main函数： 1main = putStrLn &quot;Hello World&quot; 其中putStrLn的类型是： putStrLn :: String -> IO () putStrLn接收一个String类型，并返回一个结果为()类型的IO动作（I/O action）。所以main函数的类型为IO ()。（IO的Kind是* -&gt; *） 除此之外，还有其他默认提供的输出文本的函数： putStr：输出文本，结尾不换行 putChar：输出单个字符，结尾不换行。接收的参数为单个Char，不是String（用单引号不是双引号） print：可以接收任何Show的成员，先用show转化为字符串然后输出。等同于putStrLn . show do block在main函数中使用多个putStrLn需要使用do语句： 123main = do putStrLn &quot;Line1&quot; putStrLn &quot;Line2&quot; 其中最后一行一定要返回IO ()类型的值 输入文本输入文字需要在do块中使用getLine： 123main = do line &lt;- getLine putStrLn line getLine的类型是： getLine :: IO String 而&lt;-操作符将getLine中的String提取了出来给到了line，使line变成了String类型的一个字符串。 而且使用输入的字符串必须要经过一次&lt;-，不能直接使用getLine作为字符串，因为getLine不是String类型，而是IO String类型。 除此之外，还可以使用getChar来获取单个字符，但仍然需要使用&lt;-操作符来提取Char 其他IO相关函数用法returnHaskell中的return和其他命令式语言中的return完全不同，它不会使函数直接结束并返回一个值。 main函数必须定义为类型为IO ()的函数，所以在main函数中使用if语句，如果不输出的话也不可以直接放下什么都不干，因为这时候main函数的类型不是IO ()。所以这时需要使用return ()来为main函数指定为IO ()类型，例如： 123456main = do line &lt;- getLine if null line then return () -- &lt;-这里 else do ... 使用&lt;-操作符也可以直接将return语句中的内容提取出来，比如a &lt;- return ‘A’，执行后a就是’A’。 whenwhen包含在Control.Monad模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会return ()。比如： 1234567import Control.Monad main = do c &lt;- getChar when (c /= ' ') $ do putChar c main 等同于： 1234567main = do c &lt;- getChar if c /= ' ' then do putChar c main else return () sequencesequence在IO中使用时可以达成[IO a] -&gt; IO [a]的效果，所以可以用作： 1[a, b, c] &lt;- sequence [getLine, getLine, getLine] mapM &amp; mapM_在IO相关的地方使用map，可以使用mapM和mapM_，其中mapM有返回值而mapM_直接扔掉了返回值： 123456789ghci&gt; mapM print [1,2,3] 1 2 3 [(),(),()] ghci&gt; mapM_ print [1,2,3] 1 2 3 foreverforever函数包含在Control.Monad模块中。在main函数开头加上forever函数可以使后面的do块一直重复执行直到程序被迫终止，如： 1234import Control.Monad main = forever $ do ... forMforM函数包含在Control.Monad模块中，它的功能和mapM类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回IO a类型。比如： 123456789import Control.Monadmain = do colors &lt;- forM [1, 2, 3, 4] (\\a -&gt; do putStrLn $ &quot;Which color do you associate with the number &quot; ++ show a ++ &quot;?&quot; color &lt;- getLine return color) putStrLn &quot;The colors that you associate with 1, 2, 3 and 4 are: &quot; mapM putStrLn colors getContentsgetLine获取一整行，而getContents从标准输入中获取全部内容直到遇到EOF，并且它是lazy的，在执行了foo &lt;- getContents后，它并不会读取标准输入并且赋值到foo，而是等到需要使用foo的时候再从标准输入读取。 getContents在使用管道传入文字时很常用，可以代替forever+getLine使用，比如一个Haskell程序文件code.hs： 12345import Data.Char main = do contents &lt;- getContents putStr (map toUpper contents) 使用ghc –make code编译后，通过管道传入文字： 1cat text.txt | ./code 会将text.txt中的所有字母转为大写并输出 interact上述功能还可以转化为一个String -&gt; String的函数： 1upperStrings = unlines . map (map toUpper) . lines 而在main中使用这个函数就需要： 123main = do contents &lt;- getContents putStr (upperStrings contents) 但是String -&gt; String类型的函数在输入输出中的使用太常见了，所以可以使用interact函数来简化。interact的类型是： interact :: (String -> String) -> IO () 可以看出它接收一个String -&gt; String的函数，并返回一个IO ()类型，所以可以直接用在main上。 于是整个转换为大写的程序就可以简化为： 1main = interact $ unlines . map (map toUpper) . lines 文件和流以下与文件和流相关的函数都包含在System.IO模块中 openFileopenFile函数可以用来打开一个文件，它的类型是： openFile :: FilePath -> IOMode -> IO Handle 其中FilePath是String的type synonyms，用一个字符串来表示需要打开的文件的路径 IOMode的定义是： 1data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode 所以它一共只有四个值，用来表示进行IO操作的模式 openFile返回一个IO Handle类型的值，将其用&lt;-操作符提取后会出现一个Handle的值。但不能从Handle中直接使用文字，还需要使用一系列函数： hGetContents :: Handle -&gt; IO String ，从Handle中读取全部内容，返回一个IO String hGetChar :: Handle -&gt; IO Char ，从Handle中读取一个字符 hGetLine :: Handle -&gt; IO String ，从Handle中读取一行，返回一个IO String hPutStr :: Handle -&gt; String -&gt; IO () ，向Handle中输出字符串 hPutStrLn :: Handle -&gt; String -&gt; IO () ，同上 在使用openFile进行文件操作后，需要使用hClose手动关闭Handle。hClose :: Handle -&gt; IO ()，接收一个Handle并返回IO ()，可以直接放在main函数末尾 所以使用openFile读取一个文件中的全部内容并输出的全部代码是： 1234567import System.IOmain = do handle &lt;- openFile &quot;text.txt&quot; ReadMode contents &lt;- hGetContents handle putStrLn contents hClose handle withFilewithFile类似Python中的with open，它在读取文件使用之后不需要手动close文件。它的类型是： withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a 可以看出，它接收三个参数： FilePath：一个表示文件路径的String IOMode：打开文件的模式 (Handle -&gt; IO a)：一个函数，表示对读取文件后的Handle索要进行的操作，需要返回一个I/O action；而这个返回值也将作为withFile的返回值 现在使用withFile来改写上述代码： 12345import System.IOmain = withFile &quot;text.txt&quot; ReadMode (\\handle -&gt; do contents &lt;- hGetContents handle putStrLn contents) withFile的功能相当于以下函数： 123456withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a withFile' path mode f = do handle &lt;- openFile path mode result &lt;- f handle hClose handle return result readFilereadFile可以更加简化读取文件内容的操作，它的类型： readFile :: FilePath -> IO String 它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的I/O action： 12345import System.IOmain = do contents &lt;- readFile &quot;text.txt&quot; putStrLn contents writeFilewriteFile简化了写入文件的操作，它的类型： writeFile :: FilePath -> String -> IO () 传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个IO () appendFileappendFile类似writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾 buffer文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。 也可以通过hSetBuffering函数来手动设置缓冲区大小，这个函数的类型： hSetBuffering :: Handle -> BufferMode -> IO () 它接收一个handle，和一个BufferMode，并返回IO ()。其中BufferMode有以下几种： NoBuffering：没有缓冲区，一次读入一个字符 LineBuffering：缓冲区大小是一行，即每次读入一行内容 BlockBuffering (Maybe Int)：缓冲区大小是一块，块的大小由Maybe Int指定： BlockBuffering (Nothing)：使用系统默认的块大小 BlockBuffering (Just 2048)：一块的大小是2048字节，即每次读入2048bytes的内容 缓冲区的刷新是自动的，也可以通过hFlush来手动刷新 hFlush :: Handle -> IO () 传入一个handle，返回IO ()，即刷新对应handle的缓冲区 openTempFileopenTempFile可以新建一个临时文件： openTempFile :: FilePath -> String -> IO (FilePath, Handle) FilePath指临时文件要创建的位置路径，String指临时文件名字的前缀，返回一个I/O action，其内容第一个FilePath是创建得到的临时文件的路径，Handle是临时文件的handle 例如： 123456import System.IOmain = do (tempFile, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot; ... hClose tempHandle &quot;.&quot;指临时文件要在当前目录创建，&quot;temp&quot;指临时文件名字以temp开头。最终得到的tempFile就是./temp…….，temp后为随机数字，如./temp43620-0 路径操作相关函数都包含在System.Directory模块中，全部内容见System.Directory getCurrentDirectorygetCurrentDirectory :: IO FilePath 直接返回一个I/O action，其内容是一个字符串表示当前路径的绝对路径 removeFileremoveFile :: FilePath -> IO () 输入一个文件路径，并删除掉它 renameFilerenameFile :: FilePath -> FilePath -> IO () 输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名 doesFileExistdoesFileExist :: FilePath -> IO Bool 检查文件是否存在，返回一个包含布尔值的I/O action Command line argumentsSystem.Environment模块中提供了两个函数可以用来处理传入命令行的参数 getArgsgetArgs :: IO [String] 不需要输入参数，直接返回一个I/O action，内容为传入命令行的参数（一个由String组成的列表）。相当于C语言中的argv[1:] getProgNamegetProgName :: IO String 返回I/O action，内容为程序的名字，相当于C语言中的argv[0] Randomness和随机数有关的函数都包含在System.Random模块中。GHCi启动时可能不会包含System.Random的配置，导致无法找到模块。需要通过stack打开: 1stack ghci --package random Haskell要求同样的程序需要运行出同样的结果，除了用到了I/O action，所有会造成不同结果的函数都要交给I/O action来完成 那要使随机数脱离IO存在，就要用到随机生成器（random generator） System.Random模块提供了几个生成随机数的函数： randomrandom :: (Random a, RandomGen g) => g -> (a, g) 其中又有两个新的typeclass，Random表示可以取随机，RandomGen表示随机数生成器。random函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器 获取随机数生成器可以使用mkStdGen函数： mkStdGen :: Int -> StdGen 其中StdGen是一个RandomGen的实例 运用random生成随机数需要指定类型，不然程序无法确定a是什么类型。例如： 123456ghci&gt; random (mkStdGen 100) :: (Int, StdGen)(9216477508314497915,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Char, StdGen)('\\537310',StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Bool, StdGen)(True,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125}) 再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器： 123456threeCoins :: StdGen -&gt; (Bool, Bool, Bool) threeCoins gen = let (firstCoin, newGen) = random gen (secondCoin, newGen') = random newGen (thirdCoin, newGen'') = random newGen' in (firstCoin, secondCoin, thirdCoin) randomsrandoms :: (Random a, RandomGen g) => g -> [a] randoms接收一个RandomGen，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器 randomRrandomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g) 可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围(闭区间) randomRsrandomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a] 同上两个，生成有范围的无穷随机数列表 getStdGen如果想要让程序每次运行得到不同的随机结果，需要使用getStdGen来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个I/O action，而不是一个直接的StdGen getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen 即可以看成getStdGen :: IO StdGen，需要使用&lt;-操作符将StdGen提取出来 但是在同一个程序中，getStdGen的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数newStdGen newStdGennewStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen 执行newStdGen会进行两个操作： 更新全局随机数生成器，下次执行getStdGen会获得不同的结果 返回一个I/O action，包含一个新的StdGen（但是这个生成器和全局生成器也不同） Exceptions程序在运行失败时会抛出异常，可以通过Control.Exception模块中的catch函数来捕获异常： catch :: Exception e => IO a -> (e -> IO a) -> IO a 第一个参数是要进行的操作，以IO a为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如： 12345678910import Control.Exceptionmain = main' `catch` handlermain' :: IO ()main' = do ...handler :: Exception e =&gt; e -&gt; IO ()handler e = putStrLn &quot;...&quot; 也可以利用守卫（guard）语法和System.IO.Error中的函数来判断IO异常的类型来进行不同操作： 123456789101112131415import System.Environmentimport System.IO.Errorimport Control.Exception main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) &lt;- getArgs contents &lt;- readFile fileName putStrLn $ &quot;The file has &quot; ++ show (length (lines contents)) ++ &quot; lines!&quot; handler :: IOError -&gt; IO () handler e | isDoesNotExistError e = putStrLn &quot;The file doesn't exist!&quot; | otherwise = ioError e 具体相关全部函数见文档：System.IO.Error、Control.Exception Reference Learn You a Haskell 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/a5bbe48a.html"},{"title":"「Learn Haskell」#3 类型与类型类","text":"&lt; #2 #4 &gt; TypesHaskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。Type的首字母全为大写，常用的有： Int：整型，有上下界范围，-2147483647～2147483648 Integer：整数，无界，但是效率比Int低 Float：单精度浮点型 Double：双精度浮点型 Bool：布尔值 Char：字符 String：字符串，等同于[Char] Ording：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT 列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加[]。 元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。 Typeclasses类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个TypeclassTypeclass的首字母也全为大写，常见的有： Eq：可判断是否相等 Ord：可比较大小 Show：可展示成字符串 Read：可从字符串转换成特定类型 Enum：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀 Bounded: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded Integral：是整数，包括Int和Integer RealFloat： 是实浮点数，包括Float和Double RealFrac：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中） Floating：是浮点数，包括Float、Double和Complex（在Data.Complex模块中） Real：是实数，包括Integral和RealFrac的成员 Fractional：是分数，包括RealFrac和Floating的成员 Num：是数字，包括上述所有数字相关的类型 Type variables如果查看一个函数的类型，比如head，那么将会返回以下类型： head :: [a] -> a 其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。 在函数的类型表达式其实可以看作$\\lambda$表达式，它适用于$\\alpha$变换（$\\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。 在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如(==)函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么(==)的类型就是： (==) :: (Eq a) => a -> a -> Bool 其中=&gt;前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以(==)函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。 定义新Type定义一个新的Type需要使用data关键字，比如定义Bool需要使用： data Bool = False | True 其中=左侧的部分定义了新类型的名称Bool，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。并且名称和值构造器的首字母都需要大写。 另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如： 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float 它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。如果查看Circle的类型，将返回： Circle :: Float -> Float -> Float -> Shape 如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上deriving (Show): 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) 类型的名称和值构造器名称也可以相同，比如： 1data Point = Point Float Float deriving (Show) 导出Type在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件Shapes.hs中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写： 123456module Shapes( Shape(..), Point(..), functionA, functionB) where 其中的Shape(..)导出了Shape类型和它所有的值构造器，..代表了它的所有值构造器。因此，Shape(..)相当于Shape (Circle, Rectangle)。 如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将Shape(..)替换为Shape，这样就只导出了Shape类型，而不导出其值构造器。 Record Syntax如果想要方便地取出类型实例中的参数，可以使用Record语法，如： 123data Point = Point { xcoord :: Float , ycoord :: Float } deriving (Show) 在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值： 12345ghci&gt; let point = Point 1.0 2.0ghci&gt; xcoord point1.0ghci&gt; ycoord point2.0 同时也可以通过下面方法来创建这个point： 1point = Point {ycoord=2.0, xcoord=1.0} Type parameters值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义： data Maybe a = Nothing | Just a 它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型： 1234Nothing :: Maybe aJust 1 :: Num a =&gt; Maybe aJust 'a' :: Maybe CharJust &quot;abc&quot; :: Maybe [Char] 可以用这种方法改写Point： 123data Point x y = Point { xcoord :: x , ycoord :: y } deriving (Show) 但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。 而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如： 12data (Ord k) =&gt; Map k v = ... toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] EitherEither是一个类型构造器，它有两个值构造器，定义是： 1data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) 如果使用了Left，那它的a的类型就是具体的；如果使用了Right，那它的b的类型就是具体的： 12345678ghci&gt; Right 20 Right 20 ghci&gt; Left &quot;w00t&quot; Left &quot;w00t&quot; ghci&gt; :t Right 'a' Right 'a' :: Either a Char ghci&gt; :t Left True Left True :: Either Bool b Either可以看作Maybe的补充，比如Maybe在使用时，出现异常可以返回Nothing，但只是一个Nothing，不包含任何信息；但Either包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法： 12345678safeDiv :: Int -&gt; Int -&gt; Maybe IntsafeDiv _ 0 = NothingsafeDiv x y = Just (x `div` y)ghci&gt; safeDiv 4 2Just 2ghci&gt; safeDiv 1 0Nothing 而使用Either： 12345678safeDiv :: Int -&gt; Int -&gt; Either String IntsafeDiv _ 0 = Left &quot;Divided by zero&quot;safeDiv x y = Right (x `div` y)ghci&gt; safeDiv 4 2Right 2ghci&gt; safeDiv 1 0Left &quot;Divided by zero&quot; Derived instances想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如： 12data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) 这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右） Type synonyms为了阅读方便，书写简便，可以使用type关键字为已有类型创建别名（synonyms）。比如String的定义： type String = [Char] 在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。同时，类型别名也可以接收类型参数 newtype keyword除了data、type关键字之外，还可以用newtype关键字来定义一个新的类型，比如Control.Applicative模块中的ZipList： 1newtype ZipList a = { getZipList :: [a] } 不同于type，它不是别名，可以使用record语法来直接定义取出值的函数 不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰 Recursive data structures一个类型也可以递归定义，比如一颗二叉树： 1data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) 定义新Typeclass定义一个新的Typeclass需要使用class关键字，例如定义Eq类型类： 12345class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) 其中a是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。 包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们（(==) | (/=)）成为这个类型类的最小完整定义（minimal complete definition） 查看一个类型类的成员需要实现的函数可以在GHCi中使用:info： ghci> :info Eq 手动创建实例使一个类型成为一个类型类的实例可以直接使用deriving来自动完成，也可以通过使用instance关键字来手动完成。比如使Point成为Show的实例： 123456instance Show Point where show (Point x y) = &quot;(&quot; ++ show x ++ &quot;, &quot; ++ show y ++ &quot;)&quot;-- in ghcighci&gt; Point 1.0 2.0(1.0, 2.0) 这样就可以自定义显示的内容，否则使用deriving的话只会直接将其转化为字符串。 同时也要注意类型和类型构造器的区别，传入给instance的第二个参数应该为类型而不是类型构造器，比如Maybe： 123456789101112instance Eq Maybe where ... -- 错误用法，因为Maybe是类型构造器而不是类型instance Eq (Maybe m) where ...-- 错误用法，因为m不一定是Eq的成员instance (Eq m) =&gt; Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False Functor TypeclassFunctor也是一种类型类，它只规定了一个函数： 12class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 其中f是一个类型构造器，而不是一个具体类型 Kinds一个值的类型叫做类型（Type），而一个类型的类型叫做Kind。可以通过GHCi中:k来查看Kind： 12345678ghci&gt; :k IntInt :: *ghci&gt; :k MaybeMaybe :: * -&gt; *ghci&gt; :k Maybe IntMaybe Int :: *ghci&gt; :k EitherEither :: * -&gt; * -&gt; * 其中的星号*代表了一个具体类型（concrete type）。Int本身就是一个具体类型，所以Int的Kind是*。而Maybe是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以Maybe的Kind是* -&gt; *。如果给Maybe传入了一个Int，那么得到的Maybe Int就是一个具体的类型，它的Kind就是*。Either也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以Either的Kind是* -&gt; * -&gt; *。 Reference Learn You a Haskell 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/369b7e08.html"},{"title":"「Learn Haskell」#2 高阶函数与模块","text":"&lt; #1 #3 &gt; Higher Order FunctionsCurryingHaskell中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如max函数，它的类型签名是： max :: Ord a => a -> a -> a 可以看成a -&gt; (a -&gt; a)，即接收一个参数，返回一个类型为a -&gt; a的函数。比如max 1的类型签名是： max 1 :: (Ord a, Num a) => a -> a 因此max 1 2，也就等同于(max 1) 2，即将函数max 1应用在数字2上 同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions） 一些高阶函数zipWithzipWith :: (a -> b -> c) -> [a] -> [b] -> [c] 第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例： 1234ghci&gt; zipWith (+) [4,2,5,6] [2,6,2,3] [6,8,7,9] ghci&gt; zipWith max [6,3,2,1] [7,3,1,5] [7,3,2,5] flipflip :: (a -> b -> c) -> b -> a -> c flip函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来： 1234ghci&gt; zip [1,2,3,4,5] &quot;hello&quot;[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]ghci&gt; flip zip [1,2,3,4,5] &quot;hello&quot; [('h',1),('e',2),('l',3),('l',4),('o',5)] mapmap :: (a -> b) -> [a] -> [b] map函数接收一个函数f和一个列表a，将函数f应用在列表a的每个元素中，并返回得到的所有结果组成的列表b： 12ghci&gt; map (+3) [1,5,3,1,6] [4,8,6,4,9] filterfilter :: (a -> Bool) -> [a] -> [a] filter函数接收一个函数f和一个列表a，将列表a中的每个元素传入函数f中，如果结果为True就保留，结果为False就抛弃，返回所有保留的元素组成的新列表： 12ghci&gt; filter even [1..10] [2,4,6,8,10] takeWhiletakeWhile :: (a -> Bool) -> [a] -> [a] takeWhile函数接收一个函数f和一个列表a，将列表a中从左向右每个元素传入函数f，直到结果为False停止，返回停止前传入的所有元素组成的新列表： 12ghci&gt; takeWhile (/=' ') &quot;word1 word2&quot;&quot;word1&quot; Function application函数应用可以使用$，$是一个函数，它的类型是： ($) :: (a -> b) -> a -> b 它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。 1234567f $ g x-- 等价于f (g x)-----f g x-- 等价于(f g) x Function Composition函数复合可以使用.，.也是一个函数，它的类型是： (.) :: (b -> c) -> (a -> b) -> a -> c 定义是： f . g = \\x -> f (g x) 但是函数复合的优先级要比函数执行低，比如： 1sum . replicate 5 . max 6.7 8.9 会先执行max 6.7 8.9并返回8.9，然后将sum、replicate 5、8.9复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用$来规定先复合再执行： 1sum . replicate 5 . max 6.7 $ 8.9 lambdaHaskell语言中的lambda表达式是用\\来表示的（因为看着像$\\mathtt{\\lambda}$？）具体语法是 1\\para1 para2 ... -&gt; return “-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。 fold和scanfold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表传入的二元函数f :: a -&gt; b -&gt; b将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数） foldl左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如： 1foldl f a xs 它的结果计算过程为 1234&gt; foldl f a [x1, x2, x3][1.] a = f a x1[2.] a = f a x2 = f (f a x1) x2[3.] a = f a x3 = f (f (f a x1) x2) x3 可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表 foldr右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如： 1foldr f a xs 它的结果计算过程为 1234&gt; foldr f a [x1, x2, x3][1.] a = f x3 a[2.] a = f x2 a = f x2 (f x3 a)[3.] a = f x1 a = f x1 (f x2 (f x3 a)) 从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]因此可以使用递归来写一个和foldr效果一样的函数: 123foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' _ x [] = xfoldr' f a (x:xs) = f x (foldr' f a xs) 也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表 例如： 12345ghci&gt; foldr (||) False (repeat True)True -- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了ghci&gt; foldl (||) False (repeat True)-- 这里什么都不会发生，直到电脑内存被爆掉-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表 scanl和scanrscan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表scanl则向右延伸这个列表，scanr则向左延伸这个列表但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能 12345&gt; scanr f a [x1, x2, x3][1.] 最右侧元素(-1 in python) : a[2.] 右侧第二个元素(-2) : f x3 a[3.] 右侧第三个元素(-3) : f x2 (f x3 a)[4.] 右侧第四个元素(-4) : f x1 (f x2 (f x3 a)) 可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素因此可以用递归来写一个和scanr效果一样的函数： 12345scanr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanr' _ x [] = [x]-- scanr' f a (x:xs) = f x (foldr f a xs) : scanr' f a xsscanr' f a (x:xs) = f x q : qs where qs@(q:_) = scanr' f a xs scanl也是同理： 123scanl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanl' _ x [] = [x]scanl' f a (x:xs) = a : scanl' f (f a x) xs 也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果： 1234ghci&gt; take 10 (scanl (+) 0 [1..])[0,1,3,6,10,15,21,28,36,45]ghci&gt; take 10 (scanr (+) 0 [1..])[*** Exception: stack overflow 使用foldr编写foldlpdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr： 1foldl' f z xs = foldr (\\x g y -&gt; g (f y x)) id xs z 它利用 foldr (\\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。 先来看一下foldr的类型： 12foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b 但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。 所以这里foldr的类型可以写成： (a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b) 对应于用法 foldr (\\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）而xs对应于[a]；id对应于(b -&gt; b)所以 (\\x g y -&gt; g (f y x)) 要对应于： (a -> (b -> b) -> (b -> b)) 因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。 再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为： b -> (b -> b) 现在根据foldr的定义： foldr f a (x:xs) = f x (foldr f a xs) 带入计算一下： xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn] 定义中的f即为(\\x g y -&gt; g (f y x))，a即为id 12 foldr (\\x g y -&gt; g (f y x)) id xs z= (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z 写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开： 12 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1) 不难发现，原式 (foldr (…) id xs) z 等价于： (foldr (...) id xs') (f z x1) 跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’因此下一步： 12345 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= (foldr (...) id xs''') (f (f (f z x1) x2) x3)= ... 可以发现，已经有了规律。那么最终停止时是什么样呢？ 最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id 所以最后的结果：(id的定义：id x = x) 1234567 ...= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= ...= (foldr (...) id []) (f (.. (f z x1) ..) xn)= id (f (.. (f z x1) ..) xn)= f (.. (f z x1) ..) xn 那么最后这个结果就很熟悉了，它就是 foldl f z xs。所以我们推导出了这个用foldr表示foldl的写法是正确的。 ModulesHaskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用:m + ...，比如加载Data.List模块： Prelude> :m + Data.List 而在hs文件中引入模块，需要使用import语句，下面和python的对比可以便于理解： 1234567891011121314import Data.List-- from Data.List import *import Data.List (nub, sort)-- from Data.List import nub, sortimport Data.List hiding (nub)-- 从Data.List中引入所有，但不引入nub函数import qualified Data.List-- import Data.Listimport qualified Data.List as Li-- import Data.List as Li 编写Modules模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫ModuleA.hs，那它的头部需要写： 123456module ModuleA( functionA, functionB, functionC) where 而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。 Reference Learn You a Haskell Writing foldl using foldr - StackOverflow Haskell：用foldr定义foldl 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/53e482b7.html"},{"title":"「Learn Haskell」#1 基础语法与函数","text":"&lt; #0 #2 &gt; 基础运算 + - * / ()：加减乘除 div：整除 mod：取模 True False：布尔值 || &amp;&amp; not：或且非 ==：条件判断，相等 /=：条件判断，不等 函数调用Haskell中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开： 12ghci&gt; max 1 22 前缀（prefix）函数与中缀（infix）函数转换： 对前缀函数加``使其变成中缀函数 对中缀函数加()使其变成前缀函数 12345678ghci&gt; 4 `div` 22ghci&gt; 1 `max` 22ghci&gt; (+) 1 23ghci&gt; (||) True FalseTrue List列表是Haskell中很常见的数据类型，和Python中不同，Haskell中的列表中的所有元素必须是同一个类型。 以下是列表常用的函数： (++) :: [a] -&gt; [a] -&gt; [a]：合并两个列表 (:) :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。[1, 2, 3]是1:2:3:[]的语法糖 (!!) :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。a !! 1相当于Python中的a[1] head :: [a] -&gt; a：返回列表的第一个元素 tail :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]） last :: [a] -&gt; a：返回列表中的最后一个元素 init :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表 length :: Foldable t =&gt; t a -&gt; Int：返回列表的长度 null :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空 reverse :: [a] -&gt; [a]：返回翻转后的列表 take :: Int -&gt; [a] -&gt; [a]：返回列表a的前n个元素的列表(take n a) drop :: Int -&gt; [a] -&gt; [a]：返回列表a中除去前n个元素后的列表(drop n a) maximum :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值 minimum :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值 sum :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和 product :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积 elem :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值n是否在列表a中( 123elem n a-- 或n `elem` a --用``包上可以变成中缀函数使用 Texas ranges使用..可以表示出范围并自动推导： 123456789101112ghci&gt; [1 .. 10] [1,2,3,4,5,6,7,8,9,10] ghci&gt; ['a' .. 'z'] &quot;abcdefghijklmnopqrstuvwxyz&quot; ghci&gt; ['K' .. 'Z'] &quot;KLMNOPQRSTUVWXYZ&quot; ghci&gt; [2, 4 .. 20] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [3, 6 .. 20] [3,6,9,12,15,18]ghci&gt; [5, 4 .. 1][5,4,3,2,1] 也可以用来生成无穷列表，如[1..]、[1, 3..]。同时也有函数可以生成无穷列表： cycle :: [a] -&gt; [a]：将原列表不断循环生成无穷列表 repeat :: a -&gt; [a]：将传入的值不断重复生成无穷列表 replicate :: Int -&gt; a -&gt; [a]：将值a重复n次，返回生成的列表(replicate n a) List comprehensionHaskell中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件 12345678ghci&gt; [x * 2 | x &lt;- [1 .. 10]] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [x * 2 | x &lt;- [1 .. 10], x * 2 &gt;= 12] [12,14,16,18,20]ghci&gt; [ x | x &lt;- [50 .. 100], x `mod` 7 == 3] [52,59,66,73,80,87,94] ghci&gt; [x * y | x &lt;- [2, 5, 10], y &lt;- [8, 10, 11]] [16,20,22,40,50,55,80,100,110] TupleHaskell中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数： fst :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素 snd :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素 zip :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组 Syntax in Functions函数可以直接定义： 1plus x y = x + y 这时Haskell会自动推断函数的类型为(Num a) =&gt; a -&gt; a -&gt; a。但是最好在定义函数前声明函数的类型： 12plus :: (Num a) =&gt; a -&gt; a -&gt; aplus x y = x + y Pattern matching定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如： 123factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial (n - 1) 12345678first :: (a, b, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z 其中_表示任何值，且不关心它的内容，只是用来占位 列表的(:)操作也可以用来进行模式匹配： 1234567head' :: [a] -&gt; a head' [] = error &quot;Can't call head on an empty list, dummy!&quot; head' (x:_) = xsum' :: (Num a) =&gt; [a] -&gt; a sum' [] = 0 sum' (x:xs) = x + sum' xs 但(++)操作不可以用来模式匹配 在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用xs@(q:qs)。比如[1, 2, 3]通过xs@(q:qs)匹配后，xs为[1, 2, 3]，q为1，qs为[2, 3] Guard syntax在函数的定义中，也可以使用守卫（guard）语法： 1234max' :: (Ord a) =&gt; a -&gt; a -&gt; a max' a b | a &gt; b = a | otherwise = b 先给出传入的参数变量，然后下一行缩进后加|，|后面等号前表示进行的判断，如果为True则返回这个等号后面的值；如果为False则继续判断下一行，直到otherwise Case expressions在函数的定义中，也可以使用case表达式来配合模式匹配使用： 123case expression of pattern -&gt; result pattern -&gt; result ... 例如： 1234567head' :: [a] -&gt; a head' [] = error &quot;No head for empty lists!&quot; head' (x:_) = x -- 等价于：head' :: [a] -&gt; a head' xs = case xs of [] -&gt; error &quot;No head for empty lists!&quot; (x:_) -&gt; x 12345678910describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot; [x] -&gt; &quot;a singleton list.&quot; xs -&gt; &quot;a longer list.&quot; -- 等价于：describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ what xs where what [] = &quot;empty.&quot; what [x] = &quot;a singleton list.&quot; what xs = &quot;a longer list.&quot; where声明在函数定义中要使用的局部变量，可以使用where关键字： 1234nitials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot; where (f:_) = firstname (l:_) = lastname 在where中，也可以使用上面的模式匹配 letlet &lt;bindings&gt; in &lt;expression&gt;语法可以在函数的定义中使用，也可以在普通算式或列表中使用： 12345cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r ^2 in sideArea + 2 * topArea 1234ghci&gt; 4 * (let a = 9 in a + 1) + 2 42 ghci&gt; [let square x = x * x in (square 5, square 3, square 2)] [(25,9,4)] if statementHaskell中的if语句为： 1234567if ... then ...else ...-- or if ... then ... else ...-- orif ... then ...else if ... then ...else ... 其中最后一个else无论如何也不可以省去 Reference Learn You a Haskell 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/d63b5b5f.html"},{"title":"修复manim中Text类的bug","text":"在使用manim时,对于Text类,会有一些bug,我尝试修复了它们 在shaders分支下无法使用Text类 Text文字的stroke边框不完整,导致显示stroke会非常难看 含有空格的Text的空格不在文字内部,而在ORIGIN的位置,导致Transform时会有字符在原位置和ORIGIN之间 反复横跳 Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小 这些问题已经通过#1030修复到了manim的master分支中 $\\mathcal{Bug\\ 1.}$当在shaders分支下使用Text类时会出现如下报错:其中最后一行让我发现此时的p0和p1的大小不相等,不能相加(broadcast),而p0和p1是通过贝赛尔曲线的次数(在shaders下是3)来拆分self.points的所以可能是self.points的长度不为3的倍数,导致了错误.在print(len(self.points))后发现确实是这样然后我又用了 玄学 手段,删掉了SVGMobject的最后一个点,发现可以正常渲染 此时我又去看了cairo自动生成的svg代码,根据我之前学svg的一点经验,发现每个&lt;path/&gt;的路径结尾都为Z M ... ... /&quot;&gt;而Z是将路径闭合,但闭合后又多出了一个M控制符,这会导致manim在处理svg时额外生成一个点而删掉每个路径字符串的最后一个M控制符,可以直接使用正则表达式匹配出来,然后替换掉 我第一个想到的正则表达式是Z M .*? /&quot;&gt;,但是如果在路径的中间出现Z M,则会将其后面有用的部分一起删除而有用的部分一定含有控制符,所以将控制符排除,就可以仅仅匹配掉最后一个M,正则表达式:Z M [^A-Za-z]*? /&quot;&gt; 123456def remove_last_M(self, file_name): with open(file_name, 'r') as fpr: content = fpr.read() content = re.sub(r'Z M [^[A-Za-z]*? &quot;\\/&gt;', 'Z &quot;/&gt;', content) with open(file_name, 'w') as fpw: fpw.write(content) $\\mathcal{Bug\\ 2.}$Text文字的stroke边框不完整,导致stroke显示不全,也会对DrawBorderThenFill造成影响,也有B站的观众向我提了这个问题 – 话说，感觉每个Chapter之间的文字是不是先画出轮廓再填充上色，画完轮廓的时候停顿了一下。但是停顿的时候轮廓没有画完，有些地方有点断续的感觉– Text类的bug，stroke日常乱套 为了解决这个问题,我只显示了stroke,并且用debugTeX标出了构成每个字符的self.points的位置,比如”manim”如下:通过观察和与@XiaoYoung交流之后,确定了cairo生成的svg并不能使路径自动闭合而在一般查看svg的软件(Chrome)中,svg图像只显示内部(fill),而stroke被忽略(很细),所以正常使用没问题但是在manim中有时需要使用stroke,这时cairo生成的svg出现了bug,路径没有完全闭合 我最开始的想法是直接通过.add_line_to()方法将svg收尾相连,但是这显然只解决了m和n而a和i是由两条路径复合而成的,其中的每条路径都没有闭合,所以都需要手动闭合,所以我决定遍历self.points这时我使用了一个last变量来记录遍历到当前位置所在的路径上的起点,并且如果到了下一条路径(索引为nppc的倍数,并且不与前一个点相重合),就将首尾连接上,并更新last 而这样做还需要一个特判,当points为空时(空格)直接跳过,否则points[0]会报错 12345678910111213nppc = self.n_points_per_cubic_curvefor each in self: if len(each.points) == 0: continue points = each.points last = points[0] each.clear_points() for index, point in enumerate(points): each.append_points([point]) if index != len(points) - 1 and (index + 1) % nppc == 0 and any(point != points[index+1]): each.add_line_to(last) last = points[index + 1] each.add_line_to(last) 这样做之后,这个bug就完全解决了,而且中文也同时适用,对比如下,上为修复之前,下为修复之后(都为仅显示stroke) $\\mathcal{Bug\\ 3.}$这个是非常常见的问题了,如下:之前解决这个问题是通过’假空格’,即用一个不常用字符表示空格,并将其设为背景色,或者opacity改成0通过debugTeX可以发现,Text的空格占字符而且位置在ORIGIN而TextMobject中的空格直接不占位置.所以我直接在处理bug2的同时,将len(each.points) == 0的处理中加上了self.remove(each),这样就暂时解决了而@XiaoYoung也提醒了我,这样的处理会干扰t2c的自动上色(下标改变了),在#1018这里,他决定单开一个pr来修复这个bug,所以我就把这一个commit删除掉了 $\\mathcal{Bug\\ 4.}$Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小通过阅读源码可以发现,TextMobject在__init__()的结尾,有一句 12if self.height is None: self.scale(TEX_MOB_SCALE_FACTOR) 而这个TEX_MOB_SCALE_FACTOR默认为0.05,即将默认的SVGMobject(高度为固定默认值)缩小为0.05倍而Text类最后缩小了0.1倍,导致了大小不等,将其改为0.05后,就方便统一大小了 $\\mathcal{Pull\\ Requests}$第一次提交pr,记录一下 将原repo fork到自己的用户上 clone下来fork的repo 进行更改,add/commit/push,commit的注释要规范 在GitHub网页上,打开fork的repo,会有一个按钮New Pull Request 比较,确认更改,然后Create Pull Request,表述出pr的必要性和验证,提交pr 等待repo管理员merge 这次修复bug的pr在#1030和#1031其中#1030被merge了,而#1031还在等待","link":"/p/b6815e8.html"},{"title":"树上莫队-笔记  &#x2F;「SPOJ 10707」COT2-题解","text":"通过SPOJ 10707 COT2-Count on a tree II这道题目来学习一下 树上莫队当需要离线查询 树上 的多区间问题时,可以使用 树上莫队 来解决 主要通过 欧拉序 将树转化为一条链,然后在链上执行普通莫队的操作 树上莫队欧拉序正常进行dfs,在入和出时各加入序列中比如样例的树如下:其欧拉序为1 2 2 3 5 5 6 6 7 7 3 4 8 8 4 1可以很好地呈现出子树的关系,即两个相同的数$x$之间的部分为$x$子树中的节点其有一个性质:区间内出现两次的点不在其路径上根据这个性质,可以将树转化为链来求解了 思想除了将树转化为欧拉序之外,还需要求出左右端点的$LCA$,以及一个点$\\texttt{u}$在欧拉序中第一次出现的位置$\\texttt{fst[u]}$,第二次(最后一次)出现的位置$\\texttt{lst[u]}$ 在进行莫队操作时,如果第一次经过这个点,则add其贡献,第二次经过这个点,则说明这个点不在所求链上,del其贡献这个用一个vis数组,反复进行异或操作就可以解决 再考虑询问的区间的$l,r$应该赋值为$\\texttt{fst}$还是$\\texttt{lst}$设左端点的深度小于右端点 如果$LCA$和左端点相等,则说明$[l,r]$在一条链上,$l$和$r$均取$\\texttt{fst}$即可 否则是两条链$[l, LCA],[LCA,r]$, 防止左右端点被统计两次导致贡献被删除,需要$l$取$\\texttt{lst}$,$r$取$\\texttt{fst}$ 最后考虑贡献 若是上面第一种情况,在一条链上,直接统计欧拉序区间内所有点即可,重复两次的根据前文的性质会直接删掉 若是上面第二种情况,由于左右端点都在$LCA$这颗子树内,所以区间中并不会出现$LCA$,但是却一定会经过,所以额外将$LCA$加入贡献,并且记录下当前结果之后,再将其贡献减去,防止影响下一个查询 注意: 转化为欧拉序之后的序列长度为$2n$ 时间复杂度 dfs: $O(n)$ 求$LCA$:$O(n\\log n)$ 莫队: $O(n\\sqrt{n})$ 综上,树上莫队的复杂度 差不多 也是$O(n\\sqrt{n})$ 针对$\\mathcal{SP10707}$的具体实现没啥说的,模板题,做法全在上面了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 200020;int n, m, l, r, Ans, len, ocnt;int cnt[maxn], fst[maxn], lst[maxn], vis[maxn], ans[maxn];int ord[maxn], val[maxn], dep[maxn], fa[maxn][25], old[maxn];struct Query { int l, r, id, pos, lca;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; if (a.pos &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;}struct Edge { int from, to; Edge(int f, int t): from(f), to(t) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int f, int t) { edges.push_back(Edge(f, t)); edges.push_back(Edge(t, f)); int mm = edges.size(); G[t].push_back(mm - 1); G[f].push_back(mm - 2);}void dfs(int u, int f) { ord[++ocnt] = u; fst[u] = ocnt; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to == f) continue; dep[e.to] = dep[u] + 1; fa[e.to][0] = u; for (int j = 1; j &lt;= 20; ++j) { fa[e.to][j] = fa[fa[e.to][j - 1]][j - 1]; } dfs(e.to, u); } ord[++ocnt] = u; lst[u] = ocnt;}int lca(int x, int y) { if (dep[x] &gt; dep[y]) swap(x, y); for (int i = 20; i &gt;= 0; --i) { if (dep[fa[y][i]] &gt;= dep[x]) y = fa[y][i]; } if (x == y) return x; for (int i = 20; i &gt;= 0; --i) { if (fa[x][i] != fa[y][i]) { x = fa[x][i]; y = fa[y][i]; } } return fa[x][0];}void add(int x) { cnt[val[x]]--; if (!cnt[val[x]]) Ans--;}void del(int x) { cnt[val[x]]++; if (cnt[val[x]] == 1) Ans++;}void chg(int x) { if (vis[x]) add(x); else del(x); vis[x] ^= 1;}int main() { n = read(); m = read(); len = sqrt(2 * n); for (int i = 1; i &lt;= n; ++i) old[i] = val[i] = read(); sort(old + 1, old + 1 + n); int len_ = unique(old + 1, old + 1 + n) - old - 1; for (int i = 1; i &lt;= n; ++i) val[i] = lower_bound(old + 1, old + 1 + len_, val[i]) - old; for (int i = 1; i &lt; n; ++i) add(read(), read()); dep[1] = 1; dfs(1, 0); for (int i = 1; i &lt;= m; ++i) { int il = read(), ir = read(); int LCA = lca(il, ir); if (fst[il] &gt; fst[ir]) swap(il, ir); if (il == LCA) { q[i].l = fst[il]; q[i].r = fst[ir]; } else { q[i].l = lst[il]; q[i].r = fst[ir]; q[i].lca = LCA; } q[i].id = i; q[i].pos = (q[i].l - 1) / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int i = 1; i &lt;= m; ++i) { while (l &lt; q[i].l) chg(ord[l++]); while (r &gt; q[i].r) chg(ord[r--]); while (l &gt; q[i].l) chg(ord[--l]); while (r &lt; q[i].r) chg(ord[++r]); if (q[i].lca) chg(q[i].lca); ans[q[i].id] = Ans; if (q[i].lca) chg(q[i].lca); } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/p/24f5ddbc.html"},{"title":"回滚莫队-笔记  &#x2F;「AtCoder 1219」歴史の研究-题解","text":"通过AtCoder 1219 歴史の研究这道题目来学习一下 回滚莫队回滚莫队 适用于容易进行add操作,而不容易实现del的情况 通过莫队的分块,指针移动的思想,可以让左指针进行回滚操作, 近似 达到del的效果 回滚莫队思想由于莫队对所有询问离线排序后,当左端点在同一个块内时,右端点递增所以对于每个块,右指针直接向右依次执行add操作即可 对于左指针,在一个块内时,可以每次都从块的右边界向左进行add,由于不方便进行del操作,所以可以先记录下左指针在右边界时的Ans,然后每次向左移动到q[i].l时,将左指针再移回右边界,并且将Ans回滚到移动之前的值。由于分块,这样做的复杂度也不会很大 综上,对于每个块,右指针依次向右推进,左指针在右边界和查询的左端点之间反复横跳这样,执行的就只剩add操作,通过左指针的横跳,避免了del操作 注意,当左右端点都在同一个块时,只要暴力求出结果就可以了一定要注意: 不要使用奇偶排序,必须保证右端点的 单调递增 对于每个块内的处理,大概如下图: 时间复杂度时间复杂度由以下几个方面组成 询问排序 同一个块内的暴力求解 左指针的移动(横跳) 右指针的顺次移动 下面来 不严谨 简要地计算一下时间复杂度 排序:$O(n\\log n)$ 暴力:暴力的区间最长为$\\sqrt{n}$,所以单次暴力的复杂度为$O(\\sqrt{n})$,$n$次暴力的复杂度为$O(n\\sqrt{n})$其实到不了n次 左指针移动: 进行add操作的复杂度为$O(1)$,块长$\\sqrt{n}$,每次左移最坏复杂度$O(\\sqrt{n})$,回滚时仍需要$O(\\sqrt{n})$清除贡献所以对于所有块,一共要移动$q$次,总的复杂度为$O(2q\\sqrt{n})$ 右指针移动: 对于每个块,最坏只要移动$n$次,一共$\\sqrt{n}$个块,所以复杂度为$O(n\\sqrt{n})$ 综上,总的复杂度为$O(n\\log n)+O(2q\\sqrt{n})+O(n\\sqrt{n})\\ \\sim\\ O(n\\sqrt{n})$ 针对$\\mathcal{AT1219}$的具体实现添加贡献的add操作很容易实现 1234void add(int x) { cnt[a[x]]++; Ans = max(Ans, 1LL * cnt[a[x]] * old[a[x]]);} 同一块内的暴力也很容易实现 123456789LL solve(int l, int r) { LL res = 0; for (int i = l; i &lt;= r; ++i) cnt2[a[i]] = 0; for (int i = l; i &lt;= r; ++i) { cnt2[a[i]]++; res = max(res, 1LL * cnt2[a[i]] * old[a[i]]); } return res;} 其余情况下根据前面所说,可以实现 123456while (r &lt; q[i].r) add(++r); // 右指针右移,添加贡献LL tmp = Ans; // 记录左指针移动前的答案while (l &gt; q[i].l) add(--l); // 左指针左移,添加贡献ans[q[i].id] = Ans;while (l &lt; rpos[k] + 1) cnt[a[l++]]--; // 左指针移动回右边界,并途中删除对cnt的贡献Ans = tmp; // 回滚到移动前的答案 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 100010;int n, m, len, l, r;int a[maxn], cnt[maxn], rpos[maxn], old[maxn], cnt2[maxn];LL Ans, ans[maxn];struct Query { int l, r, id, pos;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}LL solve(int l, int r) { LL res = 0; for (int i = l; i &lt;= r; ++i) cnt2[a[i]] = 0; for (int i = l; i &lt;= r; ++i) { cnt2[a[i]]++; res = max(res, 1LL * cnt2[a[i]] * old[a[i]]); } return res;}void add(int x) { cnt[a[x]]++; Ans = max(Ans, 1LL * cnt[a[x]] * old[a[x]]);}int main() { n = read(); m = read(); len = sqrt(n); int num = ceil((double)n / len); for (int i = 1; i &lt;= num; ++i) rpos[i] = len * i; rpos[num] = n; for (int i = 1; i &lt;= n; ++i) old[i] = a[i] = read(); sort(old + 1, old + 1 + n); int len_ = unique(old + 1, old + 1 + n) - old - 1; for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(old + 1, old + 1 + len_, a[i]) - old; for (int i = 1; i &lt;= m; ++i) { q[i].l = read(); q[i].r = read(); q[i].id = i; q[i].pos = (q[i].l - 1) / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int k = 1, i = 1; k &lt;= num; ++k) { l = rpos[k] + 1, r = rpos[k], Ans = 0; memset(cnt, 0, sizeof(cnt)); while (q[i].pos == k) { if (q[i].l / len == q[i].r / len) { ans[q[i].id] = solve(q[i].l, q[i].r); i++; continue; } while (r &lt; q[i].r) add(++r); LL tmp = Ans; while (l &gt; q[i].l) add(--l); ans[q[i].id] = Ans; while (l &lt; rpos[k] + 1) cnt[a[l++]]--; Ans = tmp; i++; } } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%lld\\n&quot;, ans[i]); } return 0;}","link":"/p/7d7b5548.html"},{"title":"带修莫队-笔记  &#x2F;「Luogu P1903」数颜色-题解","text":"通过Luogu P1903 数颜色/维护序列这道题目来学习一下 带修莫队顾名思义,带修莫队 不仅要支持普通莫队的查询操作,还要支持数据中途的修改 比如这道题目,需要实现以下目标 查询$[L,R]$区间内不同颜色画笔的种数 将$pos$处的画笔替换为$color$颜色 达到这个目标,可以在普通莫队的基础上加一个时间维度,实现 带修莫队 带修莫队时间戳这里的每个查询的时间戳规定为 最近修改操作的时间戳,即最近一次修改是第几次修改修改操作会增加总时间戳,查询操作不会增加时间戳 思想在普通莫队的左右两个指针的基础之上 增加 一个 时间戳指针当左右端点及时间戳移动到均和当前查询的一致,就可以记录下当前答案 所以需要在普通莫队的基础之上加上修改时间戳的修改操作,并加上以下两个判断 12while (t &lt; q[i].t) chg(++t);while (t &gt; q[i].t) chg(t--); 当当前时间小于询问时间时,先将当前时间$+1$,再修改当当前时间大于询问时间时,先修改,再将当前时间$-1$ 与普通莫队还有一点不同:所有询问的排序方法,先按照左端点分块升序,再按照右端点 分块升序,最后按照时间戳升序这样复杂度才会达到最优,节省了一系列不必要的操作 时间复杂度当分块的大小为$n^{\\frac{2}{3}}$时,复杂度最小为$O(n^{\\frac{5}{3}})$具体分析见上一篇文章:浅析莫队算法的时间复杂度 针对$\\mathcal{P1903}$的具体实现在每个询问Query的结构体内加一个时间戳$t$,并且按照上文实现排序 12345678struct Query { int l, r, t, id;}q[maxn];bool cmp(Query a, Query b) { if (block[a.l] != block[b.l]) return block[a.l] &lt; block[b.l]; if (block[a.r] != block[b.r]) return block[a.r] &lt; block[b.r]; return a.t &lt; b.t;} 再建一个结构体Change,表示每次修改操作的数据,需要$pos$和$color$ 123struct Change { int pos, color;}c[maxn]; 正常的add/del操作不再赘述现在来看一下修改时间对应数据的操作 当当前时间的操作的位置$pos$在当前区间$[l,r]$时,对答案有影响,需要调整当前答案先将$pos$位置上的贡献删去,再将当前修改操作的$color$添加进去 将$pos$位置上的数与$color$交换,这样可以保证之后可以再换回来 实现如下: 1234567void chg(int t) { if (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) { if (--cnt[a[c[t].pos]] == 0) Ans--; // 删除贡献 if (cnt[c[t].color]++ == 0) Ans++; // 添加贡献 } swap(a[c[t].pos], c[t].color); // 交换} 另外这题修改数据后严重卡常,手动开了O3,Ofast,inline才过 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#pragma GCC optimize(3)#pragma GCC optimize(&quot;Ofast&quot;)#pragma GCC optimize(&quot;inline&quot;)#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 140000;int n, m, l, r, t, len, cntq, cntr, Ans;int a[maxn], cnt[1000010], ans[maxn], block[maxn];struct Query { int l, r, t, id;}q[maxn];bool cmp(Query a, Query b) { if (block[a.l] != block[b.l]) return block[a.l] &lt; block[b.l]; if (block[a.r] != block[b.r]) return block[a.r] &lt; block[b.r]; return a.t &lt; b.t;}struct Change { int pos, color;}c[maxn];void add(int x) { if (cnt[a[x]] == 0) Ans++; cnt[a[x]]++;}void del(int x) { if (cnt[a[x]] == 1) Ans--; cnt[a[x]]--;}void chg(int t) { if (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) { del(c[t].pos); if (cnt[c[t].color] == 0) Ans++; cnt[c[t].color]++; } swap(a[c[t].pos], c[t].color);}int main() { n = read(); m = read(); len = pow(n, 2.0 / 3.0); for (int i = 1; i &lt;= n; ++i) { a[i] = read(); block[i] = (i - 1) / len + 1; } for (int i = 1; i &lt;= m; ++i) { char opt[10]; scanf(&quot;%s&quot;, opt); if (opt[0] == 'Q') { q[++cntq].l = read(); q[cntq].r = read(); q[cntq].id = cntq; q[cntq].t = cntr; } else { c[++cntr].pos = read(); c[cntr].color = read(); } } sort(q + 1, q + 1 + cntq, cmp); l = 1; for (int i = 1; i &lt;= cntq; ++i) { while (l &lt; q[i].l) del(l++); while (r &gt; q[i].r) del(r--); while (l &gt; q[i].l) add(--l); while (r &lt; q[i].r) add(++r); while (t &lt; q[i].t) chg(++t); while (t &gt; q[i].t) chg(t--); ans[q[i].id] = Ans; } for (int i = 1; i &lt;= cntq; ++i) { printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/p/838c5e29.html"},{"title":"浅析莫队算法的时间复杂度","text":"这篇文章来记录一下莫队算法时间复杂度的简单(不严谨)计算 首先分析一下莫队算法的时间复杂度有哪些方面构成 对询问Query数组的排序 区间左指针的移动 区间右指针的移动 时间复杂度每个add/del操作的复杂度为$O(1)$ 排序使用sort可以在$O(n\\log n)$内完成 由于左指针在排序中被分块,所以又分为块内移动和块间移动 块内: 设每块中含左端点$x_i$个,由于每块大小为$\\sqrt{n}$,所以在块内移动的最坏复杂度为$O(x_i\\sqrt{n})$。因此对于所有块,将复杂度求和,即为$O(\\displaystyle\\sum_ix_i\\sqrt{n})=O(n\\sqrt{n})$ 块间: 左指针在每个块内移动之后,需要移动到下一个块内的左端点处,块间跳转最坏跨两个整块需要$O(2\\sqrt{n})$。总共需要跨$\\sqrt{n}-1$个块,所以复杂度为$O((\\sqrt{n}-1)\\times 2\\sqrt{n})\\sim O(n)$ 综上,左指针移动的复杂度为$O(n\\sqrt{n})$3. 当左指针在同一个块内时,右指针是有序的,因此当左指针在同一个块内时,右指针移动的最坏复杂度为$O(n)$即全部移动一遍。而每个块长度为$\\sqrt{n}$,总长为$n$,所以一共$\\sqrt{n}$个块,所以最坏复杂度为$O(n\\sqrt{n})$ 综上,普通莫队算法的时间复杂度为$$O(n\\log n)+O(n\\sqrt{n})+O(n\\sqrt{n})\\ \\sim\\ O(n\\sqrt{n})$$ 玄学的奇偶排序优化见图: 分块大小不为$\\sqrt{n}$还是和前面一样推复杂度,设块大小为$a&gt;1$ 排序: 需要$O(n\\log n)$ 左指针移动: 块内: $O(\\displaystyle\\sum_ix_ia)=O(na)$ 块间: $O((\\dfrac{n}{a}-1)\\times 2a)=O(n)$ 右指针移动: $O(n\\times \\dfrac{n}{a})=O(\\dfrac{n^2}{a})$ 综上,总的复杂度为$O(n\\log n)+O(na)+O(n)+O(\\dfrac{n^2}{a})=O(na+\\dfrac{n^2}{a})$根据均值不等式,若让上式复杂度最小,则需要$na=\\dfrac{n^2}{a}$,即$a=\\sqrt{n}$所以当含有左右两个指针时,分块大小为$\\sqrt{n}$时总复杂度最小,为$O(n\\sqrt{n})$ 带修莫队(三指针)还是设分块的大小为$a&gt;1$,注意带修莫队排序优先级:先左端点所在块,再右端点所在块,后时间戳大小 排序: $O(n\\log n)$ 左指针移动: 同上推导,复杂度为$O(na)$ 右指针移动: 相同右端点的块的复杂度同上$O(na)$,还有换左端点决定的块时的复杂度约为$O(\\dfrac{n^2}{a})$ 时间戳移动: 由排序优先级可见,只有当右端点所在块相同时才会移动时间戳,而每次移动最坏需要移动$\\sum t \\sim n$对于每个左端点相同的块,右端点块数为$\\dfrac{n}{a}$,左端点有$\\dfrac{n}{a}$个,所以一共需要$O(\\dfrac{n}{a}\\times\\dfrac{n}{a}\\times n)=O(\\dfrac{n^3}{a^2})$ 综上,总的复杂度为$O(n\\log n)+O(na)+O(na)+O(\\dfrac{n^2}{a})+O(\\dfrac{n^3}{a^2})\\ \\sim\\ O(na+\\dfrac{n^2}{a}+\\dfrac{n^3}{a^2})$ 由于$1&lt;a&lt;n$,所以$\\dfrac{\\dfrac{n^2}{a}}{\\dfrac{n^3}{a^2}}=\\dfrac{a}{n}&lt;1 \\Rightarrow \\dfrac{n^2}{a}&lt;\\dfrac{n^3}{a^2}$,所以原式可化为$O(na+\\dfrac{n^3}{a^2})$ 根据均值不等式,当$na=\\dfrac{n^3}{a^2}$时上式最小,即$a=\\sqrt[3]{n^2}=n^{\\frac{2}{3}}$所以含有三个指针时,分块大小为$n^{\\frac{2}{3}}$时总复杂度最小,为$O(n^{\\frac{5}{3}})=O(n\\sqrt[3]{n^2})$","link":"/p/681257d9.html"},{"title":"「网络流24题」总结及图示","text":"问题编号 问题名称 问题模型 转化模型 1 飞行员配对方案问题 二分图最大匹配 网络最大流 2 太空飞行计划问题 最大权闭合图 网络最小割 3 最小路径覆盖问题 有向无环图最小路径覆盖 网络最大流 4 魔术球问题 有向无环图最小路径覆盖 网络最大流 5 圆桌问题 二分图多重匹配 网络最大流 6 最长不下降子序列问题 最多不相交路径 网络最大流 7 试题库问题 二分图多重匹配 网络最大流 8 机器人路径规划问题 $IDA*$ $IDA*$ 9 方格取数问题 二分图点权最大独立集 网络最小割 10 餐巾计划问题 线性规划网络优化 最小费用最大流 11 航空路线问题 最长不相交路径 最小费用最大流 12 软件补丁问题 最小转移代价 最短路径 13 星际转移问题 网络判定 网络最大流 14 孤岛营救问题 分层图最短路径 最短路径 15 汽车加油行驶问题 分层图最短路径 最短路径 16 数字梯形问题 最大权不相交路径 最小费用最大流 17 运输问题 网络费用流量 最小费用最大流 18 分配问题 二分图最佳匹配 最小费用最大流 19 负载平衡问题 最小代价供求 最小费用最大流 20 深海机器人问题 线性规划网络优化 最小费用最大流 21 最长k可重区间集问题 最大权不相交路径 最小费用最大流 22 最长k可重线段集问题 最大权不相交路径 最小费用最大流 23 火星探险问题 线性规划网络优化 最小费用最大流 24 骑士共存问题 二分图最大独立集 网络最小割 二分图 最大匹配: 匈牙利/最大流 带权匹配: KM/费用流 最小点覆盖: =最大匹配 最小边覆盖: =总结点数-最大匹配 最大独立集: =总结点数-最大匹配 网络流 建立超级源点,超级汇点 点存在限制,拆成出入点,将出入点之间的边看做点,限制流量 建图考虑左右二部 超级源点向源点的边可以限制总流量 无源汇有容量下界:s-下界-&gt;v u-下界-&gt;t u-上界减下界-&gt;v,当满流时存在可行流 最小割中赋流量为inf则一定不会割去 一些求最大问题,可以用sum-最小割 最大权闭合图: 建图,最小割,仍和s相连的为最大权闭合图,权值和为sum-最小割 24题 直接建二分图,最大流求最大匹配 最大权闭合图,建边,实验和仪器之间保证不切割容量为inf,跑最小割,找与s相连的实验和仪器 最大独立集,总结点数-最大流 贪心 二分图多重匹配,s-&gt;左点集和右点集-&gt;t之间的边容量不为1(即可以选多次) 动态规划+按照动态规划的dp数组的意义建边求最大流 二分图多重匹配,类型-题目数-&gt;汇点,保证可选多个,存在满流则存在答案沿满流输出 $IDA*$爆搜,但洛谷数据应该有问题 抽象出两个点集,求最大独立集 按照题目说明建图,跑费用流 按照题目说明建图,跑费用流 将错误状态进行压缩,然后跑最短路 根据时间逐层建图,直到跑出可行流 将拥有钥匙进行压缩,跑最短路 建出分层图,跑最短路或者费用流 对三个规则分别建图,跑费用流 纯费用流 二分图最佳匹配,使用费用流 费用流,注意环形 按照题目要求建图,跑费用流 离散化,将区间转化为边,费用流 转化问题,变成21题,注意端点处理和垂直于x轴的线段 按照题目要求建图,跑费用流,方案dfs 将图上所有格点转化为两个点集,建二分图,求最大独立集 图示更新中","link":"/p/dccbc6bb.html"},{"title":"「Luogu P1494」小Z的袜子-题解","text":"题目传送门: 「Luogu P1494」小Z的袜子一道推公式，后使用莫队 玄学 优化的题目 题目大意给出$n$个袜子,第$i$只袜子的颜色为$c_i$有$m$个询问,用$L,R$表示在区间$[L,R]$中随机取袜子,求取出两只袜子颜色相同的概率(最简分数) 题解考虑区间$[L,R]$,其中颜色为$A$的袜子有$a$只,颜色为$B$的袜子有$b$只$…$ 取出两只袜子的总情况数为$$C_{R-L+1}^2=\\frac{(R-L+1)(R-L)}{2}$$取出两只袜子颜色都为$A$的情况数为$$C_a^2=\\frac{a(a - 1)}{2}$$所以,取出两只袜子颜色相同的情况数为$$\\sum_{i}C_i^2=C_a^2+C_b^2+…=\\frac{a(a-1)}{2}+\\frac{b(b-1)}{2}+…$$所以最终的概率为$$\\begin{aligned}P&amp;=\\frac{\\displaystyle\\sum_{i}C_i^2}{C_{R-L+1}^2}\\\\\\\\&amp;=\\dfrac{\\dfrac{a(a-1)}{2}+\\dfrac{b(b-1)}{2}+…}{ \\dfrac{(R-L+1)(R-L)}{2} }\\\\\\\\&amp;=\\dfrac{a^2+b^2+…-a-b-…}{(R-L+1)(R-L)}\\\\\\\\&amp;=\\dfrac{\\displaystyle\\sum_ii^2-\\displaystyle\\sum_ii}{(R-L+1)(R-L)}\\\\\\\\&amp;=\\dfrac{\\displaystyle\\sum_ii^2-(R-L+1)}{(R-L+1)(R-L)}\\end{aligned}$$所以要求的就是$\\displaystyle\\sum_ii^2$,可以用莫队来维护区间平方和得到 对于最终结果的表达式,令$a=$分子,$b=$分母,求出$ab$的最大公约数,并除去最终答案即为$a/b$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b); }const int maxn = 50010;struct Query { int l, r, pos, id;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; if (a.pos &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;}struct Answer { LL a, b;}ans[maxn];int n, m, l, r, Ans, len;LL c[maxn], cnt[maxn];void del(int x) { Ans -= cnt[c[x]] * cnt[c[x]]; cnt[c[x]]--; Ans += cnt[c[x]] * cnt[c[x]];}void add(int x) { Ans -= cnt[c[x]] * cnt[c[x]]; cnt[c[x]]++; Ans += cnt[c[x]] * cnt[c[x]];}int main() { n = read(); m = read(); len = sqrt(n); for (int i = 1; i &lt;= n; ++i) c[i] = read(); for (int i = 1; i &lt;= m; ++i) { q[i].l = read(); q[i].r = read(); q[i].id = i; q[i].pos = q[i].l / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int i = 1; i &lt;= m; ++i) { while (l &lt; q[i].l) del(l++); while (r &gt; q[i].r) del(r--); while (l &gt; q[i].l) add(--l); while (r &lt; q[i].r) add(++r); if (l == r) { ans[q[i].id].a = 0; ans[q[i].id].b = 1; continue; } LL a = Ans - (r - l + 1); LL b = 1LL * (r - l + 1) * (LL)(r - l); LL g = gcd(a, b); ans[q[i].id].a = a / g; ans[q[i].id].b = b / g; } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%lld/%lld\\n&quot;, ans[i].a, ans[i].b); } return 0;}","link":"/p/49548215.html"},{"title":"「网络流24题」负载平衡问题-题解","text":"题目传送门: 「Luogu P4016」负载平衡问题 题目大意有$n$个环形的仓库,每个仓库存储一定数量的货物货物可以在相邻仓库之间搬运,最终达到每个仓货物数量一样的效果 求最少搬运次数 题解看题解说可以用数学方法推导,但是在24题里还是选择用费用流水过 先求出平均数,即目标然后将每个仓库的货物数减去平均数,得出需要移动的数量 如果大于$0$,则从 源点 向 该仓库 建一条 容量为差值,费用为$0$ 的边(需要转移出,对答案无贡献) 如果小于$0$,则从 该仓库 向 汇点 建一条 容量为差值绝对值,费用为$0$ 的边(吸收这些货物,对答案无贡献) 从 每个仓库 向 相邻两个仓库 建一条 容量为$inf$,费用为$1$ 的边(转移货物的数量无要求,对答案贡献为$1$) 注意建边3.需要考虑环形求出最小费用最大流,最小费用即为结果 因为费用流大前提是满足最大流,而且此图中源点出发的与流入汇点的边的容量和相等,所以最大流情况下一定会全部流过,即达到仓库货物数量平衡 代码1234567891011121314151617181920212223// 最小费用最大流模板省去了int num[110], tot;int main() { n = read(); s = 0; t = n + 1; for (int i = 1; i &lt;= n; ++i) { num[i] = read(); tot += num[i]; } tot /= n; for (int i = 1; i &lt;= n; ++i) { if (num[i] - tot &gt; 0) add(s, i, num[i] - tot, 0); if (num[i] - tot &lt; 0) add(i, t, tot - num[i], 0); if (i != 1) { add(i, i - 1, inf, 1); add(i - 1, i, inf, 1); } } add(1, n, inf, 1); add(n, 1, inf, 1); ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/b8624866.html"},{"title":"「网络流24题」运输问题-题解","text":"题目传送门: 「Luogu P4015」运输问题 题目大意$m$个仓库,$n$个商店,每个仓库有$a_i$个货物,每个商店需要$b_i$个货物需要从仓库运输货物到商店中,且第$i$个仓库运输到第$j$个商店费用为$c_{i,j}$ 求最小费用和最大费用 题解和P4015 分配问题一样将所有仓库和所有商店各分为一个点集 从 源点 向 每个仓库 建一条 容量为货物个数$a_i$,费用为$0$ 的边(有$a_i$个货物需要运出,且对答案无贡献) 从 每个商店 向 汇点 建一条 容量为货物个数$b_i$,费用为$0$ 的边(需要$b_i$个货物,且对答案无贡献) 从 每个仓库 向 每个商店 建一条 容量为$inf$,费用为对应费用 的边(每个仓库可以运出的最多货物不限制,且对答案工作为对应费用) 求出最小费用最大流和最大费用最大流即可 由于费用流的大前提是流量最大,所以一定满足题目中要求的供需平衡即$\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$ 代码123456789101112131415161718192021222324252627282930313233343536373839// 费用流模板省略,在P4015题解那里有// 代码里为了方便把mn调换了int input1[110], input2[110], input3[110][110];int main() { n = read(); m = read(); s = 0; t = n + m + 1; for (int i = 1; i &lt;= n; ++i) { int c = read(); input1[i] = c; add(s, i, c, 0); } for (int i = 1; i &lt;= m; ++i) { int c = read(); input2[i] = c; add(i + n, t, c, 0); } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { int c = read(); input3[i][j] = c; add(i, j + n, inf, c); } } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); for (int i = 1; i &lt;= n; ++i) add(s, i, input1[i], 0); for (int i = 1; i &lt;= m; ++i) add(i + n, t, input2[i], 0); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { add(i, j + n, inf, input3[i][j]); } } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/152673e9.html"},{"title":"「网络流24题」分配问题-题解","text":"题目传送门: 「Luogu P4014」分配问题 题目大意有$n$件工作要分配给$n$个人做给出每个人做每个工件的效益$c_{i,j}$ 求最小效益和最大效益 题解裸的最小/大费用最大流将所有人和所有工作各分为一个点集 从 源点 向 所有人 建一条 容量为$1$,费用为$0$ 的边(只能选一次,且对答案无贡献) 从 所有工作 向 汇点 建一条 容量为$1$,费用为$0$ 的边(只能做一次,且对答案无贡献) 从 每个人 向 所有工作 建一条 容量为$1$,费用为对应效益 的边(只能做一种工作,且对答案工作为对应效益) 求出最小费用最大流和最大费用最大流 两个问之间要清空图并重建(因为求最大流过程中会修改flow) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 310;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost, int opt) { if (opt == 0) memset(d, 0x3f, sizeof(d)); else memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; bool judge; if (opt) judge = d[e.to] &lt; d[x] + e.cost; else judge = d[e.to] &gt; d[x] + e.cost; if (e.cap &gt; e.flow &amp;&amp; judge) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (!opt &amp;&amp; d[t] == inf) return false; if (opt &amp;&amp; d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost, 0)); return flow;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost, 1)); return flow;}int tmp[110][110];int main() { n = read(); s = 0; t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { int c = read(); tmp[i][j] = c; add(i, j + n, 1, c); } } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1, 0); add(i + n, t, 1, 0); } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { add(i, j + n, 1, tmp[i][j]); } } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1, 0); add(i + n, t, 1, 0); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/11b1dcbd.html"},{"title":"「网络流24题」数字梯形问题-题解","text":"题目传送门: 「Luogu P4013」数字梯形问题 题目大意梯形的第一行有$m$个数字从梯形的顶部的$m$个数字开始,在每个数字处可以沿左下或右下方向移动,形成一条从梯形的顶至底的路径。 有三种规则: 从梯形的顶至底的$m$条路径互不相交 从梯形的顶至底的$m$条路径仅在数字结点处相交 从梯形的顶至底的$m$条路径允许在数字结点相交或边相交 求每种规则下经过数字的最大总和 题解很明显是 最大费用最大流 规则1.路径不相交,即没有公共点,也就是每个点只能经过一次将每个点拆成入点和出点,就可以通过控制出入点之间的容量控制经过次数 从 源点 向 第一行的$m$个点的入点 接一条 容量为$1$,费用为$0$ 的边 从 最后一行每个点的出点 接一条 容量为$1$,费用为$0$ 的边 从 每个点的入点 向 每个点的出点 接一条 容量为$1$,费用为该点数字 的边(对答案贡献为该点数字) 从 每个点的出点 向 左下右下两个点的入点 接一条 容量为$1$,费用为$0$ 的边 规则2.每条路径仅在数字节点相交,也就是不能有重边无需拆点控制每个点经过的次数,只需给每条向左下右下的边的容量设为$1$,即只能经过一次 从 源点 向 第一行的$m$个点 接一条 容量为$1$,费用为$0$ 的边 从 最后一行每个点 接一条 容量为$inf$,费用为该点数字 的边(每个点可以使用多次) 从 每个点的 向 左下右下两个点 接一条 容量为$1$,费用为该点数字 的边 规则3.边也可以重合,也就相当于没有规则,可以随意向左下右下走只需将规则2.中建边3.的容量改成$inf$即可 对于每种情况,求出最大费用最大流,最大费用即为答案注意求解规则2.3.之前要清空建的图 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 最大费用最大流模板部分省去了int in[45][45];int point[45][45], cnt;int main() { m = read(); n = read(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m + i - 1; ++j) { in[i][j] = read(); point[i][j] = ++cnt; } } // Question 1 s = 0; t = cnt * 2 + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i] + cnt, t, 1, 0); for (int i = 1; i &lt;= n; ++i) { if (i &lt; n) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j] + cnt, point[i + 1][j], 1, 0); add(point[i][j] + cnt, point[i + 1][j + 1], 1, 0); } for (int j = 1; j &lt;= m + i - 1; ++j) add(point[i][j], point[i][j] + cnt, 1, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); // Question 2 edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); s = 0; t = cnt + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i], t, inf, in[n][i]); for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j], point[i + 1][j], 1, in[i][j]); add(point[i][j], point[i + 1][j + 1], 1, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); // Question 3 edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); s = 0; t = cnt + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i], t, inf, in[n][i]); for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j], point[i + 1][j], inf, in[i][j]); add(point[i][j], point[i + 1][j + 1], inf, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/86b4c1f9.html"},{"title":"「网络流24题」深海机器人问题-题解","text":"题目传送门: 「Luogu P4012」深海机器人问题 题目大意一个$P\\times Q$网格,机器人可以向北/东走,西南为$(0, 0)$,东北为$(Q, P)$每个网格边上有生物标本,和价值有$a$个起点,每个起点有不同的机器人个数有$b$个终点,每个终点有不同的机器人个数作为目的地 求采集到生物标本的最高总价值 题解最大费用最大流 每两个节点之间建一条 容量为$1$,费用为标本价值 的边,和一条 容量为$inf$,费用为$0$ 的边(标本只能采集一次) 从 源点 向 每个起点 建一条 容量为机器人个数,费用为$0$ 的边 从 每个终点 向 汇点 建一条 容量为机器人个数,费用为$0$ 的边 跑出最大费用最大流,最大费用即为结果 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 410;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int p_, q_;int point(int x, int y) { return (x - 1) * q_ + y;}int main() { int a_ = read(), b_ = read(); p_ = read() + 1; q_ = read() + 1; s = 0, t = p_ * q_ + 1; for (int i = 1; i &lt;= p_; ++i) { for (int j = 1; j &lt; q_; ++j) { int w = read(); add(point(i, j), point(i, j + 1), 1, w); add(point(i, j), point(i, j + 1), inf, 0); } } for (int i = 1; i &lt;= q_; ++i) { for (int j = 1; j &lt; p_; ++j) { int w = read(); add(point(j, i), point(j + 1, i), 1, w); add(point(j, i), point(j + 1, i), inf, 0); } } for (int i = 1; i &lt;= a_; ++i) { int k = read(), x = read() + 1, y = read() + 1; add(s, point(x, y), k, 0); } for (int i = 1; i &lt;= b_; ++i) { int r = read(), x = read() + 1, y = read() + 1; add(point(x, y), t, r, 0); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/cfb1d422.html"},{"title":"「网络流24题」孤岛营救问题-题解","text":"题目传送门: 「Luogu P4011」孤岛营救问题 题目大意起点为$(1,1)$,终点为$(n,m)$有些格子上有若干个钥匙，两个格子之间可能有一堵墙或者一扇可以用对应钥匙打开的门每次移动需要$1$个单位时间，其他动作不需要时间 求最少需要多少时间能从起点到达终点。 题解对拥有的钥匙状态进行压缩从起点到终点跑bfs即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 20;const int go[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};int n, m, p, k;int cnt[maxn][maxn], key[maxn][maxn][maxn];bool vis[maxn][maxn][1 &lt;&lt; 15];int edge[maxn][maxn][maxn][maxn];struct Node { int x, y; int keys, times; Node(int x, int y, int k, int t): x(x), y(y), keys(k), times(t) {}};queue&lt;Node&gt; q;int bfs() { int skey = 0; for (int i = 1; i &lt;= cnt[1][1]; ++i) skey |= (1 &lt;&lt; (key[1][1][i] - 1)); q.push(Node(1, 1, skey, 0)); vis[1][1][skey] = true; while (!q.empty()) { Node u = q.front(); q.pop(); if (u.x == n &amp;&amp; u.y == m) return u.times; for (int k = 0; k &lt; 4; ++k) { int vx = u.x + go[k][0], vy = u.y + go[k][1]; if (vx &lt; 1 || vx &gt; n || vy &lt; 1 || vy &gt; m) continue; int e = edge[u.x][u.y][vx][vy]; if (e &lt; 0 || (e &gt; 0 &amp;&amp; !(1 &lt;&lt; (e - 1) &amp; u.keys))) continue; int vkeys = 0; for (int i = 1; i &lt;= cnt[vx][vy]; ++i) vkeys |= (1 &lt;&lt; (key[vx][vy][i] - 1)); int nxtkeys = u.keys | vkeys; if (vis[vx][vy][nxtkeys]) continue; q.push(Node(vx, vy, nxtkeys, u.times + 1)); vis[vx][vy][nxtkeys] = true; } } return -1;}int main() { n = read(); m = read(); p = read(); k = read(); for (int i = 1; i &lt;= k; ++i) { int x1 = read(), y1 = read(), x2 = read(), y2 = read(); int g = read(); edge[x1][y1][x2][y2] = ((g == 0) ? -1 : g); edge[x2][y2][x1][y1] = edge[x1][y1][x2][y2]; } int s = read(); for (int i = 1; i &lt;= s; ++i) { int x1 = read(), y1 = read(), q = read(); key[x1][y1][++cnt[x1][y1]] = q; } int ans = bfs(); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/p/5c532c45.html"},{"title":"「网络流24题」汽车加油行驶问题-题解","text":"题目传送门: 「Luogu P4009」汽车加油行驶问题 题目大意给出一个$N\\times N$的网格,表示有加油站的位置汽车要从$(1, 1)$走到$(N, N)$,装满油可以行驶$K$条边,且只能沿边行驶服从以下规则 可以无费用向右或向下走,但耗1点油 向左走或者向上走时需要付费用$B$,并耗1点油 在加油站处,若油没满,则必须付费用$A$,加满油 可在没有加油站的位置开设加油站,费用$C$,并加满油,付费$A$ 在起点处,油量为$K$ 求出最小费用 题解明显是最小费用最大流(其实分层图最短路也可以解决,因为每条边的容量都为1)分层建图,每层表示油量,第$0$层表示满油($K$),第$1$层表示油量为$K-1$,第$2$层表示油量为$K-2$,$…$ 对于每层每个节点,如果不是加油站,则从 该点 向 下一层的右边和下边的节点 接一条 容量为$1$,费用为$0$ 的边(规则1.) 对于每层每个节点,如果不是加油站,则从 该点 向 下一层的左边和上边的节点 接一条 容量为$1$,费用为$B$ 的边(规则2.) 对于每个节点,如果是加油站,则从 第$0$层的该点 按照上两条建边 对于每个节点,如果是加油站,则从 除$0$层外的每层节点 向 第$0$层的该点 接一条 容量为$1$,费用为$A$ 的边(规则3.) 对于每个节点,如果不是加油站,则从 第$K$层的该点 向 第$0$层的该点 接一条 容量为$1$,费用为$A+C$ 的边(规则4.) 从 源点 向 第$0$层的$(1, 1)$节点 接一条 容量为$1$,费用为$0$ 的边 从 每层的$(N, N)$节点 向 汇点 接一条 容量为$1$,费用为$0$ 的边(到终点不考虑油量) 求出最小费用最大流即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 200010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0x3f, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int N, K, A, B, C;int in[110][110];int point(int x, int y, int dep) { return (x - 1) * N + y + dep * N * N;}int main() { N = read(); K = read(); A = read(); B = read(); C = read(); s = 0; n = (K + 1) * N * N; t = n + 1; for (int i = 1; i &lt;= N; ++i) for (int j = 1; j &lt;= N; ++j) { in[i][j] = read(); if (in[i][j]) { for (int k = 1; k &lt;= K; ++k) { add(point(i, j, k), point(i, j, 0), 1, A); } } for (int k = 0; k &lt; K; ++k) { if (in[i][j] &amp;&amp; k) break; if (i + 1 &lt;= N) add(point(i, j, k), point(i + 1, j, k + 1), 1, 0); if (j + 1 &lt;= N) add(point(i, j, k), point(i, j + 1, k + 1), 1, 0); if (i - 1 &gt;= 1) add(point(i, j, k), point(i - 1, j, k + 1), 1, B); if (j - 1 &gt;= 1) add(point(i, j, k), point(i, j - 1, k + 1), 1, B); } if (!in[i][j]) add(point(i, j, K), point(i, j, 0), 1, A + C); } add(s, point(1, 1, 0), 1, 0); for (int k = 0; k &lt;= K; ++k) { add(point(N, N, k), t, 1, 0); } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/fab3e888.html"},{"title":"「网络流24题」最长k可重线段集问题-题解","text":"题目传送门: 「Luogu P3357」最长k可重线段集问题 题目大意给定一个开线段的集合$\\mathbf{I}$,从$\\mathbf{I}$中取出一些开线段,组成集合$\\mathbf{S}$使对于任何一条直线$x=p$,满足$\\mathbf{S}$中与$x=p$相交的线段数不超过$k$,且$\\mathbf{S}$中开线段总长度最大 求最大的长度 题解和「Luogu P3358」最长k可重区间集问题类似仅修改一下区间的输入部分即可 将每条线段映射到x轴上,发现可能不对,因为可能会存在垂直于x轴的线段,像P3358一样建图会省略掉这条线段 所以要将每个点扩大一倍,将左右端点x坐标相同的区间$(x, x)$更改为$(2x, 2x+1)$,使得不存在与x轴垂直的线段如果左右端点x坐标不相同,则将$(x_1, x_2)$更改为$(2x_1+1, 2x_2)$ 大概就是这么个道理: 剩下的做法和P3358一样,P3358题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}struct Interval { int l, r, len;}inter[510];int nums[1020], old[1020];int length(int a, int b, int c, int d) { return (int)sqrt((long long)(a - c) * (a - c) + (long long)(b - d) * (b - d));}int main() { int n_ = read(), k = read(); for (int i = 1; i &lt;= n_; ++i) { int a = read(), b = read(), c = read(), d = read(); inter[i].len = length(a, b, c, d); inter[i].l = a * 2; inter[i].r = c * 2; if (a == c) inter[i].r += 1; else inter[i].l += 1; nums[i * 2 - 1] = inter[i].l; nums[i * 2] = inter[i].r; } for (int i = 1; i &lt;= n_ * 2; ++i) old[i] = nums[i]; sort(old + 1, old + 1 + n_ * 2); int len = unique(old + 1, old + 1 + n_ * 2) - old - 1; for (int i = 1; i &lt;= n_ * 2; ++i) nums[i] = lower_bound(old + 1, old + 1 + len, nums[i]) - old; for (int i = 1; i &lt;= n_; ++i) { inter[i].l = nums[i * 2 - 1]; inter[i].r = nums[i * 2]; } s = 0; n = len + 2; t = n - 1; add(s, 1, k, 0); for (int i = 1; i &lt;= len; ++i) { add(i, i + 1, inf, 0); } for (int i = 1; i &lt;= n_; ++i) { add(inter[i].l, inter[i].r, 1, inter[i].len); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/f48af49a.html"},{"title":"「网络流24题」最长k可重区间集问题-题解","text":"题目传送门: 「Luogu P3358」最长k可重区间集问题 题目大意给定一个开区间的集合$\\mathbf{I}$,从$\\mathbf{I}$中取出一些开区间,组成集合$\\mathbf{S}$使对于任何一个$x$,满足$\\mathbf{S}$中包含$x$的区间数不超过$k$,且$\\mathbf{S}$中开区间总长度最大 求最大的长度 题解如果两个区间没有重叠的话,则可以同时选择,在图上表现为串联如果两个区间有重叠的话,则不能同时选择,在图上表现为并联(服从总流量的约束)先对所有节点进行离散化,注意离散化前统计出区间的长 从 源点 向 节点1 接一条 容量为$k$,费用为$0$ 的边(最大容量为k,对答案无贡献) 从 每个节点$i$ 向 节点$i+1$ 接一条 容量为$inf$,费用为$0$ 的边(可以随意通过,对答案无贡献) 从 最后一个节点 向 汇点 接一条 容量为$inf$,费用为$0$ 的边(总流量有1.控制,对答案无贡献)(可以包含在2.里) 从 每个区间的左端点 向 其右端点 接一条 容量为$1$,费用为区间长 的边(只可用一次,对答案贡献为区间长度) 求出最大费用最大流,最大费用即为最终的结果样例的图如下: 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}struct Interval { int l, r, len;}inter[510];int nums[1020], old[1020];int main() { int n_ = read(), k = read(); for (int i = 1; i &lt;= n_; ++i) { inter[i].l = read(); inter[i].r = read(); inter[i].len = inter[i].r - inter[i].l; nums[i * 2 - 1] = inter[i].l; nums[i * 2] = inter[i].r; } for (int i = 1; i &lt;= n_ * 2; ++i) old[i] = nums[i]; sort(old + 1, old + 1 + n_ * 2); int len = unique(old + 1, old + 1 + n_ * 2) - old - 1; for (int i = 1; i &lt;= n_ * 2; ++i) nums[i] = lower_bound(old + 1, old + 1 + len, nums[i]) - old; for (int i = 1; i &lt;= n_; ++i) { inter[i].l = nums[i * 2 - 1]; inter[i].r = nums[i * 2]; } s = 0; n = len + 2; t = n - 1; add(s, 1, k, 0); for (int i = 1; i &lt;= len; ++i) { add(i, i + 1, inf, 0); } for (int i = 1; i &lt;= n_; ++i) { add(inter[i].l, inter[i].r, 1, inter[i].len); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/949e7ebf.html"},{"title":"「网络流24题」火星探险问题-题解","text":"题目传送门: 「Luogu P3356」火星探险问题 题目大意有$n$辆车,$p\\times q$的网格为0可以通过,1有障碍不能通过,2为岩石可以采集从(1, 1)开始到最右下角,只能向右或向下 求出使到达终点的车最多,而且采集的岩石最多的移动方案 题解将每个位置拆成入点和出点 如果这个位置是$0$或$2$, 则从 入点 向 出点 接一条 容量为$inf$, 费用为$0$ 的边 如果这个位置是$2$, 则从 入点 向 出点 接一条 容量为$1$, 费用为$1$ 的边 如果这个位置$u$的右边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 容量为$inf$, 费用为$0$ 的边 如果这个位置$u$的下边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 容量为$inf$, 费用为$0$ 的边 跑最大费用最大流,最大流数即到达终点最多的车数输出方案使用dfs,在流量网络中搜索输出路径 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 4010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], pre[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; pre[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; pre[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[pre[u]].from) { edges[pre[u]].flow += a[t]; edges[pre[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int p, q;int in[40][40];int point(int x, int y) { return (x - 1) * p + y;}void dfs(int x, int y, int u, int id) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; Edge&amp; ne = edges[G[u][i] ^ 1]; if (e.to == s || e.to == t || e.to == u - n) continue; if (!e.flow) continue; e.flow--; if (e.to &gt; n) { dfs(x, y, e.to, id); return; } int nx, ny, dir; if (e.to == point(x, y) + 1) { nx = x; ny = y + 1; dir = 1; } else { nx = x + 1; ny = y; dir = 0; } printf(&quot;%d %d\\n&quot;, id, dir); dfs(nx, ny, e.to + n, id); return; }}int main() { int c = read(); p = read(); q = read(); n = p * q; s = 0; t = 2 * n + 1; for (int i = 1; i &lt;= q; ++i) { for (int j = 1; j &lt;= p; ++j) { in[i][j] = read(); if (in[i][j] == 0) add(point(i, j), point(i, j) + n, inf, 0); if (in[i][j] == 2) { add(point(i, j), point(i, j) + n, inf, 0); add(point(i, j), point(i, j) + n, 1, 1); } } } if (in[1][1] != 1) add(s, 1, c, 0); for (int i = 1; i &lt;= q; ++i) { for (int j = 1; j &lt;= p; ++j) { if (in[i][j] == 1) continue; if (in[i][j + 1] != 1 &amp;&amp; j + 1 &lt;= p) add(point(i, j) + n, point(i, j + 1), inf, 0); if (in[i + 1][j] != 1 &amp;&amp; i + 1 &lt;= q) add(point(i, j) + n, point(i + 1, j), inf, 0); } } if (in[q][p] != 1) add(point(q, p) + n, t, c, 0); ansflow = MaxCostMaxFlow(anscost); // printf(&quot;%d %d\\n&quot;, ansflow, anscost); for (int i = 1; i &lt;= ansflow; ++i) { dfs(1, 1, 1, i); } return 0;}","link":"/p/e7256d1.html"},{"title":"manim教程系列-颜色 笔记","text":"这篇文章是在写 manim教程系列视频 的 颜色 部分时做的一些笔记,包括 整个视频的结构 和 写代码时了解的一些用法的笔记视频已经发布,地址:BV1vZ4y1x7hT 视频结构大纲 开头 开始,标题,展示所有要将的方法 颜色的表示 所有constants.py中的颜色常量 使用hex表示颜色 使用rgb的ndarray表示颜色 颜色之间的转换 rgb_to_hex hex_to_rgb color_to_rgb rgb_to_color color_to_int_rgb 颜色的运算函数 invert_color color_gradient interpolate_color average_color random_color 设置颜色 Mobject略,一般上色的都为VMobject color分为stroke_color和fill_color 传入color, stroke_color, fill_color set_color, set_stroke, set_fill方法的color和opacity 给子物体上色 set_color set_color_by_gradient set_colors_by_radial_gradient 光泽与渐变色 set_sheen set_color中使用列表达到渐变色 一些码视频时的笔记 isinstance函数检测对象的类型 对一个字符串进行format时,想要用空格补齐左边到一定个数,可以使用str(...).rjust(num) 涉及到TransformText的地方,在Text里面不可以有空格,需要用白色的~来做出伪空格 字符串中查找一个字符的下标可以用.index(&quot; &quot;, beg=..., end=...)方法来查找第一次出现的位置,第二次出现需要传入beg为第一次位置+1 manim的rgb_to_color函数传入的rgb的值为01,不是0255 用for循环遍历字典键值对for key, value in dic.items():,遍历其中一部分for key, value in list(dic.items())[1:3]将键值对转化为列表,并用切片 Arrow的箭头为.tip .keys(),.values()不为列表,需要套在list()里面 set_colors_by_radial_gradient利用中心与center的距离对颜色进行插值,radius外的所有子物体全为outer_color颜色 含有sheen_factor的物体设置渐变色后与sheen_factor无关","link":"/p/2e2c9a7.html"},{"title":"「网络流24题」骑士共存问题-题解","text":"题目传送门: 「Luogu P3355」骑士共存问题 题目大意给出$n\\times n$的棋盘,$m$个障碍(骑士不能放置)求最多可以放多少个骑士,不能互相攻击 题解先对棋盘进行黑白二染色,$x+y$为奇数和偶数为黑和白,求二分图最大独立集 从 源点 向 黑色节点 接一条 容量为1 的边 从 白色节点 向 汇点 接一条 容量为1 的边 从 每个黑色节点 向 其能攻击到的白色节点接一条 容量为$inf$ 的边 求出最小割即最大流,结果为$\\mathtt{n\\times n - m - maxflow}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 40010;const int inf = 0x3f3f3f3f;const int go[8][2] = { {-1, 2}, {1, 2}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {-2, -1}, {-2, 1}};int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int point(int x, int y) { return (x - 1) * n + y;}bool valid[210][210];int main() { n = read(); m = read(); s = 0; t = n * n + 1; for (int i = 1; i &lt;= m; ++i) { int x = read(), y = read(); valid[x][y] = true; } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if ((i + j) &amp; 1) { if (!valid[i][j]) { add(s, point(i, j), 1); } } else { if (!valid[i][j]) { add(point(i, j), t, 1); } } } } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if (!((i + j) &amp; 1)) continue; for (int k = 0; k &lt; 8; ++k) { int nx = i + go[k][0]; int ny = j + go[k][1]; if (1 &lt;= nx &amp;&amp; nx &lt;= n &amp;&amp; 1 &lt;= ny &amp;&amp; ny &lt;= n &amp;&amp; !valid[nx][ny]) { add(point(i, j), point(nx, ny), inf); } } } } int maxflow = dinic(s, t); printf(&quot;%d\\n&quot;, n * n - m - maxflow); return 0;}","link":"/p/11da5c27.html"},{"title":"「网络流24题」圆桌问题-题解","text":"题目传送门: 「Luogu P3254」圆桌问题 题目大意有$m$个单位,$n$个餐桌第$i$个单位的代表人数$r_i$, 第$i$张餐桌能容纳的人数$c_i$同一个单位的代表不能在同一个餐桌 若有一种方案,输出$1$,并输出方案若没有方案,输出$0$ 题解二分图,左点集为单位,右点集为餐桌,求其 最大匹配 对于每个单位,从 这个点 向 所有餐桌 接一条 容量为1 的边(即每个餐桌只能容纳同一个单位的一个人) 从 源点 向 每个单位 接一条 容量为单位人数 的边(即每个单位所有人都要参加) 从 每个餐桌 向 汇点 接一条 容量为餐桌人数 的边 如果最大流和所有单位总人数相等,则有可行方案对于每个单位,输出出边满足$\\mathtt{e.cap == e.flow}$的$\\mathtt{e.to-m}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 450;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int tot;int main() { m = read(); n = read(); s = 0; t = m + n + 1; for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { add(i, j + m, 1); } } for (int i = 1; i &lt;= m; ++i) { int r = read(); tot += r; add(s, i, r); } for (int i = 1; i &lt;= n; ++i) { int c = read(); add(i + m, t, c); } int maxflow = dinic(s, t); if (maxflow == tot) { printf(&quot;1\\n&quot;); for (int u = 1; u &lt;= m; ++u) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to != s &amp;&amp; e.cap == e.flow) { printf(&quot;%d &quot;, e.to - m); } } printf(&quot;\\n&quot;); } } else { printf(&quot;0\\n&quot;); } return 0;}","link":"/p/25e68a12.html"},{"title":"「网络流24题」方格取数问题-题解","text":"题目传送门: 「Luogu P2774」方格取数问题 题目大意$m$行$n$列的方格图,每个方格中有一个正整数从方格中取数,任意两个数所在方格没有公共边求取出的数的最大总和 题解先选择所有方格,然后考虑删去一些方格相邻$-&gt;$奇偶性不同,构成一个二分图,含有两个点集 从 源点 向 点集$A$ 接一条 容量为点权 的边 从 点集$B$ 向 汇点 接一条 容量为点权 的边 从 点集$A$中每个点 向 与其相邻的在点集$B$中的点 接一条 容量为$inf$ 的边(保证不被割) 求出最小割即最大流即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 10010;const int inf = 0x3f3f3f3f;const int go[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};int n, m, s, t, d[maxn], cur[maxn], tot;struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int point(int x, int y) { return (x - 1) * n + y;}int main() { m = read(); n = read(); s = 0; t = n * m + 1; for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { int a = read(); tot += a; if ((i + j) % 2 == 0) { add(s, point(i, j), a); for (int k = 0; k &lt; 4; ++k) { int nx = i + go[k][0]; int ny = j + go[k][1]; if (1 &lt;= nx &amp;&amp; nx &lt;= m &amp;&amp; 1 &lt;= ny &amp;&amp; ny &lt;= n) { add(point(i, j), point(nx, ny), inf); } } } else { add(point(i, j), t, a); } } } int maxflow = dinic(s, t); printf(&quot;%d\\n&quot;, tot - maxflow); return 0;}","link":"/p/40e04941.html"},{"title":"「网络流24题」航空路线问题-题解","text":"题目传送门: 「Luogu P2770」航空路线问题 题目大意给出一个城市,$n$个点,$v$条边,每个城市有一个名字从西向东按序给出名字求从最西出发到达最东并返回最西(除起点外,每个城市只能访问一次)的路径 题解将每个城市拆成入点和出点 源点为点1的入点,汇点为点n的出点 对于 除源点汇点 的每个点, 从 入点 向 出点 建一条 容量为1,费用为1 的边(只能经过一次,且对答案贡献为1) 从 点1的入点 向 点1的出点 建一条 容量为2,费用为1 的边(可以经过2次,且对答案贡献为1) 从 点n的入点 向 点n的出点 建一条 容量为2,费用为1 的边(可以经过2次,且对答案贡献为1) 对于边$&lt;u, v&gt;$, 从 u的出点 向 v的入点 建一条 容量为1,费用为0 的边(可经过1次,对答案无贡献) 求 最大费用最大流, 最大流$maxflow\\leq 2$ 若最大流为$2$, 则会有一条道路, 经过的城市数为最大费用$maxcost-2$(减去重复的源点和汇点的贡献)求路径可以 先一次dfs找到从1到n的所有残量为0的路径(满流$\\mathtt{e.cap == e.flow}$),正序输出 再一次dfs找到另一条满流路径,并用vis确保没有重复城市,倒序输出(不重复输出n) 若最大流为$1$, 则直接从源点到汇点有一条通路, 输出$2$, 路径为$1-&gt;n-&gt;1$ 若最大流为$0$, 则无解$\\texttt{No Solution!}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 210;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}string name[maxn];map&lt;string, int&gt; id;void dfs1(int u) { vis[u] = true; cout &lt;&lt; name[u - n] &lt;&lt; endl; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to &lt;= n &amp;&amp; e.cap == e.flow) { dfs1(e.to + n); break; } }}void dfs2(int u) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to &lt;= n &amp;&amp; e.cap == e.flow &amp;&amp; !vis[e.to + n]) { dfs2(e.to + n); } } cout &lt;&lt; name[u - n] &lt;&lt; endl;}int main() { n = read(); m = read(); s = 1; t = 2 * n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; name[i]; id[name[i]] = i; } for (int i = 1; i &lt;= m; ++i) { string str1, str2; cin &gt;&gt; str1; cin &gt;&gt; str2; int u = id[str1], v = id[str2]; if (u &gt; v) swap(u, v); add(u + n, v, 1, 0); } for (int i = 2; i &lt; n; ++i) { add(i, i + n, 1, 1); } add(s, s + n, 2, 1); add(n, t, 2, 1); int maxflow = MinCostMaxFlow(anscost); if (maxflow == 2) { printf(&quot;%lld\\n&quot;, anscost - 2); } else if (maxflow == 1) { printf(&quot;2\\n&quot;); cout &lt;&lt; name[1] &lt;&lt; &quot;\\n&quot; &lt;&lt; name[n] &lt;&lt; &quot;\\n&quot; &lt;&lt; name[1] &lt;&lt; endl; return 0; } else { printf(&quot;No Solution!\\n&quot;); return 0; } memset(vis, 0, sizeof(vis)); dfs1(1 + n); dfs2(1 + n); return 0;}","link":"/p/6bb5462a.html"},{"title":"「网络流24题」最长不下降子序列问题-题解","text":"题目传送门: 「Luogu P2766」最长不下降子序列问题 题目大意给定正整数序列$x_1, x_2, …, x_n$ 计算其 最长不下降子序列 的长度$S$ 如果每个元素只允许使用一次,计算从给定的序列中最多可取出多少个长度为$S$的不下降子序列 如果允许在取出的序列中多次使用$x_1$和$x_n$,其他元素仍然只允许使用一次,则从给定序列中最多可取出多少个 不同 的长度为$S$的不下降子序列 题解第一问动态规划状态转移方程:$\\mathtt{f[i]=max_{1≤j&lt;i&amp;&amp;x_j≤x_i}\\{f[j]+1\\}}$初值: $\\mathtt{f[0]=0}$结果: $\\mathtt{max_{1\\leq i\\leq n}f[i]}$ 第二问将每个点(索引)拆成两个点应用了分层图的思想, 把图每个顶点$\\mathtt{i}$按照$\\mathtt{f[i]}$的不同分为了若干层这样图中从$s$出发到$t$的任何一条路径都是一个满足条件的最长上升子序列由于序列中每个点要不可重复地取出,需要把每个点拆分成两个点单位网络的最大流就是增广路的条数,所以最大流量就是第二问结果。 从 源点 向 每个$\\mathtt{f[i]==1}$的点i的左点 建一条 容量为1 的边 从 每个点的左点 向 其右点 建一条 容量为1 的边 从 $\\mathtt{f[i]==S}$的点i的右点 向 汇点 建一条 容量为1 的边 对于$j&lt;i$,若$\\mathtt{x_j\\leq x_i &amp;&amp; f[i] == f[j] + 1}$,则从 点j的右点 向 点i的左点 建一条 容量为1 的边 第三问要求$x_1$和$x_n$可以重复使用,只需取消这两个点相关边的流量限制,求网络最大流即可 从 源点 向 点1的左点 建一条 容量为$inf$ 的边 从 点1的左点 向 点1的右点 建一条 容量为$inf$ 的边 若$\\mathtt{f[n]==S}$则从 点n的左点 向 点n的右点 建一条 容量为$inf$ 的边 若$\\mathtt{f[n]==S}$则从 点n的右点 向 汇点 建一条 容量为$inf$ 的边 注意判断当$n==1$时的情况(第三问答案会出现$inf$) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;int s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int n, num[510], dp[510], ans1, ans2, ans3; int main() { n = read(); for (int i = 1; i &lt;= n; ++i) { num[i] = read(); } // Question 1 for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt; i; ++j) { if (num[j] &lt;= num[i] &amp;&amp; dp[j] &gt; dp[i]) dp[i] = dp[j]; } dp[i]++; ans1 = max(ans1, dp[i]); } printf(&quot;%d\\n&quot;, ans1); // Question 2 s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) if (dp[i] == 1) add(s, i, 1); for (int i = 1; i &lt;= n; ++i) add(i, i + n, 1); for (int i = 1; i &lt;= n; ++i) if (dp[i] == ans1) add (i + n, t, 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) if (num[j] &lt;= num[i] &amp;&amp; dp[i] == dp[j] + 1) add(j + n, i, 1); ans2 = dinic(s, t); printf(&quot;%d\\n&quot;, ans2); // Question 3 if (n == 1) { printf(&quot;1\\n&quot;); return 0; } add(s, 1, inf); add(1, 1 + n, inf); if (dp[n] == ans1) { add(n, n + n, inf); add(n + n, t, inf); } ans3 = ans2 + dinic(s, t); printf(&quot;%d\\n&quot;, ans3); return 0;}","link":"/p/a66cf8af.html"},{"title":"「网络流24题」太空飞行计划问题-题解","text":"题目传送门: 「Luogu P2762」太空飞行计划问题 题目大意有$m$个实验，每个实验只可以进行一次，但会获得相应的奖金有$n$个仪器，每个实验都需要一定的仪器，每个仪器可以运用于多个实验，但需要一定的价值 问奖金与代价的差的最大值是多少？ 题解 从源点向每个实验建 容量为实验奖金 的边 从每个仪器向汇点建 容量为仪器费用 的边 实验向对应仪器建 容量为$inf$ 的边(保证不被割) 然后求最小割即最大流,只会割断 源-&gt;实验 或者 仪器-&gt;汇 的点最后一次bfs后,仍和源相连的实验/仪器为要进行的实验/需要的仪器 最大收益为所有支付的费用之和减最大流 样例的建边见下图: 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;bool endr = false;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} if (ch == '\\r') endr = true; return x * f;}const int maxn = 110;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], cur[maxn], tot;struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int main() { int m_ = read(), n_ = read(); n = m_ + n_ + 2; s = 0; t = n - 1; for (int i = 1; i &lt;= m_; ++i) { int p = read(); tot += p; add(s, i, p); char tools[10000]; memset(tools, 0, sizeof(tools)); cin.getline(tools, 10000); int ulen = 0, tool; while (sscanf(tools + ulen, &quot;%d&quot;, &amp;tool) == 1) { add(i, tool + m_, inf); if (tool == 0) ulen++; else { while (tool) { tool /= 10; ulen++; } } ulen++; } } for (int i = 1; i &lt;= n_; ++i) { int c = read(); add(i + m_, t, c); } int ans = dinic(s, t); for (int i = 1; i &lt;= m_; ++i) { if (vis[i]) printf(&quot;%d &quot;, i); } printf(&quot;\\n&quot;); for (int i = 1; i &lt;= n_; ++i) { if (vis[i + m_]) printf(&quot;%d &quot;, i); } printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, tot - ans); return 0;}","link":"/p/f5a4cbbc.html"},{"title":"「网络流24题」软件补丁问题-题解","text":"题目传送门: 「Luogu P2761」软件补丁问题 题目大意$n$个错误,$m$个补丁 第$i$个补丁耗时$t_i$使用该补丁需要软件中包含所有$B1_i$中的错误,并且不包含$B2_i$中的任何一个错误该补丁可以修复错误$F1_i$,但会添加错误$F2_i$ 找出修复所有错误的最短时间 题解错误较少,可以使用状态压缩,用2进制表示错误的修复情况(1表示未修复,0表示已修复)起始状态$\\texttt{111…1}$,结束状态$\\texttt{000…0}$ 每个状态当做图中的节点,即求起始状态到结束状态的最短路 由于补丁较少,不用连边,在最短路需要遍历边时,遍历所有补丁,并判断是否能够联通(即当前状态是否包含该补丁的$B1$,而不包含$B2$)如果能够连接,则下一个状态为当前状态打上当前补丁(即修复$F1$,添加$F2$)边权为当前补丁的耗时使用SPFA跑最短路即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}inline int read_() { char ch = getchar(); while (ch != '+' &amp;&amp; ch != '-' &amp;&amp; ch != '0') ch = getchar(); if (ch == '+') return 1; else if (ch == '-') return 2; return 0;}const int inf = 0x3f3f3f3f;struct DLL { int time; int b1, b2; int f1, f2;}node[110];int n, m, s, t;int dis[1 &lt;&lt; 21];bool vis[1 &lt;&lt; 21];void SPFA(int s) { memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; vis[s] = true; queue&lt;int&gt; q; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for (int i = 1; i &lt;= m; ++i) { if ((u &amp; node[i].b1) == node[i].b1 &amp;&amp; (u &amp; node[i].b2) == 0) { int v = ((u | node[i].f1) | node[i].f2) ^ node[i].f1; if (dis[v] &gt; dis[u] + node[i].time) { dis[v] = dis[u] + node[i].time; if (!vis[v]) { q.push(v); vis[v] = true; } } } } }}int main() { n = read(); m = read(); s = (1 &lt;&lt; n) - 1; t = 0; for (int i = 1; i &lt;= m; ++i) { node[i].time = read(); for (int j = 0; j &lt; n; ++j) { int sta = read_(); if (sta == 1) node[i].b1 |= (1 &lt;&lt; j); if (sta == 2) node[i].b2 |= (1 &lt;&lt; j); } for (int j = 0; j &lt; n; ++j) { int sta = read_(); if (sta == 2) node[i].f1 |= (1 &lt;&lt; j); if (sta == 1) node[i].f2 |= (1 &lt;&lt; j); } } SPFA(s); printf(&quot;%d\\n&quot;, dis[t] == inf ? 0 : dis[t]); return 0;}","link":"/p/2f9adffb.html"},{"title":"「网络流24题」家园&#x2F;星际转移问题-题解","text":"题目传送门: 「Luogu P2754」家园/星际转移问题 题目大意1个地球,$n$个太空站,1个月球,$k$个人$m$艘船,第$i$艘容纳$h_i$个人,停靠$r_i$站,分别为$S_{i,j}$,每次耗时1初始人全在地球,结束人全在月球 求最短时间 题解先根据输入的停靠位置,建立并查集,若地月不连通,则无解,输出$0$ 再根据时间建边,时间每增加1,增加一层,求一次最大流,添加进答案当答案大于$k$时,即可全部到达月球 样例的建图是这样: 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], ans, cur[maxn];int ufs[25];int find(int x) { return (ufs[x] == x) ? x : ufs[x] = find(ufs[x]);}void unionn(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) ufs[fx] = fy;}struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int S[25][25];int main() { n = read(); m = read(); int k = read(); s = 0; t = n + 1; for (int i = 1; i &lt;= n + 1; ++i) ufs[i] = i; for (int i = 1; i &lt;= m; ++i) { S[0][i] = read(); S[i][0] = read(); for (int j = 1; j &lt;= S[i][0]; ++j) { S[i][j] = read(); if (S[i][j] == -1) S[i][j] = n + 1; if (j &gt; 1) unionn(S[i][j], S[i][j - 1]); } } if (find(s) != find(t)) { printf(&quot;0\\n&quot;); return 0; } for (int time = 1; ; ++time) { for (int i = 0; i &lt;= n; ++i) { add(i + (time - 1) * (n + 2), i + time * (n + 2), inf); } add(n + 1 + time * (n + 2), n + 1 + (time - 1) * (n + 2), inf); for (int i = 1; i &lt;= m; ++i) { int tmp = (time - 1) % S[i][0] + 1; add(S[i][tmp] + (time - 1) * (n + 2), S[i][time % S[i][0] + 1] + time * (n + 2), S[0][i]); } ans += dinic(s, t); if (ans &gt;= k) { printf(&quot;%d\\n&quot;, time); return 0; } }}","link":"/p/af442de1.html"},{"title":"「网络流24题」餐巾计划问题-题解","text":"题目传送门: 「Luogu P1251」餐巾计划问题 题目大意在$N$天里,第$i$天需要$r_i$个餐巾 可以购买餐巾,每张$p$元 可以将旧送快洗,$m$天,费用$f$元 可以将旧送慢洗,$n$天,费用$s$元 每天结束,可以送快洗,慢洗,保存 设计最小花费 题解将每天拆成2个点(早晚),新建源点汇点(源点表示获得,汇点表示使用) 每天早上的点,向汇点连 容量为$r_i$,费用为$0$ 的边,表示当日需要使用 源点向每天晚上的点连 容量为$r_i$,费用为$0$ 的边,每天晚上获得多少旧餐巾 源点向每天早上的点连 容量为$inf$,费用为$p$ 的边,表示购买 每天晚上向$+m$天的早上连 容量为$inf$,费用为$f$ 的边,表示快洗 每天晚上向$+n$天的早上连 容量为$inf$,费用为$s$ 的边,表示快洗 每天晚上向第二天晚上连 容量为$inf$,费用为$0$ 的边,表示保留 跑最小费用最大流 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 4010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow, r[maxn];int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { for (int i = 1; i &lt;= n; ++i) d[i] = inf; memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int main() { int N = read(); s = 0; t = 2 * N + 1; n = t + 1; for (int i = 1; i &lt;= N; ++i) { r[i] = read(); add(s, i + N, r[i], 0); add(i, t, r[i], 0); } int pr = read(), t1 = read(), c1 = read(), t2 = read(), c2 = read(); for (int i = 1; i &lt;= N; ++i) { if (i + 1 &lt;= N) add(i + N, i + N + 1, inf, 0); if (i + t1 &lt;= N) add(i + N, i + t1, inf, c1); if (i + t2 &lt;= N) add(i + N, i + t2, inf, c2); add(s, i, inf, pr); } MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/93562de2.html"},{"title":"「CSP-S 2019」题解","text":"~~今年的题真是毒瘤~~,一个蒟蒻要来写题解了 校门外有两棵树,一棵叫括号树一棵叫树上的数,这两棵树要被一匹叫格雷的马划分开为Emiya做饭,这两棵树问:那你猜猜我们的重心在哪啊 $D1T1$ 格雷码沙雕暴力dfs(我的做法)考场上真是脑残了,拿dfs模拟,忘了二分的事了,还传了四个参数注意:一定要用unsigned long long 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctype.h&gt;using namespace std;typedef unsigned long long ull;inline ull read() { ull x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); } while (isdigit(ch)) { x = x * 10 + ch - 48; ch = getchar(); } return x * f;}const int maxn = 64;ull n, k;void dfs(ull n, ull k, ull rev, ull from) { if (n == 1) { if (rev == 0) { if (k == 0) printf(&quot;0&quot;); else printf(&quot;1&quot;); } else { if (k == 0) printf(&quot;1&quot;); else printf(&quot;0&quot;); } return; } if (k &lt;= (1LL &lt;&lt; (n - 1LL)) - 1LL) { if (rev == 0 &amp;&amp; from == 0) { printf(&quot;0&quot;); dfs(n - 1LL, k, 0LL, 0LL); } else if (rev == 0 &amp;&amp; from == 1) { printf(&quot;0&quot;); dfs(n - 1LL, k, 1LL, 0LL); } else if (rev == 1 &amp;&amp; from == 0) { printf(&quot;1&quot;); dfs(n - 1LL, k, 0LL, 0LL); } else { printf(&quot;1&quot;); dfs(n - 1LL, k, 0LL, 0LL); } } else { if (rev == 0 &amp;&amp; from == 0) { printf(&quot;1&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 1LL, 1LL); } else if (rev == 1 &amp;&amp; from == 0) { printf(&quot;0&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 0LL, 1LL); } else if (rev == 0 &amp;&amp; from == 1) { printf(&quot;1&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 0LL, 1LL); } else { printf(&quot;0&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 1LL, 1LL); } }}int main() { n = read(); k = read(); dfs(n, k, 0, 0); printf(&quot;\\n&quot;); return 0;}/* 55ms 812kB */ 二分模拟($lyd$巨佬的做法)考前做过一道类似的题,但可惜我忘了$lyd$巨佬说他这题只做了15分钟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;unsigned long long n,k;unsigned long long two[65];int change=0;int main(){ two[0]=1; for(int i=1;i&lt;=63;i++) { two[i]=two[i-1]*2; } cin&gt;&gt;n&gt;&gt;k; while(n&gt;0) { if(k&gt;=two[n-1]) { if(!change) { printf(&quot;1&quot;); change^=1; } else { printf(&quot;0&quot;); } k-=two[n-1]; } else { if(change) { printf(&quot;1&quot;); change^=1; } else { printf(&quot;0&quot;); } } n--; } return 0;}/* 57ms 928kB */ 位运算正解格雷码的规律就是第$i$位为$k\\ xor\\ \\lfloor\\frac{k}{2}\\rfloor$的第$i$位 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int n;unsigned long long k;int main() { scanf(&quot;%d %llu&quot;, &amp;n, &amp;k); k ^= (k &gt;&gt; 1); while (n--) { printf(&quot;%d&quot;, (k &gt;&gt; n &amp; 1)); } puts(&quot;&quot;); return 0;}/* 54ms 932kB */ $D1T2$ 括号树后面的先咕着,等着补 $D1T3$ 树上的数$D2T1$ $Emiya$家今天的饭$D2T2$ 划分$D2T3$ 树的重心","link":"/p/7d7252b1.html"},{"title":"「CSP-S 2019」自闭游记","text":"这次大概是第二年参加信息竞赛了(虽然去年什么也不会就摸了110分,省四)按照惯例,该写篇游记(流水账)了 $Day\\ \\ -7\\sim -2$本来还是挺有信心的,校内几十次模拟赛考自闭了,想想复赛结束后周一周二就要期中考试(其实是”贴心”的年级组特意为我们OIer调的)更自闭了晚饭回来后,几个沙雕朋友听说我自闭了,围了一圈给我来了一遍奥利给,真的感动回家和父母商量好,签了个申请书脱了一周产,还说让我专心学信息,期中考试先放下 脱产的时光还是很快乐的早上六点多到校就开始整理模板,刷模板题老师到了之后花三个半小时做模拟题下午自习和$zty$巨佬研究问题四天就这么过去了,打了一本子模板带去省城复习 $Day\\ \\ -1$上午十一点和机房$wjh$,$mjc$,$lyd$(lyd AK IOI)出发去车站了还是去年的时间,还是去年的$KFC$,还是去年的垃圾笔记本看的是累积了一年的数千行模板和经验 中午到了去年同样的酒店,晚上去了去年同样的吉大日新楼吃饭回到酒店,$lyd$巨佬给同学讲爆搜技巧,$zyc$学长像去年一样来探望苦逼的$yzOIer$睡前敲了一堆板子:快读,vim配置,ST表,树状数组,Trie树,树的重心,树的直径 $Day\\ \\ 1$还是在去年的等候室 进考场$???$这防窥膜是什么鬼,什么都挡不了的好吧,看着还超难受前排的灯也没有开,没开考眼睛就生疼 $Day1\\ T1$看见题目,emmm怎么做都告诉你了,开个数组reverse模拟呗…emmm不对,数组的话貌似要开$2^64$,不行不行推规律,好像也就那么个意思,dfs模拟!!然后一顿乱搞,dfs传值从2到3到4,写了好几十行dfs跑一边样例,没问题,大样例??好像爆了,改long long…照样爆看一眼时间,艹一个小时了,得了得了,不改了 看完第二题,不行不行,得改完,$2^64$?不是unsigned long long吗又加了常数的转换操作,大概可以了 此时一个半小时过去了… $Day1\\ T2$emmm括号匹配,靠前看过类似的,好像得用栈一顿乱搞,发现审错题了…树上??我应该不会,做链的小数据$35$分得了自己出了几个样例(其实是没发现大样例有链上情况),用了$multiset,stack$乱搞,都过了,就扔下去看第三题了 $Day1\\ T3$题目绕了十分多种,看了好几遍样例才明白题干这咋做啊,正解肯定不会,链和菊花图想了半个多小时没想出来 最后剩二十分钟了,不还是有$n!$的暴力$10$分吗飞速写完代码,编译…vector没有???不应该啊,改了好多遍也过不了,拉倒,随机数吧…随机数概率太小,从$1\\sim n$依次输出.. 其实编译没过是没有加using namespace std; 中午老师请客去了去年同样的饭店,下午去了去年同样的欢乐城放松自暴自弃$day1$估分$135$,完了,明天得考一百多分才稳… 晚上睡前又看了看一天什么没用上的模板 $Day\\ \\ 2$在等候室看了树的重心,树的直径的模板我跟lyd说:昨天没考,今天肯定有 $Day2\\ T1$认真的审了题,想要$AC$画了样例的图,woc二分图,网络流???完了完了,考前没看,扔下一个$32$分$n!$暴力溜了 其实已经花了一个小时了 $Day2\\ T3$第二题没看懂题面,看到第三题题目我就来了$???$这个重心定义和我复习的不一样,大体思想差不多,开写 改了模板,写了上去,发现分割树???以前没做过,只好重新建图,删一条边建一次图辣鸡效率跑完???重心全是$2$,查了半天发现两棵树的节点数没处理…改过来之后前几个点$25$分应该是没问题了 简单推了下链和完美二叉树,没推出来,放弃…考试结束前也没想出来 $Day2\\ T2$照着样例看了十分钟才明白题目啥意思感觉应该是$DP$,但蒟蒻不会$DP$啊算了,瞎写个状态转移方程吧,乱搞…发现不是最优解,然后处理分块还有贪心什么的改了一个小时还是不对,心想算了,爆零了,1=无缘了,又回去推链的重心 考试结束前,准备提交代码,把这题中间几行没用的删了删(删少了几行),再跑一遍,奇迹般的对了测了一下几个样例,$0\\to 64\\ \\ ???$ 估分$100+35+0+32+64+25=256$,有点悬 下午刷洛谷,橙蓝黑紫黑紫…炸了(现在掉色了)晚上从车站回家在大雪里打车半个小时,到家颓废,第二天的期中彻底放弃 $Day\\ \\ 3\\sim 4$期中考试第一天开幕雷击,语文古文没背过,作文主旋律,然后三科一个月没学的文科,还有什么都没复习的英语 回家,老师传了公示代码,去$luogu$民间数据自测$Day1\\ T2\\ \\ 35\\to 0\\ 256\\to 221$ 1=没希望,彻底自闭了,要$AFO$了 $Day\\ \\ 5\\sim 6$中午去机房把东西收拾到小屋里,$zty,lyd$巨佬已经开始准备省选期中成绩陆续出来了,总体来说还可以 中午和$zty$用lemon把全省代码拿民间数据跑了一遍,排名还可以,貌似还有希望 结虽然考的很水,但学$OI$我绝不后悔接下来要努力捡起文化课了 文化课虽说恶心，但只有一年，一年完了就能读大学了，高考就与你无关了。 —$zcysky$ 加油!奥利给!!","link":"/p/1901119c.html"},{"title":"「图论算法」树上并查集 dsu on tree","text":"$dsu\\ on\\ tree$($disjoint\\ set\\ union\\ \\text{on tree}$)算法，也称 __树上并查集__。使用了并查集的按秩合并(启发式合并)的方法，结合 树链剖分 中的 轻重儿子划分 ，对 树上暴力统计 进行了优化。使用这个算法需要满足以下两个条件： 每次只对子树进行查询 过程中没有对树的修改 可以将$O(n^2)$的暴力操作优化到$O(n\\log_2n)$ $pre.\\ $树链剖分 - 轻重链划分在$dsu\\ on\\ tree$算法中，只需要统计出每个节点的轻重儿子，而不需要划分轻重链，所以我们只需要树链剖分中的$\\texttt{dfs1()}$，并且只保留和轻重儿子有关的操作即可 关于 轻重儿子 ： 一个节点的所有子节点中，子树所含节点个数最多的子节点称为 重儿子 除重儿子外，一个节点的其余儿子均为 轻儿子 123456789101112void dfs1(int x, int fa) { siz[x] = 1; // 以x为根的子树大小初始化为1 for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; dfs1(e.to, x); siz[x] += siz[e.to]; // 加上子节点的大小 if (siz[e.to] &gt; siz[son[x]]) { son[x] = e.to; // 更新重儿子 } }} $I.\\ $算法流程对于每一个节点$x$: 遍历所有子节点 递归计算所有轻儿子的子树，并删除其对答案的贡献 递归计算重儿子，保留对答案的贡献 统计所有轻儿子对答案的贡献 更新节点答案 伪代码： 123456789101112void dfs(int x, int fa, int opt) { for (all edge from x) { if (e.to == fa || e.to == son[x]) continue; dfs(e.to, x, 0); // 暴力统计轻儿子的子树的贡献，并删除(opt=0) } if (son[x]) dfs(son[x], x, 1); // 统计重儿子的贡献，不删除 upd(x); // 暴力统计该节点所有轻儿子的贡献 ans[x] = now; // 更新答案 if (!opt) { del(x); // 删除需要删除的贡献 }} 12345678void upd(int x, int fa, int val) { solve(x); // 计算当前答案 for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa || e.to == Son) continue; upd(e.to, x, val); }} 由于暴力统计的只是轻儿子，而每个节点的轻儿子不超过$\\log_2n$个，所以整个算法复杂度保证在了$O(n\\log_2n)$ $II.\\ $模板题$CodeForces\\ 600E\\ \\ Lomsat\\ gelral$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 100010;struct Edge { int from, to; Edge(int u, int v): from(u), to(v) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v) { edges.push_back(Edge(u, v)); int mm = edges.size(); G[u].push_back(mm - 1);}int n, Mx, Son, col[maxn], son[maxn], siz[maxn], cnt[maxn];long long sum = 0, ans[maxn];void dfs1(int x, int fa) { siz[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; dfs1(e.to, x); siz[x] += siz[e.to]; if (siz[e.to] &gt; siz[son[x]]) { son[x] = e.to; } }}void Add(int x, int fa, int val) { cnt[col[x]] += val; if (cnt[col[x]] &gt; Mx) { Mx = cnt[col[x]]; sum = col[x]; } else if (cnt[col[x]] == Mx) { sum += (long long)col[x]; } for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa || e.to == Son) continue; Add(e.to, x, val); }}void dfs2(int x, int fa, int opt) { for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; if (e.to != son[x]) dfs2(e.to, x, 0); } if (son[x]) { dfs2(son[x], x, 1); Son = son[x]; } Add(x, fa, 1); Son = 0; ans[x] = sum; if (!opt) { Add(x, fa, -1); sum = 0, Mx = 0; }}int main() { n = read(); for (int i = 1; i &lt;= n; ++i) { col[i] = read(); } for (int i = 1; i &lt; n; ++i) { int u = read(), v = read(); add(u, v); add(v, u); } dfs1(1, 0); dfs2(1, 0, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%lld &quot;, ans[i]); } return 0;}","link":"/p/da7e0a9d.html"},{"title":"「Luogu P1993」小K的农场-题解 &amp; 差分约束系统","text":"题目传送门: 「Luogu P1993」小K的农场 题目大意给出$m$个约束条件,$n$个农场有三种条件,其中$a,b$表示编号为$a,b$的农场的植物个数 $a-b≥c$ $a-b≤c$ $a=b$求是否存在一种方案,使农场中的植物数满足约束要求 $I.$ 差分约束系统以第$1$种约束为例:$$a-b\\ge c\\Rightarrow b\\le a+(-c)$$与求最短路径中的三角形不等式$dis[e.to]\\le dis[u] + e.val$类似所以我们对于约束条件$a-b\\ge c$,从$a$到$b$建一条边权为$-c$的边同理三种约束条件依次为 $a-b\\ge c$, 从$a$到$b$建$-c$单向边 $a-b\\le c$, 从$b$到$a$建$c$单向边 $a=b$, 从$a$到$b$建权值为$0$的双向边 如果存在一组解${x_1, x_2, \\ldots, x_n}$,则对任意常数$\\Delta$, ${x_1+\\Delta, x_2+\\Delta, \\ldots, x_n+\\Delta}$也是一组解不妨先求一组负数解,于是就有了条件$x_i-x_0\\le 0$即,从$0$向所有节点建一条边权为$0$的单向边 求解时,设$\\mathtt{dis[0]=0}$,然后以$0$为源点求单源最短路如果存在负环,则系统无解不存在负环,则$\\mathtt{dis[i]}$为系统的一组解 $II.$ 负环如果任意一条边被修改大于$n$次(执行$n$次松弛操作),这个图内一定存在至少一个负环我们可以使用一个数组$cnt$来记录每条边执行松弛操作的次数当向队列中添加节点$\\mathtt{e.to}$时,$\\mathtt{cnt[e.to]++}$然后再判断$\\mathtt{cnt[e.to]&gt;n}$,如果返回$\\mathtt{true}$则存在负环 $III.$ $SPFA$的$SLF$优化本题如果直接跑$SPFA$的话,会$TLE\\ 3$个点,即使手动开了$O3$优化,还是会$TLE\\ 1$个点所以我们可以使用$SLF(Small\\ Label\\ First)$优化 $SLF:$当加入一个新节点$v$的时候 如果此时的$\\mathtt{dis[v]}$比队首$\\mathtt{dis[q.front()]}$小的话，就把$v$点加入到队首 否则把他加入到队尾 因为先扩展最小的点可以尽量使程序尽早的结束 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 10010;const int inf = 0x3f3f3f3f;struct Edge { int from, to, val; Edge(int u, int v, int w): from(u), to(v), val(w) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int w) { edges.push_back(Edge(u, v, w)); int mm = edges.size(); G[u].push_back(mm - 1);}int n, m;int dis[maxn], vis[maxn], cnt[maxn];bool SPFA(int s) { deque&lt;int&gt; q; q.push_back(s); dis[s] = 0; vis[s] = true; while (!q.empty()) { int u = q.front(); q.pop_front(); vis[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (dis[e.to] &gt; dis[u] + e.val) { dis[e.to] = dis[u] + e.val; if (!vis[e.to]) { vis[e.to] = true; if (!q.empty() &amp;&amp; dis[e.to] &lt; dis[q.front()]) { q.push_front(e.to); } else { q.push_back(e.to); } cnt[e.to]++; } if (cnt[e.to] &gt; n) { return false; } } } } return true;}int main() { n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) { int opt = read(); if (opt == 1) { int a = read(), b = read(), c = read(); add(a, b, -c); } else if (opt == 2) { int a = read(), b = read(), c = read(); add(b, a, c); } else { int a = read(), b = read(); add(a, b, 0); add(b, a, 0); } } for (int i = 1; i &lt;= n; ++i) { add(0, i, 0); dis[i] = inf; } printf(SPFA(0) ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); return 0;}/* 1.94s 1.61MB */","link":"/p/6dcf876e.html"},{"title":"「数据结构」线段树","text":"线段树($Segment\\ Tree$)是一种基于分治思想的__二叉树__形数据结构，可以用于__区间__上的数据维护，它可以维护以下值 $maxn\\ minn$，区间上最大最小值 $sum$，区间和 $lmax$，每段上最大前缀和 $rmax$，每段上最大后缀和 $……$ 和以下操作 $Add\\ x\\ y\\ k$，把区间$[x,y]$内元素值全加$k$ $Query\\ x\\ y$，查询区间$[x,y]$内的某个值 由于线段树会维护一种数据，其他也很好写，所以本篇以__区间和__为例 区间和在每次$Add$操作中，如果将相关区间的值全部更新，则会把时间复杂度提高到$O(n)$ 所以我们可以采取一种__延迟标记__($lazy-tag$)的技巧，如果被标记，则说明本区间内的值被整体加上某个值了 详细方法见代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct SegmentTree { struct SegmentTreeNode { //树上的节点 int l, r; //节点表示区间的左右端点 long long sum, add; //区间和和add的延迟标记 #define l(x) tree[x].l //方便访问 #define r(x) tree[x].r #define sum(x) tree[x].sum #define add(x) tree[x].add } tree[maxn &lt;&lt; 2]; int a[maxn], n, m; void build(int p, int l, int r) { //建树 l(p) = l, r(p) = r; //设置左右端点 if (l == r) { sum(p) = a[l]; return; } //到达叶子节点 int mid = (l + r) &gt;&gt; 1; build(p * 2, l, mid); //递归构建左右树 build(p * 2 + 1, mid + 1, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); //更新数据，可改为需要维护的多个值的维护方法 } void pushdown(int p) { //下传延迟标记 if (add(p)) { //如果有标记 sum(p * 2) += add(p) * (r(p * 2) - l(p * 2) + 1); //sum传至左儿子 sum(p * 2 + 1) += add(p) * (r(p * 2 + 1) - l(p * 2 + 1) + 1); //右儿子 add(p * 2) += add(p); //延迟标记传至左儿子 add(p * 2 + 1) += add(p); //右儿子 add(p) = 0; //本节点延迟标记清零 } } void update(int p, int l, int r, int d) { //更新区间内值 if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) { //完全覆盖 sum(p) += (long long)d * (r(p) - l(p) + 1); //更新节点信息 add(p) += d; //打上延迟标记 return; } pushdown(p); //下传标记 int mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) update(p * 2, l, r, d); //递归更新左右 if (r &gt; mid) update(p * 2 + 1, l, r, d); sum(p) = sum(p * 2) + sum(p * 2 + 1); //维护数据 } long long query(int p, int l, int r) { //查询操作 if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) return sum(p); //完全覆盖 pushdown(p); //下传标记 int mid = (l(p) + r(p)) &gt;&gt; 1; long long ans = 0; if (l &lt;= mid) ans += query(p * 2, l, r); //加上左右部分值 if (r &gt; mid) ans += query(p * 2 + 1, l, r); return ans; } #undef add //防止后续使用add等出现错误 #undef sum #undef l #undef r}; 为了使代码简洁，还可以宏定义一些名称 1234#define lt p&lt;&lt;1 //左孩子#define rt p&lt;&lt;1|1 //右孩子#define lson lt,l,mid //左子树#define rson rt,mid+1,r //右子树 $Luogu$模板题目Luogu P3372 线段树1 (区间增加，区间查询和) Luogu P3373 线段树2 (区间增加，区间乘数，区间查询和) $SPOJ$的$GSS$系列 SP1043 GSS1 - Can you answer these queries I SP1557 GSS2 - Can you answer these queries II SP1716 GSS3 - Can you answer these queries III SP2713 GSS4 - Can you answer these queries IV SP2916 GSS5 - Can you answer these queries V SP4487 GSS6 - Can you answer these queries VI SP6779 GSS7 - Can you answer these queries VII","link":"/p/d1cf0d36.html"},{"title":"「数据结构」左偏树(可并堆)","text":"左偏树($Leftist\\ Tree$)，是一种 __可以合并的堆状结构__，支持以下操作 $Pop\\ x$，删除节点$x$ $Merge\\ x\\ y$，合并两棵左偏树 对于一个左偏树的节点，需要维护以下值 $dist$，记录这个节点到它子树里面最近的叶子节点的距离 $value$，每个节点包含的值 性质 一个节点的$value$大于(或小于)左右孩子的$value$(堆性质) 一个节点的左孩子的$dist$不小于右孩子的$dist$(左偏性质) 一个节点的距离始终等于右孩子+1 实现$Merge$操作首先我们设两个节点$x,y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了 合并了$x$的右子树和$y$后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护左偏性质，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x=dist_{rson(x)}+1$ $Pop$操作略$…$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct LeftistTree { int n, m; struct LeftistTreeNode { int dis, val, rt; int ls, rs; #define ls(x) tree[x].ls #define rs(x) tree[x].rs #define dis(x) tree[x].dis #define val(x) tree[x].val #define rt(x) tree[x].rt }tree[maxn]; int merge(int x, int y) { if (!x || !y) return x + y; if (val(x) &gt; val(y) || (val(x) == val(y) &amp;&amp; x &gt; y)) { swap(x, y); } rs(x) = merge(rs(x), y); if (dis(ls(x)) &lt; dis(rs(x))) swap(ls(x), rs(x)); rt(ls(x)) = rt(rs(x)) = rt(x) = x; dis(x) = dis(rs(x)) + 1; return x; } int get(int x) { //路径压缩 return rt(x) == x ? x : rt(x) = get(rt(x)); } void pop(int x) { val(x) = -1; rt(ls(x)) = ls(x); rt(rs(x)) = rs(x); rt(x) = merge(ls(x), rs(x)); } void init() { dis(0) = -1; for (int i = 1; i &lt;= n; ++i) { rt(i) = i; val(i) = read(); } } void SolveMerge(int x, int y) { if (val(x) == -1 || val(y) == -1) return; int fx = get(x), fy = get(y); if (fx != fy) { rt(fx) = rt(fy) = merge(fx, fy); } } void SolvePop(int x) { if (val(x) == -1) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;, val(get(x))), pop(get(x)); }}; $Luogu$模板题目Luogu P3377 左偏树(可并堆)","link":"/p/7ab0d731.html"},{"title":"「数据结构」树状数组","text":"树状数组($Binary\\ Indexed\\ Trees$)是一个维护__前缀和__的数据结构，需要支持以下操作 $Add\\ x\\ y$，单点增加，a[x] += y $Query\\ x$，查询前缀和 前置知识$lowbit$运算$lowbit(n)$表示非负整数$n$在二进制表示下__最低位的1及其后边所有的0构成的数值__ 为了实现$lowbit$运算，先把$n$取反，此时第$k$位变为$0$(设第$k$位是$1$，其后均为$0$)，第$0\\sim k-1$位变为$1$，再整体加一，所以第$k$位变为$1$，其后为$0$，其前每位恰好与原数相反，再按位求与($&amp;$)即可得到。由于在补码下，$\\sim n=-1-n$，所以 $$lowbit(n)=n\\ &amp;\\ (\\sim n+1)=n\\ &amp;\\ -n$$ 1int lowbit(int n) { return n &amp; -n; } 算法实现对于一个原序列$a[]$，可以建立一个数组$tree[]$，来保存$a$的区间$[x-lowbit(x)+1, x]$内值的和，即 $$tree[x] = \\sum_{i=x-lowbit(x)+1}^x{a[i]}$$ 同时$tree$数组可以看成一个树形结构，并满足以下性质 每个节点$tree[x]$保存以$x$为根的子树中所有叶节点的和 每个节点$tree[x]$的子节点个数等于$lowbit(x)$的位数 除树根外，每个节点$tree[x]$的父亲节点为$tree[x+lowbit(x)]$ 树的深度为$\\log_2n$ 根据这些性质，就很容易地写出代码 1234567891011121314151617struct BIT { int tree[maxn], n, m; int lowbit(int k) { return k &amp; -k; } void add(int x, int k) { for (; x &lt;= maxn; x += x &amp; -x) tree[x] += y; } int query(int x) { int ans = 0; for (; x; x -= x &amp; -x) ans += tree[x]; return ans; } int init() { for (int i = 1; i &lt;= n; ++i) { add(i, a[i]); } }}; 实际上，树状数组可以嵌套维护，来解决更多问题，例如区间修改 $Luogu$模板题目Luogu P3374 树状数组1 (单点修改，区间查询) Luogu P3368 树状数组2 (区间修改，单点查询) Luogu P3372 线段树1 (区间修改，区间查询)","link":"/p/8c13697e.html"},{"title":"「数据结构」并查集","text":"并查集($union-find\\ \\ set$)是一种可以__动态维护__若干个不重叠的__集合__，并支持__合并与查询__的数据结构，支持以下两种基本操作： $Find$，查询一个元素属于哪个集合(即查找根) $Union$，把两个集合合并成一个集合 基本实现我们可以使用树形结构存储集合，树上每个点表示一个元素，树根可以代表这个集合 使用一个数组ufs[]来保存每个节点的父亲节点 则合并$x,y$所在的集合可以表示为$ufs[root_x]=root_y$ 查找根节点可以一直沿着数组向上查找 路径压缩防止整棵树的链非常长，导致每次查询时间复杂度极高，可以在__每次执行$Find$操作时，把访问的节点指向根节点__，这种方法称为__路径压缩__，$Find$操作的时间复杂度为$O(log_2n)$ $Code\\ Below:$ 1234567891011121314int ufs[maxn];//初始化，每个点独立(自己是自己的根)for (int i = 1; i &lt;= n; ++i) ufs[i] = i;//Find操作int find(int x) { return x == ufs[x] ? x : ufs[x] = find(ufs[x]);}//union操作(注意union是C++关键字)void unionn(int x, int y) { ufs[get(x)] = get(y)} 带权并查集有时，需要维护的每个节点到根节点的边权值，可以增加一个数组d[]来保存权值，对于两个操作也有所更改 再增加一个数组size[]记录每个树根上集合大小 1234567891011121314//Findint find(int x) { if (ufs[x] == x) return x; int fx = find(ufs[x]); d[x] += d[ufs[x]]; return ufs[x] = fx;}//unionvoid union(int x, int y) { int fx = find(x), fy = find(y); ufs[fx] = fy; d[fx] = size[fy]; size[fy] += size[fx];} 可撤销并查集可能需要维护一个并查集并要求可以__撤销__两节点的连接关系 我们可以对每个操作$(u, v)$执行前，把节点$u$换为树根(不难发现，$ufs[]$变化的只有从$u$到原节点的一条链上) 然后对于操作 $Connect\\ u\\ v$，需要把$u$的父亲节点设为$v$ $Delete\\ u\\ v$，可以把$v$的父亲节点设为$0$ $Query\\ u\\ v$，直接暴力搜索$v$所在的链即可 1234567891011121314151617181920212223struct UnionFindSet { int ufs[maxn]; void init() { for (int i = 0; i &lt;= n; ++i) { ufs[i] = i; } } inline void sroot(int u) { //换u为根 for (int i = 0, fa = ufs[u]; u; fa = ufs[u]) { ufs[u] = i; i = u; u = fa; } } void connect(int u, int v) { ufs[u] = v; } void deleteuv(int u, int v) { ufs[v] = 0; } void query(int u, int v) { for (; v != u &amp;&amp; v; v = ufs[v]); puts(v == u ? &quot;Yes&quot; : &quot;No&quot;); }}; $Luogu$模板题目Luogu P3367 并查集 (普通并查集) Luogu P1196 银河英雄传说 (带权并查集) Luogu P2147 洞穴勘探 (可撤销并查集)","link":"/p/9c4b8ceb.html"},{"title":"「Luogu P2723 P1631 P2850」小练习-题解","text":"战神留的还有一道「P3378」堆,但是是模板,就不用多说了吧 $\\mathcal{「P2723」}$ 丑数$92$分$STL$做法思路很简单,每次弹出堆顶,依次乘$S$集合内的数,再压入优先队列($priority\\_queue$)和集合($set$,目的是去重)中,输出最后一个堆顶即可然而第$4$个点卡了十多秒,$92$分 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxk = 110;long long k, n, a[maxk], i, t;priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt; q;set&lt;long long&gt; s;int main() { scanf(&quot;%lld %lld&quot;, &amp;k, &amp;n); for (long long i = 1; i &lt;= k; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); } q.push(1); s.insert(1); while (i++ &lt;= n) { t = q.top(); q.pop(); for (long long j = 1; j &lt;= k; ++j) { long long num = t * a[j]; if (!s.count(num)) { s.insert(num); q.push(num); } } } printf(&quot;%lld\\n&quot;, t); return 0;}/* 92points TLE with O2 */ $100$分循环做法思路由题可知,当前产生的第$i$个丑数$s[i]$,是之前的某个丑数$\\times a[j]$某个丑数$\\times a[j]$需要大于$s[i-1]$,而且要尽可能的小于是我们可以枚举$j$,然后找到最小的一个丑数$minn$使$minn\\times a[j]&gt;s[i-1]$ 但是..三重循环可能还会$TLE$ 很容易发现满足条件的丑数$x\\times a[j]&gt;s[i-1]$,一定满足条件$x\\times a[j]&gt;s[i-2]$于是我们就可以从满足$x\\times a[j]&gt;s[i-2]$的丑数$x$的位置往后枚举,找到满足条件$x\\times a[j]&gt;s[i-1]$的丑数代码里$b[j]$表示$a[j]$至少与第几小丑数相乘才能得到一个比$s[i-1]$大的丑数 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxk = 110;const int maxn = 100010;long long k, n, a[maxk], i, t, s[maxn], b[maxk];int main() { scanf(&quot;%lld %lld&quot;, &amp;k, &amp;n); for (long long i = 1; i &lt;= k; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); } s[0] = 1; for (long long i = 1; i &lt;= n; ++i) { long long minn = (long long)1 &lt;&lt; 61; for (long long j = 1; j &lt;= k; ++j) { while (a[j] * s[b[j]] &lt;= s[i - 1]) { b[j]++; } if (a[j] * s[b[j]] &lt; minn) { minn = a[j] * s[b[j]]; } } s[i] = minn; } printf(&quot;%lld\\n&quot;, s[n]); return 0;}/* 101ms 1584kB */ $\\mathcal{「P1631」}$ 序列合并思路参考Red_w1nE 把$A$和$B$两个序列分别从小到大排序这样,从$A$和$B$中各任取一个数相加得到$n^2$个和,可以把这些和看成形成了$n$个队列: 1234a[1] + b[1] &lt;= a[1] + b[2] &lt;= ... &lt;= a[1] + B[n]a[2] + b[1] &lt;= a[2] + b[2] &lt;= ... &lt;= a[2] + B[n] ... ... ... ...a[n] + b[1] &lt;= a[n] + b[2] &lt;= ... &lt;= a[n] + B[n] 接下来,将这$n$个队列进行合并: 将这$n$个队列中的第一个元素放入优先队列中； 每次取出优先队列中的最小值,若这个最小值来自于第$k$个队列,那么,就将第$k$个队列的下一个元素放入优先队列中。我们可以使用一个结构体来记录队列中一个节点的值val,队列号id,下一个元素nxt 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;struct Node { int val, id, nxt; Node(int v, int i, int n): val(v), id(i), nxt(n) {}};bool operator &lt; (const Node&amp; a, const Node&amp; b) { return a.val &gt; b.val;}int n, a[maxn], b[maxn];priority_queue&lt;Node&gt; q;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 0; i &lt; n; ++i) { q.push(Node( a[i] + b[0], i, 1 )); } for (int i = 0; i &lt; n; ++i) { Node t = q.top(); q.pop(); printf(&quot;%d &quot;, t.val); q.push(Node( a[t.id] + b[t.nxt], t.id, t.nxt + 1 )); } return 0;}/* 402ms 3196kB */ $\\mathcal{「P2850」}$ 虫洞思路判断__负环__的模板题 每条小路连接边权为正的无向边,每个虫洞连接边权为负的无向边存在负环,则可以回到过去使用$SPFA$算法判断负环($Floyd$也可以,但不开O2优化会$TLE$) $SPFA$判断负环:如果任意一条边被修改大于$n$次,这个图内一定存在至少一个负环 代码使用vector建边,邻接表也可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 510;struct Edge { int from, to, val; Edge(int u, int v, int w): from(u), to(v), val(w) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int w) { edges.push_back(Edge(u, v, w)); int mm = edges.size(); G[u].push_back(mm - 1);}int dist[maxn], vis[maxn], cnt[maxn];int n, m, w;bool SPFA(int s) { queue&lt;int&gt; q; q.push(s); dist[s] = 0; vis[s] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (dist[e.to] &gt; dist[u] + e.val) { dist[e.to] = dist[u] + e.val; if (!vis[e.to]) { vis[e.to] = 1; q.push(e.to); cnt[e.to]++; //统计修改次数 } if (cnt[e.to] &gt; n) { //修改大于n次 return true; //存在负环 } } } } return false;}void clear() { edges.clear(); for (int i = 0; i &lt; maxn - 5; ++i) { G[i].clear(); } memset(cnt, 0, sizeof(cnt)); memset(vis, 0, sizeof(vis)); memset(dist, 0x7f, sizeof(dist));}int main() { int T = read(); while (T--) { clear(); n = read(); m = read(); w = read(); for (int i = 0; i &lt; m; ++i) { int u = read(), v = read(), d = read(); add(u, v, d); add(v, u, d); } for (int i = 0; i &lt; w; ++i) { int u = read(), v = read(), d = read(); add(u, v, -d); } if (SPFA(1)) { printf(&quot;YES\\n&quot;); } else { printf(&quot;NO\\n&quot;); } } return 0;}/* 164ms 1024kB */ 如有疑问,可以在下方评论区留言","link":"/p/1faf5003.html"},{"title":"算法笔记-数论","text":"模板地址: GitHub 欧几里得算法(Euclid algorithm)123LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b);} lcm(a, b) = a / gcd(a, b) * b 扩展欧几里得算法(exGCD)目标: 寻找一对整数$(x, y)$,使$ax+by=gcd(a,b)$ 1234void exgcd(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y) { if (!b) { d = a; x = 1; y = 0; } //d为gcd(a, b) else { exgcd(b, a % b, d, y, x); y -= x * (a / b); }} 裴蜀定理$ax+by=c$且$x,y$全为正整数,则当且仅当$gcd(a, b)|c$ 素数相关Eratosthenes筛法1234567891011bool vis[maxn];int prime[maxn];void getprime(int n) { int m = (int)sqrt(n + 0.5), num = 0; memset(vis, 0, sizeof(vis)); vis[0] = vis[1] = 1; for (int i = 2; i &lt;= m; ++i) if (!vis[i]) { prime[++num] = i; for (int j = i * i; j &lt;= n; j += i) vis[j] = 1; }} 欧拉线性筛12345678910111213void getprime(int n) { vis[1] = true; for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { prime[++cnt] = i; } for (int j = 1; j &lt;= cnt; j++) { int v = i * prime[j]; if (v &gt; n) break; vis[v] = true; } }} 素数定理$$\\pi(x) \\sim \\frac{x}{\\ln x}$$ $Miller-Rabin$素数测试原理:费马小定理若$a^{n-1}\\equiv 1\\pmod n$,$a$取值越多,可以近似认为$n$为质数使用二次探测定理改进卡卡迈尔数(合数$n$对于任何正整数$b$,都满足$gcd(b, n)=1\\ \\ b^{n-1}\\equiv 1\\pmod n$)的bug 123456789101112131415161718LL Random(LL n) { return (LL)((double)rand() / RAND_MAX * n + 0.5); }bool Witness(LL a, LL n) { LL m = n - 1; int j = 0; while (!(m &amp; 1)) { j++; m &gt;&gt;= 1; } LL x = pow_mod(a, m, n); if (x == 1 || x == n - 1) return false; while (j--) { x = x * x % n; if (x == n - 1) return false; } return true;}bool Miller_Rabin(LL n) { if (n &lt; 2) return false; if (n == 2) return true; if (!(n &amp; 1)) return false; for (int i = 1; i &lt;= 30; ++i) { LL a = Random(n - 2) + 1; if (Witness(a, n)) return false; } return true;} 模算术$$(a + b)\\bmod n = ((a\\bmod n) + (b\\bmod n))\\bmod n\\\\(a - b)\\bmod n = ((a\\bmod n) - (b\\bmod n) + n)\\bmod n\\\\ab\\mod n = (a\\bmod n)(b\\bmod n)\\bmod n$$ 快速乘 $ab\\bmod n$123456789LL mul_mod(LL a, LL b, LL n){ LL res = 0; while (b &gt; 0) { if (b &amp; 1) res = (res + a) % n; a = (a + a) % n; b &gt;&gt;= 1; } return res;} 快速幂 $a^p\\bmod n$1234567LL pow_mod(LL a, LL p, LL n) { if (p == 0 &amp;&amp; n == 1) return 0; if (p == 0) return 1; LL ans = pow_mod(a, p / 2, n); ans = ans * ans % n; if (p % 2 == 1) ans = ans * a % n; return ans;} 使用位运算: 12345LL pow_mod(LL a, LL p, LL n) { a %= n; LL ans = 1; for (; p; p &gt;&gt;= 1, a *= a, a %= n) if(p &amp; 1) ans = ans * a % n; return ans;} 欧拉$\\varphi$函数$$\\varphi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})…(1-\\frac{1}{p_k})$$$\\varphi(n)$表示不超过$n$且与$n$互质的整数个数 求值123456789int euler_phi(int n) { int m = (int)sqrt(n + 0.5); int ans = n; for (int i = 2; i &lt;= m; ++i) if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } if (n &gt; 1) ans = ans / n * (n - 1); return ans;} 筛欧拉函数表123456789int phi[maxn];void phi_table(int n) { for (int i = 2; i &lt;= n; ++i) phi[i] = 0; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) if (!phi[i]) for (int j = i; j &lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); }} 同余式定理欧拉定理若$gcd(a, n) = 1$,则$a^{\\varphi(n)}\\equiv 1\\pmod n$ 费马小定理若$p$为质数,则$a^{p-1}\\equiv 1\\pmod p$ 威尔逊定理若$p$为质数,则$(p-1)!\\equiv -1\\pmod p$ 乘法逆元$$a\\div b\\bmod n = a\\times b^{-1}\\bmod n$$$b^{-1}$称为$b$在模$n$意义下的逆元 $n$为质数使用费马小定理, $a^{-1} = a^{n - 2}$ $n$不为质数递归求解 12345LL inv(LL a, LL n) { LL d, x, y; exgcd(a, n, d, x, y); return d == 1 ? (x + n) % n : -1;} 筛逆元表1234567int inv_table[maxn];void getinv(int n, int p) { inv_table[1] = 1; for (int i = 2; i &lt;= n; ++i) { inv_table[i] = (LL)(p - p / i) * inv_table[p % i] % p; }} 同余方程$ax\\equiv b\\pmod n$可以化为$ax+ny=b$使用扩展欧拉定理解决 中国剩余定理(China Remainder Theorem)求解$x\\equiv a_i\\pmod {m_i}$满足$m_i$两两互质 12345678910LL crt(int n, int* a, int* m) { LL M = 1, d, y, x = 0; for (int i = 0; i &lt; n; ++i) M *= m[i]; for (int i = 0; i &lt; n; ++i) { LL w = M / m[i]; exgcd(m[i], w, d, d, y); x = (x + y * w * a[i]) % M; } return (x + M) % M;} 扩展中国剩余定理(exCRT)$m_i$不一定两两互质 12345678910111213LL excrt(LL n, LL* a, LL* m) { LL x, y, k, M = m[0], ans = a[0]; for (int i = 1; i &lt; n; ++i) { LL A = M, B = m[i], C = (a[i] - ans % B + B) % B, gcd; exgcd(A, B, gcd, x, y); LL bg = B / gcd; if (C % gcd != 0) return -1; x = mul_mod(x, C / gcd, bg); ans += x * M; M *= bg; ans = (ans % M + M) % M; } return (ans % M + M) % M;} 离散对数(BSGS)求解$a^x\\equiv b\\pmod n$满足$n$为质数 12345678910111213141516int log_mod(int a, int b, int n) { int m, v, e = 1, i; m = (int)sqrt(n + 0.5); v = inv(pow_mod(a, m, n), n); map&lt;int, int&gt; x; x[1] = 0; for (i = 1; i &lt; m; ++i) { e = mul_mod(e, a, n); if (!x.count(e)) x[e] = i; } for (i = 0; i &lt; m; ++i) { if (x.count(b)) return i * m + x[b]; b = mul_mod(b, v, n); } return -1;} 莫比乌斯反演整除分块整除分块可以对后面的莫比乌斯反演提供很大的优化通过枚举可以发现$\\lfloor \\frac{n}{i} \\rfloor$的结果会出现分块现象例如$n=10$时$\\ \\ \\ i\\ \\ \\ \\ 1\\ \\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 9\\ 10\\ 11\\ 12\\ 13\\ …$$\\lfloor \\frac{n}{i} \\rfloor\\ 10\\ 5\\ 3\\ 2\\ 2\\ 1\\ 1\\ 1\\ 1\\ 1\\ \\ \\ 0\\ \\ \\ 0\\ \\ \\ 0\\ \\ \\ …$不难发现,每个块的右端点为$r=\\lfloor \\frac{n}{t}\\rfloor (t=\\lfloor \\frac{n}{i}\\rfloor)$ 莫比乌斯函数$$\\mu(n) =\\begin{cases}1, &amp; n=1 \\\\(-1)^r, &amp; n=p_1p_2p_3…p_r(\\text{$p_i$为互不相同的质数}) \\\\0, &amp; else\\end{cases}$$性质:$$\\sum_{d|n}{\\mu(d)}=[n=1]$$$$\\sum_{d|n}{\\frac{\\mu(d)}{d}}=\\frac{\\varphi(n)}{n}$$线性筛: 123456789101112131415int mu[maxn], vis[maxn];int primes[maxn], cnt;void get_mu(int n) { memset(vis, 0, sizeof(vis)); memset(mu, 0, sizeof(mu)); cnt = 0; mu[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) { primes[cnt++] = i; mu[i] = -1; } for (int j = 0; j &lt; cnt &amp;&amp; primes[j] * i &lt;= n; ++j) { vis[primes[j] * i] = 1; if (i % primes[j] == 0)break; mu[i * primes[j]] = -mu[i]; } }}","link":"/p/da9a11f.html"},{"title":"「Luogu P1516」青蛙的约会-题解","text":"题目传送门: 「Luogu P1516」青蛙的约会 题目大意(规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴)现有两只青蛙$A,B$设青蛙$A$的出发点坐标是$x$，青蛙$B$的出发点坐标是$y$青蛙$A$一次能跳$m$米，青蛙$B$一次能跳$n$米，两只青蛙跳一次所花费的时间相同纬度线总长$l$米求两只青蛙跳了几次以后才会碰面 题解__同余方程__模板题求解$x + km\\equiv y + kn \\pmod l$ $Solve:$$$x+km−(y+kn)=lz,\\ \\ z\\in Z\\\\(x-y)+k(m-n)-lz=0\\\\k(n-m)+lz=(x-y)$$令$a=x-y,b=n-m$上式可化为:$$kb+lz=a$$求这个方程的最小整数解化为求此不定方程最小整数解$$k’b+lz’=gcd(b,l)$$使用扩展欧几里得算法可得一组特解$(k’,b’)$最小解为$k_{min} = k’\\bmod \\frac{l}{gcd(b,l)}$以上解$k_{min}$的方程右边是$gcd(b,l)$而不是$a$所以结果为$$\\boxed{ (k’\\times \\frac{a}{gcd(b,l)})\\bmod \\frac{l}{gcd(b,l)} }$$ 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;void exgcd(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y) { if (!b) { d = a; x = 1; y = 0; } else { exgcd(b, a % b, d, y, x); y -= x * (a / b); }}int main() { LL n, m, x, y, l, gcd, x1, y1; scanf(&quot;%lld %lld %lld %lld %lld&quot;, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l); LL b = n - m, a = x - y; if (b &lt; 0) { b = -b, a = -a; } exgcd(b, l, gcd, x1, y1); if (a % gcd) { printf(&quot;Impossible\\n&quot;); } else { LL ans = ((x1 * (a / gcd)) % (l / gcd) + (l / gcd)) % (l / gcd); printf(&quot;%lld\\n&quot;, ans); } return 0;}/* 26ms 916kB */","link":"/p/1f4bfad8.html"},{"title":"「NOIp2016」题解","text":"$???$就一道紫题$???$,还是$D1T2\\ ???$ $D1T1$ 玩具迷题简单的__模拟__,没的说 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;struct Node{ int towards; string name;} a[100001];int n, m, ai, si;int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i].towards &gt;&gt; a[i].name; } int peo = 0; for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; ai &gt;&gt; si; if (ai == 0 &amp;&amp; a[peo].towards == 0) peo = (peo + n - si) % n; else if (ai == 0 &amp;&amp; a[peo].towards == 1) peo = (peo + si) % n; else if (ai == 1 &amp;&amp; a[peo].towards == 0) peo = (peo + si) % n; else if (ai == 1 &amp;&amp; a[peo].towards == 1) peo = (peo + n - si) % n; } cout &lt;&lt; a[peo].name &lt;&lt; endl; return 0;} /* 430ms 4760kB */","link":"/p/2a6e5fce.html"},{"title":"「NOIp2017」题解","text":"NOIp2017的题比NOIp2018的题好做一点 $D1T1$ 小凯的疑惑题解推柿子(正确性未知)设$a &lt; b$ 答案为$x$所以:$$x \\equiv ma \\pmod b (1 \\leq m \\leq b - 1)$$即$x = ma + nb (1 \\leq m \\leq b - 1)$显然当$ n \\geq 0$时 $x$可以用$a, b$表示出来，不合题意因此当$n = -1$时$x$取得最大值，此时$x = ma - b$显然当$m$取得最大值$b - 1$时$x$最大，此时$x = (b - 1)a - b = ab - a - b$因此$a, b$所表示不出的最大的数是$$\\boxed{ab - a - b}$$ 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;long long a, b;int main() { scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b); printf(&quot;%lld\\n&quot;, a * b - a - b); return 0;}/* 60ms 948kB */ $D1T2$ 时间复杂度毒瘤大模拟没什么好说的,直接上代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;string str1, str2; int cal, O, NumOfLoop, vis[27], var[27], Onow, Kill, AddO[100], Omax, WhereKill, T;int main() { cin &gt;&gt; T; while (T &gt; 0) { T--; cal = 0; O = 0; Omax = 0; WhereKill = 0; NumOfLoop = 0; Onow = 0; Kill = 0; memset(vis, 0, sizeof(vis)); memset(AddO, 0, sizeof(AddO)); do { str1 = str2; cin &gt;&gt; str2; } while(str2[0] != 'O'); for (int i = 0; i &lt; str1.length(); i++) cal = cal * 10 + str1[i] - '0'; for (int i = 4; i &lt; str2.length() - 1; i++) O = O * 10 + str2[i] - '0'; while (cal &gt; 0) { cal--; cin &gt;&gt; str1; if (str1[0] == 'F') { NumOfLoop++; cin &gt;&gt; str1; if (vis[str1[0] - 96]) { NumOfLoop = -1; } else { vis[str1[0] - 96] = 1; var[NumOfLoop] = str1[0] - 96; } cin &gt;&gt; str1 &gt;&gt; str2; if (str1[0] != 'n' &amp;&amp; str2[0] == 'n' &amp;&amp; Kill == 0) { Onow++; AddO[NumOfLoop] = 1; } else if (((str1.length() == str2.length() &amp;&amp; str1 &gt; str2) || (str1.length() &gt; str2.length()) || (str1[0] == 'n' &amp;&amp; str2[0] != 'n')) &amp;&amp; Kill == 0) { Kill = 1; WhereKill = NumOfLoop; } } else { Omax = max(Omax, Onow); vis[var[NumOfLoop]] = 0; if (AddO[NumOfLoop] == 1) { Onow--; AddO[NumOfLoop] = 0; } NumOfLoop--; if (WhereKill &gt; 0 &amp;&amp; NumOfLoop &lt; WhereKill) { Kill = 0; WhereKill = 0; } } if(NumOfLoop == -1) { printf(&quot;ERR\\n&quot;); cal = -1; } } if (NumOfLoop &gt; 0) printf(&quot;ERR\\n&quot;); if (NumOfLoop == 0 &amp;&amp; Omax == O) printf(&quot;Yes\\n&quot;); if (NumOfLoop == 0 &amp;&amp; Omax != O) printf(&quot;No\\n&quot;); } return 0;}/* 34ms 756kB */ $D1T3$ 逛公园本题思路来自安妮007的题解 题解 先SPFA求最短路 再反向SPFA排除无法到达的边 再记忆化搜索走冤枉路的最优方案 详细见安妮007的题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 100010;struct Node { int x, y; Node(int x, int y): x(x), y(y) {}};int n, m, k, p, T;vector&lt;Node&gt; v[maxn], s[maxn];int d[maxn], ans[maxn][60];bool vis[maxn][60], alive[maxn];queue&lt;int&gt; q, f;int dfs(int a, int b) { //a当前点,b允许走的冤枉路长度 if (b &lt; 0) { return 0; } else if (vis[a][b] == 1) { //又回来了 return -inf; //无穷多种(-inf用于判断) } else if (ans[a][b] != -1) { //算过了 return ans[a][b]; } else { vis[a][b] = true; int key = 0; if (a == n) { //到目的地 key++; } for (int i = 0; i &lt; v[a].size(); ++i) { int g = v[a][i].x, y = v[a][i].y; //g本条边终点,y权值 int u = d[g] - d[a]; if (alive[g] == 0) { //不能到终点 continue; } int w = dfs(g, b - (y - u)); if (w == -inf) { return -inf; } else { key = (key + w) % p; } } ans[a][b] = key % p; vis[a][b] = false; //回溯 return key; }}void safe() { //排除无法到终点的点(反向SPFA) f.push(n); alive[n] = 1; //点n自身可以到达 while (!f.empty()) { int h = f.front(); f.pop(); for (int i = 0; i &lt; s[h].size(); ++i) { int g = s[h][i].x; if (alive[g] == 0) { alive[g] = 1; f.push(g); } } } return ;}void spfa() { //SPFA求最短路 q.push(1); d[1] = 0; while (!q.empty()) { int h = q.front(); q.pop(); for (int i = 0; i &lt; v[h].size(); ++i) { int g = v[h][i].x, y = v[h][i].y; if (d[h] + y &lt; d[g]) { d[g] = d[h] + y; q.push(g); } } } return ;}int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;k, &amp;p); for (int i = 1; i &lt;= n; ++i) { v[i].clear(); s[i].clear(); alive[i] = 0; for (int j = 0; j &lt;= k; ++j) { ans[i][j] = -1; vis[i][j] = 0; } } for (int i = 0; i &lt; m; ++i) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); v[a].push_back(Node(b, c)); //正向边 s[b].push_back(Node(a, c)); //反向边 } for (int i = 2; i &lt;= n; ++i) { d[i] = inf; } spfa(); //SPFA求最短路 safe(); int z = dfs(1, k); if (z == -inf) { printf(&quot;-1\\n&quot;); } else { printf(&quot;%d\\n&quot;, z); } } return 0;}/* 6488ms 44632kB with O2 */ $D2T1$ 奶酪题解没什么好说的,直接__搜索__存好每个点,排序,从下向上搜 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;bool fini = false, vis[maxn];int T, n, h, r;struct Node { double x, y, z;} node[maxn];bool cmp(Node a, Node b) { return a.z &gt; b.z;}double dist(Node a, Node b) { return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));}void dfs(Node now, int num) { if (now.z + r &gt;= h) { fini = true; return; } vis[num] = true; for (int i = 1; i &lt;= n; ++i) { if (fini) { return; } else if (!vis[i] &amp;&amp; dist(node[i], now) &lt;= r * 2) { dfs(node[i], i); } }}int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { fini = false; memset(node, 0, sizeof(node)); memset(vis, 0, sizeof(vis)); scanf(&quot;%d %d %d&quot;, &amp;n, &amp;h, &amp;r); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%lf %lf %lf&quot;, &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); } sort(node + 1, node + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) { if (node[i].z - r &lt;= 0) { dfs(node[i], i); } } printf(fini ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); } return 0;}/* 157ms 832kB */ $D2T2$ 宝藏题解状压?? 模拟退火?? 不存在的 蒟蒻不会__搜索+剪枝__能很快AC掉这道紫题不解释了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;int vis[20], dis[20], num[20]; //已访问的点,距1的距离,可以到达的点数int c[20][20], G[20][20]; //费用,图int ans = inf, tmp, tot, cnt, n, m, p;bool cmp(int a, int b) { return c[p][a] &lt; c[p][b];}void dfs(int u, int node) { for (int i = u; i &lt;= cnt; ++i) { if(tot + tmp * dis[vis[i]] &gt;= ans) return; for (int j = node; j &lt;= num[vis[i]]; ++j) { if(!dis[G[vis[i]][j]]) { cnt++; vis[cnt] = G[vis[i]][j]; tmp -= c[vis[cnt]][G[vis[cnt]][1]]; tot += c[vis[i]][vis[cnt]] * dis[vis[i]]; dis[vis[cnt]] = dis[vis[i]] + 1; dfs(i, j + 1); tot -= c[vis[i]][vis[cnt]] * dis[vis[i]]; dis[vis[cnt]] = 0; tmp += c[vis[cnt]][G[vis[cnt]][1]]; cnt--; } } node = 1; } if(cnt == n) { if(tot &lt; ans) ans = tot; return; }}int main() { int u, v, w; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { c[i][j] = inf; } } for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); if(c[u][v] &lt; w) continue; if(c[u][v] == inf) { G[u][++num[u]] = v; G[v][++num[v]] = u; } c[u][v] = c[v][u] = w; } for (int i = 1; i &lt;= n; ++i) { p = i; sort(G[i] + 1, G[i] + 1 + num[i], cmp); tmp += c[i][G[i][1]]; } for (int i = 1; i &lt;= n; ++i) { tot = 0; cnt = 1; vis[1] = i; tmp -= c[i][G[i][1]]; dis[i] = 1; dfs(1, 1); dis[i] = 0; tmp += c[i][G[i][1]]; } printf(&quot;%d&quot;, ans); return 0;}/* 65ms 808kB */ $D2T3$ 列队平衡树?? $Splay$?? $FHQ\\_Treap$?? 不会模拟拿下$50$分,以后再说,逃 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 300010;struct Node { int x, y;} a[maxn];int n, m, q, tot;LL last[maxn], h[maxn], pos[510][50010], ans;int main() { n = read(); m = read(); q = read(); for (int i = 1; i &lt;= q; ++i) { a[i].x = read(); a[i].y = read(); h[i] = a[i].x; } for (int i = 1; i &lt;= n; ++i) { last[i] = last[i - 1] + m; } sort(h + 1, h + q + 1); //排序 tot = unique(h + 1, h + q + 1) - h - 1; //去重 LL t; for (int i = 1; i &lt;= tot; ++i) { //编号 t = (LL)(h[i] - 1) * m; for (int j = 1; j &lt;= m; ++j) { pos[i][j] = ++t; } } int where; //a[i].x在h数组中的位置 for (int i = 1; i &lt;= q; ++i) { //模拟 for (int j = 1; j &lt;= tot; ++j) { if (h[j] == a[i].x) { where = j; break; } } if (a[i].y == m) { //在最后一列 ans = last[h[where]]; } else { ans = pos[where][a[i].y]; } printf(&quot;%lld\\n&quot;, ans); if (a[i].y != m) { //向左看齐 for (int j = a[i].y; j &lt; m - 1; ++j) { pos[where][j] = pos[where][j + 1]; } pos[where][m - 1] = last[h[where]]; } for (int j = h[where]; j &lt; n; ++j) { //向前看齐 last[j] = last[j + 1]; } last[n] = ans; } return 0;}/* 50Points 13662ms 67344kB */ 如有疑问,可以在下方评论区留言","link":"/p/c5ac34f0.html"},{"title":"「网络流24题」魔术球问题-题解","text":"题目传送门: 「Luogu P2765」魔术球问题 题目大意输入柱子数$n$满足如下规则 每次只能在某根柱子的最上面放球。 在同一根柱子中，任何2个相邻球的编号之和为完全平方数。输出在第$n$根柱子上最多能放多少球和放置方案 题解并不打算使用网络流,用贪心即可贪心策略: 如果可以的话尽可能放在已有的柱子上 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a[110];bool can[4010];int n, ans = 1, cnt;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i * i &lt;= 4000; ++i) { can[i * i] = true; } while (true) { for (int i = 1; i &lt;= cnt; ++i) { if (can[ ans + a[ i ][ a[i].size() - 1 ] ]) { a[i].push_back(ans++); i = 0; continue; } } if (cnt &lt; n) { cnt++; a[cnt].push_back(ans++); } else break; } printf(&quot;%d\\n&quot;, ans - 1); for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; a[i].size(); ++j) { printf(&quot;%d &quot;, a[i][j]); } printf(&quot;\\n&quot;); } return 0;}","link":"/p/f2e850c0.html"},{"title":"「网络流24题」最小路径覆盖问题-题解","text":"题目传送门: 「Luogu P2764」最小路径覆盖问题 题目大意题目描述给的很直白,输入点数边数和有向边,输出最少路径数和路径 题解正常建图如果一条路径的终点和另一条路径的起点有连边，那么这两条路径是可以合并的。但是一个终点或起点只能使用一次。比如三条路径$1 \\rightarrow 3, 2 \\rightarrow 3, 3 \\rightarrow 4$，你只能合并两条。那么这道题就转化为了：最大化一个边集，使得边集中每个起点和终点都只使用过一次。即__最大独立边集__。把每个点拆成入点$x$和出点$x’$,从源点到$x’$连一条容量为$1$的边，从$x$到汇点连一条容量为$1$的边。边权用来限制每个起点或终点的使用次数。对于每条边$x \\rightarrow y$，连接$x’ \\rightarrow y$答案是$n-最大流$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int inf = 0x3f3f3f3f;bool vis[maxn], vst[maxn];int n, m, s, t;int d[maxn], cur[maxn], to[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = true; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { to[x] = e.to; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int maxflow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); s = 0; t = 2 * n + 1; for (int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); add(u, v + n, 1); } for (int i = 1; i &lt;= n; ++i) add(s, i, 1); for (int i = 1; i &lt;= n; ++i) add(i + n, t, 1); int ans = maxflow(s, t); for (int i = 1; i &lt;= n; ++i) { if (!vst[i]) { int x = i; vst[x] = true; printf(&quot;%d &quot;, x); while (to[x] &amp;&amp; to[x] != t) { x = to[x] - n; printf(&quot;%d &quot;, x); vst[x] = true; } printf(&quot;\\n&quot;); } } printf(&quot;%d\\n&quot;, n - ans); return 0;}","link":"/p/7973b062.html"},{"title":"「网络流24题」试题库问题-题解","text":"题目传送门: 「Luogu P2763」试题库问题 题目大意假设一个试题库中有$n$道试题,每道试题都标明了所属类别,同一道题可能有多个类别属性,现要从题库中抽取$m$道题组成试卷,并要求试卷包含指定类型的试题,输出出题方案 题解建图: 类型与汇点连容量为题目数的边;题目与源点连容量为$1$的边;题目与所属类型连容量为$1$的边结果: 如果满流则可以实现(沿满流输出即可),没有满流输出No Solution! 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2020;const int inf = 0x3f3f3f3f;bool vis[maxn];int k, n, s, t, sum, d[maxn], cur[maxn];int ans[maxn], ansi;struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;k, &amp;n); s = 0; t = n + k + 1; for (int i = 1; i &lt;= k; ++i) { int type; scanf(&quot;%d&quot;, &amp;type); sum += type; add(n + i, t, type); } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1); int p, type; scanf(&quot;%d&quot;, &amp;p); for (int j = 1; j &lt;= p; ++j) { scanf(&quot;%d&quot;, &amp;type); add(i, type + n, 1); } } int maxflow = MaxFlow(s, t); if (maxflow == sum) { for (int i = n + 1; i &lt;= n + k; ++i) { printf(&quot;%d: &quot;, i - n); for (int j = 0; j &lt; G[i].size(); ++j) { Edge&amp; e = edges[G[i][j]]; if (e.cap == 0 &amp;&amp; e.flow != 0) { printf(&quot;%d &quot;, e.to); } } printf(&quot;\\n&quot;); } } else { printf(&quot;No Solution!\\n&quot;); } return 0;}","link":"/p/5a8ce31f.html"},{"title":"「Luogu P5020 P1621 P4942」小练习-题解","text":"$\\mathcal{「P5020」}$ 货币系统表面上是数论，其实就是个__动态规划__ 首先设$A = (n, a) \\ \\ B = (m, b)$可以证明$B \\subseteq A$$proof:$ 我们设$x\\in A$且$x$不能被$A$集合内除它以外的元素组成。 然后我们假设$x \\notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。 那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。 综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内$Q.E.D$ 然后动态规划dp[i]表示$i$面值最多能被几张钱表示则若其不能被表示dp[i] = -inf能表示且只有它自己则dp[i] = 1初始化dp[] = -inf; dp[0] = 0状态转移方程为dp[j] = max(dp[j], dp[j - a[i]] + 1) 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int n, T, ans, a[1010], dp[30010];int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { memset(dp, -0x3f, sizeof(dp)); memset(a, 0, sizeof(a)); ans = 0; dp[0] = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = a[i]; j &lt;= 25010; ++j) { dp[j] = max(dp[j], dp[j - a[i]] + 1); } } for (int i = 1; i &lt;= n; ++i) { if (dp[a[i]] == 1) { ans++; } } printf(&quot;%d\\n&quot;, ans); } return 0;}/* 862ms 944kB */ $\\mathcal{「P1621」}$ 集合使用__并查集和埃氏筛法__(埃拉托斯特尼筛法)即可具体操作是边筛边合并集合 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int ufs[maxn], a, b, p, ans;bool isprime[maxn];int find(int x) { return ufs[x] == x ? x : ufs[x] = find(ufs[x]);}int main() { scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;p); ans = b - a + 1; //初始个数为区间内数的个数 for (int i = a; i &lt;= b; ++i) { //初始化 ufs[i] = i; } for (int i = 2; i &lt;= b; ++i) { //埃氏筛 if (!isprime[i]) { if (i &gt;= p) { //大于p才合并 for (int j = i * 2; j &lt;= b; j += i) { isprime[j] = true; if (j - i &gt;= a &amp;&amp; find(j) != find(j - i)) { //合并 ufs[find(j)] = find(j - i); --ans; } } } else { //不大于p但要标记 for (int j = i * 2; j &lt;= b; j += i) { isprime[j] = true; } } } } printf(&quot;%d\\n&quot;, ans); return 0;}/* 38ms 1312kB */ $\\mathcal{「P4942」}$ 小凯的数字类似于$NOIp2017\\ D1T1$ 小凯的疑惑,推柿子即可 首先$l(l+1)(l+2)…(r-1)r$可以表示为$l\\times 10^? + (l + 1)\\times 10^? + … + r\\times 10^?$同时我们知道$10$的若干次方除以$9$的余数__恒为__$1$所以$l(l+1)(l+2)…(r-1)r$除以$9$的余数就等于$l + (l + 1) + … + (r - 1) + r$的余数并且$l,l+1,…,r$为等差数列,公差为$1$运用等差数列求和公式即可求解 $a_1 = l\\ d = 1$$n = r - l + 1$$S_n = n\\times a_1 + n\\times (n - 1)\\times \\frac{d}{2}$所以$$\\boxed{Ans = n\\times l + n\\times (n - 1) \\div 2}$$ 另外要边算边取模,除以$2$要变成乘模$9$下的逆元$5$所以公式如下ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9; 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int T;long long l, r, n, ans;int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%lld %lld&quot;, &amp;l, &amp;r); n = (r - l + 1) % 9; ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9; printf(&quot;%lld\\n&quot;, ans); } return 0;}/* 32ms 888kB */ 如有疑问,可以在下方评论区留言","link":"/p/eb0c7a6c.html"},{"title":"「网络流24题」飞行员配对方案问题-题解","text":"题目传送门: 「Luogu P2756」飞行员配对方案数问题 题目大意输入两方飞行员个数$m,n$,再给定两方飞行员可以配合的人编号$i,j$(以$-1,-1$结束)输出最多配对数和配对方案 题解主要在建图皇家空军与源点$s$连容量$1$的边,外籍与汇点$t$连容量$1$的边,可配合的两点间连容量为$1$的边输出最大流即可(要找配对方案) 也可以使用匈牙利算法(本文不给出) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 120;const int inf = 0x3f3f3f3f;int n, m, s, t;int d[maxn], cur[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){};};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool vis[maxn];bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;m, &amp;n); s = 0; t = n + 1; int u, v; while (scanf(&quot;%d %d&quot;, &amp;u, &amp;v) == 2 &amp;&amp; u != -1 &amp;&amp; v != -1) { add(u, v, 1); } for (int i = 1; i &lt;= m; ++i) { add(s, i, 1); } for (int i = m + 1; i &lt;= n; ++i) { add(i, t, 1); } int flow = MaxFlow(s, t); if (flow == 0) { printf(&quot;No Solution!\\n&quot;); return 0; } printf(&quot;%d\\n&quot;, flow); for (int i = 0; i &lt; edges.size(); i = i + 2) { if (edges[i].from != s &amp;&amp; edges[i].to != t) { if (edges[i].flow != 0) { printf(&quot;%d %d\\n&quot;, edges[i].from, edges[i].to); } } } return 0;}","link":"/p/154ff24f.html"},{"title":"Cpp算法-网络流相关","text":"网络流算法相关模板,讲解__以后再说吧__,咕咕咕 注:本文使用vector建图 网络最大流Edmonds-Karp算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int n, m, s, t, ans;struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];int a[maxn], p[maxn];void add(int from, int to, int cap) { edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}void EdmondsKarp() { ans = 0; for (;;) { memset(a, 0, sizeof(a)); queue&lt;int&gt; Q; Q.push(s); a[s] = 0x3f3f3f3f; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!a[e.to] &amp;&amp; e.cap &gt; e.flow) { p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); Q.push(e.to); } } if (a[t]) break; } if (!a[t]) break; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } ans += a[t]; } return;} Dinic算法(常用)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int maxn = 10010;int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, 0x3f3f3f3f); } return flow;} ISAP算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const int maxn = 10010;const int inf = 0x3f3f3f3f;int n, m, s, t;int d[maxn], p[maxn], num[maxn], cur[maxn];bool vis[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}void bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(t); d[t] = 0; vis[t] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) { vis[e.from] = 1; d[e.from] = d[x] + 1; Q.push(e.from); } } }}int Augment() { int x = t, a = inf; while (x != s) { Edge&amp; e = edges[p[x]]; a = min(a, e.cap - e.flow); x = edges[p[x]].from; } x = t; while (x != s) { edges[p[x]].flow += a; edges[p[x] ^ 1].flow -= a; x = edges[p[x]].from; } return a;}int ISAP(int s, int t) { int flow = 0; bfs(); memset(num, 0, sizeof(num)); for (int i = 0; i &lt; n; ++i) num[d[i]]++; int x = s; memset(cur, 0, sizeof(cur)); while (d[s] &lt; n) { if (x == t) { flow += Augment(); x = s; } int ok = 0; for (int i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + 1) { ok = 1; p[e.to] = G[x][i]; cur[x] = i; x = e.to; break; } } if (!ok) { int mm = n - 1; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow) mm = min(mm, d[e.to]); } if (--num[d[x]] == 0) break; num[d[x] = mm + 1]++; cur[x] = 0; if (x != s) x = edges[p[x]].from; } } return flow;} 最小费用最大流Bellman-Ford算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int maxn = 10010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { for (int i = 1; i &lt;= n; ++i) d[i] = inf; memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}","link":"/p/c3cdab79.html"},{"title":"算法笔记-计算几何","text":"啥也不说了,直接上代码,每个函数功能已经以注释方式给出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453/************************************************************* * &gt; Description : 计算几何模板 * &gt; Copyright (C) 2019 Tony**************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-10; //精度const double PI = acos(-1);/** * @brief 点(向量) * @param x 横坐标 * @param y 纵坐标 */struct Point { double x, y; Point(double x = 0, double y = 0): x(x), y(y) {}};typedef Point Vector;Vector operator + (Vector a, Vector b) { return Vector(a.x + b.x, a.y + b.y); }Vector operator - (Vector a, Vector b) { return Vector(a.x - b.x, a.y - b.y); }Vector operator * (Vector a, double p) { return Vector(a.x * p, a.y * p); }Vector operator / (Vector a, double p) { return Vector(a.x / p, a.y / p); }/** * @brief 带精度比较(三态函数) * @param[in] x 输入 * @return 大小关系：等于0(0), 小于零(-1), 大于零(1) */int dcmp(double x) { if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;}bool operator &lt; (const Point&amp; a, const Point&amp; b) { return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);}bool operator == (const Point&amp; a, const Point&amp; b) { return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;}double Dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }double Length(Vector a) { return sqrt(Dot(a, a)); }double Angle(Vector a, Vector b) { return acos(Dot(a, b) / Length(a) / Length(b)); }double Cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }double Area2(Point a, Point b, Point c) { return Cross(b - a, c - a); }double Dist2(const Point&amp; A, const Point&amp; B) { return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y); }double angle(Vector v) { return atan2(v.y, v.x); }/** * @brief 向量旋转 * @param[in] a 向量 * @param[in] rad 旋转角度(逆时针) * @return 旋转后的向量 */Vector Rotate(Vector a, double rad) { return Vector(a.x * cos(rad) - a.y * sin(rad), a.x * sin(rad) + a.y * cos(rad));}/** * @brief 求单位向量 * @param[in] a 向量 * @return 沿向量a的单位向量 */Vector Normal(Vector a) { double L = Length(a); return Vector(-a.y / L, a.x / L);}/** * @brief 两条直线交点 * @param[in] p 第一条直线的起始点 * @param[in] v 第一条直线的方向向量 * @param[in] q 第二条直线的起始点 * @param[in] w 第二条直线的方向向量 * @return 两条直线交点 */Point GetLineIntersection(Point p, Vector v, Point q, Vector w) { Vector u = p - q; double t = Cross(w, u) / Cross(v, w); return p + v * t;}/** * @brief 点到直线距离 * @param[in] p 点 * @param[in] a,b 直线上两点 * @return 点到直线距离 */double DistanceToLine(Point p, Point a, Point b) { Vector v1 = b - a, v2 = p - a; return fabs(Cross(v1, v2)) / Length(v1);}/** * @brief 点到线段距离 * @param[in] p 点 * @param[in] a,b 线段两端点 * @return 点到线段距离 */double DistanceToSegment(Point p, Point a, Point b) { if (a == b) return Length(p - a); Vector v1 = b - a, v2 = p - a, v3 = p - b; if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);}/** * @brief 点在直线上投影点 * @param[in] p 点 * @param[in] a,b 直线上两点 * @return 点在直线上投影点 */Point GetLineProjection(Point p, Point a, Point b) { Vector v = b - a; return a + v * (Dot(v, p - a) / Dot(v, v));}/** * @brief 线段相交判定(不含端点) * @param[in] a1,a2 第一条线段端点 * @param[in] b1,b2 第二条线段端点 * @return 是否相交(bool) */bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;}/** * @brief 点在线段上判定(不包括端点) * @param[in] p 点 * @param[in] a1,a2 线段两端点 * @return 是否在线段上(bool) */bool OnSegment(Point p, Point a1, Point a2) { return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;}/** * @brief 多边形面积 * @param[in] *p 顶点数组 * @param[in] * @return */double PolygonArea(Point* p, int n) { double area = 0; for (int i = 1; i &lt; n - 1; ++i) { area += Cross(p[i] - p[0], p[i + 1] - p[0]); } return area / 2;}/** * @brief 直线(参数式) * @param p 直线上的一点 * @param v 方向向量 * @param ang 方向向量极角 * @function point(double t) * @brief 直线上的点 * @param[in] t 横坐标 * @return 直线上的点 * @function move(double d) * @brief 沿直线移动 * @param[in] d 平移距离 * @return 平移后的直线 */struct Line { Point p; Vector v; double ang; Line() {} Line(Point p, Vector v): p(p), v(v) { ang = atan2(v.y, v.x); } bool operator &lt; (const Line&amp; L) const { return ang &lt; L.ang; } Point point(double t) { return p + v * t; } Line move(double d) { return Line(p + Normal(v) * d, v); }};/** * @brief 是否在直线左侧 * @param[in] L 直线 * @param[in] p 点 * @return 是否在点左侧(bool) */bool OnLeft(Line L, Point p) { return Cross(L.v, p - L.p) &gt; 0;}/** * @brief 两条直线交点(重载) * @param[in] a 第一条直线 * @param[in] b 第二条直线 * @return 两条直线交点 */Point GetLineIntersection(Line a, Line b) { Vector u = a.p - b.p; double t = Cross(b.v, u) / Cross(a.v, b.v); return a.p + a.v * t;}/** * @brief 圆 * @param c 圆心 * @param r 半径 * @function point(double a) * @brief 圆上的点 * @param[in] a 横坐标 * @return 圆上的点 */struct Circle { Point c; double r; Circle(Point c, double r): c(c), r(r) {} Point point(double a) { return Point(c.x + cos(a) * r, c.y + sin(a) * r); }};/** * @brief 直线和圆交点 * @param[in] L 直线 * @param[in] C 圆 * @param[out] t1,t2 交点横坐标 * @param[out] sol 交点集(vector) * @return 交点个数 */int GetLineCircleIntersection(Line L, Circle C, double&amp; t1, double&amp; t2, vector&lt;Point&gt;&amp; sol) { double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y; double e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r; double delta = f * f - 4 * e * g; if (dcmp(delta) &lt; 0 ) return 0; if (dcmp(delta) == 0) { t1 = t2 = -f / (2 * e); sol.push_back(L.point(t1)); return 1; } t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(L.point(t1)); t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(L.point(t2)); return 2;}/** * @brief 圆和圆交点 * @param[in] C1,C2 两圆 * @param[out] sol 交点集(vector) * @return 交点个数 */int GetCircleCircleIntersection(Circle C1, Circle C2, vector&lt;Point&gt;&amp; sol) { double d = Length(C1.c - C2.c); if (dcmp(d) == 0) { if (dcmp(C1.r - C2.r) == 0) return -1; return 0; } if (dcmp(C1.r + C2.r - d) &lt; 0) return 0; if (dcmp(fabs(C1.r - C2.r) - d) &gt; 0) return 0; double a = angle(C2.c - C1.c); double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d)); Point p1 = C1.point(a - da), p2 = C1.point(a + da); sol.push_back(p1); if (p1 == p2) return 1; sol.push_back(p2); return 2;}/** * @brief 求切线 * @param[in] p 点 * @param[in] C 圆 * @param[out] *v 切线 * @return 切线条数 */int getTangents(Point p, Circle C, Vector* v) { Vector u = C.c - p; double dist = Length(u); if (dist &lt; C.r) return 0; else if (dcmp(dist - C.r) == 0) { v[0] = Rotate(u, PI / 2); return 1; } else { double ang = asin(C.r / dist); v[0] = Rotate(u, -ang); v[1] = Rotate(u, +ang); return 2; }}/** * @brief 两圆公切线 * @param[in] A,B 两圆 * @param[out] *a,*b 切点 * @return 公切线条数 */int getTangents(Circle A, Circle B, Point* a, Point* b) { int cnt = 0; if (A.r - B.r) { swap(A, B); swap(a, b); } int d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y); int rdiff = A.r - B.r; int rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return 0; double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return -1; if (d2 == rdiff * rdiff) { a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++; return 1; } double ang = acos((A.r - B.r) / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); cnt++; if (d2 == rsum * rsum) { a[cnt] = A.point(base); b[cnt] = B.point(PI + base); cnt++; } else if (d2 &gt; rsum * rsum) { double ang = acos((A.r + B.r) / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt++; } return cnt;}typedef vector&lt;Point&gt; Polygon;/** * @brief 判定点在多边形内 * @param[in] p 点 * @param[in] poly 多边形 * @return 是否在多边形内(在1,不在0,在边上-1) */int isPointInPolygon(Point p, Polygon poly) { int wn = 0; int n = poly.size(); for (int i = 0; i &lt; n; ++i) { if (OnSegment(p, poly[i], poly[(i + 1) % n])) return -1; int k = dcmp(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); int d1 = dcmp(poly[i].y - p.y); int d2 = dcmp(poly[(i + 1) % n].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; } if (wn != 0) return 1; return 0;}/** * @brief 凸包 * @param[in] p 点集 * @return 凸包多边形 */Polygon ConvexHull(vector&lt;Point&gt; p) { sort(p.begin(), p.end()); p.erase(unique(p.begin(), p.end()), p.end()); int n = p.size(); int m = 0; Polygon ch(n + 1); for (int i = 0; i &lt; n; ++i) { while (m &gt; 1 &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) m--; ch[m++] = p[i]; } int k = m; for (int i = n - 2; i &gt;= 0; --i) { while (m &gt; k &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) m--; ch[m++] = p[i]; } if (n &gt; 1) m--; ch.resize(m); return ch;}/** * @brief 旋转卡壳 * @param[in] points 点集 * @return 直径 */int diameter2(vector&lt;Point&gt;&amp; points) { //旋转卡壳 vector&lt;Point&gt; p = ConvexHull(points); int n = p.size(); if (n == 1) return 0; if (n == 2) return Dist2(p[0], p[1]); p.push_back(p[0]); int ans = 0; for (int u = 0, v = 1; u &lt; n; ++u) { for(;;) { int diff = Cross(p[u + 1] - p[u], p[v + 1] - p[v]); if (diff &lt;= 0) { ans = max(ans, (int)Dist2(p[u], p[v])); if (diff == 0) ans = max(ans, (int)Dist2(p[u], p[v + 1])); break; } v = (v + 1) % n; } } return ans;}/** * @brief 切多边形 * @param[in] poly 多边形 * @param[in] A,B 直线上两点 * @return 新多边形 */Polygon CutPolygon(Polygon poly, Point A, Point B) { Polygon newpoly; int n = poly.size(); for (int i = 0; i &lt; n; ++i) { Point C = poly[i]; Point D = poly[(i + 1) % n]; if (dcmp(Cross(B - A, C - A)) &gt;= 0) newpoly.push_back(C); if (dcmp(Cross(B - A, C - D)) != 0) { Point ip = GetLineIntersection(A, B - A, C, D - C); if (OnSegment(ip, C, D)) newpoly.push_back(ip); } } return newpoly;}/** * @brief 半平面交 * @param[in] L 直线集 * @return 多边形 */vector&lt;Point&gt; HalfplaneIntersection(vector&lt;Line&gt; L) { int n = L.size(); sort(L.begin(), L.end()); int first, last; vector&lt;Point&gt; p(n); vector&lt;Line&gt; q(n); vector&lt;Point&gt; ans; q[first = last = 0] = L[0]; for (int i = 1; i &lt; n; i++) { while (first &lt; last &amp;&amp; !OnLeft(L[i], p[last - 1])) last--; while (first &lt; last &amp;&amp; !OnLeft(L[i], p[first])) first++; q[++last] = L[i]; if (fabs(Cross(q[last].v, q[last - 1].v)) &lt; eps) { last--; if (OnLeft(q[last], L[i].p)) q[last] = L[i]; } if (first &lt; last) p[last - 1] = GetLineIntersection(q[last - 1], q[last]); } while (first &lt; last &amp;&amp; !OnLeft(q[first], p[last - 1])) last--; if (last - first &lt;= 1) return ans; p[last] = GetLineIntersection(q[last], q[first]); for (int i = first; i &lt;= last; i++) ans.push_back(p[i]); return ans;}","link":"/p/1aba30fe.html"},{"title":"「NOIp2018」题解","text":"emmm，今天开始从2018向前做NOIp的真题，并写一些题解，太蒻了Orz $D1T1$ 铺设道路嗯～13年原题，__贪心AC__ 题解对区间进行“填坑”贪心策略： 1if (d[i] &gt; d[i - 1]) ans += d[i] - d[i - 1]; $proof:$ 假设现在有一个坑，旁边还有一个坑。 那肯定会同时填上两个坑，所以__小的坑会被大的坑带着填上__，及__小坑免费，大坑减少a[i] - a[i - 1]__$Q.E.D$结果还要加上a[1] 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int n, d[maxn];long long ans;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;d[i]); } for (int i = 2; i &lt;= n; ++i) { if (d[i] &gt; d[i - 1]) { ans += d[i] - d[i - 1]; } } printf(&quot;%lld&quot;, ans + d[1]); return 0;}/* 41ms 1220kB */ $D1T2$ 货币系统表面上是数论，其实就是个__动态规划__ 题解首先设$A = (n, a) \\ \\ B = (m, b)$可以证明$B \\subseteq A$$proof:$ 我们设$x\\in A$且$x$不能被$A$集合内除它以外的元素组成。 然后我们假设$x \\notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。 那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。 综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内$Q.E.D$ 然后动态规划dp[i]表示$i$面值最多能被几张钱表示则若其不能被表示dp[i] = -inf能表示且只有它自己则dp[i] = 1初始化dp[] = -inf; dp[0] = 0状态转移方程为dp[j] = max(dp[j], dp[j - a[i]] + 1) 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int n, T, ans, a[1010], dp[30010];int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { memset(dp, -0x3f, sizeof(dp)); memset(a, 0, sizeof(a)); ans = 0; dp[0] = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = a[i]; j &lt;= 25010; ++j) { dp[j] = max(dp[j], dp[j - a[i]] + 1); } } for (int i = 1; i &lt;= n; ++i) { if (dp[a[i]] == 1) { ans++; } } printf(&quot;%d\\n&quot;, ans); } return 0;}/* 862ms 944kB */ $D1T3$ 赛道修建这题比较复杂，先得部分分 $I.$ $m = 1$ 时最简单的情况求一条最长链，即求树的直径（记录一下最大值和次大值，每次把最大值传到它的父亲）可以通过第$1,4,5,6$个点，$20$分 代码12345678910111213141516171819namespace Meq1 { int dfs(int now, int fa) { int res1 = 0, res2 = 0; for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; res2 = max(res2, dfs(to, now) + edges[i].val); if (res2 &gt; res1) swap(res1, res2); } ans = max(ans, res1 + res2); return res1; } void solve() { dfs(1, 0); printf(&quot;%d\\n&quot;, ans); return ; }} $II.$ $a_i = 1$ 时即一个菊花图把所有边权记录下来，从大到小排序。设边权为$w$，答案即为$w_1+w_{2m-1},w_2+w_{2m-2},…,w_m+w_{m+1}$的最小值可以通过$1,5,7,8$四个点，$20$分，加上$m = 1$的情况共$35$分 代码123456789101112131415161718192021namespace Aeq1 { int arr[maxn]; bool cmp(int a, int b) { return a &gt; b; } void solve() { for (int i = head[1]; i; i = edges[i].nxt) { int to = edges[i].to; arr[to - 1] = edges[i].val; } sort(arr + 1, arr + n, cmp); ans = inf; for (int i = 1; i &lt;= m; ++i) { ans = min(ans, arr[i] + arr[2 * m - i + 1]); } printf(&quot;%d\\n&quot;, ans); return ; }} $III.$ $b_i = a_i + 1$ 时为一条链把所有边权记录下来，这种情况等价于将序列分割成$m$段，使$m$段区间和的最小值最大那么二分$m$段区间和的最小值，然后贪心扫一遍可以通过$2,9,10,11$四个点，$20$分，加上一共$55$分 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace BeqApl1 { int arr[maxn], ans; int Dfs(int now, int fa) { int res1 = 0, res2 = 0; for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; res2 = max(res2, Dfs(to, now) + edges[i].val); if (res2 &gt; res1) swap(res1, res2); } ans = max(ans, res1 + res2); return res1; } void dfs(int now, int fa) { for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; dfs(to, now); arr[now] = edges[i].val; } } bool judge(int x) { int t = 0, now = 0; for (int i = 1; i &lt; n; ++i) { if (now + arr[i] &gt;= x) { now = 0; t++; } else { now += arr[i]; } } return t &gt;= m; } void solve() { dfs(1, 0); Dfs(1, 0); int l = 1, r = ans, mid; while (l &lt; r) { mid = l + r + 1 &gt;&gt; 1; if (judge(mid)) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot;, l); return ; }} 正解最小值最大，显然是二分这个最小值$lim$对于一个节点$u$，我们可以记录一个连接到$u$的赛道的长度$val_i$，那么可以分成两种情况进行讨论：$$\\begin{cases} val_i+dis \\geq lim \\text{直接给答案+1} \\\\ val_i+dis&lt; lim \\text{利用优先队列维护}\\end{cases}$$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;void read(int&amp; x) { x = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - 48; ch = getchar();}}const int maxn = 50050;const int inf = 0x3f3f3f3f;int n, m, cnt, num, s[maxn], mid;struct Edge { int from, to, val; Edge(int u, int v, int w) : from(u), to(v), val(w) {}};vector&lt;Edge&gt; G[maxn];void add(int u, int v, int w) { G[u].push_back(Edge(u, v, w)); G[v].push_back(Edge(v, u, w));}int dfs(int u, int fa) { priority_queue&lt;int&gt; lh; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; sh; int ln = 0, sn = 1; for (int i = 0; i &lt; G[u].size(); ++i) { if (G[u][i].to != fa) { int d = G[u][i].val + dfs(G[u][i].to, u); sh.push(d); lh.push(d); ln++; } } while (ln &gt; 0 &amp;&amp; lh.top() &gt;= mid) {num++; lh.pop(); ln--;} int now = 0; while (ln &gt; sn) { if (u != 1 &amp;&amp; lh.top() + sh.top() &gt;= mid) { int cnt = 0; while (ln &gt; sn &amp;&amp; lh.top() + sh.top() &gt;= mid) {s[++cnt] = lh.top(); lh.pop(); ln--;} num++; sh.pop(); sn++; while (cnt &gt; 1) {lh.push(s[--cnt]); ln++;} } else if (u == 1 &amp;&amp; lh.top() + sh.top() &gt;= mid) { lh.pop(); sh.pop(); ln--; sn++; num++; } else { now = sh.top(); sh.pop(); sn++; } if (num &gt;= m) break; } if (ln &gt;= sn &amp;&amp; !lh.empty()) return lh.top(); else return now;}bool check() { num = 0; dfs(1, 0); if (num &gt;= m) return true; else return false;}int main() { read(n); read(m); int all = 0; for (int i = 1; i &lt; n; ++i) { int u, v, w; read(u); read(v); read(w); add(u, v, w); all += w; } int l = 0, r = all / m, ans = 0; while (l &lt;= r) { mid = (l + r) &gt;&gt; 1; if (check()) { l = mid + 1; ans = mid; } else { r = mid - 1; } } printf(&quot;%d\\n&quot;, ans); return 0;}/* 1050ms 11964kB with O2 */ $D2T1$ 旅行分两种情况讨论 $I.$ $m = n - 1$即无环，只要给一个点所能到达的点的编号进行一次从小到大的排序，在树上dfs一遍即可解决样例1图示： 代码123456789101112131415161718192021222324namespace SolveOne { int cnt = 0; bool vis[maxn]; void dfs(int u, int fa) { ans[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v]) { dfs(v, u); } } } void solve() { for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } dfs(1, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}/* 1050ms 11964kB with O2 */ $II.$ $m = n$存在一个环（基环树）手算一下样例2可以发现，有且仅有一条边不会通过逐个删边尝试即可，删边后和$m = n - 1$相同样例2图示： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;const int inf = 0x3f3f3f3f;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}int n, m, ans[maxn], in[maxn][2];vector&lt;int&gt; G[maxn];namespace SolveOne { int cnt = 0; bool vis[maxn]; void dfs(int u, int fa) { ans[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v]) { dfs(v, u); } } } void solve() { for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } dfs(1, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}namespace SolveTwo { int cnt = 0, res[maxn], du, dv; bool vis[maxn]; bool notdel(int u, int v) { //判断该边是否被删 if ((u == du &amp;&amp; v == dv) || (u == dv &amp;&amp; v == du)) { return false; } return true; } void dfs(int u, int fa) { res[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v] &amp;&amp; notdel(u, v)) { dfs(v, u); } } } bool judge() { //判断是否为更优情况 for (int i = 1; i &lt;= n; ++i) { if (ans[i] != res[i]) { return ans[i] &gt; res[i]; } } return false; } void solve() { memset(ans, 0x3f, sizeof(ans)); for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } for (int i = 1; i &lt;= m; ++i) { cnt = 0; memset(res, 0, sizeof(res)); memset(vis, 0, sizeof(vis)); du = in[i][0]; //删边 dv = in[i][1]; dfs(1, 0); if (judge() &amp;&amp; cnt == n) { //如果更优则更改ans[] memcpy(ans, res, sizeof(res)); } } for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}int main() { n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) { int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); in[i][0] = u; //存储输入信息 in[i][1] = v; } if (m == n - 1) { SolveOne::solve(); } else { SolveTwo::solve(); } return 0;}/* 2244ms 1276kB */ $D2T2$ 填数游戏暴力推柿子首先明确一个概念:本文的对角线指的是从左下方到右上方的有向线段$\\mathcal{Lemma}\\ I.$ 对角线上的数只会相同或递减$proof:$由上图两条黑线和题目描述即可证明$Q.E.D$ $\\mathcal{Lemma}\\ II.$ 若$(x-1, y)$与$(x, y-1)$的数相同,则以$(x,y)$为左上角,整个图形右下角的子矩阵的每条对角线(蓝)上填的数字相同$proof:$由图上两条橙线及题目描述即可证明$Q.E.D$ $\\mathcal{Lemma}\\ III.$ $Ans(n,m)=Ans(m,n)$ 正式推式子(默认$n \\leq m$) $I.$ $n = 1$ 时每个格内都有2种填法,故$\\Ans(1,m)=2^{m}$ $II.$ $n = 2$ 时两个角上各两种,剩余$m-1$条对角线每条有3种(11,10,00)故$Ans(2,m)=2\\times 2\\times 3^{m-1}=4\\times 3^{m-1}$ $III. $ $n \\geq 4$ 时 (只考虑$n = m$时)$case I.$ 左上角两数相同图中数字表示每条对角线方案数可以得出$Ans(caseI.)=2\\times 2\\times 4^{n-2}\\times 2^{n-1}=8^{n-1}$ $case II.$ 第三条对角线数字相同图中红色数字表示方案数可以得出$Ans(caseII.)=2\\times 2\\times 5\\times 4^{n-4}\\times 2^{n-1}=5\\times 2^{3n-7}$ $case III.$ 第三条对角线上数字不同可以发现左侧两行只能填01,所以可能会再次出现对角数字相同的情况 第一个出现 最后一个出现 倒数第二个出现 没有出现 注意第三条对角线可能有100,110两种情况所以$Ans(case III.)=2\\times (2\\times 4\\times 5\\times 2^{n-1}\\times \\sum_{i=0}^{n-5}{4^i} + 2\\times 4\\times 3\\times 2^{n-2} + 2\\times 3\\times 2^{n-2})$ $Ans(n, n)=Ans(case I.) + Ans(case II.) + Ans(case III.)$$$Ans(n,n)=\\frac{83\\times 8^n + 5\\times 2^{n+7}}{384}$$ $IV.$ $n = 3$证明与前类似$$Ans(3,m)=112\\times 3^{m-3}$$ $V.$ $n \\neq m$ 时与前类似$$Ans(n,n+1)=\\frac{83\\times 8^n + 2^{n+8}}{128}$$同时易证得$Ans(n,m+1)=3\\times Ans(n,m)$ 于是就解决了 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;typedef long long LL;int n, m;LL poww(LL a, LL b) { LL res = 1; for ( ; b; a = a * a % mod, b &gt;&gt;= 1){ if (b &amp; 1) { res = res * a % mod; } } return res;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); if (n == 1) printf(&quot;%lld\\n&quot;, poww(2, m)); else if (n == 2) printf(&quot;%lld\\n&quot;, 4 * poww(3, m - 1) % mod); else if (n == 3) printf(&quot;%lld\\n&quot;, 112 * poww(3, m - 3) % mod); else { if (m == n) printf(&quot;%lld\\n&quot;, ((83 * poww(8, n) % mod + 5 * poww(2, n + 7) % mod) * 190104168 % mod)); else printf(&quot;%lld\\n&quot;, ((83 * poww(8, n) % mod + poww(2, n + 8)) * poww(3, m - n - 1) % mod * 570312504 % mod )); } return 0;}/* 55ms 1048kB */ $D2T3$ 保卫王国动态DP,树剖,蒟蒻不会 逃 如有疑问,可以在下方评论区留言","link":"/p/34a76f7d.html"},{"title":"Hexo搭建博客","text":"由于mkdocs上有很多不足，例如没有标签，分类，评论，计数等等，故转至使用Hexo搭建博客，以下是我折腾的过程 安装Hexo我是用的是Ubuntu16.04系统，其他系统安装方法可到官网查询在nodejs官网下载node.js，并解压添加环境变量echo &quot;export PATH=$PATH:/home/tony/node-v8.11.4-linux-x64/bin&quot; &gt;&gt; ~/.zshrc（如果使用的是bash，将最后一句改为~/.bashrc）source ~/.zshrc应用更改 下载hexonpm install -g hexo-cli 搭建博客123$ mkdir blog$ cd blog$ hexo init 使用hexo s启动服务,在浏览器中输入localhost:4000便可看到预览网页 部署到GitPages创建&lt;username&gt;.github.io存储库更改_config.yml文件中这一部分 1234deploy: type: git repository: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 使用hexo d -g发布 主题我当前使用的是maupassant主题详细配置见官方中文文档 参考Hexo官网zzq浅谈用Hexo+GitHub搭建自己的blogHexo博客搭建说明书（指北书）从零搭建 Hexo + Github 博客","link":"/p/178c0d2c.html"},{"title":"更新日志","text":"本博客在2019.3.10更改至由Hexo驱动，并在2019.3.12完成更改。原文章时间均改为2019.1.9，算法模板时间改为2019.1.10。","link":"/p/5a717bf0.html"},{"title":"Cpp算法-并查集","text":"说明n, m, q点数、边数、问题数x, y需要合并的两个数ufs[]并查集find(int)查找并查集中一个数的祖先unionn(int, int)合并两个数所在集合 实现1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 10010;int ufs[maxn];int n, m, x, y, q;int find(int x){ if (ufs[x] != x) return ufs[x] = find(ufs[x]); return ufs[x] = x;}void unionn(int x, int y){ int fx = find(x); int fy = find(y); if (fx != fy) { ufs[fx] = fy; }}int main(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) ufs[i] = i; for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); unionn(x, y); } scanf(&quot;%d&quot;, &amp;q); for (int i = 1; i &lt;= q; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (find(x) == find(y)) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } return 0;}","link":"/p/9603fc0b.html"},{"title":"Cpp算法-STL标准库","text":"模板 1234template &lt;typename T&gt;/** * 写函数/结构体 */ 例12345678910111213141516171819template &lt;typename T&gt;struct Point{ T x, y; Point(T x = 0, T y = 0):x(x), y(y) {}};template &lt;typename T&gt;Point&lt;T&gt; operator + (const Point&lt;T&gt;&amp; A, const Point&lt;T&gt;&amp; B){ return Point&lt;T&gt;(A.x + B.x, A.y + B.y);}template &lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; out, const Point&lt;T&gt;&amp; p){ out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;; return out;} vector(不定长数组) 声明vector&lt;数据类型&gt; 名; 例 vector&lt;int&gt; a; 简单用法a.size();读取大小a.resize();改变大小a.push_back(x);尾部添加元素xa.pop_back();删除最后一个元素a.clear();清空a.empty()询问是否为空(bool类型)a[]访问元素(可修改) priority_queue(优先队列/堆) 声明头文件: #include &lt;queue&gt;参数: priority_queue&lt;Type, Container, Functional&gt;&emsp;Type数据类型 不可省&emsp;Container容器(vector,deque)默认vector&emsp;Functional比较方式,默认operator &lt;大根堆 使用与queue类似 小根堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;使用仿函数greater&lt;&gt; 自定义类型(struct)12345struct Node{ int x, y; Node(int a = 0, int b = 0):x(a), y(b){}}; 重载operator &lt;1234567bool operator &lt; (Node a, Node b){ if (a.x == b.x) return a.y &gt; b.y; return a.x &gt; b.x;}priority_queue&lt;Node&gt; q; x值大的优先级低,排在队前x相等,y大的优先级低 重写仿函数12345678910struct cmp{ bool operator () (Node a, Node b) { if (a.x == b.x) return a.y &gt; b.y; return a.x &gt; b.x; }}priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; q;","link":"/p/ac108281.html"},{"title":"Cpp算法-背包问题","text":"01背包问题有 $n$ 件物品，和一容积为 $V$ 的背包，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 由题意易知状态转移方程： $F_{i,j} = max(F_{i-1,j}\\ , F_{i-1,j-w_i} + c_i)$ $F_{i, j}$ 为前 $i$ 件物品放入容量为 $V$ 的背包中最大价值时间复杂度 $O(n\\times V)$ ，空间复杂度 $O(n\\times V)$ 框架注意倒序，保证f[n][V]为结果 12345678for (int i = 1; i &lt;= n; ++i){ for (int j = V; j &gt;= w[i]; --j) { f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[n][V]) 空间复杂度优化降至一维数组时间复杂度 $O(n\\times V)$ ，空间复杂度 $O(V)$ 12345678for (int i = 1; i &lt;= n; ++i){ for (int j = V; j &gt;= w[i]; --j) { f[j] = max(f[j], f[j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[V]); 完全背包问题有 $n$ 种物品（每种 无限件 ），和一容积为 $V$ 的背包，第 $i$ 种物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几种物品取任意件装入，使体积不超过总体积，且价值和最大，求最大价值。 将01背包第二个循环改为正序即可状态转移方程：$F_j = max(F_j\\ , F_{j-w_i}+c_i)$ 框架12345678for (int i = 1; i &lt;= n; ++i){ for (int j = w[i]; j &lt;= V; ++j) { f[j] = max(f[j], f[j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[V]); 多重背包问题有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 解法 $I.$ 化为完全背包状态转移方程：$F_{i,v} = max(F_{i-1,v-k\\times w_i} + k\\times c_i | 0\\leqslant k\\leqslant n_i)$时间复杂度：$O(V\\times \\sum{n_i})$ 框架1234567891011for (int i = 1; i &lt;= N; ++i){ for (int j = V; j &gt;= 0; --j) { for (int k = 0; k &lt;= n[i]; ++k) { f[i][j] = max(f[i - 1][j], [i - 1][j - k * w[i]] + k * c[i]) } }}printf(&quot;%d&quot;, f[N][V]); 解法 $II.$ 化为01背包把 $n_i$ 件一种物品化为单独的 $n_i$ 件物品即可时间复杂度：$O(V\\times \\sum{n_i})$框架略 解法 $III.$ 二进制优化$$n_i\\to 1+2+4+\\dots +2^{k-1}+\\dots +(n_i-2^k+1)$$$$\\sum{n_i}\\to \\sum{\\log_2{n_i}}$$时间复杂度：$O(V\\times \\sum{\\log_2{n_i}})$ 框架123456789101112131415161718for (int i = 1; i &lt;= n; ++i){ int w, c, n, t = 1; scanf(&quot;%d %d %d&quot;, &amp;w, &amp;c, &amp;n); while(n &gt;= t) { v[++N] = x * t; w[N] = y * t; n -= t; t *= 2; } v[++N] = x * n; w[N] = y * n;}for (int i = 1; i &lt;= N; ++i) for (int j = V; j &gt;= v[i]; --j) f[j] = max(f[j], f[j - v[i]] + w[i]);printf(&quot;%d&quot;, f[V]); 混合三种背包问题有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件或无穷件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 伪框架12345678910111213for (int i = 1; i &lt;= N; ++i){ if (第i件是有穷件) { for (int j = V; j &gt;= 0; --j) f[j] = max(f[j], f[j - w[i]] + c[i]); } else //有无穷件 { for (int j = 0; j &lt;= V; ++j) f[j] = max(f[j], f[j - w[i]] + c[i]); }} 二维费用的背包问题有 $N$ 件物品，容积为 $V,U$ 的两个背包，每件物品有两种费用，选择物品需要付出两种代价，第 $i$ 件代价为 $a_i,b_i$，价值为 $c_i$。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 改为二维数组即可状态转移方程：$F_{v,u} = max(F_{v,u}\\ , F_{v-a_i,u-b_i} + c_i)$$F_{v,u}$ 表示前面的物品付出代价分别为 $v,u$ 时的最大价值框架略 循环顺序 类01背包：v = V..0 u = U..0 类完全背包：v = 0..V u = 0..U 类多重背包：拆分物品 分组的背包问题有 $K$ 组物品， $V$ 的背包，第 $k$ 组有 $N_k$ 件物品，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ ，每组中只能选一件物品。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 框架12345678for (int k = 1; k &lt;= K; ++k){ for (int v = V; v &gt;= 0; --v) { for (int i = 1; i &lt;= N[k]; ++i) f[v] = max(f[v], f[v - w[i]] + c[i]); }} 背包问题的方案数状态转移方程：$F_{i,v} = sum(F_{i-1,v}, F_{i-1,v-w_i})\\ \\ \\ (F_{0,0} = 1)$ 框架1234567f[0] = 1;for (int i = 1; i &lt;= N; ++i){ for (int j = w[i]; j &lt;= V; ++j) f[j] += f[j - w[i]];}printf(&quot;%d&quot;, f[V]);","link":"/p/990bbe9a.html"},{"title":"Cpp算法-堆","text":"说明heap[]堆heap_size堆大小put(int)压入一个数get()弹出堆顶 普通实现12345678910111213141516171819202122232425262728293031323334int heap[maxn];int heap_size = 0;void put(int d){ int now, next; heap[++heap_size] = d; now = heap_size; while (now &gt; 1) { next = now &gt;&gt; 1; if (heap[now] &lt;= heap[next]) break; swap(heap[now], heap[next]); now = next; } return;}int get(){ int now, next, res; res = heap[1]; heap[1] = heap[heap_size--]; now = 1; while (now * 2 &lt;= heap_size) { next = now * 2; if (next &lt; heap_size &amp;&amp; heap[next + 1] &lt; heap[next]) next++; if (heap[now] &lt;= heap[next]) break; swap(heap[now], heap[next]); now = next; } return res;} STL实现1234567891011121314151617int heap[maxn];int heap_size = 0;void put(int d){ heap[++heap_size] = d; push_heap(heap + 1, heap + heap_size + 1); //push_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); return;}int get(){ pop_heap(heap + 1, heap + heap_size + 1); //pop_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); return heap[heap_size--];}","link":"/p/bb233fbc.html"},{"title":"Cpp算法-图论-SPFA","text":"说明n, m, s点数、边数、源点cnt, head[], edge[], add(int, int, int)链式前向星dist[]各点到源点路径长vis[]记录 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 10010;const int maxm = 500010;int n, m, s, dist[maxn], vis[maxn];int cnt, head[maxn];struct Edge{ int next, to, dis;}edge[maxm];void add(int from, int to, int dis){ edge[++cnt].next = head[from]; edge[cnt].to = to; edge[cnt].dis = dis; head[from] = cnt;}void SPFA(){ queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) { dist[i] = INT_MAX; } q.push(s); dist[s] = 0; vis[s] = true; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; if (dist[v] &gt; dist[u] + edge[i].dis) { dist[v] = dist[u] + edge[i].dis; if (!vis[v]) { vis[v] = true; q.push(v); } } } } return;}","link":"/p/8ed8c69a.html"},{"title":"Cpp算法-图论-链式前向星","text":"说明cnt记数head[]记录边的头struct Edge{int, int, int}边信息: 开始点、结束点、权值add_edge(int, int, int)添加边 实现123456789101112int cnt, head[maxn];struct Edge{ int next, to, val;}edge[maxm];void add_edge(int from, int to, int val){ edge[++cnt].next = head[from]; edge[cnt].to = to; edge[cnt].val = val; head[from] = cnt;}","link":"/p/dda660a4.html"},{"title":"Cpp算法-图论-Prim","text":"说明n, m, _map[][]点数、边数、邻接矩阵dist[]树根到各点路径长pre[]生成树路径 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int maxn = 101;int n, m, dist[maxn], _map[maxn][maxn], pre[maxn];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) _map[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) _map[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); _map[from][to] = w; } return;}void Prim(){ int i, j, k; int min; bool p[maxn]; for (int i = 2; i &lt;= n; ++i) { p[i] = false; dist[i] = _map[1][i]; pre[i] = 1; } dist[1] = 0; p[1] = true; for (int i = 1; i &lt;= n - 1; ++i) { min = INT_MAX; k = 0; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; dist[j] &lt; min) { min = dist[j] k = j; } } if (k == 0) return; p[k] = true; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; _map[k][j] != INT_MAX &amp;&amp; dist[j] &gt; _map[k][j]) { dist[j] = _map[k][j]; pre[j] = k; } } } return;}","link":"/p/8760af74.html"},{"title":"Cpp算法-图论-Kruskal","text":"说明ufs[], find(int), unionn(int, int)并查集结构edge[]链式前向星cmp(Edge, Edge)边排序方案 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int maxn = 1010;int ufs[maxn];int find(int x){ if (ufs[x] != x) return ufs[x] = find(ufs[x]); return ufs[x] = x;}void unionn(int x, int y){ int a = find(x); int b = find(y); if (a != b) { ufs[a] = b; }}const int maxm = 100010;struct Edge{ int a, b, w; bool select;}edge[maxm];bool cmp(Edge a, Edge b){ if (a.w != b.w) return a.w &lt; b.w; if (a.a != b.a) return a.a &lt; b.a; return a.b &lt; b.b; }void kruskal(){ for (int i = 1; i &lt;= n; ++i) { ufs[i] = i; } int k = 0, x, y; sort(edge + 1, edge + 1 + m, cmp); for (int i = 1; i &lt;= m; ++i) { if (k == n - 1) break; x = find(edge[i].a); y = find(edge[i].b); if (x != y) { unionn(x, y); k++; edge[i].select = true; } }}","link":"/p/c4fb1928.html"},{"title":"Cpp算法-字符串算法-KMP","text":"例：洛谷P3375 说明pre()求前缀数组kmp()匹配字符串 实现12345678910111213141516171819202122232425262728293031323334353637383940char s1[1000010], s2[1000010];int nxt[1000010], l1, l2;void pre(){ nxt[1] = 0; int j = 0; for (int i = 1; i &lt; l2; ++i) { while (j &gt; 0 &amp;&amp; s2[j + 1] != s2[i + 1]) j = nxt[j]; if (s2[j + 1] == s2[i + 1]) j++; nxt[i + 1] = j; }}void kmp(){ int j = 0; for (int i = 0; i &lt; l1; ++i) { while (j &gt; 0 &amp;&amp; s2[j + 1] != s1[i + 1]) j = nxt[j]; if (s2[j + 1] == s1[i + 1]) j++; if (j == l2) { printf(&quot;%d\\n&quot;, i - l2 + 2); j = nxt[j]; } }}int main(){ cin &gt;&gt; s1 + 1; cin &gt;&gt; s2 + 1; l1 = strlen(s1 + 1); l2 = strlen(s2 + 1); pre(); kmp(); return 0;}","link":"/p/632c6631.html"},{"title":"Cpp算法-字符串算法-哈希表","text":"例：洛谷P4305 说明hash[]哈希表find(int x)查找哈希表中 $x$ 的位置push(int x)将 $x$ 插入到哈希表中check(int x)查找 $x$ 是否在哈希表中 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#define p 100003#define hash(a) a%pint h[p], t, n, x;int find(int x){ int y; if (x &lt; 0) y = hash(-x); else y = hash(x); while (h[y] &amp;&amp; h[y] != x) y = hash(++y); return y;}void push(int x){ h[find(x)] = x;}bool check(int x){ return h[find(x)] == x;}int main(){ scanf(&quot;%d&quot;, &amp;t); while (t--) { memset(h, 0, sizeof(h)); scanf(&quot;%d&quot;, &amp;n); while (n--) { scanf(&quot;%d&quot;, &amp;x); if (!check(x)) { printf(&quot;%d &quot;, x); push(x); } } printf(&quot;\\n&quot;); } return 0;}","link":"/p/666f05c6.html"},{"title":"Cpp算法-字符串算法-字符串哈希","text":"例：洛谷P3370 单哈希(自然溢出)123456789101112typedef unsigned long long ULL;ULL base = 131, a[10010];char s[10010];ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = Ans * base + (ULL)s[i]; return Ans &amp; 0x7fffffff;} 单哈希(单模数)123456789101112typedef unsigned long long ULL;ULL base = 131, a[10010], mod = 19260817;char s[10010];ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod; return Ans;} 单哈希(大模数)12345678910111213typedef unsigned long long ULL;ULL base = 131, a[10010], mod = 212370440130137957LL;char s[10010];int prime = 233317;ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; ++i) Ans = (Ans * base + (ULL)s[i]) % mod + prime; return Ans;} 双哈希12345678910111213141516171819202122232425typedef unsigned long long ULL;ULL base = 131, mod1=19260817, mod2=19660813;char s[10010];struct data{ ULL x,y;}a[10010];ULL hash1(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod1; return Ans;}ULL hash2(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod2; return Ans;}","link":"/p/114af1e8.html"},{"title":"Cpp算法-数论-线性筛素数","text":"说明p[] 最终结果 实现123456789101112131415161718bool vis[N];int p[N], cnt;void get_prime(){ for (int i = 2; i &lt; N; ++i) { if (!vis[i]) p[++cnt] = i; for (int j = 1; j &lt;= cnt; ++j) { int v = i * p[j]; if (v &gt;= N) break; vis[v] = true; if (i % p[j] == 0) continue; } }}","link":"/p/cff9d95.html"},{"title":"Cpp算法-图论-Floyd","text":"说明n, m, G[][]点数、边数、邻接矩阵dist[][]每对顶点间路径长度pre[][]每对顶点之间路径make()建图 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445const int maxn = 110;int n, m, G[maxn][maxn], dist[maxn][maxn], pre[maxn][maxn];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) G[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) G[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); G[from][to] = w; } return;}void Floyd(){ for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { dist[i][j] = G[i][j]; pre[i][j] = i; } } for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; pre[i][j] = pre[k][j]; } } } } return;}","link":"/p/ba77762f.html"},{"title":"Cpp算法-图论-欧拉回路","text":"邻接矩阵说明G[][]邻接矩阵deg[]度ans[]欧拉回路n, e点数、边数 实现123456789101112131415161718192021222324252627282930313233343536int G[maxn][maxn], deg[maxn], ans[maxn];int n, e, x, y, ansi, s;void Euler(int i){ for (int j = 1; j &lt;= n; ++j) { if (G[i][j]) { G[i][j] = G[j][i] = 0; Euler(j); } } ans[++ansi] = i;}int main(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;e); for (int i = 1; i &lt;= e; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); G[x][y] = G[y][x] = 1; deg[x]++; deg[y]++; } s = 1; for (int i = 1; i &lt;= n; ++i) if (deg[i] % 2 == 1) s = i; Euler(s); for (int i = 1; i &lt;= ansi; ++i) printf(&quot;%d &quot;, ans[i]); printf(&quot;\\n&quot;); return 0;} 链式前向星说明n, m点数、边数head, edge[]链式前向星ans[], ansi路径、数组大小vis[]记录make()建图 实现12345678910111213141516171819202122232425262728293031323334353637int head[maxn];struct Node{ int to, next;}edge[maxm];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int k = 1; k &lt;= m; ++k) { int i, j; scanf(&quot;%d %d&quot;, &amp;i, &amp;j); edge[k].to = i; edge[k].next = head[i]; head[i] = k; } return;}int ans[maxm];int ansi = 0;bool vis[2 * maxm];void dfs(int now){ for (int k = head[now]; k != 0; k = edge[k].next) { if (!vis[k]) { vis[k] = true; vis[k ^ 1] = true; dfs(edge[k].to); ans[ansi++] = k; } }}","link":"/p/57662471.html"},{"title":"Cpp算法-动态规划","text":"待完成 多阶段过程决策的最优化问题12345678910111213141516graph LR A --5--&gt; B1 A --3--&gt; B2 B1 --1--&gt; C1 B1 --6--&gt; C2 B1 --3--&gt; C3 B2 --8--&gt; C2 B2 --4--&gt; C4 C1 --5--&gt; D1 C1 --6--&gt; D2 C2 --5--&gt; D1 C3 --8--&gt; D3 C4 --3--&gt; D3 D1 --3--&gt; E D2 --4--&gt; E D3 --3--&gt; E !!! tldr “题目及注解” 求上图从 $A$ 到 $E$ 的最短距离 $K$: 阶段 $D(X_I, (X+1)_J)$: 从 $X_I$ 到 $(X+1)_J$ 的距离 $F_K(X_I)$: $K$ 阶段下 $X_I$ 到终点 $E$ 的最短距离 倒推:$$K=4\\qquad F_4(D_1)=3\\qquad F_4(D_2)=4\\qquad F_4(D_3)=3$$$$K=5\\qquad F_3(C_1)=min(D(C_1,D_1)+F_4(D_1),D(C_1,D_2)+F_4(D_2))=min(5+3,6+4)=8F_3(C_2)$$","link":"/p/8364d7e9.html"},{"title":"Cpp算法-图论-Dijkstra","text":"说明n, m点数、边数G[][]邻接矩阵存图dist[]路径长度pre[]路径make()建图 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int maxn = 10010;int n, m, G[maxn][maxn], dist[maxn], pre[maxn], s;void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) G[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) G[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); G[from][to] = w; } return;}void Dijkstra(){ int k, min; bool p[maxn]; for (int i = 1; i &lt;= n; ++i) { p[i] = false; if (i != s) { dist[i] = G[s][i]; pre[i] = s; } } dist[s] = 0; p[s] = true; for (int i = 1; i &lt;= n - 1; ++i) { min = INT_MAX; k = 0; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; dist[j] &lt; min) { min = dist[j]; k = j; } } if (k == 0) return; p[k] = true; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; G[k][j] != INT_MAX &amp;&amp; dist[j] &gt; dist[k] + G[k][j]) { dist[j] = dist[k] + G[k][j]; pre[j] = k; } } } return;} 堆优化(链式前向星)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Edge{ int to, nxt, t;}edge[maxm &lt;&lt; 1];int head[maxn], cnt;void add(int a, int b, int t){ edge[++cnt].to = b; edge[cnt].nxt = head[a]; edge[cnt].t = t; head[a] = cnt;}struct heap{ int u, d; bool operator &lt; (const heap&amp; a) const { return d &gt; a.d; }};void Dijkstra(){ priority_queue&lt;heap&gt; q; for (int i = 0; i &lt;= n; ++i) dist[i] = INF; dist[1] = 0; q.push((heap){1, 0}); while (!q.empty()) { heap top = q.top(); q.pop(); int tx = top.u; int td = top.d; if (td != dist[tx]) continue; for (int i = head[tx]; i; i = edge[i].nxt) { int v = edge[i].to; if (dist[v] &gt; dist[tx] + edge[i].t) { dist[v] = dist[tx] + edge[i].t; dy[v] = i; dx[v] = tx; //记录路径 q.push((heap){v, dist[v]}); } } }} 路径123456int q = n, p[maxm];while (q != 1){ p[++tot] = dy[q]; q = dx[q];}","link":"/p/982e7a01.html"},{"title":"Cpp算法-树状数组","text":"树状数组模板：洛谷P3374 说明tree[]树状数组lowbit(int)神奇的函数add(int x, int k)第 $x$ 个数加上 $k$ sum(int x)前 $x$ 个数的和 实现1234567891011121314151617181920212223242526int tree[2000010];int lowbit(int k){ return k &amp; -k;}void add(int x, int k){ while (x &lt;= n) { tree[x] += k; x += lowbit(x); }}int sum(int x){ int ans = 0; while (x != 0) { ans += tree[x]; x -= lowbit(x); } return ans;}","link":"/p/72c90980.html"},{"title":"Cpp算法-大整数类","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;iosfwd&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;using namespace std;const int maxl = 5000;#define max(a, b) a&gt;b ? a : b#define min(a, b) a&lt;b ? a : bclass BigInteger{ public: int len, s[maxl]; BigInteger(); BigInteger(const char*); BigInteger(int); bool sign; string toStr() const; friend istream&amp; operator&gt;&gt;(istream&amp;, BigInteger&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigInteger&amp;); BigInteger operator=(const char*); BigInteger operator=(int); BigInteger operator=(const string); bool operator&gt;(const BigInteger&amp;) const; bool operator&gt;=(const BigInteger&amp;) const; bool operator&gt;(const BigInteger&amp;) const; bool operator&gt;=(const BigInteger&amp;) const; bool operator==(const BigInteger&amp;) const; bool operator!=(const BigInteger&amp;) const; BigInteger operator+(const BigInteger&amp;) const; BigInteger operator++(); BigInteger operator++(int); BigInteger operator+=(const BigInteger&amp;); BigInteger operator-(const BigInteger&amp;) const; BigInteger operator--(); BigInteger operator--(int); BigInteger operator-=(const BigInteger&amp;); BigInteger operator*(const BigInteger&amp;) const; BigInteger operator*(const int num) const; BigInteger operator*=(const BigInteger&amp;); BigInteger operator/(const BigInteger&amp;) const; BigInteger operator/=(const BigInteger&amp;); BigInteger operator%(const BigInteger&amp;) const; BigInteger factorial() const; BigInteger Sqrt() const; BigInteger Pow(const BigInteger&amp;) const; void clean(); ~BigInteger;};BigInteger::BigInteger(){ memset(s, 0, sizeof(s)); len = 1; sign = 1;}BigInteger::BigInteger(const char *num){ *this = num;}BigInteger::BigInteger(int num){ *this = num;}string BigInteger::toStr() const{ string res; res = &quot;&quot;; for (int i = 0; i &lt; len; ++i) res = (char)(s[i] + '0') + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign &amp;&amp; res != &quot;0&quot;) res = &quot;-&quot; + res; return res;}istream&amp; operator&gt;&gt;(istream&amp; in, BigInteger&amp; num){ string str; in&gt;&gt;str; num = str; return in;}ostream&amp; operator&lt;&lt;(ostream&amp; out, BigInteger&amp; num){ out&lt;&lt;num.toStr(); return out;}BigInteger BigInteger::operator=(const char* num){ memset(s, 0, sizeof(s)); char a[maxl] = &quot;&quot;; if (num[0] != &quot;-&quot;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); ++i) a[i - 1] = num[i]; sign = !(num[0] == &quot;-&quot;); len = strlen(a); for (int i = 0; i &lt; strlen(a); ++i) s[i] = a[len - i - 1] - 48; return *this;}BigInteger BigInteger::operator=(int num){ if (num &lt; 0) sign = 0, num = -num; else sign = 1; char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this;}BigInteger BigInteger::operator=(const string num){ const char* tmp; tmp = num.c_str(); *this = tmp; return *this;}bool BigInteger::operator&lt;(const BigInteger&amp; num) const{ if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; --i) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (s[i] &gt; num.s[i]) return !sign;}bool BigInteger::operator&gt;(const BigInteger&amp; num) const{ return num &lt; *this;}bool BigInteger::operator&lt;=(const BigInteger&amp; num) const{ return !(*this &gt; num);}bool BigInteger::operator&gt;=(const BigInteger&amp; num) const{ return !(*this &lt; num);}bool BigInteger::operator!=(const BigInteger&amp; num) const{ return *this &gt; num || *this &lt; num;}bool BigInteger::operator==(const BigInteger&amp; num) const{ return !(num != *this);}BigInteger BigInteger::operator+(const BigInteger&amp; num) const{ if (sign^num.sign) { BigInteger tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } BigInteger result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result;}BigInteger BigInteger::operator++(){ *this = *this + 1; return *this;}BigInteger BigInteger::operator++(int){ BigInteger old = *this; ++(*this); return old;}BigInteger BigInteger::operator+=(const BigInteger&amp; num){ *this = *this + num; return *this;}BigInteger BigInteger::operator-(const BigInteger&amp; num) const{ BigInteger b = num, a = *this; if (!num.sign &amp;&amp; !sign) { b.sign = 1; a.sign = 1; return b - a; } if (!b.sign) { b.sign = 1; return a + b; } if (!a.sign) { a.sign = 1; b = BigInteger(0) - (a + b); return b; } if (a &lt; b) { BigInteger c = (b - a); c.sign = false; return c; } BigInteger result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result;}BigInteger BigInteger::operator--(){ *this = *this - 1; return *this;}BigInteger BigInteger::operator--(int){ BigInteger old = *this; --(*this); return old;}BigInteger BigInteger::operator-=(const BigInteger&amp; num){ *this = *this - num; return *this;}BigInteger BigInteger::operator*(const BigInteger&amp; num) const{ BigInteger result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result;}BigInteger BigInteger::operator*(const int num) const{ BigInteger x = num; BigInteger z = *this; return *this;}BigInteger BigInteger::operator/(const BigInteger&amp; num) const{ BigInteger ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } BigInteger divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + '0'; BigInteger dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; BigInteger temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans;}BigInteger BigInteger::operator/=(const BigInteger&amp; num){ *this = *this / num; return *this;}BigInteger BigInteger::operator%(const BigInteger&amp; num) const{ BigInteger a = *this, b = num; a.sign = b.sign = 1; BigInteger result, temp = a / b*b; result = a - temp; result.sign = sign; return result;}BigInteger BigInteger::Pow(const BigInteger&amp; num) const{ BigInteger result = 1; for (BigInteger i = 0; i &lt; num; i++) result = result * (*this); return result;}BigInteger BigInteger::factorial() const{ BigInteger result = 1; for (BigInteger i = 1; i &lt;= *this; i++) result *= i; return result;}void BigInteger::clean(){ if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == '\\0') len--;}BigInteger BigInteger::Sqrt() const{ if(*this &lt; 0) return - 1; if(*this &lt;= 1)return *this; BigInteger l = 0, r = *this, mid; while(r - l &gt; 1) { mid = (l + r) / 2; if(mid * mid &gt; *this) r = mid; else l = mid; } return l;}BigInteger::~BigInteger(){}","link":"/p/b995b9d7.html"},{"title":"Cpp算法-BFS","text":"说明本文实现只是框架，应当灵活运用，bfs()函数内部根据情况灵活更改广搜算法基于树、队列实现，具体思路: 将当前点的子节点入队，当前点出队，如果子节点满足条件则记录并重复此过程 框架数组模拟队列12345678910111213141516171819202122232425void bfs(){ int head = 1, tail = 2; vis[start_x][start_y] = true; //标记起始点 que[head][0] = start_x; que[head][1] = start_y; //起始点入队 while(head &lt; tail) //队不为空 { int x = que[head][0], y = que[head][1] //获取队首点 for (int i = 0; i &lt; 子节点数; ++i) { int x2 = x子节点, y2 = y子节点; if (x2, y2满足条件 &amp;&amp; !vis[x2][y2]) { 记录结果; vis[x2][y2] = true; que[tail][0] = x2; que[tail][0] = y2; tail++; //入队 } } head++; //队首出队 } return} STL-queue123456789101112131415161718192021222324252627282930313233struct Node{ int x, y;}node, top;queue&lt;Node&gt; que;void bfs(){ vis[sx][sy] = true; node.x = sx; node.y = sy; que.push(node); ans[sx][sy] = 0; while(!que.empty()) { top = que.front(); for (int i = 0; i &lt; 8; ++i) { int x2 = ..., y2 = ...; if (x2, y2满足条件 &amp;&amp; !vis[x2][y2]) { 记录结果; vis[x2][y2] = true; node.x = x2; node.y = y2; que.push(node); } } que.pop(); } return;} 例洛谷P1443 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, sx, sy, vis[210][210], ans[210][210];int gox[8] = {-2, -1, 1, 2, 2, 1, -1, -2};int goy[8] = {1, 2, 2, 1, -1, -2, -2, -1};struct horse{ int x, y;}node, top;queue&lt;horse&gt; que;void bfs(){ vis[sx][sy] = 1; node.x = sx; node.y = sy; que.push(node); ans[sx][sy] = 0; while(!que.empty()) { top = que.front(); for (int i = 0; i &lt; 8; ++i) { int x2 = top.x + gox[i]; int y2 = top.y + goy[i]; if (x2 &gt;= 1 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= 1 &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2]) { ans[x2][y2] = ans[top.x][top.y] + 1; vis[x2][y2] = 1; node.x = x2; node.y = y2; que.push(node); } } que.pop(); } return;}int main(){ scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;sx, &amp;sy); memset(ans, -1, sizeof(ans)); bfs(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) printf(&quot;%-5d&quot;, ans[i][j]); printf(&quot;\\n&quot;); } return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, sx, sy, vis[210][210], que[50000][2], ans[210][210];int gox[8] = {-2, -1, 1, 2, 2, 1, -1, -2};int goy[8] = {1, 2, 2, 1, -1, -2, -2, -1};void bfs(){ int head = 1, tail = 2; vis[sx][sy] = 1; que[head][0] = sx; que[head][1] = sy; ans[sx][sy] = 0; while (head &lt; tail) { int x, x2, y, y2; x = que[head][0]; y = que[head][1]; for (int i = 0; i &lt; 8; ++i) { x2 = x + gox[i]; y2 = y + goy[i]; if (x2 &gt;= 1 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= 1 &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2]) { ans[x2][y2] = ans[x][y] + 1; vis[x2][y2] = 1; que[tail][0] = x2; que[tail][1] = y2; tail++; } } head++; } return;}int main(){ scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;sx, &amp;sy); memset(ans, -1, sizeof(ans)); bfs(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) printf(&quot;%-5d&quot;, ans[i][j]); printf(&quot;\\n&quot;); } return 0;}","link":"/p/99890668.html"},{"title":"Cpp算法-DFS","text":"说明本文实现只是框架，应当灵活运用，dfs(…)函数返回值类型、参数列表根据情况灵活更改 框架1234567891011121314151617void dfs(参数列表){ if (到达目的地) 输出结果; else { for (int i = 0; i &lt; 行动方法数; ++i) { if (下一步可行) { 记录此步; dfs(改动后的参数列表); 取消记录此步; } } } return;} 例洛谷P1605 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, t, sx, sy, fx, fy, ans;int mg[6][6], now[6][6];int go[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};void dfs(int x, int y){ int x2, y2; if (x == fx &amp;&amp; y == fy) ans++; else { for (int i = 0; i &lt; 4; ++i) { x2 = x + go[i][0]; y2 = y + go[i][1]; if (x2 &gt; 0 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt; 0 &amp;&amp; y2 &lt;= m &amp;&amp; mg[x2][y2] == 0 &amp;&amp; now[x2][y2] == 0) { now[x2][y2] = 1; dfs(x2, y2); now[x2][y2] = 0; } } } return;}int main(){ memset(mg, 0, sizeof(mg)); scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;t); scanf(&quot;%d %d %d %d&quot;, &amp;sx, &amp;sy, &amp;fx, &amp;fy); for (int i = 1; i &lt;= t; ++i) { int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); mg[x][y] = 1; } now[sx][sy] = 1; ans = 0; dfs(sx, sy); printf(&quot;%d&quot;, ans); return 0;}","link":"/p/9d047ada.html"},{"title":"Linux美化方案","text":"I. 初步系统优化 更改系统时间 安装python sudo apt install python 安装git并添加ssh密钥 sudo apt install git git config --global user.name &quot;your_name&quot; git config --global user.email &quot;you@example.com&quot; ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;一路回车 cat ~/.ssh/id_rsa.pub并复制粘贴到github上 ssh -T git@github.com测试 git clone https://github.com/Tony031218/Beautiful_Linux.git克隆下本仓库 添加语言 settings -> Region&Language -> manage installed language -> install/remove languages -> input sources 软件更新 sudo apt update sudo apt upgrade 安装GDebi sudo apt install gdebi 卸载libreoffice 安装 WPS(可选) sudo apt remove libreoffice-common 从http://www.wps.cn/product/wpslinux/ 上下载WPS sudo dpkg -i wps-office_10.1.0.6757_amd64.deb 卸载firefox 安装 Chrome(可选) sudo apt remove firefox wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome* sudo apt -f install 更换更新源 左下角 -&gt; all -&gt; Software&amp;Updates sudo apt update 安装vim sudo apt install vim 菜单栏位置 gsettings set com.canonical.Unity.Launcher launcher-position Bottom底部 gsettings set com.canonical.Unity.Launcher launcher-position Left左侧 II. 主题配置 安装 Unity-tweak-toolsudo apt install unity-tweak-tool如果出现报错需要安装缺失的包 安装 Flatabulous 主题sudo add-apt-repository ppa:noobslab/themessudo apt updatesudo apt install flatabulous-theme主题sudo add-apt-repository ppa:noobslab/iconssudo apt updatesudo apt install ultra-flat-icons图标unity-tweak-tool -&gt; 主题/图标 字体Monaco Powerline 也可以选择其他字体,但一定要支持Powerline的,否则后文会出现乱码 III. 终端Terminal美化 Terminal zsh sudo apt install zsh git clone https://github.com/robbyrussell/oh-my-zsh.git cd oh-my-zsh/tools ./install.sh 更换默认shell chsh按步骤来输入zsh地址 zsh插件 自动补全 git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 快速跳转 git clone https://github.com/joelthelion/autojump.git cd autojump ./install.py按要求把代码填写到~/.zshrc文件尾 配置 vim ~/.zshrc 修改60行左右的pluginsplugins=(git autojump zsh-suggestions) 修改皮肤 ~/.zshrc中的ZSH_THEME=&quot;robbyrussell&quot;更改 IV. vim美化 molokai mkdir ~/.vim/colors 将本仓库中的molokai.vim复制到~/.vim/colors/下 Powerline sudo apt install python-pip pip install git+git://github.com/powerline/powerline pip show powerline-status 按照具体位置更改~/.vimrc中的set rtp+=...一行(后文) 插件 pathogen插件管理 mkdir -p ~/.vim/autoload ~/.vim/bundle curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim nerdtree文件浏览器 cd ~/.vim/bundle git clone https://github.com/scrooloose/nerdtree.git taglist大纲界面taglist官网 下载后解压到~/.vim/bundle/下 vimrc 将本仓库中的vimrc.txt复制到~/.vimrc中 内包含括号匹配,html标签匹配,powerline配置(可能需要改动),cpp.sh.java.py的文件头自动输入,插件的配置(F3打开nerdtree,F4打开taglist) 参考 CSDN博客powerlinevim插件monaco powerline字体monokai主题WPS","link":"/p/f2ddc0e6.html"},{"title":"Git简单用法","text":"Git是一款版本控制软件，配合GitHub可以更好的控制代码 SSH Key1234$ ssh-keygen -t rsa -C &quot;975062472@qq.com&quot;$ cd ~/.ssh$ cat id_rsa.pub$ ssh -T git@github.com 创建仓库12345678910$ mkdir study_cpp$ cd study_cpp/$ echo &quot;# test&quot; &gt;&gt; README.md$ lsREADME.md$ git init$ git add README.md$ git commit -m &quot;添加 README.md 文件&quot;$ git remote add origin git@github.com:Tony031218/study_cpp.git$ git push -u origin master 克隆1$ git clone git@github.com:Tony031218/study_cpp 提取12$ git fetch origin$ git merge origin/master 推送123$ git add &lt;filename&gt;$ git commit -m &quot;推送信息&quot;$ git push origin master 远程仓库1234$ git remote add origin2 git@github.com:Tony031218/study_cpp.git$ git remote -v$ git remote rm origin2$ git remote -v 分支12345$ git checkout -b graph //创建分支，并切换过去$ git checkout master //回到主分支$ git push origin graph //将分支推送到远程仓库$ git pull //将本地仓库更新$ git diff graph master //显示差别 克隆分支1234$ git clone -b &lt;branch_name&gt; &lt;repo_url&gt; //克隆单个分支$ cd &lt;repo&gt;$ git branch -a //查看所有分支$ git checkout -b &lt;branch_name&gt; origin/&lt;branch_name&gt; //关联分支","link":"/p/e779c345.html"},{"title":"Markdown语法","text":"Markdown是一款简洁实用的文本标记语言，可以在mkdocs,hexo中使用 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 下划线 1234---*******---- 目录[TOC] 文字样式** **加粗* *倾斜*** ***倾斜加粗~~ ~~删除 引用&gt;一级 &gt;&gt;二级 引用 二级引用 引用 空行&amp;nbsp; 或 &lt;br/&gt;&nbsp; 空格&amp;emsp;&emsp;&emsp;空格 图片![图片名](图片地址 &quot;title&quot;) 或使用html标签&lt;img src=&quot;...&quot; width=&quot;...&quot; height=&quot;...&quot; /&gt; 链接[网页名](地址 &quot;title&quot;)百度 代码块12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ printf(&quot;hello markdown&quot;); return 0;} 序表 有序1 有序2 有序3 + 或 - 或 * 无序 无序 无序 一级无序 二级无序 三级无序 四级无序 任务列表- [ ] ...- [x] ...mkdocs需要pymdown中的pymdownx模块GitHub支持 表格123|表头|表头|表头||:----------|:----------:|----------:|| 左对齐 |居中|右对齐| 表头 表头 表头 左对齐 居中 右对齐 内联CSS&lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: 'Consolas';&quot;&gt;CSS&lt;/p&gt; CSS 语义标记123456&lt;i&gt;斜体&lt;/i&gt;&lt;b&gt;加粗&lt;/b&gt;&lt;em&gt;强调&lt;/em&gt;上标： Z&lt;sup&gt;a&lt;/sup&gt;下标： Z&lt;sub&gt;a&lt;/sub&gt;键盘文本： &lt;kbd&gt;Ctrl&lt;/kbd&gt; 斜体 加粗 强调 上标： Za 下标： Za 键盘文本： Ctrl 公式文档末尾添加 12345678&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});&lt;/script&gt; 使用$\\LaTeX$语法编写公式$$x \\href{why-equal.html} {=} y^2 + 1$$$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$$ MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","link":"/p/3c50d03d.html"},{"title":"MkDocs使用方法","text":"mkdocs是一款基于python markdown的项目文档工具,可以用来编写一个网站 安装安装python3及pip1234$ sudo apt install python3 #安装python$ sudo apt install python3-pip #安装pip$ python3 --version #检查python是否安装成功$ pip3 --version #检查pip是否安装成功 安装mkdocs12# pip3 install mkdocs #注意以root权限安装# mkdocs --version #检查是否安装成功 使用12$ mkdocs new test #创建一个名为test的文件夹,存储代码$ cd test 此时的目录结构 1234test/ ├── docs/ #存放markdown文档 │ └── index.md #主页 └── mkdocs.yml #配置文件 1$ mkdocs serve #开启内建服务器 在浏览器中输入127.0.0.1:8000预览,终端键入Ctrl+C关闭服务器 1$ mkdocs build #生成静态网页代码 这时已经生成了site/文件夹,可以将里面的内容部署到网站上了 配置文件site_name: 必须存在,文档主标题名称site_favicon: 图标,存放在docs/文件夹下theme: 主题样式例如: 12345theme: name: 'material' #使用material主题,需要pip安装mkdocs-material language: 'zh' #使用中文 feature: tabs: true #使用上方tab栏（可改为false） 目录结构123nav: - 'Index': index.md - 'About': about.md 扩展执行$ pip3 install pymdown-extensions安装扩展包 12345markdown_extensions: - admonition #支持注解 - codehilite: #代码块高亮 linenums: true #代码块显示行号 - pymdownx.tasklist #支持任务列表 !!! warning “注意” 一定要事先安装好扩展，否则不能出现预期效果 参考MkDocs中文文档MkDocs官方文档cyent的教程","link":"/p/ce42b873.html"}],"tags":[{"name":"Cpp","slug":"Cpp","link":"/tags/Cpp/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Haskell","slug":"Haskell","link":"/tags/Haskell/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"mkdocs","slug":"mkdocs","link":"/tags/mkdocs/"},{"name":"manim","slug":"manim","link":"/tags/manim/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"NOIp","slug":"NOIp","link":"/tags/NOIp/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"CSP-S","slug":"CSP-S","link":"/tags/CSP-S/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"范畴论","slug":"范畴论","link":"/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"},{"name":"莫队","slug":"莫队","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"Luogu","slug":"Luogu","link":"/tags/Luogu/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"差分约束","slug":"差分约束","link":"/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"dsu on tree","slug":"dsu-on-tree","link":"/tags/dsu-on-tree/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"左偏树","slug":"左偏树","link":"/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","link":"/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"最大流","slug":"最大流","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"SPOJ","slug":"SPOJ","link":"/tags/SPOJ/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"categories":[{"name":"C++算法","slug":"C-算法","link":"/categories/C-%E7%AE%97%E6%B3%95/"},{"name":"manim","slug":"manim","link":"/categories/manim/"},{"name":"游记","slug":"游记","link":"/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"笔记","slug":"manim/笔记","link":"/categories/manim/%E7%AC%94%E8%AE%B0/"},{"name":"笔记","slug":"C-算法/笔记","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"C-算法/笔记/数据结构","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"C-算法/笔记/图论","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"},{"name":"网络流24题","slug":"题解/网络流24题","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"}]}