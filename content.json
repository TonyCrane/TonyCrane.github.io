{"pages":[{"title":"关于","text":".intro { text-align: center; font-weight: bold } .intro a { color:var(--font-color)!important } .intro a:hover { text-decoration: underline } .intro p { line-height: 1.75 } (｡･∀･)ﾉﾞZJUer | 哔哩哔哩up主鹤翔万里 | AAAer 3b1b/manim项目Collaboratormanim-kindergarten组织Maintainer INFJ-T | HUFFLEPUFFVSCode 重度使用 | Python/C++YOASOBI | 橙星 | 花谱 | 诺兰 | 新海诚 咕咕咕～～～！！这里应该也不常更新_(:з」∠)_但希望你能喜欢(～￣▽￣)～ 历史记录 这里是B站up主鹤翔万里的个人博客高考结束，hexo重新配置，恢复更新主要记录一些学习过程中遇到的技术问题解决办法 于`2021.6.12` 这里是B站up主鹤翔万里的个人博客同时也是3b1b/manim项目的Collaborator，manim-kindergarten组织的Maintainer正在高考备考，没有更新这段时间由于hexo环境的问题，博客没有更新 于`2020.9.30` 这里是B站up主鹤翔万里的个人博客目前已经信竞退役，在B站制作一些manim教程和科普视频这段时间由于hexo环境的问题，博客没有更新 于`2020.6.21` 这里是B站up主鹤翔万里的个人博客现在还是一名$JL$的$OIer$,这个博客目前主要堆放了我学习$OI$算法时的笔记和一些题解还可能有一些乱七八糟的文章(比如游记,做视频的经验之类的)‍ _(:3」∠)_总之,非常感谢您能够来到这里,一起加油‍吧(〜￣△￣)〜 于`2020.4.27` 本博客于 2019.1.9 首次开通于 2019.3.10 更新至Hexo本博客主要记载一些经验和算法模板(C++) 于`2019.3.10`","link":"/about/index.html"},{"title":"C++算法(OI)","text":"基础算法深度优先搜索广度优先搜索动态规划&emsp;背包问题 数论欧拉线性筛大整数类 数据结构堆并查集标准模板库STL树状数组 字符串算法字符串哈希哈希表KMP算法 图论算法链式前向星存储图图的遍历欧拉回路 最小生成树PrimKruskal 最短路径DijkstraSPFAFloyd","link":"/algorithms/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"友链","text":"","link":"/friends/index.html"},{"title":"Oct, 2021","text":"e1fa201b2d31525bf9f1e5c19d32d0972c907596765b0eac77f58cdd3eed557c1458fc94dc9504ad0cd5bbf23c62bfbb95138f0e18782c3c668818ca370f300a7f70b9bb3e51de3c674a0e618dfe9a6141ca2d5927615430c498b998fa12d26101375fffe94ef9b701e4bc55febe75e4b99e28ea76f2853f627b77eb564a40b4071a38a614d631503107320530be978f6efc594360499cc3f89f0fd1aacf1dff8dd051c854146422d5e0da21d7a86686617e4599ff1129034789f7396545b64ea15204fcb6e17c5897ac939684ee95828d33d35001b9677ae7cdf82ee3cc501d4d9212263d0912c0219499f14c53b3017c8d457af112a08f15d78611255ed1597f07a170708a31942e1e8e751bbbae94c0e58322856772159e6a536947c8fef9d877465b8d268923c21b211ea1db04c1f96471d94231b18f5c2ecb3df1661c94db664eddcd132dd8ecab015cdd2e1f5b18e0c88176a22fa8c3e8c6be8cc813c06604c5ea071a19c8be210fabd54c8feb8a04dd0975752a9306863a9abdc6e989b03d83d69dc52b26b5e3023e37392d52379db3d16ee19c8229a8996ac1fccda696832988aeedf0a25901ee3866e32d138e2aae9943726e4272d7d0e654a1739a215dbbb3370c09ee30820f10c7e791c9da3ad64b414d5b0537fb6ff94d44b19c11aed9ec033fef3bc14e83864a674153af5ccf73e64cfc6201443a32e2a8b510bb9953dc6a5c0ede365238c354fdb313318100051e8d48a1505a3b1424bf03d7e4a1e51e1aee09a39c4fdc06599275d8ed2c022f5fe445c2e1daa9f20343c4defa471e3b16b43ceeee9fa5cfd38f1d7ba5f01cc8c2d1fbde7d2712633959199e09339878676ec561283ec92db96c61c8e8a0887c2c6a3f40c6bbe58ed8e4efdbd416ac6466b042405fdf2b7e708e589a4f39af6fbe346d17615a090dc53d070fe5a145024dd1f2d105fcf12d0cb509b69e0c02d14f3946b20a6e5da16adf7d3e82ce331ced11d5e10c160c1efbfc6c4e99c95fb0cc90d7a19fa6a2ae89c7021071ba1f386212a8d4648cb31e6a57ec14e8482e297b2a6948599555110e332f00c9981b7afeb04dac16d1043007018dc8b7e2c9764085e9e0a477d9a79fe1d9864a86e0b79edb8817b22a68d04c2938335e4a8b422b2de377dd3a4b44cab916bb8536c7a257153384da144398a55adc91507bc5ff0112b631a4a1a429ecbd749d0f92c9c48975c1fb4bcb493f89631e0995f42aa77bfa8014ecff3d0241d3162862b8553b935f0fa659cd1c2d22fde7f4372c727a6f7798e9232d1c08f3f0f7d34de0ffe22b51bb0461e18cf15e140f907f281b09d6cb6cf406300fcc6a2ff717e47227bd688cac3ec029152e56fe8b62a62b6ca037c6c835592e1e37df77a125c6ad34216cbdd7a4770f0bc4d37a81d09a2318f705d3757a65b6a9b07996acf5affa814ef3548d8055ffee1a8a4c3c9657b96a3b43f7a9e53b81f3a0bb942131987df362185279026fcf06c78bad548b8239ffb2cda4e880da3ccca648b147808834e39bcb5365365c4117468a1dc43e3dce1ed44dedfe9ef6eef225c112f7ee2dc1261c74fecaee7831e0618153fe09dbed85d547b8d0cf8733b201b3ed14731bdf3727325b12bf8721a0871bbb5cce3a0df6a5ea1b9e519ecf6126310dbf7d85f613812d2300294c721b04406b00c2b168b3b95a338973e009ed0445eb11deee13c07ac89f6d979623c5e8d862370b40f2b30ad5edfc022ef9df945aa8f69f46fc78c5e32ed7f2ec046d94e51e36a93d70b9630ebc12cd2b22023f19a740f0560de5fb169efca7a0b15ad0ef83920c0a70d1e62203c3c46a828c49b2c8bb08d3a0700b9ae3721b70b2f1a2f2c8feb0babf640ef4a874fd35128b46ede6f85fc1cf4c0c0f4842c3b2c24d6b453e92a8de82e67cde34d6c9c58d1c7ec168c82aa6dee565dcecd62134e7b9f38e0feb03c2670b2f1b367a59f34728142763b393c665f20dd35e264922db62af61c197f6e01c6f8a8f4e0cbd331990a3a65d9ba15b8accbfccca620605c5ed0f6a04fa2dd2fc729b43f77afc1c2b2b45ac56a3f6cad6b28c681d6678e6c7fd0504e6256b504d2f20ea9ec3e50d415e1029b75930f1edd01b2baff089f6efc7c794a0ef0b8467949a92415fc115c13f3341b90c09d8804847e57f0db20e9f3d29a787cdab95681900c26a3675146e468680901c0bc89f2a75c684be62ddfdd4506a89f3fc9cbd8837c6aef40e37b56899a4a129e4e15b2e1e55fdc928fc9f23eaf7a3063ce14d644b2552bb0d21e8acee3c535459ef87dab16acc86ff833cb20017f6033e8ee23c214a6b55bea01a764690e02bdf16882ec7971bd58121dc9dabd80708b27f1095d22d53758dbf54e2c423ce11382982dbc79041d971a8a712e58e5594b2cbf2edc2335e30eb27df6fda641af86e14a4adc6e2ff33d8752bb8b3744fa9383c2e8e2d7c101bb984f5f580d53c116797c05353d820c9b44e37cb30f762c5848de45674a8cd718b35183cb296a04f3195700d023e1c55c74429d46abfbcfd3b9adf4f6bb70838a271a8cc854df9e5a266fcb99d79b25d012577f9786822ad4b5d6401b75e67121b2d391cdb6e8b3096486110f4be065dfc1121cd676f5262a1985a05427da5b3b3a0e34b279743cbca06350ca29f9f2e819683d23c23d4453cfc4d9e9202be51960b717b5059347c2a61b91e69373f42364b1a234d99cee8bec030523d65a00eececd9f682b790d7e18bc2064cffab23322b8644e070299c7e1e69d4f6b4f999d8044ada0ab2452b6d020182e22ddeaddf9a0b0d71a8bc7751b7a785766549835130a70ced62d80811ce72f4c4d0b6232814a8dbb9433843b284db918543a088c0463872dc9cb539831a146450ce96ba348c8665180c50f82326ae8d5e2a553bf938ff80b8ae6b5ab0716c4af4f34944a4497a13f32c39b19f563ecee46d1a4ad069faffc4773de67a0c3abe3cf147c5a44fe9304fe49edf23c76ac41402ebcd56c6d77f14e6ba79a745d09186ffbd5a1579b60a176680ee28e1fa189e3c413b8f840a32efa40fd273ea8e5c415640691af118913d500655d154c888fed8681a7628c78a60e60b44c521d321d0f8b288cbaba273729d72cc548d29848b9ecad9e6b839a58f35c357d2a35d627590369591b27f3914a9dda4a5ff76dda3e10d74e20124cc2bfaafbec8b1be86dba37b00e4a684dfd4fa2276380838e3de6430dc9e46906b0ac2df0da398b9a45d7c2fd099b724d029c725086b48ce48f1a489ce89f213d4ac562d901e4a9607962132036c07209df1d5b65387a5ba88398ac34f0ce231220caef4e9d26c5be735e2a643a71370cc8289bc57bfcdb1e9bd234b24ebd1a7ffdb0d4d568b033e73b5e0c5464f5a7ac4d7801814209290869047b38361e527b8c399656ae62e586a80980a05c818477a7d13dc689df265ac1c32162871a568ecbd5f3631fa1f1a53d06ca8adcf19135defedeef3574355449ea065190e48d0e873a67db3b37f6a2fc9d914aa4b9af5adcc626df8da96d958160914b952b817636644b66e45368d479e303126058ad9bb4439870125fef273bdbbe1ad47e354c07fcd2a06cf7366a8eaacec7347668939f6ef6389b9ee2f2d2beb972b180fe1c1a29f8d6e15b749a9fa53a535be783dc9f6e3f7963d6477d612bb6a8ffb554dc069af3158a0c78fb51fe013bc390c4cfb07ae4da2858a33f44abfcf548d4b29b34314743155a03f355c78ced141f69e4d1de0936d68271a5ae292698fd59be4628df149a5f5b3bcea6133e908623670f1374062a25a719f91e72b13a8889f5d2ba14f336c0bdd08daf0c428032d4162a1a7694d4657f372854def8b3339aff203e7de02e7213e51a455a891122f6f534d906bd44c87626bbc322770a275d1dee6573207d96704213135e311ab28443ce0fd36c1805f93ad6566194e76b130ef2fb2f4213b527e4a841478d363c65e1a0b7456a8deafbee8e3aa1759bd175a659e592a4edd30200ade9ada9c16d892bd29617e8cf16420b36984467a22c951b1598c12e911c71ee3991bdef00c1953c4b4142d04373f375b436ddd614a9972f5e5899ee40286402c6f55bfb24a64cb39fbff9be040f60ed64f208aa33ae06ff1e38aed975d3ce2c7156e33554c0130db4dc6781fb186eeb88cdc2a903dd8e8dd876389e230362fe0aa605ce36d1ba108d948f49987745b43376e1764faa58d088086bf93df0ca5589670c6bb4da7532747cffa38386c53383ef8ce9f64d755cfe514615e843d76dd5aec0789775084b94b634a1c198b57bd6ed9ce5620c4470244e74631f4a9233fdcc214d8968553b3819134eac7124f9f048eb947b8490f76f3d70961b858bc3e26150c11848a9fc3cfb7e9f9cf74393e53b4cf74e412f0bb36e0ca38d6f8c7e8872f7973c66bd8b92526858a8bfa2412e2308d6f39d8be82c2a6fdc91c6e5441f78ed460119b499263831568e7cf7d052edc0fe12167c575cc317ccc98d750f804d9659c9929b3dd216646d3b0b6d91485a1a333cc304ef8d2ccbeed675f086275cc2f9cc651222c1aa9ba5c2cff7f52f09aee900b535c7af024fd9f009a848f993c5b4abe62286bded005f947fff83cff8627b32f1eddd15339fd2c55892b290de9d6759fb7f073ebb3c7b3bef0d3456a8452705445581e64412a13a0ca412f51c514553ee304a7224a73cacbf18095e4e4acba9f6c85a9459972b66533f36f06fca7573ac3453670cac11a68fd3728578345ae5411ce8e79c0e4b7d3973840175b75e6e88052f98d92f22e8fe4df88fe9d49b08484b83b0bb8ca772dd8135ecf4253f5aedcd81b92d9200926b993af3f5a6f08365621ce2dc4aa2476cf68313248a0a3fda0048e31e836f0886df3a04cee4482a1987fdc427bf1f2bf6463cac9f5ffcabf4d4751b7b7e60a404d2b758ea71616fb524fc15c0a9d5e4241cee150093036e8eca8a60821f5bce7d30075b1d1abf4ee69fbdb452152e9244fba9d36492b61ce5f3b5e6805ee90128e287e88dc70896d3c73f72cb2b6446faafc31655adfb7e7c0e1823f003c2d9d504d6233352cb44e6b655ff35a57ca9ffbb6b48a800675df73b8033c897023ec68b45084a030e99ee1bd35ce73034d6369bc45ecd9f0645e32542fe55f3268d48cfb4de31629ad4a39f770eb250475986272ced6158c00cb653ca594acaa7856e7c3e9a38367d2d2749f93a834f05c6f26237b983a738b19206fd783b5cab34b196644d2dcd7ae305b334601b51d6c39a37ad6ac995ddd003aa9e948a3f71e924838e43de834cdbd851b44b8286d625fb1368304bedef096990e420f66adbebdd4b153c2ed409cc1fcc786bf3d72176d7fe0d234603c3d1c0c8aa93fda5b6efecb97c3b1f76db811c2da9d6906d0d31d185cb131dc0a33e82f4af9fcc9a4fe6fff4044b96853654aaa0fe8c60421d2ff1ef1b5402ea23a30d4a45a846451baaaa618c51d8b6421933d48be1dde1ff8e2e8de8be81b4644beffa70fb62e149df443684a6896c44b7b771db914eaaf01c1e40f6a6cb5c843c1c599ef0e8311efa359413f941dad905c323a7d7486a159f919e080c97ca89f07a2ecd72587cb2dfa9555b001b08395f94e413fab2e88610cdf0f6917c2c84bf48a3a809da72781cff6c5a1c068f899d7ee8ff55cd241a9d9431ccb751322171932ca784548d6caee5b32bf9fee6eea10e3e055c386cd680f866b88f808aeee49e633b88ffac4458b2e15c3e34dc71a5630ffa2701cc62f66a42c2b24a2a638fa04e63be06755b09d26bdc617deb3b6acbcc8dcfb62cdd832d81538a6327969f81445326c65be15ec071ff9f539a9e01679a15d5e98636c15d017f3ea4ead3ba3eb1abff78bbd3712b6c5dbf4ffc793b9673b085a347c282cd630d416cc85b290571e9c9ca6655df6416328e68f4ba802998e676865420094192e8b3cda7f13c11330d1ae301f5eaf617372e6899f8a59e35e08e56577b69862bdd84388ae6226815df261ca5105d77d8e7745b0d3a23273350e120e58c17d6d8c623142dc3c80b8caf9a9f9f275937d1321ec9c261aa640597cad3171ca3a9492f886733fca37e8531c38d9b5fa9b689b1361801409524b838459b6d886289df67321d861c0fa8595bbef44252995f1b5cc8ba0683537ff5a9847dfd7102cfca358609d182535a974b850e789d1903efe2b2fb670e0d61ecd3596a44a47318dd66863fcd101772760f7d27516776bfdd6de3776a819c24185f81063b79fdbbc1898c0e3571019f72c53b4d0f033df6310615d897ca01cc26ee6c46855e8d261b3b8eaad426f536e888482c69674f4ba871d69ca8567bb30f19716d267fe753e43758c91c08820ae7796665033085308e6544c491e6ae6b709a7ad2a180942edd836e93378b79ae1dff6785f412217776a1ca65d9922db7442e463f0cb9dd40dbde430dd0bf54b6c83a74f950a092e87b0ad11f7fa1593d416f1fc56c32a01c1436e928fa0eef24544c649a203ec0488bf3c1c6eedafa35356849752cb09c0a57a895f281ed639a9a87bd8510741e633b40078ab39ad98979069e1ea586e6fc421093626f06fc3314a2b1b7f7c1f169049ecccc46097f218cb510a32a5e5ee9fa367d1fae79d3f74ffe4be94ff5a336179b593e4840783565e3708ecc264c69313e6749d559a6b4ce08745ce05ea8116467ed5437730f9c178fbde2483424be6fceaa49fc7bcd4b68fc18a63140dd0c1ca45bcf5d7a62dafade1950413b61cb94587756ea5362de32e387b29e613cdafe288651fe00a4dcb548335f8a35549c0ca472575f41e7ba196fa468bd6bf52f56115e8c5e37e6936736fa62f131dc0ed3295586122aa907d8510e047f8dbb18bf2a09876e4189bf61978896d41787ee7a221ae5525f7974163a00aeda509c6ab454f96e4fb9c257f1b59e7629badad54882991f5d363afb916aee0739123ede15a5290fc95f3dab28539e258caf9ebede416bc7792b4e36700ba44f187c86dbd1efa2aa33e042b827a0d5beabd0821c3023ec46763f809b12d5e28aafeb767efc572cdd6d25527f56adcc7c3d798ba903f448242117cd323ebd2a3fbeb1af52ee84b23d818450da7c4432cb337dbf94b15d70e1145193a464184bbcbeb5404fb4a7d925af2705fe21c6c68d6d95fbc79be5c933f4354201330285bade2cf536fbd316d6c3741bfbb67e32d924453485f3c18e77031f889b5b98be15d807f0ff429adf81dba9fc7a3c79f8b7d2e5dc1131d04222738ba253bc83991e3248cceb73b6669059de548c852c523cafea31b81c489ef77c0297cb6d75c0c62286430b7bf55ef9c22845f3e640fba891696a446df85cb3fbceb9e9d4354eb42595030174b42a99d9aa58de455126316f969bec2eb3c5d9d8be9be3c782adceea432f8bc63f2279aaf838b6136092455ef0c531b5d074391f662adc2726d8427af0b5ab760d77988d02940936f0ed5a1504126549717709fc7574dd82e8a202551d21a72b1ca2e13e67e30afdee4e3be21570df0935df9702beeb3e99afab1dda96827eba9b45203becb5310768ee5be713b91a6c83ac616283055719ae18971374db9550cdd263235faac2f212de6456869744a2bbc3fa24a1d8c7d21654cba08927a1cb1f4cbf1c50a8b356ad1d10c957da4acdbff70a0cbf995944ca52e6faec1fefdbdc3fa7b285edfa18328ee80468bd08d257c11aedfd2b3b38c7b36efb0244b5eb8cf7805603fc018c095575a72b62b812bda166c4a3d72e75c6e241a130d2b7e62395673994194dea85bcfe1ffd2fc75cc6461d36a6a3761d20a10d04ecf3a170e6989518f21789ff582490dee79aa154a989e436e7a49e0de5f7638a70e98bbd1551e2e9ad66592a2480575c2eded4c2d776c74336c6ca7b2fbe5ae43b18a5ecae9dd153298251608e617d16bd9f908cb0e726559111264e09644ff78bf1f32df9dd1cd5e976aa3b6f0443081504ff488e8263df3041f69572d58872b2b1e9bad22fc892bb919476fa5d25d85829595beb26a23342f383a39a417cd772844ee05fe7faf1a6080d35a65d2ba4d08164366143f55e61b5b7d83c7ce4732e21f5ef4e40111d08a8e477e156a0e199fce806d8bb343ca7d1324f80a5907abec2c09bd8b2568e4d4a5406dd3b328be95a27f3d0723f78a8b38c65144ca20d0be4522c96aca4e115f71af42144e0288b955cf908fdc9a356067c13bf1f5a1f21f0b316bfb42a5bacb4d952f4445e1db9732b9f8c8aa5ed1b64ba7da5403feeb163759d5c94fc9e243ceca4ab65f9650da00ee53afccabc323959316024d49180fc28c187e561c6797ee681a1d31ae5cdfbcaef2845e231c0df18ab9a5d52d359fb8faf44acb0e6ca09e0a38949401241dd0f134d86624cb829494c47f39e64497e2da9f32d21da6a389347b60d1c383117461bb5798aa2dfd5bb7de2887381971c22f7b9d15ee99f4d1b7f3a5f9a3a6954299a0b1f0f29d3ae71083fc90a5e5af8a48d45710f73066f6f7f9290a8bc826b70fe9a683515e55521a82d3212ba60e855cc9e19ff3d9f894c170bafbbd706152ba6b62ad0ed11ea28854ed5378da1c83229656e56ac8c37d65c9c30feeb5acedf9762560e2af9755ed604cb40cc3c37941b87098b29c728f11cb4e6e27a63935d6fa8b616fa62bd9c26a02d442e1f1b6df6b66a7861ec8f5faa59d2f941f847466bf561aef3ae4124a62e9f8394c83532b3840d54a3fa6e1e082cf799d62d7db7ad3fa3bbf26640b88afca31800f344505ba0886095f52066aa19e405acd7f3b1208791587ca2496bb2df269e978591444581224e6fae54ce3fc9b3a15eefbff40f51d623910fc274fe22a21bc20f3bf101764f520f58dece515f91c2e39395195bfba6e43fc7526e32f32d250f85952f25bfd3ebce4bac2f35e60d39cb94bbfc61598667d2f879d8be0f67b96703b161d49978ca730c6734e948dde3efcff2c9139c88d4abfe6d633eb13c8a434aa4dc780f1067615b4ef44f8960d90cc3ad0a8e2f2e150ed51d406f5f02ab41984a0870634ccb3c8d04cf7a9619677e43979a032b74b8716e772a308161823837b828cae1adbdd1799d628c580497022d536e23c202a8c8c29791d8c50b771616ef86671586c6cff2ae945167e4369262cda013a4b5637ed95f4b5aea3ca8b9b230892392123a717055c020804fd1ca059b57c2fca0106692bfc2faf233af5b3205dbbc13d14b567603cc122ae8bb1c245dc2ca145a19ba21a3ea218bfebe9c0052a84f9b5b6e9f9b133fff89e275a6197ecd8d210c74e012e4fb8091d9905852be27fd4b5125df271fdf6f7abb2ccb9023dd1176301d39cb87e0a007c54ab2ef9bb58eb06ef2076b7ffd69034dfb50b81f5cd1941690a9270aebc77397fd6dd8a7dd9538876fd1eb14cc32246bdc0102fa09e60d2418e34170b709b408373751dfd7b255c38102a60d0436f4340749b90afac787fed6304bac479434158ee47db8812ba0ffa1ceaf1655d1598fc7a15502ec240d35d06de860bad247a64eeaf935db1cef68fe3795f92a323c0d3278bec71827b007d523672c73853a8931ce0c25b9ee1963e9efa75b1ad1df1d5a65939503a0afcf7dd9785cc8412bf5f72cbb3f405f6990b74fcd865d63869f526018a33b957ee26bdcd341d8e7fc68370af301cc6b305f6bfb0cceca008aac85097721cb119c649e59cc6f01ebebc9c8c6fe33eaa433cc52fb2846cf1179ac2701247195115ffc8a4e77635660ebf278516798f66a313ae6e3f4419a0997eda2cec895b8c4966e208c66775b8881b73f2c113bd945cb208f65dbc41189a09b8b1c97a669908897be2865890af3270b4957c28fa2432e54bcc5d4a0f864436b48a5860af13a71d6485820125125c1738001f90f8b1168fd89f9db2fe24a5cdf5aae40c491d7d3f8360d81f9e378737a99fbb240e4f2f4d98663e4e54daae731ad671b2d66f371294cf56c8ccd4526db42145eaffaf92f35d472d4027afd7758fc59c2ef594f68ccea148564660ef87fe3d3e717e657ad24c2e2cec62f8e4bf28b89e3ec9021f87566dfadac69d111425afe9ac22418d79e60230fa9137cf832e15df21b1b9da9357743c6e92acc8ca7c2f6375ce07f27e79a583ec16c2ea6a5b5c93120de8f67b64f7a3f24c5968a647e2a222a15ff7f2877e184093e600c1a141ba08001497fce3888b168e98ba3eb27bd91df5440872157a25dc1378e4ac14c5ad3f649d7171bc85fdb7176bd3a1e0cffb6bb7fb3f0a675a647b9723e5f18491a5114a7d7cd3c04ce5fc5658ba1e9c914d04657112f2841e7d0142c803f52f2b918a773c3abe034b6cc5c3a6e95bf14a87236d5dda45c0014e1b9ada92a116e2a303ca7477200d68270f6be748c7c0312fe998a727074990b576a48d0f8ed9e8aed02b16bd360acb152ebde717d6a5e7d2e85b2e73439e7b6385a1892565465d173e5d48b383bf19ae233b4d70b62df0a10b66c9af577a39765bd8140465aa45339ca406507ebcbadc18992528ec41f40b4710f9035e769231ff2ccb08ac50df259f4c6d94a870aaa9b93d9a3099116be3ba26e55532933e6d63ee336019f80e7eb076ec102a9143e5045da5e08becefb72cb3601036863dc2f6779aabf10310b443ae9be3489b2cae3cdef3369ba84e908e121bb48694bd30b04edc8aab74ad5814ea1ff2043a9bf86f9ed0c0ec7356798ba4001e5e059a509aea085ec35dd57155cfcd18778bc499d49a4607dbd813d2833416c53180ac15508c5642d290861ebdf9d2c39bf845be723b156e5b752ab5f2c032936f7ef72e764671a1ca09c883186021f80ccbbad1f7dcd1a8d4b2af958ca618ec7db340602a18e37783221bd7f3978bbc4e8c36b0cd300cff162ad241da220c326ce6487ae5c14c23aad14dc4bbcb504e6c17d4fea3163c47f7a830a1f0f10e03e300e66a259aae8f52a3c9cfb9c75c20b4a88f3f961afe98612bf793da03ca1e4034a2a9020ccbb0dd9b11b53e3a119cda9517545b8199c09323bc7d66077382661a4aa22d5a6c8ce0729786f058fdef92f903b71d639d39546b668e54b30e25cd6eeec77106e26cf34b3995836c30a8c9df6d303af464d7f6b04a1126c1a74ae0c3e4bb27685b66680bc07df4154b5d5742342316faaa87f42e682e61e08cff8246a17711c05e26abdfb24701424fddddfe9aaaae48d25fd6c421d6008de9abb309c7541318effad58ba2879dfba75637f8cefc3609e1bb62ad393c619f6dfdb8b85c24480a8dbc6c2f9b2b3198a440adb36348788eb988d93f9a47cd41a389019dacac4524f3da6323ecd7771d260811ccf14a3ee3d80758a5a12e08db9440a5a954ec5d765f2d197b5a9c36d8b968c28ea2862602ad55357bfa84660d76fe7f075ffc0ac23e4d19f6427352b79676895e5dd870bad0aa4dd90daec68837979e884c497fcd948dc1e72504ca3cf8e034cf4e72a14690c4541ff181d54e19fadd60055af23e8250b1bb1d65c7a53339387c459e5dbfc6f6f92dff111f56cb524c0bd5f1c44686c20b8caa1fb106578c96da9045aa0e2ae239ac80bc8b48ec2406c432581fb081ebc55201d9c857665a4908240e2d64f488f24531536daf249c5c3ab36eb398c18a03c240233b7b30c3a4ad4d766f2c5e928a54ae94046a47f89f00baa57b6958e6145211363501636beadb6afba20003c9614047d38a050922c8bee7ae07289adec57cca9586df8a00b29f911e6630e0ae27e61d69c3506342a6f431042cb3a521dfd874022db486fafbe66aebbb27e38f6e16a0655d8362d44294769419b21bdade50c34cc39ea9830e48431300401d78eb9143c00aea40f351c9e05d823286829111c196c2e9e9c4bb1879e427f4dec67acf8c899e7bcd4e7361f1254641d14b5af314a283fc495f3d84fb21a6489bbc506cc539716e8023f4884e7fa227a97e5e0c4d1ca6c589be55c470344fb3a1b54982ae12caae14ec027ac9f5f721f544887d1f7760ed7fd6a569a808f652707f75a9e09bfc8bd303556178b667de63a494bd9943c242211564dd2d8d87ca1f2151bf5330311aafd6ab50a6e209dc327cb62be9cf63017a9cd65796eead7480c551a32883d2d3aed5989527515c1762d8cfb340ba1f4fa2e6dd8ebf4eb3e629a22987e55b6fb34aa896716b70e3284fa12ebe5e86c40aa63a5775ff0b7c705730f79f62f4276e0e48a34ca0fc481a17fdc3d91660a89447d1f9eb8d9412d3c669eb92e3615c7bf59dd121203e28b0606343ca3a131e512430a73d1dff617b0990f194329b3cbb0ec3d3e6d87d54a8bb77a5869a4eab56c17c83928814440d78a7b03f4c5747fd18de1c23d204ee649d034e0c999fe5c44b708e02c0dd938f9316b80f06801b30d982fa78aacbc97d5f968bdfd6a6af4eb7efb6ba650b770da5e5db9a3e2959b19a398e9cb5eaa9b3bf95904410db530617887bf39a9b641ec0220879be5465e5598fe98ce9b6b326388879cedb9f178871e0a30c72dfb7f0df3e3f1fb35c1cf17933c26df7caf287a15096f0cfb87505dca2efbae82236e2aecfbf94783ec84268b344e87fe6cdc9ad2ee3768a6340b097a2c24574162f0ed38343af6245d0ce3fcae36afa6e988b8a63a4615dc98126be451a729884e6f46d2c22b27d396c2c31954e0dc697a578a7ec3321a29afda6cb1a7bdb9bae5d2451fcc0f34cfa10fc2f2a9380bbec8b62eab0cd24d88406fed238e7b77fb7367406dc757ba43f024ee607cc8c58b82ce65f8cfe3570733c45694875037152a335d9f0d0fa4ccdf3ed1e9e7407e58a8b17c87704740c77be5273ac0246caee9f54679cc87b96beadfe3f4cf0280ddbd72e890d3ff8ef2ade416523daf3b61a068421c7eeb082d82e5b1a0971c1af3b9d54f18bb5d8dd95bff2e69e911d8cd49b0a69a10687f46b918b781bd0c57a39fb0fc87c8a56c58e9675694eac681ac3c94f6529575ab5f44cbf1b3a704bab54e0b3a328b3a589186cdb0b5cb62c0663de859a3847da46c79c0a8bb7566d8c33f9d91f29cb7da206831e0b20c56ec52a81c5bd471135582e5e7e56fa28f12d2d1f8a41a639ff7cd8d22bd6a61b3642742a4613e19421a21a9b39372ad558fac0d126fab1048c8911230410a5fcc9f0180595f993cdc92fe453aabf257391a407b768d12b050a1ea4ed190cc2d3ca36675095d9807f870d24f860b2d65a1fa7a39a46509372a59b308f3a86a11700b66c6da65607577aa7f407f17ebad87ceab77b082148cd59c105bfbc6479bd7b497dab232e6c7235cb0637fe173c61618b1a0f69379438990719623a2f2324ea18fff71f02d1f8dcdbd4a55068cf9afb83d5a752b0afa732e97a99ecfab6637668830a96afe4c44973b3b5a9f64c5391f53cc72db69268975468397395fe2546021c543fe9ee24a2e6320d8a2a194f054ace70dac66895b507a72e4ede45fbe507c0ae5569d608346b42b094b200658b84f7cc5ad7eba8a375c314e4ca695d40519308ac282fb7e732283c02e45a4b5ca27ae5994db6608cd32698670b0156352df0dd57d230535ec4c4598f2e5d17579ee1b658419513727d19e6181ce478fd9ecbdb569831c8f54bb1d7addb7c0adddf18d5729f569e462a37062215894ed788c49ee8231ff2477664537fa272053c83f54ab3b8fbde1ca3f1c700d3e9e0a1bd9a4da6696572976a6240b843e4366fcac25d236e02e4d2b1fe33c2b752931c216bff559d9b68cbc76c03f39c240ffbed046865c2fbb60bbcc56dbf76f2a99cd5e090db89bf2e0fa9899c4839dc74515958730da97f4c602b9bf8a79f0436d67e861cbab18170037421fc5be1f285efff66af4fd897871c324156f589c72e806123df8954aa78bfba1e644263ff44b5ca006f6f65ecc2bb10f696fa1e17295f320d5a3dfa19526910b452e71756169d73e74110551ab0bf980fed6c3f53ecdce005513027e7f3375c28a3e1c4d880d0732d6cd484a76ca1331536dd909f77d22372c548e656c22b7479345bf07f245d86a7f0c72e6d3c11ed088af1c8f0f268733743ceb924b53d9d8620a70344a460614dfd2f1117407b6e70c597d26ee4dbd6c964626affa0b0be0d3201c5974fbc2670f939cb9c74ed85043ff71193ad31b58809db1f6aee3550ac42403fe9bbb6f18d0fa1acdb6a6da6729385eac0106be375973ab51433bd408955cf59e827f096fee3ca38101ff2fecb9a0e7c8cea526367fb31b355aa947fdb03edcf0eb0e49a39fc1af50124397f03e0f3a09c12f833175a075fa2357eb224ec6e3f3e4ef081750e7a2c5684b90b5b64fd33aa69b4579ea792a6d5313388667bc5c787aa7872fd3ea0a656ff24ce3a256644cf02cbe0e57c3e6b5a39cd722ea79142aabd82cf22dd89ae682705f325b4a71a663207e34092c7647c2d714e997ad0edf0cfb0bcefabbe31a017954712536bd07028eb91d71c54381a304a722167e3aac3a724ffccbc27214c818ab7c946aff93c7b9abbad50c3577545c70bd36665b3a7b3d6a78d4510fedfc840aa58c2052a03464fd71ddbaafb6c6161698c506996d1826439e333704ee9e584b004f5664233e20c1e4f75eccd70b0957d1ebf1ac616f0aaec0a68d7769704dd7decac6d1f260a0e6f760f13915dbff9786280c45030f380f43e7a8276adcf075b3c3d16ac9647d2ce1bc206c65896252792d638000b6189d6df98f1d1948c7a31938d843715841236e44589a4431335a82867a343e11b890b0a5f7a8e19d2d0ad28a5991db69122c542366ffbd42e9acd769b2ef555adb2f720f38e0d69fb4473a0353a577b02db16167674503688501b3dd858a5ab330548f3c175501b0e8f7ddf611355cbf24184d4d04ab1d1a024fce11b62a6a429a3e618896fc15a0a6df591b428e9f951ee8d66c2a57970b0dd928f9ba5f467b451e07076c15ee22bb2675293088b4a969c7bf40fa80231753a3bbe891c2bd8d31a09f8d49067eba4048cb0ecafcb5b38107d1024f12fe7226267ee9640a54ceddcd955510a7281a989f0899572104383448c83195cd0b0e2b2acc5cdece0af831f8c4a1b42ea0af0658ed75c0f7e809e6ae0599296476d4b54bb0e56abb89833756a722e802bfab6461502100ce88e3402c811190b7f177d4e25988f4f961b4bc68d2860c16579dfbbb3d2e70a3b94daef870bf5a3d71a7787242e53342c7e003f37a5e56f1620840b4b411ae04de3286ad3a87259ffde31eb597cd5bbc52bc21b1e66568ffc4be1376086106bf07fffdd868bf4f1621582effbc809b064cea78fcad2085e63dd2d48c81e05985623dc79a424034cc5d7d36b8bc03047bd8aec1220e56c864984ab1233a250430fd9b3b776f68a47349fb3ee4dfccf5015905c09e8000fee13a16ce84764d168ffa8b187e32dcb9d60194e5acd6df048505950670eacf651d600c3e7b62a40fb97f039713942f9e341a3bf903da5c266bc34412e959aa230bc49e053d1d61cdea6d8b6dd624b33114f43537a0c2d701b538975017fc8e6397150370b2457b0ddc5e008048cf288db21c91d1c4fece18b60bddc840b370d7c14ba5032236cd3d0679f64f033b2fe1657e40d9136102d892cd9152e8f72f657b4dee5c7fe50dd3ad73c0646ef3450d3ac03abac0809f870fbb64a5cec6cdf29db8b9cc617a2b81254cb0afb460b3508bbc93e1d73dfaf2980e56f7380cad569343e64b58db6fb742f0551ea5443a4a4329af791318858c4d9ea0be4f0b4680ce32bac9becd672b3aeb4620852d48292894fbdd0aec672a2e64f8bf273a15be995edfb9a60e56f88920c815173c503373f4cf0030b15a25b8301649d3e6cf48f6c8c37e04424f453fcb2958aff2b2588743cc9d6f95024bf1c89308e174ceb2172f7585a89f5f01651b4c79c46a509853170fc1db13b435a47b2fba9c22ac4d81698a5b1c64af859e996b23d48959bc24d8f798e2c79dd5db532f48c0d53fd60582aa481efaf3e27b2125a6c124a24e7569def611cac099ddca8f497034ea1f77e215507714fd352134999fd3bc86777ed931b3592707c4ed5baa58567453d4a58c760c8f04aed79ef132dcb54b4c0f9e0892dda7e0f1e719646c5523b1fdfcfb8d12ece6a0ba59ea2f705069dedf3a678e9db37fa8aa0bc21c931c3f34c2e9bf4b53ed1d36e82727b461e43256c7c104235e481aa2123301efa5c1157a383d3a38021bf73c6fa70e3e5b481f99f78edb5475daaebaa2985e8c74450e47a615466c3f8e8792bc3120745c4b322e2ae7fbad0bd1f4c4a0e9d7b370087dfe79df58c5d49c4bf62d0a0013917ec7b82777742947ae8f0a18584732d6bf9c3247b23a34297c3048a054df4b5a94883563cdb55ad25fc7752aff52defd0e6168b96416b7b2854d4cd04569815ae8263f6b6f9db2d55c18d7d075d20058abef7c69f6b76b4d234ffc9de9b257890fc07ac517641526f9d88b6c3e13eaca202bd3fc4508a4046835546e68b30063e2f176a2c00a0c34c5d66371f69120ce0a12d81951b97286ca802ac3e77b5531d407de153fa51a04f296f0787a9e43fd940f8ded1247a2770f14f541bb0baf1271b1cd262c05b301199c86852060267ec4f7384821076dccecc6e38acb893703f742167a0afe340a9bdfa6ee31b465e18ba77d4b5144e74b96bb8fbe694d8c17ecd0868dfeb65f031f4217551a4c92e5f7f85dc26a4a2bdd93532d10bef90681009aee4cd0f9b46d5d2d34529fa4a0ef09c43dc12a1bf52010c5efc2c703a87d5e2ddaa1fe3ee39ae3067b6029be6b663b1636c875281dcbff5d73b27d620f7eeb2954dfc90286a3e1749cbb4285d90d728f9c13d56b2bf13fe8cff744db14006dd95685616d6d0808dbaab0e846824c51785df89cf84430fdefc78d42eb0dbec4e28c9170589a89df0307b99ebf831128e3ddeac6bcacad9b3ffe1fad2d797ecabc3cdab51fb8ddab04d77d8f4c9d045cf099d43e918b2ecf3564eb378c1047a7428eb5fc84125d1cd21194d7e7af3794132430168fdd22e7d459969154cf330a7dbfeb30a9d45aee3eea566c00da1568c460becf0be38cdbc24928a7ffa0d3f7c95896f112567d56dfc976849de72a6d0f35ba97e629203234e0673a257b30c2188cbf29d3bc7e12b1e7780ae6f1e9e44704027b4b1b5ee9e8b1828ea4caab5b04918e6ddffac3a0aa8fbf6d13495281f42000583c0f3047d94beb810be6585730b68600bab1c6c7e86fdfd6003fd5a14a77789e511677c9f84e10be00420d64b4a9d7d6860c15178afb233ed04e5a5f10b692a466c4ada962b957e156603f4c35e11a691c5f7688d40bfe1e7465b2bbf1bc8f05178607a10e79c8f065190073e3ca78678d6bcae4c8b988909769b710942b1e73cf520d08f79048d92d1e0b5bf6ecbea5082b84b5210eb1babac9bf3f07b27813e65f5008717998be5a2c3f625b4cd8f7a178fd3046ae4ab2c394b89ed516aace6968a51a09dc6996a98baa8b5da2224f5476c30e2280e95f49f3eda50d5a079333dddafd1988357b413aa097d84d3c2c954ef92e1719d570e06dd114f0d47eaa3b4d42de2427c2eca958c04f692084e2e9df13292b5af43189de971250040e276939049d0f6c91fbeedd7aa3356cdfc5d136375ce10f541b9177852da10c7045768fe406e1e5c53e626559579181d68efebd0b62a64dbde738f433bdf1338d509ece0d39dcaa09c4c67c6aff3bb4bc9c93d8045a7afbb9125bbbc74eee17451bed717af9dd95340955fe903c130b88dc790e8204407b1bd6b1ce17bf6d4aead4b498932164ca60936bb297549b2c6767924bd18ac2ae94f7f46667b1a329d346a8ee3811d0eaed06b9cce838c8ac66063af1de1e5b74fdb268a54e0e53b05b011bb5bb3c9e19d361d5289b8049fa572da476780df76328afca14de9581b8e3a4653e90546ad5fa71f0c40cba17428ab563ab269249eec82f749be0462ec32084bbe1d8eb2c21ebba6e6e8d174b40b4c9144449411b161f39f41f514f59476765b9a28f9042a1f6a17ecb801deae3300c1ded9b01b6e5abcbf1d3302e6a775c4d73bd9e7734a24b53af028a6869e3ff4f4aea4cca791758e34681e6548ddf1579b30d096445c3ab66dddf0564cc9e4ddac2b258a384a16e3355dfa7e344380086c98312bf78bfc5d1a3d3241937a90fa53481aa1d179382af84939b62d267486cd2dd97e537b842ccf3b5dcc6c8335515e51917bab13d67345b1cf9f5ecb7c49c851ed3cbd4d2594222e7c76421efbad0b15b07136a24047e1cdf903bce42fecd4d7cd3833040b70589e780d825d1cea2631143a848a894293264ed91ca07040d62acd9f09e5b5a1492b76f07065c71482830e58ce52b49d2becec04abaf6b28b34d3eddc551e1812fd20e3cdb987e512c8998b26b861ad2f92e41cfd49b1165335516ff4ae4bfc9f5cf289da4ed469f1481a837f9cd4099b815a68a92877c635b79d99e7b221030e706153062a5010089581c0cb8dee9adc5c534726cef2ea8a4ea66ec806345f5433d22057eab846ccc6e55b58a1de2aeae92e783f694ac02634cc9897d618b31275a190700d7c72f77a10aaa2b541e5b1c85198a80752025177be7eda9a65650ddbbc2ebc6f0ee9de4893cc821ce31f75c4136498d833a087f42d7ee172d00d6c9449a58f8df702e2edf9c90937a8794d6ac0caa1c0e754c6b625d6dc7461e7249bc7b648b6ba1a89733866d6aa54bf1c41e76c587ebab8b9480e9adc2639524fc9ffef196ae09b05d93f149474431cfb282266b50141a344ec8e73f944c07a25df31c4909142b696a6fbe371bb8374a74d461299a57b9d4eed2dc3128dc0541f7293c4a381b483a133c09f9818a009c6dd942582480f718927b1d834cc4ff60fb68df19e7031adb37989c29ff8348b00751bbaffb868856ab500570b4863043abc264bd9a873a18b0942af51b1440c4318bf46fb3184eb4b065e2c82bec769659e0468aa3f3eec8437337035e1cef85116541dbc37efbd0879a8dfcf98ddadf1938f05888b35bc33e14e1df8d902ceabaa52fab5814ca5698633e6e8ce1688887a8eb978447e9ba661632d54a3f7784c84fb9c7e773dc6d00d5b3d0e3d879f40709303ab32f5e59eccfb9aeb9841e1946dfa6687a32d89da9a14eed26ebc085d0c2ad3e326c0757e337fd211473aef6f1f52a297a7a2a2f898b57c05e2e811688a955cb043be6c582ec5cdb2a4aa920fba591906c857df2be8d8654644da1f4a5ba3225fe3464d72ee6156e3979f4275a5491bffea87f34d580ac388481dcb8c4a9adea19326614b280b06557cda8f0c7ae7b399443f1b993e00604879d0b10226af1160416e0669b8bbff1ccaf06725460ec2d090de9f22982da81c8cd114ca5a6e5b6269d19e94f84c554dc8ca6cafbce7432e3e62961d312e44fdda2a2194ce353090dd11618d55b2d9fa69a4f7fa5ddb56cfd57488e49e3a72129d3fe41cda8338f667595458c28d18429faaba8e17190280350fcb3fee72e8d1b6382c884bc5c5a734d2f4bc2881ec8786ee52761e8526b4e8f18ad95721dad92a288c6e9d109dee374edbfd0eb56f01b5712fc90109056b50da1f48daf95e9935f4e382832cd2f6044ecdb1c7c34274127395787b77576090eac3243bed620f9685c4972631b26e02d9254110fab5374cced1dcc6c8a6aa16813342e1b973d177271b476583e623d23982a6949b216fe1605089441c7b17614cf9c54f629ba241d26e5abea08375b2426eb4fd82024ec97e881eaecf00703803811d428a51b144aaf3f4ea059856b813a8818a9cf0121ca713bde00603f15a3b0a13398d9853764ec2bd19484b85f1bf85bf6073ba78e64f77154922ec8622aed3eb946c26ecec43918f3a703a00de38d843a332faa0b952a17773c4b53760a5f0b5f05c05246cf9851a9657c7683a6fc192c0378658d4c65041d41405bb627b2035fa683cd764070af0cfa4e48a9a0d8db3bef2efe76424732b1856ed407268aab564dfb2dfe434bcf22a0e0f4543c8a6b4e4b830df63cb5dd30f4df7125f7c1488c29c0ae200548a92e0454c009df0cce937aecbb3c18a66cb144ec8cfe943bdee1768872ff619d2ae80c6c136229424815dcdc6d58bfcac5d745b635e3fb80e9a31c6ea7a79b593e60409c0153cf1941bd5567dd0812cc6aaa1a9c607ee4ac3f08a6e593795edd7e65f70b6f2bddd808e414849729631434adef2cec9d6cc530282bb9773bd6996e6b44be42c08ebbcb5ec0a58400bce13253f70edcb23004c8a9386d662212ec049d01dcc3485c8498b7af395946af8f6e86dab6b7d00240de5e31fec2a9eadc0587db4b9eaabed34069338238983906ef411dc06fe7e209971e8c2dc1fd62ace8e9adf603cc772dea77ab7972bcbc1f2ae3ec8a6983d1503d42659e8ab59a966de8774b4bb7cfddd293fa9c9f76714d13d05591a14e3bea4c102bab1fd6c08fef75fdcbf277b83d56524cdbfc739835c7c7203df97eb271b6777a47c3710cccfe309862287020545e5d07e57540b0907b858dd7a67450db733c905f72186d40b1570b40b91af341d12e465fff0b1ac7336ad7601028be96b5104a623cf1b8c0f43e0f838a7d0eea51c18cd3eae5d79716dcebe66ac2e08262be98f62081ba4ebf98ecb91c270648ce608e9451e3d4670f13e27c5c9e85b02b56362baa667359b684ae1cf5031fb618e6b6bba2fc0ca30f435a06204a20f457d460b0b59b9fc7260621ec2276a77294a160f1e351b9618ff7d51b823687bf6aead92ff669413132bf095c6c37b519d58d730934a8b25d523da24d8a3d1e3e8774a81e975bf6282770b1a8d0bf1c1258131e5939c425128a0e396a191da946c1f3691fb99db33830334752f94bed83e52ba14161a7f102a9b53f594858b0475c63eebde380d625b84998937b4ac2c38ea8faecefdb17374cf217fbfa7ac5b685ff6ccb254feb2de5f6fd0e1b619f6148715442b234545ba2f1f67527fa204fcfcac4a229046e41054c8f0a810f1c771d8f013f32df4d51272d54ddf828399aed6106de2bb8bb8a441507fbeb4ac6fc7fe9af9da3440508f6f9a90a378d6cf86ccd5292c3315d9b5258919a179e38590d8f57c984808e703faaafa812e15b4ea102e48c496e86ef8d65e89ecc26fe07fa7715375c6a0235994bca34900345068b21d3555f7dc1b9ff51dabf56d7048d5b3a5f1ee4b6a1011bbfe7218cf0a6c88b3a893522b268cacf345b8fb62754b37a3fc5d5524dcaf4a44c93fb482f6a9a76e6ebd220d330f70bbefb37cfb43622a25c8d074d7e34628a0aa97b54bc74307006c856e4ad75a93ed2e45b70999470e210bdc725b9f3ae7e5016f1b15ac27ff7ee8eed7fb4cc28e2bc9fa820ad956794158b5e0250daf79cfbe16cc8fe6e0baa6c2a30948b980bcf4cf8e6144330d6fb5d6ca202d93482b8566103bcec3dc8c740073fba06e704d499b1efc4341ab3d724cd56651d9acee2357146be7dc1596d79d28ce9e72c48a4ba1f5baf538687fee82455f32acdaf826bcf14fa3affecb9dce3a7d26198779605db7991582ba345d7fe9c89749db54ae8994a7cfb4efc3ae3faf558fc30b0546f735280f3598cbcd91444715b8fa24cb11fc716fd0decc6cb89d5b71132454f8e7612616a410ef3bed0cd4f6ef310173573c17d56f154e5d05382a3d940b833938ee66dac8652de7e0827e6f69fd3fb49e1d3a4a057d22a9c703bdb7f5e5bde3ae7d4724e01dc1a3971eaa0ea40d4c43545bf142bf3ce36411a19234ab03be1dea542ee1e911554b1e30bfaff7eed2653dba826e4f40e60f1d2041bf3a578d3eabb780bb19336cc5d305161231c727d87a25196afee5bd1c1b6145d64808bfe4ac46f7c0edae254f923ca96a4c09f80e2bd6b419ccd8c7c9eb7d4d61b977ec5f9755e846e3bf7a1dd23a0b248d8b04912f9693e46c5ea3be7533ce983f48e1d7c6fe4c581d87e893e9d45bcc701bd970b7b717461eed1f16ffd911eb2ed90fdabf09e4e6739ed64370e7f99d7226661c21eb32e932cf6feb1bd605abe91cf8b4170c93b7f382aabecade3070157e5dc0f7b131bf62c5200b2d37d6d49e0711f6413cf5a10d6e291c3f8f68ad3857bd26fb6c43a530e0af3bb867d043bbfcd3fa2b595b26fdb2df906b07df1c0bff54b78871ac8c586b92d1a7012fbe740d0e13e3e5f86b427717c105dd4a2a608275d758153b66ccd430809a62f07f73276a473c4efe53eb70ae2ba46ced7222fe2ae6eb6d19fc3011e1d70b8063bf908d8c5b693bd78714a3ed97ac486c7e8ed1ed0317e04d9223edc7b2fe98e9f5647cc316c77b9f169e1babf2d7f52f01565e3b352616adfa54d79a242137e31e8ae26af789987f1caa58f3e31379b6520e2f4d6550167cf26eb534df4e638f368abf84d5d1e3346d5191929ac9cf6058026f761e46d4035789ca92a7a4bdc111f4a29037e6d50a3a0d538be9e6a35dc56cd89e7791fb279f6f2e4903ccec63a355f5e8aa4c68a8ae9b689c35f4875f371d5a344991f2e6622b8fae31e7439d77bcebc2c9d7d410231f863e1bdc59a5296b5235e62ef94ef0eaf9c4add8b0421a031a9ff892b935c99ca416b9b65cd3822135169d5f0c5b80f017e8e8724d484667a7c0a66049d643793d2be12da28196cc53ec0cfac06643c445336802bff9fdf2b890b08bbcc1b31b21f337c20c015b5ab9301ec712598d44f22b19a697c3f4550fe885e70778567d19f6acfcc1db4da109cffb2efc3dd4d6b04ba877a7aa76030ad809f71b9ad975a6e12f0bdfa782e785604e92dcf938cc3642f036f667bd47b560039b272a250e2db3cbcb09b025d6fc2b4562bb34704e350874ea5db61f8d523997181e85bcd416af0978b5295a025e4433783764fe715ce4f8cdef7cf2c8bbdc9fb508e01d68bc67081d3e27125768b81a9ec675c49bb3ac6a63ab055f51b2bbcb0c3450db8816211c72670a5c91283aa5e2c65c85075bc29f69fc7d63bb7dc2d3f89169b32072bd6b0533d6811b969fafeb178216b4f024a9205d685fc7cc8a948d4ffaf149568d511e166becbb0ca9528b99f55f61e81f2b78c1b59afa493a43e2db66bae55568eff827695bcced399092f821095a7286cf2fb20858544f5fd8f53ad2f33faf8054589041e7a306586a0b50c602c2daf49bc221fcba163860d3f8dfc10e5738d204dc84b2950946c33e7260ab92f8c0cf7ec6873b3489f53fff427747039bfe58b6ac0be9647401f35075323637390c27e902dc5dfefc9587db0c0ababb5c9eeb15c6477ba193439054860321ab6fc346180f4f80a404321c48e2bc7f9d59a9d4a15abdce15a74fb7944298089b0357d3e5cdb0da637be70a62050c127389db409689044775638211c5690bd4de40139c3f24a6445716f7e744ad507fcdd49f6e18a2cb5bce374821f520a90b8ff037260f9f86a08bc573d39231b09144b4aacd987cdeb1907f7e35000346234b5f85f639c6a7822cec27f7e3528d123db0fc744be7365d85e84566d74aec1241bc17c0bea97c23dbd7bbdbff93840d3c1bfc08cea295010e1b10616bbfc8afc969689cb169cfcfca7e684233f687adaa3ea429131589db980c69b169d28a76bbfd80fbdd30b71227f1af5fa5535be75a83679b8c3205bc060a6b39746a6b39ff9965e7c6b79f95f5264aa5fe209f9083a063746317b0ac122f1502153741bff53a114e70fece975e4fe87c19a24d46b064c6e6fb5f4b1d934079ea173482089528ecf383be284d86b43838e93bfe9a6f78f307c729573127116bd82dbf4729d70d9bcc20386857b163315de682dbe7ad18d515494ddff3b13b1b81a42d60629668fb530c600f1b4026fd2197790c13a9d0bf91100e4af57425a32f5c72e97a3f7fc3e2bf06f52d2b86cc51fd230c8910e49c8bb455fb4868a325b8bf0afcd5a6c86f110b839f51db8e33f850ac8b15d9772bd2a6837161c46facb7f7d97f0987e677ddd4edb5ec3a4513898d67b5652e6769033bb9000b2005c663ee6b9c562836b38f8b57bc799c3f3969e1dd4d67b302c855e036e0d5db9f501a22197d482595e83edb2c65f4679d8b9515a94feecd6d98e6b947f3f41c691278cc879f8712f6b1c072b937efe0613281570a6fef1335bf6663ac6158b49ac9b5c9c40ce5063f3bd87404f2c408865c0c0771b58bbb647594eaebe5bb062831ca8d2f064d4618201c00833a8997ffeb4f945e25c3982240684c47e66c3f290ce36d572c56da97f526ce7c5e0cf390bcb25deb0ecc600aad990286249d8f0f72ed4363643d75c608cec8f91ea72601335ef3895e89cf6732b8c696529e4bf89eb9033f92402b0c101370d28796b5ea65bc9c3c95146e9e3850e5ef98786ca00b65ece73ab52f9d3708167082bfa6c842b9f9299f744a624a686fa304c292886221cc490d6e91200abf71e42c8aab147993bba1b6083f99da77566fb4269cf59d12e6c1f7c7f0d002c1bc6a9ba0fcf131a59a72448b42147ff169838fa97f90ff5bf0f86f105f49566ff2fe1bf611a0c814eeff98db3a981bad5670e28559a017e31b9abedec4d29be0a1f5ea22c1e32522d5bf7e7e8d18a58961dad599b085d3d2b9f4630fd8d1ac4d293f7e947cac459d4b887a06297793bd121002a3217010a4d74caf5e93b0da11182239b1564feb815b1dc474b0a11b8c240a7e5b3f7ced006982524630240837c5a93f1d31297cc35275b4cb74ec36d8f98c131e7c8e91b761ad5ae6f5355aaa3d2e5593b522a6b2287f9683376c3edc39b1108342f1e3347d189095006096d3a11efb3f214533db95ca686b86d7d24be6428015d6f205c44e8cc5b99c0262539950c2cc9c5ee46537056f2efc64cc12f81f906636f2ad01a117c37507ecfc7468bcc721795a4a1f9f96a2f6ec04126f5404727231f9724413c6a6a46c39720a888e23189874e9bcd8486c7539c5e6c1849a931847ac2f8de5a6381ce65e5a657b58c8ba7921dff813b1ca52d2545bd6fd7375e18160ce497bff4a2feb9d6d4191c9c93e2b5d069cf88471164eedb78ef557529a8b97b2bea9ae05a9342330b8ecdd7d5f9f3b55e3b34d6f8e4f8832d15b4a3dcd424dee552393c77a412c297c4dcc93ec7bfd1629219d24a2b4c7e16353d61a0e2de0aa1b834054d67e7cf9e6e8e80e67779388aeb747066e0e7e97423262445d03e8e8e64998342cff14fc6d83fbed8423a577065db276bff48913e479b5c077fafed8ab156badde0fb318d7be9cbeac4533baa12dafabea04a7e7555eec27ef643ad3ab56aebe030c3233195d8a6e9362acd04c928741a3203f97349bbc11cf71a0f3a00062ea53ae672e626bf691e9e073d18a556274611eb2be4dc4ef20bf0160ac6e4a79303c3ce026fddd73a8c855ddff36f2ed74d0a74549f4e8fda5a938891ba559001997c1432c5d21164b2dd5db8e725a08eeeaa5472fea8e481ffa1791ec9fa47a076f0c8cf860c52d65db33a6f4b0bb1de035c5dfabc011fe3faa4cef764d6f6e9764aa33f1f1ffd9112998f562966197afc5b33f1efdc4c144b96a3e1949d61965f3230f04cbb8e6de2dfe2d24902e63100927c245e4b3311910922756fc4fe4b6c6cc7bd858d5af90c265a5dee6d5431d75acd909bcae0958acb7bfd30b3f44d8b5edb8a8fd98adfc92d77ee1522e27aebf2d6ca81dd7d8bf921707b8d7bedeacf936245c2d5a7b801e4dc0d3482d71fd79ecdbc054079760aa754274ee0f36b7bb3e752f13e48e8d20a49a4e1dc499ea82f931642524ee85bbfbb71924e36046c484c9f6547041b0f72c09cbc08af1508238c77f8bc55f6cd16177be4ce1092b77c5e7da861c823d57f859728759125b7ee8d27f9357b70b17936ec4f1d871678a6d1c91be924e7d8749e3d31af5e6cf71cb176c53bb6459d4d71f13f4769eefb1ab2a7f1343f3bf031f896f9f03651d066d7384ba2606387d32116d1a0ad8c88815f39ee587f1159d1e529c9b8bd8be3af952af7858f5d96da91f751b220a0605d0bf0f4e479cc795026775caeaebdbefd8d2c2d03865b85dcad497204974ef2e1fa7047512d74df656631c6921d113f8a376419d7fb4b4c5a7d18f65b21132ac9606308dbd2d1c4ca7d0966138e1a1e3c1593f9283534f30fdab826390a4dd29711b173faf08b5dcb6827e82bf80667e06c5e2d4830552e0e74fb19e6e065cb02d8d947cf73c821ec499f37644cf22f0616d17c4f02927e7e2c0872c02467632d0b19038d8e3d9db389e13f3faeaad0444b02d389374102d0cff59e8aae8182781d6f83535835506569f5a375dc4510878485a39cc74877b74b6524b3f44075b5fc048e37951604393675cff00a33f99449d8d735115f7e1e3c12e8b60e6a348209b6f716263ac837474bd48fe7ca88184c695e6a79939e9512387cb821605116d27eac98c6aaa46e08e4991245f78865ec7cd2b79eb8b461e6c65b1cf7f9edf222e6c98b8f72feccac503be53580b055acf4adb787e81ab7f37cf72068bb3b5b83cf144a3b73759b6e760dfe33028a8f29e1ef5e727b9bf24345bac2fd8d4f977f8607ec2e8a4bed7160afca320d0fb7e1a4544f31e92a96011387549bdc0cd3a38cb89bb0837d88596f1c44780929f8c5ac334c837d9da1e3791e81cf96f6d561b2cfcfa2845cd6450f5e1f701c9f01c1b5b3a79a21729849cd16a1b8b0cbf63ac443b44e82466530a78f37118defef32176aa333d7e29b8387eff06c3850d332e2246954dba534ac159b0da6d5506d7054f25645b06e4afa72e135af13c83a1331b34a4f4712c3b32afc9a3cfb797218a936ff84a336b9d50dc5122358a91cb82d34f55ca41e58cf61258d43a1c701ae6237ca181b25098a2cb1ee19bb8e7c51cd38c1bf14422daf9b38972b814cc952a70620621fea3f7faf66eb72a46285b69a9d018d3977bd0ce014e0fb827e5f872ee9f779ecbc87c3c5bc398a4014c7d1390004be60761c0da7780c74aa612faa779e42e21ea5bb26e92af4556903fa290f93498ef3ee60dac219d428d9e09acfee5af2e282493a4238be68b97e121e27cf3e3f26ab7e92d2d350d6fe2a46e61984d91af597d419b539ac21d5f32b1667c45d81e1a769979bf29b870a03d3abd78359a4173bd1c169fd637f8548ccd5b7a6e31711e6f1e0fdab35cef2696a85775a1e313df700cc70eda281067c8fd9c4777edf4937bbd6b9c0f54f033102007f72333bb86b3ac154aa30acef0690e7d77e60c6f85c7359db2e568bca75129b82d379b2fb5c1ab74d7ce5c8af94f1785e7a1d1b96b81bb0ac20f752ba240a85812efb610cc20208e9d76d8e1ce46243ba0ea320d7032dcb741d99113cfc989049e8837d970dd277ed4c09774f71d3549e36e4a514e07c7046d7e4128fb0b968d383b1c5302ef9403c5614f3f2640aa8bfcc42fc04e00fdf6c0223325717f10a596700d33e4492da0c069196df9b22d7378ea03744b07c85105446cdae2387a05117ddf4b4711b0eeef3caa674d09cfeb8954c31a29cb8776d73278e8e316e14dbed4c52bcd78683b82ee8418ed5563e7084ed5def5713fb0641211675981f7b29b01f31221e4958b23007133fbb062b8313d9f0517bfe222bf13189764df4d69859a3b9a887d306891caa5238f3b66c8b538010ad7bce058d34185a6e7b6c8d17cd754a75fa4903d4aaf360c8f5eaef550679403faf1ffbf33dc40a26e0985f04d6824451e653862bcc9ec8a1f42a0b1465da6bdafb8b75d7cc330c65a6a9c26d493470c85be8cde9b8e9ed289650c34cd05c78f6acb23cce855c3b4caf97a76efb5734db3ec3a10cacea746a00bcfaecddfcc0be35308d5034f42bd239432dd219008945c3fef1c919d90fc28e4f17082a2a5f6b984d31e9777124e5e9585e7351b254f9c233cde300e56f194cf3d8be196ca1f7319bdb6591133f12bd704370860b6460f7b70e44b9371b063923ef2238297e8242cafe1881d7a9923d2915709b7162686a743ed62af9e8035ca06f138ec45ca8d49c4b1c7100b06d7a53537ce78d233c9e8af1e8cbe43d9a14df673d5256072bd104504b8e0720142016224399e7b330cdd5add526684aa91533b6233eb4a83eb402b8460c788312bba938914caca96d1c7e43ca23a7ba50d17e9edd828ac07ec4a5dc348f0d5cde493f7ad3d387b359609f9c28612fc703ef56684752424557d0e9900f97d41a410f739c9382416b71251ab155cc455051c6058b475651f63a34b7c5c25e5ece84d446efefff00a2c2cb4a23072355898034d0fb4f7d2b69c0dfc1bf106e5b1b74c165cec90703f8601cd80e3dcf9c584464a17e46cd84db37974a01e49acdc7303c0f4a3efc1a44ecc41fff2a91acbf96f39aaa62615b7f8a213429322c012c340b01d0e7deb4ff8e2c932ce1a15c811ab50366b3616828d7be086407436a1b69b2fded5a6431199a771875a44f28c50ec1a5a5f5a5605d3b64219a4d66858d0cf7e3bc0ee574dcc4f7b11e4a54ff110e43c2a0dd1820caf4d0dc3596b0c77dd025ef92da59e081e4bde95ad3d77061388f28bf93f75d4fa3e9381b78b63c5b82c8401384f3361a6d6a641e49c28e8fcdb8531535773c2e98e4c5dde0ce23c88e927e01a1861c360331fc6758ad8c25c2803aa97be6d86f4da61c0e6e8bcf98ecaa3ff2ed0515d4a87d631ccbbe0ddacf85358569fb38e19653f77fc44d5576b71b68264addc525be55efc6bab4bcda47fe7c37e591f4fb329bc891099835fe751ab4dfa97268e399dc9421eb03e15f9994bb8ba260a4c3e0ba499d9ba65b2c897862654aab91c40c3dc33ee07e120f06019b374f6917f652c66b0382c5c97467fc8770bfc61bbc75477b871c879cf77bd79f7daa406806e75dc11d43902fdb3bee7a1ddc11d7e4498c0f5483b4322e0f93fe479c8ae8452e8f43f4e4c9c7d02e086add46ae2911d1ce67d39f6acca98677b2a85c7f93aaf14493fd485ad89336272679464827fdafb892289582fa1ae66577961631fefd84655544d00af6610267bc661ece0666a8858d192df847154aaa2729755558e2e5fb21ac9ebd1cc477a847d44a8585d9158d44777d30233843bd540dbbdd686745214f506ab67d58a7c201d2f60f64dac7f7bf8af85ea9fccba58557c0023d4dcd464f7139108529a658904ddc6ef4527b7b3ce81e14b831a325c7faa2f9fb9a12fde465e515427091a7cee6303a79f9119cccb4f68ee517898c00f987e1197844c5e923892fadc5dfb6f0596fecb289fe6a01f6f41834ab8c6f344e635284797d1dd8dd2af6b8871c9a9f3048904b393325d5cdae0d06bcb11551fbf65b7431ca7490901a11a1eee6661f2d3d90d3662c23faabf8726fe6ae11bffae4086498f8eda2566efbac499ded75a35f22b30e89acc4053d32a1d358413321da9f1cf5016491a8787eda3638c419c9cb535800f37fda418ba57418ed045f6e5396a43f5c75313ed20e9ae3a5eb0155e6e38e25b455d7ce81c5d142568df1e75db7fcb1e6bc200e4cdcd6cc22390f430d1be6e5df1681cf9b6881e60f86d27d284fd80a690deab92595cd39007a7d086ab8a1d49ef356755beb6b17f283c93e81d3f053aa1863a9cc425ea0f4fceb9df88ad0e76b0e11035c5517e0f3e37f301c8c8fd486904833ddb34696e0454ffa65b89096b343be04dd28aab17adcd9a4f01de944c6a342394d9d7bd363fdc41b0560b817e2c29cb2a7b6e9c4d21dca93d1b77db865bbcb3ab08763368a32cf78c0fd34950c68403f58a72aa39275ef119233405cd70d6e95ed3e40450f787f4bafa91c47eeae1c8ba2fdc02d85b4013bf8f11bfb6c3150c26c82094e53c12cae7a3ccd02287a979f0a992638181aac759ae9d2473768e23e968e98013abb7ca86812bf249d6b70e1d6e40eeb795e9d69736725f088e932448ec57c2252074db2158b22cd5292a3c10631f460cf1bc39add8219c4a1614d6a238ae86d5f472b9b7c29d33aac3eec46c4c4e5ddf542606fa31031b7eca30fa806aac6f1bf7e0d4078bc265f3902d8eadbe8a0f13d5292f3dcbce9c225ffd45568d5da96bb11de10cecb9502ded0449f5e5654217b82b568e0d2356e6705193b4735fca58eaa8b2e202177867e83b8b870790777996fd8bb906d5dd1e3f107f80141b9ad4bba2ce750dbce6f3c9cf024ce33ac83eb25275ab37c0f58ae1f020f02bf0250764e6679e91a98fb9ace86fd1ea43551a95fd478303b14361ed3ebd0097ef3e3781eee9e0d28d152ed5726c0fd3f58b9ec654fc5737b89bb5ee264cf9d1de05bc55cd90458395f4d74a6ff9d5d93df8edf608829e39dbff8bba53d013857d2cb5fa1739047f1714dfc1e7276e1844153918d6a25092354e94febe7d482a5f43788a450e3529689b77210cb191d037cb003a6a361dc30f66f3e44b82e3054bbda58a3cbe7da90181aed4d0a90baf7924cfdd0eebac4648f7aa17c3a9993539f7538fd6a2d3b08235f83d403ee0e76ce6dbc6294632d4464915c54eed96b3098f1135d1be52c3af207c0efe16759643a80f126f92606b63ec4278528677349e5c60b29818736be27c84d6124c44522e35c04ccc620ad6d672cc960dddcfc5f472da78962a75f197db910f54b52c62984a8ecfa9fe20a3a2f9039cc4de6f6fdf0c682e72f98ebc9ef90530a67bfa8f0ad6ac43277fee5a8076dba27811463c5fbae69a4d98a03e663c7c1971b44a3b69c21ae35239b9c6f7f61c3be647052e36dc25b939c1b5b4d542aaf7385880a21620a2895b8b0c891673448973a8776a0ceeff3e1c1c91df5350c389d81aba733be0f0459f8713dce2d1a8ea32ff3bbba024a86c6cf7e7db380449369764a3155feefce5ea4efd360352dcaf49d08efeb2e2b384dd8d3634382a67bb8f3ff0f9a62032e4fa4c9a01ff03d9c34b09078abdeb7ef68cefd1f57d26ae2dd954a556d98241a9bf810fe48650ebffb6be9c78751287760528f150fe1b5dc622fb42fcf922879cac231c25c6e92761cb42723a71ad7d00342692d13e11e044baaa376ab3ec7874f0703d753fc26ac786f77efd63e2ecfc603b65d9b2d8b91184072f9f2cad5cd2e7cc6693deb99eeaea1ca5a399671d56487e94bd873550e92e2e8d678d327362ff2b4d6b4dcca55a57ac83ff9566905a2b4596a2b0d052d98570debf9dd50710bfb8b18958fa6b6a7bbd6d1b917eaf5dc8559a2296144178cb2eded6e0c2132a3eacf327f4b55f4f453e76e51a7e90b5ececdabb03ea05500dde34568bafc457ef1f9637402a8d4759076d1deab3cb67ff64c28b53f2a0e9ff36b565abf86e35839038aee2443482db1dd692b5395c3280997d89622107b5b5fefdb70389260f73ac649c7b300a47fbb2de8e01a9e51d009e0cadf36be18acf734681ac15148f2762cebd4f148f3b42d6b2c9432cbe1671248ee5b2a73ee4349fd00586870b829f446173dc4fc89d004c4daf9b8ecd52cca3e083c868572384f68f22eab6a39326a3fa28c2630972941aaedf661f9d8ed45cf3e6b25f88c5a3ea34a8be5eae4c13a7441a176a772c12562cd3239baf0cd9098a044eb94f02db0df19e8066c9fe185a9113e681b3f40feb4520f23aaecad7912f0730a7a4aa57d929fcd2efb05b3eb0f533bb5485cb4f8df7414f992d76f07779aecf620bcb5e5810d92bd17de96e80421dd2be6c827b9c80b10596fe3ddbc51252ded1e1b0d579b63568046eaf1ad10010e8f7adbf0946c6ef71e18480183f87fb3e30f63b25df34ce2ab11e7e6ccc3004edcbcc32e6c506ef32f04541e83cb2cd3f6ddd49322358a002bbff5009b5e9c7ae49df35e077ac13c25255eba1ef4eadd26752fb32ce090b47f63014ba8c5be439b5b96e34a6ee61477f46cb0255c09894fb0e468b4190de6edd825e3911a8394d7f882ee3885e73d247a8bed0e8684f1854854da6ce246f3baf397cf5417309e857c82e8f3ae9374579ff3ed9b4f2af21e28b7be3f85d28c787a2878adfaed350d902113d1cddc79803cc8b3 有密码的才可以看哦","link":"/secret/21-oct.html"},{"title":"2021 年度总结","text":"82bcfb6ad35536ed66db7d5b2bb7b6ca9db8e326d4d45af47240cc0ff9ee5e1d16dcf15ea99d81a551af8e715dd8c820eb8872d7b1d1899cfa5d7608e264567060fd771cba5f4ba1594fd6fbff0755d73da6dbc283e832e6039cfaf93f26e20f7176c247512b98f555d5956bd8a4cbf4b2363d8f51c6946b5687b75d510c7a8f444790e67bb9436eeb281e6421751972fda89b32cdbc658be7cdb4620c3d8a291db1c7de3ff5def166bedf4c9192e6418c176fca9faeb9b12ab4c2c12fd8cb4395956dc3f16f353339889273def14aae179937f67c59b6fd927da06b689836db7f30dc1855ffdaaae8d271596503263dd6420141b9f08449be65f691f82d4029efdbac03b776a857569a8e61d4340b1ede43b36b078eb1bc1f1954320331ca9d5305379aee1a9ae87eed2014d6e3f7392812f2a37b35a9115e369dc6e8c70c1a87a57b4136e99a10ab359388cd97c8bebd9e1d78fcecbc4e709b7fa2dc5b8aa12e0ccf7d475b0d681a43d37049e7c9703042ee592beca3bd2b2838be8f848c37dc7b2675d461c9774f5f7e1e2fdb3b350a754e565ec4c1d31e49efbac32aabfbf940fe7de4554b474d2305842bd02b495aa49814b6ffb4ecb960d5456ab85fab594152fa00e16601ca496335338da582f78b5c1dda53455c88e698bd83c9fd4a68f4afcbe71eeb98c5f2a689f47f3c5295da9e4174a00e188d9913df1ecf017d5b2718cd9aacc053efd0c8a57e0a8900250830c182d159a8cc9760d263b9601b427d0a002086637a23e5df3ceec88f8ed741bbda2d94f411febdd49ce15ab5e50dfb9059df21e67ab726ed540af6397dac87b96963734ce387e684fca5f73e5e9ca14bcaa8b715e59ae4e5169dfc102944e742e8e9ea8cae9690c3a07633eec7a0d309a709649ecc822345f76cc5f2df97d8af020f4e859a39e7dd44dce47fe656f5a1c7960e3ee4e689c3782f7dc205934b71a61b2d36779ae8bfc8aae465fb2ae577a3debeccc20dd32fdadefd290d9f58b0c9d8cd70c8d8f094302e2bda3326237e40ace21b1e5ac018b1579d000473e0fe2b3170e9ccb1f105fd76df7e425a7ec87dcf9a798bbe1749a3af5536e8b0d0a8bde43e083753d6f34191079d28cb98b425bc167a00315fa47c7e2b83b3a4974e4aa027c25821526b8ec40b4ba327df9c7d00f9a22002a1e19f522eedccd904c068b4daa7b177e1102538247b8ef0fa9ff78c20156da35ed0ae4284138633510dad61b5376666f9b39d836c3ef9a1293478c12200f830471d8d9c204fefb8d09d6f8dcc9c6364aebb42a49675f6d75854b25eb57836b18288b56891a5257879cb5b664454737fba8406eb9ca6ecafb2939c581e5b288de73e5234579fd407f9117c180834e0a606ef5594105cb5e7e2e3d0d42e528a4db17c84c55fb1e6a2bf22774b7a13f02fb26f86d2596a7962568b9587afe2121e0e315715d343e6a09588633d6fe0286ece2862e9a96a5bba5c4502a1cc7c6a6be799d17174eb9b9362271be4c0df27be10309c86f1a77856fc2d2ad364732ef2f927ef19d04d0698b08b52470cd3d071ddf0a5c95a8462d61311e34a4948ac1d8b28b91b8d1b7fcd473663ce029ad2bc1c2b520303ce7ce16ad5413ce2635681cb0ab9505536bbf339243aab1807a00edf1d8b67a4ff05600da695af6fd2e01c30185239e2b0c768f4bc380cadafaa7e293f8f9ef9f4549fbe7c93d09c5236379e246471c4cd6c33efa276dd645f4d1d048d3aa2735ba8fed56be7124227841c2dfe7f01daae5a5f2e1c3229a5493b0fb6c83661a28adb8d0eef68ddeb12d99217d65be1a6420d9bc1acb8910b41332030ebfdae47cefdbebfb2f5cc173f84ba64878cd8d72dd65a42d5b78cb2a17a083d51955795a4816af9225f03dacba2a073f1ef90a9cc5025566539f55613263a3959b7fec2742f603661b0eeac6efdda1857c772bc011b1e6e93698e8f985729550262c5631376714bd943f9399e0c4fcaf1fb643e8fe0464655e8627a4f0b6215903bb21814965aa373ac209d8d4c52145fa3abbbd964bc5f37a8ca34ae0064cd0ddab5f67537ba9de01df860706c7ffd46c5f61bba8deca6b5b67f9d77c44aef95ae7824080d22e36403b461ed46b546c1802f32cf01500584028321a1d5f7f911c1e18a1636d0b66d3767f8be50ad560f3af363802fb70b4a41adaeb14d5af282043fc03215108ab014ac3e1bb353ce4c3a506c10b50c2c6c68c9cadb1731a88e8064634ad5c3e45f13eaa8f612e1f6ae3bb92b9ed18325d936005a999b5a2c2bbe241327f64aaf3f300fa3621dd570c1a37269e664550b0645a3d294b2f8de4dfcd08ca9efb62b5a09059c51014ae52e056a397c9e08e64dac4ef2bb6813d2fc859ccea3eaf2b4ec5451f8da718292113fe1a3cde972da7f9d8fdc5dcf9e20ea905ee08f57 有密码的才可以看哦","link":"/secret/2dac7475.html"},{"title":"Hidden Zone","text":"Diary Oct, 2021 Articles 2021 年度总结","link":"/secret/index.html"}],"posts":[{"title":"「ACTF 2022」Broken QRCode Official Writeup","text":"6 月 25～27 号我们 AAA 战队承办了一场 ACTF 比赛，我出了 Broken QRCode 这一道题目，这里是 writeup English Writeup First of all, the challenge has no attachment. Obviously the primary goal is to get the picture. According to the picture uuid recorded by the mirai QQ robot and the official API of QQ images, we can get the url of that picture: 1https://gchat.qpic.cn/gchatpic_new/0-0-AA8F922E7A7C88CE82D73F614D8/0 Then the picture:Then from the “Broken” in the title and the information “The QR code generator has bugs, the qrcode it generated can’t be scanned”, and after a simple analysis, you can see the four identifier bits at the beginning of the QR code, the size, and the padding bits in the middle. They are all exposed, so it can be speculated that there is no mask operation (you can also use the first hint “I broke this QR code by just missing a step” to be sure of this) Load the picture into qrazybox. Then apply mask and scan it, you can get https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93 , which is a hex string of a zip pack. Unpack it, you can get 12 qr codes: Scanning them, you will get: 123456789101112We're no strangers to loveYou know the rules and so do IA full commitment's what I'm thinking ofYou wouldn't get this from any other guyI just wanna tell you how I'm feelingGotta make you understandNever gonna give you upNever gonna let you downNever gonna run around and desert youNever gonna make you cryNever gonna say goodbyeNever gonna tell a lie and hurt you After analysis, it can be found that there is an additional data at the end of the first picture: 123410314c795f6b6e30775f5152436f64337d0ec187c229c4d4a44# to binary0100000100000011000101001100011110010101111101101011011011100011000001110111010111110101000101010010010000110110111101100100001100110111110100001110110000011000011111000010001010011100010011010100101001000100 It is not difficult to find out that this is a bit sequence (including identifier, size, data, padding, ecc) of a qr code content. The data it contains is the last part of flag: 1Ly_kn0w_QRCod3} Then the first part of the flag will be obtained from these twelve qr codes Through many tools, you can find errors in all of these qr codes. So you can guess that the ecc hide some changed bits. Then you can try to find out which bits are changed. The most direct solution is to use the Reed-Solomon codes to find the position of the wrong bits, and then find its place in the qr code. But this is too complicated. Since the content of each QR code is known, the version, error correction level, mask, and encoding method are all known. Then the qr code is uniquely determined. So as long as a correct QR code is generated, then we can find the changed place by diffing them: 123456789101112131415161718192021222324from qrcode import *from PIL import Image, ImageOps, ImageChopsrick = [ &quot;We're no strangers to love&quot;, &quot;You know the rules and so do I&quot;, &quot;A full commitment's what I'm thinking of&quot;, &quot;You wouldn't get this from any other guy&quot;, &quot;I just wanna tell you how I'm feeling&quot;, &quot;Gotta make you understand&quot;, &quot;Never gonna give you up&quot;, &quot;Never gonna let you down&quot;, &quot;Never gonna run around and desert you&quot;, &quot;Never gonna make you cry&quot;, &quot;Never gonna say goodbye&quot;, &quot;Never gonna tell a lie and hurt you&quot;,]for i, content in enumerate(rick): img1 = Image.open(f&quot;qrcodes/{i}.jpg&quot;).convert(&quot;RGB&quot;) img2 = make(content, version=5, error_correction=ERROR_CORRECT_H).convert(&quot;RGB&quot;) cropped_img1 = img1.crop(ImageOps.invert(img1).getbbox()) cropped_img2 = img2.crop(ImageOps.invert(img2).getbbox()).resize(cropped_img1.size) ImageChops.difference(cropped_img1, cropped_img2).save(f&quot;diff/{i}.jpg&quot;) Now we get the first part of the flag. So the flag is ACTF{Y0u_Re41Ly_kn0w_QRCod3} 题目描述翔鸽最近好像在筹备一个二维码的视频，在开发时不小心在群里泄露了题目，虽然及时撤回了，但还是从群里的 bot 日志翻到了以下信息： 123452022-06-24 13:57:24 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 刚写完了二维码生成器，但是好像写出 bug 了，扫描不了，你们看看？2022-06-24 13:57:50 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; [mirai:image:{AA8F922E-7A7C-886E-F54C-E82D73F614D8}.jpg]2022-06-24 13:58:26 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 草2022-06-24 13:58:58 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 才反应过来，这可不兴看啊，里面是要给 ACTF 出的题来着（2022-06-24 13:59:06 V/Bot.3559109703: [Project QRCode(xxx)] 鹤翔万里(xxx) -&gt; 撤了撤了（ 解题过程首先，题目只有这些文字内容，显然首要的目标是得到那个撤回了的图片，根据 mirai QQ 机器人记录下的图片 uuid 套入官方的接口就可以得到那张图片的 url： 1https://gchat.qpic.cn/gchatpic_new/0/0--AA8F922E7A7C886EF54CE82D73F614D8/0 访问得到图片：再由题目中的 Broken 以及信息 “写的二维码生成器出 bug 了，扫不了”，并且经过简单的分析可以看到二维码开头四个 bit、紧跟着的大小，以及中间的 padding 都是裸露在外的，所以可以推测是没有进行掩码操作（也可以通过第一个 hint “I broke this QR code by just missing a step“ 确定这一点） 将图片载入 qrazybox，打上一层掩码就可以直接扫描了，得到 https://gist.github.com/TonyCrane/88dba1fb35297fef2b195495447a8a93 ，里面是一个压缩包十六进制的字符串，存下来解压，得到十二个二维码： 扫描得到的结果是 Rickroll 歌词，而且均是完全的纯文本，没有内容上的把戏 123456789101112We're no strangers to loveYou know the rules and so do IA full commitment's what I'm thinking ofYou wouldn't get this from any other guyI just wanna tell you how I'm feelingGotta make you understandNever gonna give you upNever gonna let you downNever gonna run around and desert youNever gonna make you cryNever gonna say goodbyeNever gonna tell a lie and hurt you 经过分析可以发现第一张图片的结尾有附加数据： 123410314c795f6b6e30775f5152436f64337d0ec187c229c4d4a44# to binary0100000100000011000101001100011110010101111101101011011011100011000001110111010111110101000101010010010000110110111101100100001100110111110100001110110000011000011111000010001010011100010011010100101001000100 再通过本题主要考点为二维码，所以不难推测这是一段二维码填充内容的比特序列（包括标识符、大小、序列、padding、纠错码），解析出来的结果是 1Ly_kn0w_QRCod3}，即 flag 的后半段 那么前半段的 flag 就要从那十二个二维码中获得了 因为除了第一张图片以外，没有任何的图片隐写，所以问题应该就出在二维码自身上。通过很多工具都可以发现这些二维码中存在错误，扫描时都是靠纠错码来纠错得到的正确内容，所以便是通过纠错的特性隐藏了一些更改 最直接的解法是利用里的所罗门编码纠错，找到错误的比特，再反推到图上。但这样有些过于复杂 既然每个二维码的内容已知，版本号、纠错等级、掩码编号、编码方式都已知，那么最后的二维码是唯一确定的，所以只要生成一个正确的二维码再和题给的二维码逐个 diff 就可以找到被更改的点： 123456789101112131415161718192021222324from qrcode import *from PIL import Image, ImageOps, ImageChopsrick = [ &quot;We're no strangers to love&quot;, &quot;You know the rules and so do I&quot;, &quot;A full commitment's what I'm thinking of&quot;, &quot;You wouldn't get this from any other guy&quot;, &quot;I just wanna tell you how I'm feeling&quot;, &quot;Gotta make you understand&quot;, &quot;Never gonna give you up&quot;, &quot;Never gonna let you down&quot;, &quot;Never gonna run around and desert you&quot;, &quot;Never gonna make you cry&quot;, &quot;Never gonna say goodbye&quot;, &quot;Never gonna tell a lie and hurt you&quot;,]for i, content in enumerate(rick): img1 = Image.open(f&quot;qrcodes/{i}.jpg&quot;).convert(&quot;RGB&quot;) img2 = make(content, version=5, error_correction=ERROR_CORRECT_H).convert(&quot;RGB&quot;) cropped_img1 = img1.crop(ImageOps.invert(img1).getbbox()) cropped_img2 = img2.crop(ImageOps.invert(img2).getbbox()).resize(cropped_img1.size) ImageChops.difference(cropped_img1, cropped_img2).save(f&quot;diff/{i}.jpg&quot;) 即得到 flag 的前半部分，所以 flag: ACTF{Y0u_Re41Ly_kn0w_QRCod3} 后记最后十二个二维码的修改是我在 qrazybox 里手动盲点的，导致最后一个二维码改错了没发现。比赛前一天写了 exp 跑了下才发现最后一个图点错了，于是直接重新改了一次，也懒得改其它的了。导致最后一个图的大小、位置等都和前面不一样。后来放了 hint 说了这个没有关系，但是貌似还是有很多师傅在最后一张图上盯了好久，给各位师傅道歉了呜呜呜 Orz 这题我感觉出的不是很难，没有刁钻地考二维码的东西（外面的一层也只是少了个掩码而已，没有什么裁剪啊，乱序啊，打马赛克啊一系列的骚操作），看到反馈有些师傅卡在了前半段，有些卡在了后半段，感觉都挺奇妙（特别是后半段，本来应该再构造一下的，比如穿插段数字模式编码啊什么的，这次完全用了字节模式，导致做一些移位就可以直接暴露出中间的内容，并不需要了解到这也和二维码有关 也可能是做的人少的原因，最后只有 L3H 一个队解出来了，蛮巧的是我也是在 L3HCTF 那场比赛的 cropped 题目之后才详细地学习了二维码，给 L3H 的师傅跪了 OTZ 总之感谢各位师傅参与这场比赛，希望这道题你们能喜欢 (￣▽￣)","link":"/p/12a2afd2.html"},{"title":"「QRCode 标准阅读」#0 总章","text":"最近几次比赛遇到过好几次二维码的题目，打算好好来读一读标准文档 ISO/IEC 18004:2015文档 6.1 前面的内容不多，就从它后面开始记了 Table of Content 「QRCode 标准阅读」#1 构成及数据编码 对应文档中的 6.1~7.4 部分 「QRCode 标准阅读」#2 纠错码编码与图像生成 对应文档中的 7.5～7.10 部分 「QRCode 标准阅读」#3 解码纠错过程 对应文档中的 11 部分以及补充了 PGZ 解码相关内容","link":"/p/409d352d.html"},{"title":"「生活」2022 春夏学期总结","text":"想了想，这个 blog 里面还是多一点生活向的东西吧，一些技术向的整理还是放在 https://note.tonycrane.cc/ 里面随时写，现在又更新了不少东西了 这篇 blog 呢，总结一下这个刚过去的平凡又不太平凡的大一下（也就是 2022 春夏）学期吧 开学刚开学肯定是照例势头足足，而且也想弥补一下上学期数理基础课的低绩点，这学期该好好学学了（上学期基本上课都躲在教室的左后角，这学期开始坐前排了（刚开始同学都很诧异2333甚至专业课还会坐在第一排直面老师（比如汇编，结果小白老师上课还一直盯着我2333 上学期基本也都是一个人上课，然后下课就尽量往寝室奔这学期有了 wza 作伴，因为专业一样、选课类似，所以基本上好多课都是一样的，然后就经常坐一起、中午一起吃饭之类的 这学期的课比上学期多很多，而且比上学期硬，按照上课顺序聊一聊 离散首先开幕雷击，周一早八离散，大烂课可以看出老师基本没备课，上课照着 PPT 读，有些自己都搞不懂，基本就要看一大厚本英文书自学了 但是 lm 老师还突发奇想整了个恶心操作，在钉钉群里发了个投票，问要不要快速地讲完全部内容然后开始做题练习一部分不明真相的同学选了是，超过了半数，他就真的执行了大概就是，让我们回去自己看书，一个周末的时间自己看完整本书的内容，然后上课他提问每一章讲了些什么内容，然后他再自己说一说，挑重点讲一讲两三节课之后开始发去年的小测卷让我们上课做下课交然后同学们就都很不满意这种形式，向管图灵班教学的 zxb 老师反映了两次之后，他改回了原来的进度 离散开始还试图跟一跟，后来发现其实跟了也没用，讲也讲不明白，不如看书然后看书也鸽了，也就做作业的时候翻一翻，等着期末再补（ 普物然后是普物，来自日本的外教老师英语上课，口音可以接受刚开始听的比较认真，然后就从 记笔记 -&gt; 听课 + 看 PPT -&gt; 看 PPT内容从力学到简谐运动到波到相对论到热学 期中考试难度挺大的，考到波，成绩比较低，难受热学内容是临近考试周讲的，基本上没怎么听，也靠期末补了 渡边老师还是很关心学生的，他也在课后聊天的时候表示了“这门课内容太多，难度太大，对你们计算机专业来说用处还不大，但学院还是要求你们学”渡边中文还不熟练，和学校不会英文的教室管理人员交涉的时候还是有很多乐子的2333 普物实验做实验还是挺有意思的，但是写实验报告就很烦，要写十四篇实验报告，每篇实验报告五面手写的内容……同学互相帮助水水过了（ 足球这学期和同学还有 wyy 一共四个信安魂选了同一节足球，和上学期老师不一样，sgr 还是相对比较严格的，但是还挺开心，很好 数分上学期的数分是 jhy，这个学期的数分是 jhy（一个是贾一个是姜）上课风格比较催眠，经常是三课时就推了两个定理，前半学期还一直跟着，后半学期实在没耐心听了，不如自己看书到最后基本也是靠看书补天+学长组的回忆卷活下来的 锄大地其实是农事劳动实践课，是夏学期的， 待续…… 接锅考试周乌云","link":"/p/f58cf1c0.html"},{"title":"「生活」2022 寒假总结","text":"一个月的寒假这么快就过完了，闲来无聊，还是写点东西记录一下这个假期干的事情吧 _(:з」∠)_ 手机里的待办一点点变多，然后又一点点变少（不想干了/不会做了，所以删了，乐），总归还是做了点东西的 摸鱼方面当然还是先写点轻松愉快的 这个假期玩通了两个游戏，很像，也很震撼，很能给我惊喜 baba is you也算是经典游戏了（？在几次 CTF 里都见到了以 baba 为背景的游戏，所以就打算来玩一玩原版了 直播打了好几次，关卡越来越多，又不断解锁新玩法，新的隐藏地图，在隐藏地图里又开启一个另一个隐藏的地图烧脑，但是好玩，打通了又很有成就感打通之后才发现还有两个官方关卡包，还有更多新玩法，又要继续肝了（这游戏买的真的值2333 文字游戏在打 baba is you 的时候才听说的，打了预览版还挺有意思，就开始等发售了 发售当晚买了下来，从七点一直直播打到凌晨两点，打通了（其实没有）玩法当然新奇又有趣，剧情也超赞，而且 be 后的反转也搞得我浑身鸡皮疙瘩（是不是说太多了 之后隔了一天，又继续打了二周目，这回解锁了真结局，真的感动然后去搞到了全成就这个游戏就完结了说多了剧透，反正强推就完事了 番/剧/电影这个学期补完了 EVA TV 版和旧剧场版怕影响考试周，就没再接着看新剧场版这个假期又是看 B 站又是找资源，看完了 序、Q、破、终 新剧场版虽然依旧一脸懵逼，但是回味一下，还是很好的 我是个从来不看剧的人，但是在 GZTime 和同学的推荐下还是去看了《开端》算是颠覆了我对电视剧的认识（毕竟是网文改第一晚上看了三集上头了，第二天直接从吃完晚饭看到凌晨两点多一口气看完了剧情没得说，演技也全员在线（除了准备药检2333）牛的 电影嘛，电影院新上映的一部也没看在 B 站补了《烈日灼心》《我们的父辈》都相当好了（嗯.jpg语言能力尚未达到人类标准，不详细评价了 技术方面Notebook起因是看到了 chenyuan 大佬的 notebook，群友 fran (zmx0142857) 的 note，还有 widcardw 的个人笔记。都很全、很震撼、很羡慕而且感觉自己好像也缺一个这样的东西，好多学到的东西不进脑子，学完就忘，还要到原来的地方再查一遍于是就也自己开始拿 mkdocs 搭了一个，链接在：https://note.tonycrane.cc/ 在这个博客之前用的也是 mkdocs，所以还是比较熟悉的但是这次又详细地看了 mkdocs、pymarkdown、material 的文档，感觉 pymarkdown 的特性要比 hexo 的渲染器多得多，功能也多，调整空间也很大material 增加的特性也很多很好用，香的一批，写的也舒适 为了和这个博客的主题匹配，我花了很长时间来重写了字体样式和配色主题，然后又从 pymdown-extensions 的文档抄学来了暗色主题和按钮的配置（比我当时给这个博客瞎写的高到不知道哪里去了2333） 搭完了之后又补充了很多东西进去，把这个博客里曾经写过的一些系列文章和 writeup 丢了进去，现在看上去还是比较完善了 这个 mkdocs 的 repo 也公开了，在 TonyCrane/note，快去 Star Q 群机器人mk 的闲聊群里有一个机器人喵呜，很好玩（很可爱），打算自己也写一个玩一玩 然后在 GitHub 上逛到了 djkcyl/ABot-Graia 这个项目，就去看了看 mirai 和 girai-ariadne随手写了写，加了点类似显示 B 站视频信息、复读、咕咕咕、生成图片表情包、查天气、渲染 LaTeX、查 cdecl 之类的功能，写了一坨屎山然后跑了起来，加到班级群里反响还不错，同学玩得都挺有意思（ 之后又去看了 girai-saya，整理了结构，又写了最近大火的 wordle、handle 两个游戏，都放到了服务器上跑了（虽然但是，这也是第一次用 screen，第一次用 vsc ssh 远程连接服务器，老火星人了） 现在代码还很乱，或许以后收拾收拾也扔到 GitHub 上（？ ManimGL本来是打算这个假期用 manim 做视频来着，结果却变成了修 manim / 改 manim总共开了 7 个 pull request，review 了 13 个 pr，发了 3 个 release鸽兰特也给力，基本上 review 之后的当晚十二点就会给 merge 主要干的事呢，有两个 修 SVGMobject，之前也专门发过文章 修复 ManimGL 中的 SVGMobject，学到的 SVG 也放到了 notebook 里。基本上完善了基本的 SVG 需要，包括样式和复杂路径的处理（虽然之后忆拾用更好的方法(指调库)来改进了 SVGMobject） 写类型注解，主要是为了方便用 vsc 的时候提示，以及方便后续写文档。就花了三天多时间爆肝，给 ManimGL 里的所有类方法、函数都添加了类型注解，在 #1736 这个 pr 里，竟然写了 2791+ 1401-，我都觉得不可思议（ 大概还需要很长时间来检查，然后再 merge之后还打算给所有文件添加 __all__，然后规范一下代码格式，再根据一些网站改进一下代码质量鸽了，有时间就搞 _(:з」∠)_ 任务方面暖冬宣讲算是这个假期的一个主要任务（？宣讲队一共六个人，也不是太打得起精神就边摆边干活，糊弄糊弄过去了 虽然但是，效果看上去还是可以的，群里收了 350+ 人，宣讲线上会议也有 110+ 人在听希望没有给浙大丢脸（笑 视频新的一期视频打算和 GZTime、NanoApe 一起讲二维码然后刚考完试就去看了 QRCode 这个包然后按照自己的习惯拿 manim 重写了一个二维码生成器又改了改就成为了新视频的轮子 之后开始写文案和 GZTime 讨论了一下整体的安排之后花了两天写完了全部的文案（“两天”，其中穿插了打 baba、打文字游戏、看开端，乐）大概 260 条，5k+ 字左右 然后做了第一个场景之后累了，就鸽了，留着慢慢做 CTF假期也没打几场比赛，HGAME 没参加，RealWorldCTF 没起到什么作用 VNCTF 个人赛倒是打了打，太拉垮了，所以 writeup 就没往这里发，扔到 note 里留着了：VNCTF 2022 Writeup 生活方面正常过了个年（此处略去……） 作息还是没调整过来，天天一点多睡，早上十点多醒（悲） 学习方面？？？寒假学什么习数分线代想重学，没学上汇编语言也没完整看完一遍下学期的数逻也一点也没看上Rust 想重新学好久了，也没学上 我怎么这么弱啊.jpg shya 次一定，shya 次一定 这么一看这个假期做的事情还是挺多的？(´▽｀)马上开学了，希望我能从一大堆硬课和南方的气候中活下来 _(´ཀ`」 ∠)__","link":"/p/78cef964.html"},{"title":"修复 ManimGL 中的 SVGMobject","text":"今天一天都在修 ManimGL 里的 SVGMobject，还是比较有收获的，写篇文章记录一下起因是 fran 给了一个在 ManimGL 里表现怪异的 svg 文件：formula.svg 它在 ManimGL 下表现的是：不难发现几个问题： 整体上下翻转了 左边多了一条粗线 矩阵大括号中间断开了 角标没有缩放，不在正确位置上 通过检查 svg 源码可以发现主要是两个问题，一个是直接从嵌套在内层的 svg 元素中提取出了物件，二是没有正确处理 svg 的 transform 只从最外层 svg 提取物件这个问题产生的原因是在 SVGMobject.init_points 这个方法中，原来的代码是： 12345678910doc = minidom.parse(self.file_path)self.ref_to_element = {}for svg in doc.getElementsByTagName(&quot;svg&quot;): mobjects = self.get_mobjects_from(svg) if self.unpack_groups: self.add(*mobjects) else: self.add(*mobjects[0].submobjects)doc.unlink() 很明显，这里的 for 循环提取了全部的 svg 标签，然后从中提取出 mobjects 但是这样的话如果有嵌套在 svg 内部的 svg 就也会从中提取 mobjects，但这时就没有了外层的约束，导致重复生成，而且生成的位置错误 在上面那个 svg 中就是这样，大括号分为三个部分，其中中间的一段是复用了一个元素，并且使用的是 svg 标签 解决方法也很直接，直接遍历 doc 的子节点 childNodes，并且判断其 tagName 是否是 “svg”，不是就跳过但这样仍存在一个问题，doc 的子节点可能不是 Element，比如注释，就是 Comment，它并没有 tagName 属性，所以还需要先判断一下这个节点是不是 Element 最终的解决办法： 12345for child in doc.childNodes: if not isinstance(child, minidom.Element): continue if child.tagName != 'svg': continue mobjects = self.get_mobjects_from(child) ... 正确处理 transforms上面 svg 中，角标没有缩放、放到正确位置的原因是，这两个操作在这个 svg 中都使用了 transform 来达成，所以它的值是 “translate(…) scale(…)”，前者负责平移，后者负责缩放 但是 ManimGL 中原来的处理方法是直接使用 “matrix(…)” “translate(…)” “scale(…)” 进行匹配，将中间内容当作参数，如果中途任何环节出现报错，都直接忽略掉但是这样它会将这个 transform 解析成参数为 “…) scale(…” 的一个 translate，这显然会在后面抛出异常 然后就尝试了使用空格分割效果倒是出现了，但是还是有一点问题，角标距离元素的距离太近，对比发现，可能是因为缩放和平移的施加顺序不同导致的 svg 标准中也有说明，transform 应该从右向左依次施加，所以临时的修正写法是： 123transforms = element.getAttribute('transform').split(&quot; &quot;)[::-1]for transform in transforms: ... 但是这样也有问题，因为标准中对于 transform 串的规定很宽松，两个 transform 中间可以不加空格，也可以有任意多空格，名字和左括号中间也可以有空格…… 然后参考了 ManimCE，发现了里面有一个链接，是一个 python 写的 svg 解析器：https://github.com/cjlano/svg 按照里面的写法，使用了正则表达式来匹配名称和参数，根据规范，svg 仅支持 css transform 中的 matrix translate scale rotate skewX skewY，但我顺手还加了 translateX/Y scaleX/Y全部的正则和匹配方法是： 1234567891011121314transform_names = [ &quot;matrix&quot;, &quot;translate&quot;, &quot;translateX&quot;, &quot;translateY&quot;, &quot;scale&quot;, &quot;scaleX&quot;, &quot;scaleY&quot;, &quot;rotate&quot;, &quot;skewX&quot;, &quot;skewY&quot;]transform_pattern = re.compile(&quot;|&quot;.join([x + r&quot;[^)]*\\)&quot; for x in transform_names]))number_pattern = re.compile(r&quot;[-+]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][-+]?\\d+)?&quot;)transforms = transform_pattern.findall(element.getAttribute('transform'))[::-1]for transform in transforms: op_name, op_args = transform.split(&quot;(&quot;) op_name = op_name.strip() op_args = [float(x) for x in number_pattern.findall(op_args)] 其中第一个正则表达式很显然，匹配每一个名称，后面接任意多个非右括号的字符，然后是右括号第二个字符比较复杂，可视化后还是比较清晰的：然后根据标准依次解决就好了： matrix 直接保留原来写好的就可以 translate 平移，translateX 时 y=0，translateX 时 x=0 scale 缩放，注意可能有负的情况，但是 ManimGL 已经禁止 scale 的时候 factor 小于等于 0，所以需要先 flip 一下（这也是为什么上面的公式上下颠倒了，因为有一个 scale(1, -1) 没有施加） rotate 旋转，和 css 里不一样，这里的角度单位都是 deg，并且省去了 deg，而且可能会接受 3 个参数，这时后两个会做为一个坐标，表示旋转的中心点 skewX skewY 倾斜，可以直接转为 matrix： skewX(a): [1., 0., tana, 1., 0., 0.] skewY(a): [1., tana, 0., 1., 0., 0.] 这之后上面的 svg 就可以正确渲染了： 但是这之后还是有 bug，其中一个是老问题，在 path 元素的 string 中，有些时候会省略掉空格，导致原来的 ManimGL 无法处理，另一个是当 M 指令后紧接着 S 指令时，会因为点集内只有一个点而引起错误 正确解析 path string这个问题使用上面的那个正则表达式可以解决一部分，但是还有一个神奇的情况：两个 0 连着出现，也就是 “00”这时后上面的正则会认为这是一个 0.0，而实际上，这是两个 0.0 并在了一起 然后 fran 改了改正则，在前面加了 “0|” 解决了这个问题 但是另一个更神奇的情况出现了：A1.098 1.098 0 11.777 1.875z看到这个第一反应肯定是五个数对吧，但是 A 指令只接受七个数 看了浏览器解析的结果后发现，参数实际上是 1.098 1.098 0 1 1 0.777 1.875而这个是 1 1 .777 三个数而不是 11.777 一个数的原因是，A 指令的第 4、5 个参数是 flag，一定是 0 或 1 这样的话使用正则就很复杂了一顿查找后发现了另一个解析 svg path 的库：https://github.com/regebro/svg.path/ 按照里面的思路，重新写了一个 path 的解析器，即按照规则一个一个读取需要的数据，并且随时删掉开头的空格/逗号其中读取单个浮点数用的还是上边的正则表达式 在重写了 path 解析之后，就很少因为这里出问题了 正确处理 S 指令对于下一个问题，报错出现在 VMobject.get_reflection_of_last_handle： 12345678def add_smooth_cubic_curve_to(self, handle, point): self.throw_error_if_no_points() new_handle = self.get_reflection_of_last_handle() self.add_cubic_bezier_curve_to(new_handle, handle, point)def get_reflection_of_last_handle(self): points = self.get_points() return 2 * points[-1] - points[-2] 这里这样做的原因是，S 指令会把前一个点的控制点关于前一个点中心对称，作为当前点的控制点。而这里仅有一个当前点 point[-1]，而没有控制点 point[-2]，导致了 IndexError 而标准里也说了，如果 S 指令前面没有其他生成路径的指令，直接把当前点当作控制点，所以改一下就好： 1234if self.get_num_points() == 1: new_handle = self.get_points()[-1]else: new_handle = self.get_reflection_of_last_handle() 至此 SVGMobject 的 bug 基本上没剩多少了，但是还有几个标签没有实现，以及没有处理样式 而在样式处理这方面，ManimCE 做的已经很好了，打算有时间去借鉴过来 _(:з」∠)_ 今天修 bug 的全部更改详见：3b1b/manim#1712 Reference SVG Standard cjlano/svg regebro/svg.path 3b1b/manim#1712","link":"/p/81940d35.html"},{"title":"「QRCode 标准阅读」#3 解码纠错过程","text":"&lt; #2 解码（11、Annex B）简要的解码过程： 定位并获取图像中的二维码，并把图像中的黑白块提取为 1 和 0 读取格式信息 释放掩码 101010000010010 进行纠错 如果纠错失败则将二维码镜面对称再尝试 读取版本信息（如果有的话） 读取格式信息中的掩码编号，并释放掩码 读取并恢复数据字和纠错字 纠错，如果检测到了错误就纠正 把数据字解码得到结果 纠错（Annex B）Annex B 讲的纠错过程很简略，而且符号说明不全，很难看懂 去学了学 PGZ 解码：Reed–Solomon_error_correction#Peterson–Gorenstein–Zierler_decoder 设当前版本下每块中有 $n$ 个字，$k$ 个数据字，$n-k$ 个纠错字，纠错容量为 $\\nu$ 首先定义原来的完整数据（即数据字和纠错字）从高位到低位为 $c_{n-1},c_{n-2},\\cdots,c_0$ ，对应多项式为： $$s(x)=\\sum_{i=0}^{n-1}c_ix^i=c_{n-1}x^{n-1}+c_{n-2}x^{n-2}+\\cdots+c_0$$ 而且根据纠错码生成原理，$s(x)$ 可以被生成多项式 $g(x)$ 整除，其中 $$g(x)=\\prod_{i=0}^{n-k-1}(x-\\alpha^i)$$ 所以 $s(x)$ 也有根 $s(\\alpha^i)=0, i=0,1,\\dots n-k-1$ 再设接收到的消息多项式（可能有错）为 $r(x)$ ，误差多项式为 $e(x)$ ，满足： $$r(x)=s(x)+e(x),\\quad e(x)=\\sum_{i=0}^{n-1}e_ix^i$$ 先设一共有 $\\nu$ 个错误，且每个错误的位置为 $i_k,k=0,1,\\dots \\nu-1$，所以有： $$e(x)=\\sum_{k=0}^{\\nu-1}e_{i_k}x^{i_k}$$ 最终的目标就是找到错误个数 $\\nu$，错误位置 $i_k$，以及错误大小 $e_{i_k}$ 计算典型值首先定义典型值（syndromes）为把 $\\alpha^j$ 传入 $r(x)$ 得到的值 $S_j$，有： $$S_j=r(\\alpha^j)=s(\\alpha^j)+e(\\alpha^j)=e(\\alpha^j)=\\sum_{k=0}^{\\nu-1}e_{i_k}(\\alpha^j)^{i_k},j=0,1,\\dots,n-k-1$$ 此时如果得到的典型值都为 0，那说明没有错误 为了方便，再令 $X_k=\\alpha^{i_k},Y_k=e_{i_k}$，这样 $X_k$ 也能用来定位错误，同时也有： $$S_j=\\sum_{k=0}^{\\nu-1}Y_kX_k^j$$ 写成矩阵形式就是： $$\\begin{bmatrix}X_0^0 &amp;X_2^0 &amp;\\cdots &amp;X_{\\nu-1}^0\\\\X_0^1 &amp;X_1^1 &amp;\\cdots &amp;X_{\\nu-1}^1\\\\\\vdots &amp;\\vdots &amp; &amp;\\vdots\\\\X_0^{n-k-1} &amp;X_1^{n-k-1} &amp;\\cdots &amp;X_{\\nu-1}^{n-k-1}\\end{bmatrix}\\begin{bmatrix}Y_0\\\\Y_1\\\\\\vdots\\\\Y_{\\nu-1}\\end{bmatrix}=\\begin{bmatrix}S_0\\\\S_1\\\\\\vdots\\\\S_{n-k-1}\\end{bmatrix}$$ 所以只要求得位置 $X_k$ 就能得到错误大小，但是此时并不是线性的 错误定位多项式定义一个错误定位多项式（error locator polynomial）$\\Lambda(x)$： $$\\Lambda(x)=\\prod_{k=0}^{\\nu-1}(1-xX_k)=1+\\Lambda_1x+\\Lambda_2x^2+\\cdots+\\Lambda_\\nu x^\\nu$$ 可以看出 $\\Lambda(X_k^{-1})=0$，所以对于 $0\\leq j\\leq\\nu-1$ 有： $$Y_kX_k^{j+\\nu}\\Lambda(X_k^{-1}) =0$$ $$Y_{k}X_{k}^{j+\\nu }(1+\\Lambda _{1}X_{k}^{-1}+\\Lambda _{2}X_{k}^{-2}+\\cdots +\\Lambda _{\\nu }X_{k}^{-\\nu })=0$$ $$Y_{k}X_{k}^{j+\\nu }+\\Lambda _{1}Y_{k}X_{k}^{j+\\nu }X_{k}^{-1}+\\Lambda _{2}Y_{k}X_{k}^{j+\\nu }X_{k}^{-2}+\\cdots +\\Lambda _{\\nu }Y_{k}X_{k}^{j+\\nu }X_{k}^{-\\nu }=0$$ $$Y_{k}X_{k}^{j+\\nu }+\\Lambda _{1}Y_{k}X_{k}^{j+\\nu -1}+\\Lambda _{2}Y_{k}X_{k}^{j+\\nu -2}+\\cdots +\\Lambda _{\\nu }Y_{k}X_{k}^{j}=0$$ 所以把 $k$ 从 $0$ 到 $\\nu-1$ 累加起来也为 0： $$\\sum_{k=0}^{\\nu-1}\\left(Y_{k}X_{k}^{j+\\nu }+\\Lambda _{1}Y_{k}X_{k}^{j+\\nu -1}+\\Lambda _{2}Y_{k}X_{k}^{j+\\nu -2}+\\cdots +\\Lambda _{\\nu }Y_{k}X_{k}^{j}\\right)=0$$ 然后转换为每项累加并提取出 $\\Lambda_i$： $$\\left(\\sum _{k=1}^{\\nu }Y_{k}X_{k}^{j+\\nu }\\right)+\\Lambda _{1}\\left(\\sum _{k=1}^{\\nu }Y_{k}X_{k}^{j+\\nu -1}\\right)+\\cdots +\\Lambda _{\\nu }\\left(\\sum _{k=1}^{\\nu }Y_{k}X_{k}^{j}\\right)=0$$ 根据典型值的定义有： $$S_{j+\\nu}+\\Lambda_1S_{j+\\nu-1}+\\cdots+\\Lambda_\\nu S_k=0$$ 把 $S_{j+\\nu}$ 移到右边，并展开所有 $j$ 可以得到矩阵形式： $$\\begin{bmatrix}S_{0}&amp;S_{1}&amp;\\cdots &amp;S_{\\nu-1}\\\\S_{1}&amp;S_{2}&amp;\\cdots &amp;S_{\\nu}\\\\\\vdots &amp;\\vdots &amp;&amp;\\vdots \\\\S_{\\nu-1}&amp;S_{\\nu}&amp;\\cdots &amp;S_{2\\nu -2}\\end{bmatrix}\\begin{bmatrix}\\Lambda _{\\nu }\\\\\\Lambda _{\\nu -1}\\\\\\vdots \\\\\\Lambda _{1}\\end{bmatrix}=\\begin{bmatrix}-S_{\\nu}\\\\-S_{\\nu +1}\\\\\\vdots \\\\-S_{2\\nu-1 }\\end{bmatrix}$$ 此时是一个线性方程组，而且 $S_i$ 全部已知，可以解得 $\\Lambda_i$ 得到错误位置和大小此时多项式 $\\Lambda(x)$ 已经完全已知，所以可以求得其根（用 Chien search 算法在伽罗瓦域上求根） 再算其倒数即可得到 $X_k$ ，然后可以寻找到错误位置 $i_k$ 这时也就可以带入第一个方程组求得错误大小 $Y_k$（或者利用 Forney algorithm） 得到了 $e(x)$ 后就可以根据 $r(x)$ 算出原始信息 $s(x)$ 了","link":"/p/12ee036b.html"},{"title":"「QRCode 标准阅读」#2 纠错码编码与图像生成","text":"&lt; #1 #3 &gt; 纠错码编码（7.5）纠错容量（7.5.1）纠错字（error correction codewords）可以纠正两种错误，一种是比如无法扫描或无法解码的已知位置的错误字（erasures），一种是未知位置的错误字（errors），一个 erasures 可以由一个纠错字纠错，而一个 errors 需要两个纠错字来纠错 可以纠错的 erasures 和 errors 的数量满足： $$e+2t\\leq d-p$$ 其中 $e$ 是 erasures 的数量，$t$ 是 errors 的数量，$d$ 是纠错字的数量，$p$ 是被错误解析的保护字数量 其中 $p$ 由版本决定： $p=3$：版本 1-L $p=2$：版本 1-M、2-L $p=1$：版本 1-Q、1-H、3-L $p=0$：其他所有版本 分块编码纠错码根据版本号及纠错等级，数据序列需要被分成 1 个或多个块，每块内需要单独编码纠错码 如果需要补充的话一律全部补充 0 比特到需要的长度 具体不同版本的分块块数和每块中数量安排以及纠错容量都在文档中 P38-44（pdf 中 P46-52）的大表格 Table 9 中 生成纠错码（7.5.2）伽罗瓦域生成纠错码之前要先将所有数据字转换成一个多项式，使其限制于伽罗瓦域 $GF(2^3)\\bmod 100011101$ 中，而且后续的四则运算也都是该伽罗瓦域中的运算 具体伽罗瓦域的生成原理可以看：https://www.codenong.com/cs105738710/ 简单来说就是多项式的加减法都是异或，乘除法要每一个比特模 2，每一个字节模 100011101（即该伽罗瓦域中的本原多项式 $x^8+x^4+x^3+x^2+1$） 具体多项式 mod 运算的方法可以看：https://blog.csdn.net/yaongtime/article/details/17200401 简单来说就是多项式的长除法取模，而且注意这里的加减都是伽罗瓦域中的加减，即异或 生成多项式（Annex A）纠错码生成多项式的一般表达形式是： $$g(x)=(x-\\alpha^0)(x-\\alpha^1)\\cdots(x-\\alpha^{n-1})$$ 其中 $n$ 为纠错码字的个数，其中 $\\alpha=2$， $\\alpha^k$ 的是在伽罗瓦域下的运算，即： $\\alpha^0 = 1;\\ \\alpha^1=2;\\ \\alpha^2=4;\\ \\cdots;\\ \\alpha^7=128$ $\\alpha^8=256\\bmod 285=256\\oplus 285=29;\\ \\alpha^9=29\\times2=58;\\ \\cdots$ 具体计算 $\\alpha^k$ 的代码： 1234567def alpha(k): res = 1 for _ in range(k): res *= 2 if res &gt;= 256: res ^= 285 return res 文档附录 A 中已经展开了所有可能 $n$ 值下的36个生成多项式 生成纠错码文档里给了一个感觉比较晦涩难懂的图来展示生成纠错码的过程： 不是很容易理解，于是找了另一篇文章：https://blog.csdn.net/ljm1995/article/details/88819664 举个例子，比如要编码 12345678 这八个数字 版本 1-L，查 Table 9 得到分为 1 块，且该块内总字数为 26，数据字数为 19，纠错字数为 26-19=7 根据前面所说，比特流应该是： 0001 0000001000 0001111011 0111001000 1001110 0000 补成 8 的倍数长度： 00010000 00100000 01111011 01110010 00100111 00000000 添加 padding bits（补到 19 个字节）： 00010000 00100000 01111011 01110010 00100111 00000000 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 写成多项式形式，次数是 19 次，整体乘 $x^7$： $$16x^{25}+32x^{24}+123x^{23}+114x^{22}+39x^{21}+236x^{19}+\\\\17x^{18}+236x^{17}+17x^{16}+236x^{15}+17x^{14}+236x^{13}+\\\\17x^{12}+236x^{11}+17x^{10}+236x^{9}+17x^{8}+236x^{7}$$ 再查附录 A 得到次数为 7 的生成多项式，并整体乘 $x^{18}$： $$x^{25}+\\alpha^{87}x^{24}+\\alpha^{229}x^{23}+\\alpha^{146}x^{22}+\\alpha^{149}x^{21}+\\\\\\alpha^{238}x^{20}+\\alpha^{102}x^{19}+\\alpha^{21}x^{18}$$ 然后把第一个多项式除第二个多项式取余数 可以这样计算，把第二个多项式整体乘 16 即 $\\alpha^4$： $$\\alpha^4x^{25}+\\alpha^{91}x^{24}+\\alpha^{233}x^{23}+\\alpha^{150}x^{22}+\\alpha^{153}x^{21}+\\\\\\alpha^{242}x^{20}+\\alpha^{106}x^{19}+\\alpha^{25}x^{18}$$ 计算出系数的值： $$16x^{25}+163x^{24}+243x^{23}+85x^{22}+146x^{21}+\\\\176x^{20}+52x^{19}+3x^{18}$$ 之后与第一个多项式异或得到： $$131x^{24}+136x^{23}+197x^{22}+181x^{21}+216x^{19}+18x^{18}+\\\\236x^{17}+17x^{16}+236x^{15}+17x^{14}+236x^{13}+\\\\17x^{12}+236x^{11}+17x^{10}+236x^{9}+17x^{8}+236x^{7}$$ 这之后最高次就变成了 24 次，重复整个过程直到结果只剩下 7 项（即最高次为 6 次）时即可得到： $$188x^6+247x^5+62x^4+248x^3+53x^2+170x+224$$ 所以纠错码就是：188 247 62 248 53 170 224 转为二进制： 10111100 11110111 00111110 11111000 00110101 10101010 11100000 所以整个二维码的编码区域（除格式信息外）全部内容就是： 00010000 00100000 01111011 01110010 00100111 00000000 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 00010001 11101100 10111100 11110111 00111110 11111000 00110101 10101010 11100000 纠错码可以直接用 python 的 reedsolo 包来求解： 123456&gt;&gt;&gt; from reedsolo import RSCodec, ReedSolomonError&gt;&gt;&gt; rsc = RSCodec(7)&gt;&gt;&gt; list(rsc.encode([16, 32, 123, 114, 39, 0, 236, 17, 236, 17, 236, 17, 236, 17, 236, 17, 236, 17, 236]))[16, 32, 123, 114, 39, 0, 236, 17, 236, 17, 236, 17, 236, 17, 236, 17, 236, 17, 236, 188, 247, 62, 248, 53, 170, 224]&gt;&gt;&gt; list(rsc.encode([16, 32, 123, 114, 39, 0, 236, 17, 236, 17, 236, 17, 236, 17, 236, 17, 236, 17, 236]))[-7:][188, 247, 62, 248, 53, 170, 224] 剩余步骤（7.6~7.10）合成序列（7.6）首先按照 2 中所述给完整信息编码成数据序列，其中也包含 padding bits，且长度为 8 的倍数 然后根据 3.1.1 中所说对数据序列进行分块，然后对每块分别生成纠错码 最后把数据序列的所有块按照字节依次交错合成新的数据序列，然后把纠错码的所有块按照字节交错合成纠错码序列。把新的数据序列和纠错码序列连接在一起，如果总长度不够二维码的容量，则在后面补充 3/4/7 个 0 比特（需要补多少在 Table 1 中有定义） 而且这样也要保证最短的数据块在最前面（已经由 Table 9 定义） 比如 5-H 版本的序列，需要分为 4 块，前两块是 11 个数据字、22 个纠错字，后两块是 12 个数据字、22 个纠错字： 最后的序列就是 $D_1,D_{12},D_{23},D_{35},\\cdots,D_{45},D_{34},D_{46},E_1,E_{23},\\cdots,E_{88}$ 填充数据（7.7）把前面合成的完整消息序列填到二维码中，首先要先填充功能图案，然后预留出格式信息、版本信息的位置 填充时以两列为单位，即每次交替填充两列。从最右下角开始是最高位的比特，然后从右向左从下向上交替填充，到了上界时左转向下继续填充，遇到对齐图案直接穿过，遇到对齐图案边界则变为一行 也可以按照字节来依次填充，如果是向上填充，则最高位在下端，反之在上段。每个字节块内的最高位尽量取最右侧的，但如果最下(上)端只有一个比特的位置，则选它作为最高比特的位置 反正按顺序正常填就行了，遇到东西就绕 掩码遮盖（7.8）填充后的数据还要遮盖一层掩码（异或）来平衡黑白块的数量，以及减少容易产生扫描错误的大块和形似功能图案的部分出现 QR 码一共有 8 种掩码，每个掩码有一个 3 bits 的编号，和一个生成公式。这个公式用来生成掩码图样，以左上为原点，向右、下为正方向，坐标满足这个公式的点在图样中是黑色（1），不满足的是白色（0）。在版本 1 中的掩码图像表现为： 进行掩码操作就是把除去功能图案和版本信息、格式信息之外的数据部分每一块的值与掩码图样异或 整个操作需要生成分别使用不同掩码的 8 个图样，然后计算出损失分数（penalty points score），然后采用损失分数最小的掩码模式作为最终的掩码模式 计算损失分数（7.8.3）虽然进行掩码操作时仅对非功能图案、非版本信息格式信息的数据区域进行掩码，但是计算损失分数时按照整个二维码计算 计算损失分有四个规则： 相邻一行或一列内出现连续五个相同颜色块时损失分 +3，之后连续块数每加一，损失分 +1 寻找内部颜色相同的 2*2 的块，每出现一个损失分 +3 在每行和每列中寻找 10111010000 和 00001011101 ，每出现一个损失分 +40 评估黑色块占全部块数的比例，如果在 45%~55% 间则不增加损失分，在 40%~45%、55%~60% 间则损失分 +10，在 35%~40%、60%~65% 间则损失分 +10*2，以此类推 更详细的例子可以看：https://www.thonky.com/qr-code-tutorial/data-masking 然后对所有掩码结果计算损失分数后选择分数最低的一个作为最终结果 格式信息（7.9）QRCode 的格式信息是 15 bits 的序列，其中前 5 位是数据，后 10 位是针对格式信息的纠错码（由 (15, 5) BCH 码生成） 5 bits 的数据前 2 位是纠错等级标识符，分别是 L -&gt; 01 、M -&gt; 00 、Q -&gt; 11 、H -&gt; 10 后 3 位是上面说到的掩码编号 然后后接 10 bits 纠错码，最后整体异或 101010000010010 防止产生全零数据序列 生成纠错码（Annex C）先得到前 5 bits 的数据，然后化为多项式，整体乘 $x^{10}$，再除以生成多项式 $G(x)=x^{10}+x^8+x^5+x^4+x^2+x+1$ 得到余数转换为后 10 bits 的纠错码 例子 纠错等级 M，掩码编号 101 5 bits 数据： 00101 写为多项式： $x^2+1$ 整体乘 $x^{10}$： $x^{12}+x^{10}$ 除以 $G(x)$： 商 $x^2$，余数 $x^7+x^6+x^4+x^3+x^2$ 余数转为 10 bits 纠错码： 0011011100 加上原数据： 001010011011100 异或 101010000010010： 100000011001110 因为 5 bits 的数据一共只有 32 种情况，所以附录 C 中直接给出了完整的表格： 纠错：最多可以纠正 3 bits 的错误，先把格式信息异或 101010000010010 得到原始序列，然后与 Table C.1 中的有效格式信息进行对比，如果找不到说明有错误。此时仅选择 Table C.1 中与错误格式信息相差比特最少的一个作为纠正后的格式信息即可，如果相差少于等于 3 个比特，则视为纠正成功 填入二维码左上角的格式信息区域填充一份完整的格式信息（最高位在左），左下角和右上角合起来是一份完整的格式信息（最高位在左下角的最下，最低位在右上角的最右）。并且左下角的格式信息上方（位置(4V+9,8)）有一块始终是黑色： 版本信息（7.10）在版本 7 及以上的二维码中需要填入版本信息来确保准确度 版本信息只储存了该二维码的版本号（7～40），一共 18 bits，前 6 bits 为版本号的二进制（从 000111 到 101000），后 12 bits 为由 (18, 6) Golay code 生成的纠错码 不同于格式信息，因为版本号不会出现全零，所以不需要进行掩码操作 生成纠错码（Annex D）和格式信息的纠错码类似，先把前 6 bits 转为多项式，然后整体乘 $x^{12}$，得到的结果除以生成多项式 $G(x)=x^{12}+x^{11}+x^{10}+x^9+x^8+x^5+x^2+x^1$ ，把余数转为 12 bits 二进制就是纠错码了 因为只有 34 个版本有版本信息，所以也就只有 34 种有效的版本信息序列，附录 D 的 Table D.1 中给出了完整的 34 个版本信息序列 和格式信息一样，纠错时对照表格选择相差比特数最小的即可。并且版本信息也只能纠正小于等于 3 个错误 填入二维码在版本 7 以上的二维码中已经预留出了两个 6*3 大小的区域，一个位于左下分割线的上方时序图案左侧，一个位于右上分割线左侧时序图案的上方 按照下图顺序填入即可： 未完待续……「QRCode 标准阅读」#3 解码纠错过程","link":"/p/f956b4.html"},{"title":"「QRCode 标准阅读」#1 构成及数据编码","text":"&lt; #0 #2 &gt; 基础描述及结构（6.1、6.3）基础描述（5.3、6.1） 块位置：左上角为原点 (0, 0) 向下x+，向右y+ 版本表示：Version V-E（其中V是版本号，E是纠错等级） 数据表示：黑块-1 白块-0（可以带背景全部反色） 大小：从版本1到版本40依次是 21x21 ～ 177x177（每增加一个版本，边长增加4） 支持的最多字符数（版本40） 数字模式：7089 字母模式：4296 字节模式：2953 日文模式：1817 纠错等级允许的恢复比例 L：7% M：15% Q：25% H：30% 二维码结构（6.3） 功能图案（function patterns） 特征符（finder pattern）7x7黑圈 5x5白圈 3x3黑块 分割线（separator）在特征符周围的一圈全白区域 时序图案（timing patterns）第7行第7列的两条黑白条纹 对齐图案（alignment patterns）版本1无，版本2-6 1个，版本7-13 6个……（附录E） 静默区（quiet zone）至少4个单位宽 编码区域（encoding region） 格式信息（format information）左上角分割线外一圈，左下角分割线右侧，右上角分割线下侧 版本信息（version information）版本7后才有，在左下分割线上侧，右上分割线左侧 数据及纠错码区域 数据编码（7.4）数据序列（7.4.1）默认的 ECI 模式下，比特流以模式标识符开始。如果不是默认 ECI 模式，则需要从 ECI 头开始： （4 bits）ECI 模式标识符 （8/16/24 bits）ECI Designator 比特流的剩余部分由下面几部分组成： （4 bits）模式标识符 字符数量标识符（长度见下第二个表） 数据比特流 模式 标识符 说明 ECI 0111 数字模式 0001 只包含数字0-9，3个数字 10 bits 字母数字模式 0010 45个字符，0-9A-Z 及9个符号 空格$%*+-./:，2个字符 11 bits 字节模式 0100 每个字符 8 bits 日本汉字模式 1000 结构添加模式 0011 版本 数字模式字符数量标识符长度 字母模式…… 字节模式…… 日文模式…… 1～9 10 9 8 8 10～26 12 11 16 10 27～40 14 13 16 12 ECI 模式（7.4.2）ECI 模式即使用某些特定的字符映射来把字符转换为比特流 而且都使用字节模式来表示数据（即在 ECI 头后的模式标识符为字节模式的 0100） 每个 ECI 都有一个六位数编号（assignment value），可能占 1、2、3 个 codewords，具体标识方式见下表（占1个 codewords 时开头一定是0，占2个时开头一定是10，占3个时开头一定是110）表中 xxxxxxxx 表示编号的二进制 ECI Assignment Value Codewords values 000000 ～ 000127 0xxxxxxx 000000 ～ 016383 10xxxxxx xxxxxxxx 000000 ～ 999999 110xxxxx xxxxxxxx xxxxxxxx 而且 ECI 模式下中途可以更换 ECI 指示器，一个 5C（01011100）表示换新的 ECI，后面要接6个 codewords 即6个数字（十六进制30～39）表示编号，而不是用上表中的表示方法。而 5C 正常情况下表示 \\ ，所以表示 \\ 这个原数据需要用两个 5C 例子 1 使用 ISO/IEC 8859-7（ECI 000009）来表示希腊字母ΑΒΓΔΕ（该 ECI 下表示为十六进制 A1 A2 A3 A4 A5） 比特流： ECI 标识符：0111 ECI 编号：00001001 字节模式标识符：0100 字符数量：00000101（5个字符） 数据：10100001 10100010 10100011 10100100 10100101 所以最终的比特流：0111 00001001 0100 00000101 10100001 10100010 10100011 10100100 10100101 例子 2（14.3） 需要编码的数据：ABC\\123456 数据流中十六进制（字节模式标识符0100后）：41 42 43 5C 5C 31 32 33 34 35 36 需要编码的数据：ABC&lt;后接 ECI 123456 下的数据……&gt; 数据流中十六进制（字节模式标识符0100后）：41 42 43 5C 31 32 33 34 35 36 …… 数字模式（7.4.3）输入的数字字符串（因为开头可以是0）要被分成3个一组，每组会转换为 10 bits 的二进制串（999 -&gt; 1111100111）。剩余不到3个的部分，如果剩2个数字，则将其转换为 7 bits 的二进制串（99 -&gt; 1100011）如果剩1个数字，则将其转换为 4 bits 的二进制串（9 -&gt; 1001） 然后开头加上数字模式标识符 0001 和数量标识符（字符个数转为二进制，并开头补0至长度，长度由版本决定，见上 7.4.1 部分的第二个表） 例子 数据内容： 01234567（保留开头0） 数据流部分： 数字模式标识符： 0001 数量标识符： 0000001000（8，且版本1下规定为 10 bits） 数据： 012 -&gt; 0000001100 345 -&gt; 0101011001 67 -&gt; 1000011 完整数据比特流： 0001 0000001000 0000001100 0101011001 1000011 数字模式下的比特流长度为： $$B=M+C+10\\times\\lfloor\\frac{D}{3}\\rfloor+R$$ 其中 M 为 4，C 为数量标识符长度（版本1～9为 10，版本10～26为 12，版本27～40为 14），D为输入字符个数，R为剩余部分（若 D mod 3 = 0 则为 0，若 D mod 3 = 1 则为 4，若 D mod 3 = 2 则为 7） 字母数字模式（7.4.4）数字字母模式（Alphanumeric mode）下支持的编码字符有45个，把它们从0编号至44。其中 0-9 对应数字 0-9，10-35 对应字母 A-Z，36-44 对应9个符号： 输入的字符先按照上表转换为数值，然后分为两个一组，每一组内把 第一个数值 × 45 + 第二个数值，再转换为长度为 11 bits 的二进制串（最大为 44×45+44=2024 -&gt; 11111101000）。如果字符长度为奇数，则会剩余出一个字符，需要将其值转换为长度为 6 bits 的二进制串（最大为 11 -&gt; 101100） 然后开头加上字母数字模式标识符 0010 和数量标识符（长度由 7.4.1 第二个表规定） 例子 数据内容：AC-42 数据流部分： 字母数字模式标识符： 0010 数量标识符： 000000101（5，且版本1下规定长度为9） 数据：AC-42 -&gt; 10 12 41 4 2 -&gt; (10 12)(41 4)(2) 10 12 -&gt; 10*45+12=462 -&gt; 00111001110 41 4 -&gt; 41*45+4=1849 -&gt; 11100111001 2 -&gt; 2 -&gt; 000010 完整数据比特流： 0010 000000101 00111001110 11100111001 000010 字母数字模式下的比特流长度为： $$B=M+C+11\\times\\lfloor\\frac{D}{2}\\rfloor+6\\times(D\\bmod 2)$$ 其中 M 为 4，C 为数量标识符长度，D 为原数据长度 字节模式（7.4.5）字节模式（Byte mode）下把每个字符根据 Latin-1（ISO/IEC 8859-1）编码成 8 bits（1字节），直接接在字节模式标识符 0100 和数量标识符（长度由 7.4.1 第二个表规定）的后面。 字节模式下的比特流长度： $$B=M+C+8\\times D$$ 其中 M 为 4，C 为数量标识符长度，D 为原数据长度 中文编码中文在转换成比特流的时候也使用字节模式，需要用 UTF-8 编码，每个字符会被编码成 3 个字节 混合模式（7.4.7）一个二维码的数据流中也可以使用多种模式，且不需要特别表示。更换新的模式时只需要正常添加 模式标识符+数量标识符+数据 即可 例子 原始数据：123测试 数据流： 数字模式： 标识符： 0001 数量标识符： 0000000011（3，长度10） 数据：123 -&gt; 0001111011 字节模式：测试 -&gt; E6 B5 8B / E8 AF 95 标识符： 0100 数量标识符： 00000110（6，长度8） 数据： 测 -&gt; 11100110 10110101 10001011 试 -&gt; 11101000 10101111 10010101 完整数据比特流： 0001 0000000011 0001111011 0100 00000110 11100110 10110101 10001011 11101000 10101111 10010101 结束符（7.4.9）在数据的末尾要填充4个0作为结束符，如果容量不足的话可以缩短或省略即能填下则加4个0，填不下则能加几个0就加几个0 填充 padding bits（7.4.10）转换后的数据比特流还需要填充至二维码的数据容量 首先先用 0 补充比特流长度到 8 的整数倍 然后用 11101100 和 00010001 交替填补到二维码数据容量 具体的数据容量由版本号和纠错等级决定，且数据容量（比特）一定为8的倍数，完整数据见文档的 33～36 页（整个 pdf 的第 41～44 页） 注：这个地方 QRazyBox 网站存在 bug，有时无法正常识别填充的 0 比特和 padding bits（即可能把填充的 0 中前四个视为一个 terminator，把后面的 0 才视为属于 padding bits ） 未完待续……「QRCode 标准阅读」#2 纠错码编码与图像生成","link":"/p/1c1e6bbc.html"},{"title":"「Hackergame 2021」#4 Writup 持续破防篇 1","text":"&lt; #3 这里接上一篇，Writeup 的有：阵列恢复、马赛克、minecRaft、密码生成器（其实 minecRaft 应该算“开局上分”篇，但是不好塞了，就放这里了）剩下的就是做不上的了，看官方 Writeup 了（ 阵列恢复大师（这题整整做了我两天多，每天晚上都对着磁盘阵列……） 以下是两个压缩包，分别是一个 RAID 0 阵列的磁盘压缩包，和一个 RAID 5 阵列的磁盘压缩包，对应本题的两小问。你需要解析得到正确完整的磁盘阵列，挂载第一个分区后在该分区根目录下使用 Python 3.7 或以上版本执行 getflag.py 脚本以获取 flag。磁盘数据保证无损坏。 RAID 5虽然 RAID 5 是第二问，而且分数高，但是更好做，而且做出的人也多。因为数据保证无损坏，所以要做的仅仅是找出五个磁盘的顺序和块大小 顺序可以先简单地看看 strings *.img 输出的内容逐个文件看，可以发现每个文件比较靠前的地方会有一段是 git 历史记录的一部分:根据里面的时间可以推断出磁盘的顺序大致是： Qj... -> 60... -> 3R... -> Ir... -> 3D... 只是，这个顺序应该是一个环，谁在第一还没区分出来 在看每个文件的头部，只有 60… 和 3R… 有 “EFI PART”:所以应该是一个在开头，一个在结尾。所以最终的顺序是： 3R... -> Ir... -> 3D... -> Qj... -> 60... 然后需要找到块大小直接丢到 DiskGenius 里组建虚拟 RAID，选左同步，然后可以试出来当块大小是 64k 的时候正好可以拼出完整磁盘然后克隆磁盘生成 img 文件，再挂载，进入，执行 getflag.py 就得到了 flag RAID 0在做 RAID 5 的时候还发现了一个叫 Raid Reconstructor 的软件，可以爆破 RAID 阵列顺序和块大小所以这问也就懒得看了，直接丢给 Raid Reconstructor 来爆破，得到最推荐的顺序： wl. -> jC. -> 1G. -> 5q. -> d3. -> eR. -> RA. -> ID. 和块大小 128k 然后直接用 Raid Reconstructor 的 Copy 导出 img 文件，提取后又得到一个新的 img 文件通过 file 可以看到结果的文件系统是 XFS 12$ file MyDisk.imgMyDisk.img: SGI XFS filesystem data (blksz 4096, inosz 512, v2 dirs) 但是始终无法挂载（搞了一天）可能是 Raid Reconstructor 的问题，所以又用 DiskGenius 试了下因为 win 和 DiskGenius 读不了 XFS 文件系统，所以拼起来之后直接克隆出 img 文件然后拖到 Kali Linux 里挂载，成功挂载后进入、运行 getflag.py 就得到了 flag 马赛克（这道题已经做破防了，本以为是个青铜，结果是个王者……）我做的肯定不是正解，利用二维码纠错能力勉强拿到了 flag，所以就不详细写 writeup 了，主要还是要看官方 wp（逃 大概步骤就是： 读图片 把已知的像素提取出来 把四个小定位块填上 挨个马赛克块寻找使还原的数据平均数与原马赛克值差的绝对值小于1的填补方法 如果只有一种就填上，并且标注已经填好，以后不再搜寻 如果有多种就先放下不填 重复4的过程，这是还会有唯一确定的填补方案。重复4次大概就不剩唯一解了 这时重复4，找出仅有2中填补方法的，选误差最小的填上 然后再重复4 然后重复6 然后重复4 这时可以看到已经还原得差不多了，剩下的不管直接扫码也可以扫出 flag 了 看，做法很烂对吧 minecRaft kk 同学很喜欢玩 Minecraft，他最近收到了一张 MC 地图，地图里面有三盏灯，还有很多奇奇怪怪的压力板。 但他发现这些灯好像不太符合 MC 电磁学（Red stone），你能帮他把灯全部点亮吗？ 注：本题解法与原版 Minecraft 游戏无关。 补充说明：flag 花括号内为让三盏灯全部点亮的最短的输入序列。例如，如果踩踏压力板输入的最短的序列为 abc，则答案为 flag{abc}。 还挺好玩的题，在网页中模拟了一个mc出来看源码看到了引入了 flag.js 文件，所以可能就是要通过它来得到答案： 1&lt;script src=&quot;jsm/miscs/flag.js&quot;&gt;&lt;/script&gt; 也可以看到，最终判断是否正确是通过调用 gyflagh(input) 是否为 true 来判断，而 gyflagh 也在 flag.js 中，所以还是要看 flag.js 但是 flag.js 是经过简单混淆过的，还是要费点时间读一下 其中有四个转换 Str4 Base16 和 Long 的函数可以略掉不管注意到了 _0x381b() 这个函数里有一个列表，而且比较简单，其实它返回的就是这个列表 1['encrypt', '33MGcQht', '6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c', '14021KbbewD', 'charCodeAt', '808heYYJt', '5DlyrGX', '552oZzIQH', 'fromCharCode', '356IjESGA', '784713mdLTBv', '2529060PvKScd', '805548mjjthm', '844848vFCypf', '4bIkkcJ', '1356853149054377', 'length', 'slice', '1720848ZSQDkr'] 但是在 Console 里面调用 _0x381b 得到的却是以 ‘slice’ 开头、’length’ 结尾的列表，将这个列表记为 lst 方便表述而且源码中只有最开头的调用匿名函数里面有 ['push'] 和 ['shift']，所以推测这个匿名函数就是将这个列表循环右移两个位置那这个匿名函数也不用看了 再来看 _0x2c9e() 这个函数： 12345678910function _0x2c9e(_0x49e6ff, _0x310d40) { const _0x381b4c = _0x381b(); return _0x2c9e = function(_0x2c9ec6, _0x2ec3bd) { _0x2c9ec6 = _0x2c9ec6 - 0x1a6; let _0x4769df = _0x381b4c[_0x2c9ec6]; return _0x4769df; } , _0x2c9e(_0x49e6ff, _0x310d40);} 其中 _0x381b4c 是刚刚说的那个列表 lst。然后 return 里面重新定义了 _0x2c9e，但是新的定义里第二个参数并没有用，然后调用返回，所以整个函数就相当于： 1234function _0x2c9e(_0x2c9ec6, ...) { _0x2c9ec6 = _0x2c9ec6 - 0x1a6; return lst[_0x2c9ec6];} 0x1a6 是 422，所以整个函数也就相当于 function(x) { return lst[x - 422]; }同时根据第一行，程序中所有 _0x22517d 也是这个函数 然后看判断答案的 gyflagh 函数 1234567function gyflagh(_0x111955) { const _0x50051f = _0x22517d; let _0x3b790d = _0x111955[_0x50051f(0x1a8)](_0x50051f(0x1b7)); if (_0x3b790d === _0x50051f(0x1aa)) return !![]; return ![];} 没啥特别的，结合 lst 可以得到： 123456function gyflagh(ans) { if (ans[&quot;encrypt&quot;](&quot;1356853149054377&quot;) === &quot;6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c&quot;) { return true; } return false;} 然后就可以结合 lst 中的值和索引，翻译出最重要的函数再进行一些运算，用注释标注一下已知的值就可以得到： 1234567891011121314String[&quot;prototype&quot;][&quot;encrypt&quot;] = function(key) { // key = &quot;1356853149054377&quot; const left = new Array(2); const right = new Array(4); let res = &quot;&quot;; ans = escape(this); // this := ans right = [909456177, 825439544, 892352820, 926364468] for (var i = 0; i &lt; ans[&quot;length&quot;]; i = i + 8) { left[0] = Str4ToLong(ans[&quot;slice&quot;](i, i + 4)); left[1] = Str4ToLong(ans[&quot;slice&quot;](i + 4, i + 8)); code(left, right); res = res + (LongToBase16(left[0]) + LongToBase16(left[1])); } return res; // 6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c}; 再来看 code 函数，根据 &lt;&lt; 4、 ^、 &gt;&gt;&gt; 5 可以大胆推测类似 TEA，然后解码就直接翻过来就好了： 12345678function dec(left, right) { for (var i = 2654435769 * 32; i != 0;) { left[1] -= ((left[0] &lt;&lt; 4 ^ left[0] &gt;&gt;&gt; 5) + left[0] ^ i + right[i &gt;&gt;&gt; 11 &amp; 3]); i -= 2654435769; left[0] -= ((left[1] &lt;&lt; 4 ^ left[1] &gt;&gt;&gt; 5) + left[1] ^ i + right[i &amp; 3]); } console.log(left);} 最后把要得到的 res 分块，每 8 个一组： 16fbde674 819a59bf a1209256 5b4ca2a7 a11dc670 c678681d af4afb67 04b82f0c 然后从后往前，每两个执行 Base16ToLong，然后作为 left 传给 dec 函数解码，然后再 LongToStr4 得到四个字符:拼起来就是 flag 了：flag{McWebRE_inMlnCrA1t_3a5y_1cIuop9i} 密码生成器 小 T 最近又写了一个 web 应用。 他发现很多用户都喜欢设置弱密码，于是决定让所有用户的密码都必须是 16 位长，并且各种符号都要有。为了让大家可以方便生成这样的密码，他还写了一个密码生成器，让用户可以生成符合规则的密码。 但这样果真安全吗？ （感觉这次 Hackergame 题的 tag 都很诡异。这题明明是 misc(general) 为什么打了 binary 的 tag） 看到 binary tag 直接先往 IDA 里面丢，然后报错了，大概是因为部分 winapi 导入不进去的问题（？）然后就不会了…… 对着 IDA 干瞪眼 看题，题目给了一个网站，用来发布展板，看起来只有 admin 用户，而且没有注册系统，所以应该就是要搞到 admin 的密码了再细看网站，特意提到 “网页显示时间”，而且展板后面都有发布时间，点进 admin 的用户页面发现也有注册时间，着实有些许诡异（所以时间应该是一个提示 而写代码的时候设置随机数种子又常以当前时间作为种子，所以生成的密码可能是和时间有关系的通过调系统时间，可以发现在同一秒点下生成，产生的密码是一样的所以只需要把系统时间调到 admin 的注册时间左右，然后每秒生成密码，再挨个输进去爆破即可 最后得到 2021-09-22 23:10:53 时生成的密码 $Z=CBDL7TjHu~mEX 就是 admin 的密码然后登录即可在“我的”里看到一条私密展板，内容是 flag （其实这题搞得闹心的是每秒生成密码，像我这样的原始人只会反复调时间然后手动生成、复制粘贴，然后再复制粘贴检验密码）（而且其实这个时间也试了很长时间，试了 23:11 的所有秒，15:11 的所有秒（考虑到了提到的时区问题））（然后一共 120s 里也没有正确密码，就很闹心，最后的时间是 23:11 的前一分钟里的……我当时甚至想了，这些操作在一分钟之内都能完成，然后就没考虑前一分钟生成密码、后一分钟注册的问题……）（于是就有了： 好了，我做上的题也就这些了，勉勉强强混了 4k2pt没做上的题也好多：Amnesia2、赛博厨房23、灯、只读、一石二鸟、GPA、链上预言家、助记词2、Co-Program、外星人、befun、fzuu、wish、OI逆向（草，好多qwq）剩下的就看官方 Writeup 了（ Reference RAID 相关的好多文章，没留作记录","link":"/p/d11ec8ed.html"},{"title":"「Hackergame 2021」#3 Writup 持续破防篇 0","text":"&lt; #2 #4 &gt; 完成了前面两篇说到的那些题后，剩下的就开始反复折磨我了qwq每天基本都肝到一点左右，甚至四五个小时毫无成果_(´ཀ`」 ∠)__其中有些题回过头来看其实很简单，但是做的时候就是死活想不出来（ 这篇 Writeup 里面有：Amnesia1、RSA、LUKS、MicroWorld Amnesia轻度失忆 你的程序只需要输出字符串 Hello, world!（结尾有无换行均可）并正常结束。 编译指令：gcc -O file.c -m32 运行指令：./a.out 编译后 ELF 文件的 .data 和 .rodata 段会被清零。 ELF（Executable and Linkable Format）是 Linux 下常用的可执行文件格式，其中有很多不同的节： .text 节：程序运行需要的代码 .data 节：存放可修改的数据，一般是非 const 全局变量和静态变量 .rodata 节：即 read only data，一般是常量或者字符串 .bss 节：没有被初始化的变量 …… 而这道题目则是在编译生成可执行文件 a.out 后，清空 .data 和 .rodata首先不妨正常编写一个输出 “Hello, world!” 的程序： 1printf(&quot;Hello, world!\\n&quot;); 然后编译，再拖到 IDA 里可以发现，此时的 “Hello, world!” 被放到了 .rodata 节中，会被清除掉，所以这样写不行 直接使用字符串会被放到 .rodata 中清除，写成全局变量又会放到 .data 中但是，如果写成局部变量呢： 12char str[] = &quot;Hello, world!\\n&quot;;printf(str); 编译，拖到 IDA 里可以看出，这次的字符串直接写到了 .text 节中，删掉了 .data .rodata 也没有影响所以把这个代码交上去就可以输出 “Hello, world!“ 拿到 flag 了 清除记忆直接把 .text 节全删掉了，想了很久也不知道咋搞，虽然可以 __attribute__ ((section (“…”))) 来把函数或变量塞到指定的节中。但还是不清楚要怎么解决段错误的问题qwq Easy RSA 自从 Hackergame 2018 公然揭露了大整数可以被神童口算分解的事实，RSA 在 hackergame 中已经只能处于低分值的地位了。如果不在其名称前面加上 Easy 这个单词，似乎就会显得完全对不起其他题目。 更何况，在本题的附件中，你还获得了构造 p 和 q 的方式。数理基础扎实的你应该可以轻松解决这些问题吧。 谢邀，没有数理基础 看代码！ 12345678910111213141516171819202122232425262728293031e = 65537def get_p(): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 value_p = sympy.nextprime((math.factorial(y)) % x) # Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征 return value_pdef get_q(): value = [getPrime(256)] for i in range(1, 10): value.append(sympy.nextprime(value[i - 1])) print(&quot;value[-1] = &quot;, value[-1]) # value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967 n = 1 for i in range(10): n = n * value[i] q = getPrime(512) value_q = pow(q, e, n) print(&quot;value_q = &quot;, value_q) # value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 return sympy.nextprime(q)# this destroyes the rsa cryptosystemp = get_p()q = get_q()m = int.from_bytes(open(&quot;flag.txt&quot;, &quot;rb&quot;).read(), &quot;big&quot;)c = pow(m, e, p * q)print(&quot;c = &quot;, c)# c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478 可以看到，其中要解决的就是 get_p() 中 y! % x 溢出的问题，以及 get_q() 中 q 是哪个随机的512位质数的问题 get_p代码里也给了 Hint，观察 x 和 y 的特征。x 和 y 都很大，但是两个的差并不大；而且可以丢到 python 里验证出 x 是一个质数所以可以使用威尔逊定理也查到了威尔逊定理在 RSA 题目中的应用：BUU-RSA [RoarCTF2019]babyRSA 要求 y! % x（x是质数）根据威尔逊定理，有 $$(x - 1)! \\equiv -1\\pmod{x}$$ 所以： $$y!\\times \\frac{(x - 1)!}{y!}\\equiv -1\\pmod{x}$$ 令 $k = \\dfrac{(x - 1)!}{y!} = (y+1)(y+2)…(x-1)x$ ，所以有： $$y!\\equiv -\\mathrm{inv}(k, x)\\pmod{x}$$ （其中 $\\mathrm{inv}(k, x)$ 表示模 x 下 k 的逆元）所以重写 get_p() 即可正确的得到 p： 12345678def get_p(): x = ... y = ... k = 1 for i in range(y + 1, x): k = (k * i) % x res = (-gmpy2.invert(k, x)) % x return sympy.nextprime(res) get_q相比来说，get_q 就没那么需要技巧了给出了 value[-1] 的值，所以可以直接用 sympy.prevprime 逆推出整个 value 数组 1234value = [80096058210213458444437404275177554701604739094679033012396452382975889905967]for i in range(1, 10): value.append(sympy.prevprime(value[i - 1]))print(&quot;value[-1] = &quot;, value[-1]) 后面计算 value_q 细看其实也是一个 RSA 算法： q：密文 e：私钥 value_q：明文 n：就是 n，只不过不是两个质数相乘，是十个质数相乘 十个质数相乘得到 n 的 RSA 算法也一样，因为 RSA 的正确性并没有要求 n 一定是两个大质数相乘，这样只是难以破解保证安全性解决这个同样也是需要公钥 d，所以需要 phi(n)根据欧拉函数的性质，phi(n) 等于 n 的所有质因数减一的积即 phi(n) = (value[0] - 1) * (value[1] - 1) * … * (value[9] - 1) 再解密即可得到密文 q，然后也就得到了 get_q 的结果 123456789n = phi = 1for i in range(10): n = n * value[i] phi *= (value[i] - 1)value_q = ...d = pow(e, -1, phi) q = pow(value_q, d, n)return sympy.nextprime(q) flag搞定了 get_p 和 get_q 之后就可以直接解出 flag 了： 123456789e = 65537p = get_p()q = get_q()c = ...d = pow(e, -1, (p-1) * (q-1))m = pow(c, d, p * q)print(int.to_bytes(m, 30, byteorder=&quot;big&quot;)) 加密的 U 盘（本来挺好做的一道题，怎么题给的提示我就硬是没领会到） 这是一个关于 LUKS (Linux Unified Key Setup) 的故事。 第一天小 T：「你要的随机过程的课件我帮你拷好了，在这个 U 盘里，LUKS 加密的密码是 suijiguocheng123123。」小 Z：「啊，你又搞了 Linux 文件系统加密，真拿你没办法。我现在不方便用 Linux，我直接把这块盘做成磁盘镜像文件再回去处理吧。」 第二天小 Z：「谢谢你昨天帮我拷的课件。你每次都搞这个加密，它真的安全吗？」小 T：「当然了！你看，你还给我之后，我已经把这块盘的弱密码改掉了，现在是随机生成的强密码，这样除了我自己，世界上任何人都无法解密它了。」小 Z：「我可不信。」小 T：「你不信？你看，我现在往 U 盘里放一个 flag 文件，然后这个 U 盘就给你了，你绝对解密不出来这个文件的内容。当初搞 LUKS 的时候我可研究了好几天，班上可没人比我更懂加密！」 一共给了两个 img 文件，通过 file 可以看出都是 DOS/MBR boot sector 123$ file *.img day1.img: DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 40959 sectors, extended partition table (last)day2.img: DOS/MBR boot sector; partition 1 : ID=0xee, start-CHS (0x0,0,2), end-CHS (0x3ff,255,63), startsector 1, 40959 sectors, extended partition table (last) 所以先直接 7z 提取，得到两个新的 img，再 file： 123$ file *.img My Disk.img: LUKS encrypted file, ver 2 [, , sha256] UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998My Disk 2.img: LUKS encrypted file, ver 2 [, , sha256] UUID: e9a660d5-4a91-4dca-bda5-3f6a49eea998 发现都是 LUKS encrypted file 在 Kali Linux 里尝试直接挂载第一个 img，要求输入密码，把题给的密码输入就可以看到 “课件” 以上都是已知的试验部分，真正要做的是解开第二个未知密码的 LUKS img已知磁盘的加密使用的是 luks2，在网上查了破解 luks2 之类的都说 luks2 不可破解，或者是使用已知的密码字典来爆破但是题里说了 “随机生成的强密码”，所以也是没有密码字典的 其实这道题的最大提示就在于它给了两个 img，既然第一个 img 打开后仅仅是一个课件，如果它的用处仅仅是用来试验 luks 怎么打开的话，根本它没必要给出所以第一个 img 肯定还是有用的。 再看题目，反复说了 U 盘，所以这两个 img 应该是同一个 U 盘的镜像文件，只是更改了密码而已（file 看到的 uuid 也是一致的）于是继续必应，发现同一个磁盘的 master-key 是一样的，而且可以用 master-key 来添加密码恢复磁盘（见：10 Linux cryptsetup Examples for LUKS Key Management） 所以就跟着文章里的做法，从第一个 img 中提取出 master-key，然后用它来提供 AddKey 的权限。添加了新 passphrase 后就可以用新密码打开磁盘了： 1234567891011$ cryptsetup luksDump --dump-master-key MyDisk.img # 输出 master-key...MK dump: be 97 db 91 5c 30 47 ce 1c 59 c5 c0 8c 75 3c 40 72 35 85 9d fe 49 c0 52 c4 f5 26 60 af 3e d4 2c ec a3 60 53 aa 96 70 4d f3 f2 ff 56 8f 49 a1 82 60 18 7c 58 d7 6a ec e8 00 c1 90 c1 88 43 f8 9a$ cat &quot;be...9a&quot; &gt; master_key.txt # 存入文件$ xxd -r -p master_key.txt master_key.bin # 转为二进制$ cryptsetup luksAddKey MyDisk2.img --master-key-file &lt;(cat master_key.bin) # 添加密码Enter new passphrase for key slot: # 输入新密码即可，因为master-key-file相当于提供了原始密码Verify passphrase: （一定要用 root 权限才可以加密码）然后挂载、输入密码，就可以看到 flag.txt 了 Micro World 宇宙中某一片极其微小的区域里的粒子被一股神秘力量初始化设置成了 flag 的形状，程序忠实地记录了一段时间之后这片区域的粒子运动情况。 拿到了 exe 文件，看起来挺精致，运行起来是一些点运动碰撞的场景拖到 IDA 里看看，发现了 __main__ 以及 .rdata 里一些 py 有关的字符串：所以推测是使用 python 编写的，然后用 pyinstaller 打包 这样的话试着用 pyinstxtractor 解包 .exe，成功得到一个文件夹里面是一堆 .pyc .pyd .dll 文件，从名字就可以看出大部分是 import 的包，只有一个特别的 2.pyc所以这个应该就是编译后的源码了 接下来用 uncompyle6 来反编译 pyc 文件，输出得到了源码 2.py尝试运行，发现跑起来之后只有一个点在运动，应该是反编译时出了些问题于是开始看源码 基本上简单说就是，初始有一些数据，表示每个点的位置和速度，然后运行，每次运行都检测碰撞，然后获得新的点位置，再绘制出来调试一下，输出每次的 pointlist，发现第一次是所有点，第二次变成2个，第三次往后就只有一个了所以问题大概就出在了 next_pos_list 函数： 12345678910111213141516171819def next_pos_list(Pointlist): pointlist = [] for i in range(len(Pointlist)): for point in Pointlist[i + 1:]: times = checkcrush(Pointlist[i], point) if times != None: a, b = get_new_point(times, Pointlist[i], point) pointlist.extend([a, b]) Pointlist[i].flag = 0 point.flag = 0 else: for item in Pointlist: if item.flag != 0: pointlist.append(Point((item.x + item.vx, item.y + item.vy), item.vx, item.vy)) for poi in pointlist: poi.x = poi.x % WIDTH poi.y = poi.y % HEIGHT else: return pointlist 仔细读一读，可以发现这里面的 for-else 块很奇怪，导致循环结束和 return 都早了，所以根据函数的意思改一改： 12345678def next_pos_list(Pointlist): pointlist = [] for i in range(len(Pointlist)): for point in Pointlist[i + 1:]: ... for item in Pointlist: ... return pointlist 这样就可以成功运行了 但是画面仍然是杂乱的。因为题里说了 “记录了一段时间之后这片区域的粒子运动情况”所以需要将轨迹往前推，最方便的方法就是更改每个点的速度方向： 123Pointlist = []for item in list_: Pointlist.append(Point((item[0], item[1]), -item[2], -item[3])) 运行后等待一小会儿就可以看到点逐渐有序，在某一刻汇成了 flag：虽然不太清晰，但是也可以猜个大概 又写了蛮长的，剩下的放在下一篇(:з」∠) Reference Wilson’s theorem - wikipedia BUU-RSA [RoarCTF2019]babyRSA - CSDN Euler’s totient function - wikipedia LUKS2 doc pdf 10 Linux cryptsetup Examples for LUKS Key Management pyinstxtractor uncompyle6 &lt; #2 #4 &gt;","link":"/p/f152ab1f.html"},{"title":"「Hackergame 2021」#2 Writup 开局上分篇 1","text":"&lt; #1 #3 &gt; 这里接上一篇，Writeup 的有：大砍刀、图之上、赛博厨房01、助记词1、p😭q有些虽然偏后、分值高，但是总体并不难 FLAG 助力大红包 参与活动，助力抽奖！集满 1 个 flag，即可提取 1 个 flag。 恭喜你积攒到 0.5…… 个 flag，剩余时间：10分00秒 已有 0 位好友为您助力。 将如下链接分享给好友，可以获得好友助力，获得更多 flag：…… 老并夕夕了，经过一些测试和看规则可以知道，ip 在同一 /8 网段的用户被视为同一用户，即 ip 地址的第一个点前面的数字不一样才是不同用户再用虚拟机和手机试一下，发现每个用户增加的 flag 数量很小所以推测需要200+个 ip 地址，肯定不会要真的转发，而且也很难凑出很多不在同一 /8 网段的 ip 于是在 BurpSuite 里面抓包可以看到，每次点击“助力”都会发送一个到助力链接的 POST，内容为 ip 地址然后将其发送到 Repeater 中，尝试更改 ip 地址，得到的 Response 中说 “失败！检测到前后端检测 IPv4 地址不匹配” 所以仅仅更改 POST 内容的 ip 是不够的，而提供给检测的内容也仅仅是一个 POST，所以可以更改 POST 头，添加 X-Forwarded-For然后使用 python 就可以循环发送 POST 并伪造 ip 地址得到256个助力了，刚好达到1个flag：（要注意 sleep 一段时间，不然会出现操作过快拒绝的情况；也不要 sleep 过长，否则超过10分钟 flag 就无效了） 1234567891011121314import requests import timefrom tqdm import tqdmurl = &quot;http://202.38.93.111:10888/invite/...&quot;with tqdm(total=256) as pbar: for i in range(256): res = requests.post(url, data={&quot;ip&quot;: f&quot;{i}.0.0.0&quot;}, headers={&quot;X-Forwarded-For&quot;: f&quot;{i}.0.0.0&quot;}) if &quot;成功&quot; not in res.text: print(&quot;[x] 失败&quot;) print(res.text) time.sleep(1.5) pbar.update(1) 图之上的信息 小 T 听说 GraphQL 是一种特别的 API 设计模式，也是 RESTful API 的有力竞争者，所以他写了个小网站来实验这项技术。 你能通过这个全新的接口，获取到没有公开出来的管理员的邮箱地址吗？ 题目信息给的很充分，用的是 GraphQL，要用其得到 admin 的邮箱 没接触过 GraphQL，所以直接必应（逃查到了很多有用的东西： GraphQL官网：了解一下 GraphQL 是干什么的，要怎么用 GraphiQL：一个进行 GraphQL 查询的 GUI 【安全记录】玩转GraphQL - DVGA靶场（上）- 知乎 GraphQL Voyager：可视化现实 GraphQL 内省出的结构 简而言之，GraphQL 就是一个可以通过一次 query 请求查询多个资源的 API 模式，只要 网址/graphql?query=... 就可以实现查询有些使用 GraphQL 的网站可以直接通过访问 网址/graphiql 得到查询的 GUI但是本题中禁止了，但可以使用 GraphiQL 软件来进行查询 在第三个链接中可以了解到，可以利用 GraphQL 的内省查询来泄露出内部的结构，把其中的查询语句丢到 GraphiQL 中可以得到结果 1query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } directives { name description locations args { ...InputValue } } }}fragment FullType on __Type { kind name description fields(includeDeprecated: true) { name description args { ...InputValue } type { ...TypeRef } isDeprecated deprecationReason } inputFields { ...InputValue } interfaces { ...TypeRef } enumValues(includeDeprecated: true) { name description isDeprecated deprecationReason } possibleTypes { ...TypeRef }}fragment InputValue on __InputValue { name description type { ...TypeRef } defaultValue}fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } }} 然后把结果丢到 GraphQL Voyager 中就可以得到可视化的结构： 所以只需要根据 id query 一下 user 就可以了： 123456789query { user(id: 1) { privateEmail, } }&gt;&gt;&gt; { &quot;data&quot;: { &quot;user&quot;: { &quot;privateEmail&quot;: &quot;flag{...}&quot; } }} 赛博厨房 虽然这是你的餐厅，但只有机器人可以在厨房工作。机器人精确地按照程序工作，在厨房中移动，从物品源取出食材，按照菜谱的顺序把食材依次放入锅内。 机器人不需要休息，只需要一个晚上的时间来学习你教给它的程序，在此之后你就可以在任何时候让机器人执行这个程序，程序的每一步执行都会被记录下来，方便你检查机器人做菜的过程。 另外为了符合食品安全法的要求，赛博厨房中的机器人同一时间手里只能拿一种食物，每次做菜前都必须执行清理厨房的操作，把各处的食物残渣清理掉，然后回到厨房角落待命。 每天的菜谱可能不同，但也许也存在一些规律。 对机器人编程可以使用的指令有（n, m 为整数参数，程序的行号从 0 开始，注意指令中需要正确使用空格）： 向上 n 步向下 n 步向左 n 步向右 n 步放下 n 个物品拿起 n 个物品放下盘子拿起盘子如果手上的物品大于等于 n 向上跳转 m 行如果手上的物品大于等于 n 向下跳转 m 行 赶紧进入赛博厨房开始做菜吧！ 刚看题还是挺懵的，想了好半天才明白简单说来就是，每天可以编写新的程序，但是只能运行一个之前编写过的程序每个程序只有几种指令可以使用，需要在其中满足菜谱的顺序要求 而问题在于，编写程序后的第二天的菜谱可能会不同，导致前面编写的程序无法使用所以就需要预测第二天的菜谱 Level 0可以看到第 0 天的菜谱是 1, 0，也就是要在同一个程序中依次向锅(1,0)中放入 1 号食物(0,2)和 0 号食物(0,1)随便编写程序保存，直接到下一天，可以发现菜谱发生了变化多次尝试之后发现菜谱只有 0,0 / 0,1 / 1,0 / 1,1 四种 所以在第 0 天编写学习四个程序，到下一天就可以根据菜谱来执行了例如程序 1,0 就可以编写为： 123456789101112向右 2 步拿起 1 个物品向左 2 步向下 1 步放下 1 个物品向上 1 步向右 1 步拿起 1 个物品向左 1 步向下 1 步放下 1 个物品向上 1 步 只要正确了一天，就可以拿到 flag 了 Level 1只有 1 个食物，菜谱是好多 0同样随便编写程序保存进入下一天，发现菜谱没有变化，还是 73 个 0所以这一关可能只是循环的教程可用的指令中有一条 “如果手上的物品大于等于 n 向上跳转 m 行”可以用它来达到循环的效果 只需要拿 73 个物品，然后循环放下直到手中没有了即可 123456向右 1 步拿起 73 个物品向左 1 步向下 1 步放下 1 个物品如果手上的物品大于等于 1 向上跳转 1 行 同样保存下一天执行就可以拿到 flag 了 剩下的两个看起来大概是通过源码来推测出菜谱的生成方法，然后编写相应的指令，太难了，不会qwq 助记词题目有效内容： 你的室友终于连夜赶完了他的 Java 语言程序设计的课程大作业。看起来他使用 Java 17 写了一个保存助记词的后端，当然还有配套的前端。助记词由四个英文单词组成，每个用户最多保存 32 条。 你从他充满激情却又夹杂不清的表述中得知，他似乎还为此专门在大作业里藏了两个 flag：当访问延迟达到两个特殊的阈值时，flag 便会打印出来，届时你便可以拿着 flag 让你的室友请你吃一顿大餐。 下载到源码后翻一翻，有用的就只有 Phrase.java 和 Instance.java其中 Phrase.java 定义了 Phrase，其中重载了 equals 方法，其中有： 123456try { TimeUnit.MILLISECONDS.sleep(EQUALS_DURATION_MILLIS); // 20ms // TODO: remove it since it is for debugging} catch (InterruptedException e) { throw new RuntimeException(e);} 所以在每次比较相等的时候就会 sleep 20ms 而 Instance.java 的 post 方法中对于每次的输入，遍历输入的列表，然后逐个加进 HashMap 中在加入 HashMap 的时候就涉及到判断是否相等而最终会判断在完成前后的总的时间间隔是多少，如果大于 600ms 就提取出第一个 flag： 123456789101112var modified = 0;var before = System.nanoTime();for (var i = 0; i &lt; input.length() &amp;&amp; i &lt; MAX_PHRASES &amp;&amp; phrases.size() &lt; MAX_PHRASES; ++i) { var text = input.optString(i, &quot;&quot;).toLowerCase(Locale.ENGLISH); modified += phrases.add(Phrase.create(this.mnemonics, text, token)) ? 1 : 0; // 这里会 sleep}var after = System.nanoTime();var duration = TimeUnit.MILLISECONDS.convert(after - before, TimeUnit.NANOSECONDS);if (duration &gt; FLAG1_DURATION_MILLIS) { // 600ms token.addFlag(1, flag -&gt; output.put(&quot;flag1&quot;, flag));} 而在网页中添加条目的时候，一次只能添加一条，也就是一个 POST 里面只有一个 Phrase但是源码中有一个循环，遍历整个 input，所以一个 POST 里的内容其实是一个列表所以可以用 BurpSuite 获取 POST 然后更改一下内容再发送出去（先 random 一个，然后 add）根据 flag 里的提示，正解（第二顿大餐）应该是使用哈希碰撞，但是不会 p😭q 学会傅里叶的一瞬间，悔恨的泪水流了下来。 当我看到音频播放器中跳动的频谱动画，月明星稀的夜晚，深邃的银河，只有天使在浅吟低唱，复杂的情感于我眼中溢出，像是沉入了雾里朦胧的海一样的温柔。 这一刻我才知道，耳机音响也就图一乐，真听音乐还得靠眼睛。 （注意：flag 花括号内是一个 12 位整数，由 0-9 数位组成，没有其它字符。） 虽然这题是在倒数第三题，还值 400pt，但你一说傅里叶我可就不困了嗷 下载题目包，有一个生成 gif 的 py 代码和那个 gif 文件正好前面的电波也有一段音频，可以用那个带入到 generate_sound_visualization.py 中生成一个 gif，然后用这个来测试 再仔细看一看 generate_sound_visualization.py 这个文件主要使用了 librosa，于是就可以翻文档来看懂这个程序： 123456789101112y, sample_rate = librosa.load(&quot;flag.mp3&quot;) # 从mp3中读取数据和采样率spectrogram = numpy.around( # 四舍五入，但会造成逆向的时候有少许误差导致杂音 librosa.power_to_db( # 把以功率为单位的频谱图转换为以分贝为单位 librosa.feature.melspectrogram( # 通过音频数据和采样率计算梅尔频谱 y, sample_rate, n_mels=num_freqs, n_fft=fft_window_size, hop_length=frame_step_size, window=window_function_type ) ) / quantize # 除以2) * quantize # 乘以2 然后又通过一些 numpy 的骚操作来生成每一帧的数据，然后通过 array2gif 包的 write_gif 函数来生成 gif 所以主要思路就是把整个程序完整地逆过来 由于必应没有查到 gif2array 的包，所以读取 gif 就用了经典 PIL.Image： 123456789from PIL import Imagefile = Image.open(&quot;flag.gif&quot;)try: while True: gif_data.append(np.array(file)) file.seek(file.tell() + 1)except: print(&quot;[+] Read gif file&quot;) 然后是解决那一大段 numpy 骚操作的逆骚操作（但是数理基础这么差的我当然是不想仔细研究了，所以直接用电波那题的 radio.mp3 带入，看一看要得到的 spectrogram 是什么样子输出得到的 spectrogram 是： 1234567[[-58. -48. -30. ... -58. -58. -58.] [-58. -44. -26. ... -58. -58. -58.] [-58. -40. -16. ... -58. -58. -58.] ... [-58. -42. -30. ... -58. -58. -58.] [-58. -44. -32. ... -58. -58. -58.] [-58. -46. -34. ... -58. -58. -58.]] 而转置过来是： 1234567[[-58. -58. -58. ... -58. -58. -58.] [-48. -44. -40. ... -42. -44. -46.] [-30. -26. -16. ... -30. -32. -34.] ... [-58. -58. -58. ... -58. -58. -58.] [-58. -58. -58. ... -58. -58. -58.] [-58. -58. -58. ... -58. -58. -58.]] 减去 min_db=-60 第一行正好是 2，第二行是 [12. 16. 20. … 18. 16. 14.]再对应到生成的 gif 文件中，可以看出 gif 的第一帧每个矩形的高度都是 2而第二帧每个矩形的高度也恰好是刚得出的那组数所以要得到的 spectrogram 就是 gif 每一帧所有矩形的高度构成的矩阵的转置 再结合源码： 1234567numpy.array([ [ red_pixel if freq % 2 and round(frame[freq // 2]) &gt; threshold else white_pixel for threshold in list(range(min_db, max_db + 1, quantize))[::-1] ] for freq in range(num_freqs * 2 + 1)]) 可以看出，每个矩形加上左边的空格正好是 4 个像素，所以每四列读取最后一列即可： 12345678910spectrogramT = []for data in gif_data: res = [] for ind, line in enumerate(data.transpose()): # 将每一帧转置，方便计算 num = sum(line) # 计算每个矩形的高度（转置后是宽度） if ind % 4 == 3: res.append(num + min_db) # 得到的数要加上-60才符合规矩 spectrogramT.append(res)spectrogram = np.array(spectrogramT).transpose() # 得到的结果转置一下 这样就得到了梅尔频谱图的数据，可以对 librosa 的部分进行逆过程了翻 librosa 的文档，有 power_to_db 当然也就有 db_to_power而且类似于 melspectrogram 函数在 librosa.feature 中，可以专门看 feature 部分的文档翻到了 inverse 部分，可以看到有一个函数 librosa.feature.inverse.mel_to_audio 可以直接把梅尔频谱图专为音频数据，所以就用它了： 1234567y = librosa.feature.inverse.mel_to_audio( librosa.db_to_power(spectrogram), # 乘二除二没什么大用，而且影响效果，就删了 sample_rate, n_iter=num_freqs, # 采样率题目提供了，是 22050Hz n_fft=fft_window_size, hop_length=frame_step_size, window=window_function_type,) 这样就完成了还原，最后是输出，但是并没在 librosa 中找到音频输出的函数，所以就用了经典 soundfile： 12import soundfile as sfsf.write(&quot;flag.wav&quot;, y, sample_rate) 然后打开听就行了，题目说了是个 12 位数，所以剩下的就是英语听力了，翻译过来的数字就是 flag 了 基本上我觉得比较简单的也就这些了，剩下的令我破防的放下一篇_(:з」∠)_ Reference 伪造http请求ip地址 - 博客园 GraphQL官网、GraphiQL、GraphQL Voyager 【安全记录】玩转GraphQL - DVGA靶场（上）- 知乎 librosa文档 PySoundFile文档 &lt; #1 #3 &gt;","link":"/p/f54b44c.html"},{"title":"「Hackergame 2021」#1 Writup 开局上分篇 0","text":"&lt; #0 #2 &gt; 这篇 Writeup 写一下 Hackergame 2021 里面比较好做的一些题目做法（以及吐槽）：签到、十六进制、电波、猫咪问答、卖瓜、透明文件、旅行照片 开局基本上就靠这些上分了（逃也都是看上去就知道该怎么做，只是实现的难度不同了（ 签到 为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！ 很明确，进入网址后一直点 Next 翻到比赛时间就好了（误 看到了 URI 里有 ?page=...，所以也懒得计算了，手动二分，大概 ?page=1635000000 左右就可以看到 flag 了 赛后才反应过来原来是 UNIX 时间戳 进制十六——参上也很明确，直接把右侧挡住的 flag 部分对应左边的十六进制数换算成十进制，然后根据 ASCII 码转成字符。或者直接把左侧抄进 Hex Friend 也可以直接得到右侧的flag。 （**当时这题抄串行了两三次……） 去吧！追寻自由的电波 当然，如果只是这样还远远不够。遵依史称“老爹”的上古先贤的至理名言，必须要“用魔法打败魔法”。X 同学向上级申请到了科大西区同步辐射实验室设备的使用权限，以此打通次元空间，借助到另一个平行宇宙中 Z 同学的法力进行数据对冲，方才于乱中搏得一丝机会，将 flag 用无线电的形式发射了出去。 考虑到信息的鲁棒性，X 同学使用了无线电中惯用的方法来区分字符串中读音相近的字母。即使如此，打破次元的强大能量扭曲了时空，使得最终接受到的录音的速度有所改变。 （这题在群里看起来好像卡了很多人，不知道为什么）题目下载下来是一个听起来杂乱的音频 题里最后说了 “最终接受到的录音的速度有所改变”，所以考虑将音频时间拉长。最开始使用了 Adobe Audition，但是效果不是很理想，大概是重新采样等一系列算法导致的所以换了 Adobe Premier Pro 直接用比率拉伸工具拉长音频，还是可以听清的不断尝试之后，大概放慢三倍左右就可以听出读的是英语单词了 题里说到了 “考虑到信息的鲁棒性，X 同学使用了无线电中惯用的方法来区分字符串中读音相近的字母”，所以就查到了国际航空无线电通讯26个英文字母读法然后仔细听，辨别每个单词的第一个音就可以得到 flag 了 猫咪问答 Pro Max五道刁钻的题目，但是还是好查到的，题目里也说了“解出谜题不需要是科大在校学生” 2017 年，中科大信息安全俱乐部（SEC@USTC）并入中科大 Linux 用户协会（USTCLUG）。目前，信息安全俱乐部的域名（sec.ustc.edu.cn）已经无法访问，但你能找到信息安全俱乐部的社团章程在哪一天的会员代表大会上通过的吗？ 看到了 “目前，已经无法访问” 说明这个域名曾经是可以访问的，直接通过互联网的记忆archive.org，查到这个域名的历史存档，随便找一天就可以看到他们官网中的信息安全俱乐部社团章程。其中第一行就写了 “本章程在 2015 年 5 月 4 日，经会员代表大会审议通过。” 所以答案就是 20150504 中国科学技术大学 Linux 用户协会在近五年多少次被评为校五星级社团？ 直接去科大 LUG 官网的 Intro 页面，就可以看到 “于 2015 年 5 月、2017 年 7 月、2018 年 9 月、2019 年 8 月及 2020 年 9 月被评为中国科学技术大学五星级学生社团。”所以是4次（x但是怀疑一下为什么没有2021年，因为都是在9月份左右，所以可能是数据没更新，这题4和5都有可能 尝试后得到答案是 5 中国科学技术大学 Linux 用户协会位于西区图书馆的活动室门口的牌子上“LUG @ USTC”下方的小字是？ 这题也简单，直接问科大同学就好了（x翻了 LUG 的微信公众号和 QQ 官方号，都没啥收获，最后发现官网上有 News。这样的话，如果新启用活动室的话，一定会有一篇新闻稿，搜索“图书馆”得到了「西区图书馆新活动室启用」这篇文章，开篇第一张大图就是门口牌子的照片 所以答案是 Development Team of Library （注意大小写） 在 SIGBOVIK 2021 的一篇关于二进制 Newcomb-Benford 定律的论文中，作者一共展示了多少个数据集对其理论结果进行验证？ 应该没必要搜谷歌学术之类的，直接必应查 “SIGBOVIK Newcomb-Benford” 就可以找到 SIGBOVIK 的这一篇大文章合集，再搜索 Newcomb 就可以看到题目里说的论文了。全文也不长，只有四页，后两页全是数据的图，数一下，一共有13幅 所以答案是 13 不严格遵循协议规范的操作着实令人生厌，好在 IETF 于 2021 年成立了 Protocol Police 以监督并惩戒所有违背 RFC 文档的行为个体。假如你发现了某位同学可能违反了协议规范，根据 Protocol Police 相关文档中规定的举报方法，你应该将你的举报信发往何处？ 没啥好说的，直接查，答案 /dev/null 然后提交就可以得到flag 卖瓜题目里比较重要的话就是： 补充说明：当称的数字变为浮点数而不是整数时，HQ 不会认可最终的称重结果。 题目的目的也很明确，用一堆9和一堆6加起来得到20。肯定不能像华强一样劈瓜，所以输入一定是整数那就可以考虑溢出但是经过尝试，给的数字太大，就会使结果溢出到浮点数，这不是想要的（因为即使凑到了20.0也不正确） 那如果数字再大呢，比如 2000000000000000000（18个0）个9斤的瓜，可以发现，这时直接溢出到了负整型 -446744073709551616再补上 49638230412172000 个9斤的瓜就可以得到 -3616，加上20可以被6整除，所以再加上606个6斤的瓜就可以得到 20 恭喜你逃过一劫！华强～华强！ 透明的文件 一个透明的文件，用于在终端中展示一个五颜六色的 flag。 可能是在 cmd.exe 等劣质终端中被长期使用的原因，这个文件失去了一些重要成分，变成了一堆乱码，也不会再显示出 flag 了。 注意：flag 内部的字符全部为小写字母。 拿到文件，看到里面好多 [ ; m 之类的，再结合终端中输出带颜色文字的 \\033[...m; 之类的方法，以及题目中的 “失去了一些重要成分”所以直接尝试把 [ 全局替换为 \\033[，然后复制到 python 中 print，就可以看到神奇的一幕了（其实并没完全做完，但是可以已经看了）然后读出 flag 即可（全是小写字母） 旅行照片 你的学长决定来一场说走就走的旅行。通过他发给你的照片来看，他应该是在酒店住下了。 从照片来看，酒店似乎在小区的一栋高楼里，附近还有一家 KFC 分店。突然，你意识到照片里透露出来的信息比表面上看起来的要多。 请观察照片并答对全部 5 道题以获取 flag。注意：图片未在其他地方公开发布过，也未采取任何隐写措施（通过手机拍摄屏幕亦可答题）。 “手机拍摄屏幕亦可答题”，所以照片中没有任何地址的元信息，只能靠看图线索：海边、KFC、高楼、大石头、停车位 先看那个KFC，大概是个网红店，所以搜索 “网红 海边 KFC”，查到了秦皇岛，而且也是海边再进一步看地图和街景地图就可以确定地点在 秦皇岛新澳海底世界 然后是5个问题 该照片拍摄者的面朝方向为： 根据地图，对比一下就可以得到，面朝方向是 东南 该照片的拍摄时间大致为： 根据选项里的时间，下午是两点半左右，而在东北的两点半左右其实和中午差不多，影子和光温也不太像这个样子，所以可以确定时间大致是 傍晚 该照片的拍摄者所在楼层为： 不好确定，但是答案可以交很多次，所以从9层左右依次试就可以了，最后得到楼层是 14 该照片左上角 KFC 分店的电话号码是： 直接用地图软件搜 “秦皇岛新澳 KFC” 就可以查到那家店铺，也给了电话，或者搜索 ”网红 海边 KFC“ 也可以直接得到电话：0335-7168800 该照片左上角 KFC 分店左侧建筑有三个水平排列的汉字，它们是： 通过街景地图就可以看到 KFC 左边的建筑上写了 海豚馆 看来写了不少了，剩下的简单题放到下一篇里_(:з」∠)_ Reference Hackergame 国际航空无线电通讯26个英文字母读法 - 知乎 LUG@USTC 官网 Wayback Machine archive.org SIGBOVIK 2021 百度全景地图 &lt; #0 #2 &gt;","link":"/p/fd872e78.html"},{"title":"「Hackergame 2021」#0 赛后总结","text":"七天紧张刺激破防的 Hackergame 2021 终于结束了_(:з」∠)_在这丢一个总结和 Writeup 链接。 Writeup 「Hackergame 2021」#1 Writup 开局上分篇 0 签到、十六进制、电波、猫咪问答、卖瓜、透明文件、旅行照片 「Hackergame 2021」#2 Writup 开局上分篇 1 大砍刀、图之上、赛博厨房01、助记词1、p😭q 「Hackergame 2021」#3 Writup 持续破防篇 0 Amnesia1、RSA、LUKS、MicroWorld 「Hackergame 2021」#4 Writup 持续破防篇 1 阵列恢复、马赛克、minecRaft、密码生成器 Summary第一次参加 Hackergame，大概也算是第一次参加比较正式的 CTF 比赛。 这次的时间也比较难受，10月23日开始，然而当天有管乐团音乐会演出，要全天排练。24号去听了帝玖室内乐团的音乐会。剩下工作日的时间也要上课，还要复（预）习小测。但还是抽出很长时间来打了 Hackergame。 经过七天，拿到了浙大组内第三、总排行第二十二的成绩总之，非常感谢鼓励我（拉入坑）的 GZTime，感谢一直上分的 yyy 大佬和 Cage 学长督促我继续做题（别卷啦），感谢纳新群里活跃气氛的学长（不感谢膜），感谢容忍我凌晨一两点在寝室做题、第二天早上被一堆闹铃吵醒的室友，还要感谢没参加比赛来暴虐我的图灵大佬们（） 开赛的时候刚好乐团中午休息，于是在休息室做了几道题，接着一两天陆续把会的有思路的题做了。然后就开始了破防阶段（）一杯茶，一包烟，一道题目做一天（x基本上每天除了上课写作业的所有时间都来打 hackergame 了（中间做马赛克破防的夜晚出去闲逛了两个小时） 总之我也才大一，刚接触 CTF 一个多月，这次打得也挺爽，不知道能不能借此混进 AAA（逃 体验良好，但不完全良好，下次再来_(:з」∠)_ 声明：虽然总结和 Writeup 的创建时间在比赛结束前，但均在比赛结束后才发布到互联网","link":"/p/c05d7b7c.html"},{"title":"绕过AST解析的python沙箱逃逸方法","text":"这类题是在zjusec.com上 ACTF 2019 分组中chenyuan出的一系列python沙箱逃逸题目中看到的在网上搜索貌似也只能搜到 TokyoWesterns CTF 4th 2018 这一次比赛中的题目 简介这类题目不像普通的沙箱逃逸一样通过删除内置函数字典或者删除某些模块的内容来实现而是在输入命令后即使用python的 ast 模块对其进行语法分析，只要使用了某些禁止的抽象语法，就抛出异常导致程序中断 因为它直接使用 ast.parse 分析了语法，所以很难蒙混过关骗过 ast，这时就需要寻找题目中遍历语法树的漏洞了 题目分析先来看看cy的pysandbox13，这个最终版的AST检查绕过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112dbgprint = sys.stderr.writeclass Traversal(): def __init__(self, node): self.tisiv(node) depth = -1 def tisiv(self, nodes): if not isinstance(nodes, list): nodes = [nodes] self.depth += 1 for node in nodes: func = getattr(self, 'tisiv_' + node.__class__.__name__, None) if func: dbgprint(&quot; &quot;*self.depth + &quot;tisiv&quot;[::-1] +&quot;\\t&quot;+ node.__class__.__name__+&quot;\\n&quot;) return func(node) else: if not isinstance(node, ast.expr): raise Exception(&quot;not allowed &quot;+str(node)) self.depth -= 1 def tisiv_Call(self, node): raise Exception(&quot;not allowed&quot;) self.tisiv(node.func) self.tisiv(node.args) self.tisiv(node.keywords) def tisiv_Attribute(self, node): raise Exception(&quot;not allowed&quot;) self.tisiv(node.value) self.tisiv(node.attr) self.tisiv(node.ctx) def tisiv_Import(self, node): raise Exception(&quot;not allowed&quot;) def tisiv_Module(self, node): self.tisiv(node.body) def tisiv_BoolOp(self, node): self.tisiv(node.values) def tisiv_BinOp(self, node): self.tisiv(node.left) self.tisiv(node.right) def tisiv_UnaryOp(self, node): self.tisiv(node.operand) def tisiv_Lambda(self, node): self.tisiv(node.body) self.tisiv(node.args) def tisiv_IfExp(self, node): self.tisiv(node.test) self.tisiv(node.body) self.tisiv(node.orelse) def tisiv_Dict(self, node): self.tisiv(node.keys) self.tisiv(node.values) def tisiv_Set(self, node): self.tisiv(node.elts) def tisiv_ListComp(self, node): self.tisiv(node.elt) self.tisiv(node.generators) def tisiv_SetComp(self, node): self.tisiv(node.elt) self.tisiv(node.generators) def tisiv_DictComp(self, node): self.tisiv(node.key) self.tisiv(node.value) self.tisiv(node.generators) def tisiv_GeneratorExp(self, node): self.tisiv(node.elt) self.tisiv(node.generators) def tisiv_Yield(self, node): self.tisiv(node.value) def tisiv_Compare(self, node): self.tisiv(node.left) self.tisiv(node.comparators) def tisiv_Repr(self, node): self.tisiv(node.value) def tisiv_Subscript(self, node): self.tisiv(node.value) self.tisiv(node.slice) def tisiv_List(self, node): self.tisiv(node.elts) def tisiv_Tuple(self, node): self.tisiv(node.elts) def tisiv_Expr(self, node): self.tisiv(node.value) def tisiv_JoinedStr(self, node): self.tisiv(node.values) def tisiv_NameConstant(self, node): passTraversal(ast.parse(c)) 可以读出，它定义了一个 Traversal 类，在初始化的时候对传入的节点调用 tisiv 方法，即对其所有子节点继续逐层检查如果 tisiv_{该节点类名} 已经有了存在的方法，就调用它，在那些方法中又分别对其子节点进行了检查如果不存在这样的方法，就检测这个节点的语法类型是不是 ast.expr，如果不是就直接禁止 再看 TokyoWesterns CTF 4th 2018 这道题： 12345678910111213141516171819202122232425262728293031323334353637383940def check(node): if isinstance(node, list): return all([check(n) for n in node]) else: attributes = { 'BoolOp': ['values'], 'BinOp': ['left', 'right'], 'UnaryOp': ['operand'], 'Lambda': ['body'], 'IfExp': ['test', 'body', 'orelse'], 'Dict': ['keys', 'values'], 'Set': ['elts'], 'ListComp': ['elt', 'generators'], 'SetComp': ['elt', 'generators'], 'DictComp': ['key', 'value', 'generators'], 'GeneratorExp': ['elt', 'generators'], 'Yield': ['value'], 'Compare': ['left', 'comparators'], 'Call': False, # call is not permitted 'Repr': ['value'], 'Num': True, 'Str': True, 'Attribute': False, # attribute is also not permitted 'Subscript': ['value'], 'Name': True, 'List': ['elts'], 'Tuple': ['elts'], 'Expr': ['value'], # root node 'comprehension': ['target', 'iter', 'ifs'], } for k, v in attributes.items(): if hasattr(ast, k) and isinstance(node, getattr(ast, k)): if isinstance(v, bool): return v return all([check(getattr(node, attr)) for attr in v])if __name__ == '__main__': expr = sys.stdin.readline() body = ast.parse(expr).body 这道题目的代码就更加明确了，道理是类似的 绕过语法树检查正如前面说的，我们需要找检查程序中的漏洞 寻找没有遍历到的子节点我们发现，在题目的程序中，都是手动编写了对某个抽象语法的哪些部分进行检测，所以可能就会出现某个语法的某个部分没被检测到的情况。 这时候就可以去和 AST文档中抽象语法 对比，文档中给出的 ast.expr 包含了： 12345678910111213141516171819202122232425262728293031323334expr = BoolOp(boolop op, expr* values) | NamedExpr(expr target, expr value) | BinOp(expr left, operator op, expr right) | UnaryOp(unaryop op, expr operand) | Lambda(arguments args, expr body) | IfExp(expr test, expr body, expr orelse) | Dict(expr* keys, expr* values) | Set(expr* elts) | ListComp(expr elt, comprehension* generators) | SetComp(expr elt, comprehension* generators) | DictComp(expr key, expr value, comprehension* generators) | GeneratorExp(expr elt, comprehension* generators) -- the grammar constrains where yield expressions can occur | Await(expr value) | Yield(expr? value) | YieldFrom(expr value) -- need sequences for compare to distinguish between -- x &lt; 4 &lt; 3 and (x &lt; 4) &lt; 3 | Compare(expr left, cmpop* ops, expr* comparators) | Call(expr func, expr* args, keyword* keywords) | FormattedValue(expr value, int? conversion, expr? format_spec) | JoinedStr(expr* values) | Constant(constant value, string? kind) -- the following expression can appear in assignment context | Attribute(expr value, identifier attr, expr_context ctx) | Subscript(expr value, expr slice, expr_context ctx) | Starred(expr value, expr_context ctx) | Name(identifier id, expr_context ctx) | List(expr* elts, expr_context ctx) | Tuple(expr* elts, expr_context ctx) -- can appear only in Subscript | Slice(expr? lower, expr? upper, expr? step) 比如，BinOp(expr left, operator op, expr right) 表示了二元运算这个语法，left 表示左侧的表达式，op 表示二元运算符，right 表示右侧表达式。同理 ListComp(expr elt, comprehension* generators) 中 elt 表示其中列表推导的元素，而 generator 则表示生成器子句 再来看 TWCTF 这道题，它的检查中写了： 1'Subscript': ['value'], 而文档中给的索引访问是 Subscript(expr value, expr slice, expr_context ctx) 因此可以发现程序并没有检测索引访问中的切片 slice，这样例如 a[…] 中的 … 部分就会被全部忽略所以就可以在[]中藏一个eval执行我们想要的功能 寻找没有检查的节点再来看 zjusec 这道题，通过对比可以发现所有检测的节点的子节点也都遍历了但是再细看可以发现 FormattedValue 这个节点并没有在题目代码里出现 而且 ast.FormattedValue 属于 ast.expr，所以它既不会被检查，也不会抛出异常看名字像是 f-string 相关，可以 dump 一下看看： 12&gt;&gt;&gt; ast.dump(ast.parse(&quot;f'{x}'&quot;))&quot;Module(body=[Expr(value=JoinedStr(values=[FormattedValue(value=Name(id='x', ctx=Load()), conversion=-1, format_spec=None)]))], type_ignores=[])&quot; 可以发现，f-string 是 JoinedStr，而 FormattedValue 是其中被格式化的部分 所以就可以向 f-string 的 {} 部分藏 eval 来干坏事了 其他漏洞这个是 pysandbox12 的一种解法python中的语法不仅有 ast.expr 一种，而且很特别的是，列表推导 ListComp 的生成器子句并不是 ast.expr，而是 ast.comprehension 12&gt;&gt;&gt; ast.dump(ast.parse(&quot;[x for x in range(n)]&quot;))&quot;Module(body=[Expr(value=ListComp(elt=Name(id='x', ctx=Load()), generators=[comprehension(target=Name(id='x', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='n', ctx=Load())], keywords=[]), ifs=[], is_async=0)]))], type_ignores=[])&quot; 但是 pysandbox13 这样排除了 ast.expr ： 12if not isinstance(node, ast.expr): raise Exception(&quot;not allowed &quot;+str(node)) 但是12题中并没有，所以 ast.comprehension 这个类型完全没有被检查因此直接向生成器表达式中插入坏东西即可： [x for x in [eval(...)]] Reference TokyoWesterns CTF 4th 2018 Writeup — Part 5 Documentation of ast","link":"/p/6dee32d5.html"},{"title":"「ZJUSec Writeup」cy的python沙箱逃逸系列","text":"64cf36da832c32ee150f47182e85c12ad08e8fdc7585aba87e7caa43ef24ea022ddcd838c221edd44ce79d4382c4fb2a74a2a61c083a697ca366d8dabf906ff9cb977e2710eeea3b8665606c597245f9f66aaa8aa22b8d5b2d1684f09275090bd4b7d3188beb27c45725d276fcdcf3ae57bfa442335531788e63d75df4fcf1fcfd15e92f8112599c4866a6079026a5fa9152331f68e4abdf9025def0aa02a5b0e37c6daf00b3a2b203a9e9f2d7e9eea7f2b1dbc49486232143013cdaa01fd99c8805e6a12626f0e243fbeb22664d1a50421fca401b58c44b6886982e475810037f3e254e2dd27f0ddbe819e923f3d18b663455a9d8870cb5d49dacdcd4c4235e401da124c87617cd2e091e7d7cd1be23b33628afb1e5ea1d264473d5d9da6c36cb6bd9c3b66ffbf4dbf22f774d58451ce46a5b30390352a4e4ffa037305813298adf392ed06eccc3ad88c8381241d7e74dde7dd34270ab36bb0896f5739b9e16ce4b9b1618ce707ad0464491a72361640e3174f61d8ed93929e0747ba5ee39780bf4591c35351151103d2245eba2dfe47ee2091013013903b1e71a04a38c7e2df148c1014423b438b4ac4a77011d7f66265c25fe6323fe17aba66aede8e62406ad7419eebb351c55395a27e149c2dc0fbd3d0a1bb35e49cab3a1af15529c472c992d9cfbff7b3b3aa0f11f7c250eb6bf2af2501a0cc8fcbb2a8adf63438a959716dd2a0d42e56b87dbd4dd8fa504aa39a8f5ab0ed1402d2c9eb4b373afcea577e6a796daf15d894c7e1d358ea20b0cf15799b885472ae2e0e246bcf51932278fa4253d722610d13340f6b03e599fa8622312069f3db8f0302fc46a924f6b841364107a936c767434c9439e97e4e0b00c6fe2cb88e30c5a4fb92f8112f0fca9e321b84020a42ae30ce9d214fd30d166b0606d7db0adbb2032472d02103c1a2a6645ceeb41c7fedf420bc585c9afedbeab13edeecb4a7eecfc2dbbd672545a1b1bf6952812250a40840692d1c9d0a33e24280025191fb741711ade955dee0e2782dd0497ced9a8c288ee777ba9ae026c0558ef971458a5b6c3813f61b0d950e15bec2c955955be9379445b9a1a53f3837378cecb48d2c6e611bb7ba61343895d04e4f7604fc2e9ccb29a90777c563fdffce54329685c52e50da0dc57557b02a473cdfb64ad41e1685c1f78026f56633de036875ecb4c30d1299b9d6c9cc452909136fd146c2e240633c20abbff091923388d2fb5ad348e3bdf0c29659e37225784a463e3be36fc9c0645272edd36ee91cd71bf44016a756cf3bd0db0385743f3ef26edd1737e2220297ef9a373cbc2bb6a57f11f5e3f0abb20c14d630ec5f854d04884b5a709a77fdae8ff7d608d4f13d3ecd34d9415261d9ebceed5fe04a23e81169bc4006efa02f1322bd932c8a4a2c3fa0e7c56dc5eb41db5424648f8c7e4c81c3cc871fdbb24d292724616a00b8470fef023d148b027e0604070bcde2bfe1cf89b3c1ba242badd7f8f5932b5b961472bc5cb6ae66828462fa016f0e502f22ce878acb15ea8d164d088afd9eaa2771d4b3739cc990c4910e5e225796e1f3aceb5e280b686e960aa4f04a94b1fee8879d0d541e8ea5966ef4673bc18afdd45a28a3151bacc91a4d9c469cbaff8f570defa9357a8645c91da1565da741df9e724fe439ef456d8d485974f1bfcd17759784eb94f915fb7232dabd5f4dda27cf2949b1f1c2ce6b27f4f87b7c0d0ac89b524602d5584a2d86044302a95c0b254b044e9f50fb25592e92016c594298f15a127456811f70f370b1944545f60cca7018fbf74ba146a00c4ed58f13d3cb1ec02fd3d8a822bba47ee473bd06828848015caa8f344e4e55467bf45b938e045122d5633a5aba91020151d0446b7f17dfee313dd2c50c7694e71ab35a878b9561c893b0b128dcb54cb05307beb31c35440bddb1408e4ca5ef21c4ab6f2a8b5c1f4bee47fa39ef73b6e60f035abbd4bb498d0476bec408696975fc6f0181ecb564900f8502fb02668ab5ce427862cafe6c42d012294f8fb97158b571a44c0696edb342418af6cd9d189b7002b3a37b3aeb738ba800018c446af13a8d2da28f400293825695fdfca5e1d43217ed5ca445789bb022707fe24fb99aa07d8b4c122b21de532d610e8912161335d678d3998fba5307e3bdd24c32afb8e13eb4ab625ac48945deeeac71abf8d8c74525bb22d9832cc8f52c74829dbd8106e63a36efa52dd6470f0f13d2044c818cdbc5c01377a5b76ccbc0ae47caa036844fa3e511cede6da1fba4ccc38c46d3dc29d7e160ae43bd111f47570b875852ae8b771af6acf5ac79d7f165101f3c71768dfa73fe4a8a1f3341427b9b4170b6ea17696c93706500d7235b886c01672b421e7c238bf6216ef2ba9c77f3ae128136e4ba28662e2217cf9a6f68ff19fb73ad0b5256d8f09d8b29a80c7fb45b9f6ed859844ce0c186c64e812e59d5f84120c900d3f22c80ada37da9f5585b290c401621ac25db83be1aa574cedd74cf7ac95312376755e6045fedbca51634167f31f7780570aa5b7756e5402deb99ee3d07d8c1d26f2890bc4ca82b91933570195776ddbc75a2c1ab004111dde8ecc509bc377f446529fd5025aa320065b81f6237e68e7f2ee97ee03cb89c9b14f0458ac4834624947a08e157da874cb71e989e5403c0769e94f17e0d4b2b38a9938ec18af8d480e7d0c57badccebd4d9242f3092edf0690b6c47077a2b4797e42e4953c51d6b633a2e201e6b0a949eebc5e8d094e3a5761eac87cb3029376257080bccbfa63c360257432cb3afa31472b54d2aac7d26d4ed233783b3817add2fc1015d5019078e65148c5d363c4f52c1312c37553bde86c7bce48fc74b54e7832cca6f9971d944ecd346a9c3e8af08ed3bd0cee66c300040a8eea8c2e45c1c8ea9c98396a02cd0032af301771d10d9a828f6bd14b6b1f4e15c2d9fc767d218e5fc391946aefc11e25827284e54c478de248903908cca4ebfa4fcab0cbe8d764fab8ee6956f8648008bfc4fd0b924cf8cca7e6b01955031e8cd4391904164f5ead3e45018826d17916e521592bbc7fb150145c0450b7cb73a75f9b92a3fc3c62e31c6745c9b579244d5f731c719536016cb0f88328284d608f4f29f5612d66f985b990ee0aedf4607a7b835790cc8c13495d873abd6593c89027dc0f7c211120b1ec4933d70536c4562b5b3dafb196e5fb83422edb26628f42e283c1e2626b52bd40c6b55219e060239b667f4cb4dba5796e01db505511efe0fa597b76e82281901f11e61451d0a627cbeaec13065eef2256736032789c425d4fee058a0937e299afcb26351572a37710875e10e6d396bcff54e2286aabfda147213f75ae154a703f1be115c4f0f97c17810a4d818fb56e8ef7ae8afa7c02367bd71d24c13e3cdbb3c38da7624c4a47ba62ce5e5bcb7a0eaa9a2aa3399ab11e2becd696fdac2c23fd09e2bae8f6d658ad97be029018c5a766ed62a7e4a6405445e5135562bd143d349a765924b3a98aa02a382846d7c3620bfb8cd16a5594f47b28315b6e33a399ab88be1a2e64f9eea1031e96861b98d2bc7470450d852c86a1392a6cadfa03c91e298df8f025c2d857797a6c192bb47c6f5fdb459c58acbd4ec54b94d59131c221d39e6726c51932eadbf0c3d3d4273e5ce0648d4886fffbefcfbb8df2d07e3e2941ad1a8a24b0b89d5d7415aa0f4d06d36b1d000c37fc3ce2a2059aa67c26eada6d33b4675db37f74289750e834a513f569bfc602ebadbf21780790a2680a8ab4f878570eee3124e10e8dab2a58cd4ea88691877b3dc6f17cc9a71aedfac2d403c45688715c4fda9fb4c8895d315545adffa91e33681ed41070a9178cf958819dbe9cb2063dea92f54ff44e72f13ce2c3706f314643b13af0b7a36cd89c986a7aa1eada7567788cc0a7f563c6d20c11bfcc7d1e53c9079c21c14bebd909a7f293c1492310dc4b9f852573d8cf829c4f73dbb86d73c6c1ede361f6a4a2cb4bfd45460673c5ea258d762713d3bb2d250be1eada634203e06b68206a10878d032390e681744c13403b539855776bd5bd40bd28dac86ffcf8c6d23ecd205e615fd4d278479b5304455022bcbf77f7e795bc78b79d99e1cba24467ce2b5d6eb8967678abd7f1b39fa24e77ed53a0db55bab48db9cd1e1089d7c1e08270656dc5d6248bfd1ce85c0da80e5c291533d078d5f82f4324b1c0d203dd3daefb6d097c1532121aa740edd8e9877e9fa2c07c0048fc0f8811dbc26fbc0b986d11ec2fb581e6f2deee2203779f027c2465c34a48ea1f9195e9a84f3ad2fc7efa47aecc021360db7de6d694a33ff08f6af543668df2eb340ac91b8b8aac4a70829382d5d2a720038f4dadea12194f3c22145e0ffda57f287f60d0e17255d5e4f216b5270a58dc8a3ef216d93c4322e8020871d14bb46a8892612a7e8d0f81c42f736fc49cdd5194e85e2cf9b2b18fdc841e447aa8b7d9a1a2b942fd1a29b28ebd91cee582a51720c2785935b08b4398a6d521de619fb51905e4aa3174821d6ee6b225412526c8b196d498d576a51879d47184afac4feec7ffb1022298bacf0f3f26519ef379db70326f37e68b0b343967d3595660cf310614fcc077b573644e578ec2010c8a79b7832047361d55e699e0eb87503a1ceed840b9dd8c0b2a82eb0fba42564efe136ff3c98951885e655b1172d0cc68b376ba50c89b285b16b0a878aaca8b699617a0aa08af55173270648dae074363e790e7f9fe169613bc66296403231a84d97d428696c3fb10a14dbe42941463b144d3d7266fc69adb37c9923cf68b29301e101c547725ed068bdeb378027119bbb2f99a0fad44e6537b99309d0264016a89b77091314ae0486f30b88280679c7ecd4ae41424b0d4ecf482358bb2ecfa0f0739cde518df02d352d2e5f7b12229eecbbcf78e6523c8596f49faada419203361b34778261c2b99f0f2cbe0981080e86b1e150dbad65c43a8b0c19b7fe290dfde1fe647b6d148b89a7ce1ecb3206029a373cdf5075a415467f4b28d989cffe518517d11469775ed5088f34ab82ef6312babf892b5674f227f9cb7b0a692b0799ceb18f765074c35bfb489a01ddb3dfd40856e6fa7d14fe6d81aae5f4b053b2b13f7bb06e143fe148937438314b9e28369ef750ba9964face3426eacf25af301ebfc22dbd29e2a084a74c813acafa71bac015a2769deaa5dedce86f22a0c59a4ba72003e08087bc6e188a379d2bd4518b68dd0ec5654913ca8a5a014dd40b4a410d4f37e69a973343c7ee46bb1be5e856351b4decdc13d07e47b06b3c34ab3f808ab16dedd877b64bd95e2c9c414e8de0a1f3fa21f2af0657f5b3309bee876341fbcdbd36c7af97065df3efe2931ddc9e9552962759839c9ed6e25a51547019aa599c178a866bc2558f2ac83be1c01bf2174908fddd14559b871719065d101d4aeb7de3b0b4d5139037ad90e77cc349e0cfe8dfdf41d6842fd6b8ea1120c356f9fc7be1029054ef0d6ebaa69b3496473c12c0448fd471f07eacaf51fba7f7492f370ef7f2b083834f239aed640818406fcc7b0c3736716eac114369e9f30637fb1dea243c69ceffe680c17f9551c752f7c37638104dca0099d78f4b5ce6fa1737941fd5e86dc855ad18413ff071e0ff189e1d2cc571582080c6b79a1d2cff5c410c51d93b0c420f75eb174eb3193878012d32a88c1e7e31aeefd6bd531d0dfca26c2f5c28feb466b19826979d9f2003fc8b02b3d933b6c55cc964931ab719da7b5a40b7845080c3937f654a76a254108b0dd3236fda765425f1defe8681f85f4f1ca7a1cca7b3376cf209ed39cc816c6877de7b1735ac8d7720ab4b7306bdab173b054dea72a8d476917c42146bcc6cabda590845c4aaf9a8dd260c335ac4e131c2ebdf525c325c0441334d566b7043a19611174ecb4a9ad176da44c767bd721d0c711a28247bc0d239780a831e929d226e2221856e2cc95779416813fa4a5018376d0eb90d9ea6b18d74b49dbf6ffbb84cdd97006fdb2c737fbb2a9af1333e33f75dbf5d3d75bfc560dcdf33a0396448e2b02830eb12beb779c67f335450f81656ef918b31b0302ab36c351185cbeb58fc0fc407bf0f8dc52c493592c39759face76737532daccbb18740d2d7d00a59fee0c46ef14c91daf7da7a6dde41af5cb6f675593736b64c68701d2bef803aec42e7d6a85f7b9adc17b59707ea2d05907858e381c4ba61271a70be961958693dfcfd043d5b3ed8037b546180f9d1662c74b6dcdc447c4c9113a37e8088bd3e8cd21399d46430150b9b0aa8f5471f6fa5669bcbfdc7580d2e71522b03ee9d397e0bc7fd9ca72abb7ab55df725221135a04bb29222972dc5a8ae35d90b08def2b3c67b8f3b0192bdf6daed7fbd76a94410cc980cb4b2d2129ae81738323e360c81545d8e547157adada64a7499cf3f3c795d3d84a3efbfbd71d7529695c985dd66caa499824b124c6ca48f3e93cd50daaa0f578b14d45b3396328fdf0b1e3b8367244b625307bccbc7f4912c8185a46be1d5e7117fed40ef4f128033324d24e03457f01e4a32989fe06a2b88bf565a1937b32530dd93be7ddee230cae93ad5293278b74e50abd3997849ae6919077ad43338f72b0dbd1c9a47b87e854addc17ca4fbba4faa68444c6938a14f52386a47124720666eb6ad54eb18079b270c4ed3cb6c068aac39bd8fefec97abb5ebacef348dd9ed938ce1737f3e24ad1c2d6ee7e1ca152d3c215c6d3ec13cb6fa5ce849bb254fd3a48a7ab29d3aa987f8d8a66b628136dbb226901677b856d6e52145b52df4699f8c9954aa9d92a975e71a8b9bf2bdb5df577f7726f597c1c8d344ed118410afc774e87b5b424583e39b28d58eb407d1f55b294052918ed6f8d2b5726f4e5acc460e07174343329f649f50e95470d9e477882d44df5cf24afb262bcebe9859af7b666325c4e9d08db9104b31b4718d79cf92573d7afb3d967f669ccae89d6c8d4552cbdb08183f00fa6ffc8f9f2056da4bcf66cd0604d79693d878d071fec15a1575524e46cbd2ffa664cf2f89df38c59b2f1906018cdb6ad7b156644f4fd99ef9efafff57f38cc87abc89574dbd36f1607d7d3181f18dd6b3efdf633b866b9ecb9588710acfc60de6a5d204e734a7bdbebffe410fb8024f0af2a7037020ce6451c4ec78b3cea09c39dccd1df6e88c39208e5b92ac739cffdb3ccb2db497b08757a4a307a9a87e78d3a49d0ac1172d9f7f281f487f85415e7396c3266f9269aa69eefbd5018ba9b1664d014e1bc368ae34f340e100377eecef40ce75f5ad6effa8716e579c2487b4d4e31da02d9937f1dd577b021b629f9ff335b06e875988e5df3221f0168e6b133295325970cc1c3c6af6c551b4be96b1a1fbcc8897626a47a7c166765a18628807f734e928fb4a42972bdf0596ba5dc3f4b51dffd2005eaba5498d44808916d3fbb1694e3610e65b6eeaff10ed3889a08b7ad62ecdde84ecd2a3b744492e842452e75f849de5fbba6faf80e308af9bdfe40def2b24a9f3c63811b2de74703c7b7c9c5c51e743361d8627639209b98986e6f2e5b739c6c31a1286870427ec29a3e7b088f0295145d3bced9e470db2e74d5b463395aa3647e7f4623ff7a6753bebef8cf41a30f0849b9eca72a196423f8f8aadbd97ed8535107e02396ade40a221cb2fdbca6654fe9f768002e0f27e4e6cb8821a64065456e200c878f1db4d79e7860d36ae02e8a9cb08226f07ed49b44537496655cd928ca2662a506dd570b6ca73522ede562a4a1be04b906f686ff32d0ed50f1abff3b12b85a5bf00f9706845ecbde3523f0250e8b00d8cf276ac84578c31df9ff945db2a33afdedffe6845030b8eea95e78ebe8ee433264ec765a6451e83d8afef00046e0373d348518ce54d46e88669cc3bad2f10fd97a8ead3d3dc8cf80a9c1db43d92ddaa148bb06007fe1e6fb24a144c959b1ef083d3f3b4eaa2ec523a90a5521081f61a421b46074fde18f860671347c08533def30914de7bf29125b86bae9782ffe588581fcd7ad308475e709e1d0873ea0de9192ae46b2c4f5a5c26a109aa07fa5d7c5ce29183c12dbd6b5b1736f5fb25c7cd1390ab5ef017a433779a1ffc0472851e4a58963a6a5cd34614651384f3e04e49d3b2ef8d45d6dd7ca852cb3db9cf2bd3bd0f7da4643accca6f68848672de5810e53035fab6eba9be9b0f56d467a669eb1cdb7938fba77ea401a95166e8f45dcd8a23617dc42a47070d36bac5f243f3e04eb2c0b8e62d784cc5a40f45e6081de530726a724bcda48753632f303bedcca10ebcabe89ad2612ad7249275355ddc90d7420c6c76d028bc62155debf15a02b72f4cd7b114d4ceab59f93f58856ffee01ffd29d7e957ea3e4c929c33395a69f7e39f05010e93673ebfec203f97bb0f52cf28172a30d6c5010c8c655bacb40314e10da58ec3fc722651469772fd48a77b96be2b8683e56ece4c2105ba8a02366832303b0b49569cafa65510da2b0d98bb95dee0d3c19a1c339597aa1e91e559f8a6eeff43fdfad248b493cf1532669ed765044340a7c907f4bb28002323ee079eedf2b06aead5aa034de4b1834547d2b51909ba1700f2a0e367c5522a1605da5119c95edb8af56ccd8dcf6fe903ebba48ab4703bea682ef42835ce1f54f44f24e13861c2e82553f4460a8b00b4469a715d59fa4f7fb4a1b028766fcf4e48e985df8527b7735a8c98f609764f2d9b304fec6360a0a5bfda8424d48fbb25a4e0d56131879640484a77a7985bcd6475c861850397da50144eb5c0c1a9080212a99122b2ee68e337623b94f84b9056476fa4d64d549389a9467406650c09571b4d30f2e024eff9be35f006aa770d89df4ab5a5f54655673c654a02898a36bd1717a4cd06e77e01bb1fe67bb69d644b8e06b81685438d3a17c85ad29f42e4c85fbbd0f461fab0b854ddad4216a81cbaae93d64e0dc76f66b096b5fc0a89c766ec0afbb2b013b5f0c502517c9a1ae612a2f46db22fee046e0e16e317c7bf200572221f7deadc59f30595b75624ae5c54039f25e85761f2511f5695319a2fdf06832d1db76dda9b38f5ea8a3e5b493d83a1b76ef89b8c202573e71feb99b68d08860914ad47977184624c33ba6a756c92815e934a20a337c8d426949675d24b3c590aa915e7ef06bc66a8f31f0a6d0b9b20e715b275ac60dcd3f2aa3f1a09b366df2f264af6c7b5a7df46d47fe1cf4f77d391408bce000c4065f855ffc332c40feb01ade5fec84b41a7c0ae9233b4e024254592f8d8672c6072e049c5bf66b8a9640859ad96b6db46e85e9614c7562e051f36e614adea530d9fdf9e3beaf27c601c059a8d9e853cc67cc78fcd2390711fa4029d9100c992ea316bf65daf7fdc0397ea6065d3563258f7de0f8cd7a6df2da04e89aac320ae2733f5bb2671c985fa7b9d44ab18c4c7944c2208d59b15138022ab4f217b9fadaf5486f1950923dcd5628ad86be99cd0b90755e5bfbc9a612935feeb5983e58965c265304a7b45bead3bf9f16c0d919ff05a359570aa629a0b47bb925b278ebeaa87941842deb6ecb6b327c3f6878af78d5fbcc5ac94472d82dd28e5568bb6d29d3025125f222abc3e650f286e7d8043bc6f679647afeae345183a16411982749b4823382999ac97de9571c24bcad272797783d907d2dcc0211c155750bc96cdfde20a13278b3744271a1bd2facab1e23d9e1265423dd799f73729beef868ebf2a4e38c928fd83357a65880eb8caee847524cb4b54a39203588aa19525b9d73a0d5d3fb005e500d533051a5eb150308e0f4d9fde9730a7f637446f00553d0c10d129f1f37d93a022a89b3126ae882ee96d0b217d75ea445137c919d054121e6c339d3b583db38048fd0a214b24bcc5a3e5ebca07a594f21a8416a9c86fb14b2ab2df4ef99079745ea24dc4e0ecfb55f6b4f5ad817a6a1c10a586806ce5149bc1e489fca91ec34714c94b9468ff2b3de21fbdfebc1bf552666f9c26cdd502cc072b73a729e895df8c1e4b0820dab0cae57cebf340e98d778bcfcd077c434243dd0a83b17feafaeea641795eaeeb1395740fcba8b3f9b96bf54039b033e75150d8d68c1ceb24662fa210db816949d23f59291c97c30618de0d11a93a498116d1dba4e3453ad6afb7513f621439ad74f3dd2b3ead4b414c7d4edd1f305d8a02b0389c9c7dc757a32b6d6fa8794bc6144f571b151d9ce4eb18ec1939bf9cc0a687920cd0d61e9567be0045b3ff9e5914d67f286c1f09233ff1837676ccb3c319f8b47e940087bfe1aaf173dd7b04dd1ccb0b82effe2806db829052f8124ad895fecc53802f54c5d910ec970f24b38de8a6ce3f1fd9cd90628e92e59bef503117c0d0918231ba67d883fc198ce737fb57b1577112991178c8485c7a95ae5ed6bd1135d2062a2b78bf8849bd84f2cdbfaeb91e5962642b847aafe93cfdf62fe6f8b61dbac03cffabfebd564d7ff2c65ab47c8f4675aaa24c5bc41d046b767fc1a54a21ee08475b62b7bef42b069962ee4770ede4461012e7f1585cc84319a6bd89ac552946d59c2476de0cfebf8bbf433ea7cf61cf82b6e117c942eabe3572e1cd8b60b709d4f83fbce649a17164c0d7c2979002b0fedb85aa313aa97313b87116b5c03b713e8b725704288f6cc336a612e3acc9a734dedb6469dfe47ddb5434134f1cd45093ae0f3e84d2ab8a626c04f246414abb517bba1fcf18e0137047ee415f3917b061de17dd82217d53aa546853210b20cfedbb1285f4ea609e1d477084dac3c8725cd0c3a78ea482c1c87eff2c7ae445d820e2ce09cb611706eefa942b40e8d1b4289ab6a80d6ceb8ddc22c06646cca79567b974c9712ed563a2d4935a50fd51b9e149b863a3c9d1adb95ba4d4c5bd33b1907c7751db5807ecaf3b2b5a7c67783377402e4694320f18be03f45236c33d6af29321327c86cc8c0a171e831f5b61a62f39b6c3687b6db3704c1ee961e7e1199d33cc80309e5ebc4edfc737ad0ff7a2985fcbb86d2cf4efaea86e40a30b24e400868b09b867e2567f8f420d22f42a2105e81bfc5a9feef15fc09b1d16ce46b8cb3f1e2157c91f2c6224548cbf1d14b381f441824f262cb8a1c4a7f2694e59387becd0652ea11067eef0835d88e0c997202b4097f8ef958418937aab492b7ce61b8f5a463c25cff4f8e8bee3096d61a7e4d69fd7fa924e4bb6e5a3d64a9f3721ea823dba8ac81562c0111343b173cd0200eb54e1c991154ef88ea2bbaf52444600bb19c36ff3bd6fc4d50cd32c303a004745e8956d1c50abe1ec490de7baeb32a39e50f21e594e03c59779df7d0eda9cc30101b3b026327833ddda0899eeb6dd9a7e1d030d75590dece741fcb3cc7ca075b9185ab2941953a5be1d8c59384b758977b4cc87f45e434f72bcc707c6e55661a1c1a5ac7cac19da3d6c686ec5944509f87d0f33ebc3b93a7b98ff74ac1883369781dff2a03b0091913ed358a347cb9749f787b23cb215b4afb63377a36c0a42fe0c9b0b299f41984081dbe18cfe34e5fef914a9a83c9b69589d73520a28bc3838abe1c2aab06432cf2aa9af5c3f18d341c060cb51b54552af559ea3101c06c901e01ad4b4af91050b10d0a0ff8bf1754f71c291a06e51b86c1175bdc9acaef6e328d2d6269d9602db54c76876d13d6756911f4c4ecb019c5e373327786ecba91f0546d680c8b13b77cf645f5d563655c83d97b909cf49f7a43f8e7fa4f4b9af46c3ab0dd4cd8003cd3dd616c395aedabcdb1bfb43cce9f007db692d0f7b9ac6d46756d0c0a49b4c4bd2da22383df12b3d4a94d5005329e69d07e3c5713721499719c73ad78add9f1594d4381ce3872771423ebf83ced7860acde3d1254d001b11c1a0076ae28e29be12ef36c7da90317b90b50974ef9ab99fe1eacbaa92f7c5e9887df04540d0e6f00c080633c692cf2674d38a75b9defcf216119857abfcf1af0332018489f3a5108a3b376433edb62bf4db6f9a1b3029d2a677a2c200fa76ca922a8558e859fc06f04dfddf8e8f5e6dd7b5d84e55820cff8d6a7a565bcbd26ecb9508790d4015701c9fc7ef93dbf16f6835f107589c9cf059a7737bdb1dffa8519c31e73e95779e38a9da471c710de2d65be73435710d8c89dc1de96799d89e19e327e1c8561d1ef63804575a5b3766c6d81f10b65a8563db153d8267f03b003456e603bc063931d436ce828945d7e7df452523f78390360442e7c5dbec50b571e751aa79c863dd442f1c1a52900ed017405539c5e64deb7777d82d141fb95fdbd871dc6176fc0afa9bd423581c8a71613590a7368918f24e4ae51519af4dbdf1c5376091e5fe0b625053b9273d2e79034c0f451a6126a9dc72368a7b68c89cc2c8146e9cf89530363012fb337838bd400574056ab160737df2db01d8e347b70c2a546dc1427708e1ae2b79a983d8c358835d30e442da1f84d805827cea636cb0ecb75d4da9e8dc2963a527238334ce3bb3642999f61bfe63131271e00ba54aedc5caefb1cdfdf1cbb94cc6d957a3bd7bfbcbdad57cde087985bdaa3a7b14572be519afbb39e9fcd9f73704daf4257ca429403fff8f1f941d20a429aab82c039e8dfc12dccbf876e5e954029337ed9728c90b4675b0ae969143856ab734e963c24f4cd397e917d6026c6153349efbed924bd913ee5f640b0ec52e4cfa5163c9db553267993f73717c63c073681c26604e1d12912aee98a0ada677ab5b34944cc787cd994fadcc279e2fc688eeb34bfc4fda216e2e08032fb7ce1644c7275b0aeffd723c1582e8eee767564bae0c86fa1545fd10be5df337e143fc3ffa81c612bf963ade7e2c0a5c7f71d96c98f5fdbd84ab3ca57a920b220bdb0f0070145a758693a591748665190a8dc2d305fb62f8551c14920ea655509611ff55e208381032c23a824ef04d8657e4072a41a06f493552b0233059bfb98e69e0d9e6ce4b793318cab7cc89d3d8d04b560d370951c689c46e7e901eaf9af7ca3af2f3d1be39a302dc7c2ac9766be78d3cea9a9a4183074b109ec003fbc771abf8059e5b547962cea43da299457ea6d41bc2fc82e2b3a0687e81b0a65802b64bfb97c61181062cc24b8901f881987c882e34a02845ce91efd92e5cf41fc38f3530c5b4e80bc3b5ad67238c0946023810b6c87c2e378598a09dbeff9b9023c01197d947e676daa32253f6920fe6716b9bf8a777f3fcab9501c9b17f6feaee4252513a73794f8b06c0e121cc9dc4fdf3e06277180395c3832f776192d000543d46d00e40b452a1cb6c73958099310a44bb1e2e8fe119edebdd45621f64996904d3f15ef1b3dec2e1feabaf16b86f4a2f5237210a2936f2e9320ee7eec62f05dc262239a70b8f708044e5159815358bf863ed85abb54f00963d75d8ce5d7df8bb68400dc7b5a11c30376a9f7c04beca2626cf059f7973702d3add1c4e7c21b53805cc4306d0c9bcce0800e1ece0c015362b6c956f144e7eb44d0848b3dd2bfe13d7b1adbec82ef63a190d20d937c8a41c8ea9442d29bc4c1e57a2eb44590e76ea635d6128fa804ab00b033faaa64c72b8752e5b5b3d8b30728a98efc3b30a5e0701d8d3e7dd6226ff59fed2fe3fdd3e184577e0ffac4326b887b5e7d29458f3da2dc229e44f971816bd9fe317bcff919c7b1365afc9c5315557a7d946dce8f283180e8d4d72d1245dcaebb041f7454470e5f12a84ebf2563d83a2b5e9621d306f288d2fe5f218a7d5d701ae96d0ea422e1d28559b94d8affd3b2ea1467410fd45b618193823cbb717918cc9f57a2e7784e1223899bc25cffcc07a1e519409fc14f833367ac697bcf2ebb7ba13bde24363f85c08aa0b16a480161b33c802b659d5c37fc8383d487e797fb44441449a12c6e461369928ad1a595a258a936d2d2070c4c7b372725a8a554657271060ff429f5356ebc4371bf8e1b24208df6830f804fb1b5099f0b211669f80922c8adc29aeab23557402f2588709edb60181f17b2d1f22911e4bdb9d0cad209502b157254478728866b1d28507382e354f35a0af533845f7835fb69c194a15d8afa4d7a3410c2f8fe57cb12d5c74875bc390be53ee59de19df0f47a0a1345c73f9d762d65e3ca16b205b5f7281cb39c7a5d07f609249e823bd9e06c3f82765f715303ba29ba96945ae784ee8b21d57aab0372e98b5092e2dd1a017939375702eb71c075db7b86107298f62f597b2f54649a6721ff69364162d6e405e58ab30f7f0c7bb9d3197eade843409a0b1f1a5d15a10316edd0aeaa4271ed294f2e404d989332c018a03a263c96f2f84a441fefd749e8aefe0d3ef4d0e794546b96cdb04dd734f847674df6754941a72b10e941d26bc7dacd90d2b00e9a6d2db6c3c342b195b34b484cd21f78a29e98cbc14d1992761692bc29c6fd311009454b9065e55ec5925db7a740051df5a783df0361f442717544d1884ab6eaa8e150138f506198fafb1bec5fe75911a55a8cb0a3c22f30e4df999d3f4a312890c4205b4d0dc1f7d0cf71423f10cce263d021dffabd94c518287ed19a92cdda44bd5a1b9bff94b2f0555ce205819ce2e4eb9cc15d78d218b27305f2ecc49b9016403b668377ac95558461de5f0aa57a92e6382005886b89929a2977561720340fc10e002d76d80de877ff4a3caf7a5c0d5f930b773b1b55c4f5d6d16b149fc9c158f62c37484d0876ae9df841c96bd20edfa625e41415aadb54636caf4eaaaa512fbab59c94206ea37a985f382debb6dddbcd652cd5c35ac91810cf2759e1f788bf0fe94f77aa62c6218a82ee7d88ad156ca7d368f8f316cc017845c7d3f1652697e8b8691714e5dea4dba6504b194ef5f79810433a49bf63db602fb8ffefefbadf135154299a591194717a7fad2243fa35e32da4c7cb6405ad71000aced9bef12bc1ee8308ec84fecc34e17afd13bb3b00f317d52bc275888e8b80e1d7003a526078dc98dacf5c3a7687cd612d640b218388bbfa937d7fd36f7f103c60a5b04652c361009069d2a6ff0c671990163bb83ea2ae55a427e443dd7585a306b8541c163460091d9411a84e7c345b509a36f109f305e23e70f5874b334fc5d26888f52e2bb0295ebd6809ad28d8cfc012a5b3b5f412763113801abb2be8a5681e26f29349fec5b2fa281e76723d6fa35bd2fce395eac9cf58e2e85963971ad771465848ed243432ffe80cea3ae9f7a31d8eb04037e5e83613156605c12234535053fbe5244442d3d4ffc52e53f3e56cdfbb2f05a46f94269eac282613c818f7f0bbed7a03795ac689f041d35fcfb0dc5543be62c2916ddb47fd26033929429437d2d2628f4fef4d0e8a2aefb798b2296c4a997b2da736e8d078630908c3eeeb2648404429402918fda2c67003ee2fd02544ec72489a309d0b268d8b6dc153b8fa2fa1d8fa44161648fae57a883195a663025daa3dbacb7b660767151b72579bde6fa405cb8236018ad0fd5ba9f59e29773588fd9722dc43ed1be98d6f7fa33f80bc4572559f3e36436a502ee89aef69920b29d25e891d2f1a429a1ebce2ede0d7795b79c5e01385d596743447d239b2a79df92ac96c870ca9b2b9cf8de371d258aab6cfb40f5d0c11aaec9fa679753c5e63a331cc1e4f5ecea7b148627b4d9e4d1c75fda7f7763be9e5cbdf66d80b5fc7432b777d04f193fc6b4b176cf7570055159c541fc546a8501798762c0d87edf5e30a2188f63319f382fd836bd1a499843a7ac25fefba94be62facbbf819c828d32f868ab822cc27426e11c922052ba97ea5a696a6713dbccffe94a1455425c4cbf69b116f6f87536cb8fd30d6d41b9ae811a064a4af5904fc4ae72fa2ff24f48a5ae129564127e67e80226221e9d454f7206f919d735a5772d52db3bec482baf64be497cbb1c593a8e8b37a6e8d816ce999dc68397243fab6adc40cf9f2115e7d9f1e7f8de819d140971ebd8c30ea26a0712f30b1b4d6431b6e52405498d4a99fff7149a1ba16064e46bc49181e5a3866786bd6080ae651c2aa43c5ac6f5af86f1abbcd6f19dec9851015bf8abb76c2f73edbf1de5d61c7825c1d676b69addbf6d5ef6647cefc91b54220fccd1219db49d1b5d810f639d58c4b48cf61a21e72bb8bb9cf05b7cf072e82b268cc111936f2d5918016934ef596c2d71f308fbcb9c868c6b8f02fbcb1c184fcf957c32b7e4c8058313523460a13c1c51ee06d712b555d30c9ab7d77196016713bd5ca23b250121d793a3d64ad501b08b2621586823a40fac9b64aba8de60e455f2972f5d9ede6fb5dd5f938298262aa77eaaaf4f18fe875fb3b271d46d94216e63e9e0beb2a2810bbe0c43d0326b515c419c58d9c3d2f8a9da758145c8b542422a55d5d47590da372c88e98a305c3c179f13fbe9dca855517bf80dd34c481f60ee722f213bb7225b1b254052af111c472120ce12f66dac44f84bc26d729d58cea2ab4311aa07698a19b3a9fc88a8959210500d1e5b4c9562a5a5fb37205fef5d364be04b692abfae5d645c860e6c9ae32cf82912eb7f435270bea8f1461ac1e094846bc63c7aed019a85e7821dd428dd2696a88afd922024a7d93631dd7000e5e93f91b17146a540c277fa920d09aeafedab66ead05a79302e78c40ac74c9d6d8fde15f43704f7b3ce6bb60cc8ef79c4a5c3596ad28edc61271ea84194febd98da7b4f454137818b42de9c87020ff465d8fcd826d8cbf8d90b25673f92460654b81daf2b446b7a2d0db0b5c8fc4f774d14d3b6e2546d32392157dc958cf40a79c1c9a7f0bd950bf02923fb0f6f77c4184b37c0ef03e155fb033f73cc0a1da0d99e51f905abf8994dd75945fbb93b9d171cfaed7876f76ed3ec4c2b2cae5327651ed16effa9b29f58af023db29a682586e8438dbebc304a20ac51efd1a4f14966626e42a59e8d19d4b54703c4f80eabef9046e9b174aac080c291218a12fffe39a0e63a1093ef55523ebd5e49c3c246821d351b51e7b429a21b78e9c728157dbe86d5202e19f165416d4223d72f555d0399e3bf21832a6e92a92d29d68878be89762606769862980eb421250421034c4c0a023eaa5a997621eb683d6351e8cd8145b8b02afad584e99747c648b3547663caaebe009691b114d32375a54a64fc0f75c9b786f31e3e1515a1ed71dd5d20bbc807897d05b6baeec2ef98d7bee46a25f1aa639d95d1f179f74a65478e78b56e149d602d168d1213fc0257e98f43be4373c03af237dfbd75cb0dbcc6a991d59cda960824008a49f6192704486b0d429789133a46e9ab703d1d1336801eeda38bb253871fac0f9386485a93df3a8102127209d198113d4d92dca4993d9fc5d745c4611b1642b22ee1724747cf453a0a5bb083673106d54ce9ed19b010cf0207fde5fe3f9eacb5ecbe4e86b87fc5061e24fcc1f43992055289651b3c7ae94d9fd42a0156ad81509d17e2771ac5dd05f91f86054483af6284ada31b55e2ce9eebaeec7115ccdf9cd7aac15916e11010421b5ab070b8e2d1bd89296df07108f0b230165560e5708f8429496ef9086282b16b095c271022c7be2245170375a4ee1d70488ddb04ab96975375e6982c2ca45407630c57a7bc6752027d6dec003f250d467838cf04126f04dea1a58d5633b60bc12902e4f377cd051acba454a6e2290699491854ef40834f5ff8f5a08787fe1c3bd9ea35cb7673b79ce217c730b1cc07c349d5e8a13e1e8a87fb516e28790cfb892e2d957441e3bf8eedb8502a5612e650ff8468ccc1db27999a9b2e83f6fedb8ae060b7f744552b0788ae9054f7ccfa1cbd2181bf570dd186c04877284eb5350bb907d6363d6cc5e1e534ce044c0378c5df1535a0b65edefbd19acfda6eaa59552870462dc43c99a610899052e1c76e4be0bcf88b4ed2d5834b66d0e85f84d02dea7dac3425c5a7281b9b53b8decf68c077e046babea11a1fbdce73bd6454465d99394880bb20e732a3f0cc051d05d966046bc76bd831e71bb17fbfe358d0052d71c4e6025ec5dcba4f76ae5e7a099d48fee8d2545de3a3882001f8d467ac4f57c82dfc7bcb1798829fe7e5f83f0ac1caefa99e80d17792b407a14fb81b311d9df57f528b148a20284aad43b096cc61f48b50c07af3a2e1c6aca823f8aa7b16a239655832ef39d41f70e529d000a98e5aa94870d1c63a0f50ae687ac494715df461d0077f3df5dc5c29c5fbbe2a55916f7f878056e57d0a60f56d10fa775f926ff7de26fd137b1b913ea1f30c680e5c73ada1ac645934a5a91b858ca92bb3e3c19a2d81b8bccebd69f5e7d4f1ad53e651fb652bcf77e8d414950b0517cacec6272c9c76befa400dc8cd7668ed61f144f7a1046e681438b5c7ceaacef5a2d6b066736123f30421284b57afe140d74700f8a9a02a8564ef0125650a91bd82740835f42a2514892d58f57d93353c67da286628f92cc9e6a8fe4b22b24edf5a7eb9d3307a3bbe4c1bddb9e7a4058fcda097109a0faf61afe183fe89add20c8397e4274c9251013cb5724d2b81386948ca37be911ef4f995fafa89bdf2359bf5bdb875119aa85a0238644eb7f92a390a4e082b0207440d16bc2b0409b528e9c928580f16ca1508761fd2735e8cc9bec5299ca3bd2221c53f61d8a1559dd6dc71c1a78b35df13091faca89ecad846e6f973541c545bd14bfb0d57ab1906cb5be22591e9ee557ed99ad71cafdb01d46b92e7f46eb718c0a5c1a9f9d1e379576295d0c6178ba1c98742123eece8c56d336147d6c6ac1bbf1a9225bd30f6a2ae4aca91d4c22d44dc05ffdeb91796a56c459aeeb6feb1ea18c6ce4151e4ac59ff31ef0f420de1d247720ffaf2f2b3d8360b2a632500d4996a77e5e3c55b89c8192ada8d7b4fcc2e9e50421e3f169ae8515277532cac71c0d5b96632267490893f5e6300723f4bc7463772c05cbc9ad5ee43664e2271ea0d507906764f4ed166bcfefb38b27c7dab59a875b9c2217916a65cad570d3bfe5b4ed0fd0a415706bf6e8a3acc23b6ec5e26eeafbbd79aa2a6cf35d3372e57b1bc2fe0f84feeaf873162a794b3b391c76d464e28a7a3616aaaa05c540fcb2a557077d357e38695068d5dd96259a2277ab7c82586379d32a2a98fa86aabe0e7f2f46869bb3f4aa072a0ca32e23fcc1a13edbe1ea37c36281f5ee121a4299bbc3881ebca191fce9fd118726b5ad7a7190f06d03a949cae164073cfe265f44cda8641e5e13e5e7b2db7ac0bbc23b5aa5e632f170840de036c1a8b34e0de7f5298b057e457cf29ddfa5e65b0d2d6e117ae670c1a7d9d2a719187361150e7587a88cb454bf5044a83053943d8584de9d5fe123864344a9bdfbaecc97fba6209e2c349d4a5af97699ad026ae1eedcc4d3f92c4c3ff57fb7b7088610d0b874ca3745820c9b959665364e3e490bf5f21247202a10a08cca9c30f05c838fcde032014b559fa12e28966006f557ba0eff7e33d5bb95d16c0f5873a4c84249acfac5710e732b5f6aa9a91ffb04c53dba6a41e98498a71e898a288670141f3a859d25a3045664b883161416412e3f62a153797d1990d8f850f663c52ef0a2fb9cfb8e9dd1eb8380746d51c9cf66fd33e711f87c9cd6c72c59ef1801820d5d949c51b25528466189dbbf0b94f2e4076f7d22daebff7f272132da73a8f86c3baff27370cb8326dee1d053d6fe32da228fa4febdea07e45d93c13265f19a52f3d822ca832f05ce24ee6bea3f859376e8841b84df7ca65a55169a5333fd18781f53992fb028ca487d44586240f4a7bc34745539dea32d25824ff8b9d792495f5fa13be817f052ef2372481ace9dd3ebce5f30be20b83e406d23c3069a4a6fd19e969dc314078e077f1fc1e6e61755532619fadab81e1467203d4e03c9e2c917c1dbd800465b0945d65f980c47c1a74c8f1255c1461a2e41da84c59479c2f70c89e65503b71649b322fc0b3b299dbf43f4e08fbc96f5801f6de163f93f82685d34c6376de5360a6920c36ff88a832ac1827a955c6a9f79c150c3392ea42733df5131ca0ebcb4e8326163b22cb3555b3dd11e815a329042edf9beb311a7252ece5993bebab93c784974be61324b0b8345a46b8d9b30301104f22f9a33b96c24d1215aacd0775ff94b7b406a18c3aaf004fbdb1dc987a5ffc9f37e86ad0fdc0bf74d34ead84ada35b37a692dbf0aef003d9d571d20cf540e642a940f4f796055f678adbd38c675284bdae355e0b5c71aed274ae311b91a210a013fecb47b09a57b6de7a78d50cac12f55d1b1bfd702cd79f9fa6e01a8ef56f3d9522fee65af0460029078cddc22b9692e64f0304c7595d59a33a708e807ee388a9ad8e190834878e649d8b7e9533cdc1cb7f82d4522a12eb1c66ef11a62e0e1fd21079974340de6daa42ba3bfcec415b80ddf6f3c76d1dd116b31f2e187b036d3310dc202ee68637ca38aefb819980b7c254cbde14ced657c4c7322e82fcb39591b19f6b3502c84891ed8449de8045070f5d9171eb24012ffde20f1bdc6744482b72b159b059febcbddfb8eb074a4e6db6ae8bf3559bf358a13b2cbc6744b4de6b01426d923810f593355f4cb73f6d1c6f25ca8d14b04a99481bf76a5ac08b55d229ac586ed6ce86db2ceb0e77cfe8a9ee9502f5ca053452048ebec778933cf13ff272effe1811b96246e1d207b8b95d0efa3fc8e3e827c2c3f3db1a22e8b3b7e92eb7d93a9bfcba8dcd790fc8f5869c095701ae4d6aced62b2117d3b9daaea0c50c0abec97f4ba4b1609b78b6c2ce5a995f0608ca923fecb70955d4ad5c49bdab204e4fae5f83f343a3402a00e7c814e74097e0e7abb5079bc1737d4548b76e2fb51a91a354db40e6283c4c91b1bb8223ad79df0a93a6dfc130c8dfe90f8d5444f2bc65260c7d0aa363396d19791abc4b0295bb9df5b639ff6aecbdbb16b84be7a63994bccf61d1442b41a5c0fbb432a385010a3e81bed78b3ad05423cb0a7d517958dc099e09cf314917d7da8faa56feb9f272867c0dcf65c8516288cbb6ac1c2414c8ada0798f62e9c2a597208b728acef3cd6337368824925970f06f1dffdddf90c161b4c00c31827c2b0549dc19d572c5284b3a787a36ad0c09e021235209b31a0cee1414cfe112848fe76f40fb0e6eb3e4fd07d461e81c6d60fa9eb404a77e947d9a379e3bad0c91b8610a522d25c8f433ddfbbaaef704ba0c02d1e92550dcb1a158e1aaad52d971bc2d86e986d446ba072b7d88d4c30430478193ebcd11faf6f63391bdc5d6790eba81356eb275f1004de3ae6286a263d39089425041efa6554e227539ca4a6bfa95fddf66bde03c64a66207578c9f3f415982b4cc6fb44d81e4c3307db5285db79fa084fbfa96069ccf51fecabdbb22c99835872993c48dfadbd7ae4de12059011534cbfadcf3b8bada2a3aefd88eec8c3827c9aa843c815f14545501a08d2ca8596f6cee7b4ca84d00c781bd3b4568d821f61bc314fa7e1bbdd1e34721f8278b3ce9ee644e63fe2b1ed09a216036599278584671a6cf13ffecbb527906c5d2415fc6477e4d8273b0ea8ac1b7c32c4e79e7c3a857d89b55c9ebb7d1f498e30ef055bc5cb84947f4ac8f3e6735e3daae71e854450272db5a1c9101c203b9883a629ea24b612e92ee662a379c196135e95c60c20a709804139e96991d9dff3b8b1e245eae6fb9d24ebfb76c15bf8c1c6100cb632f221f58f669ac4066609c483ce10020d15b443b6759f87d20fc6c6173c274268bf03766db4e6bc30a5267055278619df9776e61a23b7fce1f55dcc8adfd5efac966eb66794bb2f12eb7198e835e806d48332834547dcadb11470f4a7ecd14bf43eb551e61cb7d499b06aeed91d5edcd445a5bc83884f82bb594be394ea590d5c4af584aa9518e843bf0a6c2d271a9550065a54cc608154d166670dbe9e58ed41b5e8ecabddccb7df5c6e3011f07123c23596edf5832a5f5a112b8a429a43e518b4ecd8925effcbd239624dda9ab0f2e64f752a15bd202bf29bd5bd5cb660dd281ab4af9c4b4c2c2225d20ebfc23ac86f095ff256302c71f3e8c1b61980cff244dd5b200b5401da206f490eefa7e6161e3ec676f045b27c2260b9231af0bb8b1d34204f04ca52297f8bbb19aa3e4fed8bffb52b79daf76bd63b0aafe084920e0826974400f8021672f8210da03c182fff624f9865fa85d3a664f3e38541825ac03dd902c26508ce36961152124b0b5f0c771efd641e047070841e091155085b0f85278496b3226633f0795b61bb8394cdf898cce7dd3f6f867a6bede031a9d41921564014ebc85d44b788895b3b333ab68a1623b7384f65320b8e7f0706f24a149f7a6efa9bd11dfaf0c171b3f258899533302838a0bbb7d50b2e056bceb1489086f43b57dabd290c0e8f1a46efbaeef254800ad2979d23c47a1557ba6d4b218650edea5e74baf8c813ce73aefcbc6a22d4d23d754d937f9ef40883d6e3fb00261d4edb5b0262b29b6f38d87ab4b5e8696a913e38ff806024c27d77a0e6c4b5a05fa04d7c5510c40f074e0340c790b998b1ab93e7792240f45b2327aac47ea2174dd208cba75afb030b336b68e1d14c60a76d7ed10c6b4cecaba1e16942d29937b8bf52edff47be37d24d1782268d99cf5886f4b2fe952064a18fcceb970d4a407559d70baddf61ba57162063e01b074bc72736ca49ab46b1a18a2add5d3adf5fdb17f7bbe3012eeea59a7e0f907fa671d092bd7daf4a33d0390e166df613c569fdf6dafa63712fc9ca835d6a7fc54125632b7c61cfc672c63730863b5ed178fc176d54e8b4e99d293b1b7cade79cc6a986f7baabdd1e7ec7c2b92ff258f9ad4a8de2c18eb5a32bf394a24482cbcbc6005f8ce75f8cfe9f813de0f29a99e5b0b5b407a884efa0b140fa4cc94da14272dd489c1ad82469afb016e7903a59dedd9d54b9f5b4f8bf6906eff82af05aa3d8d2c2153abba3d649e839b379d7482d57bde08fe10e16566f69b2e3429204bc79f178a46ebdbe331bbbf02196a95e864129d01ed2ac262b7e313466f9f4a4a75b55aeb9fcf9fe7fa5d71d6b7f912405930f0de6cd5ae91eee04f2cda611737c8bfb9ef3de50311116f207db42ca39d6d9a68d628e05380fceeac80e795076675f6b5cfbf4c6b4ef11719c1f6c951da743a0cd0abfcfb32faffbf63222fabf6aa8b88f1bdd1934f4fac3722a2a726e8e962f4a2433d2310111586fdaccf939c7b7c32196bd679eb5036a57b429f51671a1ae2f50d9a7b5b37b0f7b52870a6bef5562a4c84aace5adddd157b08572357cecd343ee203374cb200851a80ae1ffd88837952dbb7e30d0af72abaf04636a98505828fe7537751c59e3fc99b3f16333b99985fb0d9d7fef8182f8e93e36fe8bb7eb0e184f351bd3d09b775fc38b9f0b9ec4019c396c3309ef7b0fa09e2d6461d1e7c11f13a08808ea3a7c9295085755bac079c33c86fdc42a8436ae6f3597bcd838f9295cac67ae7f05eb7bcfa9dddd7a1d78034418dc7071dc5b5a9c44ce0af03eb997d33e088028f6a321cb192edda128fcce4d74e3e43943561f8ff9600ba465a844e5b92d2d57910f6d9b8cfb21c574b081daa18ca9b9d70048f6628a3a3bb8a533600f83ad030b2d8d7f41dfadc24c5dddbbd1b784d01c9ac4e3a5fc412bd53aa4672a202576bfcfd75dda848dd1cdee6c65afd704ea38b378e914af28dd5ad5882366f2ee563916f7a99c18dd61b86e1c4f9168c16a3119b1e66762c51557f27d10250641e4e91e43a0d1b9b10c2788675b59bf60634d300a32c82ff5a51ca2f6b69bcbc21ec27c36a75a0298595cc2d0fe282c9c5b8a95461b3fe95ad1ff527dd93c58c4caf0356709a5eb9e4d3874a7f33ea38c4ebd0b362f98ce867cc970eb0503f1a3a4c0891f0b95d1c0cd09de85326bbfbe490817bb8c12335165bcc3f120f3577ee9093bf55c8b1f1209e82370c5cf4d59154f0cf41b5aff8db8374ead9b99aa3bdba1d022eed6b0e26db83b4d86e73949c9684c5fafec46a461f2e606123550d8815bc79b68bcd2513f1f9c0cd3287bb0f1cb740927c9ea28178cf349fc0c629ffa5ce11dd00269576b23817f60df6a023ed895fa43296c41e556315dd5d7f9bfabb0d41842271c4ee4eb11b0b975309db443f18128ecd090238d667e33c804b2b85e05c86e28f6a48add8eedece4c2c8113d669a5bd739f0f8137efa6e58679a64a76be948fb7179f53978dab151927893c5fd74e8ea0a7b9822d96512681b71d7b455bf5cf30a54cce0cd631d4aec23af53901ce45289bb87e7d7b1a3d522067183134700cfe21a5d1e069dd313c32bdc1716b5fdf67ad72950aab5efe1e545fb30fe55dde282f74799d011257858aed3053c22c836be328bbac4f581a57d4b0739f3ed597fc69b7248223e72736c95de26d2edf167cd2c47a23ec7fc15f2ca1f22f13a3496d5a4843a091901c0bad5cd8e47d85923685c156c9c1c92724f9e8210dfd4f396ae3a318b2416c9732fd037f5502b30522cbee12cdef920232e19dfb4ea9a6f0601bf3627c40c87203a9b35d4e27066cd396611c8f149695538c06cc92b046c9deb0bcccf0d9fd3bb46ccfdfec1d1251afe4efc14ad5850ff10807fd1139398c16c24a838811c583b75d49a26a4acc10a30d89848bdad0a8c8eeea3318742ead0e3be77f39b5e79c3c20da7beccbff0942c2abcf73ae7ba21cd90c1ed91a4b8a9f96cf149b00a48e9db77f92e1f27740540f82cc87d41df5560b3c6ce6d055718b0bfdd3cce8c25b7e2441c8728d92a1f06748c8b25342bf5981785ad944184454c9e5d4ec259eb239635d95a69eff608cc85b5c6bc11cd7b7050fae3f437ba8c1c35ab473f5f488194cc80f94bd128550d1c5db6a23c4aa55bd0d80ab282652107f2ea73a8c074a5ba75dcc5a6830c28832633794637213d5eb377f5f91bee7ec5b33a26d9d0c4b625ba201d2891cab740d26e749d4174a91f6e48b53d74b273d29661045562584558bfaae16f1eb5a309b7c0ed03fdc2b7c89769ac8d55a5a094b29dea28b2d054361a5ebbeab99230b52310e381709ec75706e72c295ebf7b9a9fc5287aaf9cfb8600f2b3d5bf0b71643c44b198bf3311568718e92c51b8bac2892dc2500e6fa71b4ce2e9ac8a35ff86b91352dcfefbcc05ad8c3a36575e1269267b521c70cad6cf5cf5f046ffb4473d1ef1a512f1787105c99252099a34529da115b9a4b921fd95f61083897c42ba9b6d8a5ea8f5b2fa09be4c0f6d18d1502de70e780fe86486e0409f027fa02464f9bd64e15215815f41d151b5ad2ba636e34dc42d85db51abcd809677db12972c97b66441c8eb29cf0d334b9fb6cc905c9f136165e6c0b274b4bfd2635346a009f378d5edeefc11da2339b3cf401a0cfceba00253c34c698ac5446c88a3e06de03d6f7e62235d32c37c504e2f532c21a3c6afa259576cd2fc7aafac8fd8fc5503e860ac8fa43bd8e433ba37bf8f558658d5f75b576b3adc0120ac997c8169b754e742470f98ea0dd126f22949f77320af9a630a7d12ded02bdd105692fa697c58d65253f3db0e4b0267615c739178315ab9b86116a65e88e01666a2dfeb119a256561cc4b171746f2da0917d84c55511f81126b563a9c154bfcc7a56b6b2525bf8adf8d2f1fe36e1c763bff1cfcc38e7655b11e783af89d4666bf075e0a9615cad4f1cb6916b73133f29de12daed03daf4bc632bf1253a1220a9a8bf463b7ca84154d79865f58a954f6567110c387e82866bb37aa7b8aa3deba7eccf82cb95e777ef06af459ddd0c65b51dc20403e7fb88490d79a079fe6e802044ece4d41036e9f1c552558f470384ced53f73eb7af1a890ff28490c19b0fd2b9baafac1ef645a37c0af515603bd913de9e4339f9fe0a36b45c582d163998454f9a961560d7760e00440944563f9872afa502a70c847365a3c40fb656c631f8d454d50d76fc6caf952739f744d0e2bdb76fd2f3785ef3077e0d9e7aa5edca4dcf9551267ed63c844e7b452dfe50885600c14301ddd508486910b929b1fef7d8894999d9b5386f5c6f644bb5f8dd1ad26984c4ef743f54acb7b08bc548a7e29f669428603d901356cd9520eb47e1735cefba908642748f60d2975128352bbf68498c9d883657bcb1723ce1d187f75ad900f2ea85f65a0657b82cf4b01624805cc8cd8e552d473dcb5568e0059dca21f98374dea8fdabb1a6481602f50ea5377f6533f5f224a860ce68420870e9e7e6eea4c9928fd8193cfbba96cb176f9dae2443d64561d500a7de1e470c4b377e3a5851b9cde66ab82a4978e534f49b552bb2c506f2db0e5e65e2d3cec8e30fd80a502a451fdcafd1a669144eec7633cfd0a05d180e418768c5b9f0d61a5605487e7157c269b267cdff3419563b300e3fd78c4b6c2c94abd139d8c8b9f5ee05ed2d8d5669e70ef12d93a3d43f47878eee4437524ab9dbc1debe31e3e04b2fcd1edb01720c9a3355b636b485e462578db5ca3c9a24cc431cd2bdfbabd96f348856534d9995042ad09de57c981acb8eaa03dbd75fc1117efe1d3520e04af9baa4546ea971aa5d560efb86c99a5657182846d9e7d6fe28da532a1854a5ae58566f586849fecde3a57e65f893b640a95c94240ce5e320a68155f4af5e150b5a6b84e43d821db7206703d3bfbdd5a9d3fb3d6a5405504a3d09db643f28bde75114e1f914516a8b76b6f408f06ad35d3377c38e44da614aa56324fb5d3dca4e00623e09fd6f29cdd5d43d08106866b59e58d068987ce7d68ee0431dc6625a76f12b6e680faa60f31ef6e718207c14c18cd43b4860c5e24729377007a95371643a70e2a8ff81250aab96cc4536a0d8cd109a696a5a89031d84cdbabbfdb741dbb7adb192290122fd29493286dfc9521de694c97703f30389f96d80e6df92cda9266b1fe158ce43455da03813006f7efb015489fe5d2f6bf2468ac3693c6af96a67d4075dd9d8f806a51958be6a33da59e51bff852c049d8f92c03022681a21c7eb15c76a02080e0b26af92566e77a069379b8e75d691fec04120a28239a65044a758de0941a461645423eeb9ab16bc7d0c565530bbd00c423ff053add05068301695366f5f73ba558867320bf43e8974d4733d453ee973cd8ec5c6979aa03822e7a1a7e2e70d7107401f00bdd61c2035bfdcb74141b87834557910751289486b183fb7928dfe3ebd05914a081894c9955291e68cc813030a8694197d5d4d7bfbd5e383ec79a42c267c476e9897f8b63521c0f9b227238a3b6192f10c878ba6db36061eea48c31b15b00ef6cdfc351f9c0e1d9923cc8c9bca8598f2fb08af9846c2fafc067a718c35b6f1056939823bed5c74a948bab6480214c27a46acf120cf65d4fa94e4b1807eb78ef681e0ef40d27f02f62c1e2f134c6ea5b55155df0a31dead857c35f5e754aae410f90bfacbca54f4bf7f3f24bd69e5c0cd55fd32eb9c022b927b6ba30388e52f5709398f9d0c34ddcb42633c72b42b12fe98755e84da841a7d01ee9c3deedd2f85c8625fff3badf901326918bb45fb9c2881da48836bfb7142d2e5d87c13d413525d872ed645a838aeaf04f346811c30369e2ea607e922fdb0a3692f8c074950f14e78c5a355b3784571a9794b9a149d21eb4c80213c41d212958806388015140c38c68dd30b5b48989d00a689c53e2d3b33e63389f4b35ee9ad3a13b7944f7d7e77a3063d37b02b405d19ce44cd47bbf26a3f2c63842ec4be6874980824b46fc8486609ccff238b6a1264e1a02f2cb73346e16f07bad5c317d6928470490589ee184ff6f1be403a8c7bc27fca8f6d1188d652be09dae5cf56579f43e8c47c4d441d9a7ac97fa80036b5f96fecd260de14ea2bd4998e21b2d27a9e195d3a5d9a4ed0243b51f41932186dcf2c36e4c94d789ab4e86daa375f1b4dbffd8ac4cd40170e79ee3c45715477df534f23a93b3ddca6f6ce12f057508692989227c98b2afdf000b7f9f65158b820fde07eb2bb1d17f9a2d9e30b0450c538d46fbdaa4d8e44defbb28f13e66b2a83f8fa6b7cd298cfc68273ecfe2b5f63562c26b2ff8f53aee8185943bf3b2b55af26f3936d14119e9deb289e0173d0af575eb202553ad9faf31acee9df6111185af1735f3b9ccbba6ffd96233bdc2f049e78dad40fd90b64f3c43ce1d5eca03dee98f1d19744780022e669aae469e0269fba9d9c01bcbfa65558ccb5c2f4d4114d7bcacad8776b1f5b7d2b8cffc066878e55612e02693aa6e85c22f7b1fe79361fef07065606bacb1ee3200dafee73ee4d6da39194e20032ac29aa4c5f2016f0949f5fe0a88f3d40b7c1775df4ce8b70eda3a5ad94e9eab98d642e26fd35ff2ee0e755fa5d872c1bc629a05eec7009d9d7cb99f198ff7b18dc15bdf24b973927d8efcafb89cbaa63dd7bf58fd539d77c8bbf9b810b92ef2b36d42f988ebd497984b1e9600d703affcff3f8a3af8deee638e10eaaa0fa68787c93c19acc5fb4ac232c22d88d4e6c9422983de95d5f46cd9f5fd4952b935d90cf123bb8151b9a76f40a758fca8edbce8a57d76201b60cd9c6b824fbe6a6693a67790f4062061df084e73694a12f075c2e7c5dec2932a9681c72ce9539ea5990dc2b9ed3055e4b5a4b909ad46ac6dbd761378bc85bcb3dc6edca518bb456a4451427c455395bee311e913e3cdfebc2ba3875761cea4928412b9550dd05218d0f46f351ea7d4f1f346c728f10a462aa1e813e3eea154f189939997fe605a6f91c12c86da217261aeb01c81bbabc0e9996799b662fc687d9a0b7c22965c3460fbc26b267149a0b7bcfcb8a22013e0d80d2ef44c7f0c3e43a7cf6f64b7973354ee698d65f137c0bd49be87efbe7740a64f1c61c93b6314cc5609e58e442fc42631aac297b3ff7638e57dceadd75cda144ec59b31a1ec9588abba9bf744dfdc64ddd5f31ec6a6c4467ab25e660a672a467da611ae799f21dedb3dc9554d4c60d06ddccee6dceab4da382dd2525095b283af32e099d3a281089c306301d3b7e50b05fe859b80de8c41158dc396f414ad43bce0fcaa6d1ae1566ef5776b254583ebe11bbff5d6dd85f2fd7c60d37e38c906f21f3679f310d6f82de219ac601474d86237f5ec5579a954ebbb56d76fd206783ff779dc66d2597d759b0fc75d97569eed6388cf8d2f05163e934a1a09b385a452934d31c1047d5a8a34ec46ae1db62ec4836036a5bc56055f47f527c650c0ece3f29274dd129d943739723b129393e0380d4d3a341e61da5be4cb4a6099b5f04f448df9c7c61802ab09a49683eed546c7576620480edc6bc25afa9f495562430f19bb2c82c962548b4d6eef27df616c7a3411c7d415a8d0565016d5fcbd6a3f3ab575ecd2f39b6a0002a876050ae3803d50279a93976ce86800899d640c5cafd1a1ae93b40f9cd8dbe330f4a387db943574525a54d4c8cac0c770d1e225a94a3599997d0b511d8aa077285074b83a93ed4ed49aa8141f2107f933486d1b9976c3e96adce0c7e8d39d2ce1fc0cdca80e78d06d87eff63dc28aaab0488c4e10380bbb2c02d74d254dcac231b28e735d6adb8cc323e7ddcae27b3e8e78f64263caf4dd88c1b7bdbc1997e85ea0616d64a91efccf5117c2347dabf5c5346d9568ef5513062bdb869176a9621f9bdcf820112d72b4eef6bf49ba01fac56cf4ea0c9aa4cb01db544789c6fa5930a29ef69b68263dd8ace1c8020c22c20b39c4944a500a19c7b406ea9cf062f62e85087a3aefcc7f7c26bfc0db40d0a081eb49453ceb93725ab6b95a7a4c8879433ae07a6c9b43ace2cfbee9f83bbbbf44e9a1537bb60896583c067b8af82339fc443ef3b77ecc315dd0ef8b23ecd23528852a5fcfb6ad5dba0c5fc3e1c672d801a2db1407af1eee2b87635888663b33de51b421de44f7ca26b64fc2f8ea1663f1e9fdb7aa1e3a06944133ce5d57abbc325c31ed851d20141c0e7ed254c1879bcd302518a82c81a6b97d26b790dbf40294bb24563e1015b53db3d1ada9d92c42a2428caaeb426c050dfd86ff5576ef1a686bce5129d6d7fefe6da4b3fd549a9448331ec6978901bea31e9a9cb4a9722ea785400a012300fb61fd166296f315dc062d8de2696e781717ef0e1c1e9b8af5371e1559629c66619157b30b49eb56ec6f9aa1c794971bd967e7b7c6ff4e9530f9eb060ebda0c4cade9433cc329cf6a7146bb604551c0c24d32cc11e5ff2cc8e41d1154179289a43b629c6fd29c2f3ddc705dbb458911a3132ee9a3928d690b2fafbd3aff029ee0d28839837de9846725134975aa4053d7fb4c5e49c1899c52f6bc6ec701431e0d43e1af3ba4aeea2d8e3a4ac664b5fc7546d69ddeeabc9e54c9bf89d4d6407a6a78f81cb52b92199a00afbf72af071e8a3cb5b26364bdcfa4b96ccb4b2854d4713ce03b7d9912102c48f49db7a0818cdd4db243a2c53dbddd077289410679a67491aaf8e533655277c380399e51a61b24f141e7bc382de1b3886d93da0ef2269991edf52a42db33697193ae150b2b308b9dab799357d7968276455b4f3c3c7047e32aa94838cea89345d875462bd12c75dd415c924baee259f6c0874e5a31856d46f170d6b9117546ddd6d57d54ea8b17f5a6fcf410b40ccbcbf92a8031b763df8d13a78f6f1c9d50d42eb6f2546dcfa3d684f15bc6a8261f8a23c658227d317adeeb2008043101f3be89024bdcb6aeb2d9dc145946c8d6d171bbbc2c8c686c39d7c61a4554e91825f3f35e7ad2f3872d154de5b9f93569d558532877e3fe552a63f0ab2291e914a41736b6fcd349a4397787f396bfe92c9e3b758949742159cdc65a85f308e4f0c2a64903c1e415a18fd91e82e7eb1513d5616f495bf9fce2a525a52b431420e97c31a140c4ad70b678263aad0f88ed12dfdea638025350c0448dd3b1e0f012428d0a5b1ae8442349c30c7c10221f98d017195cb34c3a74f4d7212a5a008abadfc542338a474bb29f31298afdc89a71c303c6297426215c44412db7754445623647da60980a51e37dc61feb426cba4043e92e7de6a5a3e9cc9b837bf095ede72d170bb4f6693b65897c27c69f947ab5f00aeb8790f43b099fcc5965fcc8dc51d82d22657102d2d915b937bdcbf1f0b957788697b8405e4644a4e0bc6a523554a3c6025e7f0ec7d9d3bf191893c00667bd0060a44ea24db7267688ffba0f18546c1283bbb44f730722fcb7b9beb638125b9ed58a380f73eebbf78f707345c152ab60a8f5dfdd9ad78414f93b6f9e9fbac2b5b346edb70e78d79eea4bd8422d9db32a7f9f1f50c3aa31ce2a09763c5ff907b1814c0ff4d2f706dfa6895c4e7404d3f5b4de06e2ff7fe30fe69d3b2bca96d71d7ae44514c98c40d4881f1900005b770719f23bca1822ce61daf6a70f983803ab2a03ae0f65de8be07163039b2d732c0513423cd05069c2a8ca7ff3798d623e7b4522242025e1c90a2ea790cc39d384be6a183bf5572038260e3414cc70cd5a8bd293ffada4e0100b361fb0a424df5090f27cc5353e5d5a501cac9921f7c186866cb1c7497e976a8c681bf8bbb2cb4cee57a164ed52163def3dd03b70cf9c7e7dbcce3204627d2f2890857f319dd3cb23f91492d7223b184a31621811a3e779b3aa2fab05a07724ce523ac8aceafdfc27e00c8317baa7bd89727fdbefaef94c25b64824dc9f6cb450122c28db3807c3b0fefa4169e14093086ffbcd8c9b2e8a172f0d4083f0b73b10e1cd4866a81ebb3733e14fbe30e65a9c1e5e591f420a75f2bdb3043192e44c45fd9526f254dcaa141938262022d16bac01ae25e0c825533e72d7dbd86b3a9d1f3ec724782f0e3fda2c6ed11466b1519e1df825996d449eadf3b9126cdb33451fd2f9fcd5c106bf1da13c0d4846c390e4599eda6d8454593982e97c23bea1985bb8c5bf86831485e00833aaaa8fc97bf610bf1f5c631d9271fadfcc7b7096d7837fb7f04da672b17827c500a34a292189ee2eb210c6c6b42f4522aeac70b2535784cbe183c8e8e508e9f4f4af467a911580d226e82516a6ec105f2fe3d71af7d740353b70be4445745b43c8ff5456f7ed8092e51e87b22d77da2c88c9083a38d62e4fe6301a8d936a3c1e82760b7886078749d6636651af04a5123cb1b371d15b750c57a93516a72adafe184bd7f5524d9b538afcb85d1580c18f952bfb2723de6b432e244c1c3c917759eb88d797e2f7672d5a8eac100d1d788545259a8b33c2c510944eb79ab87218f64d7a0db04e595eb8e8f6ba7beab54fdc1aa33156fb5619202f7b9eee11b65da9753c306554f266557a1196176ca5e246e0f09c40076259d61f6b2b485d6f7ba23bed162624e786a6b5d36ea9f768299b22a5951e10e98ee09a95768c2230e0a7247c9afe449bf5cf2a52373ae119d481350fd149143434d724a7d129a9e0299dfc58b8f5cbeed07573277a449914909a5d7e5228b2775624592eb85041ef3a7136ad86a06851233ab4aa13b2d1d652d8fefbd093d0190c57c49a4fa6803689e67ff889331c0789105c1c622385545c0cc4210bffdb2bedf9f5121824d4957d878953cf1f107b50bdaf903073690df1f54f8f243d429024ad2a22c55e56ee93fbdd0345de14ba2b76a5aba7f34444d23647f339c37ddec0aa22525f9beb300296d37099a5823954e42536406b7feaddad5e7b5903c847d3ceb5f6ff6e368f8aa809c4272f721877b2135d8c2f67cd24fb7b1e0b8c0ffbdc611dad39267dce7ff642061f1d590881aef058960be5c7b3bb2b2ec40de1b4a65a51884403ec3f9b421d5afeba9014efc3af8d2eb707e34b11a8bd2aa865716e1f56c7d121548cf6660b860fa53555e6a23e4bb7fa00d1bcdf03ed2c27838922cdea99742ab47e98f874b5f89bfb5687e2dc6c85f074160f4c6a83cba2104ecb01076eef51d2864f6f90f747ee19316d454ce5ba0b8d1f67cb3936e45e874cab34061657fc978691a0eed0c120d8c1046784fb01cbb6f3bcd06f3e56afa7f53a86fe17a76dac920736e4549fb66f756917b025d4838e74ec0599083f1ee527cecbfbee993cd9407d8c744b7a0a6e918abdc1b9004bd1265f0de1b22736b6afec75a0aa0e6cc4bec91317edf00d471fc6a7c884551f549a07605a42298c3056cb32f5b3ec54b37fe1c439f98543add7731ea2d4aae6d1af34b184f24ed991952c06e149107194265ad588753daa7179aba88712042e59af67fd9dd0812352b3307f8a50b12a0c074f98155d45fad4a5fc0e56987da6fe6e321197a573a70e27bbc01a57f21e9bbec84ed32a884c137ddc61d6257256fdfd417093cf930ee841a91ac185c92a07aa3e8027c537bb3bcd4456ae44afe504a4dbd1694ef9223dcaea9e1ecfd260c47ee03943aaeb595ceecbc2a186749900f4e88a149426ac2f200cc4e7b7185cb6b118087bc07e192617afe37bdce8e67b79f24885923853d73c20b6306b339cdc964ea483500c8c2f661b7f8fb5a0c2be4efc5cded90c426916b9232bbd24d6330d218bd976b63f41ee8c445e082f3a41f69e3d0291b85ab782d5baabeec9156a5bc4deace32765f91c2304b221e1107c70fbbdcedca7f9967df96cd80030928c85d6f05a52852cb272b16d19d3f03f9465e58944c56200a3b6be853d71635f8ac7a77af9d981612792862824d63e0b29338208ac182cae9eb5dea007643d50aba610dc074402692f3372e52115eaabcf08936eb595c26132419bab762702602132e04431eae187e0976fdc5c2fc3ae4baae209b4b3fe57f794c33d48118845ceef063a2990f252b78b0f4625bd172d06973b577108611921cffe58960064e90bb9ff80d0eac618cfbf1b0440df81d6f4e28004edac40ccc2bfbcab4683b02dd88a455c50bfcd97c404d933ee0391b157d95e1148397a33b84d9f9b88048a938b16b772fd586e03ca4854cfc203c428fb2edc9872d05a3a533557b2a4bbe762bf5a734a7a9cca627505cbbf51fd56e81c46d4114891585a60c5839584c36e9ae635b87f8e9b3d349d83fa3b1fcd21f25eb6765dca8ce0c38e8811b3828d719079a4385f3159edbc6ef50f88ef739b9bb598cbd3be54bf64914b24b6920363f437db96c72a9f337e9770764fb320e8fadc67792b7999f8cf3fc635b40e3645ed4eee273aafef448956f36cff5b6a030f8fde47233b338e771d28ad02c45a80c20ef97d55129727cf3f963d22683fd08e9f2718cddf3859bc5fc544ba7bbfdc5f46241e397c441296931ee8711bcce412a7b2f40bedc150369d7c4356c75cca58312f9b6e48b45898808215d536d105527f8d2f865f7481960fcaa6b50d4e2f67bb711b2067ed2e0628bb6c28ed93c453fff4baed84a281bafec4fbc74efe01b5c3ed9822ee3ae9c5edf2be6355452963287b6d9079335d6caad178ad90fee598142ca618a1ea89362267d7cb3cc67f1ee5e049a683bd8e2ff190c7e9eca113582d31419381437b40ba9c192a40ce8210aa42620eb055e2ec2c8281b1092dfd3a50b0ab318a2ff0d9e8f783135d865831d26cd4f9601ec594e211582f8097fec5bc3833baa8badc63e95e5c5daeea8ed6ac6fbd10a48fbfe973001154f759ab2df121acad9cf0019e9ddc1163b0bb1c84cc95a3b9e948924299a0448ed8dfbaf1d1a358111f215c6a275188de20cb8c02d4f3c5b4041d6577ee7803fce75028494758a1230f201ae9dbd22399713a2f31b0d6da2adcb74d244837dd7922aeb095abfbb6671e1ae7a1095cc29386130847677a7ff684bb873f2c17079859e257f3ead280455ff038f2b4aca3e562a643597de92ffaaa11fe9b62e4c31a1f47e5c970ee03d2fff77be550f31e3e131287b9178d69f045463e49b82e27d4881fbf8bcb5e32f2b2624e9d4aa27079a5cdd72b4a4755c38478e034df09806bcdebf7bd0b70d536cd43dbf25e1c98278f25339ae2139e4806557730a192d352b15dfcfd4f3fce940cc8ec28e0caadd98a5827f3da0c364f0f7df6d996d609f517df339c66da23cf7ce88fb9a6b6005251814d2a5a16665962050481dc679f1afedefbfa16fe97bdd9b06197b80ce13083102d4e32c3fe0e41215e32466e0d757243773491e756e01d90e3eb192f7f940f562c857f968f3fe25f44e9ec78971000ec04dba4367654537c7fb090d65eace075277e3a6519d9b085f46de9929f87aa9b3b07492b4b4a9e2b58b712ec5c309d225aa6788635699ea52f3cea59ad1f2f588721c939a5e592811434bde5dc4a530f0187f7ec01aa92ea5dea6c43276258ba5f130195cd3eda74b83e77a7d31dbf379cd41d1d84a0443d9d77099b61ce5a94e66929d169dd9a7f081e64fca4805f4723192b511aff1289c11525cc078dd5b3e087b3c66f9839b843a46cc0e21b84389ea912d3990b72a10626bf566c753daba788af7927313fcd45ced02171d922b66c0443c99dd48889302aadf5a9dfcf913c64289d4dc6db9421c547dcfbc44c0c9c8d553f62fc8c917866df8a53f70fa55e74fa1b463217d1cf045bf654873761887f97327a4bef08f00777d4209386c510b39fc741393dcd22e6e1fe6ad176407af7e9d9daf21e819ca930b322b6b5b96b96691c2e85a78fb06b6bcea5c0489335227499876c875b84adca936663283e290eb6d16e9d25b83f0541760aba51f77b3616505da6bdcfe049f8da2c02db60bea65c6d2ad3ab196952b909e3baef37f5f19deeac5ad8db2e0f4d8498281f14f1c1317c5616f66285f71a679634ec47b262667c4e03ff9d78d619e1878adb0224dc703235ba50ef6c57c1c2bc8a7d77aa1acaebd1415b112ba297a540d2841089a8caa5d4d434b944c34d3db2ddd9cee689d6d0876adf517ad9c197e80682523ae0b9d1dd81fc03053e4d26b041f4d02b3438b03881ba0805cd0bbfaf23e1259ca34fd6c548d58f0ce74d64ff595cb6f1202e8a5bf529d12db40d6916f60c4de94d0e2f08b7587b5da999f71d5515d95e8ef2e8702f96c2bb5520b928021a1623179e3fbc078592991504a6a7b58f83519db84854a72608a4cb41be56afb048c156ffd84aae0016de7eef337f6eefbb24f827ea7e038a27395580c4f5ee9eca58f7476a831f15d8a6fb79e7df5e091916e1ea73a36e3e2ff9e7c41c49c1e7e1f50b3287c2e4942ef7075ec9d16b0249d9ebe8430e5a4ea38be65a6a11b31ec1aa0ae1e6758cb374b4193e6399c299b3f431e562284e15dfb2b406ab0ac962c6f0230e2200a4de6fda4bdfc5f41af2cb45bd06ed0bd6e28b47f8afdf982a970a6f59a172abb67a328e32112b0596f225d14bb4ee750d6a6cb15dc7a557d54afbf7f2536fbe2f546128c20fab243a31488f65d77c0078d5e1d3259f0e7dff5bba0b9c9c3dce60ab6be0c9306329440142adea92f6156b1eb2d0fbde1d5fe6caf002fb5b739277a18383f57f468dcf79ed1258692af520ddd32e49c044517d145da662593db6903d4304c81d728e66c612277f9c91b82a1468b65b650d26512d5e868982bd9a54fb6fd7f4f6ce1e69fe90c9720966fb303e5e3820e0201bb95c1e0cd3ffbff863d8533900e3674cc9d9e9b8a050d67ba7d08973e9d7c4afff7afa11c07bc1b83fb9702566819e51220872ac304adc403902aace55a4d740e7a1f79f01d729191ab29310a35bd8be134fb86690eb760fea2b311cb25855d9b405c5904b6cd3550a605babdde37d33343aad7d4cfb9c7b89ba3a47bb53689e595eb3b6ca157da1f8eaa04ddc96c7fb9d22c95e1bd2475b29e4f7d4720c5b47995dae19db8fda324b1c7275de7792a0cfb1e5df495414401df722228f2d7efea4f834a23360fb98a3d830678d229ac087361753a5af71dde630efa75d44a4d6f657c96ce9997ebf5f064f7e64705d2d23595c76d1663d86029acb988ba7a62bc3718323ebf8b2ec934da9f71f0fe4a79c69bda99ccd5231c6bb0f3c662d901d30865bce0758e9bbc08b56e46851255e284c6c6b0bcbb6ba5b431df97f10f4ef5015f49ab84fd446439c0087c4cd39625002a30430ae1b072121e539e42e293c6a89f810476ae6a303c7f3a0848ec1c74cced393260b336644fdc1fa1cb4dfabfd6e2f44bbf9862dee05e5dc36fdfb61fc30dae6caafdfe9c50323fec9ba856c3a754355f4fff46802a116b84a783f291ac3d9374e9bf1d4c836818aa9e773d2d74821d34a73058cb6bd5bbf9e579d83d4743200920fc0880527b8a020505461168a70ecd4d3a56d869e1b21f418dc6c3d6038b094717b76b30d05ca91c89dcad288d8593d66d1515f4f4e92e648ea88f02e26f429ea20131f0da70dde1c5954697309a1ad2c1412ada33d1c645aba6975c023d2e516f4807f77551340e7f1c4ed621f4fea61f8169f495bcd5d794e7b7a1cc449bf391f6c2cb324be4eb43bbc328b6ca3def75b76cd404ae66748d788e1cc8d97c0d9f11030e84cfd6de6709761b36e65448fb01484e45781e584f23d479e25a86c62c7f88233d5d3e9b9bc5e6044d5fe298b5c1e4e2aaf9a4daa90e11bb84d4b393d076a95f4d05fe241e05529220687fbab1d25c9c3fc7cc9d2d933ace82c127afa8cc895bc278a64c45cf07c332a4844564f84c262bfee7a58e764eef992ac7599d30ca36cd2c52732d9dd120965af58e71c5a8e2d2964249679bf36cc1f052632daa3c3b3e22c759332eb93b4cc3bf09b62164f6dc8f37a8524e96d9562fd3a02b5f83d29b466e6fa47ec97ca4696f85f4ff1f65f401aa052b17586d55055fbcee4b0a3e794fffda5fd78fb0d5eab52bb8157f97a87d97defe525e88becda274be3d62aa6876dc07162976ec781a737510a870bd83ad0bf2f9db27b82aa2c9e86d4996269ca719efb5efa5c79107fe82f4f6e6f2360080264fe2e2819238a9db9fbab89824b2e9792c792b04b6c6d2aeda67205e23e100c9d96414eba19ded5f9b9cf1cca1128301f767b8c1a2087d5beb2a3a1063776967aeb638ba7a22ecc298f85b0b70e01f0fced90e2325bcf689b68647b6a90c40c184404d045cf9e4169339e20018186df48d89bbf4eac0139a125b430fe11f7b9c917a2881a586273eb10fd381f6b3307750caae227304111efbcdad21241f607b8e9f9d7bdb3fbe7c3fe41f2f9cf9d83469cf642cdb7c3c1c2e534562728136bbd5bfe3ab3aa65f04b1b4b19ea4bc8532d14e232457d597a2819b61061020dbe8b17e2a6435a76d5662a6a3ef9e647c9ca6ddf423c898fc6816920dca7f85a580a08cc73e76c6dd31677e8be0355ecee74b67d6c50ad280b9753b7ef78c67dcf3aefccc2da98a1ebeae9b7ba2cd1434621f27809061423b3dea920d4d51838bbd72d642ee7c3aef154a0c458b1393613ee09e30a547bd0286068cc5bc9e71bfdff3e8f0fa96742d43bebf5994de2072018e142a956ca8a0ce0535db01e3d84dac0f175456863165242e3aa15a3cb6c449200f0332a62c4fa7d9781eb520805e0146ee4275e9f661f2e36a2fdb039c154464780e8fb54d8d4bd29808dd8946b98813498b18ba9205f5cac5e9e2ffb6856d8fde4379ff88aeb83d16530a1be94e74e05dde509bbd33f016dfe7b1b17d2c75cdf129b0059f4489788e6be80de1a7d53b132ca47d95e745750e8ec63d810bb41c612e5991b4062c3014c2f76173bb1c9495c46ca45fa5693011d033396680f5c35c1ec6a6dfdc2e09f75c81b619fc5ab6e05df9eceecc1b44156e3f7a07b34f363b7e37ba180d6b60b2b2ccc57bc17a74c6889238f6d106220462330fc0873286b55cb1d29ca3fe2a0b1a13bee094ac4eb2049307fb569ca458af66fbef330643d4d784a6eb20d3076421ef80ce1cd4df83c3e8a25442c96b9f62d27fd14bf8b0096909f29f97eb0a0308ae34f7086a64de71867dc345ff6c35decd2ff3fd87c29e045734f4f28e256f80be6f5d03d6930ff64bf14c528174160fd1b4545f9d56d61b719936dfa58ac3629015b1f35e94d6bdc2fd1a67c3bb87efd92c0d8fcd0eb58e9eacccfb2a87899656e6ad3c2e7715b0eee7efedd4441cd671d76f37dcc46939782ead41ce3154cce2a69eda4d8c7f327dd781274b7424dfc575d5c62995fe38936fcbbdca5d42a2f3394c24f2f6d55620272ac0da9ecbebc622e267df22616897c9bf658a625cb41b5c63ca508a3134e1052b300ff92fe7419f0a9040c6cfbe9b59bdfb1274df1251e64d7237cc247ac44564a18428e65479ae20f3af06b365d19a223b0e2403a17ac29ecbaf879bfe67db9279e29770a870a9278021c788c5069e89908e7d6edc0d5c214f9b808043dbae25a295576ab65ef7a3c79b7b3bdda087f3fcfd2105c4ed9ab2a9baf91fb123a3bb700ad867137de7137e469e6daebd19c7ccd5dfc5a70aa275439b57b07ad30b507f39fe69d66b6840c8c1c6756605d6a27772e117392ffc634675d37cfc3f1d267e2ca4b592229d1becb2e91041da95a17f9a97be9d48ae4b157351290e14f4027e3de916e7bef2c1d288fd07010691aa74f9088c90e60e29433bbf53e3722d7ada5c1d7728bccaba0dee2b9bd2c711ef1983237d10cc6aa766b60b7280c950cfeb04298637b7f2727377baccf457798d35008a6e97d430ca7d99e8343304e148ba7796b94c2c47877806ec1733b27b3f6f30456bab841d7e5e1e8906d9e3dd3b6d8c45e8f62a60c57b6487bc3b972ff35f822e521964b8488f60cc0df1d8e762e21605e104efa4601fa79ab555f35217195bbdd3606893e050ce93cb8bdafcbf4aab52e453ee83e03cc8cd6188c654d7a73ae565d76d1bf7c8dbb2c9412e00d21e52f8fc5391c92c6dc346802d96bc8b946d3fa5b4520df8afac0065ff00474bfd733d58e0d169087e235b96d6a45057c5bf472255c34a3558038d56dcccbb5fbec2e9900d9b88c97b488f12c1bb1d8a0eb0b5eaf74438f25764cb90be2cf509c497f133df7bddecfa3f1ca43e2da1b367eb2d0e21b2f985f1659dd38a9db4b59538d499f129f9af59e666cddb9d997c88beacbf77dbed60ccd7ee9460542d68147264f14be5f0e73e81f850cc043e83fff40b8c8ad88b2f73b012bd6cf776a16f533f96d8a16c1ab33a39e8369d87f340592e2944a63c5bc74b78e028f16efaff63e3076ca46919468e1a512d99b75e53150aed05c0be9474c60662c16920370dde7ba8c7cb3b7c2a9e60faccaa28432eab6cbd8de4279f405509be9a6d3cb34022e1b7c73e6e53eabd7232f767b3d721c787bb8c1fb8b9d61b9998f2541e00d0791202973a5ef5ace80850c7021635f24ef719c82ba9f6cde77f6151aa7cd310a40ef480a1d3731f942d4a3f70de93fd643db2e523bb17ac2a8cd0eb356771aaa95f053fd17916f84d835b3521f4a1132f5a573eaea9478998e1e866c87604552c5c1bd4ae05e52c790613d3f882bf3fd46f48b81aa742c69170359b87736406f80b2f70399d4485c113f92a1c639c75405da9ac3e072c3e785039d5ee2d18234c88638fbeec09be140279625e9a33c66061860ad892f7b59106dbae7827e170b7986aee7f8d39706f55a884f1f0ebca61e97cc79a22db39b1f171ef6879a465b2c48cff415632ecb89cde8cb142f0bafec220b717c6e2eb496ef64266713a1fcdb8218e05e3b2146bdbb48d24c9e72685606c6b4383eff22a15a19a13aad864b3634455c2f289adfc9c2fbcde5ded196c884df0a4979a141cac768cfea2d279119fe349e753e9690007b89b82b7a5143e353aed6545fecb1e9a00305f3f1dedc153506ce915f335fcbfbf38390c006ac97891f036f4ca37098f2c0872c369f68f71a1d45bfde0f8ec90aaa0e8517820292b35e493c169c5369e2ad75d5d957623f0e95456accbcb5f356ef7440526d05b1c367a454b99009c88fa3abf2bf49792429b02564e87e5c1bb4b704f03c7b6ecef8fa178b2d2d485a68aacbdd856c2d2e12aadf5ddec7ee672b58d18996bfca0487a38641320d365c86b220ee37d5ea93e69b0cca34cb4cd4e494ce44d2820be34d376d3f268ac1bfe8c7e6bf0eb9d19ea7f5161365050c44925b7d8ef702cff07f40921a4349fe617c88e3410373d600a0a1f1bb2dba778d6f4dd0a9045ebe9a7df59e079013f09ff7713e5981af0ab46ff4050b135a0863469be6f2d34c4439df5bbf195467d9bb74859f8f5e51b6f098c4ba6e328e12931846afcf74b25eb3429642b6d0081d9caeae66796aa5c8d4fa965524b416d839032ae02c5d38de15564249212c05f21ab2ec222296b58c0b2a68f2d28ec7399d55b200decb6bece4a0ca44d6ecf1980c9ac53811a8a09e176791e47637bbe6bb6b90edf47568cfff148ebe878dae554fb9dfed53f55b26106e1fe1286d35ae148d127be2e8379d13ee68685001ed85e42ea61680f707f8e6b0dc85bbcfb02388d5d1f00e20ead55ebdbddf5da7aa30b4a60626f5be64cd53ba35d25713670c89be0c7a4d44b4fd89a06330b4d86836e7ab6d12d8b21d3e4e557c4dc9d250cc286734b3773a092fdcfad5c5a49e615e0b51716d4a8fb39974e5e56198402931a78c0a8205569d5553c56a6f61ad6d65f97d532b4634cb024a2bb15b3f4ad08d43302c333b845c871e44c5c462256ba253681a6cb69fe577708ad6d92ce9da22de45196787029b44e3269dbaabd3b51157e447dc436d0312c0f64de2e9b6a9d23a66e7d82054159edf80a8591e18bc48e34f3c0e2762ae4bfda060416a28f14f205e74dffd8f71b1fc1d88ec4cec580b271006712f3e3b45f35c224f0b768848e97db390f485320d323093978dca8fca81e750d2e8839545ec2b304abfb176e2f5b0e8702f5452d2d59a2966156c230c73c7d21c5827135a3c0e2bf31d752bc25d0f7951cc5fdbd1f6aa9dddb885f89e8e129a9c09b122392e3635d9774efb7eb46b61f731411fd9130abf82b0a7c6ab77204f4f91bd5e6cb0ee3811e1a8b717606b6ab63fd29076d1987c9ef082a2103d009303e54253f5100f07e87787ca0c7ac4f76ea2f636d8b1dee8a150a0bcf228ba703e79187d19ab2d608d73903c1f7eacead6399de9e7250356756781d50b426672ecdbe558e4e46c749080e86cb92f0345fbac2ef287bdd3538e1cd498ff7a0e03dea46c730d60496210f7a3063eed64a4f71c8c715da8af59f916790580d4cf2acd92252a187c905cf4372fd886bf8aa9ff30afd37a955bb77532fd32ea9b95670b08d06afdb30aeed5e32d4170c9f806d8029813c87da6a93c0d93078ed212b8dfa824e23d0a8df253bae0117a8b3224f4118a68e0267a0474813e4eb75f7c400716a01f983d3079c50d66b59f2154ee8b72ba690c89e89793de9cde3271420099ef22862795f0434b48aac25cd679fda430f1ed676398ae134c1b5408f25641a593b0d25465c6fb49daff868ec017f9e69192e3f07730c48928e7dae97be3b3bb4da54d2f2136bb53a9d4f96ced4ba95353c007fe2e40257fbdd772d28916c231cd0e8b6ef1b9997add97d410fc9428c70c1b62e7f1c899cd70dadc49b9680cceb2d497fb2f63d5075aea81c6859e049950c6f82318659e6ea46c06fa1410fb73031a767d87296dfd2e6105c80ff8b1ba53b019525f4040e7624646014421c33e21351fc37ce671d2ec668207aac5a7959f4b91c3ae36c95eec9ba325c370f76f1f3db67754ff79656e3380c508d7737d8ee5b70fb56f5ac2089834d169c6695f73b1896ea2d946ceeb4fb2c0a2545f09355b6724fbc56fdbfce3e5735c041c36ac8b848d541f49d6a4b1f0d7bf730cd3309a2800f26946f87f678645de8d0248d63840d098fb81b819b67614d0184de681832850757739232c9bdb8e1a27f83ce1d011cf33ad989c201d53b593c0d8cbc7fedb685110c62dd0037c1834942b81d5341fd94c55e6eab21c6c1035d44ab72ca8bf5230e71d26bf24cb5a20815be69484a839a04df9b8c1bc11d968929cbea6906a81f280d6128cda31197450f2a084f1cfe253b215c7e686ae66a3f966c82ee9c81d975dc7f296077772c7ce422479174b73bbf5ae378c29d16a7db727edc83c19453425659a74d852befb15482b3c783beddd05650d59314309750077137854e1c544563b1783835d33524c265eb027b49a953594ba3b65a5e685e689e815e1bb7fe681ae79d3d496fdd8d00c52abca6048d42eb45f551f56061781c84104b706ef66c7b166424559c867b706516a7576aeb3b822dbed48d89ed5ec269c28d6749e1daf15b9446b3485790df119a7fa2d87371a6ac9b1c8e6ec20f1b06e47641175ce0fa18a589f53e0e12a5f9ae61bab1928d208f6e6ca99cf9a1174375d3c254490f1b41264865feaa2990b26e7687cc1b649a28200583898300a7421da42be6730309b6a61d19337333858fc7bf7fbdc8385ec8cc709308a88a01703c28f37e4848f2c8855c11c959b32ce349858932708a23a78bd34f0af98909e9d4f76aafca44cfddda434c85c962281bdc8d6caba8a437c13d13dffaa647d131799f8443dc13081e483da02dfef9f3207320b74cf07eaba17d466c68797d0692e1077c562242df55044b00a3743973d6d27f35f463f849fbfe98f41836b58d24a40b07aa082538b8f6a788042c2b7828cb5b37359a8272e17731f78c884bf199ad977c58137fd64bf0aaf9154ea69ee3cb2a440ea27fe84ddf2969010a4d69399fc4fa9cb1315673b5b038ea828b196ba7041664053c502bd75565e5197192749b4c84eeb12bd01c4a591393c26ef7dc8cd70773e9cfed4f1e14b136350fe41b6e3da9b5ba06397fe08a9dc48018916158faffd4626271fcab61498031f6dfed3a26dee7741134c8f7ce01af895654e5a6884b0a600a30aaed6974c40b5560f1af4875f5c243d863a23a0a62574ea86f2a880b0f7750b158baeb6e009e7f9a71c1f32384f333dbb9826aa5900b64c8255dfed71bb0b883c6b9129d8b50d489166d31ed4196e1f47f7adf0114eef2a154a2335a474d99250f58f39eb66140098ab6f7118d9eeeeed24f06c0932c3210f9bcf4c9098450f9c32c80a238a933e8651428fdaf5c3622ace27083b8862f92cf4abadc38aa7c5f1406e78189b67ce02d2263f1c5ade65e75dffd26efd3edf453247e5e1ca2aa044c0471e813e32abfe626fd43c4eb4d4bad6045e64e25fa70059c6e2e7f0aae6d64aa48102c888249e7185efc11409ad5d2ed5173b3282416e56fae1176f75989e096ab33d4702d8c9bfda089882594dd0a31eab10515ff2bb2d93c0ae3276728c2d389cd0529451eabc4ba0cd8c05ea9583be9280026274c9e3ef34b12f7c09dc4690633faacec67a4292b366e090f7d3e214f284f6475755839ced63066b74bcaad9da47ea9c699c2cca3702d276b4b886798dced0b43b4009b09a170e53e6ea694a49301fd3b75f430afe74005433238b7b84a0225b5e7d566fdc9ddea930a9248509c2542360ba5f9f30d93b2ea4956bebc56c932dceaeb3c02f876a899186d1b2a398712a560b608290985e9c667298172179326b37334d519f0abc83654306269154fec14bd53f06f50695e69b95305730a8ecbc58dbd3116ed6b1dbf94b84bd8f3fe85768f62d060f0ac916d67130f723c7fe7b248a749faaf74e44c37e197cf8119cb9c2713a2560286c68a57663c72b83baba4894c0cda05e88099e2acaff10db01d5b20a07980a0756ddbfa4de8e64d79f75c767163f3c1c24c95d8a3c033fe800658c3689f8775808db6c259e7e8636c226d2b482225740a1f85e1cc5196c78c7cb90576905d3d4396dfb8d4babcc0ec4c294b9c76fb8c6580a19878d376fa06329786f2999a95dbfe3c08619f5127edb642f04114e082c3bf2451d1608949637cd9fad4817b9a1426717fbe1048fba5abbf5755ddd2547c6246a5ec609446440f0bafbbe190e9a1ec4569d76ee9a8bd9e398f0e75d4e7d911c768bfec5dc85d58c8160c6ad99dd99d48771179b70c69d8117be09877e5b8ceade62800f037d449950a276265b1a459cd876485de15d6db9ac31929b75f64169a4483c22edffadb353e11757a13d5dd58241b04821fe2022b64d3cae91d38c6ff63b10343355cedf2113a0d045341cb1fdd62ee90b4d037c00d1dda3da71200a45d4042897963f78645e73f7205b6c59844c9b94f1206aea4b173478eb7eac2d697dd596ffd484f7f9615680725f9256d32ad8f517b8a5a38bf1ca0c752521055a20f5e43e36c37cc79d20ef62b4ba3bccac2b45512253bdb1a4423ce3c499750d732356c6d436bee3f637bc120b5f9894a6133dd04536984dd35f7e67f5f402a2adb7cb21874b234a19d9507189e4cd48f16b6d864a132308bf1c8fffebdbff193272db81be4dd7e11599283c958ce4c05c5c6a9677f24eb7b729494ec704045be3da113058b14778c6d8cec8cb3d54581eabe5102066ab85d9ba4e5f044f98060e46d8916004cf8f736915a7d3548bafbd20e3345ea00a2741e8f0959c8417fccc0cfa4ef1dffaf9c52e30230ab692b5db83883d503829274da4e66049452923b42a266fb7868e058488386bab00824d2051757bb74451a06b5ada870bc31248b81158fb79c733c4924904ed42f0b91ae7535a118eac68bfd4bc5ab1300b390e4b9741dea94be7d7ea4c77ad0de231717bf00fa493fbf42eb48398b63aa716fb626684f03ad6a118d70a2b6a5ce65fd90f50db5f390252ae7b2645f3e343d4e31891d1a74e72d32007ec40aa8f788796c4126ee7e9a4c7cd9918d707383a8dadff8f819dfd15a84bbf91af4af8f30d10072d9c9324f6b48c8a0228942c45f182b1163e040587086501eba7f91f92c76545d1665da5394c6f3619715ce2c2fa575fbf79ad2f32f99aac711e460cc152147cd07ac18b7e6a8a2491359c122e47f1991bd3aeacf7b78a1024b466c494e48b01fd2bc9f108fb3646582a6a684578a685766b8b6963a9735f0e522e0aee71f40adcad080707be2c0a5cde361bf13be997a660c4d8f9381a8d2f801a53b209365531f9312856a73f2d4af1d9453ee0a9e1284f8de0c64ebdfff1bb31b02e7491c281b2131299f5b9bd681b429dc108f3cb712c6024edb290f7feec54c19744549ea0f705ffb46489938a2dc2257560bd0fdadd14f2ff933bb7f9091303f814eb91d1d92efc3bd5ffd56c4fff3e189b90f7ab13a43bb13d4bc57baad51964ca7078654dbe3b2ed487fe68c97687fce1cb775926749116d0a15d9ee679937a460596c903d92fcd68ba673888b106465582ac0f1ac34ff75b984ddb069cca66e340466fe12a5c8304aaa664e83e0750367de45f5799f8108384d6b2214752ad945b57e5c6216cd99ab8ff8ad6143d620c71363bce48f6077f1341420900f2aab6fa7114ee99fd1e14cf83a1151378edc73f40749c27897a4a3718cfecc6dc362c40cde10053b2cf0f4a6eb5d696276a64061474c99003b254beafe19e49155380d1c1b003474d6c6b424a2402898479b08876229218e9c6c906847351cadc1764815c66b4fbdb9b5747e4b06b6934bfd36ba7b27672d0e47321ca6943430fb5b5e99c830dd807d88704722a3047092615a36073068d17058f0163bebdfda676d64d1588413435a80e61c6b0c96580b8e659e6ccb083e90cd1f9925f1097d65c07ac54a3943197735207c87d11ddbdfc366dfd69e4ebc6e90d015f2fe9fd3cfef644153e41d7a1e8c852621886db50c998da4c32c4d5fce06483c7cdf2fc782bf5ecd3642ccbeb6df0c7260d44993572d743d9ff67087439fe40ec2c06f2f0071dba3c0150b222ce053bc124d489dd0e4b4224509f3bf45bcac2c9bfbefafb1170ef63fc78a8fd7195ab3fd5b01cd78939bcb5645f1fd0cc9c2c0132e21f6f6eb03cbc807d08076a17e252024bf67168cc684af4c1e7525c15ba1bad230cf932f0d69efe2ff1d55aed7e8e09e6d25130741fe793014cbcb07b19edb13c875cd56a747dd54efbb0744bacf8df20ca5452d661aff7a48aff2521ad62bcf8976d04038bb329539b7823d99279140f54d141c5647f5bb7a708da61074b36d7d854345981a9c7fd67f6c8e093747a4392ddf94faef23d50686e21f24a9817c1fae3e4cbde2cc04535e41415bb16b8cfc5d1d796a253641abc83dfe232dcbada81a22ec3920d4b8cfebd3c54861dd99d24f46259ab3077e4abf2a53e16b484bc4686e8548277b02f7e05f2607a2cedc7155e9f6c2e1d542a5195e119c9a13720d5ceca8ce92ebd88e63436292676078eaec9621c57ed38e1be3b1ac08dfb12bbbb868b06380db8cf5a0a2dded1d3d90d3219174189334fca504a7db642076c868db5a57a2e3089b2ce127fb3a626ab751e65bffe8e06a36b1792cc5ce768f49a063eaa6eecd5206220a44571767b6785d7c0a7065584248df23b9d8302f0038c71d1d776c55aae4d02df30bc10a31ed018a29bac8bde7493bf6b49debf8d02e52299e951f52de75a32c161ead7113df27154dc62f9a3cd1a4e8deddc344d6ebd1b6a18f34ae38e5db1d891d88b7f259b0811b01abc13be80778df1f1c97b25924ed54a1066e28001bdd81102726e332fb14071d79b4e36ddb3fdf11cde7a383a2b4ea3dae77c0df25a9dc16d397d938ed6249f6d39797f252e6c011eaf2d8fcaa6fe487f19381e1c92cef0a48602a5abbd68ab0876fafab02e929bac1e2c1afbf89879eef7a72653191221a06b64371737a02726548b0c9fc1fcd687f6a09f7fd5916d05e7dffdc9f03245eda55eafdd253ed474a5640c37e7ba0b032e20e3e1cb7989329d0c771e0531a7a8d8dc4554995135c328926c8fe1704e27b9d154cc6b912b98a0296dd9eb021627a5cfdeb998aa65a6fc145a72a0e099cf76afbf3a8d856a40cb6a0b6cae2fa1340e6de441f4e166e10250d486369cace07670c005f1221e42c41796c3b04b2ae7c2872415d5a0ad31a318808c85a704c5187c5f503fdf3a030bbc3d5d39148212ffd27f1da34757a2d92bc310ead7f826fc19d140ca477adb389ae1ca38d891571ca442bdea9afe56a9f187b9c2480cdb0c0ae6a38ff4c92f2b3e4e20f6bcb2bb66e288160890dd9bd732b50d5feab52d973b3eb78adf29c8787a137537d70fd28f08b041989eb880b650167e182f95e918acd1834f408e9460387c5daea4804b831dcd8626a31f0051930ce2911c6df7b09dbc2d770749c285f7d01c5b0a85053f416620330ba658e9629b9e109d6ee3ad4079f49118c11fac9624f8dafaf526e70349d3a17dbb44d27a784a3c451f8f81d5d750ead8bacbdb804d6b28f244781b3cf58ae3ab345d8a9b06b0cfd0f39f8d475eb9de8d9b638c20416e877fc3576af431bef6e4c801b1e56ed44c33650e91587c01594da583589fc59d31c5651eddc2b94be4571ca02fb27a1bad74d2a459cffd7aba53487c9bbff5bb497c9ea55cb947d3ad54bd7d08a3efaf05d225373a611e2c072ceba37a14b33eb1ae22d54d4f3eb66280d8199cd3a5e2db41f38004231bd475a9e1e971515a8bff1834f8d3f5c8f287e0e8a239fcdba588ce62f4f6494108ea01bc403b57ac012e6f5c9734c69ad23ce3cd404a377412275a6f695f3cd95ec3bb714a54e1cbc603000a869a492ba6ee7a64b96f28c6229138aa2c8e7ea6b218473ef07c2922f0b2c2b5f287dc8fcfbf7149fd24bbf8a97f88d8e95d91f694b4fc92464279ec678cddc7c05e67ab4954237f138f43264fd9de7cd767e23e2e4aa7c408df1c375cd49e2f085e50b4f834e29115aa234e243ffe6547126a292461436d44bf3d00282f0cb79c55f0319c17c2e510d59072a69c2d75ed273691201af187f419df0a92b92d798d3d1f807dac8cf958c5675b349d6af5bff5bb29743941c12b04c07b86eac804e6b41e3f17c1010e4375424a8d8a0b5b7a0a45ce76cdfdf38c2f261e80485b54dac5371ae5b24d933bd0b96830e67bfd62f972299690b2636318ee20264fce5b37f72181a8410c0b212fbd9b519cb538276d7f28adbb6e73b5dd6c3262fd86cdd39b9bdc861831cb99494b6513354176f011787951efec9b0906222419ed3579180de12ddb3889f9130673dad898fada6700796654bbd77af1d30f5cf1e1dd10736bcbc3001998c7f7c02b1db7892ca7a220716cc01110c4795f01856763090c1440f9ca2cf4a506f804662635b71395e3d14202fc9331c3dffa5767be63628be6e15e307cc814e416dffd616bad81e1055294bbdefb79a8b9387897c512881554a28c6aa8d7576de3b3a86b91e9816ca570f4aaa123fec6b10de324c1a780847d13ceba60f4bf2547b3794f19085e8ee7696088fa4bad5eb6ddb9220281b22f25f2a6011a17d861dfa54ae10c42acf73d2042a36f42ef05e83c072bd0153f83c523f7d9926a9af303146cd10663d6746919f9e3c83db21521b964d9bdff57f747a656841d0a623acdb4dfafd2c9bef8728c4b1be450251e6b07c87b6b271b6fa9cd4e94187023f820151884f80d4d1241e25425f3b45fde1b72600f3232b544dd1c81a5dc5db124be9c00cf2f0cd21628c57d329822e667288151fdf847adf7895117bd7069b77b8949231391fa48f18e43aa93ca8c24a7d8bbe4382a0998e7394a97359b0345a239be2f9670629f04c2b88a055b1b9e0d941b40fba7f9b82ac0e2a8c5076f75460a7d00d8702d80057c9e9aaaf4f20750b806b5d5fb37ed46c9a3326eaf80b7d31d19544313ce2c43b3af7b870ecbee7ecbf5a3e45f6edf8fc721f1179074a319d186dcc05ad7e799c14e78ae5375e3c51c8d254fedab095baecf33833f152e88e7e7009fa7832c611b12d1dd01e40658b86fdc071af4b8c9b458f8aa246b42f266cd554f3714276bc45f936a8c7b2913a2a16913a3e9b32cfaf9e3cceb1fc5b6c538baefb81bb97c0a2cf52f8696ed5cdf55c24426d4e3dfa03ddb8827883d02e17b177b8b13c0e7e7f47932d3eb62b96124cb51b293ce02fe2ed562e2c66e6a92a94366daeaa5ac074298cbac3b4439eafbec15a3aa5ea9e9000b6749bacd21ad25cc3bb0fc4eddef4e2931fef59bb4ce9a9fd61efa7c06b6d661dfdb8d971e3608cd1df7bf3babd17d146c130078ba5712028a292feda3cabe806dd61b5385d51ad8e123e39e1bfba013f9555cb55ccb8b89acd70f313b3ad943e082e88234d865f780e3ad2736245d2c913435994a46c9d19deeeef30140199d6da8f0dd949f6f232f0167c0bb00e5136d6e432d1150fdc3007f98961402d7743d59fbc6378c4431b4e2f7fd03e0cc66ad698e450f9dcf221cf6b4e00cd333d4447346fc75828938c1c6ad8fc0d72e82d96ed62e452da08b160e536c3de33243773d62d2dee14f2951e00e4790736830320e1406f3c2c67a84010aebc35d9228178efb64f26e727da91551b4e3540b9b5ec85f511ad98665f24b951070aa831ca476fd7e84b403a6ac3a515cea819e446a735d19f4132a8a05f0ad4d3cc138e26426f49b8d733e40c43af699dcf7ebbc71ccc069abf946ea70f07f47ad919ea5bf2b8bcf9ae6e2de10c9424110ebdaf982a9f05ed61adf5882179b79d6fc2f01b4c198a738bca0fd7f8d456ca759fffa2ecd76e0e8aaeb129fb8686b0ecbafa0587246c49c00f3aa2c26c5703ee822bd146418241ce6033a26db4f5102e116b74c26c2d45ab7adb9a88e8e4d3cdf44857478ad4f07bbd6d140d738706ba5dee58a7cbd9bccbeb91d747d77c7fd72c6bc1e3d37c420b4e72660d5f7b85ad432e6a1b29797df64e3ac22650a6095231d7d7b4d7d91b060afe2fee3775aedc1c8db74ad7798a6d3699982419d50655aa70b228fdc7b012ac491a4f194c95874380b8c4a67cad056ec49b0ec2c4aa453d3bff03c48146f3d196fb1afdd351cbe393f5ebf803e60840014f8aa62c6263a71175ab1f1bc43632e473028a84b207eb039a68715134e5740c54a991011b4057d090fbb899b8dfaed1c8ca73f600e0d55869d8fbd53a906ec948491d3201eac6fc630a3e203898e0300d21a953d74fe68630e3cfbe36745a1bc851ee470fcadea77220f524df022c847bd6ff9e2af25b6e52324f1a5c08a6b527ac0748872bd917c55e32733bde1e37f3b5c1d99c729e0435191d9ce72f8f78c6a17460e86609c73568b48d8814322bddc3f2fdcde1df850368fc02da1884c3365bdfff2dfa94107afa23554c2c4f976b489557b1ac36d3e93778a39b98e83795ff738c22cf53a88dacd494d8a493456d40fa71b92bab373e8739580ae95f8be6f3c7b15c6a5822cc5cf700d645a6e50f9f5ff2eb5f8a26a9adb4402012ce6f7f9eca895bcabc09100ac802faacf750b0689e85d1e71b4dc3ee975f39573e86da72c70164b45a691d765af53768b933b477a12858a4a705d9eb0790079e53dc9173fa0bf47295cd9e99c42310beef0831d987389224700b8444d75935fa9941817c7e5e3959875c32a1f8a789fe1364f93e6b6ad27552e29317e6ba3a4b91f113e2cad851ba7bb9fbae7cce65bbbb91d3f0955b46d5a897dc17fd9b34fb8146e5e89d2f829966f8cb35b15524d22c04c3bcc4e4b8d8730b086f39c1384d2a392b4affe0e0065af927bcfe1320422a402d8ae5fa187dabe80724d2c056818271d43611b6babdb2690cb8df31e7305ea028ade53e1b95d82d023af6aa279d19a18aff92a8c0c982ed18b4807fc14ae51e3f6d7ecd162dc38a6b8cd787abadb1e405a7e42202dc02ab6c61e96af5a98e4ea6874fcb8fe3a85c6ad91224e60e2f792241d757654d960a0e24a85d7f2dc72b5786cb65ec0fd22cf724712f5fb45992501fbe6b9e1b1d62153a8e56fa3d3aabc7b99c3becbb2a7a48a0f8bdc91b11d5b0b02e479a172bf18a68920d5f5fa550b11a6e9541b074f3e3fc2a752d0ddc880a96696b1c1a699c5b622811d63629d604725fc2ea456b3b81d239ab57374d055dfd76dc6199da23d52e9877b734507f0c0959183f30fd47ad728a13ac4bde5a74eb261d2cad5495524b25395929b8122f8965c4ba8e0209ae4ef966278313258388b5d06ee49bb8f29b654bad8d2e8787c74cb099c1fdc018b3059e6fc7524d3ec359e5c01d0d3958798f916bf61e18d5689e3c3b55eba92d5bee49e2aa7043c3a6a5f831744447f7c5b08e1088dc2a09166cb98e56d2538c2c6d9a2c68c607c2a712bf2e55f36706b78afcd336a48e536ac7e8d08e2673e49a619f808dff7ef4c941b9132c6b9798fbf6a2859a251bef23a43966415f131fa4dddec86dc1ab6a641f61c08b199b307bd49379e997b27a272b4d544c06e3a8acbaae12ad6bd94e2b7dddbaf2e21d596fc1f8853a4059688c1baf8a4528bc4223960b0ff415af68b91554b9681b0749e5dd8d7836c27fedaba9bdc33118bcd8228b01ec77ed6a052b340655fdb08a9b9d178620d78aca1cca5c86149fc943c569a7fe8f820a18809006ec19ae0e7b3b2b59215ed1e9029cc0ef8f1cb49638a3d69d02cc3af2f10ab21f50e0da06a87217e6e3253a23b5de581e39f145fd16596cf6c8f75e492042be02c46816a87615c2da64 密码是pysandbox13的flag","link":"/p/e8996288.html"},{"title":"与manim之间的往事","text":"最近刚到大学报到完，恰巧有些闲暇时间闲来无事，来记录一下自己与一步一步推动我走到现在的manim之间的故事（指流水账这篇虽然叫「与manim之间的往事」，但是里面很多都和manim无关（逃 一切的起点 现在的一切还要从初中开始说起（因为小学时期就是一直在玩，很少考虑学习的事情）上了初中，关注了很多没营养的公众号 —— 初中数学、初中英语、初中物理 等等一整个系列其中有一个很特别的公众号就是初中化学，总是会转载一些很有趣的实验视频有一次它就转载了 @真·凤舞九天 的疯狂化学两期视频当时看得我大受震撼，于是就顺着链接爬到了贴吧 正好萌凤开始制作DEC（实验室的魔法日常）了，然后就在贴吧上每一期都找到来看逐渐我发现这些视频发布的平台都是一个粉色小网站“那我既然每期都从贴吧翻到哔哩哔哩来看这些视频，那我为什么不直接在这个网站上等待更新呢？”凭着这个想法，我注册了B站 初入B站所以真正带我来B站的，是大萌凤（当时的入站考试还很严格，问题也都很有趣，极大地吸引了我的兴趣起昵称的时候突然想到 凤舞 和我名字里的 鹤翔 还挺搭配的，所以就顺势补全起了个昵称“鹤翔万里” 刚入B站也只是每周看看更新的DEC然后逐渐逛着逛着就发现了这里深藏着的一堆一堆宝藏，一点一点关注了很多up主 其中，在某个评论区，看到了有人推荐up主 @3Blue1Brown，就去看了一看结果也是大受震撼，他可以将一个知识讲得直白易懂、又不缺乏严谨性，更重要的是动画也顺滑舒适好看 初识manim在看了3b1b的视频后，就一直非常好奇这样的视频是怎么做的在疑问了很久之后（已经到了初三），我终于看视频简介了（x发现这是使用一个叫做manim的东西制作的百度一搜索，结果搜到了 @Solara570 的专栏 一看发现，竟然是编写代码制作的，感觉很神奇而且里面的代码看起来也好好看（其实就是Consolas等宽+普通高亮所以也就很想学着做一做 所以就打算先跟着教程试着安装一遍，结果果然处 处 碰 壁 安装什么都会卡住一下，特别是LaTeX，总是出问题，而且很难解决当时正是初三中考复习，而且家里也限制用电脑，所以就只好先放下了但当时就确立了我的一个目标： “我要学会使用manim” 踏上编程的不归路当时在教程中了解到，这里面的代码是python语言，所以就决定要先放下manim好好学一学python（注入怨念：这恰恰是不少人做不到的，很多零基础的人盲目只是要用manim，然后即使没有python基础也要硬着头皮安装，结果出现了各种问题，而且还到处问） 在中考完的暑假中，我买了一本《Python编程：从入门到实践》，在极短的假期（因为高中创新班开学早）中不惜推掉部分衔接课程完整地刷了一遍书，甚至还做了一小本笔记也凭借着部分网络资源，我学会了简单的python语法以及有关计算机的很多知识，也觉得这些东西确实挺有意思的这时我又尝试安装了一遍manim，中途的错误少了很多，但还是卡在了安装LaTeX上高中已经开学，所以我又不得不放下了manim 上了高中，因为是创新班，所以会推荐选择一两门竞赛来学习，为了学到更多的计算机知识，报名了信息竞赛发到了教材之后我就开始疯狂看，甚至自习晚自习，只要是有空闲时间了就拿出来看，这样一个多月学了C++的基础语法（当时班主任发现了还比较不高兴，要求我一直保持年级前二十，但是很显然这是保持不住的） 在高一的NOIp2018后，我发现学长们都不太会使用Linux以及bash，而考试的系统还是NOI Linux所以就决定干脆做几个视频放在B站上供大家参考（都是黑历史）就这样，我成为了一名up主 在超前学了信息竞赛课的内容之后，我开始用那个时间来研究安装manim为了解决LaTeX的报错问题，我试过很多方法，最后使用docker成功安装了环境（为此还花了一段时间了解docker）在做出了第一个带有文字的动画之后很是激动 这样在2019年寒假的时候我抽了点时间来练习练习manim，制作了我的第一个manim视频「动态规划-01背包问题」慢慢的，在每天自习的信息竞赛课上我又学了不少计算机方面的知识当时想要做一个自己的博客，在学markdown时发现数学公式也是用LaTeX写的而且了解到这个东西可以排出很好看的文档，所以就干脆又从零学了LaTeX学了LaTeX之后manim安装就不再出现无法解决的问题了，也就可以顺利安装了 在高一下高二上，我也是凭着兴趣做了几个视频，从中也逐渐地发掘了manim的一些简单用法，也尝试看了一些manim源码当时还觉得那些源码都还是很远的东西，觉得自己能看懂一部分就很好了 在2019年年末，我发现了同是使用manim的up主 @cigar666一段时间后，他建立了manim的交流群，这个群也逐渐地发展壮大在这个群里我也学到了很多知识，教了很多人入坑manim，也认识了好多好多全国各地的朋友 高二的寒假，我计划做了FFT算法那期视频，在那期间，我非常活跃地在群里回答各种问题有一次我给出了一个很复杂的解决办法，而manim源码中其实是有轮子的这时S570说了一句“还是源码看的不够”，我也就从此提高了目标： “我要看懂manim源码” 成立MK高二的寒假，疫情突如其来，假期也随之延长而当时大部分人也都在假期中，为了更好地交流代码，我在GitHub上建立了组织，并且投票选举出了名称manim-kindergarten之后在群友的合作之下又进行了很多资料的完善为了方便回复一些常见的问题，我也编写了《manim常见问题》这个文档，在一年多的完善后，它已经迭代到了3.1版本 同时我也顺势做了很多比较短的视频，参加了一些活动，也被妈咪叔转发了，获得了不少粉丝，也拿到了知识领域优质up主的认证而且MK内部也组织了几次联合投稿，共同完成了一些视频其中我们突发奇想，尝试了使用manim来制作manim教程，结果还蛮不错所以我也就单独在这个系列下完成了几个视频 在制作这个视频时，我也在逐渐深入地阅读源码，感觉没有那么晦涩难懂，代码思路还是很清晰正好有MK成员开了一个文档的repo来汇总一些网上的文档，我也就正好把里面的内容归纳归纳，保留了一些有价值的内容，也补充了部分中文的文档字符串，就这样完成了一大半中文文档 疫情期间，我也加入了manim的discord频道，在里面也帮助了很多人解决了manim上的问题我发现discord上manim channel的管理员是eulertour，而且他在GitHub上也是manim的collaborator，同时还做了很多项目当时就在mk的QQ群里表达了一下对他的仰慕，然后就有一个群友说了句： “其实你也可以” 成为合作者疫情期间在学校机房脱产的时候也经常会读一读manim，还顺便把一直容易出现的Text问题修复了一下当时Grant正在开发基于OpenGL的manim，所以这些pull request一直是eulertour来merge的，但是在他加入了ManimCommunity之后就已经打算将3b1b/manim荒废掉，很少来管issue和pr，甚至有用的pr也只会让交到ManimCommunity里但是我觉得这比较不好，毕竟还有很多人正在使用3b1b/manim，所以我就在暑假的时候抱着试一试的心态给Grant写了一封信来申请3b1b/manim存储库上的权限 结果几天后Grant真的回复了，他同意给我manim上的write权限，但是要先和eulertour沟通一下几个月后的十一假期，我收到了Grant发来的成为collaborator的邀请（其实中间一直没有回复是因为我的邮件跑到了Grant的垃圾信箱里） 在成为collaborator后，我merge了一些有用的pull request，关掉了一些没用的/已解决的/老旧的issue同时我也大致了解了新ManimGL的大致逻辑，也向Grant提了好几项改进的建议，他也采纳了很多部分 在开学了之后，为了复习高考，也基本放下了manim上的活动（还收到了来自Grant的祝福）在2021年寒假，又因为疫情上了一段时间网课，我也又抽时间来玩一玩manim了那时ManimGL已经基本完工，在一些准备之后，shaders分支被合并到了master分支成为了正式版本我也为之写了全新的中英文文档（虽然还是很不完善）在那之后我也对manim做了一些改善，关闭了一些过时的pull request，打开了disscussion，发布新的python包等等 嗯，然后就是开学-&gt;复习-&gt;高考 高考发挥的还算比较好，成功进入了ZJU-Turing为了更好地汇总信息，在假期里我又为mk写了官方网站：manim.org.cn然后就是开学到现在了 后记是manim在一步一步推动着我前进从想要用manim到想要看懂源码到想要为它做出点贡献从一个什么都不会的初中生变成了manim的collaborator这仅仅是三年啊（ 所以，那么接下来继续努力吧 写的太水了，反正就随便写写，想到哪写到哪了，没想到你还真的看到这了_(:з」∠)_","link":"/p/6222a56.html"},{"title":"「Learn LambdaCalculus」#0","text":"前言前段时间，GZTime也跟我聊过一些关于lambda演算的东西学Haskell的时候也总是能听说这个东西看起来挺有意思，来学学_(:з」∠)_ 那我也引用GZTime引用的知乎同学的一句话： 在介绍λ演算之前，我们需要放空一下我们的大脑，忘掉C语言，忘掉冯·诺伊曼机，忘掉图灵机，甚至要忘掉0和1，加和减。我们来到一个只有符号的世界。在这个新的世界里，只需要几条简单的定义和规则，便可以构造出与图灵机完全等价的计算模型，即它是图灵完全（Turing Complete）的。和图灵机一样，这个计算模型可以解决任何一个可以机械计算的问题；与图灵机倾向于硬件实现不同，它更倾向于逻辑的推理。它就是λ演算（Lambda演算）。 lambda term一个合法的lambda表达式又被称为lambda项（lambda term），以下三个规律归纳性地定义了一个合法的lambda项： Variable：一个变量 x 本身也是一个合法的lambda项 Abstraction：如果 M 是一个合法的lambda项，x 是一个变量，那么 (λx.M) 也是一个合法的lambda项（这相当于定义了一个 x -&gt; M 的函数） Application：如果 M 和 N 都是合法lambda项，那么 (M N) 也是一个合法lambda项 lambda表达式的组成有变量、抽象符号λ和一个点.、括号 所有lambda项构成$\\Lambda$空间，通过上述合法lambda项的定义，$\\Lambda$空间的正式定义是： 如果$x$是一个变量，那么$x\\in\\Lambda$ 如果$x$是一个变量且$M\\in\\Lambda$，那么$(\\lambda x.M)\\in\\Lambda$ 如果$M, N\\in\\Lambda$，那么$(M\\ N)\\in\\Lambda$ notation为了使lambda表达式的记法更清晰，可以有以下简化： 一个lambda项最外侧的括号可以省略。比如 (M N) 可以写成 M N 应用是左结合的。比如 M N P 表示的实际是 ((M N) P) 这和Haskell中函数左结合是一样的 抽象是尽可能向右延伸的。比如 λx.M N 实际上表示的是 λx.(M N) 而不是 (λ. M) N 这和Haskell中lambda表达式向右一直延伸是一致的，因此一般要为lambda表达式加上括号 嵌套的多个lambda表达式可以缩写成类似多元函数的样子。比如 λx.λy.λz.M 就可以缩写成 λxyz.M Free &amp; bound variables在一个lambda表达式中，也有自由变量（free variables）和约束变量（bound variables）的概念。 在lambda项 λx.M 中，λx被称为binder，它将输入的x与M中的变量x绑定在一起，这时x就是约束变量，而其它的所有变量都是自由变量。 &emsp;比如在表达式 λx.x+y 中，x就是约束变量，y是自由变量。 对于一个lambda项M的自由变量构成的集合FV(M)，也有一些规律需要满足： 如果 x 是一个变量，那么 FV(x) = {x} FV(λx.M) = FV(M) \\ {x} （M中除去x之外的变量都是自由变量） FV(M N) = FV(M) ∪ FV(N) （M应用在N上得到的lambda项的自由变量是MN两个lambda项的自由变量的并集） Substitutionlambda项也有一种记法叫做替换（substitution），记法 t[x:=r] 表示将lambda项t中的自由变量x都替换成r。它满足以下规律： x[x:=r]=r （一个变量就是自由变量，将其替换成r就变为r） y[x:=r]=y if x!=y （如果x和y不相等，那么）","link":"/p/92a6fc79.html"},{"title":"「Learn Rust」#0 总章","text":"学习一门新语言之Haskell 前言Haskell学的差不多了，也没啥事想干了GZTime之前也跟我推荐过Rust挺好玩的这几天看一看一样，没有教程，只是我的笔记而已 InstallationMac上安装只需要安装rustup即可： 1$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh 然后更新、卸载、检查： 123$ rustup update$ rustup self uninstall$ rustc --version Rust代码的后缀名是.rs，通过rustc code.rs来编译出二进制文件code再运行 Cargo通过rustup安装后自带cargo，可以通过cargo --version检查 通过cargo new project_name来新建一个项目，这时会在当前目录下自动生成下面的目录结构： 123456project_name ├── .git/ ├── .gitignore ├── Cargo.toml └── src └── main.rs cargo会根据输入的项目名称新建一个文件夹，并且默认使用git进行版本控制（可以使用cargo new ... --vcs none取消版本控制） 其中main.rs文件中就是一个Hell World程序。Cargo.toml是这个项目的配置文件： 12345678[package]name = &quot;project_name&quot;version = &quot;0.1.0&quot;edition = &quot;2018&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] 构建、运行、发布 使用cargo build会构建这个项目，并且将可执行文件创建在target/debug/文件夹中 使用cargo run直接构建并运行这个项目 使用cargo check检查项目，但不生产可执行文件、也不输出结果 使用cargo build --release来发布，产生但可执行文件在target/release/文件夹中，不用于直接build，它会进行一些优化来使程序运行地更快 常见编程概念变量let语句会创建一个变量，但是默认都是不可变的（immutable）。即一旦使用let创建一个变量并为其赋值，那这个变量将不允许被改动，如果在代码中改动了这个变量，那么将不会通过编译 但是可以再使用let语句来创建一个同名变量： 12let x = 1;let x = x + 1; 这时，原来的x就被隐藏（shadowing）了（这种方式的前后两个x本质上还是两个变量，它们允许有着不同的数据类型） 在let后面加上mut也可以创建一个可变的变量： 12let mut x = 1;x = x + 1; 但这时x不能更改数据类型 常量常量不同于变量，它一定是不可变的。常量通过const关键字创建，而且需要明确指定数据类型（Rust常量命名规范是用全大写）： 1const MAX_POINT: u32 = 100_000; 数据类型Rust是静态类型语言，编译器需要在编译时得到所有变量的类型，但是也可以自动推测类型。 Rust中的类型分为两种，标量（scalar）和复合（compound） scalar整型： 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize isize和usize是根据系统而定（32/64） 同时整型的值也可以用不同进制表示（十六进制0x开头，八进制0o开头，二进制0b开头，单字节字符b开头（b’A’）），在数值中间也可以增加_来增强可读性，在数值结尾也可以加上类型后缀来明确类型 浮点型：单精度浮点f32，双精度浮点f64 布尔型：bool，值是小写true/false 字符型：char，四字节（使用unicode）。字符是单引号而字符串是双引号 compound元组：元素类型可以不同，但是整个元组的类型和各个元素的类型都有关，例如： 1let tup: (i32, f64, u8) = (500, 6.4, 1); 可以通过.加索引来访问元素： 1let x = tup.1 列表：不同于Python/Haskell，Rust中的列表的长度也是不可变的，而且列表中的所有元素的类型也必须一致。含有五个i32类型的元素的列表的类型就可以写成[i32; 5] 同时[3; 5]这种写法也等价于[3, 3, 3, 3, 3] 可以通过[index]来访问元素，如lst[1]。但如果索引超出列表元素个数，那么编译将不会报错，但运行时会报错 函数通过fn关键字来定义函数，参数的类型必须指定，如果有返回值，返回值的类型也要在()后面用-&gt; type指定。返回值可以在函数中途直接return返回，也可以在函数结尾直接写出要返回的值（不加分号，此时是表达式而不是语句），比如： 123fn plus_one(x: i32) -&gt; i32 { x + 1} 同样，用{}括上的代码块也是一个表达式，它也可以有返回值： 12345let x = 5;let y = { let x = 3; x + 1}; 控制流条件常规的if语句，比如： 1234567if a == 1 { ...;} else if a == 2 { ...;} else { ...;} 不同于Haskell，它可以没有else只有if if语句也可以用在let上，这时{}中要是一个表达式而不是语句，即不带分号： 12345let number = if condition { 5} else { 6}; 循环loop：使用loop会将块一直循环直到遇到break，也可以从loop循环返回值，比如： 123456789let mut counter = 0;let result = loop { counter += 1; if counter == 10 { break counter * 2; }}; while： 123while condition { ...;} for： 123for element in lst.iter() { ...;} 所有权鸽了，明天再写 Reference Rust程序设计语言 简体中文版","link":"/p/db45bee5.html"},{"title":"「Learn Haskell」#7 一些其它类型类","text":"&lt; #6 #A &gt; FoldableFoldable是表示可以折叠（fold）的类型类，在Data.Foldable中定义，这使得和fold相关的函数可以用在任意Foldable的实例类型上。它的定义是： 12345678910111213141516171819class Foldable t where fold :: Monoid m =&gt; t m -&gt; m foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m foldMap' :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldr1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a foldl1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a toList :: t a -&gt; [a] null :: t a -&gt; Bool length :: t a -&gt; Int elem :: Eq a =&gt; a -&gt; t a -&gt; Bool maximum :: Ord a =&gt; t a -&gt; a minimum :: Ord a =&gt; t a -&gt; a sum :: Num a =&gt; t a -&gt; a product :: Num a =&gt; t a -&gt; a {-# MINIMAL foldMap | foldr #-} 最少只要实现foldr和foldMap其中之一就可以使一个类型成为Foldable的实例，其它的函数都有由这两个函数提供的默认实现，而且这两个函数之间也有相互实现。因此只要实现foldr或foldMap一个函数就可以使用所有其它Foldable中的函数。foldr函数在前面已经有学过，foldMap的例子是： 123456ghci&gt; foldMap Sum [1, 3, 5]Sum {getSum = 9}ghci&gt; foldMap Product [1, 3, 5]Product {getProduct = 15}ghci&gt; foldMap (replicate 3) [1, 2, 3][1,1,1,2,2,2,3,3,3] Foldable实例[]、Maybe、Either a、(,) a都是Foldable的实例，标准容器库中的Map、Set等也都是Foldable的实例。也可以自定义二叉树类型，并使其成为Foldable的实例： 1234567data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)instance Foldable Tree where foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; Tree a -&gt; m foldMap f Empty = mempty foldMap f (Leaf x) = f x foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r 常用函数 asum :: (Alternative f, Foldable t) =&gt; t (f a) -&gt; f a，用&lt;|&gt;逐个连接所有元素 sequenceA_ :: (Applicative f, Foldable t) =&gt; t (f a) -&gt; f ()，由于丢弃结果，所以Foldable t就可以满足；因此不同于sequenceA需要Traversable traverse_ :: (Applicative f, Foldable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f () for_ :: (Applicative f, Foldable t) =&gt; t a -&gt; (a -&gt; f b) -&gt; f () TraversableTraversable是表示可遍历的类型类，在Data.Traversable模块中定义，它是Foldable的升级版，同时也是一个Functor，它的定义是： 123456class (Functor t, Foldable t) =&gt; Traversable t where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a) mapM :: Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b) sequence :: Monad m =&gt; t (m a) -&gt; m (t a) {-# MINIMAL traverse | sequenceA #-} 最少只需要实现traverse函数或者sequenceA函数。其中各个函数的功能通过类型签名也都能推测出来。但是其中mapM就是traverse，sequence就是sequenceA，它们存在只是历史遗留（ Traversable实例1234567891011121314151617instance Traversable Maybe where traverse _ Nothing = pure Nothing traverse f (Just x) = Just &lt;$&gt; f xinstance Traversable [] where {-# INLINE traverse #-} traverse f = foldr cons_f (pure []) where cons_f x ys = liftA2 (:) (f x) ysinstance Traversable (Either a) where traverse _ (Left x) = pure (Left x) traverse f (Right y) = Right &lt;$&gt; f yinstance Traversable ((,) a) where traverse f (x, y) = (,) x &lt;$&gt; f y... 上面的Tree也可以成为Traversable的实例： 123456789101112131415instance Functor Tree where fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b fmap g Empty = Empty fmap g (Leaf x) = Leaf $ g x fmap g (Node l x r) = Node (fmap g l) (g x) (fmap g r)instance Traversable Tree where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; Tree a -&gt; f (Tree b) traverse g Empty = pure Empty traverse g (Leaf x) = Leaf &lt;$&gt; g x traverse g (Node l x r) = Node &lt;$&gt; traverse g l &lt;*&gt; g x &lt;*&gt; traverse g r Traversable LawsTraversable也有两条定律： traverse Identity = Identity traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f 其中Identity和Compose分别定义在Data.Functor.Identity和Data.Functor.Compose两个模块中： 12newtype Identity a = Identity { runIdentity :: a } deriving (...)newtype Compose f g a = Compose { getCompose :: f (g a) } deriving (...) BifunctorFunctor的实例的kind都是* -&gt; *，因此fmap只能将一个函数映射到一个值上。而Bifunctor（在Data.Bifunctor模块中定义）的实例的kind是* -&gt; * -&gt; *，而且它的bimap可以同时将两个函数映射到两个值上： 12345class Bifunctor p where bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d first :: (a -&gt; b) -&gt; p a c -&gt; p b c second :: (b -&gt; c) -&gt; p a b -&gt; p a c {-# MINIMAL bimap | first, second #-} 同时bimap和first,second之间也可以相互转换： 1234bimap f g = first f . second gfirst f = bimap f idsecond g = bimap id g 对于Functor，((,) e)和Either e才是Functor的实例，因为他们是* -&gt; *。但是对于Bifunctor，(,)和Either就是Bifunctor的实例： 12ghci&gt; bimap (+1) length (4, [1,2,3])(5,3) Bifunctor Laws bimap id id = id first id = id second id = id bimap (f . g) (h . i) = bimap f h . bimap g i first (f . g) = first f . first g second (f . g) = second f . second g CategoryHaskell中的Category将一般的函数推广到了普遍的态射上，它在Control.Category模块中，定义是： 123class Category cat where id :: cat a a (.) :: cat b c -&gt; cat a b -&gt; cat a c 它的实例有(-&gt;)和Kleisli m： 123instance Category (-&gt;) where id = GHC.Base.id (.) = (GHC.Base..) Kleisli是一个范畴，用来表示函数a -&gt; m b，Haskell中，它在Control.Arrow模块中定义： 12345678newtype Kleisli m a b = Kleisli { runKleisli :: a -&gt; m b }instance Monad m =&gt; Category (Kleisli m) where id :: Kleisli m a a id = Kleisli return (.) :: Kleisli m b c -&gt; Kleisli m a b -&gt; Kleisli m a c Kleisli g . Kleisli h = Kleisli (h &gt;=&gt; g) Category要满足的定律只有id是(.)操作的单位元，以及(.)操作是可结合的 同时Category还提供了两个函数&lt;&lt;&lt;和&gt;&gt;&gt;： 12345(&lt;&lt;&lt;) :: Category cat =&gt; cat b c -&gt; cat a b -&gt; cat a c(&lt;&lt;&lt;) = (.)(&gt;&gt;&gt;) :: Category cat =&gt; cat a b -&gt; cat b c -&gt; cat a c f &gt;&gt;&gt; g = g . f ArrowArrow将函数进一步抽象化，它定义在Control.Arrow模块中： 1234567class Category a =&gt; Arrow a where arr :: (b -&gt; c) -&gt; a b c first :: a b c -&gt; a (b, d) (c, d) second :: a b c -&gt; a (d, b) (d, c) (***) :: a b c -&gt; a b' c' -&gt; a (b, b') (c, c') (&amp;&amp;&amp;) :: a b c -&gt; a b c' -&gt; a b (c, c') {-# MINIMAL arr, (first | (***)) #-} 其中： arr函数将一个函数变成一个Arrow first函数将一个Arrow变成一个二元组间的Arrow，且只会对一个元素进行操作，第二个元素保持不变 second函数与first相反，第一个元素保持不变 ***函数是Arrow之间的parallel composition，对于函数: (g *** h) (x, y) = (g x, h y) &amp;&amp;&amp;函数是Arrow之间的fanout composition，对于函数: (g &amp;&amp;&amp; h) x = (g x, h x) 它的实例也有(-&gt;)和Kleisli： 1234567891011121314instance Arrow (-&gt;) where arr :: (b -&gt; c) -&gt; (b -&gt; c) arr g = g first :: (b -&gt; c) -&gt; ((b,d) -&gt; (c,d)) first g (x,y) = (g x, y)instance Monad m =&gt; Arrow (Kleisli m) where arr :: (b -&gt; c) -&gt; Kleisli m b c arr f = Kleisli (return . f) first :: Kleisli m b c -&gt; Kleisli m (b,d) (c,d) first (Kleisli f) = Kleisli (\\ ~(b,d) -&gt; do c &lt;- f b return (c,d) ) 常用函数： 1234567891011121314returnA :: Arrow a =&gt; a b breturnA = arr id(^&gt;&gt;) :: Arrow a =&gt; (b -&gt; c) -&gt; a c d -&gt; a b df ^&gt;&gt; a = arr f &gt;&gt;&gt; a(&gt;&gt;^) :: Arrow a =&gt; a b c -&gt; (c -&gt; d) -&gt; a b da &gt;&gt;^ f = a &gt;&gt;&gt; arr f(&lt;&lt;^) :: Arrow a =&gt; a c d -&gt; (b -&gt; c) -&gt; a b da &lt;&lt;^ f = a &lt;&lt;&lt; arr f(^&lt;&lt;) :: Arrow a =&gt; (c -&gt; d) -&gt; a b c -&gt; a b df ^&lt;&lt; a = arr f &lt;&lt;&lt; a Arrow notation类似do-notation，Arrow也提供了一套方便的语句： 1234proc x -&gt; do y &lt;- action1 -&lt; ... z &lt;- action2 -&lt; ... returnA -&lt; ... 其中proc代替了lambda表达式中的斜杠\\，-&lt;右边的为输入，左边的为接收输入的函数。比如，下面三种写法达成的效果是一样的： 12345678910111213141516171819202122232425262728f :: Int -&gt; (Int, Int)f = \\x -&gt; let y = 2 * x z1 = y + 3 z2 = y - 5 in (z1, z2) -- ghci&gt; f 10 -- (23,15)fM :: Int -&gt; Identity (Int, Int)fM = \\x -&gt; do y &lt;- return (2 * x) z1 &lt;- return (y + 3) z2 &lt;- return (y - 5) return (z1, z2)-- ghci&gt; runIdentity (fM 10)-- (23,15)fA :: Int -&gt; (Int, Int)fA = proc x -&gt; do y &lt;- (2 *) -&lt; x z1 &lt;- (+ 3) -&lt; y z2 &lt;- (subtract 5) -&lt; y returnA -&lt; (z1, z2)-- ghci&gt; fA 10-- (23,15) ArrowChoice12345678910111213141516171819202122232425262728293031class Arrow a =&gt; ArrowChoice a where left :: a b c -&gt; a (Either b d) (Either c d) left = (+++ id) right :: a b c -&gt; a (Either d b) (Either d c) right = (id +++) (+++) :: a b c -&gt; a b' c' -&gt; a (Either b b') (Either c c') f +++ g = left f &gt;&gt;&gt; arr mirror &gt;&gt;&gt; left g &gt;&gt;&gt; arr mirror where mirror :: Either x y -&gt; Either y x mirror (Left x) = Right x mirror (Right y) = Left y (|||) :: a b d -&gt; a c d -&gt; a (Either b c) d f ||| g = f +++ g &gt;&gt;&gt; arr untag where untag (Left x) = x untag (Right y) = yinstance ArrowChoice (-&gt;) where left f = f +++ id right f = id +++ f f +++ g = (Left . f) ||| (Right . g) (|||) = eitherinstance Monad m =&gt; ArrowChoice (Kleisli m) where left f = f +++ arr id right f = arr id +++ f f +++ g = (f &gt;&gt;&gt; arr Left) ||| (g &gt;&gt;&gt; arr Right) Kleisli f ||| Kleisli g = Kleisli (either f g) ArrowZero &amp; ArrowPlus1234567891011class Arrow a =&gt; ArrowZero a where zeroArrow :: a b cclass ArrowZero a =&gt; ArrowPlus a where (&lt;+&gt;) :: a b c -&gt; a b c -&gt; a b cinstance MonadPlus m =&gt; ArrowZero (Kleisli m) where zeroArrow = Kleisli (\\_ -&gt; mzero)instance MonadPlus m =&gt; ArrowPlus (Kleisli m) where Kleisli f &lt;+&gt; Kleisli g = Kleisli (\\x -&gt; f x `mplus` g x) 例子123456789101112131415161718192021222324252627282930ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) &lt;+&gt; (Kleisli (\\x -&gt; [x, -x]))) 2[4,2,-2]ghci&gt; either (+2) (*3) (Left 3)5ghci&gt; either (+2) (*3) (Right 3)9ghci&gt; (+2) ||| (*3) $ (Left 3)5ghci&gt; (+2) +++ (*3) $ (Left 3)Left 5ghci&gt; (+2) ||| (*3) $ (Right 3)9ghci&gt; (+2) +++ (*3) $ (Right 3)Right 9ghci&gt; left (+2) (Left 3)Left 5ghci&gt; right (*3) (Right 3)Right 9ghci&gt; left (+2) (Right 3)Right 3ghci&gt; right (*3) (Left 3)Left 3ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) ||| (Kleisli (\\x -&gt; [x, -x]))) (Left 3)[6]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) ||| (Kleisli (\\x -&gt; [x, -x]))) (Right 3)[3,-3]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) +++ (Kleisli (\\x -&gt; [x, -x]))) (Left 3)[Left 6]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) +++ (Kleisli (\\x -&gt; [x, -x]))) (Right 3)[Right 3,Right (-3)] Reference Typeclassopedia - Haskell wiki Haskell语言学习笔记（40）Arrow（1） - zwvista 24 Days of GHC Extensions: Arrows - Tom Ellis Haskell语言学习笔记（47）Arrow（2） - zwvista 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/68ef8146.html"},{"title":"「Learn Haskell」#A Haskell与范畴论","text":"Haskell中的函子单子等都与范畴论（category theory）有很多联系，所以打算简单了解一下范畴论的相关内容。 范畴论是数学的一门学科，以抽象的方法处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。数学中许多重要的领域可以形式化为范畴。使用范畴论可以令这些领域中许多难理解、难捉摸的数学结论更容易叙述证明。 ———— 维基百科 范畴（Category）范畴本质上是一个简单的集合，一个范畴$\\mathbf{C}$包含三个组成成分： 一个类$\\mathrm{ob}(\\mathbf{C})$：其中元素称为对象（objects） 一个类$\\mathrm{hom}(\\mathbf{C})$：其中元素称为态射（morphisms）（或箭号（arrows））：每个态射连接了两个对象：源对象（source object）、目标对象（target object）。如果$f$是从源对象$A$到目标对象$B$（$A, B\\in \\mathrm{ob}(\\mathbf{C})$）的态射，那么记为$f : A\\to B$ 一个二元运算，称为态射复合（composition）：两个态射$g : A\\to B$、$f : B\\to C$的复合记为$f\\circ g : A\\to C$在Haskell和大部分数学理论中都是从右向左计算，即$f\\circ g$中是先计算$g : A\\to B$再计算$f : B\\to C$ 许多东西都可以组成范畴。比如: &emsp;$\\mathbf{Set}$是一个范畴，对象为所有集合，态射为集合之间的函数，复合即函数之间的复合 &emsp;$\\mathbf{Grp}$是一个范畴，对象为所有群，态射为群同态（group homomorphisms），例如对于群$(G,*)$和$(H,\\cdot )$，有群同态$h : (G,*)\\to (H,\\cdot )$，则需要对于$G$中的任意元素$u,v$满足$$h(u*v)=h(u)\\cdot h(v)$$ 注意：态射不必须为函数；而且可以存在源对象和目标对象都相同的不同态射 范畴公理每个范畴都需要满足三条定律： 态射复合需要满足结合律（associativity）：$$f\\circ (g\\circ h) = (f\\circ g)\\circ h$$ 范畴在复合操作下是闭合的（closed）：&emsp;&emsp;&emsp;如果范畴$\\mathbf{C}$中存在态射$f : B\\to C$、$g : A\\to B$，那么范畴$\\mathbf{C}$中也一定存在态射$h : A\\to C$，且$h=f\\circ g$ 每个对象都需要有单位态射（identity morphisms）：&emsp;&emsp;&emsp;对于范畴$\\mathbf{C}$中的对象$A$，一定存在单位态射$\\mathrm{id}_A : A\\to A$，且对于每个态射$g : A\\to B$，一定有：$$g\\circ\\mathrm{id}_A = \\mathrm{id}_B\\circ g = g$$ $\\mathbf{Hask}$范畴范畴$\\mathbf{Hask}$的对象为Haskell中的类型（types），态射是Haskell中的函数，复合运算是(.)。即从类型A到类型B的函数 f :: A -&gt; B 就是$\\mathbf{Hask}$范畴中的一个态射。而函数 f :: B -&gt; C 、g :: A -&gt; B 的组合 f . g 就是一个新的函数 h :: A -&gt; C。 对于三条定律： 第一条显然满足：f . (g . h) = (f . g) . h 第二条也显然满足，如果有函数 f :: B -&gt; C 、g :: A -&gt; B，一定有函数 h = (f . g) :: A -&gt; C 对于第三条定律，Haskell中存在单位函数 id ，但id是多态（polymorphic）的，要为其指定类型使其变成单态（monomorphic）的。比如态射$\\mathrm{id}_A$在Haskell中就可以表示为 id :: A -&gt; A。并且显然满足第三条定律（其中 f :: A -&gt; B）：(id :: B -> B) . f = f . (id :: A -> A) = f 函子（Functors）一个范畴中的态射将两个对象联系起来，而函子则会将两个范畴联系起来。换句话说，函子就是从一个范畴到另一个范畴的变换。比如对于范畴$\\mathbf{C}$、$\\mathbf{D}$，定义函子$F : \\mathbf{C}\\to\\mathbf{D}$满足： 对于$\\mathbf{C}$中的任意对象$A$，在$\\mathbf{D}$中都有对象$F(A)$ 对于$\\mathbf{C}$中的任意态射$f : A\\to B$，在$\\mathbf{D}$中都有态射$F(f) : F(A)\\to F(B)$ 比如： &emsp;遗忘函子（forgetful functor）$U : \\mathbf{Grp}\\to\\mathbf{Set}$，将一个群映射到一个集合中，将群同态映射到集合间的函数 &emsp;幂集函子（power set functor）$P : \\mathbf{Set}\\to\\mathbf{Set}$，将一个集合映射到它的幂集，将原集合中的函数$f : A\\to B$映射到函数$P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$，即从$U\\subseteq A$到值域$f(U)\\subseteq B$的映射 &emsp;自函子（endofunctor）$1_{\\mathbf{C}} : \\mathbf{C}\\to\\mathbf{C}$，将一个范畴映射到它本身 函子公理函子$F : \\mathbf{C}\\to\\mathbf{D}$也需要满足两个公理： 对于任意对象$X\\in\\mathbf{C}$，恒有$F(\\mathrm{id}_X)=\\mathrm{id}_{F(X)}$ 对于态射$f : Y\\to Z$、$g : X\\to Y$，恒有$F(f\\circ g) = F(f)\\circ F(g)$ $\\mathbf{Hask}$范畴上的函子Haskell中的Functor定义是： 12class Functor (f :: * -&gt; *) where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 对于Haskell中的Functor，它实际上是从$\\mathbf{Hask}$范畴（types）到它子范畴的变换。比如列表函子$\\mathtt{[]} : \\mathbf{Hask}\\to\\mathbf{Lst}$（其中$\\mathbf{Lst}$是所有Haskell中列表类型构成的范畴） 它也达成了范畴论中对于函子的要求。函子需要进行两个操作：将一个范畴中的对象映射到另一个范畴中、将一个范畴中的态射映射到另一个范畴中。以Maybe为例，它实现了函子的要求： Maybe是一个类型构造器，他可以将任意类型 T 变成新类型 Maybe T，相当于从$\\mathbf{Hask}$范畴的对象变成了$\\mathbf{Maybe}$范畴的对象 fmap函数接收一个 a -&gt; b 类型的函数，返回一个 Maybe a -&gt; Maybe b 类型的函数，相当于将$\\mathbf{Hask}$范畴中的态射$f : A\\to B$映射成了$\\mathbf{Maybe}$范畴中的态射$\\mathbf{Maybe}(f) : \\mathbf{Maybe}(A)\\to\\mathbf{Maybe}(B)$ 注意：时刻记住这里研究的是$\\mathbf{Hask}$范畴和它的子范畴，对象是类型而不是值，态射是函数也指的是从类型到类型 同时，Haskell中的Functor也满足函子公理： fmap id = id 即 fmap (id :: A -&gt; A) = (id :: f A -&gt; f A) fmap (f . g) = fmap f . fmap g 单子（Monads） 一个单子说白了不过就是自函子范畴上的一个幺半群而已 _(:з」∠)_ 自函子在前面说到过是从一个范畴到自身的一个函子，如范畴$\\mathbf{C}$上的自函子是$F : \\mathbf{C}\\to\\mathbf{C}$。自函子范畴就是对象都是自函子的范畴。幺半群和Haskell中学到的Monoid类型类一样，是一个有可结合二元运算和单位元的代数结构。因此单子就是一个自函子，而且它有可结合二元运算（Haskell中&gt;=&gt;）和单位元（Haskell中return）。 一个单子$M : \\mathbf{C}\\to\\mathbf{C}$还包含两个态射（对于范畴$\\mathbf{C}$中的所有对象$X$）： $\\mathrm{unit}_X^M : X\\to M(X)$ $\\mathrm{join}_X^M : M(M(X))\\to M(X)$ （当式子中的单子明显是$M$时，可以省略上标${}^M$） Haskell中Monad的定义是： 123class Functor m =&gt; Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b 其中很显然多态函数return对应了定义中的$\\mathrm{unit}$，但是&gt;&gt;=和$mathrm{join}$的对应关系并不明显。因此Haskell中有一个工具函数join，它的效果就是定义中的$\\mathrm{join}$，而且它可以和&gt;&gt;=互相定义： 12345join :: Monad m =&gt; m (m a) -&gt; m ajoin x = x &gt;&gt;= id(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x 所以Haskell中为Monad要求定义&gt;&gt;=就相当于定义了$\\mathrm{join}$ 例如，幂集函子$P : \\mathbf{Set}\\to\\mathbf{Set}$也是一个单子，可以为它定义$\\mathrm{unit}$和$\\mathrm{join}$两个态射。Haskell中的列表也可以近似看作幂集函子。 &emsp;态射/函数的类型： 幂集函子 Haskell中列表 一个集合$S$和一个态射$f : A\\to B$ 一个类型 T 和一个函数 f :: A -&gt; B $P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$ fmap f :: [A] -&gt; [B] $\\mathrm{unit}_S : S\\to\\mathcal{P}(S)$ return :: T -&gt; [T] $\\mathrm{join}_S : \\mathcal{P}(\\mathcal{P}(S))\\to\\mathcal{P}(S)$ join :: [[T]] -&gt; [T] &emsp;态射/函数的定义： 幂集函子 Haskell中列表 $(\\mathcal{P}(f))(S) = \\{f(a):a\\in S\\}$ fmap f xs = [ f a | a &lt;- xs ] $\\mathrm{unit}_S(x) = \\{x\\}$ return x = [x] $\\mathrm{join}_S(L) = \\bigcup L$ join xs = concat xs 单子公理给定一个单子$M : \\mathbf{C}\\to\\mathbf{C}$，和一个态射$f : A\\to B$（其中$A,B\\in \\mathbf{C}$），那么满足下面四条定律： $\\mathrm{join}\\circ M(\\mathrm{join})=\\mathrm{join}\\circ\\mathrm{join}$ $\\mathrm{join}\\circ M(\\mathrm{unit})=\\mathrm{join}\\circ\\mathrm{unit}=\\mathrm{id}$ $\\mathrm{unit}\\circ f = M(f)\\circ\\mathrm{unit}$ $\\mathrm{join}\\circ M(M(f)) = M(f)\\circ\\mathrm{join}$ 也可以很自然地将其转化为Haskell中的表述： join . fmap join = join . join join . fmap return = join . return = id return . f = fmap f . return join . fmap (fmap f) = fmap f . join 在Haskell中，使用&gt;&gt;=也有三个定律和这四个定律是等价的： return x &gt;&gt;= f = f x 123456 return x &gt;&gt;= f = join (fmap f (return x)) = join (fmap f . return $ x)= join (return (f x)) = join (return . f $ x)= join . return $ (f x)= id (f x)= f x m &gt;&gt;= return = m1234 m &gt;&gt;= return = join (fmap return m) = join . fmap return $ m = id m= m (m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)123456789101112 (m &gt;&gt;= f) &gt;&gt;= g = (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))= join . fmap g . join $ fmap f m = join . join . fmap (fmap g) $ fmap f m = join . join . fmap (fmap g) . fmap f $ m = join . join . fmap (fmap g . f) $ m = join . fmap join . fmap (fmap g . f) $ m = join . fmap (join . (fmap g . f)) $ m = join . fmap (\\x -&gt; join (fmap g (f x))) $ m = join . fmap (\\x -&gt; f x &gt;&gt;= g) $ m = join (fmap (\\x -&gt; f x &gt;&gt;= g) m)= m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g) （范畴论就先简单看这些，只是为了更好理解Haskell中概念而已） Reference Haskell/Category theory - wikibooks Category theory - wikipedia 范畴论 - 维基百科 Monad (category theory) - wikipedia Functor - wikipedia 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/96c32eae.html"},{"title":"「Learn Haskell」#6 半群与幺半群","text":"&lt; #5 #7 &gt; Semigroup半群（semigroup）是一个集合$S$，它需要指定一个二元运算符$\\oplus$，并且满足 $$a\\oplus b \\in S\\quad a, b\\in S$$ 以及结合（associative）律： $$(a\\oplus b)\\oplus c = a\\oplus (b\\oplus c)$$ 这个二元运算符在Haskell的Semigroup中被定义为&lt;&gt;函数： 12345678910class Semigroup a where (&lt;&gt;) :: a -&gt; a -&gt; a sconcat :: NonEmpty a -&gt; a sconcat (a :| as) = go a as where go b (c:cs) = b &lt;&gt; go c cs go b [] = b stimes :: Integarl b =&gt; b -&gt; a -&gt; a stimes = ... 除此之外还有sconcat和stimes函数，都给出了默认实现。对于列表，&lt;&gt;相当于(++)，stimes相当于concat . replicate： 123456ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; sconcat $ fromList [[1, 2], [3, 4]][1,2,3,4]ghci&gt; stimes 3 [1, 2][1,2,1,2,1,2] Semigroup Law (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) 补：NonEmptyNonEmpty表示非空列表，定义是： 1data NonEmpty a = a :| [a] deriving (Eq, Ord) 使用一个元素和一个列表用:|连接就可以生成一个NonEmpty类型的列表 Data.List.NonEmpty模块中实现了很多普通列表有的函数，需要qualified import后调用，使用fromList、toList函数可以在普通列表和非空列表之间转换 12345678ghci&gt; import qualified Data.List.NonEmpty as NEghci&gt; arr = NE.fromList [1, 2, 3]ghci&gt; arr1 :| [2,3]ghci&gt; NE.head arr 1ghci&gt; NE.tail arr [2,3] Monoid幺半群（Monoid）是一个有单位元素$e$的半群，即$e$满足： $$e\\oplus x = x\\oplus e = x$$ 12345678class Semigroup a =&gt; Monoid a where mempty :: a mappend :: a -&gt; a -&gt; a mappend = (&lt;&gt;) mconcat :: [a] -&gt; a mconcat = foldr mappend mempty 可以看出Monoid要求了三个函数，其中最少只需要mempty，它直接返回一个值，表示单位元素。mappend即Semigroup中的&lt;&gt;运算符，mconcat也提供了默认实现 实例[a]因为Monoid的实例是一个具体类型，而不是像Functor等一样等类型构造器，所以[]并不是Monoid的实例，但是具体类型[a]是一个幺半群： 123456instance Semigroup [a] where (&lt;&gt;) = (++)instance Monoid [a] where mempty = [] mconcat xss = [x | xs &lt;- xss, x &lt;- xs] 列表的单位元素(mempty)就是空列表[]，运算符就是合并列表(++)，mconcat也用列表推导重新实现提高效率 12345678ghci&gt; mempty :: [Int] []ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; [1, 2] `mappend` [3, 4][1,2,3,4]ghci&gt; mconcat [[1,2], [3,4]][1,2,3,4] Ordering1234567instance Semigroup Ordering where LT &lt;&gt; _ = LT EQ &lt;&gt; y = y GT &lt;&gt; _ = GTinstance Monoid Ordering where mempty = EQ 主要可以用于比较字典序： 12ghci&gt; mconcat (zipWith compare &quot;abcd&quot; &quot;acbd&quot;)LT Sum &amp; Product对于数字，加法和乘法都满足结合律，所以对于Num，有两种实现Monoid的方式，但是不能为同一类型设置两种实例方式，所以Data.Monoid中提供了两个包装器————Sum和Product： 12newtype Sum a = Sum {getSum :: a} deriving (...)newtype Product a = Product {getProduct :: a} deriving (...) 它们使用Sum或Product来包装起一个数字，可以通过getSum或getProduct来获取其中的值 对于加法，二元操作为(+)，单位元素为0；对于乘法，二元操作为(*)，单位元素为1: 1234567891011instance Num a =&gt; Semigroup (Sum a) where (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Sum a) where mempty = Sum 0instance Num a =&gt; Semigroup (Product a) where (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Product a) where mempty = Product 1 12345678ghci&gt; Sum 5 &lt;&gt; Sum 6 &lt;&gt; Sum 10Sum {getSum = 21}ghci&gt; getSum . mconcat . fmap Sum $ [5, 6, 10]21ghci&gt; Product 5 &lt;&gt; Product 6 &lt;&gt; Product 10Product {getProduct = 300}ghci&gt; getProduct . mconcat . fmap Product $ [5, 6, 10]300 All &amp; Any和数字一样，布尔值也有两种实现Monoid的方式，因此Data.Monoid模块中也提供了两个包装器，分别实现了这两种Monoid： 12345678910111213141516newtype All = All { getAll :: Bool } deriving (...)instance Semigroup All where (&lt;&gt;) = coerce (&amp;&amp;)instance Monoid All where mempty = All Truenewtype Any = Any { getAny :: Bool } deriving (...)instance Semigroup Any where (&lt;&gt;) = coerce (||)instance Monoid Any where mempty = Any False 12345678ghci&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)Falseghci&gt; getAll (mconcat (map (\\x -&gt; All (even x)) [2,4,6,7,8]))Falseghci&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)Trueghci&gt; getAny (mconcat (map (\\x -&gt; Any (even x)) [2,4,6,7,8]))True Monoid a =&gt; Maybe a如果a是一个(幺)半群，那么Maybe a也是一个幺半群，单位元就是Nothing： 1234567instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b a &lt;&gt; Nothing = a Just a &lt;&gt; Just b = Just (a &lt;&gt; b)instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing 123456ghci&gt; Nothing &lt;&gt; Just &quot;andy&quot;Just &quot;andy&quot;ghci&gt; Just LT &lt;&gt; NothingJust LTghci&gt; Just (Sum 3) &lt;&gt; Just (Sum 4) Just (Sum {getSum = 7}) First &amp; Last对于Maybe也有两种实现Monoid的方法，即&lt;&gt;操作每次恒取左边和每次恒取右边（在没有Nothing的情况下），所以Data.Monoid模块中也提供了两个新的包装器：First和Last： 123456789101112131415161718newtype First a = First { getFirst :: Maybe a } deriving (...)instance Semigroup (First a) where First Nothing &lt;&gt; b = b a &lt;&gt; _ = ainstance Monoid (First a) where mempty = First Nothingnewtype Last a = Last { getLast :: Maybe a } deriving (...)instance Semigroup (Last a) where a &lt;&gt; Last Nothing = a _ &lt;&gt; b = binstance Monoid (Last a) where mempty = Last Nothing 12345678ghci&gt; getFirst (First (Just &quot;hello&quot;) &lt;&gt; First Nothing &lt;&gt; First (Just &quot;world&quot;))Just &quot;hello&quot;ghci&gt; getLast (Last (Just &quot;hello&quot;) &lt;&gt; Last Nothing &lt;&gt; Last (Just &quot;world&quot;))Just &quot;world&quot;ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10] Just 9ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10] Just 10 Min &amp; Max对于有界的类型，也有两种实现Monoid的方式，每次二元操作都取最小或最大。Data.Semigroup模块中提供了两个包装其器：Min和Max： 12345678910111213141516newtype Min a = Min { getMin :: a } deriving (...)instance Ord a =&gt; Semigroup (Min a) where (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Min a) where mempty = maxBoundnewtype Max a = Max { getMax :: a } deriving (...)instance Ord a =&gt; Semigroup (Max a) where (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Max a) where mempty = minBound 12345678ghci&gt; Min 3 &lt;&gt; Min 5Min {getMin = 3}ghci&gt; Max 3 &lt;&gt; Max 5Max {getMax = 5}ghci&gt; getMin . mconcat . map Min $ [1,2,3] :: Int1ghci&gt; getMax . mconcat . map Max $ [1,2,3] :: Int3 元组当元组内的所有元素都是幺半群时，整个元组也是一个幺半群： 123456instance (Semigroup a, Semigroup b) =&gt; Semigroup (a, b) where (a,b) &lt;&gt; (a',b') = (a&lt;&gt;a',b&lt;&gt;b') stimes n (a,b) = (stimes n a, stimes n b)instance (Monoid a, Monoid b) =&gt; Monoid (a,b) where mempty = (mempty, mempty) 12ghci&gt; mconcat $ map (\\x -&gt; (Min x, Max x)) [1..10] :: (Min Int, Max Int)(Min {getMin = 1},Max {getMax = 10}) Monoid Laws mempty &lt;&gt; x = x x &lt;&gt; mempty = x (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) Monoidal classesApplicative、Monad、Arrow都有有幺半群性质的子类型类，分别是Alternative、MonadPlus、ArrowPlus Alternative12345678910class Applicative f =&gt; Alternative f where -- | The identity of '&lt;|&gt;' empty :: f a -- | An associative binary operation (&lt;|&gt;) :: f a -&gt; f a -&gt; f a some :: f a -&gt; f [a] some v = (:) &lt;$&gt; v &lt;*&gt; many v many :: f a -&gt; f [a] many v = some v &lt;|&gt; pure [] 其中empty是幺半群中的单位元素，&lt;|&gt;是幺半群中的二元运算符。some和many是两个函数（意义还不懂） Alternative实例[]123instance Alternative [] where empty = [] (&lt;|&gt;) = (++) 和Monoid一样，单位元素是空列表，二元运算是列表合并 123456ghci&gt; [1,2,3] &lt;|&gt; empty &lt;|&gt; [4,5][1,2,3,4,5]ghci&gt; some [][]ghci&gt; many [][[]] Maybe1234instance Alternative Maybe where empty = Nothing Nothing &lt;|&gt; r = r l &lt;|&gt; _ = l Maybe作为Alternative的单位元素是Nothing，二元运算是始终取左边（当左边不为Nothing时） 123456ghci&gt; Nothing &lt;|&gt; Just 1 &lt;|&gt; Just 2 Just 1 ghci&gt; some NothingNothing ghci&gt; many Nothing Just [] ZipList123instance Alternative ZipList where empty = ZipList [] ZipList xs &lt;|&gt; ZipList ys = ZipList (xs ++ drop (length xs) ys) 1234&lt;&gt;getZipList $ ZipList [1,2] &lt;|&gt; ZipList [3,4,5,6][1,2,5,6]&lt;&gt;getZipList $ ZipList [1,2,3,4] &lt;|&gt; ZipList [3,4,5,6][1,2,3,4] Alternative Laws Monoid laws: 123empty &lt;|&gt; x = x x &lt;|&gt; empty = x (x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z) Left zero law：empty &lt;*&gt; f = empty以上的定律是都满足都，下面的定律只有部分满足： Right zero law：f &lt;*&gt; empty = empty （大部分包括Maybe、[]满足，IO不满足） Left distribution：(a &lt;|&gt; b) &lt;*&gt; c = (a &lt;*&gt; c) &lt;|&gt; (b &lt;*&gt; c) （Maybe、[]满足，IO及大部分parsers不满足） Right distribution：a &lt;*&gt; (b &lt;|&gt; c) = (a &lt;*&gt; b) &lt;|&gt; (a &lt;*&gt; c) （大部分不满足，但Maybe满足） Left catch：(pure a) &lt;|&gt; x = pure a （Maybe、IO、parsers满足，但[]不满足） 常用函数 asum :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a，相当于foldr (&lt;|&gt;) empty： 1234ghci&gt; asum [Nothing, Just 5, Just 3]Just 5ghci&gt; asum [[2],[3],[4,5]][2,3,4,5] guard :: (Alternative f) =&gt; Bool -&gt; f ()： 12guard True = pure ()guard False = empty MonadPlus123456class (Alternative m, Monad m) =&gt; MonadPlus m where mzero :: m a mzero = empty mplus :: m a -&gt; m a -&gt; m a mplus = (&lt;|&gt;) MonadPlus实例[]、Maybe都是MonadPlus的实例，mzero和mplus都由Alternative实现 MonadPlus Laws Monoid laws Left zero：mzero &gt;&gt;= f = mzero Right zero：m &gt;&gt; mzero = mzero 常用函数 msum = asum mfilter： 123mfilter p ma = do a &lt;- ma if p a then return a else mzero ArrowPlusArrowZero和ArrowPlus分别为Arrow设置了Monoid中的单位元素和二元运算符，使之成为了一个幺半群： 12345class Arrow arr =&gt; ArrowZero arr where zeroArrow :: b `arr` cclass ArrowZero arr =&gt; ArrowPlus arr where (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c) Reference Typeclassopedia - Haskell wiki Haskell语言学习笔记（8）Monoid - zwvista Haskell语言学习笔记（16）Alternative - zwvista 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/d4bb2633.html"},{"title":"「Learn Haskell」#5 函子、应用函子与单子","text":"&lt; #4 #6 &gt; Functors函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用fmap :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子 Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子 函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的f a和f b也是因为f是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中 Functor的定义是: 1234class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b (&lt;$) :: a -&gt; f a -&gt; f b (&lt;$) = fmap . const 可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如： 12ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot; 但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名： const :: a -> b -> a 即接收两个参数，但始终只返回第一个参数 Functor实例[]列表[]是一个函子，它通过map函数来实现fmap的功能： 12instance Functor [] where fmap = map map :: (a -> b) -> [a] -> [b] map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表 MaybeMaybe也具有kind * -&gt; *，它也是一个函子： 12345678instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x)ghci&gt; fmap (*2) NothingNothingghci&gt; fmap (*2) (Just 2)Just 4 Either aEither的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子： 12345678instance Functor (Either a) where fmap f (Left x) = Left x fmap f (Right x) = Right (f x)ghci&gt; fmap (*2) (Left 4)Left 4ghci&gt; fmap (*2) (Right 4)Right 8 因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在） IOIO也是一个函子，使用fmap对IO中内容应用函数： 12345678instance Functor IO where fmap f action = do result &lt;- action return (f result)ghci&gt; fmap (&quot;input: &quot;++) getLinetest&quot;input: test&quot; (,) a(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用： 12instance Functor ((,) a) where fmap f (x, y) = (x, f y) 只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用： 12345instance Functor ((,,) a b) where fmap f (a, b, c) = (a, b, f c)instance Functor ((,,,) a b c) where fmap f (a, b, c, d) = (a, b, c, f d) (-&gt;) r-&gt;也是一个类型构造器，它的kind： (->) :: * -> * -> * 一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中r是输入的类型） 规定的fmap的类型签名是： fmap :: (a -> b) -> f a -> f b 其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到： fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b) 把其中的(-&gt;)换成中缀可以得到： fmap :: (a -> b) -> (r -> a) -> (r -> b) 传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是： 12instance Functor ((-&gt;) r) where fmap f g = (\\x -&gt; f (g x)) 所以(-&gt;) r的fmap其实就是函数复合(.)： 12instance Functor ((-&gt;) r) where fmap = (.) 12345678ghci&gt; :t fmap (*3) (+100) fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a ghci&gt; fmap (*3) (+100) 1 303 ghci&gt; (*3) `fmap` (+100) $ 1 303 ghci&gt; (*3) . (+100) $ 1 303 Functor Laws所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律： fmap id = id（其中id为函数(\\x -&gt; x)）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： 1234ghci&gt; fmap id [1, 2, 3][1,2,3]ghci&gt; fmap id (Just 2)Just 2 fmap (f . g) = fmap f . fmap g：即函子的fmap支持结合律 fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中a为一个函子 fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) 12ghci&gt; fmap ((*3) . (+100)) (Just 1)Just 303 满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可 Intuition对于函子和fmap，有两种理解方法 函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器 函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作fmap :: (a -> b) -> (f a -> f b) 接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数 fmap g :: f a -> f b 使普通的函数g可以在计算上下文f中使用，这种转换也被称为提升（lift） 常用函数&lt;$&gt;&lt;$&gt;函数是fmap的中缀形式（它看着类似$，f $ 3将f应用在单个值3上，而f &lt;$&gt; [1, 2, 3]将f应用在一个函子上，也就是应用在一个函子内部的所有值上）： 1234ghci&gt; fmap (*2) (Just 2)4ghci&gt; (*2) &lt;$&gt; Just 24 $&gt;$&gt;函数包含在Data.Functor模块中 ($>) :: Functor f => f a -> b -> f b Functor定义时要求了&lt;$函数，将函子内部的元素全部替换为指定的某个值，而$&gt;正好将&lt;$函数的两个参数反了过来，相当于flip (&lt;$)： 1234ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot;ghci&gt; [1, 2, 3] $&gt; 'a'&quot;aaa&quot; voidvoid函数也包含在Data.Functor模块中 void :: Functor f => f a -> f () void函数把一个函子内部的全部元素都变成空（()），void x相当于() &lt;$ x： 1234ghci&gt; void [1, 2, 3][(), (), ()]ghci&gt; void (Just 2)Just () Applicative Functor应用函子（Applicative Functor）是函子的升级版，它包含在Control.Applicative模块中。 fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义： 123class Functor f =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b 应用函子要求实现两个函数： pure :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just &lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。 Applicative Functor实例MaybeMaybe是一个应用函子： 1234instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something pure函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x &lt;*&gt;函数：将装有函数的函子中的函数应用另一个函子中 第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing 第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可 实际应用的例子： 12345678ghci&gt; Just (+3) &lt;*&gt; Just 9Just 12ghci&gt; pure (+3) &lt;*&gt; Just 9Just 12ghci&gt; (+3) &lt;$&gt; Just 9Just 12ghci&gt; Nothing &lt;*&gt; Just 9Nothing 第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12 第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了 而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如： 1234ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9Just 12ghci&gt; pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5Just 12 &lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12: 12345 pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5= (pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3) &lt;*&gt; Just 4 &lt;*&gt; Just 5= (Just (\\y z -&gt; 3 + y + z) &lt;*&gt; Just 4) &lt;*&gt; Just 5= Just (\\z -&gt; 3 + 4 + z) &lt;*&gt; Just 5 = Just (+7) &lt;*&gt; Just 5= Just 12 所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。 而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是： f x y ... []列表也是一个应用函子： 123instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs] pure函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x] &lt;*&gt;函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表 使用例子： 1234ghci&gt; [(+3), (*2)] &lt;*&gt; [1, 2][4,5,2,4]ghci&gt; [(+), (*)] &lt;*&gt; [1, 2] &lt;*&gt; [3, 4] [4, 5, 5, 6, 3, 4, 6, 8] IO123456instance Applicative IO where pure = return a &lt;*&gt; b = do f &lt;- a x &lt;- b return (f x) 也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子 1234ghci&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLineLine1Line2&quot;Line1Line2&quot; (-&gt;) r(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名： :: f (a -> b) -> f a -> f b 其中f为(-&gt;) r，将其代入并替换为中缀： :: (r -> a -> b) -> (r -> a) -> (r -> b) 可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b) 那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是： \\x -> f x (g x) 于是： 123instance Applicative ((-&gt;) r) where pure x = (\\_ -&gt; x) f &lt;*&gt; g = \\x -&gt; f x (g x) 将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x 应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子： 12ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5508 执行这句时发生了什么？： 12345678 (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5= ((+) &lt;$&gt; (+3)) &lt;*&gt; (*100) $ 5= ((+) . (+3)) &lt;*&gt; (*100) $ 5 = (\\a -&gt; (+) ((+3) a)) &lt;*&gt; (*100) $ 5= (\\a b -&gt; (a + 3 + b)) &lt;*&gt; (*100) $ 5= (\\x -&gt; x + 3 + ((*100) x)) $ 5= (\\x -&gt; x + 3 + x * 100) $ 5= 5 + 3 + 5 * 100 = 508= (5 + 3) + (5 * 100) 所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+) 同样： 12ghci&gt; (\\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5 [8.0,10.0,2.5] 先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\\x y z -&gt; [x,y,z])得到了最终的结果 12 f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i= (\\x -&gt; f (g x) (h x) (i x)) ZipList普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在Control.Applicative模块中 123instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith ($) fs xs) 但是ZipList并不是Show的实例，所以不能直接显示出来，要使用getZipList来获取它内部的列表： 1234ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..] [101,102,103]ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList &quot;dog&quot; &lt;*&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot; [('d','c','r'),('o','a','a'),('g','t','t')] Applicative Functor Laws应用函子一般有四个定律，都是保证pure的正确性的： Identity law：pure id &lt;*&gt; v = v Homomorphism：pure f &lt;*&gt; pure x = pure (f x) Interchange：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u Composition：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w Intuition理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：$$[[\\ \\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ \\ ]]$$ 其中$x_i$的类型是$f\\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是： $$t_1\\to t_2\\to\\cdots\\to t_n\\to t$$ 所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\\ x_1$结果的类型是： $$f\\ \\ (t_2\\to t_3\\to\\cdots\\to t_n\\to t)$$ 但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ ]]$，只需要： g x1 x2 ... xn 而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算： g x1 pure x2 ... xn 常用函数liftA &amp; liftA2 &amp; liftA3liftA :: Applicative f => (a -> b) -> f a -> f b liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d 不难推测liftA就是fmap，liftA2 f x1 x2相当于f &lt;$&gt; x1 &lt;*&gt; x2，liftA3 f x1 x2 x3相当于f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3 &lt;* &amp; *&gt;类型类似函子的&lt;$和$&gt;： (&lt;*) :: Applicative f => f a -> f b -> f a (*>) :: Applicative f => f a -> f b -> f b &lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来 12345678910111213141516ghci&gt; Just 3 &lt;* Just 4Just 3ghci&gt; Just 3 *&gt; Just 4Just 4ghci&gt; Nothing &lt;* Just 3Nothingghci&gt; Nothing *&gt; Just 3Nothingghci&gt; [1, 2, 3] &lt;* [3, 4][1,1,2,2,3,3]ghci&gt; [1, 2, 3] *&gt; [3, 4][3,4,3,4,3,4]ghci&gt; [] &lt;* [1, 2, 3][]ghci&gt; [] *&gt; [1, 2, 3][] &lt;**&gt;(**) :: Applicative f => f a -> f (a -> b) -> f b 接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用： 123456ghci&gt; [(+1), (+2), (+3)] &lt;*&gt; [1, 2][2,3,3,4,4,5]ghci&gt; [1, 2] &lt;**&gt; [(+1), (+2), (+3)][2,3,4,3,4,5]ghci&gt; flip(&lt;*&gt;) [1, 2] [(+1), (+2), (+3)][2,3,3,4,4,5] when &amp; unlesswhen :: Applicative f => Bool -> f () -> f () 传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过） unless则与when相反，测试为True返回pure () sequenceAsequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) 应用在列表上时，它的类型相当于： [f a] -> f [a] 所以在列表上它的使用方法： 12345678910ghci&gt; sequenceA [Just 3, Just 2, Just 1] Just [3,2,1] ghci&gt; sequenceA [Just 3, Nothing, Just 1] Nothing ghci&gt; sequenceA [(+3),(+2),(+1)] 3 [6,5,4] ghci&gt; sequenceA [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]] ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]] [] 它在对同一个参数应用不同函数时很有用： 1234ghci&gt; map (\\f -&gt; f 7) [(&gt;4), (&lt;10), odd] [True,True,True] ghci&gt; sequenceA [(&gt;4), (&lt;10), odd] 7 [True,True,True] Monad单子（Monad）是对Applicative Functor的扩展（但是诞生比Applicative早），Functor的&lt;$&gt;函数实现了将普通函数应用在上下文值上，Applicative的&lt;*&gt;函数将上下文中函数应用在上下文值上。而Monad提供了一个函数&gt;&gt;=（bind），将一个接收普通值返回上下文值的函数应用在上下文值上： 123456class Applicative m =&gt; Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b return :: a -&gt; m a m &gt;&gt; n = m &gt;&gt;= \\_ -&gt; n return = pure return函数：和pure一样，只是有另一个名字 &gt;&gt;函数：提供了默认的实现方法，它的作用和Applicative的*&gt;函数一样 &gt;&gt;=函数（bind）：比Applicative升级的函数，第一个参数是一个单子，第二个参数是一个接收值返回单子的函数，将这个函数应用在第一个参数单子中的值上，并返回得到的新单子 Monad实例MaybeMaybe是一个单子实例，Applicative已经为它实现了return，因此只需要&gt;&gt;=函数： 123instance Monad Maybe where (Just x) &gt;&gt;= f = f x Nothing &gt;&gt;= _ = Nothing 根据定义就很容易实现Maybe的&gt;&gt;=函数了，而且也很好理解 12345678ghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1)Just 2ghci&gt; Just 1 &gt;&gt;= \\x -&gt; return (x + 1)Just 2ghci&gt; Nothing &gt;&gt;= \\x -&gt; Just (x + 1)Nothingghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1) &gt;&gt; Nothing &gt;&gt;= \\y -&gt; Just (y + 1)Nothing 最后一个例子中出现了&gt;&gt; Nothing，这时Nothing前的部分全都相当于没用，因为&gt;&gt;操作符的左右两边只要有一个出现Nothing，那整体就会是Nothing。这个特性可以用于在中途随时判断失误，只要有一处失误，结果就会是Nothing []列表也是一个单子： 12instance Monad [] where xs &gt;&gt;= f = concat (map f xs) 将这个函数应用在xs的每个值上，将返回的所有列表平铺成一个列表： 1234ghci&gt; [3,4,5] &gt;&gt;= \\x -&gt; [x,-x] [3,-3,4,-4,5,-5] ghci&gt; [1,2] &gt;&gt;= \\n -&gt; ['a','b'] &gt;&gt;= \\ch -&gt; return (n,ch) [(1,'a'),(1,'b'),(2,'a'),(2,'b')] IOIO也是一个单子，但是实现方法比较深奥（逃 (-&gt;) r(-&gt;) r也是一个单子，和Functor、Applicative一样，先分析它的&gt;&gt;=类型签名： (>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b) 也可以看出来，它接收两个函数f :: r -&gt; a、g :: a -&gt; r -&gt; b，然后返回一个新的函数h :: r -&gt; b 那么函数h接收一个类型为r的参数，返回一个类型为b的值。所以先对输入应用f得到类型为a的中间值，然后再将这个值和输入参数一起传入函数g得到结果。所以函数h的定义应该是： \\x -> g (f x) x 12instance Monad ((-&gt;) r) where f &gt;&gt;= g = \\x -&gt; g (f x) x 1234ghci&gt; (+3) &gt;&gt;= (+) $ 15ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; id $ 15 do-notationHaskell的do语句为链式的&gt;&gt;=应用提供了类似命令式（imperative style）的语法糖。比如a &gt;&gt;= \\x -&gt; b &gt;&gt; c &gt;&gt;= \\y -&gt; d： 1234a &gt;&gt;= \\x -&gt;b &gt;&gt;c &gt;&gt;= \\y -&gt;d 其中有abcd四个值，可以看出a中内容绑定到了x上，c中内容绑定到了y上。使用do语句来表示这个操作可以写成： 12345do { x &lt;- a ; b ; y &lt;- c ; d } 其中的大括号和分号可以省略不写（挤在一行时不能省略）。do语句也只是一个语法糖，它可以递归地转换成普通的Monad操作语句： do e：e do { e; ... }：e &gt;&gt; do { … } do { v &lt;- e; ... }：e &gt;&gt;= \\v -&gt; do { … } do { let ...; ... }：let … in do { … } ApplicativeDo比如如下一个do语句： 1234do x &lt;- a y &lt;- b z &lt;- c return (f x y z) 它可以转化成： a >>= \\x -> b >>= \\y -> c >>= \\z -> return (f x y z) 但是经过观察可以发现，整个语句实际上将函数f应用在了三个上下文中的值上，所以仅用Applicative的&lt;$&gt;和&lt;*&gt;完全可以实现： f a b c 而且在运行的时候Applicative的效率会比Monad高，所以Haskell会将do语句尽可能优先转换为Applicative的表示方法然后再计算 Monad Laws Left identity： return a &gt;&gt;= k = k a Right identity：m &gt;&gt;= return = m Associativity：(m &gt;&gt;= g) &gt;&gt;= h = m &gt;&gt;= (\\x -&gt; g x &gt;&gt;= h) 前两个定律很好理解： 将a注入上下文之后绑定（bind）给函数k(:: a -&gt; m a)，相当于直接将a直接传入函数k 将已经包含在上下文中的值绑定给return函数，相当于保持不变 第三个定律是结合律，把它写成更像结合律的表示方法是： (m >>= (\\x -> g x)) >>= h = m >>= (\\x -> g x >>= h) 组合运算符（&gt;=&gt;）形式Control.Monad模块中还定义了函数&gt;=&gt;（Kleisli-composition operator）： 123infixr 1 &gt;=&gt;(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)f &gt;=&gt; g = \\x -&gt; f x &gt;&gt;= g 使用&gt;=&gt;运算符可以将两个用于绑定的函数结合在一起。用它表示的Monad定律更加清晰直观： Left identity：return &gt;=&gt; f = f Right identity：f &gt;=&gt; return = f Associativity：(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h) do-notation形式Monad的这三个定律还可以使用do语句来描述： Left identity： 123do { x' &lt;- return x; f x' = do { f x } } Right identity： 123do { x &lt;- m; return x = do { m } } Associativity： 12345do { y &lt;- do { x &lt;- m; do { x &lt;- m; do { x &lt;- m; f x do { y &lt;- f x; y &lt;- f x; } = g y = g y g y } } } } IntuitionMonad也可以很自然地看成Applicative的升级版，比如Applicative的操作全部是固定的，而Monad的操作可以在中途突然改变 同时Monad也完成了Functor和Applicative无法完成的操作。比如要用fmap和实现&gt;&gt;=函数（即达成操作 m a -&gt; (a -&gt; m b) -&gt; m b），先假设 f :: a -&gt; m b，那么fmap f的类型就会是 m a -&gt; m (m b)，将m a应用在fmap f上会得到结果m (m b)，而不是m b。但是目前只可以使用pure将一个值装入上下文中（a -&gt; m a），而没有一个函数可以从上下文中提取值（m a -&gt; a）。那么就需要定义一个新的函数来实现这个操作的效果（m (m b) -&gt; m b）。因此Monad的另一个等效的定义方法是： 12345class Applicative m =&gt; Monad' m where join :: m (m a) -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x 但是\b定义&gt;&gt;=函数会更为直观方便，所以Haskell采用了用&gt;&gt;=函数定义Monad的方法 同时Haskell还提供了join函数的定义： 12join :: Monad m =&gt; m (m a) -&gt; m a join x = x &gt;&gt;= id 常用函数liftM &amp; apliftM :: Monad m => (a -> b) -> m a -> m b ap :: Monad m => m (a -> b) -> m a -> m b 所以liftM其实就是fmap、ap就是&lt;*&gt;，但是老版本的GHC定义Monad并没有Functor、Applicative的约束，所以实现了liftM、ap，并且保留了这个名字 因此一个单子也可以通过pure = return、(&lt;*&gt;) = ap直接成为应用函子的实例 sequencesequence :: Monad m => [m a] -> m [a] sequence的作用显而易见，而且在IO部分也使用到了。但是这个版本是在GHC.Base模块中定义的，还有一个更广泛的使用Traversable的定义在Data.Traversable模块中 replicateMreplicateM :: Applicative m => Int -> m a -> m [a] mapM &amp; forMmapM :: Monad m => (a -> m b) -> [a] -> m [b] forM :: Monad m => [a] -> (a -> m b) -> m [b] forM的用法在IO部分已经说过，mapM和forM都在Data.Traversable模块中有广泛版本 还有一些其他的函数：filterM、zipWithM、foldM、forever，通过名字就可以看出用法，是将原来仅使用与列表的函数提升至可以适用于所有单子 并且在函数名后加下划线，比如sequence_、mapM_，会忽略返回值（最终结果为m ()） =&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;（&gt;=&gt;操作符在上面Monad Laws部分已经给出了定义） x &gt;&gt;= f = f =&lt;&lt; x f &gt;=&gt; g = g &lt;=&lt; f MonadFailMonadFail定义在Control.Monad.Fail模块中： 12class Monad m =&gt; MonadFail m where fail :: String -&gt; m a 它只要求在Monad的基础上实现fail函数，接收一个字符串返回一个单子。这会使在do语句中产生错误时直接变为错误值（空值）使最终的返回值为错误值 MonadFail实例12345678instance MonadFail Maybe where fail _ = Nothinginstance MonadFail [] where fail _ = []instance MonadFail IO where fail = failIO Maybe和[]的fail函数都与第一个参数无关，直接返回空值（Nothing、[]）；而IO的fail函数直接使用failIO，实现方法也是深奥（接着逃 1234567exampleFail :: Maybe Char exampleFail = do (x:xs) &lt;- Just &quot;&quot; return x ghci&gt; exampleFailNothing 在这个例子的do语句中，在提取Just “”中的值时用了模式匹配，但是因为其内容为空字符串，x:xs匹配会出现错误，这时就会触发fail函数直接返回Nothing MonadFail Law fail s &gt;&gt;= m = fail s Reference Learn You a Haskell Typeclassopedia - Haskell wiki Functors, Applicatives, And Monads In Pictures Haskell学习 - functor 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/290ecb74.html"},{"title":"「Learn Haskell」#4 输入输出与文件","text":"&lt; #3 #5 &gt; Input/Output运行Haskell程序不在GHCi中运行一个Haskell程序有两种方式： 编译运行： 12$ ghc --make code$ ./code 通过runhaskell命令直接运行： 1$ runhaskell code.hs 输出文本在一个Haskell程序中输出文字需要定义一个main函数： 1main = putStrLn &quot;Hello World&quot; 其中putStrLn的类型是： putStrLn :: String -> IO () putStrLn接收一个String类型，并返回一个结果为()类型的IO动作（I/O action）。所以main函数的类型为IO ()。（IO的Kind是* -&gt; *） 除此之外，还有其他默认提供的输出文本的函数： putStr：输出文本，结尾不换行 putChar：输出单个字符，结尾不换行。接收的参数为单个Char，不是String（用单引号不是双引号） print：可以接收任何Show的成员，先用show转化为字符串然后输出。等同于putStrLn . show do block在main函数中使用多个putStrLn需要使用do语句： 123main = do putStrLn &quot;Line1&quot; putStrLn &quot;Line2&quot; 其中最后一行一定要返回IO ()类型的值 输入文本输入文字需要在do块中使用getLine： 123main = do line &lt;- getLine putStrLn line getLine的类型是： getLine :: IO String 而&lt;-操作符将getLine中的String提取了出来给到了line，使line变成了String类型的一个字符串。 而且使用输入的字符串必须要经过一次&lt;-，不能直接使用getLine作为字符串，因为getLine不是String类型，而是IO String类型。 除此之外，还可以使用getChar来获取单个字符，但仍然需要使用&lt;-操作符来提取Char 其他IO相关函数用法returnHaskell中的return和其他命令式语言中的return完全不同，它不会使函数直接结束并返回一个值。 main函数必须定义为类型为IO ()的函数，所以在main函数中使用if语句，如果不输出的话也不可以直接放下什么都不干，因为这时候main函数的类型不是IO ()。所以这时需要使用return ()来为main函数指定为IO ()类型，例如： 123456main = do line &lt;- getLine if null line then return () -- &lt;-这里 else do ... 使用&lt;-操作符也可以直接将return语句中的内容提取出来，比如a &lt;- return ‘A’，执行后a就是’A’。 whenwhen包含在Control.Monad模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会return ()。比如： 1234567import Control.Monad main = do c &lt;- getChar when (c /= ' ') $ do putChar c main 等同于： 1234567main = do c &lt;- getChar if c /= ' ' then do putChar c main else return () sequencesequence在IO中使用时可以达成[IO a] -&gt; IO [a]的效果，所以可以用作： 1[a, b, c] &lt;- sequence [getLine, getLine, getLine] mapM &amp; mapM_在IO相关的地方使用map，可以使用mapM和mapM_，其中mapM有返回值而mapM_直接扔掉了返回值： 123456789ghci&gt; mapM print [1,2,3] 1 2 3 [(),(),()] ghci&gt; mapM_ print [1,2,3] 1 2 3 foreverforever函数包含在Control.Monad模块中。在main函数开头加上forever函数可以使后面的do块一直重复执行直到程序被迫终止，如： 1234import Control.Monad main = forever $ do ... forMforM函数包含在Control.Monad模块中，它的功能和mapM类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回IO a类型。比如： 123456789import Control.Monadmain = do colors &lt;- forM [1, 2, 3, 4] (\\a -&gt; do putStrLn $ &quot;Which color do you associate with the number &quot; ++ show a ++ &quot;?&quot; color &lt;- getLine return color) putStrLn &quot;The colors that you associate with 1, 2, 3 and 4 are: &quot; mapM putStrLn colors getContentsgetLine获取一整行，而getContents从标准输入中获取全部内容直到遇到EOF，并且它是lazy的，在执行了foo &lt;- getContents后，它并不会读取标准输入并且赋值到foo，而是等到需要使用foo的时候再从标准输入读取。 getContents在使用管道传入文字时很常用，可以代替forever+getLine使用，比如一个Haskell程序文件code.hs： 12345import Data.Char main = do contents &lt;- getContents putStr (map toUpper contents) 使用ghc –make code编译后，通过管道传入文字： 1cat text.txt | ./code 会将text.txt中的所有字母转为大写并输出 interact上述功能还可以转化为一个String -&gt; String的函数： 1upperStrings = unlines . map (map toUpper) . lines 而在main中使用这个函数就需要： 123main = do contents &lt;- getContents putStr (upperStrings contents) 但是String -&gt; String类型的函数在输入输出中的使用太常见了，所以可以使用interact函数来简化。interact的类型是： interact :: (String -> String) -> IO () 可以看出它接收一个String -&gt; String的函数，并返回一个IO ()类型，所以可以直接用在main上。 于是整个转换为大写的程序就可以简化为： 1main = interact $ unlines . map (map toUpper) . lines 文件和流以下与文件和流相关的函数都包含在System.IO模块中 openFileopenFile函数可以用来打开一个文件，它的类型是： openFile :: FilePath -> IOMode -> IO Handle 其中FilePath是String的type synonyms，用一个字符串来表示需要打开的文件的路径 IOMode的定义是： 1data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode 所以它一共只有四个值，用来表示进行IO操作的模式 openFile返回一个IO Handle类型的值，将其用&lt;-操作符提取后会出现一个Handle的值。但不能从Handle中直接使用文字，还需要使用一系列函数： hGetContents :: Handle -&gt; IO String ，从Handle中读取全部内容，返回一个IO String hGetChar :: Handle -&gt; IO Char ，从Handle中读取一个字符 hGetLine :: Handle -&gt; IO String ，从Handle中读取一行，返回一个IO String hPutStr :: Handle -&gt; String -&gt; IO () ，向Handle中输出字符串 hPutStrLn :: Handle -&gt; String -&gt; IO () ，同上 在使用openFile进行文件操作后，需要使用hClose手动关闭Handle。hClose :: Handle -&gt; IO ()，接收一个Handle并返回IO ()，可以直接放在main函数末尾 所以使用openFile读取一个文件中的全部内容并输出的全部代码是： 1234567import System.IOmain = do handle &lt;- openFile &quot;text.txt&quot; ReadMode contents &lt;- hGetContents handle putStrLn contents hClose handle withFilewithFile类似Python中的with open，它在读取文件使用之后不需要手动close文件。它的类型是： withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a 可以看出，它接收三个参数： FilePath：一个表示文件路径的String IOMode：打开文件的模式 (Handle -&gt; IO a)：一个函数，表示对读取文件后的Handle索要进行的操作，需要返回一个I/O action；而这个返回值也将作为withFile的返回值 现在使用withFile来改写上述代码： 12345import System.IOmain = withFile &quot;text.txt&quot; ReadMode (\\handle -&gt; do contents &lt;- hGetContents handle putStrLn contents) withFile的功能相当于以下函数： 123456withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a withFile' path mode f = do handle &lt;- openFile path mode result &lt;- f handle hClose handle return result readFilereadFile可以更加简化读取文件内容的操作，它的类型： readFile :: FilePath -> IO String 它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的I/O action： 12345import System.IOmain = do contents &lt;- readFile &quot;text.txt&quot; putStrLn contents writeFilewriteFile简化了写入文件的操作，它的类型： writeFile :: FilePath -> String -> IO () 传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个IO () appendFileappendFile类似writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾 buffer文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。 也可以通过hSetBuffering函数来手动设置缓冲区大小，这个函数的类型： hSetBuffering :: Handle -> BufferMode -> IO () 它接收一个handle，和一个BufferMode，并返回IO ()。其中BufferMode有以下几种： NoBuffering：没有缓冲区，一次读入一个字符 LineBuffering：缓冲区大小是一行，即每次读入一行内容 BlockBuffering (Maybe Int)：缓冲区大小是一块，块的大小由Maybe Int指定： BlockBuffering (Nothing)：使用系统默认的块大小 BlockBuffering (Just 2048)：一块的大小是2048字节，即每次读入2048bytes的内容 缓冲区的刷新是自动的，也可以通过hFlush来手动刷新 hFlush :: Handle -> IO () 传入一个handle，返回IO ()，即刷新对应handle的缓冲区 openTempFileopenTempFile可以新建一个临时文件： openTempFile :: FilePath -> String -> IO (FilePath, Handle) FilePath指临时文件要创建的位置路径，String指临时文件名字的前缀，返回一个I/O action，其内容第一个FilePath是创建得到的临时文件的路径，Handle是临时文件的handle 例如： 123456import System.IOmain = do (tempFile, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot; ... hClose tempHandle &quot;.&quot;指临时文件要在当前目录创建，&quot;temp&quot;指临时文件名字以temp开头。最终得到的tempFile就是./temp…….，temp后为随机数字，如./temp43620-0 路径操作相关函数都包含在System.Directory模块中，全部内容见System.Directory getCurrentDirectorygetCurrentDirectory :: IO FilePath 直接返回一个I/O action，其内容是一个字符串表示当前路径的绝对路径 removeFileremoveFile :: FilePath -> IO () 输入一个文件路径，并删除掉它 renameFilerenameFile :: FilePath -> FilePath -> IO () 输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名 doesFileExistdoesFileExist :: FilePath -> IO Bool 检查文件是否存在，返回一个包含布尔值的I/O action Command line argumentsSystem.Environment模块中提供了两个函数可以用来处理传入命令行的参数 getArgsgetArgs :: IO [String] 不需要输入参数，直接返回一个I/O action，内容为传入命令行的参数（一个由String组成的列表）。相当于C语言中的argv[1:] getProgNamegetProgName :: IO String 返回I/O action，内容为程序的名字，相当于C语言中的argv[0] Randomness和随机数有关的函数都包含在System.Random模块中。GHCi启动时可能不会包含System.Random的配置，导致无法找到模块。需要通过stack打开: 1stack ghci --package random Haskell要求同样的程序需要运行出同样的结果，除了用到了I/O action，所有会造成不同结果的函数都要交给I/O action来完成 那要使随机数脱离IO存在，就要用到随机生成器（random generator） System.Random模块提供了几个生成随机数的函数： randomrandom :: (Random a, RandomGen g) => g -> (a, g) 其中又有两个新的typeclass，Random表示可以取随机，RandomGen表示随机数生成器。random函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器 获取随机数生成器可以使用mkStdGen函数： mkStdGen :: Int -> StdGen 其中StdGen是一个RandomGen的实例 运用random生成随机数需要指定类型，不然程序无法确定a是什么类型。例如： 123456ghci&gt; random (mkStdGen 100) :: (Int, StdGen)(9216477508314497915,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Char, StdGen)('\\537310',StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Bool, StdGen)(True,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125}) 再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器： 123456threeCoins :: StdGen -&gt; (Bool, Bool, Bool) threeCoins gen = let (firstCoin, newGen) = random gen (secondCoin, newGen') = random newGen (thirdCoin, newGen'') = random newGen' in (firstCoin, secondCoin, thirdCoin) randomsrandoms :: (Random a, RandomGen g) => g -> [a] randoms接收一个RandomGen，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器 randomRrandomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g) 可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围(闭区间) randomRsrandomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a] 同上两个，生成有范围的无穷随机数列表 getStdGen如果想要让程序每次运行得到不同的随机结果，需要使用getStdGen来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个I/O action，而不是一个直接的StdGen getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen 即可以看成getStdGen :: IO StdGen，需要使用&lt;-操作符将StdGen提取出来 但是在同一个程序中，getStdGen的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数newStdGen newStdGennewStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen 执行newStdGen会进行两个操作： 更新全局随机数生成器，下次执行getStdGen会获得不同的结果 返回一个I/O action，包含一个新的StdGen（但是这个生成器和全局生成器也不同） Exceptions程序在运行失败时会抛出异常，可以通过Control.Exception模块中的catch函数来捕获异常： catch :: Exception e => IO a -> (e -> IO a) -> IO a 第一个参数是要进行的操作，以IO a为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如： 12345678910import Control.Exceptionmain = main' `catch` handlermain' :: IO ()main' = do ...handler :: Exception e =&gt; e -&gt; IO ()handler e = putStrLn &quot;...&quot; 也可以利用守卫（guard）语法和System.IO.Error中的函数来判断IO异常的类型来进行不同操作： 123456789101112131415import System.Environmentimport System.IO.Errorimport Control.Exception main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) &lt;- getArgs contents &lt;- readFile fileName putStrLn $ &quot;The file has &quot; ++ show (length (lines contents)) ++ &quot; lines!&quot; handler :: IOError -&gt; IO () handler e | isDoesNotExistError e = putStrLn &quot;The file doesn't exist!&quot; | otherwise = ioError e 具体相关全部函数见文档：System.IO.Error、Control.Exception Reference Learn You a Haskell 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/a5bbe48a.html"},{"title":"「Learn Haskell」#3 类型与类型类","text":"&lt; #2 #4 &gt; TypesHaskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。Type的首字母全为大写，常用的有： Int：整型，有上下界范围，-2147483647～2147483648 Integer：整数，无界，但是效率比Int低 Float：单精度浮点型 Double：双精度浮点型 Bool：布尔值 Char：字符 String：字符串，等同于[Char] Ordering：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT 列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加[]。 元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。 Typeclasses类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个TypeclassTypeclass的首字母也全为大写，常见的有： Eq：可判断是否相等 Ord：可比较大小 Show：可展示成字符串 Read：可从字符串转换成特定类型 Enum：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀 Bounded: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded Integral：是整数，包括Int和Integer RealFloat： 是实浮点数，包括Float和Double RealFrac：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中） Floating：是浮点数，包括Float、Double和Complex（在Data.Complex模块中） Real：是实数，包括Integral和RealFrac的成员 Fractional：是分数，包括RealFrac和Floating的成员 Num：是数字，包括上述所有数字相关的类型 Type variables如果查看一个函数的类型，比如head，那么将会返回以下类型： head :: [a] -> a 其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。 在函数的类型表达式其实可以看作$\\lambda$表达式，它适用于$\\alpha$变换（$\\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。 在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如(==)函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么(==)的类型就是： (==) :: (Eq a) => a -> a -> Bool 其中=&gt;前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以(==)函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。 定义新Type定义一个新的Type需要使用data关键字，比如定义Bool需要使用： data Bool = False | True 其中=左侧的部分定义了新类型的名称Bool，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。并且名称和值构造器的首字母都需要大写。 另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如： 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float 它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。如果查看Circle的类型，将返回： Circle :: Float -> Float -> Float -> Shape 如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上deriving (Show): 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) 类型的名称和值构造器名称也可以相同，比如： 1data Point = Point Float Float deriving (Show) 导出Type在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件Shapes.hs中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写： 123456module Shapes( Shape(..), Point(..), functionA, functionB) where 其中的Shape(..)导出了Shape类型和它所有的值构造器，..代表了它的所有值构造器。因此，Shape(..)相当于Shape (Circle, Rectangle)。 如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将Shape(..)替换为Shape，这样就只导出了Shape类型，而不导出其值构造器。 Record Syntax如果想要方便地取出类型实例中的参数，可以使用Record语法，如： 123data Point = Point { xcoord :: Float , ycoord :: Float } deriving (Show) 在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值： 12345ghci&gt; let point = Point 1.0 2.0ghci&gt; xcoord point1.0ghci&gt; ycoord point2.0 同时也可以通过下面方法来创建这个point： 1point = Point {ycoord=2.0, xcoord=1.0} Type parameters值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义： data Maybe a = Nothing | Just a 它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型： 1234Nothing :: Maybe aJust 1 :: Num a =&gt; Maybe aJust 'a' :: Maybe CharJust &quot;abc&quot; :: Maybe [Char] 可以用这种方法改写Point： 123data Point x y = Point { xcoord :: x , ycoord :: y } deriving (Show) 但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。 而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如： 12data (Ord k) =&gt; Map k v = ... toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] EitherEither是一个类型构造器，它有两个值构造器，定义是： 1data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) 如果使用了Left，那它的a的类型就是具体的；如果使用了Right，那它的b的类型就是具体的： 12345678ghci&gt; Right 20 Right 20 ghci&gt; Left &quot;w00t&quot; Left &quot;w00t&quot; ghci&gt; :t Right 'a' Right 'a' :: Either a Char ghci&gt; :t Left True Left True :: Either Bool b Either可以看作Maybe的补充，比如Maybe在使用时，出现异常可以返回Nothing，但只是一个Nothing，不包含任何信息；但Either包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法： 12345678safeDiv :: Int -&gt; Int -&gt; Maybe IntsafeDiv _ 0 = NothingsafeDiv x y = Just (x `div` y)ghci&gt; safeDiv 4 2Just 2ghci&gt; safeDiv 1 0Nothing 而使用Either： 12345678safeDiv :: Int -&gt; Int -&gt; Either String IntsafeDiv _ 0 = Left &quot;Divided by zero&quot;safeDiv x y = Right (x `div` y)ghci&gt; safeDiv 4 2Right 2ghci&gt; safeDiv 1 0Left &quot;Divided by zero&quot; Derived instances想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如： 12data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) 这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右） Type synonyms为了阅读方便，书写简便，可以使用type关键字为已有类型创建别名（synonyms）。比如String的定义： type String = [Char] 在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。同时，类型别名也可以接收类型参数 newtype keyword除了data、type关键字之外，还可以用newtype关键字来定义一个新的类型，比如Control.Applicative模块中的ZipList： 1newtype ZipList a = { getZipList :: [a] } 不同于type，它不是别名，可以使用record语法来直接定义取出值的函数 不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰 Recursive data structures一个类型也可以递归定义，比如一颗二叉树： 1data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) 定义新Typeclass定义一个新的Typeclass需要使用class关键字，例如定义Eq类型类： 12345class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) 其中a是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。 包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们（(==) | (/=)）成为这个类型类的最小完整定义（minimal complete definition） 查看一个类型类的成员需要实现的函数可以在GHCi中使用:info： ghci> :info Eq 手动创建实例使一个类型成为一个类型类的实例可以直接使用deriving来自动完成，也可以通过使用instance关键字来手动完成。比如使Point成为Show的实例： 123456instance Show Point where show (Point x y) = &quot;(&quot; ++ show x ++ &quot;, &quot; ++ show y ++ &quot;)&quot;-- in ghcighci&gt; Point 1.0 2.0(1.0, 2.0) 这样就可以自定义显示的内容，否则使用deriving的话只会直接将其转化为字符串。 同时也要注意类型和类型构造器的区别，传入给instance的第二个参数应该为类型而不是类型构造器，比如Maybe： 123456789101112instance Eq Maybe where ... -- 错误用法，因为Maybe是类型构造器而不是类型instance Eq (Maybe m) where ...-- 错误用法，因为m不一定是Eq的成员instance (Eq m) =&gt; Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False Functor TypeclassFunctor也是一种类型类，它只规定了一个函数： 12class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 其中f是一个类型构造器，而不是一个具体类型 Kinds一个值的类型叫做类型（Type），而一个类型的类型叫做Kind。可以通过GHCi中:k来查看Kind： 12345678ghci&gt; :k IntInt :: *ghci&gt; :k MaybeMaybe :: * -&gt; *ghci&gt; :k Maybe IntMaybe Int :: *ghci&gt; :k EitherEither :: * -&gt; * -&gt; * 其中的星号*代表了一个具体类型（concrete type）。Int本身就是一个具体类型，所以Int的Kind是*。而Maybe是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以Maybe的Kind是* -&gt; *。如果给Maybe传入了一个Int，那么得到的Maybe Int就是一个具体的类型，它的Kind就是*。Either也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以Either的Kind是* -&gt; * -&gt; *。 Reference Learn You a Haskell 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/369b7e08.html"},{"title":"「Learn Haskell」#2 高阶函数与模块","text":"&lt; #1 #3 &gt; Higher Order FunctionsCurryingHaskell中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如max函数，它的类型签名是： max :: Ord a => a -> a -> a 可以看成a -&gt; (a -&gt; a)，即接收一个参数，返回一个类型为a -&gt; a的函数。比如max 1的类型签名是： max 1 :: (Ord a, Num a) => a -> a 因此max 1 2，也就等同于(max 1) 2，即将函数max 1应用在数字2上 同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions） 一些高阶函数zipWithzipWith :: (a -> b -> c) -> [a] -> [b] -> [c] 第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例： 1234ghci&gt; zipWith (+) [4,2,5,6] [2,6,2,3] [6,8,7,9] ghci&gt; zipWith max [6,3,2,1] [7,3,1,5] [7,3,2,5] flipflip :: (a -> b -> c) -> b -> a -> c flip函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来： 1234ghci&gt; zip [1,2,3,4,5] &quot;hello&quot;[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]ghci&gt; flip zip [1,2,3,4,5] &quot;hello&quot; [('h',1),('e',2),('l',3),('l',4),('o',5)] mapmap :: (a -> b) -> [a] -> [b] map函数接收一个函数f和一个列表a，将函数f应用在列表a的每个元素中，并返回得到的所有结果组成的列表b： 12ghci&gt; map (+3) [1,5,3,1,6] [4,8,6,4,9] filterfilter :: (a -> Bool) -> [a] -> [a] filter函数接收一个函数f和一个列表a，将列表a中的每个元素传入函数f中，如果结果为True就保留，结果为False就抛弃，返回所有保留的元素组成的新列表： 12ghci&gt; filter even [1..10] [2,4,6,8,10] takeWhiletakeWhile :: (a -> Bool) -> [a] -> [a] takeWhile函数接收一个函数f和一个列表a，将列表a中从左向右每个元素传入函数f，直到结果为False停止，返回停止前传入的所有元素组成的新列表： 12ghci&gt; takeWhile (/=' ') &quot;word1 word2&quot;&quot;word1&quot; Function application函数应用可以使用$，$是一个函数，它的类型是： ($) :: (a -> b) -> a -> b 它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。 1234567f $ g x-- 等价于f (g x)-----f g x-- 等价于(f g) x Function Composition函数复合可以使用.，.也是一个函数，它的类型是： (.) :: (b -> c) -> (a -> b) -> a -> c 定义是： f . g = \\x -> f (g x) 但是函数复合的优先级要比函数执行低，比如： 1sum . replicate 5 . max 6.7 8.9 会先执行max 6.7 8.9并返回8.9，然后将sum、replicate 5、8.9复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用$来规定先复合再执行： 1sum . replicate 5 . max 6.7 $ 8.9 lambdaHaskell语言中的lambda表达式是用\\来表示的（因为看着像$\\mathtt{\\lambda}$？）具体语法是 1\\para1 para2 ... -&gt; return “-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。 fold和scanfold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表传入的二元函数f :: a -&gt; b -&gt; b将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数） foldl左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如： 1foldl f a xs 它的结果计算过程为 1234&gt; foldl f a [x1, x2, x3][1.] a = f a x1[2.] a = f a x2 = f (f a x1) x2[3.] a = f a x3 = f (f (f a x1) x2) x3 可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表 foldr右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如： 1foldr f a xs 它的结果计算过程为 1234&gt; foldr f a [x1, x2, x3][1.] a = f x3 a[2.] a = f x2 a = f x2 (f x3 a)[3.] a = f x1 a = f x1 (f x2 (f x3 a)) 从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]因此可以使用递归来写一个和foldr效果一样的函数: 123foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' _ x [] = xfoldr' f a (x:xs) = f x (foldr' f a xs) 也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表 例如： 12345ghci&gt; foldr (||) False (repeat True)True -- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了ghci&gt; foldl (||) False (repeat True)-- 这里什么都不会发生，直到电脑内存被爆掉-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表 scanl和scanrscan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表scanl则向右延伸这个列表，scanr则向左延伸这个列表但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能 12345&gt; scanr f a [x1, x2, x3][1.] 最右侧元素(-1 in python) : a[2.] 右侧第二个元素(-2) : f x3 a[3.] 右侧第三个元素(-3) : f x2 (f x3 a)[4.] 右侧第四个元素(-4) : f x1 (f x2 (f x3 a)) 可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素因此可以用递归来写一个和scanr效果一样的函数： 12345scanr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanr' _ x [] = [x]-- scanr' f a (x:xs) = f x (foldr f a xs) : scanr' f a xsscanr' f a (x:xs) = f x q : qs where qs@(q:_) = scanr' f a xs scanl也是同理： 123scanl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanl' _ x [] = [x]scanl' f a (x:xs) = a : scanl' f (f a x) xs 也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果： 1234ghci&gt; take 10 (scanl (+) 0 [1..])[0,1,3,6,10,15,21,28,36,45]ghci&gt; take 10 (scanr (+) 0 [1..])[*** Exception: stack overflow 使用foldr编写foldlpdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr： 1foldl' f z xs = foldr (\\x g y -&gt; g (f y x)) id xs z 它利用 foldr (\\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。 先来看一下foldr的类型： 12foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b 但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。 所以这里foldr的类型可以写成： (a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b) 对应于用法 foldr (\\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）而xs对应于[a]；id对应于(b -&gt; b)所以 (\\x g y -&gt; g (f y x)) 要对应于： (a -> (b -> b) -> (b -> b)) 因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。 再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为： b -> (b -> b) 现在根据foldr的定义： foldr f a (x:xs) = f x (foldr f a xs) 带入计算一下： xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn] 定义中的f即为(\\x g y -&gt; g (f y x))，a即为id 12 foldr (\\x g y -&gt; g (f y x)) id xs z= (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z 写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开： 12 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1) 不难发现，原式 (foldr (…) id xs) z 等价于： (foldr (...) id xs') (f z x1) 跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’因此下一步： 12345 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= (foldr (...) id xs''') (f (f (f z x1) x2) x3)= ... 可以发现，已经有了规律。那么最终停止时是什么样呢？ 最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id 所以最后的结果：(id的定义：id x = x) 1234567 ...= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= ...= (foldr (...) id []) (f (.. (f z x1) ..) xn)= id (f (.. (f z x1) ..) xn)= f (.. (f z x1) ..) xn 那么最后这个结果就很熟悉了，它就是 foldl f z xs。所以我们推导出了这个用foldr表示foldl的写法是正确的。 ModulesHaskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用:m + ...，比如加载Data.List模块： Prelude> :m + Data.List 而在hs文件中引入模块，需要使用import语句，下面和python的对比可以便于理解： 1234567891011121314import Data.List-- from Data.List import *import Data.List (nub, sort)-- from Data.List import nub, sortimport Data.List hiding (nub)-- 从Data.List中引入所有，但不引入nub函数import qualified Data.List-- import Data.Listimport qualified Data.List as Li-- import Data.List as Li 编写Modules模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫ModuleA.hs，那它的头部需要写： 123456module ModuleA( functionA, functionB, functionC) where 而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。 Reference Learn You a Haskell Writing foldl using foldr - StackOverflow Haskell：用foldr定义foldl 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/53e482b7.html"},{"title":"「Learn Haskell」#1 基础语法与函数","text":"&lt; #0 #2 &gt; 基础运算 + - * / ()：加减乘除 div：整除 mod：取模 True False：布尔值 || &amp;&amp; not：或且非 ==：条件判断，相等 /=：条件判断，不等 函数调用Haskell中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开： 12ghci&gt; max 1 22 前缀（prefix）函数与中缀（infix）函数转换： 对前缀函数加``使其变成中缀函数 对中缀函数加()使其变成前缀函数 12345678ghci&gt; 4 `div` 22ghci&gt; 1 `max` 22ghci&gt; (+) 1 23ghci&gt; (||) True FalseTrue List列表是Haskell中很常见的数据类型，和Python中不同，Haskell中的列表中的所有元素必须是同一个类型。 以下是列表常用的函数： (++) :: [a] -&gt; [a] -&gt; [a]：合并两个列表 (:) :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。[1, 2, 3]是1:2:3:[]的语法糖 (!!) :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。a !! 1相当于Python中的a[1] head :: [a] -&gt; a：返回列表的第一个元素 tail :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]） last :: [a] -&gt; a：返回列表中的最后一个元素 init :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表 length :: Foldable t =&gt; t a -&gt; Int：返回列表的长度 null :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空 reverse :: [a] -&gt; [a]：返回翻转后的列表 take :: Int -&gt; [a] -&gt; [a]：返回列表a的前n个元素的列表(take n a) drop :: Int -&gt; [a] -&gt; [a]：返回列表a中除去前n个元素后的列表(drop n a) maximum :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值 minimum :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值 sum :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和 product :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积 elem :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值n是否在列表a中( 123elem n a-- 或n `elem` a --用``包上可以变成中缀函数使用 Texas ranges使用..可以表示出范围并自动推导： 123456789101112ghci&gt; [1 .. 10] [1,2,3,4,5,6,7,8,9,10] ghci&gt; ['a' .. 'z'] &quot;abcdefghijklmnopqrstuvwxyz&quot; ghci&gt; ['K' .. 'Z'] &quot;KLMNOPQRSTUVWXYZ&quot; ghci&gt; [2, 4 .. 20] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [3, 6 .. 20] [3,6,9,12,15,18]ghci&gt; [5, 4 .. 1][5,4,3,2,1] 也可以用来生成无穷列表，如[1..]、[1, 3..]。同时也有函数可以生成无穷列表： cycle :: [a] -&gt; [a]：将原列表不断循环生成无穷列表 repeat :: a -&gt; [a]：将传入的值不断重复生成无穷列表 replicate :: Int -&gt; a -&gt; [a]：将值a重复n次，返回生成的列表(replicate n a) List comprehensionHaskell中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件 12345678ghci&gt; [x * 2 | x &lt;- [1 .. 10]] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [x * 2 | x &lt;- [1 .. 10], x * 2 &gt;= 12] [12,14,16,18,20]ghci&gt; [ x | x &lt;- [50 .. 100], x `mod` 7 == 3] [52,59,66,73,80,87,94] ghci&gt; [x * y | x &lt;- [2, 5, 10], y &lt;- [8, 10, 11]] [16,20,22,40,50,55,80,100,110] TupleHaskell中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数： fst :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素 snd :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素 zip :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组 Syntax in Functions函数可以直接定义： 1plus x y = x + y 这时Haskell会自动推断函数的类型为(Num a) =&gt; a -&gt; a -&gt; a。但是最好在定义函数前声明函数的类型： 12plus :: (Num a) =&gt; a -&gt; a -&gt; aplus x y = x + y Pattern matching定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如： 123factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial (n - 1) 12345678first :: (a, b, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z 其中_表示任何值，且不关心它的内容，只是用来占位 列表的(:)操作也可以用来进行模式匹配： 1234567head' :: [a] -&gt; a head' [] = error &quot;Can't call head on an empty list, dummy!&quot; head' (x:_) = xsum' :: (Num a) =&gt; [a] -&gt; a sum' [] = 0 sum' (x:xs) = x + sum' xs 但(++)操作不可以用来模式匹配 在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用xs@(q:qs)。比如[1, 2, 3]通过xs@(q:qs)匹配后，xs为[1, 2, 3]，q为1，qs为[2, 3] Guard syntax在函数的定义中，也可以使用守卫（guard）语法： 1234max' :: (Ord a) =&gt; a -&gt; a -&gt; a max' a b | a &gt; b = a | otherwise = b 先给出传入的参数变量，然后下一行缩进后加|，|后面等号前表示进行的判断，如果为True则返回这个等号后面的值；如果为False则继续判断下一行，直到otherwise Case expressions在函数的定义中，也可以使用case表达式来配合模式匹配使用： 123case expression of pattern -&gt; result pattern -&gt; result ... 例如： 1234567head' :: [a] -&gt; a head' [] = error &quot;No head for empty lists!&quot; head' (x:_) = x -- 等价于：head' :: [a] -&gt; a head' xs = case xs of [] -&gt; error &quot;No head for empty lists!&quot; (x:_) -&gt; x 12345678910describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot; [x] -&gt; &quot;a singleton list.&quot; xs -&gt; &quot;a longer list.&quot; -- 等价于：describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ what xs where what [] = &quot;empty.&quot; what [x] = &quot;a singleton list.&quot; what xs = &quot;a longer list.&quot; where声明在函数定义中要使用的局部变量，可以使用where关键字： 1234initials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot; where (f:_) = firstname (l:_) = lastname 在where中，也可以使用上面的模式匹配 letlet &lt;bindings&gt; in &lt;expression&gt;语法可以在函数的定义中使用，也可以在普通算式或列表中使用： 12345cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r ^2 in sideArea + 2 * topArea 1234ghci&gt; 4 * (let a = 9 in a + 1) + 2 42 ghci&gt; [let square x = x * x in (square 5, square 3, square 2)] [(25,9,4)] if statementHaskell中的if语句为： 1234567if ... then ...else ...-- or if ... then ... else ...-- orif ... then ...else if ... then ...else ... 其中最后一个else无论如何也不可以省去 Reference Learn You a Haskell 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp;","link":"/p/d63b5b5f.html"},{"title":"「Learn Haskell」#0 总章","text":"学习一门新语言之Haskell 前言之前一直很好奇函数式编程，觉得Haskell挺有意思的，想学学现在高考完放假了，可以有时间具体学一学了这里没有Haskell的教程，只有我在学习Haskell时写下的笔记 目录 #0&nbsp;|&nbsp;总章&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#1&nbsp;|&nbsp;基础语法与函数&emsp;&emsp;&emsp;#2&nbsp;|&nbsp;高阶函数与模块&emsp;&emsp;&emsp;#3&nbsp;|&nbsp;类型与类型类&emsp;&emsp;&emsp;&emsp;#4&nbsp;|&nbsp;输入输出与文件&emsp;&emsp;&emsp;#5&nbsp;|&nbsp;函子、应用函子与单子#6&nbsp;|&nbsp;半群与幺半群&emsp;&emsp;&emsp;&emsp;#7&nbsp;|&nbsp;一些其它类型类&emsp;&emsp;&emsp;#A&nbsp;|&nbsp;Haskell与范畴论&emsp;&nbsp;&thinsp; 基础运算 + - * / ()：加减乘除 div：整除 mod：取模 True False：布尔值 || &amp;&amp; not：或且非 ==：条件判断，相等 /=：条件判断，不等 函数调用Haskell中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开： 12ghci&gt; max 1 22 前缀（prefix）函数与中缀（infix）函数转换： 对前缀函数加``使其变成中缀函数 对中缀函数加()使其变成前缀函数 12345678ghci&gt; 4 `div` 22ghci&gt; 1 `max` 22ghci&gt; (+) 1 23ghci&gt; (||) True FalseTrue List列表是Haskell中很常见的数据类型，和Python中不同，Haskell中的列表中的所有元素必须是同一个类型。 以下是列表常用的函数： (++) :: [a] -&gt; [a] -&gt; [a]：合并两个列表 (:) :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。[1, 2, 3]是1:2:3:[]的语法糖 (!!) :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。a !! 1相当于Python中的a[1] head :: [a] -&gt; a：返回列表的第一个元素 tail :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表[]） last :: [a] -&gt; a：返回列表中的最后一个元素 init :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表 length :: Foldable t =&gt; t a -&gt; Int：返回列表的长度 null :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空 reverse :: [a] -&gt; [a]：返回翻转后的列表 take :: Int -&gt; [a] -&gt; [a]：返回列表a的前n个元素的列表(take n a) drop :: Int -&gt; [a] -&gt; [a]：返回列表a中除去前n个元素后的列表(drop n a) maximum :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值 minimum :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值 sum :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和 product :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积 elem :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值n是否在列表a中( 123elem n a-- 或n `elem` a --用``包上可以变成中缀函数使用 Texas ranges使用..可以表示出范围并自动推导： 123456789101112ghci&gt; [1 .. 10] [1,2,3,4,5,6,7,8,9,10] ghci&gt; ['a' .. 'z'] &quot;abcdefghijklmnopqrstuvwxyz&quot; ghci&gt; ['K' .. 'Z'] &quot;KLMNOPQRSTUVWXYZ&quot; ghci&gt; [2, 4 .. 20] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [3, 6 .. 20] [3,6,9,12,15,18]ghci&gt; [5, 4 .. 1][5,4,3,2,1] 也可以用来生成无穷列表，如[1..]、[1, 3..]。同时也有函数可以生成无穷列表： cycle :: [a] -&gt; [a]：将原列表不断循环生成无穷列表 repeat :: a -&gt; [a]：将传入的值不断重复生成无穷列表 replicate :: Int -&gt; a -&gt; [a]：将值a重复n次，返回生成的列表(replicate n a) List comprehensionHaskell中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件 12345678ghci&gt; [x * 2 | x &lt;- [1 .. 10]] [2,4,6,8,10,12,14,16,18,20] ghci&gt; [x * 2 | x &lt;- [1 .. 10], x * 2 &gt;= 12] [12,14,16,18,20]ghci&gt; [ x | x &lt;- [50 .. 100], x `mod` 7 == 3] [52,59,66,73,80,87,94] ghci&gt; [x * y | x &lt;- [2, 5, 10], y &lt;- [8, 10, 11]] [16,20,22,40,50,55,80,100,110] TupleHaskell中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数： fst :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素 snd :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素 zip :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组 Syntax in Functions函数可以直接定义： 1plus x y = x + y 这时Haskell会自动推断函数的类型为(Num a) =&gt; a -&gt; a -&gt; a。但是最好在定义函数前声明函数的类型： 12plus :: (Num a) =&gt; a -&gt; a -&gt; aplus x y = x + y Pattern matching定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如： 123factorial :: (Integral a) =&gt; a -&gt; a factorial 0 = 1 factorial n = n * factorial (n - 1) 12345678first :: (a, b, c) -&gt; a first (x, _, _) = x second :: (a, b, c) -&gt; b second (_, y, _) = y third :: (a, b, c) -&gt; c third (_, _, z) = z 其中_表示任何值，且不关心它的内容，只是用来占位 列表的(:)操作也可以用来进行模式匹配： 1234567head' :: [a] -&gt; a head' [] = error &quot;Can't call head on an empty list, dummy!&quot; head' (x:_) = xsum' :: (Num a) =&gt; [a] -&gt; a sum' [] = 0 sum' (x:xs) = x + sum' xs 但(++)操作不可以用来模式匹配 在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用xs@(q:qs)。比如[1, 2, 3]通过xs@(q:qs)匹配后，xs为[1, 2, 3]，q为1，qs为[2, 3] Guard syntax在函数的定义中，也可以使用守卫（guard）语法： 1234max' :: (Ord a) =&gt; a -&gt; a -&gt; a max' a b | a &gt; b = a | otherwise = b 先给出传入的参数变量，然后下一行缩进后加|，|后面等号前表示进行的判断，如果为True则返回这个等号后面的值；如果为False则继续判断下一行，直到otherwise Case expressions在函数的定义中，也可以使用case表达式来配合模式匹配使用： 123case expression of pattern -&gt; result pattern -&gt; result ... 例如： 1234567head' :: [a] -&gt; a head' [] = error &quot;No head for empty lists!&quot; head' (x:_) = x -- 等价于：head' :: [a] -&gt; a head' xs = case xs of [] -&gt; error &quot;No head for empty lists!&quot; (x:_) -&gt; x 12345678910describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ case xs of [] -&gt; &quot;empty.&quot; [x] -&gt; &quot;a singleton list.&quot; xs -&gt; &quot;a longer list.&quot; -- 等价于：describeList :: [a] -&gt; String describeList xs = &quot;The list is &quot; ++ what xs where what [] = &quot;empty.&quot; what [x] = &quot;a singleton list.&quot; what xs = &quot;a longer list.&quot; where声明在函数定义中要使用的局部变量，可以使用where关键字： 1234initials :: String -&gt; String -&gt; String initials firstname lastname = [f] ++ &quot;. &quot; ++ [l] ++ &quot;.&quot; where (f:_) = firstname (l:_) = lastname 在where中，也可以使用上面的模式匹配 letlet &lt;bindings&gt; in &lt;expression&gt;语法可以在函数的定义中使用，也可以在普通算式或列表中使用： 12345cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a cylinder r h = let sideArea = 2 * pi * r * h topArea = pi * r ^2 in sideArea + 2 * topArea 1234ghci&gt; 4 * (let a = 9 in a + 1) + 2 42 ghci&gt; [let square x = x * x in (square 5, square 3, square 2)] [(25,9,4)] if statementHaskell中的if语句为： 1234567if ... then ...else ...-- or if ... then ... else ...-- orif ... then ...else if ... then ...else ... 其中最后一个else无论如何也不可以省去 Higher Order FunctionsCurryingHaskell中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如max函数，它的类型签名是： max :: Ord a => a -> a -> a 可以看成a -&gt; (a -&gt; a)，即接收一个参数，返回一个类型为a -&gt; a的函数。比如max 1的类型签名是： max 1 :: (Ord a, Num a) => a -> a 因此max 1 2，也就等同于(max 1) 2，即将函数max 1应用在数字2上 同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions） 一些高阶函数zipWithzipWith :: (a -> b -> c) -> [a] -> [b] -> [c] 第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例： 1234ghci&gt; zipWith (+) [4,2,5,6] [2,6,2,3] [6,8,7,9] ghci&gt; zipWith max [6,3,2,1] [7,3,1,5] [7,3,2,5] flipflip :: (a -> b -> c) -> b -> a -> c flip函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来： 1234ghci&gt; zip [1,2,3,4,5] &quot;hello&quot;[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]ghci&gt; flip zip [1,2,3,4,5] &quot;hello&quot; [('h',1),('e',2),('l',3),('l',4),('o',5)] mapmap :: (a -> b) -> [a] -> [b] map函数接收一个函数f和一个列表a，将函数f应用在列表a的每个元素中，并返回得到的所有结果组成的列表b： 12ghci&gt; map (+3) [1,5,3,1,6] [4,8,6,4,9] filterfilter :: (a -> Bool) -> [a] -> [a] filter函数接收一个函数f和一个列表a，将列表a中的每个元素传入函数f中，如果结果为True就保留，结果为False就抛弃，返回所有保留的元素组成的新列表： 12ghci&gt; filter even [1..10] [2,4,6,8,10] takeWhiletakeWhile :: (a -> Bool) -> [a] -> [a] takeWhile函数接收一个函数f和一个列表a，将列表a中从左向右每个元素传入函数f，直到结果为False停止，返回停止前传入的所有元素组成的新列表： 12ghci&gt; takeWhile (/=' ') &quot;word1 word2&quot;&quot;word1&quot; Function application函数应用可以使用$，$是一个函数，它的类型是： ($) :: (a -> b) -> a -> b 它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。 1234567f $ g x-- 等价于f (g x)-----f g x-- 等价于(f g) x Function Composition函数复合可以使用.，.也是一个函数，它的类型是： (.) :: (b -> c) -> (a -> b) -> a -> c 定义是： f . g = \\x -> f (g x) 但是函数复合的优先级要比函数执行低，比如： 1sum . replicate 5 . max 6.7 8.9 会先执行max 6.7 8.9并返回8.9，然后将sum、replicate 5、8.9复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用$来规定先复合再执行： 1sum . replicate 5 . max 6.7 $ 8.9 lambdaHaskell语言中的lambda表达式是用\\来表示的（因为看着像$\\mathtt{\\lambda}$？）具体语法是 1\\para1 para2 ... -&gt; return “-&gt;”前的 para1 para2 … 是传入参数，单个多个都可以，需要用空格隔开；”-&gt;”后的 return 是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。 fold和scanfold和scan都接收三个参数（一个二元函数，一个初始值accumulator，一个要折叠的列表），fold返回一个值，而scan返回一个列表传入的二元函数f :: a -&gt; b -&gt; b将accumulator和从列表中取出的值一同传入（l则accumulator在左边为第一个参数，r则accumulator在右边为第二个参数） foldl左折叠，每次从列表最左侧取出一个值，和accumulator一起传入二元函数，并且accumulator在左边为第一个参数，如： 1foldl f a xs 它的结果计算过程为 1234&gt; foldl f a [x1, x2, x3][1.] a = f a x1[2.] a = f a x2 = f (f a x1) x2[3.] a = f a x3 = f (f (f a x1) x2) x3 可以看出 f (f a x1) x2 其实就是 foldl f a [x1, x2]而且因此，foldl在计算时最外层需要找到x3，这样如果xs是一个无穷列表，那么将无法计算，陷入无穷。所以foldl虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表 foldr右折叠，每次从列表最右侧取出一个值，和accumulator一起传入二元函数，并且accumulator在右边为第二个参数，如： 1foldr f a xs 它的结果计算过程为 1234&gt; foldr f a [x1, x2, x3][1.] a = f x3 a[2.] a = f x2 a = f x2 (f x3 a)[3.] a = f x1 a = f x1 (f x2 (f x3 a)) 从中可以看出 f x2 (f x3 a) 就是 foldr f a [x2, x3]因此可以使用递归来写一个和foldr效果一样的函数: 123foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; bfoldr' _ x [] = xfoldr' f a (x:xs) = f x (foldr' f a xs) 也可以看出，最外层计算时只需要x1并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。foldr即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表 例如： 12345ghci&gt; foldr (||) False (repeat True)True -- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了ghci&gt; foldl (||) False (repeat True)-- 这里什么都不会发生，直到电脑内存被爆掉-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表 scanl和scanrscan类似fold，只是将中间得到的每一个值都添加进一个列表中并返回这个列表scanl则向右延伸这个列表，scanr则向左延伸这个列表但是它和fold恰恰相反，scanl能用于无穷列表，而scanr不能 12345&gt; scanr f a [x1, x2, x3][1.] 最右侧元素(-1 in python) : a[2.] 右侧第二个元素(-2) : f x3 a[3.] 右侧第三个元素(-3) : f x2 (f x3 a)[4.] 右侧第四个元素(-4) : f x1 (f x2 (f x3 a)) 可以看出 f x2 (f x3 a) 是 foldr f a [x2, x3]，也是 scanr f a [x2, x3] 的第一个元素因此可以用递归来写一个和scanr效果一样的函数： 12345scanr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanr' _ x [] = [x]-- scanr' f a (x:xs) = f x (foldr f a xs) : scanr' f a xsscanr' f a (x:xs) = f x q : qs where qs@(q:_) = scanr' f a xs scanl也是同理： 123scanl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]scanl' _ x [] = [x]scanl' f a (x:xs) = a : scanl' f (f a x) xs 也可以看出，scanr返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而scanl返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果： 1234ghci&gt; take 10 (scanl (+) 0 [1..])[0,1,3,6,10,15,21,28,36,45]ghci&gt; take 10 (scanr (+) 0 [1..])[*** Exception: stack overflow 使用foldr编写foldlpdcxs还给我介绍了一个神奇的操作，用foldl来定义foldr： 1foldl' f z xs = foldr (\\x g y -&gt; g (f y x)) id xs z 它利用 foldr (\\x g y -&gt; g (f y x)) id xs 生成一个函数，作用于z得到结果。 先来看一下foldr的类型： 12foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b 但是在这个例子中，类型b并不是一个数字，而是一个函数(b -&gt; b)。 所以这里foldr的类型可以写成： (a -> (b -> b) -> (b -> b)) -> (b -> b) -> [a] -> (b -> b) 对应于用法 foldr (\\x g y -&gt; g (f y x)) id xs ，它返回的值应该是一个函数，类型为 b -&gt; b（后面要作用于z）而xs对应于[a]；id对应于(b -&gt; b)所以 (\\x g y -&gt; g (f y x)) 要对应于： (a -> (b -> b) -> (b -> b)) 因此可以推断出x的类型是a；y的类型是b；而返回的值为一个类型为(b -&gt; b)的函数。 再看，返回的值是 g (f y x) ，其中 f y x 返回的是一个值，类型为b所以g接收一个类型b，返回一个类型b -&gt; b。即g的类型为： b -> (b -> b) 现在根据foldr的定义： foldr f a (x:xs) = f x (foldr f a xs) 带入计算一下： xs即为[x1..xn]，为了方便，用xs’来表示[x2..xn]，用xs’’来表示[x3..xn] 定义中的f即为(\\x g y -&gt; g (f y x))，a即为id 12 foldr (\\x g y -&gt; g (f y x)) id xs z= (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z 写完第一步，可以发现，x1 (foldr (…) id xs’) z 正好分别对应了lambda表达式中的x、g、y。可以将其应用，进一步展开： 12 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1) 不难发现，原式 (foldr (…) id xs) z 等价于： (foldr (...) id xs') (f z x1) 跟着这个思路，xs每次少一个开头的元素x’，z每次变换成为 f z x’因此下一步： 12345 (\\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= (foldr (...) id xs''') (f (f (f z x1) x2) x3)= ... 可以发现，已经有了规律。那么最终停止时是什么样呢？ 最后到了不能在展开时，最前面的 foldr (…) id xs 已经变成了 foldr (…) id []而根据前面foldr的定义 foldr _ x [] = x ，它应该返回id 所以最后的结果：(id的定义：id x = x) 1234567 ...= (foldr (...) id xs') (f z x1)= (foldr (...) id xs'') (f (f z x1) x2)= ...= (foldr (...) id []) (f (.. (f z x1) ..) xn)= id (f (.. (f z x1) ..) xn)= f (.. (f z x1) ..) xn 那么最后这个结果就很熟悉了，它就是 foldl f z xs。所以我们推导出了这个用foldr表示foldl的写法是正确的。 ModulesHaskell会自动加载Prelude模块（module），如果在GHCi中再加载其他模块，需要使用:m + ...，比如加载Data.List模块： Prelude> :m + Data.List 而在hs文件中引入模块，需要使用import语句，下面和python的对比可以便于理解： 1234567891011121314import Data.List-- from Data.List import *import Data.List (nub, sort)-- from Data.List import nub, sortimport Data.List hiding (nub)-- 从Data.List中引入所有，但不引入nub函数import qualified Data.List-- import Data.Listimport qualified Data.List as Li-- import Data.List as Li 编写Modules模块中要包含将要使用的一些函数，像正常的hs文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫ModuleA.hs，那它的头部需要写： 123456module ModuleA( functionA, functionB, functionC) where 而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有functionD供前三个函数内部使用，那么在import ModuleA之后也无法调用functionD。 Types &amp; TypeclassesTypesHaskell有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。Type的首字母全为大写，常用的有： Int：整型，有上下界范围，-2147483647～2147483648 Integer：整数，无界，但是效率比Int低 Float：单精度浮点型 Double：双精度浮点型 Bool：布尔值 Char：字符 String：字符串，等同于[Char] Ordering：大小关系，包含LT、EQ、GT，且它们有大小关系 LT &lt; EQ &lt; GT 列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加[]。 元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如(“abc”, ‘a’, True)的类型是([Char], Char, Bool)。 Typeclasses类型类（Typeclass）是定义一系列功能的接口，如果一个Type属于一个Typeclass的成员，那么它可以实现这个类型类所规定的功能。一个Type也可以属于多个TypeclassTypeclass的首字母也全为大写，常见的有： Eq：可判断是否相等 Ord：可比较大小 Show：可展示成字符串 Read：可从字符串转换成特定类型 Enum：可枚举（连续），即可以使用pred和succ函数得到前驱和后缀 Bounded: 有上下界，如果元组中所有元素都属于Bounded，那这个元组的类型也属于Bounded Integral：是整数，包括Int和Integer RealFloat： 是实浮点数，包括Float和Double RealFrac：是实分数，包括Float、Double和Ratio（在Data.Ratio模块中） Floating：是浮点数，包括Float、Double和Complex（在Data.Complex模块中） Real：是实数，包括Integral和RealFrac的成员 Fractional：是分数，包括RealFrac和Floating的成员 Num：是数字，包括上述所有数字相关的类型 Type variables如果查看一个函数的类型，比如head，那么将会返回以下类型： head :: [a] -> a 其中的a就是一个类型变量（type variable），它在head中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。 在函数的类型表达式其实可以看作$\\lambda$表达式，它适用于$\\alpha$变换（$\\alpha$-conversion）。即a在这里可以指Int、Char等类型，也可以指[Char], (Int, Char), 甚至函数Int -&gt; Int等。 在大部分函数的类型中，类型变量需要保证是某个Typeclass的成员才能完成操作。比如(==)函数，它需要传入的参数是可判断相等的，即是Eq的成员，那么(==)的类型就是： (==) :: (Eq a) => a -> a -> Bool 其中=&gt;前的部分(Eq a)就是类约束（class constraint），它规定了a是Eq的成员，所以(==)函数传入的两个参数都是a类型，且都是Eq的成员，保证了它们之间是可以比较是否相等的。 定义新Type定义一个新的Type需要使用data关键字，比如定义Bool需要使用： data Bool = False | True 其中=左侧的部分定义了新类型的名称Bool，右侧的部分叫做值构造器（value constructors），表示了Bool类型的值为False或True。并且名称和值构造器的首字母都需要大写。 另外，值构造器也是函数，它们可以有参数，叫做项（field）。比如： 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float 它定义了一个新Type叫Shape，值构造器是Circle和Rectangle，Circle接收三个参数都是Float类型，Rectangle接收四个Float类型参数。如果查看Circle的类型，将返回： Circle :: Float -> Float -> Float -> Shape 如果想要让它能给直接显示出来，需要让它属于Show类型类。在代码中只需要在结尾加上deriving (Show): 1data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) 类型的名称和值构造器名称也可以相同，比如： 1data Point = Point Float Float deriving (Show) 导出Type在文件中定义了新的Type之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件Shapes.hs中定义了Shape和Point，以及其他的一些函数，那么文件开头需要写： 123456module Shapes( Shape(..), Point(..), functionA, functionB) where 其中的Shape(..)导出了Shape类型和它所有的值构造器，..代表了它的所有值构造器。因此，Shape(..)相当于Shape (Circle, Rectangle)。 如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将Shape(..)替换为Shape，这样就只导出了Shape类型，而不导出其值构造器。 Record Syntax如果想要方便地取出类型实例中的参数，可以使用Record语法，如： 123data Point = Point { xcoord :: Float , ycoord :: Float } deriving (Show) 在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord），后面指定类型（:: Float）。这样xcoord和ycoord就都是一个类型为Point -&gt; Float的函数，可以通过下面方法来访问值： 12345ghci&gt; let point = Point 1.0 2.0ghci&gt; xcoord point1.0ghci&gt; ycoord point2.0 同时也可以通过下面方法来创建这个point： 1point = Point {ycoord=2.0, xcoord=1.0} Type parameters值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如Maybe的定义： data Maybe a = Nothing | Just a 它的值是Nothing时，类型为Maybe a，是多态的（polymorphic）。他的值不是Nothing时，类型取决于值Just a中a的类型，可以构造出Maybe Int、Maybe [Char]等多种类型： 1234Nothing :: Maybe aJust 1 :: Num a =&gt; Maybe aJust 'a' :: Maybe CharJust &quot;abc&quot; :: Maybe [Char] 可以用这种方法改写Point： 123data Point x y = Point { xcoord :: x , ycoord :: y } deriving (Show) 但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用Point来表示Point类型，而是必须写成Point Float Float。 而且不能在定义类型构造器时添加类约束（class constraint），不然在之后声明函数类型的时候也都需要添加类约束，如： 12data (Ord k) =&gt; Map k v = ... toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)] EitherEither是一个类型构造器，它有两个值构造器，定义是： 1data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) 如果使用了Left，那它的a的类型就是具体的；如果使用了Right，那它的b的类型就是具体的： 12345678ghci&gt; Right 20 Right 20 ghci&gt; Left &quot;w00t&quot; Left &quot;w00t&quot; ghci&gt; :t Right 'a' Right 'a' :: Either a Char ghci&gt; :t Left True Left True :: Either Bool b Either可以看作Maybe的补充，比如Maybe在使用时，出现异常可以返回Nothing，但只是一个Nothing，不包含任何信息；但Either包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法： 12345678safeDiv :: Int -&gt; Int -&gt; Maybe IntsafeDiv _ 0 = NothingsafeDiv x y = Just (x `div` y)ghci&gt; safeDiv 4 2Just 2ghci&gt; safeDiv 1 0Nothing 而使用Either： 12345678safeDiv :: Int -&gt; Int -&gt; Either String IntsafeDiv _ 0 = Left &quot;Divided by zero&quot;safeDiv x y = Right (x `div` y)ghci&gt; safeDiv 4 2Right 2ghci&gt; safeDiv 1 0Left &quot;Divided by zero&quot; Derived instances想要使一个定义的类满足某些Typeclass的需求，需要从其派生（derive），比如： 12data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) 这样Day类型的值（Monday～Sunday）之间就可以比较是否相等（从Eq派生），比较大小（从Ord派生，左侧为小，右侧为大），显示成字符串（从Show派生），从字符串中读取（从Read派生），包含边界（从Bounded派生），可以枚举（从Enum派生，按照值构造器中的顺序依次向右） Type synonyms为了阅读方便，书写简便，可以使用type关键字为已有类型创建别名（synonyms）。比如String的定义： type String = [Char] 在所有需要使用字符串（即[Char]）的地方都可以使用String来代替，它们是完全一致的，只是String更简便易读。同时，类型别名也可以接收类型参数 newtype keyword除了data、type关键字之外，还可以用newtype关键字来定义一个新的类型，比如Control.Applicative模块中的ZipList： 1newtype ZipList a = { getZipList :: [a] } 不同于type，它不是别名，可以使用record语法来直接定义取出值的函数 不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰 Recursive data structures一个类型也可以递归定义，比如一颗二叉树： 1data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) 定义新Typeclass定义一个新的Typeclass需要使用class关键字，例如定义Eq类型类： 12345class Eq a where (==) :: a -&gt; a -&gt; Bool (/=) :: a -&gt; a -&gt; Bool x == y = not (x /= y) x /= y = not (x == y) 其中a是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。 包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们（(==) | (/=)）成为这个类型类的最小完整定义（minimal complete definition） 查看一个类型类的成员需要实现的函数可以在GHCi中使用:info： ghci> :info Eq 手动创建实例使一个类型成为一个类型类的实例可以直接使用deriving来自动完成，也可以通过使用instance关键字来手动完成。比如使Point成为Show的实例： 123456instance Show Point where show (Point x y) = &quot;(&quot; ++ show x ++ &quot;, &quot; ++ show y ++ &quot;)&quot;-- in ghcighci&gt; Point 1.0 2.0(1.0, 2.0) 这样就可以自定义显示的内容，否则使用deriving的话只会直接将其转化为字符串。 同时也要注意类型和类型构造器的区别，传入给instance的第二个参数应该为类型而不是类型构造器，比如Maybe： 123456789101112instance Eq Maybe where ... -- 错误用法，因为Maybe是类型构造器而不是类型instance Eq (Maybe m) where ...-- 错误用法，因为m不一定是Eq的成员instance (Eq m) =&gt; Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False Functor TypeclassFunctor也是一种类型类，它只规定了一个函数： 12class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 其中f是一个类型构造器，而不是一个具体类型 Kinds一个值的类型叫做类型（Type），而一个类型的类型叫做Kind。可以通过GHCi中:k来查看Kind： 12345678ghci&gt; :k IntInt :: *ghci&gt; :k MaybeMaybe :: * -&gt; *ghci&gt; :k Maybe IntMaybe Int :: *ghci&gt; :k EitherEither :: * -&gt; * -&gt; * 其中的星号*代表了一个具体类型（concrete type）。Int本身就是一个具体类型，所以Int的Kind是*。而Maybe是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以Maybe的Kind是* -&gt; *。如果给Maybe传入了一个Int，那么得到的Maybe Int就是一个具体的类型，它的Kind就是*。Either也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以Either的Kind是* -&gt; * -&gt; *。 Input/Output运行Haskell程序不在GHCi中运行一个Haskell程序有两种方式： 编译运行： 12$ ghc --make code$ ./code 通过runhaskell命令直接运行： 1$ runhaskell code.hs 输出文本在一个Haskell程序中输出文字需要定义一个main函数： 1main = putStrLn &quot;Hello World&quot; 其中putStrLn的类型是： putStrLn :: String -> IO () putStrLn接收一个String类型，并返回一个结果为()类型的IO动作（I/O action）。所以main函数的类型为IO ()。（IO的Kind是* -&gt; *） 除此之外，还有其他默认提供的输出文本的函数： putStr：输出文本，结尾不换行 putChar：输出单个字符，结尾不换行。接收的参数为单个Char，不是String（用单引号不是双引号） print：可以接收任何Show的成员，先用show转化为字符串然后输出。等同于putStrLn . show do block在main函数中使用多个putStrLn需要使用do语句： 123main = do putStrLn &quot;Line1&quot; putStrLn &quot;Line2&quot; 其中最后一行一定要返回IO ()类型的值 输入文本输入文字需要在do块中使用getLine： 123main = do line &lt;- getLine putStrLn line getLine的类型是： getLine :: IO String 而&lt;-操作符将getLine中的String提取了出来给到了line，使line变成了String类型的一个字符串。 而且使用输入的字符串必须要经过一次&lt;-，不能直接使用getLine作为字符串，因为getLine不是String类型，而是IO String类型。 除此之外，还可以使用getChar来获取单个字符，但仍然需要使用&lt;-操作符来提取Char 其他IO相关函数用法returnHaskell中的return和其他命令式语言中的return完全不同，它不会使函数直接结束并返回一个值。 main函数必须定义为类型为IO ()的函数，所以在main函数中使用if语句，如果不输出的话也不可以直接放下什么都不干，因为这时候main函数的类型不是IO ()。所以这时需要使用return ()来为main函数指定为IO ()类型，例如： 123456main = do line &lt;- getLine if null line then return () -- &lt;-这里 else do ... 使用&lt;-操作符也可以直接将return语句中的内容提取出来，比如a &lt;- return ‘A’，执行后a就是’A’。 whenwhen包含在Control.Monad模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会return ()。比如： 1234567import Control.Monad main = do c &lt;- getChar when (c /= ' ') $ do putChar c main 等同于： 1234567main = do c &lt;- getChar if c /= ' ' then do putChar c main else return () sequencesequence在IO中使用时可以达成[IO a] -&gt; IO [a]的效果，所以可以用作： 1[a, b, c] &lt;- sequence [getLine, getLine, getLine] mapM &amp; mapM_在IO相关的地方使用map，可以使用mapM和mapM_，其中mapM有返回值而mapM_直接扔掉了返回值： 123456789ghci&gt; mapM print [1,2,3] 1 2 3 [(),(),()] ghci&gt; mapM_ print [1,2,3] 1 2 3 foreverforever函数包含在Control.Monad模块中。在main函数开头加上forever函数可以使后面的do块一直重复执行直到程序被迫终止，如： 1234import Control.Monad main = forever $ do ... forMforM函数包含在Control.Monad模块中，它的功能和mapM类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回IO a类型。比如： 123456789import Control.Monadmain = do colors &lt;- forM [1, 2, 3, 4] (\\a -&gt; do putStrLn $ &quot;Which color do you associate with the number &quot; ++ show a ++ &quot;?&quot; color &lt;- getLine return color) putStrLn &quot;The colors that you associate with 1, 2, 3 and 4 are: &quot; mapM putStrLn colors getContentsgetLine获取一整行，而getContents从标准输入中获取全部内容直到遇到EOF，并且它是lazy的，在执行了foo &lt;- getContents后，它并不会读取标准输入并且赋值到foo，而是等到需要使用foo的时候再从标准输入读取。 getContents在使用管道传入文字时很常用，可以代替forever+getLine使用，比如一个Haskell程序文件code.hs： 12345import Data.Char main = do contents &lt;- getContents putStr (map toUpper contents) 使用ghc –make code编译后，通过管道传入文字： 1cat text.txt | ./code 会将text.txt中的所有字母转为大写并输出 interact上述功能还可以转化为一个String -&gt; String的函数： 1upperStrings = unlines . map (map toUpper) . lines 而在main中使用这个函数就需要： 123main = do contents &lt;- getContents putStr (upperStrings contents) 但是String -&gt; String类型的函数在输入输出中的使用太常见了，所以可以使用interact函数来简化。interact的类型是： interact :: (String -> String) -> IO () 可以看出它接收一个String -&gt; String的函数，并返回一个IO ()类型，所以可以直接用在main上。 于是整个转换为大写的程序就可以简化为： 1main = interact $ unlines . map (map toUpper) . lines 文件和流以下与文件和流相关的函数都包含在System.IO模块中 openFileopenFile函数可以用来打开一个文件，它的类型是： openFile :: FilePath -> IOMode -> IO Handle 其中FilePath是String的type synonyms，用一个字符串来表示需要打开的文件的路径 IOMode的定义是： 1data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode 所以它一共只有四个值，用来表示进行IO操作的模式 openFile返回一个IO Handle类型的值，将其用&lt;-操作符提取后会出现一个Handle的值。但不能从Handle中直接使用文字，还需要使用一系列函数： hGetContents :: Handle -&gt; IO String ，从Handle中读取全部内容，返回一个IO String hGetChar :: Handle -&gt; IO Char ，从Handle中读取一个字符 hGetLine :: Handle -&gt; IO String ，从Handle中读取一行，返回一个IO String hPutStr :: Handle -&gt; String -&gt; IO () ，向Handle中输出字符串 hPutStrLn :: Handle -&gt; String -&gt; IO () ，同上 在使用openFile进行文件操作后，需要使用hClose手动关闭Handle。hClose :: Handle -&gt; IO ()，接收一个Handle并返回IO ()，可以直接放在main函数末尾 所以使用openFile读取一个文件中的全部内容并输出的全部代码是： 1234567import System.IOmain = do handle &lt;- openFile &quot;text.txt&quot; ReadMode contents &lt;- hGetContents handle putStrLn contents hClose handle withFilewithFile类似Python中的with open，它在读取文件使用之后不需要手动close文件。它的类型是： withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a 可以看出，它接收三个参数： FilePath：一个表示文件路径的String IOMode：打开文件的模式 (Handle -&gt; IO a)：一个函数，表示对读取文件后的Handle索要进行的操作，需要返回一个I/O action；而这个返回值也将作为withFile的返回值 现在使用withFile来改写上述代码： 12345import System.IOmain = withFile &quot;text.txt&quot; ReadMode (\\handle -&gt; do contents &lt;- hGetContents handle putStrLn contents) withFile的功能相当于以下函数： 123456withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a withFile' path mode f = do handle &lt;- openFile path mode result &lt;- f handle hClose handle return result readFilereadFile可以更加简化读取文件内容的操作，它的类型： readFile :: FilePath -> IO String 它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的I/O action： 12345import System.IOmain = do contents &lt;- readFile &quot;text.txt&quot; putStrLn contents writeFilewriteFile简化了写入文件的操作，它的类型： writeFile :: FilePath -> String -> IO () 传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个IO () appendFileappendFile类似writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾 buffer文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。 也可以通过hSetBuffering函数来手动设置缓冲区大小，这个函数的类型： hSetBuffering :: Handle -> BufferMode -> IO () 它接收一个handle，和一个BufferMode，并返回IO ()。其中BufferMode有以下几种： NoBuffering：没有缓冲区，一次读入一个字符 LineBuffering：缓冲区大小是一行，即每次读入一行内容 BlockBuffering (Maybe Int)：缓冲区大小是一块，块的大小由Maybe Int指定： BlockBuffering (Nothing)：使用系统默认的块大小 BlockBuffering (Just 2048)：一块的大小是2048字节，即每次读入2048bytes的内容 缓冲区的刷新是自动的，也可以通过hFlush来手动刷新 hFlush :: Handle -> IO () 传入一个handle，返回IO ()，即刷新对应handle的缓冲区 openTempFileopenTempFile可以新建一个临时文件： openTempFile :: FilePath -> String -> IO (FilePath, Handle) FilePath指临时文件要创建的位置路径，String指临时文件名字的前缀，返回一个I/O action，其内容第一个FilePath是创建得到的临时文件的路径，Handle是临时文件的handle 例如： 123456import System.IOmain = do (tempFile, tempHandle) &lt;- openTempFile &quot;.&quot; &quot;temp&quot; ... hClose tempHandle &quot;.&quot;指临时文件要在当前目录创建，&quot;temp&quot;指临时文件名字以temp开头。最终得到的tempFile就是./temp…….，temp后为随机数字，如./temp43620-0 路径操作相关函数都包含在System.Directory模块中，全部内容见System.Directory getCurrentDirectorygetCurrentDirectory :: IO FilePath 直接返回一个I/O action，其内容是一个字符串表示当前路径的绝对路径 removeFileremoveFile :: FilePath -> IO () 输入一个文件路径，并删除掉它 renameFilerenameFile :: FilePath -> FilePath -> IO () 输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名 doesFileExistdoesFileExist :: FilePath -> IO Bool 检查文件是否存在，返回一个包含布尔值的I/O action Command line argumentsSystem.Environment模块中提供了两个函数可以用来处理传入命令行的参数 getArgsgetArgs :: IO [String] 不需要输入参数，直接返回一个I/O action，内容为传入命令行的参数（一个由String组成的列表）。相当于C语言中的argv[1:] getProgNamegetProgName :: IO String 返回I/O action，内容为程序的名字，相当于C语言中的argv[0] Randomness和随机数有关的函数都包含在System.Random模块中。GHCi启动时可能不会包含System.Random的配置，导致无法找到模块。需要通过stack打开: 1stack ghci --package random Haskell要求同样的程序需要运行出同样的结果，除了用到了I/O action，所有会造成不同结果的函数都要交给I/O action来完成 那要使随机数脱离IO存在，就要用到随机生成器（random generator） System.Random模块提供了几个生成随机数的函数： randomrandom :: (Random a, RandomGen g) => g -> (a, g) 其中又有两个新的typeclass，Random表示可以取随机，RandomGen表示随机数生成器。random函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器 获取随机数生成器可以使用mkStdGen函数： mkStdGen :: Int -> StdGen 其中StdGen是一个RandomGen的实例 运用random生成随机数需要指定类型，不然程序无法确定a是什么类型。例如： 123456ghci&gt; random (mkStdGen 100) :: (Int, StdGen)(9216477508314497915,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Char, StdGen)('\\537310',StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})ghci&gt; random (mkStdGen 100) :: (Bool, StdGen)(True,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125}) 再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器： 123456threeCoins :: StdGen -&gt; (Bool, Bool, Bool) threeCoins gen = let (firstCoin, newGen) = random gen (secondCoin, newGen') = random newGen (thirdCoin, newGen'') = random newGen' in (firstCoin, secondCoin, thirdCoin) randomsrandoms :: (Random a, RandomGen g) => g -> [a] randoms接收一个RandomGen，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器 randomRrandomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g) 可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围(闭区间) randomRsrandomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a] 同上两个，生成有范围的无穷随机数列表 getStdGen如果想要让程序每次运行得到不同的随机结果，需要使用getStdGen来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个I/O action，而不是一个直接的StdGen getStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen 即可以看成getStdGen :: IO StdGen，需要使用&lt;-操作符将StdGen提取出来 但是在同一个程序中，getStdGen的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数newStdGen newStdGennewStdGen :: Control.Monad.IO.Class.MonadIO m => m StdGen 执行newStdGen会进行两个操作： 更新全局随机数生成器，下次执行getStdGen会获得不同的结果 返回一个I/O action，包含一个新的StdGen（但是这个生成器和全局生成器也不同） Exceptions程序在运行失败时会抛出异常，可以通过Control.Exception模块中的catch函数来捕获异常： catch :: Exception e => IO a -> (e -> IO a) -> IO a 第一个参数是要进行的操作，以IO a为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如： 12345678910import Control.Exceptionmain = main' `catch` handlermain' :: IO ()main' = do ...handler :: Exception e =&gt; e -&gt; IO ()handler e = putStrLn &quot;...&quot; 也可以利用守卫（guard）语法和System.IO.Error中的函数来判断IO异常的类型来进行不同操作： 123456789101112131415import System.Environmentimport System.IO.Errorimport Control.Exception main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) &lt;- getArgs contents &lt;- readFile fileName putStrLn $ &quot;The file has &quot; ++ show (length (lines contents)) ++ &quot; lines!&quot; handler :: IOError -&gt; IO () handler e | isDoesNotExistError e = putStrLn &quot;The file doesn't exist!&quot; | otherwise = ioError e 具体相关全部函数见文档：System.IO.Error、Control.Exception Functors函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用fmap :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子 Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子 函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的f a和f b也是因为f是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中 Functor的定义是: 1234class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b (&lt;$) :: a -&gt; f a -&gt; f b (&lt;$) = fmap . const 可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如： 12ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot; 但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名： const :: a -> b -> a 即接收两个参数，但始终只返回第一个参数 Functor实例[]列表[]是一个函子，它通过map函数来实现fmap的功能： 12instance Functor [] where fmap = map map :: (a -> b) -> [a] -> [b] map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表 MaybeMaybe也具有kind * -&gt; *，它也是一个函子： 12345678instance Functor Maybe where fmap f Nothing = Nothing fmap f (Just x) = Just (f x)ghci&gt; fmap (*2) NothingNothingghci&gt; fmap (*2) (Just 2)Just 4 Either aEither的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子： 12345678instance Functor (Either a) where fmap f (Left x) = Left x fmap f (Right x) = Right (f x)ghci&gt; fmap (*2) (Left 4)Left 4ghci&gt; fmap (*2) (Right 4)Right 8 因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在） IOIO也是一个函子，使用fmap对IO中内容应用函数： 12345678instance Functor IO where fmap f action = do result &lt;- action return (f result)ghci&gt; fmap (&quot;input: &quot;++) getLinetest&quot;input: test&quot; (,) a(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用： 12instance Functor ((,) a) where fmap f (x, y) = (x, f y) 只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用： 12345instance Functor ((,,) a b) where fmap f (a, b, c) = (a, b, f c)instance Functor ((,,,) a b c) where fmap f (a, b, c, d) = (a, b, c, f d) (-&gt;) r-&gt;也是一个类型构造器，它的kind： (->) :: * -> * -> * 一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中r是输入的类型） 规定的fmap的类型签名是： fmap :: (a -> b) -> f a -> f b 其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到： fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b) 把其中的(-&gt;)换成中缀可以得到： fmap :: (a -> b) -> (r -> a) -> (r -> b) 传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是： 12instance Functor ((-&gt;) r) where fmap f g = (\\x -&gt; f (g x)) 所以(-&gt;) r的fmap其实就是函数复合(.)： 12instance Functor ((-&gt;) r) where fmap = (.) 12345678ghci&gt; :t fmap (*3) (+100) fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a ghci&gt; fmap (*3) (+100) 1 303 ghci&gt; (*3) `fmap` (+100) $ 1 303 ghci&gt; (*3) . (+100) $ 1 303 Functor Laws所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律： fmap id = id（其中id为函数(\\x -&gt; x)）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： 1234ghci&gt; fmap id [1, 2, 3][1,2,3]ghci&gt; fmap id (Just 2)Just 2 fmap (f . g) = fmap f . fmap g：即函子的fmap支持结合律 fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中a为一个函子 fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) 12ghci&gt; fmap ((*3) . (+100)) (Just 1)Just 303 满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可 Intuition对于函子和fmap，有两种理解方法 函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器 函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作fmap :: (a -> b) -> (f a -> f b) 接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数 fmap g :: f a -> f b 使普通的函数g可以在计算上下文f中使用，这种转换也被称为提升（lift） 常用函数&lt;$&gt;&lt;$&gt;函数是fmap的中缀形式（它看着类似$，f $ 3将f应用在单个值3上，而f &lt;$&gt; [1, 2, 3]将f应用在一个函子上，也就是应用在一个函子内部的所有值上）： 1234ghci&gt; fmap (*2) (Just 2)4ghci&gt; (*2) &lt;$&gt; Just 24 $&gt;$&gt;函数包含在Data.Functor模块中 ($>) :: Functor f => f a -> b -> f b Functor定义时要求了&lt;$函数，将函子内部的元素全部替换为指定的某个值，而$&gt;正好将&lt;$函数的两个参数反了过来，相当于flip (&lt;$)： 1234ghci&gt; 'a' &lt;$ [1, 2, 3]&quot;aaa&quot;ghci&gt; [1, 2, 3] $&gt; 'a'&quot;aaa&quot; voidvoid函数也包含在Data.Functor模块中 void :: Functor f => f a -> f () void函数把一个函子内部的全部元素都变成空（()），void x相当于() &lt;$ x： 1234ghci&gt; void [1, 2, 3][(), (), ()]ghci&gt; void (Just 2)Just () Applicative Functor应用函子（Applicative Functor）是函子的升级版，它包含在Control.Applicative模块中。 fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义： 123class Functor f =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b 应用函子要求实现两个函数： pure :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just &lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。 Applicative Functor实例MaybeMaybe是一个应用函子： 1234instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something pure函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x &lt;*&gt;函数：将装有函数的函子中的函数应用另一个函子中 第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing 第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可 实际应用的例子： 12345678ghci&gt; Just (+3) &lt;*&gt; Just 9Just 12ghci&gt; pure (+3) &lt;*&gt; Just 9Just 12ghci&gt; (+3) &lt;$&gt; Just 9Just 12ghci&gt; Nothing &lt;*&gt; Just 9Nothing 第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12 第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了 而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如： 1234ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9Just 12ghci&gt; pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5Just 12 &lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12: 12345 pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5= (pure (\\x y z -&gt; x + y + z) &lt;*&gt; Just 3) &lt;*&gt; Just 4 &lt;*&gt; Just 5= (Just (\\y z -&gt; 3 + y + z) &lt;*&gt; Just 4) &lt;*&gt; Just 5= Just (\\z -&gt; 3 + 4 + z) &lt;*&gt; Just 5 = Just (+7) &lt;*&gt; Just 5= Just 12 所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。 而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是： f x y ... []列表也是一个应用函子： 123instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs] pure函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x] &lt;*&gt;函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表 使用例子： 1234ghci&gt; [(+3), (*2)] &lt;*&gt; [1, 2][4,5,2,4]ghci&gt; [(+), (*)] &lt;*&gt; [1, 2] &lt;*&gt; [3, 4] [4, 5, 5, 6, 3, 4, 6, 8] IO123456instance Applicative IO where pure = return a &lt;*&gt; b = do f &lt;- a x &lt;- b return (f x) 也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子 1234ghci&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLineLine1Line2&quot;Line1Line2&quot; (-&gt;) r(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名： :: f (a -> b) -> f a -> f b 其中f为(-&gt;) r，将其代入并替换为中缀： :: (r -> a -> b) -> (r -> a) -> (r -> b) 可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b) 那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是： \\x -> f x (g x) 于是： 123instance Applicative ((-&gt;) r) where pure x = (\\_ -&gt; x) f &lt;*&gt; g = \\x -&gt; f x (g x) 将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x 应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子： 12ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5508 执行这句时发生了什么？： 12345678 (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5= ((+) &lt;$&gt; (+3)) &lt;*&gt; (*100) $ 5= ((+) . (+3)) &lt;*&gt; (*100) $ 5 = (\\a -&gt; (+) ((+3) a)) &lt;*&gt; (*100) $ 5= (\\a b -&gt; (a + 3 + b)) &lt;*&gt; (*100) $ 5= (\\x -&gt; x + 3 + ((*100) x)) $ 5= (\\x -&gt; x + 3 + x * 100) $ 5= 5 + 3 + 5 * 100 = 508= (5 + 3) + (5 * 100) 所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+) 同样： 12ghci&gt; (\\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5 [8.0,10.0,2.5] 先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\\x y z -&gt; [x,y,z])得到了最终的结果 12 f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i= (\\x -&gt; f (g x) (h x) (i x)) ZipList普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在Control.Applicative模块中 123instance Applicative ZipList where pure x = ZipList (repeat x) ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith ($) fs xs) 但是ZipList并不是Show的实例，所以不能直接显示出来，要使用getZipList来获取它内部的列表： 1234ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..] [101,102,103]ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList &quot;dog&quot; &lt;*&gt; ZipList &quot;cat&quot; &lt;*&gt; ZipList &quot;rat&quot; [('d','c','r'),('o','a','a'),('g','t','t')] Applicative Functor Laws应用函子一般有四个定律，都是保证pure的正确性的： Identity law：pure id &lt;*&gt; v = v Homomorphism：pure f &lt;*&gt; pure x = pure (f x) Interchange：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u Composition：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w Intuition理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：$$[[\\ \\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ \\ ]]$$ 其中$x_i$的类型是$f\\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是： $$t_1\\to t_2\\to\\cdots\\to t_n\\to t$$ 所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\\ x_1$结果的类型是： $$f\\ \\ (t_2\\to t_3\\to\\cdots\\to t_n\\to t)$$ 但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\\ g\\ x_1\\ x_2\\ \\cdots\\ x_n\\ ]]$，只需要： g x1 x2 ... xn 而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算： g x1 pure x2 ... xn 常用函数liftA &amp; liftA2 &amp; liftA3liftA :: Applicative f => (a -> b) -> f a -> f b liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d 不难推测liftA就是fmap，liftA2 f x1 x2相当于f &lt;$&gt; x1 &lt;*&gt; x2，liftA3 f x1 x2 x3相当于f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3 &lt;* &amp; *&gt;类型类似函子的&lt;$和$&gt;： (&lt;*) :: Applicative f => f a -> f b -> f a (*>) :: Applicative f => f a -> f b -> f b &lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来 12345678910111213141516ghci&gt; Just 3 &lt;* Just 4Just 3ghci&gt; Just 3 *&gt; Just 4Just 4ghci&gt; Nothing &lt;* Just 3Nothingghci&gt; Nothing *&gt; Just 3Nothingghci&gt; [1, 2, 3] &lt;* [3, 4][1,1,2,2,3,3]ghci&gt; [1, 2, 3] *&gt; [3, 4][3,4,3,4,3,4]ghci&gt; [] &lt;* [1, 2, 3][]ghci&gt; [] *&gt; [1, 2, 3][] &lt;**&gt;(**) :: Applicative f => f a -> f (a -> b) -> f b 接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用： 123456ghci&gt; [(+1), (+2), (+3)] &lt;*&gt; [1, 2][2,3,3,4,4,5]ghci&gt; [1, 2] &lt;**&gt; [(+1), (+2), (+3)][2,3,4,3,4,5]ghci&gt; flip(&lt;*&gt;) [1, 2] [(+1), (+2), (+3)][2,3,3,4,4,5] when &amp; unlesswhen :: Applicative f => Bool -> f () -> f () 传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过） unless则与when相反，测试为True返回pure () sequenceAsequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a) 应用在列表上时，它的类型相当于： [f a] -> f [a] 所以在列表上它的使用方法： 12345678910ghci&gt; sequenceA [Just 3, Just 2, Just 1] Just [3,2,1] ghci&gt; sequenceA [Just 3, Nothing, Just 1] Nothing ghci&gt; sequenceA [(+3),(+2),(+1)] 3 [6,5,4] ghci&gt; sequenceA [[1,2,3],[4,5,6]] [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]] ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]] [] 它在对同一个参数应用不同函数时很有用： 1234ghci&gt; map (\\f -&gt; f 7) [(&gt;4), (&lt;10), odd] [True,True,True] ghci&gt; sequenceA [(&gt;4), (&lt;10), odd] 7 [True,True,True] Monad单子（Monad）是对Applicative Functor的扩展（但是诞生比Applicative早），Functor的&lt;$&gt;函数实现了将普通函数应用在上下文值上，Applicative的&lt;*&gt;函数将上下文中函数应用在上下文值上。而Monad提供了一个函数&gt;&gt;=（bind），将一个接收普通值返回上下文值的函数应用在上下文值上： 123456class Applicative m =&gt; Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b return :: a -&gt; m a m &gt;&gt; n = m &gt;&gt;= \\_ -&gt; n return = pure return函数：和pure一样，只是有另一个名字 &gt;&gt;函数：提供了默认的实现方法，它的作用和Applicative的*&gt;函数一样 &gt;&gt;=函数（bind）：比Applicative升级的函数，第一个参数是一个单子，第二个参数是一个接收值返回单子的函数，将这个函数应用在第一个参数单子中的值上，并返回得到的新单子 Monad实例MaybeMaybe是一个单子实例，Applicative已经为它实现了return，因此只需要&gt;&gt;=函数： 123instance Monad Maybe where (Just x) &gt;&gt;= f = f x Nothing &gt;&gt;= _ = Nothing 根据定义就很容易实现Maybe的&gt;&gt;=函数了，而且也很好理解 12345678ghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1)Just 2ghci&gt; Just 1 &gt;&gt;= \\x -&gt; return (x + 1)Just 2ghci&gt; Nothing &gt;&gt;= \\x -&gt; Just (x + 1)Nothingghci&gt; Just 1 &gt;&gt;= \\x -&gt; Just (x + 1) &gt;&gt; Nothing &gt;&gt;= \\y -&gt; Just (y + 1)Nothing 最后一个例子中出现了&gt;&gt; Nothing，这时Nothing前的部分全都相当于没用，因为&gt;&gt;操作符的左右两边只要有一个出现Nothing，那整体就会是Nothing。这个特性可以用于在中途随时判断失误，只要有一处失误，结果就会是Nothing []列表也是一个单子： 12instance Monad [] where xs &gt;&gt;= f = concat (map f xs) 将这个函数应用在xs的每个值上，将返回的所有列表平铺成一个列表： 1234ghci&gt; [3,4,5] &gt;&gt;= \\x -&gt; [x,-x] [3,-3,4,-4,5,-5] ghci&gt; [1,2] &gt;&gt;= \\n -&gt; ['a','b'] &gt;&gt;= \\ch -&gt; return (n,ch) [(1,'a'),(1,'b'),(2,'a'),(2,'b')] IOIO也是一个单子，但是实现方法比较深奥（逃 (-&gt;) r(-&gt;) r也是一个单子，和Functor、Applicative一样，先分析它的&gt;&gt;=类型签名： (>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b (>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b) 也可以看出来，它接收两个函数f :: r -&gt; a、g :: a -&gt; r -&gt; b，然后返回一个新的函数h :: r -&gt; b 那么函数h接收一个类型为r的参数，返回一个类型为b的值。所以先对输入应用f得到类型为a的中间值，然后再将这个值和输入参数一起传入函数g得到结果。所以函数h的定义应该是： \\x -> g (f x) x 12instance Monad ((-&gt;) r) where f &gt;&gt;= g = \\x -&gt; g (f x) x 1234ghci&gt; (+3) &gt;&gt;= (+) $ 15ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; id $ 15 do-notationHaskell的do语句为链式的&gt;&gt;=应用提供了类似命令式（imperative style）的语法糖。比如a &gt;&gt;= \\x -&gt; b &gt;&gt; c &gt;&gt;= \\y -&gt; d： 1234a &gt;&gt;= \\x -&gt;b &gt;&gt;c &gt;&gt;= \\y -&gt;d 其中有abcd四个值，可以看出a中内容绑定到了x上，c中内容绑定到了y上。使用do语句来表示这个操作可以写成： 12345do { x &lt;- a ; b ; y &lt;- c ; d } 其中的大括号和分号可以省略不写（挤在一行时不能省略）。do语句也只是一个语法糖，它可以递归地转换成普通的Monad操作语句： do e：e do { e; ... }：e &gt;&gt; do { … } do { v &lt;- e; ... }：e &gt;&gt;= \\v -&gt; do { … } do { let ...; ... }：let … in do { … } ApplicativeDo比如如下一个do语句： 1234do x &lt;- a y &lt;- b z &lt;- c return (f x y z) 它可以转化成： a >>= \\x -> b >>= \\y -> c >>= \\z -> return (f x y z) 但是经过观察可以发现，整个语句实际上将函数f应用在了三个上下文中的值上，所以仅用Applicative的&lt;$&gt;和&lt;*&gt;完全可以实现： f a b c 而且在运行的时候Applicative的效率会比Monad高，所以Haskell会将do语句尽可能优先转换为Applicative的表示方法然后再计算 Monad Laws Left identity： return a &gt;&gt;= k = k a Right identity：m &gt;&gt;= return = m Associativity：(m &gt;&gt;= g) &gt;&gt;= h = m &gt;&gt;= (\\x -&gt; g x &gt;&gt;= h) 前两个定律很好理解： 将a注入上下文之后绑定（bind）给函数k(:: a -&gt; m a)，相当于直接将a直接传入函数k 将已经包含在上下文中的值绑定给return函数，相当于保持不变 第三个定律是结合律，把它写成更像结合律的表示方法是： (m >>= (\\x -> g x)) >>= h = m >>= (\\x -> g x >>= h) 组合运算符（&gt;=&gt;）形式Control.Monad模块中还定义了函数&gt;=&gt;（Kleisli-composition operator）： 123infixr 1 &gt;=&gt;(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)f &gt;=&gt; g = \\x -&gt; f x &gt;&gt;= g 使用&gt;=&gt;运算符可以将两个用于绑定的函数结合在一起。用它表示的Monad定律更加清晰直观： Left identity：return &gt;=&gt; f = f Right identity：f &gt;=&gt; return = f Associativity：(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h) do-notation形式Monad的这三个定律还可以使用do语句来描述： Left identity： 123do { x' &lt;- return x; f x' = do { f x } } Right identity： 123do { x &lt;- m; return x = do { m } } Associativity： 12345do { y &lt;- do { x &lt;- m; do { x &lt;- m; do { x &lt;- m; f x do { y &lt;- f x; y &lt;- f x; } = g y = g y g y } } } } IntuitionMonad也可以很自然地看成Applicative的升级版，比如Applicative的操作全部是固定的，而Monad的操作可以在中途突然改变 同时Monad也完成了Functor和Applicative无法完成的操作。比如要用fmap和实现&gt;&gt;=函数（即达成操作 m a -&gt; (a -&gt; m b) -&gt; m b），先假设 f :: a -&gt; m b，那么fmap f的类型就会是 m a -&gt; m (m b)，将m a应用在fmap f上会得到结果m (m b)，而不是m b。但是目前只可以使用pure将一个值装入上下文中（a -&gt; m a），而没有一个函数可以从上下文中提取值（m a -&gt; a）。那么就需要定义一个新的函数来实现这个操作的效果（m (m b) -&gt; m b）。因此Monad的另一个等效的定义方法是： 12345class Applicative m =&gt; Monad' m where join :: m (m a) -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x 但是\b定义&gt;&gt;=函数会更为直观方便，所以Haskell采用了用&gt;&gt;=函数定义Monad的方法 同时Haskell还提供了join函数的定义： 12join :: Monad m =&gt; m (m a) -&gt; m a join x = x &gt;&gt;= id 常用函数liftM &amp; apliftM :: Monad m => (a -> b) -> m a -> m b ap :: Monad m => m (a -> b) -> m a -> m b 所以liftM其实就是fmap、ap就是&lt;*&gt;，但是老版本的GHC定义Monad并没有Functor、Applicative的约束，所以实现了liftM、ap，并且保留了这个名字 因此一个单子也可以通过pure = return、(&lt;*&gt;) = ap直接成为应用函子的实例 sequencesequence :: Monad m => [m a] -> m [a] sequence的作用显而易见，而且在IO部分也使用到了。但是这个版本是在GHC.Base模块中定义的，还有一个更广泛的使用Traversable的定义在Data.Traversable模块中 replicateMreplicateM :: Applicative m => Int -> m a -> m [a] mapM &amp; forMmapM :: Monad m => (a -> m b) -> [a] -> m [b] forM :: Monad m => [a] -> (a -> m b) -> m [b] forM的用法在IO部分已经说过，mapM和forM都在Data.Traversable模块中有广泛版本 还有一些其他的函数：filterM、zipWithM、foldM、forever，通过名字就可以看出用法，是将原来仅使用与列表的函数提升至可以适用于所有单子 并且在函数名后加下划线，比如sequence_、mapM_，会忽略返回值（最终结果为m ()） =&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;（&gt;=&gt;操作符在上面Monad Laws部分已经给出了定义） x &gt;&gt;= f = f =&lt;&lt; x f &gt;=&gt; g = g &lt;=&lt; f MonadFailMonadFail定义在Control.Monad.Fail模块中： 12class Monad m =&gt; MonadFail m where fail :: String -&gt; m a 它只要求在Monad的基础上实现fail函数，接收一个字符串返回一个单子。这会使在do语句中产生错误时直接变为错误值（空值）使最终的返回值为错误值 MonadFail实例12345678instance MonadFail Maybe where fail _ = Nothinginstance MonadFail [] where fail _ = []instance MonadFail IO where fail = failIO Maybe和[]的fail函数都与第一个参数无关，直接返回空值（Nothing、[]）；而IO的fail函数直接使用failIO，实现方法也是深奥（接着逃 1234567exampleFail :: Maybe Char exampleFail = do (x:xs) &lt;- Just &quot;&quot; return x ghci&gt; exampleFailNothing 在这个例子的do语句中，在提取Just “”中的值时用了模式匹配，但是因为其内容为空字符串，x:xs匹配会出现错误，这时就会触发fail函数直接返回Nothing MonadFail Law fail s &gt;&gt;= m = fail s Semigroup半群（semigroup）是一个集合$S$，它需要指定一个二元运算符$\\oplus$，并且满足 $$a\\oplus b \\in S\\quad a, b\\in S$$ 以及结合（associative）律： $$(a\\oplus b)\\oplus c = a\\oplus (b\\oplus c)$$ 这个二元运算符在Haskell的Semigroup中被定义为&lt;&gt;函数： 12345678910class Semigroup a where (&lt;&gt;) :: a -&gt; a -&gt; a sconcat :: NonEmpty a -&gt; a sconcat (a :| as) = go a as where go b (c:cs) = b &lt;&gt; go c cs go b [] = b stimes :: Integarl b =&gt; b -&gt; a -&gt; a stimes = ... 除此之外还有sconcat和stimes函数，都给出了默认实现。对于列表，&lt;&gt;相当于(++)，stimes相当于concat . replicate： 123456ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; sconcat $ fromList [[1, 2], [3, 4]][1,2,3,4]ghci&gt; stimes 3 [1, 2][1,2,1,2,1,2] Semigroup Law (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) 补：NonEmptyNonEmpty表示非空列表，定义是： 1data NonEmpty a = a :| [a] deriving (Eq, Ord) 使用一个元素和一个列表用:|连接就可以生成一个NonEmpty类型的列表 Data.List.NonEmpty模块中实现了很多普通列表有的函数，需要qualified import后调用，使用fromList、toList函数可以在普通列表和非空列表之间转换 12345678ghci&gt; import qualified Data.List.NonEmpty as NEghci&gt; arr = NE.fromList [1, 2, 3]ghci&gt; arr1 :| [2,3]ghci&gt; NE.head arr 1ghci&gt; NE.tail arr [2,3] Monoid幺半群（Monoid）是一个有单位元素$e$的半群，即$e$满足： $$e\\oplus x = x\\oplus e = x$$ 12345678class Semigroup a =&gt; Monoid a where mempty :: a mappend :: a -&gt; a -&gt; a mappend = (&lt;&gt;) mconcat :: [a] -&gt; a mconcat = foldr mappend mempty 可以看出Monoid要求了三个函数，其中最少只需要mempty，它直接返回一个值，表示单位元素。mappend即Semigroup中的&lt;&gt;运算符，mconcat也提供了默认实现 实例[a]因为Monoid的实例是一个具体类型，而不是像Functor等一样等类型构造器，所以[]并不是Monoid的实例，但是具体类型[a]是一个幺半群： 123456instance Semigroup [a] where (&lt;&gt;) = (++)instance Monoid [a] where mempty = [] mconcat xss = [x | xs &lt;- xss, x &lt;- xs] 列表的单位元素(mempty)就是空列表[]，运算符就是合并列表(++)，mconcat也用列表推导重新实现提高效率 12345678ghci&gt; mempty :: [Int] []ghci&gt; [1, 2] &lt;&gt; [3, 4][1,2,3,4]ghci&gt; [1, 2] `mappend` [3, 4][1,2,3,4]ghci&gt; mconcat [[1,2], [3,4]][1,2,3,4] Ordering1234567instance Semigroup Ordering where LT &lt;&gt; _ = LT EQ &lt;&gt; y = y GT &lt;&gt; _ = GTinstance Monoid Ordering where mempty = EQ 主要可以用于比较字典序： 12ghci&gt; mconcat (zipWith compare &quot;abcd&quot; &quot;acbd&quot;)LT Sum &amp; Product对于数字，加法和乘法都满足结合律，所以对于Num，有两种实现Monoid的方式，但是不能为同一类型设置两种实例方式，所以Data.Monoid中提供了两个包装器————Sum和Product： 12newtype Sum a = Sum {getSum :: a} deriving (...)newtype Product a = Product {getProduct :: a} deriving (...) 它们使用Sum或Product来包装起一个数字，可以通过getSum或getProduct来获取其中的值 对于加法，二元操作为(+)，单位元素为0；对于乘法，二元操作为(*)，单位元素为1: 1234567891011instance Num a =&gt; Semigroup (Sum a) where (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Sum a) where mempty = Sum 0instance Num a =&gt; Semigroup (Product a) where (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)instance Num a =&gt; Monoid (Product a) where mempty = Product 1 12345678ghci&gt; Sum 5 &lt;&gt; Sum 6 &lt;&gt; Sum 10Sum {getSum = 21}ghci&gt; getSum . mconcat . fmap Sum $ [5, 6, 10]21ghci&gt; Product 5 &lt;&gt; Product 6 &lt;&gt; Product 10Product {getProduct = 300}ghci&gt; getProduct . mconcat . fmap Product $ [5, 6, 10]300 All &amp; Any和数字一样，布尔值也有两种实现Monoid的方式，因此Data.Monoid模块中也提供了两个包装器，分别实现了这两种Monoid： 12345678910111213141516newtype All = All { getAll :: Bool } deriving (...)instance Semigroup All where (&lt;&gt;) = coerce (&amp;&amp;)instance Monoid All where mempty = All Truenewtype Any = Any { getAny :: Bool } deriving (...)instance Semigroup Any where (&lt;&gt;) = coerce (||)instance Monoid Any where mempty = Any False 12345678ghci&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)Falseghci&gt; getAll (mconcat (map (\\x -&gt; All (even x)) [2,4,6,7,8]))Falseghci&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)Trueghci&gt; getAny (mconcat (map (\\x -&gt; Any (even x)) [2,4,6,7,8]))True Monoid a =&gt; Maybe a如果a是一个(幺)半群，那么Maybe a也是一个幺半群，单位元就是Nothing： 1234567instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b a &lt;&gt; Nothing = a Just a &lt;&gt; Just b = Just (a &lt;&gt; b)instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing 123456ghci&gt; Nothing &lt;&gt; Just &quot;andy&quot;Just &quot;andy&quot;ghci&gt; Just LT &lt;&gt; NothingJust LTghci&gt; Just (Sum 3) &lt;&gt; Just (Sum 4) Just (Sum {getSum = 7}) First &amp; Last对于Maybe也有两种实现Monoid的方法，即&lt;&gt;操作每次恒取左边和每次恒取右边（在没有Nothing的情况下），所以Data.Monoid模块中也提供了两个新的包装器：First和Last： 123456789101112131415161718newtype First a = First { getFirst :: Maybe a } deriving (...)instance Semigroup (First a) where First Nothing &lt;&gt; b = b a &lt;&gt; _ = ainstance Monoid (First a) where mempty = First Nothingnewtype Last a = Last { getLast :: Maybe a } deriving (...)instance Semigroup (Last a) where a &lt;&gt; Last Nothing = a _ &lt;&gt; b = binstance Monoid (Last a) where mempty = Last Nothing 12345678ghci&gt; getFirst (First (Just &quot;hello&quot;) &lt;&gt; First Nothing &lt;&gt; First (Just &quot;world&quot;))Just &quot;hello&quot;ghci&gt; getLast (Last (Just &quot;hello&quot;) &lt;&gt; Last Nothing &lt;&gt; Last (Just &quot;world&quot;))Just &quot;world&quot;ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10] Just 9ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10] Just 10 Min &amp; Max对于有界的类型，也有两种实现Monoid的方式，每次二元操作都取最小或最大。Data.Semigroup模块中提供了两个包装其器：Min和Max： 12345678910111213141516newtype Min a = Min { getMin :: a } deriving (...)instance Ord a =&gt; Semigroup (Min a) where (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Min a) where mempty = maxBoundnewtype Max a = Max { getMax :: a } deriving (...)instance Ord a =&gt; Semigroup (Max a) where (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)instance (Ord a, Bounded a) =&gt; Monoid (Max a) where mempty = minBound 12345678ghci&gt; Min 3 &lt;&gt; Min 5Min {getMin = 3}ghci&gt; Max 3 &lt;&gt; Max 5Max {getMax = 5}ghci&gt; getMin . mconcat . map Min $ [1,2,3] :: Int1ghci&gt; getMax . mconcat . map Max $ [1,2,3] :: Int3 元组当元组内的所有元素都是幺半群时，整个元组也是一个幺半群： 123456instance (Semigroup a, Semigroup b) =&gt; Semigroup (a, b) where (a,b) &lt;&gt; (a',b') = (a&lt;&gt;a',b&lt;&gt;b') stimes n (a,b) = (stimes n a, stimes n b)instance (Monoid a, Monoid b) =&gt; Monoid (a,b) where mempty = (mempty, mempty) 12ghci&gt; mconcat $ map (\\x -&gt; (Min x, Max x)) [1..10] :: (Min Int, Max Int)(Min {getMin = 1},Max {getMax = 10}) Monoid Laws mempty &lt;&gt; x = x x &lt;&gt; mempty = x (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z) Monoidal classesApplicative、Monad、Arrow都有有幺半群性质的子类型类，分别是Alternative、MonadPlus、ArrowPlus Alternative12345678910class Applicative f =&gt; Alternative f where -- | The identity of '&lt;|&gt;' empty :: f a -- | An associative binary operation (&lt;|&gt;) :: f a -&gt; f a -&gt; f a some :: f a -&gt; f [a] some v = (:) &lt;$&gt; v &lt;*&gt; many v many :: f a -&gt; f [a] many v = some v &lt;|&gt; pure [] 其中empty是幺半群中的单位元素，&lt;|&gt;是幺半群中的二元运算符。some和many是两个函数（意义还不懂） Alternative实例[]123instance Alternative [] where empty = [] (&lt;|&gt;) = (++) 和Monoid一样，单位元素是空列表，二元运算是列表合并 123456ghci&gt; [1,2,3] &lt;|&gt; empty &lt;|&gt; [4,5][1,2,3,4,5]ghci&gt; some [][]ghci&gt; many [][[]] Maybe1234instance Alternative Maybe where empty = Nothing Nothing &lt;|&gt; r = r l &lt;|&gt; _ = l Maybe作为Alternative的单位元素是Nothing，二元运算是始终取左边（当左边不为Nothing时） 123456ghci&gt; Nothing &lt;|&gt; Just 1 &lt;|&gt; Just 2 Just 1 ghci&gt; some NothingNothing ghci&gt; many Nothing Just [] ZipList123instance Alternative ZipList where empty = ZipList [] ZipList xs &lt;|&gt; ZipList ys = ZipList (xs ++ drop (length xs) ys) 1234&lt;&gt;getZipList $ ZipList [1,2] &lt;|&gt; ZipList [3,4,5,6][1,2,5,6]&lt;&gt;getZipList $ ZipList [1,2,3,4] &lt;|&gt; ZipList [3,4,5,6][1,2,3,4] Alternative Laws Monoid laws: 123empty &lt;|&gt; x = x x &lt;|&gt; empty = x (x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z) Left zero law：empty &lt;*&gt; f = empty以上的定律是都满足都，下面的定律只有部分满足： Right zero law：f &lt;*&gt; empty = empty （大部分包括Maybe、[]满足，IO不满足） Left distribution：(a &lt;|&gt; b) &lt;*&gt; c = (a &lt;*&gt; c) &lt;|&gt; (b &lt;*&gt; c) （Maybe、[]满足，IO及大部分parsers不满足） Right distribution：a &lt;*&gt; (b &lt;|&gt; c) = (a &lt;*&gt; b) &lt;|&gt; (a &lt;*&gt; c) （大部分不满足，但Maybe满足） Left catch：(pure a) &lt;|&gt; x = pure a （Maybe、IO、parsers满足，但[]不满足） 常用函数 asum :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a，相当于foldr (&lt;|&gt;) empty： 1234ghci&gt; asum [Nothing, Just 5, Just 3]Just 5ghci&gt; asum [[2],[3],[4,5]][2,3,4,5] guard :: (Alternative f) =&gt; Bool -&gt; f ()： 12guard True = pure ()guard False = empty MonadPlus123456class (Alternative m, Monad m) =&gt; MonadPlus m where mzero :: m a mzero = empty mplus :: m a -&gt; m a -&gt; m a mplus = (&lt;|&gt;) MonadPlus实例[]、Maybe都是MonadPlus的实例，mzero和mplus都由Alternative实现 MonadPlus Laws Monoid laws Left zero：mzero &gt;&gt;= f = mzero Right zero：m &gt;&gt; mzero = mzero 常用函数 msum = asum mfilter： 123mfilter p ma = do a &lt;- ma if p a then return a else mzero ArrowPlusArrowZero和ArrowPlus分别为Arrow设置了Monoid中的单位元素和二元运算符，使之成为了一个幺半群： 12345class Arrow arr =&gt; ArrowZero arr where zeroArrow :: b `arr` cclass ArrowZero arr =&gt; ArrowPlus arr where (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c) 一些其它typeclassesFoldableFoldable是表示可以折叠（fold）的类型类，在Data.Foldable中定义，这使得和fold相关的函数可以用在任意Foldable的实例类型上。它的定义是： 12345678910111213141516171819class Foldable t where fold :: Monoid m =&gt; t m -&gt; m foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m foldMap' :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b foldr1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a foldl1 :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a toList :: t a -&gt; [a] null :: t a -&gt; Bool length :: t a -&gt; Int elem :: Eq a =&gt; a -&gt; t a -&gt; Bool maximum :: Ord a =&gt; t a -&gt; a minimum :: Ord a =&gt; t a -&gt; a sum :: Num a =&gt; t a -&gt; a product :: Num a =&gt; t a -&gt; a {-# MINIMAL foldMap | foldr #-} 最少只要实现foldr和foldMap其中之一就可以使一个类型成为Foldable的实例，其它的函数都有由这两个函数提供的默认实现，而且这两个函数之间也有相互实现。因此只要实现foldr或foldMap一个函数就可以使用所有其它Foldable中的函数。foldr函数在前面已经有学过，foldMap的例子是： 123456ghci&gt; foldMap Sum [1, 3, 5]Sum {getSum = 9}ghci&gt; foldMap Product [1, 3, 5]Product {getProduct = 15}ghci&gt; foldMap (replicate 3) [1, 2, 3][1,1,1,2,2,2,3,3,3] Foldable实例[]、Maybe、Either a、(,) a都是Foldable的实例，标准容器库中的Map、Set等也都是Foldable的实例。也可以自定义二叉树类型，并使其成为Foldable的实例： 1234567data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)instance Foldable Tree where foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; Tree a -&gt; m foldMap f Empty = mempty foldMap f (Leaf x) = f x foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r 常用函数 asum :: (Alternative f, Foldable t) =&gt; t (f a) -&gt; f a，用&lt;|&gt;逐个连接所有元素 sequenceA_ :: (Applicative f, Foldable t) =&gt; t (f a) -&gt; f ()，由于丢弃结果，所以Foldable t就可以满足；因此不同于sequenceA需要Traversable traverse_ :: (Applicative f, Foldable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f () for_ :: (Applicative f, Foldable t) =&gt; t a -&gt; (a -&gt; f b) -&gt; f () TraversableTraversable是表示可遍历的类型类，在Data.Traversable模块中定义，它是Foldable的升级版，同时也是一个Functor，它的定义是： 123456class (Functor t, Foldable t) =&gt; Traversable t where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a) mapM :: Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b) sequence :: Monad m =&gt; t (m a) -&gt; m (t a) {-# MINIMAL traverse | sequenceA #-} 最少只需要实现traverse函数或者sequenceA函数。其中各个函数的功能通过类型签名也都能推测出来。但是其中mapM就是traverse，sequence就是sequenceA，它们存在只是历史遗留（ Traversable实例1234567891011121314151617instance Traversable Maybe where traverse _ Nothing = pure Nothing traverse f (Just x) = Just &lt;$&gt; f xinstance Traversable [] where {-# INLINE traverse #-} traverse f = foldr cons_f (pure []) where cons_f x ys = liftA2 (:) (f x) ysinstance Traversable (Either a) where traverse _ (Left x) = pure (Left x) traverse f (Right y) = Right &lt;$&gt; f yinstance Traversable ((,) a) where traverse f (x, y) = (,) x &lt;$&gt; f y... 上面的Tree也可以成为Traversable的实例： 123456789101112131415instance Functor Tree where fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b fmap g Empty = Empty fmap g (Leaf x) = Leaf $ g x fmap g (Node l x r) = Node (fmap g l) (g x) (fmap g r)instance Traversable Tree where traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; Tree a -&gt; f (Tree b) traverse g Empty = pure Empty traverse g (Leaf x) = Leaf &lt;$&gt; g x traverse g (Node l x r) = Node &lt;$&gt; traverse g l &lt;*&gt; g x &lt;*&gt; traverse g r Traversable LawsTraversable也有两条定律： traverse Identity = Identity traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f 其中Identity和Compose分别定义在Data.Functor.Identity和Data.Functor.Compose两个模块中： 12newtype Identity a = Identity { runIdentity :: a } deriving (...)newtype Compose f g a = Compose { getCompose :: f (g a) } deriving (...) BifunctorFunctor的实例的kind都是* -&gt; *，因此fmap只能将一个函数映射到一个值上。而Bifunctor（在Data.Bifunctor模块中定义）的实例的kind是* -&gt; * -&gt; *，而且它的bimap可以同时将两个函数映射到两个值上： 12345class Bifunctor p where bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d first :: (a -&gt; b) -&gt; p a c -&gt; p b c second :: (b -&gt; c) -&gt; p a b -&gt; p a c {-# MINIMAL bimap | first, second #-} 同时bimap和first,second之间也可以相互转换： 1234bimap f g = first f . second gfirst f = bimap f idsecond g = bimap id g 对于Functor，((,) e)和Either e才是Functor的实例，因为他们是* -&gt; *。但是对于Bifunctor，(,)和Either就是Bifunctor的实例： 12ghci&gt; bimap (+1) length (4, [1,2,3])(5,3) Bifunctor Laws bimap id id = id first id = id second id = id bimap (f . g) (h . i) = bimap f h . bimap g i first (f . g) = first f . first g second (f . g) = second f . second g CategoryHaskell中的Category将一般的函数推广到了普遍的态射上，它在Control.Category模块中，定义是： 123class Category cat where id :: cat a a (.) :: cat b c -&gt; cat a b -&gt; cat a c 它的实例有(-&gt;)和Kleisli m： 123instance Category (-&gt;) where id = GHC.Base.id (.) = (GHC.Base..) Kleisli是一个范畴，用来表示函数a -&gt; m b，Haskell中，它在Control.Arrow模块中定义： 12345678newtype Kleisli m a b = Kleisli { runKleisli :: a -&gt; m b }instance Monad m =&gt; Category (Kleisli m) where id :: Kleisli m a a id = Kleisli return (.) :: Kleisli m b c -&gt; Kleisli m a b -&gt; Kleisli m a c Kleisli g . Kleisli h = Kleisli (h &gt;=&gt; g) Category要满足的定律只有id是(.)操作的单位元，以及(.)操作是可结合的 同时Category还提供了两个函数&lt;&lt;&lt;和&gt;&gt;&gt;： 12345(&lt;&lt;&lt;) :: Category cat =&gt; cat b c -&gt; cat a b -&gt; cat a c(&lt;&lt;&lt;) = (.)(&gt;&gt;&gt;) :: Category cat =&gt; cat a b -&gt; cat b c -&gt; cat a c f &gt;&gt;&gt; g = g . f ArrowArrow将函数进一步抽象化，它定义在Control.Arrow模块中： 1234567class Category a =&gt; Arrow a where arr :: (b -&gt; c) -&gt; a b c first :: a b c -&gt; a (b, d) (c, d) second :: a b c -&gt; a (d, b) (d, c) (***) :: a b c -&gt; a b' c' -&gt; a (b, b') (c, c') (&amp;&amp;&amp;) :: a b c -&gt; a b c' -&gt; a b (c, c') {-# MINIMAL arr, (first | (***)) #-} 其中： arr函数将一个函数变成一个Arrow first函数将一个Arrow变成一个二元组间的Arrow，且只会对一个元素进行操作，第二个元素保持不变 second函数与first相反，第一个元素保持不变 ***函数是Arrow之间的parallel composition，对于函数: (g *** h) (x, y) = (g x, h y) &amp;&amp;&amp;函数是Arrow之间的fanout composition，对于函数: (g &amp;&amp;&amp; h) x = (g x, h x) 它的实例也有(-&gt;)和Kleisli： 1234567891011121314instance Arrow (-&gt;) where arr :: (b -&gt; c) -&gt; (b -&gt; c) arr g = g first :: (b -&gt; c) -&gt; ((b,d) -&gt; (c,d)) first g (x,y) = (g x, y)instance Monad m =&gt; Arrow (Kleisli m) where arr :: (b -&gt; c) -&gt; Kleisli m b c arr f = Kleisli (return . f) first :: Kleisli m b c -&gt; Kleisli m (b,d) (c,d) first (Kleisli f) = Kleisli (\\ ~(b,d) -&gt; do c &lt;- f b return (c,d) ) 常用函数： 1234567891011121314returnA :: Arrow a =&gt; a b breturnA = arr id(^&gt;&gt;) :: Arrow a =&gt; (b -&gt; c) -&gt; a c d -&gt; a b df ^&gt;&gt; a = arr f &gt;&gt;&gt; a(&gt;&gt;^) :: Arrow a =&gt; a b c -&gt; (c -&gt; d) -&gt; a b da &gt;&gt;^ f = a &gt;&gt;&gt; arr f(&lt;&lt;^) :: Arrow a =&gt; a c d -&gt; (b -&gt; c) -&gt; a b da &lt;&lt;^ f = a &lt;&lt;&lt; arr f(^&lt;&lt;) :: Arrow a =&gt; (c -&gt; d) -&gt; a b c -&gt; a b df ^&lt;&lt; a = arr f &lt;&lt;&lt; a Arrow notation类似do-notation，Arrow也提供了一套方便的语句： 1234proc x -&gt; do y &lt;- action1 -&lt; ... z &lt;- action2 -&lt; ... returnA -&lt; ... 其中proc代替了lambda表达式中的斜杠\\，-&lt;右边的为输入，左边的为接收输入的函数。比如，下面三种写法达成的效果是一样的： 12345678910111213141516171819202122232425262728f :: Int -&gt; (Int, Int)f = \\x -&gt; let y = 2 * x z1 = y + 3 z2 = y - 5 in (z1, z2) -- ghci&gt; f 10 -- (23,15)fM :: Int -&gt; Identity (Int, Int)fM = \\x -&gt; do y &lt;- return (2 * x) z1 &lt;- return (y + 3) z2 &lt;- return (y - 5) return (z1, z2)-- ghci&gt; runIdentity (fM 10)-- (23,15)fA :: Int -&gt; (Int, Int)fA = proc x -&gt; do y &lt;- (2 *) -&lt; x z1 &lt;- (+ 3) -&lt; y z2 &lt;- (subtract 5) -&lt; y returnA -&lt; (z1, z2)-- ghci&gt; fA 10-- (23,15) ArrowChoice12345678910111213141516171819202122232425262728293031class Arrow a =&gt; ArrowChoice a where left :: a b c -&gt; a (Either b d) (Either c d) left = (+++ id) right :: a b c -&gt; a (Either d b) (Either d c) right = (id +++) (+++) :: a b c -&gt; a b' c' -&gt; a (Either b b') (Either c c') f +++ g = left f &gt;&gt;&gt; arr mirror &gt;&gt;&gt; left g &gt;&gt;&gt; arr mirror where mirror :: Either x y -&gt; Either y x mirror (Left x) = Right x mirror (Right y) = Left y (|||) :: a b d -&gt; a c d -&gt; a (Either b c) d f ||| g = f +++ g &gt;&gt;&gt; arr untag where untag (Left x) = x untag (Right y) = yinstance ArrowChoice (-&gt;) where left f = f +++ id right f = id +++ f f +++ g = (Left . f) ||| (Right . g) (|||) = eitherinstance Monad m =&gt; ArrowChoice (Kleisli m) where left f = f +++ arr id right f = arr id +++ f f +++ g = (f &gt;&gt;&gt; arr Left) ||| (g &gt;&gt;&gt; arr Right) Kleisli f ||| Kleisli g = Kleisli (either f g) ArrowZero &amp; ArrowPlus1234567891011class Arrow a =&gt; ArrowZero a where zeroArrow :: a b cclass ArrowZero a =&gt; ArrowPlus a where (&lt;+&gt;) :: a b c -&gt; a b c -&gt; a b cinstance MonadPlus m =&gt; ArrowZero (Kleisli m) where zeroArrow = Kleisli (\\_ -&gt; mzero)instance MonadPlus m =&gt; ArrowPlus (Kleisli m) where Kleisli f &lt;+&gt; Kleisli g = Kleisli (\\x -&gt; f x `mplus` g x) 例子123456789101112131415161718192021222324252627282930ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) &lt;+&gt; (Kleisli (\\x -&gt; [x, -x]))) 2[4,2,-2]ghci&gt; either (+2) (*3) (Left 3)5ghci&gt; either (+2) (*3) (Right 3)9ghci&gt; (+2) ||| (*3) $ (Left 3)5ghci&gt; (+2) +++ (*3) $ (Left 3)Left 5ghci&gt; (+2) ||| (*3) $ (Right 3)9ghci&gt; (+2) +++ (*3) $ (Right 3)Right 9ghci&gt; left (+2) (Left 3)Left 5ghci&gt; right (*3) (Right 3)Right 9ghci&gt; left (+2) (Right 3)Right 3ghci&gt; right (*3) (Left 3)Left 3ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) ||| (Kleisli (\\x -&gt; [x, -x]))) (Left 3)[6]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) ||| (Kleisli (\\x -&gt; [x, -x]))) (Right 3)[3,-3]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) +++ (Kleisli (\\x -&gt; [x, -x]))) (Left 3)[Left 6]ghci&gt; runKleisli ((Kleisli (\\x -&gt; [x * 2])) +++ (Kleisli (\\x -&gt; [x, -x]))) (Right 3)[Right 3,Right (-3)] Haskell与范畴论Haskell中的函子单子等都与范畴论（category theory）有很多联系，所以打算简单了解一下范畴论的相关内容。 范畴论是数学的一门学科，以抽象的方法处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。数学中许多重要的领域可以形式化为范畴。使用范畴论可以令这些领域中许多难理解、难捉摸的数学结论更容易叙述证明。 ———— 维基百科 范畴（Category）范畴本质上是一个简单的集合，一个范畴$\\mathbf{C}$包含三个组成成分： 一个类$\\mathrm{ob}(\\mathbf{C})$：其中元素称为对象（objects） 一个类$\\mathrm{hom}(\\mathbf{C})$：其中元素称为态射（morphisms）（或箭号（arrows））：每个态射连接了两个对象：源对象（source object）、目标对象（target object）。如果$f$是从源对象$A$到目标对象$B$（$A, B\\in \\mathrm{ob}(\\mathbf{C})$）的态射，那么记为$f : A\\to B$ 一个二元运算，称为态射复合（composition）：两个态射$g : A\\to B$、$f : B\\to C$的复合记为$f\\circ g : A\\to C$在Haskell和大部分数学理论中都是从右向左计算，即$f\\circ g$中是先计算$g : A\\to B$再计算$f : B\\to C$ 许多东西都可以组成范畴。比如: &emsp;$\\mathbf{Set}$是一个范畴，对象为所有集合，态射为集合之间的函数，复合即函数之间的复合 &emsp;$\\mathbf{Grp}$是一个范畴，对象为所有群，态射为群同态（group homomorphisms），例如对于群$(G,*)$和$(H,\\cdot )$，有群同态$h : (G,*)\\to (H,\\cdot )$，则需要对于$G$中的任意元素$u,v$满足$$h(u*v)=h(u)\\cdot h(v)$$ 注意：态射不必须为函数；而且可以存在源对象和目标对象都相同的不同态射 范畴公理每个范畴都需要满足三条定律： 态射复合需要满足结合律（associativity）：$$f\\circ (g\\circ h) = (f\\circ g)\\circ h$$ 范畴在复合操作下是闭合的（closed）：&emsp;&emsp;&emsp;如果范畴$\\mathbf{C}$中存在态射$f : B\\to C$、$g : A\\to B$，那么范畴$\\mathbf{C}$中也一定存在态射$h : A\\to C$，且$h=f\\circ g$ 每个对象都需要有单位态射（identity morphisms）：&emsp;&emsp;&emsp;对于范畴$\\mathbf{C}$中的对象$A$，一定存在单位态射$\\mathrm{id}_A : A\\to A$，且对于每个态射$g : A\\to B$，一定有：$$g\\circ\\mathrm{id}_A = \\mathrm{id}_B\\circ g = g$$ $\\mathbf{Hask}$范畴范畴$\\mathbf{Hask}$的对象为Haskell中的类型（types），态射是Haskell中的函数，复合运算是(.)。即从类型A到类型B的函数 f :: A -&gt; B 就是$\\mathbf{Hask}$范畴中的一个态射。而函数 f :: B -&gt; C 、g :: A -&gt; B 的组合 f . g 就是一个新的函数 h :: A -&gt; C。 对于三条定律： 第一条显然满足：f . (g . h) = (f . g) . h 第二条也显然满足，如果有函数 f :: B -&gt; C 、g :: A -&gt; B，一定有函数 h = (f . g) :: A -&gt; C 对于第三条定律，Haskell中存在单位函数 id ，但id是多态（polymorphic）的，要为其指定类型使其变成单态（monomorphic）的。比如态射$\\mathrm{id}_A$在Haskell中就可以表示为 id :: A -&gt; A。并且显然满足第三条定律（其中 f :: A -&gt; B）：(id :: B -> B) . f = f . (id :: A -> A) = f 函子（Functors）一个范畴中的态射将两个对象联系起来，而函子则会将两个范畴联系起来。换句话说，函子就是从一个范畴到另一个范畴的变换。比如对于范畴$\\mathbf{C}$、$\\mathbf{D}$，定义函子$F : \\mathbf{C}\\to\\mathbf{D}$满足： 对于$\\mathbf{C}$中的任意对象$A$，在$\\mathbf{D}$中都有对象$F(A)$ 对于$\\mathbf{C}$中的任意态射$f : A\\to B$，在$\\mathbf{D}$中都有态射$F(f) : F(A)\\to F(B)$ 比如： &emsp;遗忘函子（forgetful functor）$U : \\mathbf{Grp}\\to\\mathbf{Set}$，将一个群映射到一个集合中，将群同态映射到集合间的函数 &emsp;幂集函子（power set functor）$P : \\mathbf{Set}\\to\\mathbf{Set}$，将一个集合映射到它的幂集，将原集合中的函数$f : A\\to B$映射到函数$P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$，即从$U\\subseteq A$到值域$f(U)\\subseteq B$的映射 &emsp;自函子（endofunctor）$1_{\\mathbf{C}} : \\mathbf{C}\\to\\mathbf{C}$，将一个范畴映射到它本身 函子公理函子$F : \\mathbf{C}\\to\\mathbf{D}$也需要满足两个公理： 对于任意对象$X\\in\\mathbf{C}$，恒有$F(\\mathrm{id}_X)=\\mathrm{id}_{F(X)}$ 对于态射$f : Y\\to Z$、$g : X\\to Y$，恒有$F(f\\circ g) = F(f)\\circ F(g)$ $\\mathbf{Hask}$范畴上的函子Haskell中的Functor定义是： 12class Functor (f :: * -&gt; *) where fmap :: (a -&gt; b) -&gt; f a -&gt; f b 对于Haskell中的Functor，它实际上是从$\\mathbf{Hask}$范畴（types）到它子范畴的变换。比如列表函子$\\mathtt{[]} : \\mathbf{Hask}\\to\\mathbf{Lst}$（其中$\\mathbf{Lst}$是所有Haskell中列表类型构成的范畴） 它也达成了范畴论中对于函子的要求。函子需要进行两个操作：将一个范畴中的对象映射到另一个范畴中、将一个范畴中的态射映射到另一个范畴中。以Maybe为例，它实现了函子的要求： Maybe是一个类型构造器，他可以将任意类型 T 变成新类型 Maybe T，相当于从$\\mathbf{Hask}$范畴的对象变成了$\\mathbf{Maybe}$范畴的对象 fmap函数接收一个 a -&gt; b 类型的函数，返回一个 Maybe a -&gt; Maybe b 类型的函数，相当于将$\\mathbf{Hask}$范畴中的态射$f : A\\to B$映射成了$\\mathbf{Maybe}$范畴中的态射$\\mathbf{Maybe}(f) : \\mathbf{Maybe}(A)\\to\\mathbf{Maybe}(B)$ 注意：时刻记住这里研究的是$\\mathbf{Hask}$范畴和它的子范畴，对象是类型而不是值，态射是函数也指的是从类型到类型 同时，Haskell中的Functor也满足函子公理： fmap id = id 即 fmap (id :: A -&gt; A) = (id :: f A -&gt; f A) fmap (f . g) = fmap f . fmap g 单子（Monads） 一个单子说白了不过就是自函子范畴上的一个幺半群而已 _(:з」∠)_ 自函子在前面说到过是从一个范畴到自身的一个函子，如范畴$\\mathbf{C}$上的自函子是$F : \\mathbf{C}\\to\\mathbf{C}$。自函子范畴就是对象都是自函子的范畴。幺半群和Haskell中学到的Monoid类型类一样，是一个有可结合二元运算和单位元的代数结构。因此单子就是一个自函子，而且它有可结合二元运算（Haskell中&gt;=&gt;）和单位元（Haskell中return）。 一个单子$M : \\mathbf{C}\\to\\mathbf{C}$还包含两个态射（对于范畴$\\mathbf{C}$中的所有对象$X$）： $\\mathrm{unit}_X^M : X\\to M(X)$ $\\mathrm{join}_X^M : M(M(X))\\to M(X)$ （当式子中的单子明显是$M$时，可以省略上标${}^M$） Haskell中Monad的定义是： 123class Functor m =&gt; Monad m where return :: a -&gt; m a (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b 其中很显然多态函数return对应了定义中的$\\mathrm{unit}$，但是&gt;&gt;=和$mathrm{join}$的对应关系并不明显。因此Haskell中有一个工具函数join，它的效果就是定义中的$\\mathrm{join}$，而且它可以和&gt;&gt;=互相定义： 12345join :: Monad m =&gt; m (m a) -&gt; m ajoin x = x &gt;&gt;= id(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b x &gt;&gt;= f = join $ fmap f x 所以Haskell中为Monad要求定义&gt;&gt;=就相当于定义了$\\mathrm{join}$ 例如，幂集函子$P : \\mathbf{Set}\\to\\mathbf{Set}$也是一个单子，可以为它定义$\\mathrm{unit}$和$\\mathrm{join}$两个态射。Haskell中的列表也可以近似看作幂集函子。 &emsp;态射/函数的类型： 幂集函子 Haskell中列表 一个集合$S$和一个态射$f : A\\to B$ 一个类型 T 和一个函数 f :: A -&gt; B $P(f) : \\mathcal{P}(A)\\to\\mathcal{P}(B)$ fmap f :: [A] -&gt; [B] $\\mathrm{unit}_S : S\\to\\mathcal{P}(S)$ return :: T -&gt; [T] $\\mathrm{join}_S : \\mathcal{P}(\\mathcal{P}(S))\\to\\mathcal{P}(S)$ join :: [[T]] -&gt; [T] &emsp;态射/函数的定义： 幂集函子 Haskell中列表 $(\\mathcal{P}(f))(S) = \\{f(a):a\\in S\\}$ fmap f xs = [ f a | a &lt;- xs ] $\\mathrm{unit}_S(x) = \\{x\\}$ return x = [x] $\\mathrm{join}_S(L) = \\bigcup L$ join xs = concat xs 单子公理给定一个单子$M : \\mathbf{C}\\to\\mathbf{C}$，和一个态射$f : A\\to B$（其中$A,B\\in \\mathbf{C}$），那么满足下面四条定律： $\\mathrm{join}\\circ M(\\mathrm{join})=\\mathrm{join}\\circ\\mathrm{join}$ $\\mathrm{join}\\circ M(\\mathrm{unit})=\\mathrm{join}\\circ\\mathrm{unit}=\\mathrm{id}$ $\\mathrm{unit}\\circ f = M(f)\\circ\\mathrm{unit}$ $\\mathrm{join}\\circ M(M(f)) = M(f)\\circ\\mathrm{join}$ 也可以很自然地将其转化为Haskell中的表述： join . fmap join = join . join join . fmap return = join . return = id return . f = fmap f . return join . fmap (fmap f) = fmap f . join 在Haskell中，使用&gt;&gt;=也有三个定律和这四个定律是等价的： return x &gt;&gt;= f = f x 123456 return x &gt;&gt;= f = join (fmap f (return x)) = join (fmap f . return $ x)= join (return (f x)) = join (return . f $ x)= join . return $ (f x)= id (f x)= f x m &gt;&gt;= return = m1234 m &gt;&gt;= return = join (fmap return m) = join . fmap return $ m = id m= m (m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g)123456789101112 (m &gt;&gt;= f) &gt;&gt;= g = (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))= join . fmap g . join $ fmap f m = join . join . fmap (fmap g) $ fmap f m = join . join . fmap (fmap g) . fmap f $ m = join . join . fmap (fmap g . f) $ m = join . fmap join . fmap (fmap g . f) $ m = join . fmap (join . (fmap g . f)) $ m = join . fmap (\\x -&gt; join (fmap g (f x))) $ m = join . fmap (\\x -&gt; f x &gt;&gt;= g) $ m = join (fmap (\\x -&gt; f x &gt;&gt;= g) m)= m &gt;&gt;= (\\x -&gt; f x &gt;&gt;= g) 有关do语句和&gt;=&gt;的公理表述在上文中已经说过 后记啃了将近一个月，算是把Haskell的主要内容都啃完了。主要就是前期看Learn You a Haskell，后期看Typeclassopedia，都是pdcxs推荐给的教程。但是一堆视频一个都没有耐心看进去qwq 后面的部分的理解感觉也没到位，Category、Arrow等这些类型类也就是大致地看了一眼，甚至有什么用都不太清楚_(:з」∠)_ 感觉Haskell这门语言确实很神奇，很多语法都很有意思，而且可以做到非常贴近数学、贴近数学概念。学的时候也是越学坑越多，先是函数式编程引申到了lambda演算，然后是函子等一系列概念引申到了范畴论，目前范畴论简单地看了一部分，lambda演算也没深入研究，以后有时间再说了（咕咕咕） 现在感觉我学到的Haskell简直是皮毛，还有一堆源码里的东西不知道是怎么回事（包括但不限于#，~），也还有一堆类型类和用法没有学到（包括但不限于Monad Transformer、Writer、Reader、State、Comonad、MonadFix、Lens、Parsec、……）md，这么一看差的还真多，以后有时间再慢慢学了，这个假期还有好多其它事要干呢，Haskell这边先摸了_(:з」∠)_ Reference Learn You a Haskell Writing foldl using foldr - StackOverflow Haskell：用foldr定义foldl Typeclassopedia - Haskell wiki Hoogle Functors, Applicatives, And Monads In Pictures Haskell学习 - functor Haskell语言学习笔记（8）Monoid - zwvista Haskell语言学习笔记（16）Alternative - zwvista Haskell语言学习笔记（40）Arrow（1） - zwvista 24 Days of GHC Extensions: Arrows - Tom Ellis Haskell语言学习笔记（47）Arrow（2） - zwvista Haskell/Category theory - wikibooks Category theory - wikipedia 范畴论 - 维基百科 Monad (category theory) - wikipedia Functor - wikipedia \"The End?\"","link":"/p/b3ca5c18.html"},{"title":"修复manim中Text类的bug","text":"在使用manim时,对于Text类,会有一些bug,我尝试修复了它们 在shaders分支下无法使用Text类 Text文字的stroke边框不完整,导致显示stroke会非常难看 含有空格的Text的空格不在文字内部,而在ORIGIN的位置,导致Transform时会有字符在原位置和ORIGIN之间 反复横跳 Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小 这些问题已经通过#1030修复到了manim的master分支中 $\\mathcal{Bug\\ 1.}$当在shaders分支下使用Text类时会出现如下报错:其中最后一行让我发现此时的p0和p1的大小不相等,不能相加(broadcast),而p0和p1是通过贝赛尔曲线的次数(在shaders下是3)来拆分self.points的所以可能是self.points的长度不为3的倍数,导致了错误.在print(len(self.points))后发现确实是这样然后我又用了 玄学 手段,删掉了SVGMobject的最后一个点,发现可以正常渲染 此时我又去看了cairo自动生成的svg代码,根据我之前学svg的一点经验,发现每个&lt;path/&gt;的路径结尾都为Z M ... ... /&quot;&gt;而Z是将路径闭合,但闭合后又多出了一个M控制符,这会导致manim在处理svg时额外生成一个点而删掉每个路径字符串的最后一个M控制符,可以直接使用正则表达式匹配出来,然后替换掉 我第一个想到的正则表达式是Z M .*? /&quot;&gt;,但是如果在路径的中间出现Z M,则会将其后面有用的部分一起删除而有用的部分一定含有控制符,所以将控制符排除,就可以仅仅匹配掉最后一个M,正则表达式:Z M [^A-Za-z]*? /&quot;&gt; 123456def remove_last_M(self, file_name): with open(file_name, 'r') as fpr: content = fpr.read() content = re.sub(r'Z M [^[A-Za-z]*? &quot;\\/&gt;', 'Z &quot;/&gt;', content) with open(file_name, 'w') as fpw: fpw.write(content) $\\mathcal{Bug\\ 2.}$Text文字的stroke边框不完整,导致stroke显示不全,也会对DrawBorderThenFill造成影响,也有B站的观众向我提了这个问题 – 话说，感觉每个Chapter之间的文字是不是先画出轮廓再填充上色，画完轮廓的时候停顿了一下。但是停顿的时候轮廓没有画完，有些地方有点断续的感觉– Text类的bug，stroke日常乱套 为了解决这个问题,我只显示了stroke,并且用debugTeX标出了构成每个字符的self.points的位置,比如”manim”如下:通过观察和与@XiaoYoung交流之后,确定了cairo生成的svg并不能使路径自动闭合而在一般查看svg的软件(Chrome)中,svg图像只显示内部(fill),而stroke被忽略(很细),所以正常使用没问题但是在manim中有时需要使用stroke,这时cairo生成的svg出现了bug,路径没有完全闭合 我最开始的想法是直接通过.add_line_to()方法将svg收尾相连,但是这显然只解决了m和n而a和i是由两条路径复合而成的,其中的每条路径都没有闭合,所以都需要手动闭合,所以我决定遍历self.points这时我使用了一个last变量来记录遍历到当前位置所在的路径上的起点,并且如果到了下一条路径(索引为nppc的倍数,并且不与前一个点相重合),就将首尾连接上,并更新last 而这样做还需要一个特判,当points为空时(空格)直接跳过,否则points[0]会报错 12345678910111213nppc = self.n_points_per_cubic_curvefor each in self: if len(each.points) == 0: continue points = each.points last = points[0] each.clear_points() for index, point in enumerate(points): each.append_points([point]) if index != len(points) - 1 and (index + 1) % nppc == 0 and any(point != points[index+1]): each.add_line_to(last) last = points[index + 1] each.add_line_to(last) 这样做之后,这个bug就完全解决了,而且中文也同时适用,对比如下,上为修复之前,下为修复之后(都为仅显示stroke) $\\mathcal{Bug\\ 3.}$这个是非常常见的问题了,如下:之前解决这个问题是通过’假空格’,即用一个不常用字符表示空格,并将其设为背景色,或者opacity改成0通过debugTeX可以发现,Text的空格占字符而且位置在ORIGIN而TextMobject中的空格直接不占位置.所以我直接在处理bug2的同时,将len(each.points) == 0的处理中加上了self.remove(each),这样就暂时解决了而@XiaoYoung也提醒了我,这样的处理会干扰t2c的自动上色(下标改变了),在#1018这里,他决定单开一个pr来修复这个bug,所以我就把这一个commit删除掉了 $\\mathcal{Bug\\ 4.}$Text文字的默认大小要比TextMobject大,不容易像TextMobject一样控制大小通过阅读源码可以发现,TextMobject在__init__()的结尾,有一句 12if self.height is None: self.scale(TEX_MOB_SCALE_FACTOR) 而这个TEX_MOB_SCALE_FACTOR默认为0.05,即将默认的SVGMobject(高度为固定默认值)缩小为0.05倍而Text类最后缩小了0.1倍,导致了大小不等,将其改为0.05后,就方便统一大小了 $\\mathcal{Pull\\ Requests}$第一次提交pr,记录一下 将原repo fork到自己的用户上 clone下来fork的repo 进行更改,add/commit/push,commit的注释要规范 在GitHub网页上,打开fork的repo,会有一个按钮New Pull Request 比较,确认更改,然后Create Pull Request,表述出pr的必要性和验证,提交pr 等待repo管理员merge 这次修复bug的pr在#1030和#1031其中#1030被merge了,而#1031还在等待","link":"/p/b6815e8.html"},{"title":"树上莫队-笔记  &#x2F;「SPOJ 10707」COT2-题解","text":"通过SPOJ 10707 COT2-Count on a tree II这道题目来学习一下 树上莫队当需要离线查询 树上 的多区间问题时,可以使用 树上莫队 来解决 主要通过 欧拉序 将树转化为一条链,然后在链上执行普通莫队的操作 树上莫队欧拉序正常进行dfs,在入和出时各加入序列中比如样例的树如下:其欧拉序为1 2 2 3 5 5 6 6 7 7 3 4 8 8 4 1可以很好地呈现出子树的关系,即两个相同的数$x$之间的部分为$x$子树中的节点其有一个性质:区间内出现两次的点不在其路径上根据这个性质,可以将树转化为链来求解了 思想除了将树转化为欧拉序之外,还需要求出左右端点的$LCA$,以及一个点$\\texttt{u}$在欧拉序中第一次出现的位置$\\texttt{fst[u]}$,第二次(最后一次)出现的位置$\\texttt{lst[u]}$ 在进行莫队操作时,如果第一次经过这个点,则add其贡献,第二次经过这个点,则说明这个点不在所求链上,del其贡献这个用一个vis数组,反复进行异或操作就可以解决 再考虑询问的区间的$l,r$应该赋值为$\\texttt{fst}$还是$\\texttt{lst}$设左端点的深度小于右端点 如果$LCA$和左端点相等,则说明$[l,r]$在一条链上,$l$和$r$均取$\\texttt{fst}$即可 否则是两条链$[l, LCA],[LCA,r]$, 防止左右端点被统计两次导致贡献被删除,需要$l$取$\\texttt{lst}$,$r$取$\\texttt{fst}$ 最后考虑贡献 若是上面第一种情况,在一条链上,直接统计欧拉序区间内所有点即可,重复两次的根据前文的性质会直接删掉 若是上面第二种情况,由于左右端点都在$LCA$这颗子树内,所以区间中并不会出现$LCA$,但是却一定会经过,所以额外将$LCA$加入贡献,并且记录下当前结果之后,再将其贡献减去,防止影响下一个查询 注意: 转化为欧拉序之后的序列长度为$2n$ 时间复杂度 dfs: $O(n)$ 求$LCA$:$O(n\\log n)$ 莫队: $O(n\\sqrt{n})$ 综上,树上莫队的复杂度 差不多 也是$O(n\\sqrt{n})$ 针对$\\mathcal{SP10707}$的具体实现没啥说的,模板题,做法全在上面了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 200020;int n, m, l, r, Ans, len, ocnt;int cnt[maxn], fst[maxn], lst[maxn], vis[maxn], ans[maxn];int ord[maxn], val[maxn], dep[maxn], fa[maxn][25], old[maxn];struct Query { int l, r, id, pos, lca;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; if (a.pos &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;}struct Edge { int from, to; Edge(int f, int t): from(f), to(t) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int f, int t) { edges.push_back(Edge(f, t)); edges.push_back(Edge(t, f)); int mm = edges.size(); G[t].push_back(mm - 1); G[f].push_back(mm - 2);}void dfs(int u, int f) { ord[++ocnt] = u; fst[u] = ocnt; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to == f) continue; dep[e.to] = dep[u] + 1; fa[e.to][0] = u; for (int j = 1; j &lt;= 20; ++j) { fa[e.to][j] = fa[fa[e.to][j - 1]][j - 1]; } dfs(e.to, u); } ord[++ocnt] = u; lst[u] = ocnt;}int lca(int x, int y) { if (dep[x] &gt; dep[y]) swap(x, y); for (int i = 20; i &gt;= 0; --i) { if (dep[fa[y][i]] &gt;= dep[x]) y = fa[y][i]; } if (x == y) return x; for (int i = 20; i &gt;= 0; --i) { if (fa[x][i] != fa[y][i]) { x = fa[x][i]; y = fa[y][i]; } } return fa[x][0];}void add(int x) { cnt[val[x]]--; if (!cnt[val[x]]) Ans--;}void del(int x) { cnt[val[x]]++; if (cnt[val[x]] == 1) Ans++;}void chg(int x) { if (vis[x]) add(x); else del(x); vis[x] ^= 1;}int main() { n = read(); m = read(); len = sqrt(2 * n); for (int i = 1; i &lt;= n; ++i) old[i] = val[i] = read(); sort(old + 1, old + 1 + n); int len_ = unique(old + 1, old + 1 + n) - old - 1; for (int i = 1; i &lt;= n; ++i) val[i] = lower_bound(old + 1, old + 1 + len_, val[i]) - old; for (int i = 1; i &lt; n; ++i) add(read(), read()); dep[1] = 1; dfs(1, 0); for (int i = 1; i &lt;= m; ++i) { int il = read(), ir = read(); int LCA = lca(il, ir); if (fst[il] &gt; fst[ir]) swap(il, ir); if (il == LCA) { q[i].l = fst[il]; q[i].r = fst[ir]; } else { q[i].l = lst[il]; q[i].r = fst[ir]; q[i].lca = LCA; } q[i].id = i; q[i].pos = (q[i].l - 1) / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int i = 1; i &lt;= m; ++i) { while (l &lt; q[i].l) chg(ord[l++]); while (r &gt; q[i].r) chg(ord[r--]); while (l &gt; q[i].l) chg(ord[--l]); while (r &lt; q[i].r) chg(ord[++r]); if (q[i].lca) chg(q[i].lca); ans[q[i].id] = Ans; if (q[i].lca) chg(q[i].lca); } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/p/24f5ddbc.html"},{"title":"回滚莫队-笔记  &#x2F;「AtCoder 1219」歴史の研究-题解","text":"通过AtCoder 1219 歴史の研究这道题目来学习一下 回滚莫队回滚莫队 适用于容易进行add操作,而不容易实现del的情况 通过莫队的分块,指针移动的思想,可以让左指针进行回滚操作, 近似 达到del的效果 回滚莫队思想由于莫队对所有询问离线排序后,当左端点在同一个块内时,右端点递增所以对于每个块,右指针直接向右依次执行add操作即可 对于左指针,在一个块内时,可以每次都从块的右边界向左进行add,由于不方便进行del操作,所以可以先记录下左指针在右边界时的Ans,然后每次向左移动到q[i].l时,将左指针再移回右边界,并且将Ans回滚到移动之前的值。由于分块,这样做的复杂度也不会很大 综上,对于每个块,右指针依次向右推进,左指针在右边界和查询的左端点之间反复横跳这样,执行的就只剩add操作,通过左指针的横跳,避免了del操作 注意,当左右端点都在同一个块时,只要暴力求出结果就可以了一定要注意: 不要使用奇偶排序,必须保证右端点的 单调递增 对于每个块内的处理,大概如下图: 时间复杂度时间复杂度由以下几个方面组成 询问排序 同一个块内的暴力求解 左指针的移动(横跳) 右指针的顺次移动 下面来 不严谨 简要地计算一下时间复杂度 排序:$O(n\\log n)$ 暴力:暴力的区间最长为$\\sqrt{n}$,所以单次暴力的复杂度为$O(\\sqrt{n})$,$n$次暴力的复杂度为$O(n\\sqrt{n})$其实到不了n次 左指针移动: 进行add操作的复杂度为$O(1)$,块长$\\sqrt{n}$,每次左移最坏复杂度$O(\\sqrt{n})$,回滚时仍需要$O(\\sqrt{n})$清除贡献所以对于所有块,一共要移动$q$次,总的复杂度为$O(2q\\sqrt{n})$ 右指针移动: 对于每个块,最坏只要移动$n$次,一共$\\sqrt{n}$个块,所以复杂度为$O(n\\sqrt{n})$ 综上,总的复杂度为$O(n\\log n)+O(2q\\sqrt{n})+O(n\\sqrt{n})\\ \\sim\\ O(n\\sqrt{n})$ 针对$\\mathcal{AT1219}$的具体实现添加贡献的add操作很容易实现 1234void add(int x) { cnt[a[x]]++; Ans = max(Ans, 1LL * cnt[a[x]] * old[a[x]]);} 同一块内的暴力也很容易实现 123456789LL solve(int l, int r) { LL res = 0; for (int i = l; i &lt;= r; ++i) cnt2[a[i]] = 0; for (int i = l; i &lt;= r; ++i) { cnt2[a[i]]++; res = max(res, 1LL * cnt2[a[i]] * old[a[i]]); } return res;} 其余情况下根据前面所说,可以实现 123456while (r &lt; q[i].r) add(++r); // 右指针右移,添加贡献LL tmp = Ans; // 记录左指针移动前的答案while (l &gt; q[i].l) add(--l); // 左指针左移,添加贡献ans[q[i].id] = Ans;while (l &lt; rpos[k] + 1) cnt[a[l++]]--; // 左指针移动回右边界,并途中删除对cnt的贡献Ans = tmp; // 回滚到移动前的答案 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 100010;int n, m, len, l, r;int a[maxn], cnt[maxn], rpos[maxn], old[maxn], cnt2[maxn];LL Ans, ans[maxn];struct Query { int l, r, id, pos;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; return a.r &lt; b.r;}LL solve(int l, int r) { LL res = 0; for (int i = l; i &lt;= r; ++i) cnt2[a[i]] = 0; for (int i = l; i &lt;= r; ++i) { cnt2[a[i]]++; res = max(res, 1LL * cnt2[a[i]] * old[a[i]]); } return res;}void add(int x) { cnt[a[x]]++; Ans = max(Ans, 1LL * cnt[a[x]] * old[a[x]]);}int main() { n = read(); m = read(); len = sqrt(n); int num = ceil((double)n / len); for (int i = 1; i &lt;= num; ++i) rpos[i] = len * i; rpos[num] = n; for (int i = 1; i &lt;= n; ++i) old[i] = a[i] = read(); sort(old + 1, old + 1 + n); int len_ = unique(old + 1, old + 1 + n) - old - 1; for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(old + 1, old + 1 + len_, a[i]) - old; for (int i = 1; i &lt;= m; ++i) { q[i].l = read(); q[i].r = read(); q[i].id = i; q[i].pos = (q[i].l - 1) / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int k = 1, i = 1; k &lt;= num; ++k) { l = rpos[k] + 1, r = rpos[k], Ans = 0; memset(cnt, 0, sizeof(cnt)); while (q[i].pos == k) { if (q[i].l / len == q[i].r / len) { ans[q[i].id] = solve(q[i].l, q[i].r); i++; continue; } while (r &lt; q[i].r) add(++r); LL tmp = Ans; while (l &gt; q[i].l) add(--l); ans[q[i].id] = Ans; while (l &lt; rpos[k] + 1) cnt[a[l++]]--; Ans = tmp; i++; } } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%lld\\n&quot;, ans[i]); } return 0;}","link":"/p/7d7b5548.html"},{"title":"带修莫队-笔记  &#x2F;「Luogu P1903」数颜色-题解","text":"通过Luogu P1903 数颜色/维护序列这道题目来学习一下 带修莫队顾名思义,带修莫队 不仅要支持普通莫队的查询操作,还要支持数据中途的修改 比如这道题目,需要实现以下目标 查询$[L,R]$区间内不同颜色画笔的种数 将$pos$处的画笔替换为$color$颜色 达到这个目标,可以在普通莫队的基础上加一个时间维度,实现 带修莫队 带修莫队时间戳这里的每个查询的时间戳规定为 最近修改操作的时间戳,即最近一次修改是第几次修改修改操作会增加总时间戳,查询操作不会增加时间戳 思想在普通莫队的左右两个指针的基础之上 增加 一个 时间戳指针当左右端点及时间戳移动到均和当前查询的一致,就可以记录下当前答案 所以需要在普通莫队的基础之上加上修改时间戳的修改操作,并加上以下两个判断 12while (t &lt; q[i].t) chg(++t);while (t &gt; q[i].t) chg(t--); 当当前时间小于询问时间时,先将当前时间$+1$,再修改当当前时间大于询问时间时,先修改,再将当前时间$-1$ 与普通莫队还有一点不同:所有询问的排序方法,先按照左端点分块升序,再按照右端点 分块升序,最后按照时间戳升序这样复杂度才会达到最优,节省了一系列不必要的操作 时间复杂度当分块的大小为$n^{\\frac{2}{3}}$时,复杂度最小为$O(n^{\\frac{5}{3}})$具体分析见上一篇文章:浅析莫队算法的时间复杂度 针对$\\mathcal{P1903}$的具体实现在每个询问Query的结构体内加一个时间戳$t$,并且按照上文实现排序 12345678struct Query { int l, r, t, id;}q[maxn];bool cmp(Query a, Query b) { if (block[a.l] != block[b.l]) return block[a.l] &lt; block[b.l]; if (block[a.r] != block[b.r]) return block[a.r] &lt; block[b.r]; return a.t &lt; b.t;} 再建一个结构体Change,表示每次修改操作的数据,需要$pos$和$color$ 123struct Change { int pos, color;}c[maxn]; 正常的add/del操作不再赘述现在来看一下修改时间对应数据的操作 当当前时间的操作的位置$pos$在当前区间$[l,r]$时,对答案有影响,需要调整当前答案先将$pos$位置上的贡献删去,再将当前修改操作的$color$添加进去 将$pos$位置上的数与$color$交换,这样可以保证之后可以再换回来 实现如下: 1234567void chg(int t) { if (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) { if (--cnt[a[c[t].pos]] == 0) Ans--; // 删除贡献 if (cnt[c[t].color]++ == 0) Ans++; // 添加贡献 } swap(a[c[t].pos], c[t].color); // 交换} 另外这题修改数据后严重卡常,手动开了O3,Ofast,inline才过 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#pragma GCC optimize(3)#pragma GCC optimize(&quot;Ofast&quot;)#pragma GCC optimize(&quot;inline&quot;)#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 140000;int n, m, l, r, t, len, cntq, cntr, Ans;int a[maxn], cnt[1000010], ans[maxn], block[maxn];struct Query { int l, r, t, id;}q[maxn];bool cmp(Query a, Query b) { if (block[a.l] != block[b.l]) return block[a.l] &lt; block[b.l]; if (block[a.r] != block[b.r]) return block[a.r] &lt; block[b.r]; return a.t &lt; b.t;}struct Change { int pos, color;}c[maxn];void add(int x) { if (cnt[a[x]] == 0) Ans++; cnt[a[x]]++;}void del(int x) { if (cnt[a[x]] == 1) Ans--; cnt[a[x]]--;}void chg(int t) { if (l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= r) { del(c[t].pos); if (cnt[c[t].color] == 0) Ans++; cnt[c[t].color]++; } swap(a[c[t].pos], c[t].color);}int main() { n = read(); m = read(); len = pow(n, 2.0 / 3.0); for (int i = 1; i &lt;= n; ++i) { a[i] = read(); block[i] = (i - 1) / len + 1; } for (int i = 1; i &lt;= m; ++i) { char opt[10]; scanf(&quot;%s&quot;, opt); if (opt[0] == 'Q') { q[++cntq].l = read(); q[cntq].r = read(); q[cntq].id = cntq; q[cntq].t = cntr; } else { c[++cntr].pos = read(); c[cntr].color = read(); } } sort(q + 1, q + 1 + cntq, cmp); l = 1; for (int i = 1; i &lt;= cntq; ++i) { while (l &lt; q[i].l) del(l++); while (r &gt; q[i].r) del(r--); while (l &gt; q[i].l) add(--l); while (r &lt; q[i].r) add(++r); while (t &lt; q[i].t) chg(++t); while (t &gt; q[i].t) chg(t--); ans[q[i].id] = Ans; } for (int i = 1; i &lt;= cntq; ++i) { printf(&quot;%d\\n&quot;, ans[i]); } return 0;}","link":"/p/838c5e29.html"},{"title":"浅析莫队算法的时间复杂度","text":"这篇文章来记录一下莫队算法时间复杂度的简单(不严谨)计算 首先分析一下莫队算法的时间复杂度有哪些方面构成 对询问Query数组的排序 区间左指针的移动 区间右指针的移动 时间复杂度每个add/del操作的复杂度为$O(1)$ 排序使用sort可以在$O(n\\log n)$内完成 由于左指针在排序中被分块,所以又分为块内移动和块间移动 块内: 设每块中含左端点$x_i$个,由于每块大小为$\\sqrt{n}$,所以在块内移动的最坏复杂度为$O(x_i\\sqrt{n})$。因此对于所有块,将复杂度求和,即为$O(\\displaystyle\\sum_ix_i\\sqrt{n})=O(n\\sqrt{n})$ 块间: 左指针在每个块内移动之后,需要移动到下一个块内的左端点处,块间跳转最坏跨两个整块需要$O(2\\sqrt{n})$。总共需要跨$\\sqrt{n}-1$个块,所以复杂度为$O((\\sqrt{n}-1)\\times 2\\sqrt{n})\\sim O(n)$ 综上,左指针移动的复杂度为$O(n\\sqrt{n})$3. 当左指针在同一个块内时,右指针是有序的,因此当左指针在同一个块内时,右指针移动的最坏复杂度为$O(n)$即全部移动一遍。而每个块长度为$\\sqrt{n}$,总长为$n$,所以一共$\\sqrt{n}$个块,所以最坏复杂度为$O(n\\sqrt{n})$ 综上,普通莫队算法的时间复杂度为$$O(n\\log n)+O(n\\sqrt{n})+O(n\\sqrt{n})\\ \\sim\\ O(n\\sqrt{n})$$ 玄学的奇偶排序优化见图: 分块大小不为$\\sqrt{n}$还是和前面一样推复杂度,设块大小为$a&gt;1$ 排序: 需要$O(n\\log n)$ 左指针移动: 块内: $O(\\displaystyle\\sum_ix_ia)=O(na)$ 块间: $O((\\dfrac{n}{a}-1)\\times 2a)=O(n)$ 右指针移动: $O(n\\times \\dfrac{n}{a})=O(\\dfrac{n^2}{a})$ 综上,总的复杂度为$O(n\\log n)+O(na)+O(n)+O(\\dfrac{n^2}{a})=O(na+\\dfrac{n^2}{a})$根据均值不等式,若让上式复杂度最小,则需要$na=\\dfrac{n^2}{a}$,即$a=\\sqrt{n}$所以当含有左右两个指针时,分块大小为$\\sqrt{n}$时总复杂度最小,为$O(n\\sqrt{n})$ 带修莫队(三指针)还是设分块的大小为$a&gt;1$,注意带修莫队排序优先级:先左端点所在块,再右端点所在块,后时间戳大小 排序: $O(n\\log n)$ 左指针移动: 同上推导,复杂度为$O(na)$ 右指针移动: 相同右端点的块的复杂度同上$O(na)$,还有换左端点决定的块时的复杂度约为$O(\\dfrac{n^2}{a})$ 时间戳移动: 由排序优先级可见,只有当右端点所在块相同时才会移动时间戳,而每次移动最坏需要移动$\\sum t \\sim n$对于每个左端点相同的块,右端点块数为$\\dfrac{n}{a}$,左端点有$\\dfrac{n}{a}$个,所以一共需要$O(\\dfrac{n}{a}\\times\\dfrac{n}{a}\\times n)=O(\\dfrac{n^3}{a^2})$ 综上,总的复杂度为$O(n\\log n)+O(na)+O(na)+O(\\dfrac{n^2}{a})+O(\\dfrac{n^3}{a^2})\\ \\sim\\ O(na+\\dfrac{n^2}{a}+\\dfrac{n^3}{a^2})$ 由于$1&lt;a&lt;n$,所以$\\dfrac{\\dfrac{n^2}{a}}{\\dfrac{n^3}{a^2}}=\\dfrac{a}{n}&lt;1 \\Rightarrow \\dfrac{n^2}{a}&lt;\\dfrac{n^3}{a^2}$,所以原式可化为$O(na+\\dfrac{n^3}{a^2})$ 根据均值不等式,当$na=\\dfrac{n^3}{a^2}$时上式最小,即$a=\\sqrt[3]{n^2}=n^{\\frac{2}{3}}$所以含有三个指针时,分块大小为$n^{\\frac{2}{3}}$时总复杂度最小,为$O(n^{\\frac{5}{3}})=O(n\\sqrt[3]{n^2})$","link":"/p/681257d9.html"},{"title":"「网络流24题」总结及图示","text":"问题编号 问题名称 问题模型 转化模型 1 飞行员配对方案问题 二分图最大匹配 网络最大流 2 太空飞行计划问题 最大权闭合图 网络最小割 3 最小路径覆盖问题 有向无环图最小路径覆盖 网络最大流 4 魔术球问题 有向无环图最小路径覆盖 网络最大流 5 圆桌问题 二分图多重匹配 网络最大流 6 最长不下降子序列问题 最多不相交路径 网络最大流 7 试题库问题 二分图多重匹配 网络最大流 8 机器人路径规划问题 $IDA*$ $IDA*$ 9 方格取数问题 二分图点权最大独立集 网络最小割 10 餐巾计划问题 线性规划网络优化 最小费用最大流 11 航空路线问题 最长不相交路径 最小费用最大流 12 软件补丁问题 最小转移代价 最短路径 13 星际转移问题 网络判定 网络最大流 14 孤岛营救问题 分层图最短路径 最短路径 15 汽车加油行驶问题 分层图最短路径 最短路径 16 数字梯形问题 最大权不相交路径 最小费用最大流 17 运输问题 网络费用流量 最小费用最大流 18 分配问题 二分图最佳匹配 最小费用最大流 19 负载平衡问题 最小代价供求 最小费用最大流 20 深海机器人问题 线性规划网络优化 最小费用最大流 21 最长k可重区间集问题 最大权不相交路径 最小费用最大流 22 最长k可重线段集问题 最大权不相交路径 最小费用最大流 23 火星探险问题 线性规划网络优化 最小费用最大流 24 骑士共存问题 二分图最大独立集 网络最小割 二分图 最大匹配: 匈牙利/最大流 带权匹配: KM/费用流 最小点覆盖: =最大匹配 最小边覆盖: =总结点数-最大匹配 最大独立集: =总结点数-最大匹配 网络流 建立超级源点,超级汇点 点存在限制,拆成出入点,将出入点之间的边看做点,限制流量 建图考虑左右二部 超级源点向源点的边可以限制总流量 无源汇有容量下界:s-下界-&gt;v u-下界-&gt;t u-上界减下界-&gt;v,当满流时存在可行流 最小割中赋流量为inf则一定不会割去 一些求最大问题,可以用sum-最小割 最大权闭合图: 建图,最小割,仍和s相连的为最大权闭合图,权值和为sum-最小割 24题 直接建二分图,最大流求最大匹配 最大权闭合图,建边,实验和仪器之间保证不切割容量为inf,跑最小割,找与s相连的实验和仪器 最大独立集,总结点数-最大流 贪心 二分图多重匹配,s-&gt;左点集和右点集-&gt;t之间的边容量不为1(即可以选多次) 动态规划+按照动态规划的dp数组的意义建边求最大流 二分图多重匹配,类型-题目数-&gt;汇点,保证可选多个,存在满流则存在答案沿满流输出 $IDA*$爆搜,但洛谷数据应该有问题 抽象出两个点集,求最大独立集 按照题目说明建图,跑费用流 按照题目说明建图,跑费用流 将错误状态进行压缩,然后跑最短路 根据时间逐层建图,直到跑出可行流 将拥有钥匙进行压缩,跑最短路 建出分层图,跑最短路或者费用流 对三个规则分别建图,跑费用流 纯费用流 二分图最佳匹配,使用费用流 费用流,注意环形 按照题目要求建图,跑费用流 离散化,将区间转化为边,费用流 转化问题,变成21题,注意端点处理和垂直于x轴的线段 按照题目要求建图,跑费用流,方案dfs 将图上所有格点转化为两个点集,建二分图,求最大独立集 图示更新中","link":"/p/dccbc6bb.html"},{"title":"「Luogu P1494」小Z的袜子-题解","text":"题目传送门: 「Luogu P1494」小Z的袜子一道推公式，后使用莫队 玄学 优化的题目 题目大意给出$n$个袜子,第$i$只袜子的颜色为$c_i$有$m$个询问,用$L,R$表示在区间$[L,R]$中随机取袜子,求取出两只袜子颜色相同的概率(最简分数) 题解考虑区间$[L,R]$,其中颜色为$A$的袜子有$a$只,颜色为$B$的袜子有$b$只$…$ 取出两只袜子的总情况数为$$C_{R-L+1}^2=\\frac{(R-L+1)(R-L)}{2}$$取出两只袜子颜色都为$A$的情况数为$$C_a^2=\\frac{a(a - 1)}{2}$$所以,取出两只袜子颜色相同的情况数为$$\\sum_{i}C_i^2=C_a^2+C_b^2+…=\\frac{a(a-1)}{2}+\\frac{b(b-1)}{2}+…$$所以最终的概率为$$\\begin{aligned}P&amp;=\\frac{\\displaystyle\\sum_{i}C_i^2}{C_{R-L+1}^2}\\\\\\\\&amp;=\\dfrac{\\dfrac{a(a-1)}{2}+\\dfrac{b(b-1)}{2}+…}{ \\dfrac{(R-L+1)(R-L)}{2} }\\\\\\\\&amp;=\\dfrac{a^2+b^2+…-a-b-…}{(R-L+1)(R-L)}\\\\\\\\&amp;=\\dfrac{\\displaystyle\\sum_ii^2-\\displaystyle\\sum_ii}{(R-L+1)(R-L)}\\\\\\\\&amp;=\\dfrac{\\displaystyle\\sum_ii^2-(R-L+1)}{(R-L+1)(R-L)}\\end{aligned}$$所以要求的就是$\\displaystyle\\sum_ii^2$,可以用莫队来维护区间平方和得到 对于最终结果的表达式,令$a=$分子,$b=$分母,求出$ab$的最大公约数,并除去最终答案即为$a/b$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b); }const int maxn = 50010;struct Query { int l, r, pos, id;}q[maxn];bool cmp(Query a, Query b) { if (a.pos != b.pos) return a.pos &lt; b.pos; if (a.pos &amp; 1) return a.r &lt; b.r; return a.r &gt; b.r;}struct Answer { LL a, b;}ans[maxn];int n, m, l, r, Ans, len;LL c[maxn], cnt[maxn];void del(int x) { Ans -= cnt[c[x]] * cnt[c[x]]; cnt[c[x]]--; Ans += cnt[c[x]] * cnt[c[x]];}void add(int x) { Ans -= cnt[c[x]] * cnt[c[x]]; cnt[c[x]]++; Ans += cnt[c[x]] * cnt[c[x]];}int main() { n = read(); m = read(); len = sqrt(n); for (int i = 1; i &lt;= n; ++i) c[i] = read(); for (int i = 1; i &lt;= m; ++i) { q[i].l = read(); q[i].r = read(); q[i].id = i; q[i].pos = q[i].l / len + 1; } sort(q + 1, q + 1 + m, cmp); l = 1; for (int i = 1; i &lt;= m; ++i) { while (l &lt; q[i].l) del(l++); while (r &gt; q[i].r) del(r--); while (l &gt; q[i].l) add(--l); while (r &lt; q[i].r) add(++r); if (l == r) { ans[q[i].id].a = 0; ans[q[i].id].b = 1; continue; } LL a = Ans - (r - l + 1); LL b = 1LL * (r - l + 1) * (LL)(r - l); LL g = gcd(a, b); ans[q[i].id].a = a / g; ans[q[i].id].b = b / g; } for (int i = 1; i &lt;= m; ++i) { printf(&quot;%lld/%lld\\n&quot;, ans[i].a, ans[i].b); } return 0;}","link":"/p/49548215.html"},{"title":"「网络流24题」负载平衡问题-题解","text":"题目传送门: 「Luogu P4016」负载平衡问题 题目大意有$n$个环形的仓库,每个仓库存储一定数量的货物货物可以在相邻仓库之间搬运,最终达到每个仓货物数量一样的效果 求最少搬运次数 题解看题解说可以用数学方法推导,但是在24题里还是选择用费用流水过 先求出平均数,即目标然后将每个仓库的货物数减去平均数,得出需要移动的数量 如果大于$0$,则从 源点 向 该仓库 建一条 容量为差值,费用为$0$ 的边(需要转移出,对答案无贡献) 如果小于$0$,则从 该仓库 向 汇点 建一条 容量为差值绝对值,费用为$0$ 的边(吸收这些货物,对答案无贡献) 从 每个仓库 向 相邻两个仓库 建一条 容量为$inf$,费用为$1$ 的边(转移货物的数量无要求,对答案贡献为$1$) 注意建边3.需要考虑环形求出最小费用最大流,最小费用即为结果 因为费用流大前提是满足最大流,而且此图中源点出发的与流入汇点的边的容量和相等,所以最大流情况下一定会全部流过,即达到仓库货物数量平衡 代码1234567891011121314151617181920212223// 最小费用最大流模板省去了int num[110], tot;int main() { n = read(); s = 0; t = n + 1; for (int i = 1; i &lt;= n; ++i) { num[i] = read(); tot += num[i]; } tot /= n; for (int i = 1; i &lt;= n; ++i) { if (num[i] - tot &gt; 0) add(s, i, num[i] - tot, 0); if (num[i] - tot &lt; 0) add(i, t, tot - num[i], 0); if (i != 1) { add(i, i - 1, inf, 1); add(i - 1, i, inf, 1); } } add(1, n, inf, 1); add(n, 1, inf, 1); ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/b8624866.html"},{"title":"「网络流24题」运输问题-题解","text":"题目传送门: 「Luogu P4015」运输问题 题目大意$m$个仓库,$n$个商店,每个仓库有$a_i$个货物,每个商店需要$b_i$个货物需要从仓库运输货物到商店中,且第$i$个仓库运输到第$j$个商店费用为$c_{i,j}$ 求最小费用和最大费用 题解和P4015 分配问题一样将所有仓库和所有商店各分为一个点集 从 源点 向 每个仓库 建一条 容量为货物个数$a_i$,费用为$0$ 的边(有$a_i$个货物需要运出,且对答案无贡献) 从 每个商店 向 汇点 建一条 容量为货物个数$b_i$,费用为$0$ 的边(需要$b_i$个货物,且对答案无贡献) 从 每个仓库 向 每个商店 建一条 容量为$inf$,费用为对应费用 的边(每个仓库可以运出的最多货物不限制,且对答案工作为对应费用) 求出最小费用最大流和最大费用最大流即可 由于费用流的大前提是流量最大,所以一定满足题目中要求的供需平衡即$\\sum\\limits_{i=1}^{m}a_i=\\sum\\limits_{j=1}^{n}b_j$ 代码123456789101112131415161718192021222324252627282930313233343536373839// 费用流模板省略,在P4015题解那里有// 代码里为了方便把mn调换了int input1[110], input2[110], input3[110][110];int main() { n = read(); m = read(); s = 0; t = n + m + 1; for (int i = 1; i &lt;= n; ++i) { int c = read(); input1[i] = c; add(s, i, c, 0); } for (int i = 1; i &lt;= m; ++i) { int c = read(); input2[i] = c; add(i + n, t, c, 0); } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { int c = read(); input3[i][j] = c; add(i, j + n, inf, c); } } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); for (int i = 1; i &lt;= n; ++i) add(s, i, input1[i], 0); for (int i = 1; i &lt;= m; ++i) add(i + n, t, input2[i], 0); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { add(i, j + n, inf, input3[i][j]); } } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/152673e9.html"},{"title":"「网络流24题」分配问题-题解","text":"题目传送门: 「Luogu P4014」分配问题 题目大意有$n$件工作要分配给$n$个人做给出每个人做每个工件的效益$c_{i,j}$ 求最小效益和最大效益 题解裸的最小/大费用最大流将所有人和所有工作各分为一个点集 从 源点 向 所有人 建一条 容量为$1$,费用为$0$ 的边(只能选一次,且对答案无贡献) 从 所有工作 向 汇点 建一条 容量为$1$,费用为$0$ 的边(只能做一次,且对答案无贡献) 从 每个人 向 所有工作 建一条 容量为$1$,费用为对应效益 的边(只能做一种工作,且对答案工作为对应效益) 求出最小费用最大流和最大费用最大流 两个问之间要清空图并重建(因为求最大流过程中会修改flow) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 310;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost, int opt) { if (opt == 0) memset(d, 0x3f, sizeof(d)); else memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; bool judge; if (opt) judge = d[e.to] &lt; d[x] + e.cost; else judge = d[e.to] &gt; d[x] + e.cost; if (e.cap &gt; e.flow &amp;&amp; judge) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (!opt &amp;&amp; d[t] == inf) return false; if (opt &amp;&amp; d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost, 0)); return flow;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost, 1)); return flow;}int tmp[110][110];int main() { n = read(); s = 0; t = n * 2 + 1; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { int c = read(); tmp[i][j] = c; add(i, j + n, 1, c); } } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1, 0); add(i + n, t, 1, 0); } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { add(i, j + n, 1, tmp[i][j]); } } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1, 0); add(i + n, t, 1, 0); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/11b1dcbd.html"},{"title":"「网络流24题」数字梯形问题-题解","text":"题目传送门: 「Luogu P4013」数字梯形问题 题目大意梯形的第一行有$m$个数字从梯形的顶部的$m$个数字开始,在每个数字处可以沿左下或右下方向移动,形成一条从梯形的顶至底的路径。 有三种规则: 从梯形的顶至底的$m$条路径互不相交 从梯形的顶至底的$m$条路径仅在数字结点处相交 从梯形的顶至底的$m$条路径允许在数字结点相交或边相交 求每种规则下经过数字的最大总和 题解很明显是 最大费用最大流 规则1.路径不相交,即没有公共点,也就是每个点只能经过一次将每个点拆成入点和出点,就可以通过控制出入点之间的容量控制经过次数 从 源点 向 第一行的$m$个点的入点 接一条 容量为$1$,费用为$0$ 的边 从 最后一行每个点的出点 接一条 容量为$1$,费用为$0$ 的边 从 每个点的入点 向 每个点的出点 接一条 容量为$1$,费用为该点数字 的边(对答案贡献为该点数字) 从 每个点的出点 向 左下右下两个点的入点 接一条 容量为$1$,费用为$0$ 的边 规则2.每条路径仅在数字节点相交,也就是不能有重边无需拆点控制每个点经过的次数,只需给每条向左下右下的边的容量设为$1$,即只能经过一次 从 源点 向 第一行的$m$个点 接一条 容量为$1$,费用为$0$ 的边 从 最后一行每个点 接一条 容量为$inf$,费用为该点数字 的边(每个点可以使用多次) 从 每个点的 向 左下右下两个点 接一条 容量为$1$,费用为该点数字 的边 规则3.边也可以重合,也就相当于没有规则,可以随意向左下右下走只需将规则2.中建边3.的容量改成$inf$即可 对于每种情况,求出最大费用最大流,最大费用即为答案注意求解规则2.3.之前要清空建的图 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 最大费用最大流模板部分省去了int in[45][45];int point[45][45], cnt;int main() { m = read(); n = read(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m + i - 1; ++j) { in[i][j] = read(); point[i][j] = ++cnt; } } // Question 1 s = 0; t = cnt * 2 + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i] + cnt, t, 1, 0); for (int i = 1; i &lt;= n; ++i) { if (i &lt; n) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j] + cnt, point[i + 1][j], 1, 0); add(point[i][j] + cnt, point[i + 1][j + 1], 1, 0); } for (int j = 1; j &lt;= m + i - 1; ++j) add(point[i][j], point[i][j] + cnt, 1, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); // Question 2 edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); s = 0; t = cnt + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i], t, inf, in[n][i]); for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j], point[i + 1][j], 1, in[i][j]); add(point[i][j], point[i + 1][j + 1], 1, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); // Question 3 edges.clear(); for (int i = 0; i &lt; maxn; ++i) G[i].clear(); s = 0; t = cnt + 1; for (int i = 1; i &lt;= m; ++i) add(s, point[1][i], 1, 0); for (int i = 1; i &lt;= n + m - 1; ++i) add(point[n][i], t, inf, in[n][i]); for (int i = 1; i &lt; n; ++i) for (int j = 1; j &lt;= m + i - 1; ++j) { add(point[i][j], point[i + 1][j], inf, in[i][j]); add(point[i][j], point[i + 1][j + 1], inf, in[i][j]); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/86b4c1f9.html"},{"title":"「网络流24题」深海机器人问题-题解","text":"题目传送门: 「Luogu P4012」深海机器人问题 题目大意一个$P\\times Q$网格,机器人可以向北/东走,西南为$(0, 0)$,东北为$(Q, P)$每个网格边上有生物标本,和价值有$a$个起点,每个起点有不同的机器人个数有$b$个终点,每个终点有不同的机器人个数作为目的地 求采集到生物标本的最高总价值 题解最大费用最大流 每两个节点之间建一条 容量为$1$,费用为标本价值 的边,和一条 容量为$inf$,费用为$0$ 的边(标本只能采集一次) 从 源点 向 每个起点 建一条 容量为机器人个数,费用为$0$ 的边 从 每个终点 向 汇点 建一条 容量为机器人个数,费用为$0$ 的边 跑出最大费用最大流,最大费用即为结果 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 410;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int p_, q_;int point(int x, int y) { return (x - 1) * q_ + y;}int main() { int a_ = read(), b_ = read(); p_ = read() + 1; q_ = read() + 1; s = 0, t = p_ * q_ + 1; for (int i = 1; i &lt;= p_; ++i) { for (int j = 1; j &lt; q_; ++j) { int w = read(); add(point(i, j), point(i, j + 1), 1, w); add(point(i, j), point(i, j + 1), inf, 0); } } for (int i = 1; i &lt;= q_; ++i) { for (int j = 1; j &lt; p_; ++j) { int w = read(); add(point(j, i), point(j + 1, i), 1, w); add(point(j, i), point(j + 1, i), inf, 0); } } for (int i = 1; i &lt;= a_; ++i) { int k = read(), x = read() + 1, y = read() + 1; add(s, point(x, y), k, 0); } for (int i = 1; i &lt;= b_; ++i) { int r = read(), x = read() + 1, y = read() + 1; add(point(x, y), t, r, 0); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/cfb1d422.html"},{"title":"「网络流24题」孤岛营救问题-题解","text":"题目传送门: 「Luogu P4011」孤岛营救问题 题目大意起点为$(1,1)$,终点为$(n,m)$有些格子上有若干个钥匙，两个格子之间可能有一堵墙或者一扇可以用对应钥匙打开的门每次移动需要$1$个单位时间，其他动作不需要时间 求最少需要多少时间能从起点到达终点。 题解对拥有的钥匙状态进行压缩从起点到终点跑bfs即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 20;const int go[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};int n, m, p, k;int cnt[maxn][maxn], key[maxn][maxn][maxn];bool vis[maxn][maxn][1 &lt;&lt; 15];int edge[maxn][maxn][maxn][maxn];struct Node { int x, y; int keys, times; Node(int x, int y, int k, int t): x(x), y(y), keys(k), times(t) {}};queue&lt;Node&gt; q;int bfs() { int skey = 0; for (int i = 1; i &lt;= cnt[1][1]; ++i) skey |= (1 &lt;&lt; (key[1][1][i] - 1)); q.push(Node(1, 1, skey, 0)); vis[1][1][skey] = true; while (!q.empty()) { Node u = q.front(); q.pop(); if (u.x == n &amp;&amp; u.y == m) return u.times; for (int k = 0; k &lt; 4; ++k) { int vx = u.x + go[k][0], vy = u.y + go[k][1]; if (vx &lt; 1 || vx &gt; n || vy &lt; 1 || vy &gt; m) continue; int e = edge[u.x][u.y][vx][vy]; if (e &lt; 0 || (e &gt; 0 &amp;&amp; !(1 &lt;&lt; (e - 1) &amp; u.keys))) continue; int vkeys = 0; for (int i = 1; i &lt;= cnt[vx][vy]; ++i) vkeys |= (1 &lt;&lt; (key[vx][vy][i] - 1)); int nxtkeys = u.keys | vkeys; if (vis[vx][vy][nxtkeys]) continue; q.push(Node(vx, vy, nxtkeys, u.times + 1)); vis[vx][vy][nxtkeys] = true; } } return -1;}int main() { n = read(); m = read(); p = read(); k = read(); for (int i = 1; i &lt;= k; ++i) { int x1 = read(), y1 = read(), x2 = read(), y2 = read(); int g = read(); edge[x1][y1][x2][y2] = ((g == 0) ? -1 : g); edge[x2][y2][x1][y1] = edge[x1][y1][x2][y2]; } int s = read(); for (int i = 1; i &lt;= s; ++i) { int x1 = read(), y1 = read(), q = read(); key[x1][y1][++cnt[x1][y1]] = q; } int ans = bfs(); printf(&quot;%d\\n&quot;, ans); return 0;}","link":"/p/5c532c45.html"},{"title":"「网络流24题」汽车加油行驶问题-题解","text":"题目传送门: 「Luogu P4009」汽车加油行驶问题 题目大意给出一个$N\\times N$的网格,表示有加油站的位置汽车要从$(1, 1)$走到$(N, N)$,装满油可以行驶$K$条边,且只能沿边行驶服从以下规则 可以无费用向右或向下走,但耗1点油 向左走或者向上走时需要付费用$B$,并耗1点油 在加油站处,若油没满,则必须付费用$A$,加满油 可在没有加油站的位置开设加油站,费用$C$,并加满油,付费$A$ 在起点处,油量为$K$ 求出最小费用 题解明显是最小费用最大流(其实分层图最短路也可以解决,因为每条边的容量都为1)分层建图,每层表示油量,第$0$层表示满油($K$),第$1$层表示油量为$K-1$,第$2$层表示油量为$K-2$,$…$ 对于每层每个节点,如果不是加油站,则从 该点 向 下一层的右边和下边的节点 接一条 容量为$1$,费用为$0$ 的边(规则1.) 对于每层每个节点,如果不是加油站,则从 该点 向 下一层的左边和上边的节点 接一条 容量为$1$,费用为$B$ 的边(规则2.) 对于每个节点,如果是加油站,则从 第$0$层的该点 按照上两条建边 对于每个节点,如果是加油站,则从 除$0$层外的每层节点 向 第$0$层的该点 接一条 容量为$1$,费用为$A$ 的边(规则3.) 对于每个节点,如果不是加油站,则从 第$K$层的该点 向 第$0$层的该点 接一条 容量为$1$,费用为$A+C$ 的边(规则4.) 从 源点 向 第$0$层的$(1, 1)$节点 接一条 容量为$1$,费用为$0$ 的边 从 每层的$(N, N)$节点 向 汇点 接一条 容量为$1$,费用为$0$ 的边(到终点不考虑油量) 求出最小费用最大流即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 200010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0x3f, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int N, K, A, B, C;int in[110][110];int point(int x, int y, int dep) { return (x - 1) * N + y + dep * N * N;}int main() { N = read(); K = read(); A = read(); B = read(); C = read(); s = 0; n = (K + 1) * N * N; t = n + 1; for (int i = 1; i &lt;= N; ++i) for (int j = 1; j &lt;= N; ++j) { in[i][j] = read(); if (in[i][j]) { for (int k = 1; k &lt;= K; ++k) { add(point(i, j, k), point(i, j, 0), 1, A); } } for (int k = 0; k &lt; K; ++k) { if (in[i][j] &amp;&amp; k) break; if (i + 1 &lt;= N) add(point(i, j, k), point(i + 1, j, k + 1), 1, 0); if (j + 1 &lt;= N) add(point(i, j, k), point(i, j + 1, k + 1), 1, 0); if (i - 1 &gt;= 1) add(point(i, j, k), point(i - 1, j, k + 1), 1, B); if (j - 1 &gt;= 1) add(point(i, j, k), point(i, j - 1, k + 1), 1, B); } if (!in[i][j]) add(point(i, j, K), point(i, j, 0), 1, A + C); } add(s, point(1, 1, 0), 1, 0); for (int k = 0; k &lt;= K; ++k) { add(point(N, N, k), t, 1, 0); } ansflow = MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/fab3e888.html"},{"title":"「网络流24题」最长k可重线段集问题-题解","text":"题目传送门: 「Luogu P3357」最长k可重线段集问题 题目大意给定一个开线段的集合$\\mathbf{I}$,从$\\mathbf{I}$中取出一些开线段,组成集合$\\mathbf{S}$使对于任何一条直线$x=p$,满足$\\mathbf{S}$中与$x=p$相交的线段数不超过$k$,且$\\mathbf{S}$中开线段总长度最大 求最大的长度 题解和「Luogu P3358」最长k可重区间集问题类似仅修改一下区间的输入部分即可 将每条线段映射到x轴上,发现可能不对,因为可能会存在垂直于x轴的线段,像P3358一样建图会省略掉这条线段 所以要将每个点扩大一倍,将左右端点x坐标相同的区间$(x, x)$更改为$(2x, 2x+1)$,使得不存在与x轴垂直的线段如果左右端点x坐标不相同,则将$(x_1, x_2)$更改为$(2x_1+1, 2x_2)$ 大概就是这么个道理: 剩下的做法和P3358一样,P3358题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}struct Interval { int l, r, len;}inter[510];int nums[1020], old[1020];int length(int a, int b, int c, int d) { return (int)sqrt((long long)(a - c) * (a - c) + (long long)(b - d) * (b - d));}int main() { int n_ = read(), k = read(); for (int i = 1; i &lt;= n_; ++i) { int a = read(), b = read(), c = read(), d = read(); inter[i].len = length(a, b, c, d); inter[i].l = a * 2; inter[i].r = c * 2; if (a == c) inter[i].r += 1; else inter[i].l += 1; nums[i * 2 - 1] = inter[i].l; nums[i * 2] = inter[i].r; } for (int i = 1; i &lt;= n_ * 2; ++i) old[i] = nums[i]; sort(old + 1, old + 1 + n_ * 2); int len = unique(old + 1, old + 1 + n_ * 2) - old - 1; for (int i = 1; i &lt;= n_ * 2; ++i) nums[i] = lower_bound(old + 1, old + 1 + len, nums[i]) - old; for (int i = 1; i &lt;= n_; ++i) { inter[i].l = nums[i * 2 - 1]; inter[i].r = nums[i * 2]; } s = 0; n = len + 2; t = n - 1; add(s, 1, k, 0); for (int i = 1; i &lt;= len; ++i) { add(i, i + 1, inf, 0); } for (int i = 1; i &lt;= n_; ++i) { add(inter[i].l, inter[i].r, 1, inter[i].len); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/f48af49a.html"},{"title":"「网络流24题」最长k可重区间集问题-题解","text":"题目传送门: 「Luogu P3358」最长k可重区间集问题 题目大意给定一个开区间的集合$\\mathbf{I}$,从$\\mathbf{I}$中取出一些开区间,组成集合$\\mathbf{S}$使对于任何一个$x$,满足$\\mathbf{S}$中包含$x$的区间数不超过$k$,且$\\mathbf{S}$中开区间总长度最大 求最大的长度 题解如果两个区间没有重叠的话,则可以同时选择,在图上表现为串联如果两个区间有重叠的话,则不能同时选择,在图上表现为并联(服从总流量的约束)先对所有节点进行离散化,注意离散化前统计出区间的长 从 源点 向 节点1 接一条 容量为$k$,费用为$0$ 的边(最大容量为k,对答案无贡献) 从 每个节点$i$ 向 节点$i+1$ 接一条 容量为$inf$,费用为$0$ 的边(可以随意通过,对答案无贡献) 从 最后一个节点 向 汇点 接一条 容量为$inf$,费用为$0$ 的边(总流量有1.控制,对答案无贡献)(可以包含在2.里) 从 每个区间的左端点 向 其右端点 接一条 容量为$1$,费用为区间长 的边(只可用一次,对答案贡献为区间长度) 求出最大费用最大流,最大费用即为最终的结果样例的图如下: 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}struct Interval { int l, r, len;}inter[510];int nums[1020], old[1020];int main() { int n_ = read(), k = read(); for (int i = 1; i &lt;= n_; ++i) { inter[i].l = read(); inter[i].r = read(); inter[i].len = inter[i].r - inter[i].l; nums[i * 2 - 1] = inter[i].l; nums[i * 2] = inter[i].r; } for (int i = 1; i &lt;= n_ * 2; ++i) old[i] = nums[i]; sort(old + 1, old + 1 + n_ * 2); int len = unique(old + 1, old + 1 + n_ * 2) - old - 1; for (int i = 1; i &lt;= n_ * 2; ++i) nums[i] = lower_bound(old + 1, old + 1 + len, nums[i]) - old; for (int i = 1; i &lt;= n_; ++i) { inter[i].l = nums[i * 2 - 1]; inter[i].r = nums[i * 2]; } s = 0; n = len + 2; t = n - 1; add(s, 1, k, 0); for (int i = 1; i &lt;= len; ++i) { add(i, i + 1, inf, 0); } for (int i = 1; i &lt;= n_; ++i) { add(inter[i].l, inter[i].r, 1, inter[i].len); } ansflow = MaxCostMaxFlow(anscost); printf(&quot;%d\\n&quot;, anscost); return 0;}","link":"/p/949e7ebf.html"},{"title":"「网络流24题」火星探险问题-题解","text":"题目传送门: 「Luogu P3356」火星探险问题 题目大意有$n$辆车,$p\\times q$的网格为0可以通过,1有障碍不能通过,2为岩石可以采集从(1, 1)开始到最右下角,只能向右或向下 求出使到达终点的车最多,而且采集的岩石最多的移动方案 题解将每个位置拆成入点和出点 如果这个位置是$0$或$2$, 则从 入点 向 出点 接一条 容量为$inf$, 费用为$0$ 的边 如果这个位置是$2$, 则从 入点 向 出点 接一条 容量为$1$, 费用为$1$ 的边 如果这个位置$u$的右边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 容量为$inf$, 费用为$0$ 的边 如果这个位置$u$的下边$v$是不是$1$, 则从 $u$的出点 向 $v$的入点 接一条 容量为$inf$, 费用为$0$ 的边 跑最大费用最大流,最大流数即到达终点最多的车数输出方案使用dfs,在流量网络中搜索输出路径 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 4010;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], pre[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; pre[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; pre[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[pre[u]].from) { edges[pre[u]].flow += a[t]; edges[pre[u] ^ 1].flow -= a[t]; } return true;}int MaxCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int p, q;int in[40][40];int point(int x, int y) { return (x - 1) * p + y;}void dfs(int x, int y, int u, int id) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; Edge&amp; ne = edges[G[u][i] ^ 1]; if (e.to == s || e.to == t || e.to == u - n) continue; if (!e.flow) continue; e.flow--; if (e.to &gt; n) { dfs(x, y, e.to, id); return; } int nx, ny, dir; if (e.to == point(x, y) + 1) { nx = x; ny = y + 1; dir = 1; } else { nx = x + 1; ny = y; dir = 0; } printf(&quot;%d %d\\n&quot;, id, dir); dfs(nx, ny, e.to + n, id); return; }}int main() { int c = read(); p = read(); q = read(); n = p * q; s = 0; t = 2 * n + 1; for (int i = 1; i &lt;= q; ++i) { for (int j = 1; j &lt;= p; ++j) { in[i][j] = read(); if (in[i][j] == 0) add(point(i, j), point(i, j) + n, inf, 0); if (in[i][j] == 2) { add(point(i, j), point(i, j) + n, inf, 0); add(point(i, j), point(i, j) + n, 1, 1); } } } if (in[1][1] != 1) add(s, 1, c, 0); for (int i = 1; i &lt;= q; ++i) { for (int j = 1; j &lt;= p; ++j) { if (in[i][j] == 1) continue; if (in[i][j + 1] != 1 &amp;&amp; j + 1 &lt;= p) add(point(i, j) + n, point(i, j + 1), inf, 0); if (in[i + 1][j] != 1 &amp;&amp; i + 1 &lt;= q) add(point(i, j) + n, point(i + 1, j), inf, 0); } } if (in[q][p] != 1) add(point(q, p) + n, t, c, 0); ansflow = MaxCostMaxFlow(anscost); // printf(&quot;%d %d\\n&quot;, ansflow, anscost); for (int i = 1; i &lt;= ansflow; ++i) { dfs(1, 1, 1, i); } return 0;}","link":"/p/e7256d1.html"},{"title":"manim教程系列-颜色 笔记","text":"这篇文章是在写 manim教程系列视频 的 颜色 部分时做的一些笔记,包括 整个视频的结构 和 写代码时了解的一些用法的笔记视频已经发布,地址:BV1vZ4y1x7hT 视频结构大纲 开头 开始,标题,展示所有要将的方法 颜色的表示 所有constants.py中的颜色常量 使用hex表示颜色 使用rgb的ndarray表示颜色 颜色之间的转换 rgb_to_hex hex_to_rgb color_to_rgb rgb_to_color color_to_int_rgb 颜色的运算函数 invert_color color_gradient interpolate_color average_color random_color 设置颜色 Mobject略,一般上色的都为VMobject color分为stroke_color和fill_color 传入color, stroke_color, fill_color set_color, set_stroke, set_fill方法的color和opacity 给子物体上色 set_color set_color_by_gradient set_colors_by_radial_gradient 光泽与渐变色 set_sheen set_color中使用列表达到渐变色 一些码视频时的笔记 isinstance函数检测对象的类型 对一个字符串进行format时,想要用空格补齐左边到一定个数,可以使用str(...).rjust(num) 涉及到TransformText的地方,在Text里面不可以有空格,需要用白色的~来做出伪空格 字符串中查找一个字符的下标可以用.index(&quot; &quot;, beg=..., end=...)方法来查找第一次出现的位置,第二次出现需要传入beg为第一次位置+1 manim的rgb_to_color函数传入的rgb的值为01,不是0255 用for循环遍历字典键值对for key, value in dic.items():,遍历其中一部分for key, value in list(dic.items())[1:3]将键值对转化为列表,并用切片 Arrow的箭头为.tip .keys(),.values()不为列表,需要套在list()里面 set_colors_by_radial_gradient利用中心与center的距离对颜色进行插值,radius外的所有子物体全为outer_color颜色 含有sheen_factor的物体设置渐变色后与sheen_factor无关","link":"/p/2e2c9a7.html"},{"title":"「网络流24题」骑士共存问题-题解","text":"题目传送门: 「Luogu P3355」骑士共存问题 题目大意给出$n\\times n$的棋盘,$m$个障碍(骑士不能放置)求最多可以放多少个骑士,不能互相攻击 题解先对棋盘进行黑白二染色,$x+y$为奇数和偶数为黑和白,求二分图最大独立集 从 源点 向 黑色节点 接一条 容量为1 的边 从 白色节点 向 汇点 接一条 容量为1 的边 从 每个黑色节点 向 其能攻击到的白色节点接一条 容量为$inf$ 的边 求出最小割即最大流,结果为$\\mathtt{n\\times n - m - maxflow}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 40010;const int inf = 0x3f3f3f3f;const int go[8][2] = { {-1, 2}, {1, 2}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {-2, -1}, {-2, 1}};int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int point(int x, int y) { return (x - 1) * n + y;}bool valid[210][210];int main() { n = read(); m = read(); s = 0; t = n * n + 1; for (int i = 1; i &lt;= m; ++i) { int x = read(), y = read(); valid[x][y] = true; } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if ((i + j) &amp; 1) { if (!valid[i][j]) { add(s, point(i, j), 1); } } else { if (!valid[i][j]) { add(point(i, j), t, 1); } } } } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if (!((i + j) &amp; 1)) continue; for (int k = 0; k &lt; 8; ++k) { int nx = i + go[k][0]; int ny = j + go[k][1]; if (1 &lt;= nx &amp;&amp; nx &lt;= n &amp;&amp; 1 &lt;= ny &amp;&amp; ny &lt;= n &amp;&amp; !valid[nx][ny]) { add(point(i, j), point(nx, ny), inf); } } } } int maxflow = dinic(s, t); printf(&quot;%d\\n&quot;, n * n - m - maxflow); return 0;}","link":"/p/11da5c27.html"},{"title":"「网络流24题」圆桌问题-题解","text":"题目传送门: 「Luogu P3254」圆桌问题 题目大意有$m$个单位,$n$个餐桌第$i$个单位的代表人数$r_i$, 第$i$张餐桌能容纳的人数$c_i$同一个单位的代表不能在同一个餐桌 若有一种方案,输出$1$,并输出方案若没有方案,输出$0$ 题解二分图,左点集为单位,右点集为餐桌,求其 最大匹配 对于每个单位,从 这个点 向 所有餐桌 接一条 容量为1 的边(即每个餐桌只能容纳同一个单位的一个人) 从 源点 向 每个单位 接一条 容量为单位人数 的边(即每个单位所有人都要参加) 从 每个餐桌 向 汇点 接一条 容量为餐桌人数 的边 如果最大流和所有单位总人数相等,则有可行方案对于每个单位,输出出边满足$\\mathtt{e.cap == e.flow}$的$\\mathtt{e.to-m}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 450;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int tot;int main() { m = read(); n = read(); s = 0; t = m + n + 1; for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { add(i, j + m, 1); } } for (int i = 1; i &lt;= m; ++i) { int r = read(); tot += r; add(s, i, r); } for (int i = 1; i &lt;= n; ++i) { int c = read(); add(i + m, t, c); } int maxflow = dinic(s, t); if (maxflow == tot) { printf(&quot;1\\n&quot;); for (int u = 1; u &lt;= m; ++u) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to != s &amp;&amp; e.cap == e.flow) { printf(&quot;%d &quot;, e.to - m); } } printf(&quot;\\n&quot;); } } else { printf(&quot;0\\n&quot;); } return 0;}","link":"/p/25e68a12.html"},{"title":"「网络流24题」方格取数问题-题解","text":"题目传送门: 「Luogu P2774」方格取数问题 题目大意$m$行$n$列的方格图,每个方格中有一个正整数从方格中取数,任意两个数所在方格没有公共边求取出的数的最大总和 题解先选择所有方格,然后考虑删去一些方格相邻$-&gt;$奇偶性不同,构成一个二分图,含有两个点集 从 源点 向 点集$A$ 接一条 容量为点权 的边 从 点集$B$ 向 汇点 接一条 容量为点权 的边 从 点集$A$中每个点 向 与其相邻的在点集$B$中的点 接一条 容量为$inf$ 的边(保证不被割) 求出最小割即最大流即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 10010;const int inf = 0x3f3f3f3f;const int go[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};int n, m, s, t, d[maxn], cur[maxn], tot;struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int point(int x, int y) { return (x - 1) * n + y;}int main() { m = read(); n = read(); s = 0; t = n * m + 1; for (int i = 1; i &lt;= m; ++i) { for (int j = 1; j &lt;= n; ++j) { int a = read(); tot += a; if ((i + j) % 2 == 0) { add(s, point(i, j), a); for (int k = 0; k &lt; 4; ++k) { int nx = i + go[k][0]; int ny = j + go[k][1]; if (1 &lt;= nx &amp;&amp; nx &lt;= m &amp;&amp; 1 &lt;= ny &amp;&amp; ny &lt;= n) { add(point(i, j), point(nx, ny), inf); } } } else { add(point(i, j), t, a); } } } int maxflow = dinic(s, t); printf(&quot;%d\\n&quot;, tot - maxflow); return 0;}","link":"/p/40e04941.html"},{"title":"「网络流24题」航空路线问题-题解","text":"题目传送门: 「Luogu P2770」航空路线问题 题目大意给出一个城市,$n$个点,$v$条边,每个城市有一个名字从西向东按序给出名字求从最西出发到达最东并返回最西(除起点外,每个城市只能访问一次)的路径 题解将每个城市拆成入点和出点 源点为点1的入点,汇点为点n的出点 对于 除源点汇点 的每个点, 从 入点 向 出点 建一条 容量为1,费用为1 的边(只能经过一次,且对答案贡献为1) 从 点1的入点 向 点1的出点 建一条 容量为2,费用为1 的边(可以经过2次,且对答案贡献为1) 从 点n的入点 向 点n的出点 建一条 容量为2,费用为1 的边(可以经过2次,且对答案贡献为1) 对于边$&lt;u, v&gt;$, 从 u的出点 向 v的入点 建一条 容量为1,费用为0 的边(可经过1次,对答案无贡献) 求 最大费用最大流, 最大流$maxflow\\leq 2$ 若最大流为$2$, 则会有一条道路, 经过的城市数为最大费用$maxcost-2$(减去重复的源点和汇点的贡献)求路径可以 先一次dfs找到从1到n的所有残量为0的路径(满流$\\mathtt{e.cap == e.flow}$),正序输出 再一次dfs找到另一条满流路径,并用vis确保没有重复城市,倒序输出(不重复输出n) 若最大流为$1$, 则直接从源点到汇点有一条通路, 输出$2$, 路径为$1-&gt;n-&gt;1$ 若最大流为$0$, 则无解$\\texttt{No Solution!}$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 210;const int inf = 0x3f3f3f3f;const int ninf = 0xc0c0c0c0;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { memset(d, 0xc0, sizeof(d)); memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &lt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == ninf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}string name[maxn];map&lt;string, int&gt; id;void dfs1(int u) { vis[u] = true; cout &lt;&lt; name[u - n] &lt;&lt; endl; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to &lt;= n &amp;&amp; e.cap == e.flow) { dfs1(e.to + n); break; } }}void dfs2(int u) { for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (e.to &lt;= n &amp;&amp; e.cap == e.flow &amp;&amp; !vis[e.to + n]) { dfs2(e.to + n); } } cout &lt;&lt; name[u - n] &lt;&lt; endl;}int main() { n = read(); m = read(); s = 1; t = 2 * n; for (int i = 1; i &lt;= n; ++i) { cin &gt;&gt; name[i]; id[name[i]] = i; } for (int i = 1; i &lt;= m; ++i) { string str1, str2; cin &gt;&gt; str1; cin &gt;&gt; str2; int u = id[str1], v = id[str2]; if (u &gt; v) swap(u, v); add(u + n, v, 1, 0); } for (int i = 2; i &lt; n; ++i) { add(i, i + n, 1, 1); } add(s, s + n, 2, 1); add(n, t, 2, 1); int maxflow = MinCostMaxFlow(anscost); if (maxflow == 2) { printf(&quot;%lld\\n&quot;, anscost - 2); } else if (maxflow == 1) { printf(&quot;2\\n&quot;); cout &lt;&lt; name[1] &lt;&lt; &quot;\\n&quot; &lt;&lt; name[n] &lt;&lt; &quot;\\n&quot; &lt;&lt; name[1] &lt;&lt; endl; return 0; } else { printf(&quot;No Solution!\\n&quot;); return 0; } memset(vis, 0, sizeof(vis)); dfs1(1 + n); dfs2(1 + n); return 0;}","link":"/p/6bb5462a.html"},{"title":"「网络流24题」最长不下降子序列问题-题解","text":"题目传送门: 「Luogu P2766」最长不下降子序列问题 题目大意给定正整数序列$x_1, x_2, …, x_n$ 计算其 最长不下降子序列 的长度$S$ 如果每个元素只允许使用一次,计算从给定的序列中最多可取出多少个长度为$S$的不下降子序列 如果允许在取出的序列中多次使用$x_1$和$x_n$,其他元素仍然只允许使用一次,则从给定序列中最多可取出多少个 不同 的长度为$S$的不下降子序列 题解第一问动态规划状态转移方程:$\\mathtt{f[i]=max_{1≤j&lt;i&amp;&amp;x_j≤x_i}\\{f[j]+1\\}}$初值: $\\mathtt{f[0]=0}$结果: $\\mathtt{max_{1\\leq i\\leq n}f[i]}$ 第二问将每个点(索引)拆成两个点应用了分层图的思想, 把图每个顶点$\\mathtt{i}$按照$\\mathtt{f[i]}$的不同分为了若干层这样图中从$s$出发到$t$的任何一条路径都是一个满足条件的最长上升子序列由于序列中每个点要不可重复地取出,需要把每个点拆分成两个点单位网络的最大流就是增广路的条数,所以最大流量就是第二问结果。 从 源点 向 每个$\\mathtt{f[i]==1}$的点i的左点 建一条 容量为1 的边 从 每个点的左点 向 其右点 建一条 容量为1 的边 从 $\\mathtt{f[i]==S}$的点i的右点 向 汇点 建一条 容量为1 的边 对于$j&lt;i$,若$\\mathtt{x_j\\leq x_i &amp;&amp; f[i] == f[j] + 1}$,则从 点j的右点 向 点i的左点 建一条 容量为1 的边 第三问要求$x_1$和$x_n$可以重复使用,只需取消这两个点相关边的流量限制,求网络最大流即可 从 源点 向 点1的左点 建一条 容量为$inf$ 的边 从 点1的左点 向 点1的右点 建一条 容量为$inf$ 的边 若$\\mathtt{f[n]==S}$则从 点n的左点 向 点n的右点 建一条 容量为$inf$ 的边 若$\\mathtt{f[n]==S}$则从 点n的右点 向 汇点 建一条 容量为$inf$ 的边 注意判断当$n==1$时的情况(第三问答案会出现$inf$) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 2010;const int inf = 0x3f3f3f3f;int s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int n, num[510], dp[510], ans1, ans2, ans3; int main() { n = read(); for (int i = 1; i &lt;= n; ++i) { num[i] = read(); } // Question 1 for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt; i; ++j) { if (num[j] &lt;= num[i] &amp;&amp; dp[j] &gt; dp[i]) dp[i] = dp[j]; } dp[i]++; ans1 = max(ans1, dp[i]); } printf(&quot;%d\\n&quot;, ans1); // Question 2 s = 0, t = 2 * n + 1; for (int i = 1; i &lt;= n; ++i) if (dp[i] == 1) add(s, i, 1); for (int i = 1; i &lt;= n; ++i) add(i, i + n, 1); for (int i = 1; i &lt;= n; ++i) if (dp[i] == ans1) add (i + n, t, 1); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt; i; ++j) if (num[j] &lt;= num[i] &amp;&amp; dp[i] == dp[j] + 1) add(j + n, i, 1); ans2 = dinic(s, t); printf(&quot;%d\\n&quot;, ans2); // Question 3 if (n == 1) { printf(&quot;1\\n&quot;); return 0; } add(s, 1, inf); add(1, 1 + n, inf); if (dp[n] == ans1) { add(n, n + n, inf); add(n + n, t, inf); } ans3 = ans2 + dinic(s, t); printf(&quot;%d\\n&quot;, ans3); return 0;}","link":"/p/a66cf8af.html"},{"title":"「网络流24题」太空飞行计划问题-题解","text":"题目传送门: 「Luogu P2762」太空飞行计划问题 题目大意有$m$个实验，每个实验只可以进行一次，但会获得相应的奖金有$n$个仪器，每个实验都需要一定的仪器，每个仪器可以运用于多个实验，但需要一定的价值 问奖金与代价的差的最大值是多少？ 题解 从源点向每个实验建 容量为实验奖金 的边 从每个仪器向汇点建 容量为仪器费用 的边 实验向对应仪器建 容量为$inf$ 的边(保证不被割) 然后求最小割即最大流,只会割断 源-&gt;实验 或者 仪器-&gt;汇 的点最后一次bfs后,仍和源相连的实验/仪器为要进行的实验/需要的仪器 最大收益为所有支付的费用之和减最大流 样例的建边见下图: 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;bool endr = false;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} if (ch == '\\r') endr = true; return x * f;}const int maxn = 110;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], cur[maxn], tot;struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int main() { int m_ = read(), n_ = read(); n = m_ + n_ + 2; s = 0; t = n - 1; for (int i = 1; i &lt;= m_; ++i) { int p = read(); tot += p; add(s, i, p); char tools[10000]; memset(tools, 0, sizeof(tools)); cin.getline(tools, 10000); int ulen = 0, tool; while (sscanf(tools + ulen, &quot;%d&quot;, &amp;tool) == 1) { add(i, tool + m_, inf); if (tool == 0) ulen++; else { while (tool) { tool /= 10; ulen++; } } ulen++; } } for (int i = 1; i &lt;= n_; ++i) { int c = read(); add(i + m_, t, c); } int ans = dinic(s, t); for (int i = 1; i &lt;= m_; ++i) { if (vis[i]) printf(&quot;%d &quot;, i); } printf(&quot;\\n&quot;); for (int i = 1; i &lt;= n_; ++i) { if (vis[i + m_]) printf(&quot;%d &quot;, i); } printf(&quot;\\n&quot;); printf(&quot;%d\\n&quot;, tot - ans); return 0;}","link":"/p/f5a4cbbc.html"},{"title":"「网络流24题」软件补丁问题-题解","text":"题目传送门: 「Luogu P2761」软件补丁问题 题目大意$n$个错误,$m$个补丁 第$i$个补丁耗时$t_i$使用该补丁需要软件中包含所有$B1_i$中的错误,并且不包含$B2_i$中的任何一个错误该补丁可以修复错误$F1_i$,但会添加错误$F2_i$ 找出修复所有错误的最短时间 题解错误较少,可以使用状态压缩,用2进制表示错误的修复情况(1表示未修复,0表示已修复)起始状态$\\texttt{111…1}$,结束状态$\\texttt{000…0}$ 每个状态当做图中的节点,即求起始状态到结束状态的最短路 由于补丁较少,不用连边,在最短路需要遍历边时,遍历所有补丁,并判断是否能够联通(即当前状态是否包含该补丁的$B1$,而不包含$B2$)如果能够连接,则下一个状态为当前状态打上当前补丁(即修复$F1$,添加$F2$)边权为当前补丁的耗时使用SPFA跑最短路即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}inline int read_() { char ch = getchar(); while (ch != '+' &amp;&amp; ch != '-' &amp;&amp; ch != '0') ch = getchar(); if (ch == '+') return 1; else if (ch == '-') return 2; return 0;}const int inf = 0x3f3f3f3f;struct DLL { int time; int b1, b2; int f1, f2;}node[110];int n, m, s, t;int dis[1 &lt;&lt; 21];bool vis[1 &lt;&lt; 21];void SPFA(int s) { memset(dis, 0x3f, sizeof(dis)); dis[s] = 0; vis[s] = true; queue&lt;int&gt; q; q.push(s); while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = false; for (int i = 1; i &lt;= m; ++i) { if ((u &amp; node[i].b1) == node[i].b1 &amp;&amp; (u &amp; node[i].b2) == 0) { int v = ((u | node[i].f1) | node[i].f2) ^ node[i].f1; if (dis[v] &gt; dis[u] + node[i].time) { dis[v] = dis[u] + node[i].time; if (!vis[v]) { q.push(v); vis[v] = true; } } } } }}int main() { n = read(); m = read(); s = (1 &lt;&lt; n) - 1; t = 0; for (int i = 1; i &lt;= m; ++i) { node[i].time = read(); for (int j = 0; j &lt; n; ++j) { int sta = read_(); if (sta == 1) node[i].b1 |= (1 &lt;&lt; j); if (sta == 2) node[i].b2 |= (1 &lt;&lt; j); } for (int j = 0; j &lt; n; ++j) { int sta = read_(); if (sta == 2) node[i].f1 |= (1 &lt;&lt; j); if (sta == 1) node[i].f2 |= (1 &lt;&lt; j); } } SPFA(s); printf(&quot;%d\\n&quot;, dis[t] == inf ? 0 : dis[t]); return 0;}","link":"/p/2f9adffb.html"},{"title":"「网络流24题」家园&#x2F;星际转移问题-题解","text":"题目传送门: 「Luogu P2754」家园/星际转移问题 题目大意1个地球,$n$个太空站,1个月球,$k$个人$m$艘船,第$i$艘容纳$h_i$个人,停靠$r_i$站,分别为$S_{i,j}$,每次耗时1初始人全在地球,结束人全在月球 求最短时间 题解先根据输入的停靠位置,建立并查集,若地月不连通,则无解,输出$0$ 再根据时间建边,时间每增加1,增加一层,求一次最大流,添加进答案当答案大于$k$时,即可全部到达月球 样例的建图是这样: 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 5010;const int inf = 0x3f3f3f3f;int n, m, s, t, d[maxn], ans, cur[maxn];int ufs[25];int find(int x) { return (ufs[x] == x) ? x : ufs[x] = find(ufs[x]);}void unionn(int x, int y) { int fx = find(x), fy = find(y); if (fx != fy) ufs[fx] = fy;}struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int dinic(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, inf); } return flow;}int S[25][25];int main() { n = read(); m = read(); int k = read(); s = 0; t = n + 1; for (int i = 1; i &lt;= n + 1; ++i) ufs[i] = i; for (int i = 1; i &lt;= m; ++i) { S[0][i] = read(); S[i][0] = read(); for (int j = 1; j &lt;= S[i][0]; ++j) { S[i][j] = read(); if (S[i][j] == -1) S[i][j] = n + 1; if (j &gt; 1) unionn(S[i][j], S[i][j - 1]); } } if (find(s) != find(t)) { printf(&quot;0\\n&quot;); return 0; } for (int time = 1; ; ++time) { for (int i = 0; i &lt;= n; ++i) { add(i + (time - 1) * (n + 2), i + time * (n + 2), inf); } add(n + 1 + time * (n + 2), n + 1 + (time - 1) * (n + 2), inf); for (int i = 1; i &lt;= m; ++i) { int tmp = (time - 1) % S[i][0] + 1; add(S[i][tmp] + (time - 1) * (n + 2), S[i][time % S[i][0] + 1] + time * (n + 2), S[0][i]); } ans += dinic(s, t); if (ans &gt;= k) { printf(&quot;%d\\n&quot;, time); return 0; } }}","link":"/p/af442de1.html"},{"title":"「网络流24题」餐巾计划问题-题解","text":"题目传送门: 「Luogu P1251」餐巾计划问题 题目大意在$N$天里,第$i$天需要$r_i$个餐巾 可以购买餐巾,每张$p$元 可以将旧送快洗,$m$天,费用$f$元 可以将旧送慢洗,$n$天,费用$s$元 每天结束,可以送快洗,慢洗,保存 设计最小花费 题解将每天拆成2个点(早晚),新建源点汇点(源点表示获得,汇点表示使用) 每天早上的点,向汇点连 容量为$r_i$,费用为$0$ 的边,表示当日需要使用 源点向每天晚上的点连 容量为$r_i$,费用为$0$ 的边,每天晚上获得多少旧餐巾 源点向每天早上的点连 容量为$inf$,费用为$p$ 的边,表示购买 每天晚上向$+m$天的早上连 容量为$inf$,费用为$f$ 的边,表示快洗 每天晚上向$+n$天的早上连 容量为$inf$,费用为$s$ 的边,表示快洗 每天晚上向第二天晚上连 容量为$inf$,费用为$0$ 的边,表示保留 跑最小费用最大流 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 4010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow, r[maxn];int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { for (int i = 1; i &lt;= n; ++i) d[i] = inf; memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}int main() { int N = read(); s = 0; t = 2 * N + 1; n = t + 1; for (int i = 1; i &lt;= N; ++i) { r[i] = read(); add(s, i + N, r[i], 0); add(i, t, r[i], 0); } int pr = read(), t1 = read(), c1 = read(), t2 = read(), c2 = read(); for (int i = 1; i &lt;= N; ++i) { if (i + 1 &lt;= N) add(i + N, i + N + 1, inf, 0); if (i + t1 &lt;= N) add(i + N, i + t1, inf, c1); if (i + t2 &lt;= N) add(i + N, i + t2, inf, c2); add(s, i, inf, pr); } MinCostMaxFlow(anscost); printf(&quot;%lld\\n&quot;, anscost); return 0;}","link":"/p/93562de2.html"},{"title":"「CSP-S 2019」题解","text":"~~今年的题真是毒瘤~~,一个蒟蒻要来写题解了 校门外有两棵树,一棵叫括号树一棵叫树上的数,这两棵树要被一匹叫格雷的马划分开为Emiya做饭,这两棵树问:那你猜猜我们的重心在哪啊 $D1T1$ 格雷码沙雕暴力dfs(我的做法)考场上真是脑残了,拿dfs模拟,忘了二分的事了,还传了四个参数注意:一定要用unsigned long long 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctype.h&gt;using namespace std;typedef unsigned long long ull;inline ull read() { ull x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); } while (isdigit(ch)) { x = x * 10 + ch - 48; ch = getchar(); } return x * f;}const int maxn = 64;ull n, k;void dfs(ull n, ull k, ull rev, ull from) { if (n == 1) { if (rev == 0) { if (k == 0) printf(&quot;0&quot;); else printf(&quot;1&quot;); } else { if (k == 0) printf(&quot;1&quot;); else printf(&quot;0&quot;); } return; } if (k &lt;= (1LL &lt;&lt; (n - 1LL)) - 1LL) { if (rev == 0 &amp;&amp; from == 0) { printf(&quot;0&quot;); dfs(n - 1LL, k, 0LL, 0LL); } else if (rev == 0 &amp;&amp; from == 1) { printf(&quot;0&quot;); dfs(n - 1LL, k, 1LL, 0LL); } else if (rev == 1 &amp;&amp; from == 0) { printf(&quot;1&quot;); dfs(n - 1LL, k, 0LL, 0LL); } else { printf(&quot;1&quot;); dfs(n - 1LL, k, 0LL, 0LL); } } else { if (rev == 0 &amp;&amp; from == 0) { printf(&quot;1&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 1LL, 1LL); } else if (rev == 1 &amp;&amp; from == 0) { printf(&quot;0&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 0LL, 1LL); } else if (rev == 0 &amp;&amp; from == 1) { printf(&quot;1&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 0LL, 1LL); } else { printf(&quot;0&quot;); dfs(n - 1LL, k - (1LL &lt;&lt; (n - 1LL)), 1LL, 1LL); } }}int main() { n = read(); k = read(); dfs(n, k, 0, 0); printf(&quot;\\n&quot;); return 0;}/* 55ms 812kB */ 二分模拟($lyd$巨佬的做法)考前做过一道类似的题,但可惜我忘了$lyd$巨佬说他这题只做了15分钟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;unsigned long long n,k;unsigned long long two[65];int change=0;int main(){ two[0]=1; for(int i=1;i&lt;=63;i++) { two[i]=two[i-1]*2; } cin&gt;&gt;n&gt;&gt;k; while(n&gt;0) { if(k&gt;=two[n-1]) { if(!change) { printf(&quot;1&quot;); change^=1; } else { printf(&quot;0&quot;); } k-=two[n-1]; } else { if(change) { printf(&quot;1&quot;); change^=1; } else { printf(&quot;0&quot;); } } n--; } return 0;}/* 57ms 928kB */ 位运算正解格雷码的规律就是第$i$位为$k\\ xor\\ \\lfloor\\frac{k}{2}\\rfloor$的第$i$位 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int n;unsigned long long k;int main() { scanf(&quot;%d %llu&quot;, &amp;n, &amp;k); k ^= (k &gt;&gt; 1); while (n--) { printf(&quot;%d&quot;, (k &gt;&gt; n &amp; 1)); } puts(&quot;&quot;); return 0;}/* 54ms 932kB */ $D1T2$ 括号树后面的先咕着,等着补 $D1T3$ 树上的数$D2T1$ $Emiya$家今天的饭$D2T2$ 划分$D2T3$ 树的重心","link":"/p/7d7252b1.html"},{"title":"「CSP-S 2019」自闭游记","text":"这次大概是第二年参加信息竞赛了(虽然去年什么也不会就摸了110分,省四)按照惯例,该写篇游记(流水账)了 $Day\\ \\ -7\\sim -2$本来还是挺有信心的,校内几十次模拟赛考自闭了,想想复赛结束后周一周二就要期中考试(其实是”贴心”的年级组特意为我们OIer调的)更自闭了晚饭回来后,几个沙雕朋友听说我自闭了,围了一圈给我来了一遍奥利给,真的感动回家和父母商量好,签了个申请书脱了一周产,还说让我专心学信息,期中考试先放下 脱产的时光还是很快乐的早上六点多到校就开始整理模板,刷模板题老师到了之后花三个半小时做模拟题下午自习和$zty$巨佬研究问题四天就这么过去了,打了一本子模板带去省城复习 $Day\\ \\ -1$上午十一点和机房$wjh$,$mjc$,$lyd$(lyd AK IOI)出发去车站了还是去年的时间,还是去年的$KFC$,还是去年的垃圾笔记本看的是累积了一年的数千行模板和经验 中午到了去年同样的酒店,晚上去了去年同样的吉大日新楼吃饭回到酒店,$lyd$巨佬给同学讲爆搜技巧,$zyc$学长像去年一样来探望苦逼的$yzOIer$睡前敲了一堆板子:快读,vim配置,ST表,树状数组,Trie树,树的重心,树的直径 $Day\\ \\ 1$还是在去年的等候室 进考场$???$这防窥膜是什么鬼,什么都挡不了的好吧,看着还超难受前排的灯也没有开,没开考眼睛就生疼 $Day1\\ T1$看见题目,emmm怎么做都告诉你了,开个数组reverse模拟呗…emmm不对,数组的话貌似要开$2^64$,不行不行推规律,好像也就那么个意思,dfs模拟!!然后一顿乱搞,dfs传值从2到3到4,写了好几十行dfs跑一边样例,没问题,大样例??好像爆了,改long long…照样爆看一眼时间,艹一个小时了,得了得了,不改了 看完第二题,不行不行,得改完,$2^64$?不是unsigned long long吗又加了常数的转换操作,大概可以了 此时一个半小时过去了… $Day1\\ T2$emmm括号匹配,靠前看过类似的,好像得用栈一顿乱搞,发现审错题了…树上??我应该不会,做链的小数据$35$分得了自己出了几个样例(其实是没发现大样例有链上情况),用了$multiset,stack$乱搞,都过了,就扔下去看第三题了 $Day1\\ T3$题目绕了十分多种,看了好几遍样例才明白题干这咋做啊,正解肯定不会,链和菊花图想了半个多小时没想出来 最后剩二十分钟了,不还是有$n!$的暴力$10$分吗飞速写完代码,编译…vector没有???不应该啊,改了好多遍也过不了,拉倒,随机数吧…随机数概率太小,从$1\\sim n$依次输出.. 其实编译没过是没有加using namespace std; 中午老师请客去了去年同样的饭店,下午去了去年同样的欢乐城放松自暴自弃$day1$估分$135$,完了,明天得考一百多分才稳… 晚上睡前又看了看一天什么没用上的模板 $Day\\ \\ 2$在等候室看了树的重心,树的直径的模板我跟lyd说:昨天没考,今天肯定有 $Day2\\ T1$认真的审了题,想要$AC$画了样例的图,woc二分图,网络流???完了完了,考前没看,扔下一个$32$分$n!$暴力溜了 其实已经花了一个小时了 $Day2\\ T3$第二题没看懂题面,看到第三题题目我就来了$???$这个重心定义和我复习的不一样,大体思想差不多,开写 改了模板,写了上去,发现分割树???以前没做过,只好重新建图,删一条边建一次图辣鸡效率跑完???重心全是$2$,查了半天发现两棵树的节点数没处理…改过来之后前几个点$25$分应该是没问题了 简单推了下链和完美二叉树,没推出来,放弃…考试结束前也没想出来 $Day2\\ T2$照着样例看了十分钟才明白题目啥意思感觉应该是$DP$,但蒟蒻不会$DP$啊算了,瞎写个状态转移方程吧,乱搞…发现不是最优解,然后处理分块还有贪心什么的改了一个小时还是不对,心想算了,爆零了,1=无缘了,又回去推链的重心 考试结束前,准备提交代码,把这题中间几行没用的删了删(删少了几行),再跑一遍,奇迹般的对了测了一下几个样例,$0\\to 64\\ \\ ???$ 估分$100+35+0+32+64+25=256$,有点悬 下午刷洛谷,橙蓝黑紫黑紫…炸了(现在掉色了)晚上从车站回家在大雪里打车半个小时,到家颓废,第二天的期中彻底放弃 $Day\\ \\ 3\\sim 4$期中考试第一天开幕雷击,语文古文没背过,作文主旋律,然后三科一个月没学的文科,还有什么都没复习的英语 回家,老师传了公示代码,去$luogu$民间数据自测$Day1\\ T2\\ \\ 35\\to 0\\ 256\\to 221$ 1=没希望,彻底自闭了,要$AFO$了 $Day\\ \\ 5\\sim 6$中午去机房把东西收拾到小屋里,$zty,lyd$巨佬已经开始准备省选期中成绩陆续出来了,总体来说还可以 中午和$zty$用lemon把全省代码拿民间数据跑了一遍,排名还可以,貌似还有希望 结虽然考的很水,但学$OI$我绝不后悔接下来要努力捡起文化课了 文化课虽说恶心，但只有一年，一年完了就能读大学了，高考就与你无关了。 —$zcysky$ 加油!奥利给!!","link":"/p/1901119c.html"},{"title":"「图论算法」树上并查集 dsu on tree","text":"$dsu\\ on\\ tree$($disjoint\\ set\\ union\\ \\text{on tree}$)算法，也称 __树上并查集__。使用了并查集的按秩合并(启发式合并)的方法，结合 树链剖分 中的 轻重儿子划分 ，对 树上暴力统计 进行了优化。使用这个算法需要满足以下两个条件： 每次只对子树进行查询 过程中没有对树的修改 可以将$O(n^2)$的暴力操作优化到$O(n\\log_2n)$ $pre.\\ $树链剖分 - 轻重链划分在$dsu\\ on\\ tree$算法中，只需要统计出每个节点的轻重儿子，而不需要划分轻重链，所以我们只需要树链剖分中的$\\texttt{dfs1()}$，并且只保留和轻重儿子有关的操作即可 关于 轻重儿子 ： 一个节点的所有子节点中，子树所含节点个数最多的子节点称为 重儿子 除重儿子外，一个节点的其余儿子均为 轻儿子 123456789101112void dfs1(int x, int fa) { siz[x] = 1; // 以x为根的子树大小初始化为1 for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; dfs1(e.to, x); siz[x] += siz[e.to]; // 加上子节点的大小 if (siz[e.to] &gt; siz[son[x]]) { son[x] = e.to; // 更新重儿子 } }} $I.\\ $算法流程对于每一个节点$x$: 遍历所有子节点 递归计算所有轻儿子的子树，并删除其对答案的贡献 递归计算重儿子，保留对答案的贡献 统计所有轻儿子对答案的贡献 更新节点答案 伪代码： 123456789101112void dfs(int x, int fa, int opt) { for (all edge from x) { if (e.to == fa || e.to == son[x]) continue; dfs(e.to, x, 0); // 暴力统计轻儿子的子树的贡献，并删除(opt=0) } if (son[x]) dfs(son[x], x, 1); // 统计重儿子的贡献，不删除 upd(x); // 暴力统计该节点所有轻儿子的贡献 ans[x] = now; // 更新答案 if (!opt) { del(x); // 删除需要删除的贡献 }} 12345678void upd(int x, int fa, int val) { solve(x); // 计算当前答案 for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa || e.to == Son) continue; upd(e.to, x, val); }} 由于暴力统计的只是轻儿子，而每个节点的轻儿子不超过$\\log_2n$个，所以整个算法复杂度保证在了$O(n\\log_2n)$ $II.\\ $模板题$CodeForces\\ 600E\\ \\ Lomsat\\ gelral$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 100010;struct Edge { int from, to; Edge(int u, int v): from(u), to(v) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v) { edges.push_back(Edge(u, v)); int mm = edges.size(); G[u].push_back(mm - 1);}int n, Mx, Son, col[maxn], son[maxn], siz[maxn], cnt[maxn];long long sum = 0, ans[maxn];void dfs1(int x, int fa) { siz[x] = 1; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; dfs1(e.to, x); siz[x] += siz[e.to]; if (siz[e.to] &gt; siz[son[x]]) { son[x] = e.to; } }}void Add(int x, int fa, int val) { cnt[col[x]] += val; if (cnt[col[x]] &gt; Mx) { Mx = cnt[col[x]]; sum = col[x]; } else if (cnt[col[x]] == Mx) { sum += (long long)col[x]; } for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa || e.to == Son) continue; Add(e.to, x, val); }}void dfs2(int x, int fa, int opt) { for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.to == fa) continue; if (e.to != son[x]) dfs2(e.to, x, 0); } if (son[x]) { dfs2(son[x], x, 1); Son = son[x]; } Add(x, fa, 1); Son = 0; ans[x] = sum; if (!opt) { Add(x, fa, -1); sum = 0, Mx = 0; }}int main() { n = read(); for (int i = 1; i &lt;= n; ++i) { col[i] = read(); } for (int i = 1; i &lt; n; ++i) { int u = read(), v = read(); add(u, v); add(v, u); } dfs1(1, 0); dfs2(1, 0, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%lld &quot;, ans[i]); } return 0;}","link":"/p/da7e0a9d.html"},{"title":"「Luogu P1993」小K的农场-题解 &amp; 差分约束系统","text":"题目传送门: 「Luogu P1993」小K的农场 题目大意给出$m$个约束条件,$n$个农场有三种条件,其中$a,b$表示编号为$a,b$的农场的植物个数 $a-b≥c$ $a-b≤c$ $a=b$求是否存在一种方案,使农场中的植物数满足约束要求 $I.$ 差分约束系统以第$1$种约束为例:$$a-b\\ge c\\Rightarrow b\\le a+(-c)$$与求最短路径中的三角形不等式$dis[e.to]\\le dis[u] + e.val$类似所以我们对于约束条件$a-b\\ge c$,从$a$到$b$建一条边权为$-c$的边同理三种约束条件依次为 $a-b\\ge c$, 从$a$到$b$建$-c$单向边 $a-b\\le c$, 从$b$到$a$建$c$单向边 $a=b$, 从$a$到$b$建权值为$0$的双向边 如果存在一组解${x_1, x_2, \\ldots, x_n}$,则对任意常数$\\Delta$, ${x_1+\\Delta, x_2+\\Delta, \\ldots, x_n+\\Delta}$也是一组解不妨先求一组负数解,于是就有了条件$x_i-x_0\\le 0$即,从$0$向所有节点建一条边权为$0$的单向边 求解时,设$\\mathtt{dis[0]=0}$,然后以$0$为源点求单源最短路如果存在负环,则系统无解不存在负环,则$\\mathtt{dis[i]}$为系统的一组解 $II.$ 负环如果任意一条边被修改大于$n$次(执行$n$次松弛操作),这个图内一定存在至少一个负环我们可以使用一个数组$cnt$来记录每条边执行松弛操作的次数当向队列中添加节点$\\mathtt{e.to}$时,$\\mathtt{cnt[e.to]++}$然后再判断$\\mathtt{cnt[e.to]&gt;n}$,如果返回$\\mathtt{true}$则存在负环 $III.$ $SPFA$的$SLF$优化本题如果直接跑$SPFA$的话,会$TLE\\ 3$个点,即使手动开了$O3$优化,还是会$TLE\\ 1$个点所以我们可以使用$SLF(Small\\ Label\\ First)$优化 $SLF:$当加入一个新节点$v$的时候 如果此时的$\\mathtt{dis[v]}$比队首$\\mathtt{dis[q.front()]}$小的话，就把$v$点加入到队首 否则把他加入到队尾 因为先扩展最小的点可以尽量使程序尽早的结束 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0; int f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 10010;const int inf = 0x3f3f3f3f;struct Edge { int from, to, val; Edge(int u, int v, int w): from(u), to(v), val(w) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int w) { edges.push_back(Edge(u, v, w)); int mm = edges.size(); G[u].push_back(mm - 1);}int n, m;int dis[maxn], vis[maxn], cnt[maxn];bool SPFA(int s) { deque&lt;int&gt; q; q.push_back(s); dis[s] = 0; vis[s] = true; while (!q.empty()) { int u = q.front(); q.pop_front(); vis[u] = false; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (dis[e.to] &gt; dis[u] + e.val) { dis[e.to] = dis[u] + e.val; if (!vis[e.to]) { vis[e.to] = true; if (!q.empty() &amp;&amp; dis[e.to] &lt; dis[q.front()]) { q.push_front(e.to); } else { q.push_back(e.to); } cnt[e.to]++; } if (cnt[e.to] &gt; n) { return false; } } } } return true;}int main() { n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) { int opt = read(); if (opt == 1) { int a = read(), b = read(), c = read(); add(a, b, -c); } else if (opt == 2) { int a = read(), b = read(), c = read(); add(b, a, c); } else { int a = read(), b = read(); add(a, b, 0); add(b, a, 0); } } for (int i = 1; i &lt;= n; ++i) { add(0, i, 0); dis[i] = inf; } printf(SPFA(0) ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); return 0;}/* 1.94s 1.61MB */","link":"/p/6dcf876e.html"},{"title":"「数据结构」线段树","text":"线段树($Segment\\ Tree$)是一种基于分治思想的__二叉树__形数据结构，可以用于__区间__上的数据维护，它可以维护以下值 $maxn\\ minn$，区间上最大最小值 $sum$，区间和 $lmax$，每段上最大前缀和 $rmax$，每段上最大后缀和 $……$ 和以下操作 $Add\\ x\\ y\\ k$，把区间$[x,y]$内元素值全加$k$ $Query\\ x\\ y$，查询区间$[x,y]$内的某个值 由于线段树会维护一种数据，其他也很好写，所以本篇以__区间和__为例 区间和在每次$Add$操作中，如果将相关区间的值全部更新，则会把时间复杂度提高到$O(n)$ 所以我们可以采取一种__延迟标记__($lazy-tag$)的技巧，如果被标记，则说明本区间内的值被整体加上某个值了 详细方法见代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct SegmentTree { struct SegmentTreeNode { //树上的节点 int l, r; //节点表示区间的左右端点 long long sum, add; //区间和和add的延迟标记 #define l(x) tree[x].l //方便访问 #define r(x) tree[x].r #define sum(x) tree[x].sum #define add(x) tree[x].add } tree[maxn &lt;&lt; 2]; int a[maxn], n, m; void build(int p, int l, int r) { //建树 l(p) = l, r(p) = r; //设置左右端点 if (l == r) { sum(p) = a[l]; return; } //到达叶子节点 int mid = (l + r) &gt;&gt; 1; build(p * 2, l, mid); //递归构建左右树 build(p * 2 + 1, mid + 1, r); sum(p) = sum(p * 2) + sum(p * 2 + 1); //更新数据，可改为需要维护的多个值的维护方法 } void pushdown(int p) { //下传延迟标记 if (add(p)) { //如果有标记 sum(p * 2) += add(p) * (r(p * 2) - l(p * 2) + 1); //sum传至左儿子 sum(p * 2 + 1) += add(p) * (r(p * 2 + 1) - l(p * 2 + 1) + 1); //右儿子 add(p * 2) += add(p); //延迟标记传至左儿子 add(p * 2 + 1) += add(p); //右儿子 add(p) = 0; //本节点延迟标记清零 } } void update(int p, int l, int r, int d) { //更新区间内值 if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) { //完全覆盖 sum(p) += (long long)d * (r(p) - l(p) + 1); //更新节点信息 add(p) += d; //打上延迟标记 return; } pushdown(p); //下传标记 int mid = (l(p) + r(p)) &gt;&gt; 1; if (l &lt;= mid) update(p * 2, l, r, d); //递归更新左右 if (r &gt; mid) update(p * 2 + 1, l, r, d); sum(p) = sum(p * 2) + sum(p * 2 + 1); //维护数据 } long long query(int p, int l, int r) { //查询操作 if (l &lt;= l(p) &amp;&amp; r &gt;= r(p)) return sum(p); //完全覆盖 pushdown(p); //下传标记 int mid = (l(p) + r(p)) &gt;&gt; 1; long long ans = 0; if (l &lt;= mid) ans += query(p * 2, l, r); //加上左右部分值 if (r &gt; mid) ans += query(p * 2 + 1, l, r); return ans; } #undef add //防止后续使用add等出现错误 #undef sum #undef l #undef r}; 为了使代码简洁，还可以宏定义一些名称 1234#define lt p&lt;&lt;1 //左孩子#define rt p&lt;&lt;1|1 //右孩子#define lson lt,l,mid //左子树#define rson rt,mid+1,r //右子树 $Luogu$模板题目Luogu P3372 线段树1 (区间增加，区间查询和) Luogu P3373 线段树2 (区间增加，区间乘数，区间查询和) $SPOJ$的$GSS$系列 SP1043 GSS1 - Can you answer these queries I SP1557 GSS2 - Can you answer these queries II SP1716 GSS3 - Can you answer these queries III SP2713 GSS4 - Can you answer these queries IV SP2916 GSS5 - Can you answer these queries V SP4487 GSS6 - Can you answer these queries VI SP6779 GSS7 - Can you answer these queries VII","link":"/p/d1cf0d36.html"},{"title":"「数据结构」左偏树(可并堆)","text":"左偏树($Leftist\\ Tree$)，是一种 __可以合并的堆状结构__，支持以下操作 $Pop\\ x$，删除节点$x$ $Merge\\ x\\ y$，合并两棵左偏树 对于一个左偏树的节点，需要维护以下值 $dist$，记录这个节点到它子树里面最近的叶子节点的距离 $value$，每个节点包含的值 性质 一个节点的$value$大于(或小于)左右孩子的$value$(堆性质) 一个节点的左孩子的$dist$不小于右孩子的$dist$(左偏性质) 一个节点的距离始终等于右孩子+1 实现$Merge$操作首先我们设两个节点$x,y$，$x$的根节点的权值小于等于$y$的根节点（否则$swap(x,y)$），把$x$的根节点作为新树$Z$的根节点，剩下的事就是合并$x$的右子树和$y$了 合并了$x$的右子树和$y$后，$x$当$x$的右子树的距离大于$x$的左子树的距离时，为了维护左偏性质，我们要交换$x$的右子树和左子树。顺便维护性质三，所以直接$dist_x=dist_{rson(x)}+1$ $Pop$操作略$…$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849struct LeftistTree { int n, m; struct LeftistTreeNode { int dis, val, rt; int ls, rs; #define ls(x) tree[x].ls #define rs(x) tree[x].rs #define dis(x) tree[x].dis #define val(x) tree[x].val #define rt(x) tree[x].rt }tree[maxn]; int merge(int x, int y) { if (!x || !y) return x + y; if (val(x) &gt; val(y) || (val(x) == val(y) &amp;&amp; x &gt; y)) { swap(x, y); } rs(x) = merge(rs(x), y); if (dis(ls(x)) &lt; dis(rs(x))) swap(ls(x), rs(x)); rt(ls(x)) = rt(rs(x)) = rt(x) = x; dis(x) = dis(rs(x)) + 1; return x; } int get(int x) { //路径压缩 return rt(x) == x ? x : rt(x) = get(rt(x)); } void pop(int x) { val(x) = -1; rt(ls(x)) = ls(x); rt(rs(x)) = rs(x); rt(x) = merge(ls(x), rs(x)); } void init() { dis(0) = -1; for (int i = 1; i &lt;= n; ++i) { rt(i) = i; val(i) = read(); } } void SolveMerge(int x, int y) { if (val(x) == -1 || val(y) == -1) return; int fx = get(x), fy = get(y); if (fx != fy) { rt(fx) = rt(fy) = merge(fx, fy); } } void SolvePop(int x) { if (val(x) == -1) puts(&quot;-1&quot;); else printf(&quot;%d\\n&quot;, val(get(x))), pop(get(x)); }}; $Luogu$模板题目Luogu P3377 左偏树(可并堆)","link":"/p/7ab0d731.html"},{"title":"「数据结构」树状数组","text":"树状数组($Binary\\ Indexed\\ Trees$)是一个维护__前缀和__的数据结构，需要支持以下操作 $Add\\ x\\ y$，单点增加，a[x] += y $Query\\ x$，查询前缀和 前置知识$lowbit$运算$lowbit(n)$表示非负整数$n$在二进制表示下__最低位的1及其后边所有的0构成的数值__ 为了实现$lowbit$运算，先把$n$取反，此时第$k$位变为$0$(设第$k$位是$1$，其后均为$0$)，第$0\\sim k-1$位变为$1$，再整体加一，所以第$k$位变为$1$，其后为$0$，其前每位恰好与原数相反，再按位求与($&amp;$)即可得到。由于在补码下，$\\sim n=-1-n$，所以 $$lowbit(n)=n\\ &amp;\\ (\\sim n+1)=n\\ &amp;\\ -n$$ 1int lowbit(int n) { return n &amp; -n; } 算法实现对于一个原序列$a[]$，可以建立一个数组$tree[]$，来保存$a$的区间$[x-lowbit(x)+1, x]$内值的和，即 $$tree[x] = \\sum_{i=x-lowbit(x)+1}^x{a[i]}$$ 同时$tree$数组可以看成一个树形结构，并满足以下性质 每个节点$tree[x]$保存以$x$为根的子树中所有叶节点的和 每个节点$tree[x]$的子节点个数等于$lowbit(x)$的位数 除树根外，每个节点$tree[x]$的父亲节点为$tree[x+lowbit(x)]$ 树的深度为$\\log_2n$ 根据这些性质，就很容易地写出代码 1234567891011121314151617struct BIT { int tree[maxn], n, m; int lowbit(int k) { return k &amp; -k; } void add(int x, int k) { for (; x &lt;= maxn; x += x &amp; -x) tree[x] += y; } int query(int x) { int ans = 0; for (; x; x -= x &amp; -x) ans += tree[x]; return ans; } int init() { for (int i = 1; i &lt;= n; ++i) { add(i, a[i]); } }}; 实际上，树状数组可以嵌套维护，来解决更多问题，例如区间修改 $Luogu$模板题目Luogu P3374 树状数组1 (单点修改，区间查询) Luogu P3368 树状数组2 (区间修改，单点查询) Luogu P3372 线段树1 (区间修改，区间查询)","link":"/p/8c13697e.html"},{"title":"「数据结构」并查集","text":"并查集($union-find\\ \\ set$)是一种可以__动态维护__若干个不重叠的__集合__，并支持__合并与查询__的数据结构，支持以下两种基本操作： $Find$，查询一个元素属于哪个集合(即查找根) $Union$，把两个集合合并成一个集合 基本实现我们可以使用树形结构存储集合，树上每个点表示一个元素，树根可以代表这个集合 使用一个数组ufs[]来保存每个节点的父亲节点 则合并$x,y$所在的集合可以表示为$ufs[root_x]=root_y$ 查找根节点可以一直沿着数组向上查找 路径压缩防止整棵树的链非常长，导致每次查询时间复杂度极高，可以在__每次执行$Find$操作时，把访问的节点指向根节点__，这种方法称为__路径压缩__，$Find$操作的时间复杂度为$O(log_2n)$ $Code\\ Below:$ 1234567891011121314int ufs[maxn];//初始化，每个点独立(自己是自己的根)for (int i = 1; i &lt;= n; ++i) ufs[i] = i;//Find操作int find(int x) { return x == ufs[x] ? x : ufs[x] = find(ufs[x]);}//union操作(注意union是C++关键字)void unionn(int x, int y) { ufs[get(x)] = get(y)} 带权并查集有时，需要维护的每个节点到根节点的边权值，可以增加一个数组d[]来保存权值，对于两个操作也有所更改 再增加一个数组size[]记录每个树根上集合大小 1234567891011121314//Findint find(int x) { if (ufs[x] == x) return x; int fx = find(ufs[x]); d[x] += d[ufs[x]]; return ufs[x] = fx;}//unionvoid union(int x, int y) { int fx = find(x), fy = find(y); ufs[fx] = fy; d[fx] = size[fy]; size[fy] += size[fx];} 可撤销并查集可能需要维护一个并查集并要求可以__撤销__两节点的连接关系 我们可以对每个操作$(u, v)$执行前，把节点$u$换为树根(不难发现，$ufs[]$变化的只有从$u$到原节点的一条链上) 然后对于操作 $Connect\\ u\\ v$，需要把$u$的父亲节点设为$v$ $Delete\\ u\\ v$，可以把$v$的父亲节点设为$0$ $Query\\ u\\ v$，直接暴力搜索$v$所在的链即可 1234567891011121314151617181920212223struct UnionFindSet { int ufs[maxn]; void init() { for (int i = 0; i &lt;= n; ++i) { ufs[i] = i; } } inline void sroot(int u) { //换u为根 for (int i = 0, fa = ufs[u]; u; fa = ufs[u]) { ufs[u] = i; i = u; u = fa; } } void connect(int u, int v) { ufs[u] = v; } void deleteuv(int u, int v) { ufs[v] = 0; } void query(int u, int v) { for (; v != u &amp;&amp; v; v = ufs[v]); puts(v == u ? &quot;Yes&quot; : &quot;No&quot;); }}; $Luogu$模板题目Luogu P3367 并查集 (普通并查集) Luogu P1196 银河英雄传说 (带权并查集) Luogu P2147 洞穴勘探 (可撤销并查集)","link":"/p/9c4b8ceb.html"},{"title":"「Luogu P2723 P1631 P2850」小练习-题解","text":"战神留的还有一道「P3378」堆,但是是模板,就不用多说了吧 $\\mathcal{「P2723」}$ 丑数$92$分$STL$做法思路很简单,每次弹出堆顶,依次乘$S$集合内的数,再压入优先队列($priority\\_queue$)和集合($set$,目的是去重)中,输出最后一个堆顶即可然而第$4$个点卡了十多秒,$92$分 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int maxk = 110;long long k, n, a[maxk], i, t;priority_queue&lt;long long, vector&lt;long long&gt;, greater&lt;long long&gt; &gt; q;set&lt;long long&gt; s;int main() { scanf(&quot;%lld %lld&quot;, &amp;k, &amp;n); for (long long i = 1; i &lt;= k; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); } q.push(1); s.insert(1); while (i++ &lt;= n) { t = q.top(); q.pop(); for (long long j = 1; j &lt;= k; ++j) { long long num = t * a[j]; if (!s.count(num)) { s.insert(num); q.push(num); } } } printf(&quot;%lld\\n&quot;, t); return 0;}/* 92points TLE with O2 */ $100$分循环做法思路由题可知,当前产生的第$i$个丑数$s[i]$,是之前的某个丑数$\\times a[j]$某个丑数$\\times a[j]$需要大于$s[i-1]$,而且要尽可能的小于是我们可以枚举$j$,然后找到最小的一个丑数$minn$使$minn\\times a[j]&gt;s[i-1]$ 但是..三重循环可能还会$TLE$ 很容易发现满足条件的丑数$x\\times a[j]&gt;s[i-1]$,一定满足条件$x\\times a[j]&gt;s[i-2]$于是我们就可以从满足$x\\times a[j]&gt;s[i-2]$的丑数$x$的位置往后枚举,找到满足条件$x\\times a[j]&gt;s[i-1]$的丑数代码里$b[j]$表示$a[j]$至少与第几小丑数相乘才能得到一个比$s[i-1]$大的丑数 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;const int maxk = 110;const int maxn = 100010;long long k, n, a[maxk], i, t, s[maxn], b[maxk];int main() { scanf(&quot;%lld %lld&quot;, &amp;k, &amp;n); for (long long i = 1; i &lt;= k; ++i) { scanf(&quot;%lld&quot;, &amp;a[i]); } s[0] = 1; for (long long i = 1; i &lt;= n; ++i) { long long minn = (long long)1 &lt;&lt; 61; for (long long j = 1; j &lt;= k; ++j) { while (a[j] * s[b[j]] &lt;= s[i - 1]) { b[j]++; } if (a[j] * s[b[j]] &lt; minn) { minn = a[j] * s[b[j]]; } } s[i] = minn; } printf(&quot;%lld\\n&quot;, s[n]); return 0;}/* 101ms 1584kB */ $\\mathcal{「P1631」}$ 序列合并思路参考Red_w1nE 把$A$和$B$两个序列分别从小到大排序这样,从$A$和$B$中各任取一个数相加得到$n^2$个和,可以把这些和看成形成了$n$个队列: 1234a[1] + b[1] &lt;= a[1] + b[2] &lt;= ... &lt;= a[1] + B[n]a[2] + b[1] &lt;= a[2] + b[2] &lt;= ... &lt;= a[2] + B[n] ... ... ... ...a[n] + b[1] &lt;= a[n] + b[2] &lt;= ... &lt;= a[n] + B[n] 接下来,将这$n$个队列进行合并: 将这$n$个队列中的第一个元素放入优先队列中； 每次取出优先队列中的最小值,若这个最小值来自于第$k$个队列,那么,就将第$k$个队列的下一个元素放入优先队列中。我们可以使用一个结构体来记录队列中一个节点的值val,队列号id,下一个元素nxt 代码1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;struct Node { int val, id, nxt; Node(int v, int i, int n): val(v), id(i), nxt(n) {}};bool operator &lt; (const Node&amp; a, const Node&amp; b) { return a.val &gt; b.val;}int n, a[maxn], b[maxn];priority_queue&lt;Node&gt; q;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;b[i]); for (int i = 0; i &lt; n; ++i) { q.push(Node( a[i] + b[0], i, 1 )); } for (int i = 0; i &lt; n; ++i) { Node t = q.top(); q.pop(); printf(&quot;%d &quot;, t.val); q.push(Node( a[t.id] + b[t.nxt], t.id, t.nxt + 1 )); } return 0;}/* 402ms 3196kB */ $\\mathcal{「P2850」}$ 虫洞思路判断__负环__的模板题 每条小路连接边权为正的无向边,每个虫洞连接边权为负的无向边存在负环,则可以回到过去使用$SPFA$算法判断负环($Floyd$也可以,但不开O2优化会$TLE$) $SPFA$判断负环:如果任意一条边被修改大于$n$次,这个图内一定存在至少一个负环 代码使用vector建边,邻接表也可以 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 510;struct Edge { int from, to, val; Edge(int u, int v, int w): from(u), to(v), val(w) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int w) { edges.push_back(Edge(u, v, w)); int mm = edges.size(); G[u].push_back(mm - 1);}int dist[maxn], vis[maxn], cnt[maxn];int n, m, w;bool SPFA(int s) { queue&lt;int&gt; q; q.push(s); dist[s] = 0; vis[s] = 1; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = 0; i &lt; G[u].size(); ++i) { Edge&amp; e = edges[G[u][i]]; if (dist[e.to] &gt; dist[u] + e.val) { dist[e.to] = dist[u] + e.val; if (!vis[e.to]) { vis[e.to] = 1; q.push(e.to); cnt[e.to]++; //统计修改次数 } if (cnt[e.to] &gt; n) { //修改大于n次 return true; //存在负环 } } } } return false;}void clear() { edges.clear(); for (int i = 0; i &lt; maxn - 5; ++i) { G[i].clear(); } memset(cnt, 0, sizeof(cnt)); memset(vis, 0, sizeof(vis)); memset(dist, 0x7f, sizeof(dist));}int main() { int T = read(); while (T--) { clear(); n = read(); m = read(); w = read(); for (int i = 0; i &lt; m; ++i) { int u = read(), v = read(), d = read(); add(u, v, d); add(v, u, d); } for (int i = 0; i &lt; w; ++i) { int u = read(), v = read(), d = read(); add(u, v, -d); } if (SPFA(1)) { printf(&quot;YES\\n&quot;); } else { printf(&quot;NO\\n&quot;); } } return 0;}/* 164ms 1024kB */ 如有疑问,可以在下方评论区留言","link":"/p/1faf5003.html"},{"title":"算法笔记-数论","text":"模板地址: GitHub 欧几里得算法(Euclid algorithm)123LL gcd(LL a, LL b) { return b == 0 ? a : gcd(b, a % b);} lcm(a, b) = a / gcd(a, b) * b 扩展欧几里得算法(exGCD)目标: 寻找一对整数$(x, y)$,使$ax+by=gcd(a,b)$ 1234void exgcd(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y) { if (!b) { d = a; x = 1; y = 0; } //d为gcd(a, b) else { exgcd(b, a % b, d, y, x); y -= x * (a / b); }} 裴蜀定理$ax+by=c$且$x,y$全为正整数,则当且仅当$gcd(a, b)|c$ 素数相关Eratosthenes筛法1234567891011bool vis[maxn];int prime[maxn];void getprime(int n) { int m = (int)sqrt(n + 0.5), num = 0; memset(vis, 0, sizeof(vis)); vis[0] = vis[1] = 1; for (int i = 2; i &lt;= m; ++i) if (!vis[i]) { prime[++num] = i; for (int j = i * i; j &lt;= n; j += i) vis[j] = 1; }} 欧拉线性筛12345678910111213void getprime(int n) { vis[1] = true; for (int i = 2; i &lt;= n; i++) { if (!vis[i]) { prime[++cnt] = i; } for (int j = 1; j &lt;= cnt; j++) { int v = i * prime[j]; if (v &gt; n) break; vis[v] = true; } }} 素数定理$$\\pi(x) \\sim \\frac{x}{\\ln x}$$ $Miller-Rabin$素数测试原理:费马小定理若$a^{n-1}\\equiv 1\\pmod n$,$a$取值越多,可以近似认为$n$为质数使用二次探测定理改进卡卡迈尔数(合数$n$对于任何正整数$b$,都满足$gcd(b, n)=1\\ \\ b^{n-1}\\equiv 1\\pmod n$)的bug 123456789101112131415161718LL Random(LL n) { return (LL)((double)rand() / RAND_MAX * n + 0.5); }bool Witness(LL a, LL n) { LL m = n - 1; int j = 0; while (!(m &amp; 1)) { j++; m &gt;&gt;= 1; } LL x = pow_mod(a, m, n); if (x == 1 || x == n - 1) return false; while (j--) { x = x * x % n; if (x == n - 1) return false; } return true;}bool Miller_Rabin(LL n) { if (n &lt; 2) return false; if (n == 2) return true; if (!(n &amp; 1)) return false; for (int i = 1; i &lt;= 30; ++i) { LL a = Random(n - 2) + 1; if (Witness(a, n)) return false; } return true;} 模算术$$(a + b)\\bmod n = ((a\\bmod n) + (b\\bmod n))\\bmod n\\\\(a - b)\\bmod n = ((a\\bmod n) - (b\\bmod n) + n)\\bmod n\\\\ab\\mod n = (a\\bmod n)(b\\bmod n)\\bmod n$$ 快速乘 $ab\\bmod n$123456789LL mul_mod(LL a, LL b, LL n){ LL res = 0; while (b &gt; 0) { if (b &amp; 1) res = (res + a) % n; a = (a + a) % n; b &gt;&gt;= 1; } return res;} 快速幂 $a^p\\bmod n$1234567LL pow_mod(LL a, LL p, LL n) { if (p == 0 &amp;&amp; n == 1) return 0; if (p == 0) return 1; LL ans = pow_mod(a, p / 2, n); ans = ans * ans % n; if (p % 2 == 1) ans = ans * a % n; return ans;} 使用位运算: 12345LL pow_mod(LL a, LL p, LL n) { a %= n; LL ans = 1; for (; p; p &gt;&gt;= 1, a *= a, a %= n) if(p &amp; 1) ans = ans * a % n; return ans;} 欧拉$\\varphi$函数$$\\varphi(n)=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})…(1-\\frac{1}{p_k})$$$\\varphi(n)$表示不超过$n$且与$n$互质的整数个数 求值123456789int euler_phi(int n) { int m = (int)sqrt(n + 0.5); int ans = n; for (int i = 2; i &lt;= m; ++i) if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } if (n &gt; 1) ans = ans / n * (n - 1); return ans;} 筛欧拉函数表123456789int phi[maxn];void phi_table(int n) { for (int i = 2; i &lt;= n; ++i) phi[i] = 0; phi[1] = 1; for (int i = 2; i &lt;= n; ++i) if (!phi[i]) for (int j = i; j &lt;= n; j += i) { if (!phi[j]) phi[j] = j; phi[j] = phi[j] / i * (i - 1); }} 同余式定理欧拉定理若$gcd(a, n) = 1$,则$a^{\\varphi(n)}\\equiv 1\\pmod n$ 费马小定理若$p$为质数,则$a^{p-1}\\equiv 1\\pmod p$ 威尔逊定理若$p$为质数,则$(p-1)!\\equiv -1\\pmod p$ 乘法逆元$$a\\div b\\bmod n = a\\times b^{-1}\\bmod n$$$b^{-1}$称为$b$在模$n$意义下的逆元 $n$为质数使用费马小定理, $a^{-1} = a^{n - 2}$ $n$不为质数递归求解 12345LL inv(LL a, LL n) { LL d, x, y; exgcd(a, n, d, x, y); return d == 1 ? (x + n) % n : -1;} 筛逆元表1234567int inv_table[maxn];void getinv(int n, int p) { inv_table[1] = 1; for (int i = 2; i &lt;= n; ++i) { inv_table[i] = (LL)(p - p / i) * inv_table[p % i] % p; }} 同余方程$ax\\equiv b\\pmod n$可以化为$ax+ny=b$使用扩展欧拉定理解决 中国剩余定理(China Remainder Theorem)求解$x\\equiv a_i\\pmod {m_i}$满足$m_i$两两互质 12345678910LL crt(int n, int* a, int* m) { LL M = 1, d, y, x = 0; for (int i = 0; i &lt; n; ++i) M *= m[i]; for (int i = 0; i &lt; n; ++i) { LL w = M / m[i]; exgcd(m[i], w, d, d, y); x = (x + y * w * a[i]) % M; } return (x + M) % M;} 扩展中国剩余定理(exCRT)$m_i$不一定两两互质 12345678910111213LL excrt(LL n, LL* a, LL* m) { LL x, y, k, M = m[0], ans = a[0]; for (int i = 1; i &lt; n; ++i) { LL A = M, B = m[i], C = (a[i] - ans % B + B) % B, gcd; exgcd(A, B, gcd, x, y); LL bg = B / gcd; if (C % gcd != 0) return -1; x = mul_mod(x, C / gcd, bg); ans += x * M; M *= bg; ans = (ans % M + M) % M; } return (ans % M + M) % M;} 离散对数(BSGS)求解$a^x\\equiv b\\pmod n$满足$n$为质数 12345678910111213141516int log_mod(int a, int b, int n) { int m, v, e = 1, i; m = (int)sqrt(n + 0.5); v = inv(pow_mod(a, m, n), n); map&lt;int, int&gt; x; x[1] = 0; for (i = 1; i &lt; m; ++i) { e = mul_mod(e, a, n); if (!x.count(e)) x[e] = i; } for (i = 0; i &lt; m; ++i) { if (x.count(b)) return i * m + x[b]; b = mul_mod(b, v, n); } return -1;} 莫比乌斯反演整除分块整除分块可以对后面的莫比乌斯反演提供很大的优化通过枚举可以发现$\\lfloor \\frac{n}{i} \\rfloor$的结果会出现分块现象例如$n=10$时$\\ \\ \\ i\\ \\ \\ \\ 1\\ \\ 2\\ 3\\ 4\\ 5\\ 6\\ 7\\ 8\\ 9\\ 10\\ 11\\ 12\\ 13\\ …$$\\lfloor \\frac{n}{i} \\rfloor\\ 10\\ 5\\ 3\\ 2\\ 2\\ 1\\ 1\\ 1\\ 1\\ 1\\ \\ \\ 0\\ \\ \\ 0\\ \\ \\ 0\\ \\ \\ …$不难发现,每个块的右端点为$r=\\lfloor \\frac{n}{t}\\rfloor (t=\\lfloor \\frac{n}{i}\\rfloor)$ 莫比乌斯函数$$\\mu(n) =\\begin{cases}1, &amp; n=1 \\\\(-1)^r, &amp; n=p_1p_2p_3…p_r(\\text{$p_i$为互不相同的质数}) \\\\0, &amp; else\\end{cases}$$性质:$$\\sum_{d|n}{\\mu(d)}=[n=1]$$$$\\sum_{d|n}{\\frac{\\mu(d)}{d}}=\\frac{\\varphi(n)}{n}$$线性筛: 123456789101112131415int mu[maxn], vis[maxn];int primes[maxn], cnt;void get_mu(int n) { memset(vis, 0, sizeof(vis)); memset(mu, 0, sizeof(mu)); cnt = 0; mu[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) { primes[cnt++] = i; mu[i] = -1; } for (int j = 0; j &lt; cnt &amp;&amp; primes[j] * i &lt;= n; ++j) { vis[primes[j] * i] = 1; if (i % primes[j] == 0)break; mu[i * primes[j]] = -mu[i]; } }}","link":"/p/da9a11f.html"},{"title":"「Luogu P1516」青蛙的约会-题解","text":"题目传送门: 「Luogu P1516」青蛙的约会 题目大意(规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴)现有两只青蛙$A,B$设青蛙$A$的出发点坐标是$x$，青蛙$B$的出发点坐标是$y$青蛙$A$一次能跳$m$米，青蛙$B$一次能跳$n$米，两只青蛙跳一次所花费的时间相同纬度线总长$l$米求两只青蛙跳了几次以后才会碰面 题解__同余方程__模板题求解$x + km\\equiv y + kn \\pmod l$ $Solve:$$$x+km−(y+kn)=lz,\\ \\ z\\in Z\\\\(x-y)+k(m-n)-lz=0\\\\k(n-m)+lz=(x-y)$$令$a=x-y,b=n-m$上式可化为:$$kb+lz=a$$求这个方程的最小整数解化为求此不定方程最小整数解$$k’b+lz’=gcd(b,l)$$使用扩展欧几里得算法可得一组特解$(k’,b’)$最小解为$k_{min} = k’\\bmod \\frac{l}{gcd(b,l)}$以上解$k_{min}$的方程右边是$gcd(b,l)$而不是$a$所以结果为$$\\boxed{ (k’\\times \\frac{a}{gcd(b,l)})\\bmod \\frac{l}{gcd(b,l)} }$$ 代码123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;void exgcd(LL a, LL b, LL&amp; d, LL&amp; x, LL&amp; y) { if (!b) { d = a; x = 1; y = 0; } else { exgcd(b, a % b, d, y, x); y -= x * (a / b); }}int main() { LL n, m, x, y, l, gcd, x1, y1; scanf(&quot;%lld %lld %lld %lld %lld&quot;, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l); LL b = n - m, a = x - y; if (b &lt; 0) { b = -b, a = -a; } exgcd(b, l, gcd, x1, y1); if (a % gcd) { printf(&quot;Impossible\\n&quot;); } else { LL ans = ((x1 * (a / gcd)) % (l / gcd) + (l / gcd)) % (l / gcd); printf(&quot;%lld\\n&quot;, ans); } return 0;}/* 26ms 916kB */","link":"/p/1f4bfad8.html"},{"title":"「NOIp2016」题解","text":"$???$就一道紫题$???$,还是$D1T2\\ ???$ $D1T1$ 玩具迷题简单的__模拟__,没的说 代码123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;struct Node{ int towards; string name;} a[100001];int n, m, ai, si;int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i].towards &gt;&gt; a[i].name; } int peo = 0; for (int i = 1; i &lt;= m; ++i) { cin &gt;&gt; ai &gt;&gt; si; if (ai == 0 &amp;&amp; a[peo].towards == 0) peo = (peo + n - si) % n; else if (ai == 0 &amp;&amp; a[peo].towards == 1) peo = (peo + si) % n; else if (ai == 1 &amp;&amp; a[peo].towards == 0) peo = (peo + si) % n; else if (ai == 1 &amp;&amp; a[peo].towards == 1) peo = (peo + n - si) % n; } cout &lt;&lt; a[peo].name &lt;&lt; endl; return 0;} /* 430ms 4760kB */","link":"/p/2a6e5fce.html"},{"title":"「NOIp2017」题解","text":"NOIp2017的题比NOIp2018的题好做一点 $D1T1$ 小凯的疑惑题解推柿子(正确性未知)设$a &lt; b$ 答案为$x$所以:$$x \\equiv ma \\pmod b (1 \\leq m \\leq b - 1)$$即$x = ma + nb (1 \\leq m \\leq b - 1)$显然当$ n \\geq 0$时 $x$可以用$a, b$表示出来，不合题意因此当$n = -1$时$x$取得最大值，此时$x = ma - b$显然当$m$取得最大值$b - 1$时$x$最大，此时$x = (b - 1)a - b = ab - a - b$因此$a, b$所表示不出的最大的数是$$\\boxed{ab - a - b}$$ 代码1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;long long a, b;int main() { scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b); printf(&quot;%lld\\n&quot;, a * b - a - b); return 0;}/* 60ms 948kB */ $D1T2$ 时间复杂度毒瘤大模拟没什么好说的,直接上代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;string str1, str2; int cal, O, NumOfLoop, vis[27], var[27], Onow, Kill, AddO[100], Omax, WhereKill, T;int main() { cin &gt;&gt; T; while (T &gt; 0) { T--; cal = 0; O = 0; Omax = 0; WhereKill = 0; NumOfLoop = 0; Onow = 0; Kill = 0; memset(vis, 0, sizeof(vis)); memset(AddO, 0, sizeof(AddO)); do { str1 = str2; cin &gt;&gt; str2; } while(str2[0] != 'O'); for (int i = 0; i &lt; str1.length(); i++) cal = cal * 10 + str1[i] - '0'; for (int i = 4; i &lt; str2.length() - 1; i++) O = O * 10 + str2[i] - '0'; while (cal &gt; 0) { cal--; cin &gt;&gt; str1; if (str1[0] == 'F') { NumOfLoop++; cin &gt;&gt; str1; if (vis[str1[0] - 96]) { NumOfLoop = -1; } else { vis[str1[0] - 96] = 1; var[NumOfLoop] = str1[0] - 96; } cin &gt;&gt; str1 &gt;&gt; str2; if (str1[0] != 'n' &amp;&amp; str2[0] == 'n' &amp;&amp; Kill == 0) { Onow++; AddO[NumOfLoop] = 1; } else if (((str1.length() == str2.length() &amp;&amp; str1 &gt; str2) || (str1.length() &gt; str2.length()) || (str1[0] == 'n' &amp;&amp; str2[0] != 'n')) &amp;&amp; Kill == 0) { Kill = 1; WhereKill = NumOfLoop; } } else { Omax = max(Omax, Onow); vis[var[NumOfLoop]] = 0; if (AddO[NumOfLoop] == 1) { Onow--; AddO[NumOfLoop] = 0; } NumOfLoop--; if (WhereKill &gt; 0 &amp;&amp; NumOfLoop &lt; WhereKill) { Kill = 0; WhereKill = 0; } } if(NumOfLoop == -1) { printf(&quot;ERR\\n&quot;); cal = -1; } } if (NumOfLoop &gt; 0) printf(&quot;ERR\\n&quot;); if (NumOfLoop == 0 &amp;&amp; Omax == O) printf(&quot;Yes\\n&quot;); if (NumOfLoop == 0 &amp;&amp; Omax != O) printf(&quot;No\\n&quot;); } return 0;}/* 34ms 756kB */ $D1T3$ 逛公园本题思路来自安妮007的题解 题解 先SPFA求最短路 再反向SPFA排除无法到达的边 再记忆化搜索走冤枉路的最优方案 详细见安妮007的题解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x7fffffff;const int maxn = 100010;struct Node { int x, y; Node(int x, int y): x(x), y(y) {}};int n, m, k, p, T;vector&lt;Node&gt; v[maxn], s[maxn];int d[maxn], ans[maxn][60];bool vis[maxn][60], alive[maxn];queue&lt;int&gt; q, f;int dfs(int a, int b) { //a当前点,b允许走的冤枉路长度 if (b &lt; 0) { return 0; } else if (vis[a][b] == 1) { //又回来了 return -inf; //无穷多种(-inf用于判断) } else if (ans[a][b] != -1) { //算过了 return ans[a][b]; } else { vis[a][b] = true; int key = 0; if (a == n) { //到目的地 key++; } for (int i = 0; i &lt; v[a].size(); ++i) { int g = v[a][i].x, y = v[a][i].y; //g本条边终点,y权值 int u = d[g] - d[a]; if (alive[g] == 0) { //不能到终点 continue; } int w = dfs(g, b - (y - u)); if (w == -inf) { return -inf; } else { key = (key + w) % p; } } ans[a][b] = key % p; vis[a][b] = false; //回溯 return key; }}void safe() { //排除无法到终点的点(反向SPFA) f.push(n); alive[n] = 1; //点n自身可以到达 while (!f.empty()) { int h = f.front(); f.pop(); for (int i = 0; i &lt; s[h].size(); ++i) { int g = s[h][i].x; if (alive[g] == 0) { alive[g] = 1; f.push(g); } } } return ;}void spfa() { //SPFA求最短路 q.push(1); d[1] = 0; while (!q.empty()) { int h = q.front(); q.pop(); for (int i = 0; i &lt; v[h].size(); ++i) { int g = v[h][i].x, y = v[h][i].y; if (d[h] + y &lt; d[g]) { d[g] = d[h] + y; q.push(g); } } } return ;}int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;k, &amp;p); for (int i = 1; i &lt;= n; ++i) { v[i].clear(); s[i].clear(); alive[i] = 0; for (int j = 0; j &lt;= k; ++j) { ans[i][j] = -1; vis[i][j] = 0; } } for (int i = 0; i &lt; m; ++i) { int a, b, c; scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); v[a].push_back(Node(b, c)); //正向边 s[b].push_back(Node(a, c)); //反向边 } for (int i = 2; i &lt;= n; ++i) { d[i] = inf; } spfa(); //SPFA求最短路 safe(); int z = dfs(1, k); if (z == -inf) { printf(&quot;-1\\n&quot;); } else { printf(&quot;%d\\n&quot;, z); } } return 0;}/* 6488ms 44632kB with O2 */ $D2T1$ 奶酪题解没什么好说的,直接__搜索__存好每个点,排序,从下向上搜 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;bool fini = false, vis[maxn];int T, n, h, r;struct Node { double x, y, z;} node[maxn];bool cmp(Node a, Node b) { return a.z &gt; b.z;}double dist(Node a, Node b) { return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2) + pow(a.z - b.z, 2));}void dfs(Node now, int num) { if (now.z + r &gt;= h) { fini = true; return; } vis[num] = true; for (int i = 1; i &lt;= n; ++i) { if (fini) { return; } else if (!vis[i] &amp;&amp; dist(node[i], now) &lt;= r * 2) { dfs(node[i], i); } }}int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { fini = false; memset(node, 0, sizeof(node)); memset(vis, 0, sizeof(vis)); scanf(&quot;%d %d %d&quot;, &amp;n, &amp;h, &amp;r); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%lf %lf %lf&quot;, &amp;node[i].x, &amp;node[i].y, &amp;node[i].z); } sort(node + 1, node + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) { if (node[i].z - r &lt;= 0) { dfs(node[i], i); } } printf(fini ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); } return 0;}/* 157ms 832kB */ $D2T2$ 宝藏题解状压?? 模拟退火?? 不存在的 蒟蒻不会__搜索+剪枝__能很快AC掉这道紫题不解释了 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int inf = 0x3f3f3f3f;int vis[20], dis[20], num[20]; //已访问的点,距1的距离,可以到达的点数int c[20][20], G[20][20]; //费用,图int ans = inf, tmp, tot, cnt, n, m, p;bool cmp(int a, int b) { return c[p][a] &lt; c[p][b];}void dfs(int u, int node) { for (int i = u; i &lt;= cnt; ++i) { if(tot + tmp * dis[vis[i]] &gt;= ans) return; for (int j = node; j &lt;= num[vis[i]]; ++j) { if(!dis[G[vis[i]][j]]) { cnt++; vis[cnt] = G[vis[i]][j]; tmp -= c[vis[cnt]][G[vis[cnt]][1]]; tot += c[vis[i]][vis[cnt]] * dis[vis[i]]; dis[vis[cnt]] = dis[vis[i]] + 1; dfs(i, j + 1); tot -= c[vis[i]][vis[cnt]] * dis[vis[i]]; dis[vis[cnt]] = 0; tmp += c[vis[cnt]][G[vis[cnt]][1]]; cnt--; } } node = 1; } if(cnt == n) { if(tot &lt; ans) ans = tot; return; }}int main() { int u, v, w; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { c[i][j] = inf; } } for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w); if(c[u][v] &lt; w) continue; if(c[u][v] == inf) { G[u][++num[u]] = v; G[v][++num[v]] = u; } c[u][v] = c[v][u] = w; } for (int i = 1; i &lt;= n; ++i) { p = i; sort(G[i] + 1, G[i] + 1 + num[i], cmp); tmp += c[i][G[i][1]]; } for (int i = 1; i &lt;= n; ++i) { tot = 0; cnt = 1; vis[1] = i; tmp -= c[i][G[i][1]]; dis[i] = 1; dfs(1, 1); dis[i] = 0; tmp += c[i][G[i][1]]; } printf(&quot;%d&quot;, ans); return 0;}/* 65ms 808kB */ $D2T3$ 列队平衡树?? $Splay$?? $FHQ\\_Treap$?? 不会模拟拿下$50$分,以后再说,逃 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}const int maxn = 300010;struct Node { int x, y;} a[maxn];int n, m, q, tot;LL last[maxn], h[maxn], pos[510][50010], ans;int main() { n = read(); m = read(); q = read(); for (int i = 1; i &lt;= q; ++i) { a[i].x = read(); a[i].y = read(); h[i] = a[i].x; } for (int i = 1; i &lt;= n; ++i) { last[i] = last[i - 1] + m; } sort(h + 1, h + q + 1); //排序 tot = unique(h + 1, h + q + 1) - h - 1; //去重 LL t; for (int i = 1; i &lt;= tot; ++i) { //编号 t = (LL)(h[i] - 1) * m; for (int j = 1; j &lt;= m; ++j) { pos[i][j] = ++t; } } int where; //a[i].x在h数组中的位置 for (int i = 1; i &lt;= q; ++i) { //模拟 for (int j = 1; j &lt;= tot; ++j) { if (h[j] == a[i].x) { where = j; break; } } if (a[i].y == m) { //在最后一列 ans = last[h[where]]; } else { ans = pos[where][a[i].y]; } printf(&quot;%lld\\n&quot;, ans); if (a[i].y != m) { //向左看齐 for (int j = a[i].y; j &lt; m - 1; ++j) { pos[where][j] = pos[where][j + 1]; } pos[where][m - 1] = last[h[where]]; } for (int j = h[where]; j &lt; n; ++j) { //向前看齐 last[j] = last[j + 1]; } last[n] = ans; } return 0;}/* 50Points 13662ms 67344kB */ 如有疑问,可以在下方评论区留言","link":"/p/c5ac34f0.html"},{"title":"「网络流24题」魔术球问题-题解","text":"题目传送门: 「Luogu P2765」魔术球问题 题目大意输入柱子数$n$满足如下规则 每次只能在某根柱子的最上面放球。 在同一根柱子中，任何2个相邻球的编号之和为完全平方数。输出在第$n$根柱子上最多能放多少球和放置方案 题解并不打算使用网络流,用贪心即可贪心策略: 如果可以的话尽可能放在已有的柱子上 代码12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; a[110];bool can[4010];int n, ans = 1, cnt;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i * i &lt;= 4000; ++i) { can[i * i] = true; } while (true) { for (int i = 1; i &lt;= cnt; ++i) { if (can[ ans + a[ i ][ a[i].size() - 1 ] ]) { a[i].push_back(ans++); i = 0; continue; } } if (cnt &lt; n) { cnt++; a[cnt].push_back(ans++); } else break; } printf(&quot;%d\\n&quot;, ans - 1); for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt; a[i].size(); ++j) { printf(&quot;%d &quot;, a[i][j]); } printf(&quot;\\n&quot;); } return 0;}","link":"/p/f2e850c0.html"},{"title":"「网络流24题」最小路径覆盖问题-题解","text":"题目传送门: 「Luogu P2764」最小路径覆盖问题 题目大意题目描述给的很直白,输入点数边数和有向边,输出最少路径数和路径 题解正常建图如果一条路径的终点和另一条路径的起点有连边，那么这两条路径是可以合并的。但是一个终点或起点只能使用一次。比如三条路径$1 \\rightarrow 3, 2 \\rightarrow 3, 3 \\rightarrow 4$，你只能合并两条。那么这道题就转化为了：最大化一个边集，使得边集中每个起点和终点都只使用过一次。即__最大独立边集__。把每个点拆成入点$x$和出点$x’$,从源点到$x’$连一条容量为$1$的边，从$x$到汇点连一条容量为$1$的边。边权用来限制每个起点或终点的使用次数。对于每条边$x \\rightarrow y$，连接$x’ \\rightarrow y$答案是$n-最大流$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1010;const int inf = 0x3f3f3f3f;bool vis[maxn], vst[maxn];int n, m, s, t;int d[maxn], cur[maxn], to[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = true; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { to[x] = e.to; e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int maxflow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); s = 0; t = 2 * n + 1; for (int i = 1; i &lt;= m; ++i) { int u, v; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); add(u, v + n, 1); } for (int i = 1; i &lt;= n; ++i) add(s, i, 1); for (int i = 1; i &lt;= n; ++i) add(i + n, t, 1); int ans = maxflow(s, t); for (int i = 1; i &lt;= n; ++i) { if (!vst[i]) { int x = i; vst[x] = true; printf(&quot;%d &quot;, x); while (to[x] &amp;&amp; to[x] != t) { x = to[x] - n; printf(&quot;%d &quot;, x); vst[x] = true; } printf(&quot;\\n&quot;); } } printf(&quot;%d\\n&quot;, n - ans); return 0;}","link":"/p/7973b062.html"},{"title":"「网络流24题」试题库问题-题解","text":"题目传送门: 「Luogu P2763」试题库问题 题目大意假设一个试题库中有$n$道试题,每道试题都标明了所属类别,同一道题可能有多个类别属性,现要从题库中抽取$m$道题组成试卷,并要求试卷包含指定类型的试题,输出出题方案 题解建图: 类型与汇点连容量为题目数的边;题目与源点连容量为$1$的边;题目与所属类型连容量为$1$的边结果: 如果满流则可以实现(沿满流输出即可),没有满流输出No Solution! 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 2020;const int inf = 0x3f3f3f3f;bool vis[maxn];int k, n, s, t, sum, d[maxn], cur[maxn];int ans[maxn], ansi;struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = true; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;k, &amp;n); s = 0; t = n + k + 1; for (int i = 1; i &lt;= k; ++i) { int type; scanf(&quot;%d&quot;, &amp;type); sum += type; add(n + i, t, type); } for (int i = 1; i &lt;= n; ++i) { add(s, i, 1); int p, type; scanf(&quot;%d&quot;, &amp;p); for (int j = 1; j &lt;= p; ++j) { scanf(&quot;%d&quot;, &amp;type); add(i, type + n, 1); } } int maxflow = MaxFlow(s, t); if (maxflow == sum) { for (int i = n + 1; i &lt;= n + k; ++i) { printf(&quot;%d: &quot;, i - n); for (int j = 0; j &lt; G[i].size(); ++j) { Edge&amp; e = edges[G[i][j]]; if (e.cap == 0 &amp;&amp; e.flow != 0) { printf(&quot;%d &quot;, e.to); } } printf(&quot;\\n&quot;); } } else { printf(&quot;No Solution!\\n&quot;); } return 0;}","link":"/p/5a8ce31f.html"},{"title":"「Luogu P5020 P1621 P4942」小练习-题解","text":"$\\mathcal{「P5020」}$ 货币系统表面上是数论，其实就是个__动态规划__ 首先设$A = (n, a) \\ \\ B = (m, b)$可以证明$B \\subseteq A$$proof:$ 我们设$x\\in A$且$x$不能被$A$集合内除它以外的元素组成。 然后我们假设$x \\notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。 那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。 综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内$Q.E.D$ 然后动态规划dp[i]表示$i$面值最多能被几张钱表示则若其不能被表示dp[i] = -inf能表示且只有它自己则dp[i] = 1初始化dp[] = -inf; dp[0] = 0状态转移方程为dp[j] = max(dp[j], dp[j - a[i]] + 1) 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int n, T, ans, a[1010], dp[30010];int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { memset(dp, -0x3f, sizeof(dp)); memset(a, 0, sizeof(a)); ans = 0; dp[0] = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = a[i]; j &lt;= 25010; ++j) { dp[j] = max(dp[j], dp[j - a[i]] + 1); } } for (int i = 1; i &lt;= n; ++i) { if (dp[a[i]] == 1) { ans++; } } printf(&quot;%d\\n&quot;, ans); } return 0;}/* 862ms 944kB */ $\\mathcal{「P1621」}$ 集合使用__并查集和埃氏筛法__(埃拉托斯特尼筛法)即可具体操作是边筛边合并集合 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int ufs[maxn], a, b, p, ans;bool isprime[maxn];int find(int x) { return ufs[x] == x ? x : ufs[x] = find(ufs[x]);}int main() { scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;p); ans = b - a + 1; //初始个数为区间内数的个数 for (int i = a; i &lt;= b; ++i) { //初始化 ufs[i] = i; } for (int i = 2; i &lt;= b; ++i) { //埃氏筛 if (!isprime[i]) { if (i &gt;= p) { //大于p才合并 for (int j = i * 2; j &lt;= b; j += i) { isprime[j] = true; if (j - i &gt;= a &amp;&amp; find(j) != find(j - i)) { //合并 ufs[find(j)] = find(j - i); --ans; } } } else { //不大于p但要标记 for (int j = i * 2; j &lt;= b; j += i) { isprime[j] = true; } } } } printf(&quot;%d\\n&quot;, ans); return 0;}/* 38ms 1312kB */ $\\mathcal{「P4942」}$ 小凯的数字类似于$NOIp2017\\ D1T1$ 小凯的疑惑,推柿子即可 首先$l(l+1)(l+2)…(r-1)r$可以表示为$l\\times 10^? + (l + 1)\\times 10^? + … + r\\times 10^?$同时我们知道$10$的若干次方除以$9$的余数__恒为__$1$所以$l(l+1)(l+2)…(r-1)r$除以$9$的余数就等于$l + (l + 1) + … + (r - 1) + r$的余数并且$l,l+1,…,r$为等差数列,公差为$1$运用等差数列求和公式即可求解 $a_1 = l\\ d = 1$$n = r - l + 1$$S_n = n\\times a_1 + n\\times (n - 1)\\times \\frac{d}{2}$所以$$\\boxed{Ans = n\\times l + n\\times (n - 1) \\div 2}$$ 另外要边算边取模,除以$2$要变成乘模$9$下的逆元$5$所以公式如下ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9; 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int T;long long l, r, n, ans;int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%lld %lld&quot;, &amp;l, &amp;r); n = (r - l + 1) % 9; ans = (n * (l % 9) % 9 + n * (n - 1) % 9 * 5 % 9) % 9; printf(&quot;%lld\\n&quot;, ans); } return 0;}/* 32ms 888kB */ 如有疑问,可以在下方评论区留言","link":"/p/eb0c7a6c.html"},{"title":"「网络流24题」飞行员配对方案问题-题解","text":"题目传送门: 「Luogu P2756」飞行员配对方案数问题 题目大意输入两方飞行员个数$m,n$,再给定两方飞行员可以配合的人编号$i,j$(以$-1,-1$结束)输出最多配对数和配对方案 题解主要在建图皇家空军与源点$s$连容量$1$的边,外籍与汇点$t$连容量$1$的边,可配合的两点间连容量为$1$的边输出最大流即可(要找配对方案) 也可以使用匈牙利算法(本文不给出) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 120;const int inf = 0x3f3f3f3f;int n, m, s, t;int d[maxn], cur[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){};};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c) { edges.push_back(Edge(u, v, c, 0)); edges.push_back(Edge(v, u, 0, 0)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool vis[maxn];bool bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int dfs(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = dfs(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (bfs()) { memset(cur, 0, sizeof(cur)); flow += dfs(s, inf); } return flow;}int main() { scanf(&quot;%d %d&quot;, &amp;m, &amp;n); s = 0; t = n + 1; int u, v; while (scanf(&quot;%d %d&quot;, &amp;u, &amp;v) == 2 &amp;&amp; u != -1 &amp;&amp; v != -1) { add(u, v, 1); } for (int i = 1; i &lt;= m; ++i) { add(s, i, 1); } for (int i = m + 1; i &lt;= n; ++i) { add(i, t, 1); } int flow = MaxFlow(s, t); if (flow == 0) { printf(&quot;No Solution!\\n&quot;); return 0; } printf(&quot;%d\\n&quot;, flow); for (int i = 0; i &lt; edges.size(); i = i + 2) { if (edges[i].from != s &amp;&amp; edges[i].to != t) { if (edges[i].flow != 0) { printf(&quot;%d %d\\n&quot;, edges[i].from, edges[i].to); } } } return 0;}","link":"/p/154ff24f.html"},{"title":"Cpp算法-网络流相关","text":"网络流算法相关模板,讲解__以后再说吧__,咕咕咕 注:本文使用vector建图 网络最大流Edmonds-Karp算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int n, m, s, t, ans;struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];int a[maxn], p[maxn];void add(int from, int to, int cap) { edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}void EdmondsKarp() { ans = 0; for (;;) { memset(a, 0, sizeof(a)); queue&lt;int&gt; Q; Q.push(s); a[s] = 0x3f3f3f3f; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!a[e.to] &amp;&amp; e.cap &gt; e.flow) { p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); Q.push(e.to); } } if (a[t]) break; } if (!a[t]) break; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } ans += a[t]; } return;} Dinic算法(常用)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int maxn = 10010;int n, m, s, t, d[maxn], cur[maxn];struct Edge { int from, to, cap, flow;};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back((Edge) {from, to, cap, 0}); edges.push_back((Edge) {to, from, 0, 0}); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}bool vis[maxn];bool BFS() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(s); d[s] = 0; vis[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) { vis[e.to] = 1; d[e.to] = d[x] + 1; Q.push(e.to); } } } return vis[t];}int DFS(int x, int a) { if (x == t || a == 0) return a; int flow = 0, f; for (int&amp; i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (d[x] + 1 == d[e.to] &amp;&amp; (f = DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) { e.flow += f; edges[G[x][i] ^ 1].flow -= f; flow += f; a -= f; if (a == 0) break; } } return flow;}int MaxFlow(int s, int t) { int flow = 0; while (BFS()) { memset(cur, 0, sizeof(cur)); flow += DFS(s, 0x3f3f3f3f); } return flow;} ISAP算法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const int maxn = 10010;const int inf = 0x3f3f3f3f;int n, m, s, t;int d[maxn], p[maxn], num[maxn], cur[maxn];bool vis[maxn];struct Edge { int from, to, cap, flow; Edge(int u, int v, int c, int f): from(u), to(v), cap(c), flow(f){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int from, int to, int cap) { edges.push_back(Edge(from, to, cap, 0)); edges.push_back(Edge(to, from, 0, 0)); int mm = edges.size(); G[from].push_back(mm - 2); G[to].push_back(mm - 1);}void bfs() { memset(vis, 0, sizeof(vis)); queue&lt;int&gt; Q; Q.push(t); d[t] = 0; vis[t] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (!vis[e.from] &amp;&amp; e.cap &gt; e.flow) { vis[e.from] = 1; d[e.from] = d[x] + 1; Q.push(e.from); } } }}int Augment() { int x = t, a = inf; while (x != s) { Edge&amp; e = edges[p[x]]; a = min(a, e.cap - e.flow); x = edges[p[x]].from; } x = t; while (x != s) { edges[p[x]].flow += a; edges[p[x] ^ 1].flow -= a; x = edges[p[x]].from; } return a;}int ISAP(int s, int t) { int flow = 0; bfs(); memset(num, 0, sizeof(num)); for (int i = 0; i &lt; n; ++i) num[d[i]]++; int x = s; memset(cur, 0, sizeof(cur)); while (d[s] &lt; n) { if (x == t) { flow += Augment(); x = s; } int ok = 0; for (int i = cur[x]; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[x] == d[e.to] + 1) { ok = 1; p[e.to] = G[x][i]; cur[x] = i; x = e.to; break; } } if (!ok) { int mm = n - 1; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow) mm = min(mm, d[e.to]); } if (--num[d[x]] == 0) break; num[d[x] = mm + 1]++; cur[x] = 0; if (x != s) x = edges[p[x]].from; } } return flow;} 最小费用最大流Bellman-Ford算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const int maxn = 10010;const int inf = 0x3f3f3f3f;int n, m, s, t, ansflow;int vis[maxn], d[maxn], p[maxn], a[maxn];long long anscost;struct Edge { int from, to, cap, flow, cost; Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}};vector&lt;Edge&gt; edges;vector&lt;int&gt; G[maxn];void add(int u, int v, int c, int w) { edges.push_back(Edge(u, v, c, 0, w)); edges.push_back(Edge(v, u, 0, 0,-w)); int mm = edges.size(); G[u].push_back(mm - 2); G[v].push_back(mm - 1);}bool BellmanFord(int&amp; flow, long long&amp; cost) { for (int i = 1; i &lt;= n; ++i) d[i] = inf; memset(vis, 0, sizeof(vis)); d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf; queue&lt;int&gt; Q; Q.push(s); while (!Q.empty()) { int x = Q.front(); Q.pop(); vis[x] = 0; for (int i = 0; i &lt; G[x].size(); ++i) { Edge&amp; e = edges[G[x][i]]; if (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[x] + e.cost) { d[e.to] = d[x] + e.cost; p[e.to] = G[x][i]; a[e.to] = min(a[x], e.cap - e.flow); if (!vis[e.to]) { Q.push(e.to); vis[e.to] = 1; } } } } if (d[t] == inf) return false; flow += a[t]; cost += (long long)d[t] * (long long)a[t]; for (int u = t; u != s; u = edges[p[u]].from) { edges[p[u]].flow += a[t]; edges[p[u] ^ 1].flow -= a[t]; } return true;}int MinCostMaxFlow(long long&amp; cost) { int flow = 0; cost = 0; while (BellmanFord(flow, cost)); return flow;}","link":"/p/c3cdab79.html"},{"title":"算法笔记-计算几何","text":"啥也不说了,直接上代码,每个函数功能已经以注释方式给出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453/************************************************************* * &gt; Description : 计算几何模板 * &gt; Copyright (C) 2019 Tony**************************************************************/#include &lt;bits/stdc++.h&gt;using namespace std;const double eps = 1e-10; //精度const double PI = acos(-1);/** * @brief 点(向量) * @param x 横坐标 * @param y 纵坐标 */struct Point { double x, y; Point(double x = 0, double y = 0): x(x), y(y) {}};typedef Point Vector;Vector operator + (Vector a, Vector b) { return Vector(a.x + b.x, a.y + b.y); }Vector operator - (Vector a, Vector b) { return Vector(a.x - b.x, a.y - b.y); }Vector operator * (Vector a, double p) { return Vector(a.x * p, a.y * p); }Vector operator / (Vector a, double p) { return Vector(a.x / p, a.y / p); }/** * @brief 带精度比较(三态函数) * @param[in] x 输入 * @return 大小关系：等于0(0), 小于零(-1), 大于零(1) */int dcmp(double x) { if (fabs(x) &lt; eps) return 0; else return x &lt; 0 ? -1 : 1;}bool operator &lt; (const Point&amp; a, const Point&amp; b) { return a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);}bool operator == (const Point&amp; a, const Point&amp; b) { return dcmp(a.x - b.x) == 0 &amp;&amp; dcmp(a.y - b.y) == 0;}double Dot(Vector a, Vector b) { return a.x * b.x + a.y * b.y; }double Length(Vector a) { return sqrt(Dot(a, a)); }double Angle(Vector a, Vector b) { return acos(Dot(a, b) / Length(a) / Length(b)); }double Cross(Vector a, Vector b) { return a.x * b.y - a.y * b.x; }double Area2(Point a, Point b, Point c) { return Cross(b - a, c - a); }double Dist2(const Point&amp; A, const Point&amp; B) { return (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y); }double angle(Vector v) { return atan2(v.y, v.x); }/** * @brief 向量旋转 * @param[in] a 向量 * @param[in] rad 旋转角度(逆时针) * @return 旋转后的向量 */Vector Rotate(Vector a, double rad) { return Vector(a.x * cos(rad) - a.y * sin(rad), a.x * sin(rad) + a.y * cos(rad));}/** * @brief 求单位向量 * @param[in] a 向量 * @return 沿向量a的单位向量 */Vector Normal(Vector a) { double L = Length(a); return Vector(-a.y / L, a.x / L);}/** * @brief 两条直线交点 * @param[in] p 第一条直线的起始点 * @param[in] v 第一条直线的方向向量 * @param[in] q 第二条直线的起始点 * @param[in] w 第二条直线的方向向量 * @return 两条直线交点 */Point GetLineIntersection(Point p, Vector v, Point q, Vector w) { Vector u = p - q; double t = Cross(w, u) / Cross(v, w); return p + v * t;}/** * @brief 点到直线距离 * @param[in] p 点 * @param[in] a,b 直线上两点 * @return 点到直线距离 */double DistanceToLine(Point p, Point a, Point b) { Vector v1 = b - a, v2 = p - a; return fabs(Cross(v1, v2)) / Length(v1);}/** * @brief 点到线段距离 * @param[in] p 点 * @param[in] a,b 线段两端点 * @return 点到线段距离 */double DistanceToSegment(Point p, Point a, Point b) { if (a == b) return Length(p - a); Vector v1 = b - a, v2 = p - a, v3 = p - b; if (dcmp(Dot(v1, v2)) &lt; 0) return Length(v2); else if (dcmp(Dot(v1, v3)) &gt; 0) return Length(v3); else return fabs(Cross(v1, v2)) / Length(v1);}/** * @brief 点在直线上投影点 * @param[in] p 点 * @param[in] a,b 直线上两点 * @return 点在直线上投影点 */Point GetLineProjection(Point p, Point a, Point b) { Vector v = b - a; return a + v * (Dot(v, p - a) / Dot(v, v));}/** * @brief 线段相交判定(不含端点) * @param[in] a1,a2 第一条线段端点 * @param[in] b1,b2 第二条线段端点 * @return 是否相交(bool) */bool SegmentProperIntersection(Point a1, Point a2, Point b1, Point b2) { double c1 = Cross(a2 - a1, b1 - a1), c2 = Cross(a2 - a1, b2 - a1), c3 = Cross(b2 - b1, a1 - b1), c4 = Cross(b2 - b1, a2 - b1); return dcmp(c1) * dcmp(c2) &lt; 0 &amp;&amp; dcmp(c3) * dcmp(c4) &lt; 0;}/** * @brief 点在线段上判定(不包括端点) * @param[in] p 点 * @param[in] a1,a2 线段两端点 * @return 是否在线段上(bool) */bool OnSegment(Point p, Point a1, Point a2) { return dcmp(Cross(a1 - p, a2 - p)) == 0 &amp;&amp; dcmp(Dot(a1 - p, a2 - p)) &lt; 0;}/** * @brief 多边形面积 * @param[in] *p 顶点数组 * @param[in] * @return */double PolygonArea(Point* p, int n) { double area = 0; for (int i = 1; i &lt; n - 1; ++i) { area += Cross(p[i] - p[0], p[i + 1] - p[0]); } return area / 2;}/** * @brief 直线(参数式) * @param p 直线上的一点 * @param v 方向向量 * @param ang 方向向量极角 * @function point(double t) * @brief 直线上的点 * @param[in] t 横坐标 * @return 直线上的点 * @function move(double d) * @brief 沿直线移动 * @param[in] d 平移距离 * @return 平移后的直线 */struct Line { Point p; Vector v; double ang; Line() {} Line(Point p, Vector v): p(p), v(v) { ang = atan2(v.y, v.x); } bool operator &lt; (const Line&amp; L) const { return ang &lt; L.ang; } Point point(double t) { return p + v * t; } Line move(double d) { return Line(p + Normal(v) * d, v); }};/** * @brief 是否在直线左侧 * @param[in] L 直线 * @param[in] p 点 * @return 是否在点左侧(bool) */bool OnLeft(Line L, Point p) { return Cross(L.v, p - L.p) &gt; 0;}/** * @brief 两条直线交点(重载) * @param[in] a 第一条直线 * @param[in] b 第二条直线 * @return 两条直线交点 */Point GetLineIntersection(Line a, Line b) { Vector u = a.p - b.p; double t = Cross(b.v, u) / Cross(a.v, b.v); return a.p + a.v * t;}/** * @brief 圆 * @param c 圆心 * @param r 半径 * @function point(double a) * @brief 圆上的点 * @param[in] a 横坐标 * @return 圆上的点 */struct Circle { Point c; double r; Circle(Point c, double r): c(c), r(r) {} Point point(double a) { return Point(c.x + cos(a) * r, c.y + sin(a) * r); }};/** * @brief 直线和圆交点 * @param[in] L 直线 * @param[in] C 圆 * @param[out] t1,t2 交点横坐标 * @param[out] sol 交点集(vector) * @return 交点个数 */int GetLineCircleIntersection(Line L, Circle C, double&amp; t1, double&amp; t2, vector&lt;Point&gt;&amp; sol) { double a = L.v.x, b = L.p.x - C.c.x, c = L.v.y, d = L.p.y - C.c.y; double e = a * a + c * c, f = 2 * (a * b + c * d), g = b * b + d * d - C.r * C.r; double delta = f * f - 4 * e * g; if (dcmp(delta) &lt; 0 ) return 0; if (dcmp(delta) == 0) { t1 = t2 = -f / (2 * e); sol.push_back(L.point(t1)); return 1; } t1 = (-f - sqrt(delta)) / (2 * e); sol.push_back(L.point(t1)); t2 = (-f + sqrt(delta)) / (2 * e); sol.push_back(L.point(t2)); return 2;}/** * @brief 圆和圆交点 * @param[in] C1,C2 两圆 * @param[out] sol 交点集(vector) * @return 交点个数 */int GetCircleCircleIntersection(Circle C1, Circle C2, vector&lt;Point&gt;&amp; sol) { double d = Length(C1.c - C2.c); if (dcmp(d) == 0) { if (dcmp(C1.r - C2.r) == 0) return -1; return 0; } if (dcmp(C1.r + C2.r - d) &lt; 0) return 0; if (dcmp(fabs(C1.r - C2.r) - d) &gt; 0) return 0; double a = angle(C2.c - C1.c); double da = acos((C1.r * C1.r + d * d - C2.r * C2.r) / (2 * C1.r * d)); Point p1 = C1.point(a - da), p2 = C1.point(a + da); sol.push_back(p1); if (p1 == p2) return 1; sol.push_back(p2); return 2;}/** * @brief 求切线 * @param[in] p 点 * @param[in] C 圆 * @param[out] *v 切线 * @return 切线条数 */int getTangents(Point p, Circle C, Vector* v) { Vector u = C.c - p; double dist = Length(u); if (dist &lt; C.r) return 0; else if (dcmp(dist - C.r) == 0) { v[0] = Rotate(u, PI / 2); return 1; } else { double ang = asin(C.r / dist); v[0] = Rotate(u, -ang); v[1] = Rotate(u, +ang); return 2; }}/** * @brief 两圆公切线 * @param[in] A,B 两圆 * @param[out] *a,*b 切点 * @return 公切线条数 */int getTangents(Circle A, Circle B, Point* a, Point* b) { int cnt = 0; if (A.r - B.r) { swap(A, B); swap(a, b); } int d2 = (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y); int rdiff = A.r - B.r; int rsum = A.r + B.r; if (d2 &lt; rdiff * rdiff) return 0; double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x); if (d2 == 0 &amp;&amp; A.r == B.r) return -1; if (d2 == rdiff * rdiff) { a[cnt] = A.point(base); b[cnt] = B.point(base); cnt++; return 1; } double ang = acos((A.r - B.r) / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(base - ang); cnt++; if (d2 == rsum * rsum) { a[cnt] = A.point(base); b[cnt] = B.point(PI + base); cnt++; } else if (d2 &gt; rsum * rsum) { double ang = acos((A.r + B.r) / sqrt(d2)); a[cnt] = A.point(base + ang); b[cnt] = B.point(PI + base + ang); cnt++; a[cnt] = A.point(base - ang); b[cnt] = B.point(PI + base - ang); cnt++; } return cnt;}typedef vector&lt;Point&gt; Polygon;/** * @brief 判定点在多边形内 * @param[in] p 点 * @param[in] poly 多边形 * @return 是否在多边形内(在1,不在0,在边上-1) */int isPointInPolygon(Point p, Polygon poly) { int wn = 0; int n = poly.size(); for (int i = 0; i &lt; n; ++i) { if (OnSegment(p, poly[i], poly[(i + 1) % n])) return -1; int k = dcmp(Cross(poly[(i + 1) % n] - poly[i], p - poly[i])); int d1 = dcmp(poly[i].y - p.y); int d2 = dcmp(poly[(i + 1) % n].y - p.y); if (k &gt; 0 &amp;&amp; d1 &lt;= 0 &amp;&amp; d2 &gt; 0) wn++; if (k &lt; 0 &amp;&amp; d2 &lt;= 0 &amp;&amp; d1 &gt; 0) wn--; } if (wn != 0) return 1; return 0;}/** * @brief 凸包 * @param[in] p 点集 * @return 凸包多边形 */Polygon ConvexHull(vector&lt;Point&gt; p) { sort(p.begin(), p.end()); p.erase(unique(p.begin(), p.end()), p.end()); int n = p.size(); int m = 0; Polygon ch(n + 1); for (int i = 0; i &lt; n; ++i) { while (m &gt; 1 &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) m--; ch[m++] = p[i]; } int k = m; for (int i = n - 2; i &gt;= 0; --i) { while (m &gt; k &amp;&amp; Cross(ch[m - 1] - ch[m - 2], p[i] - ch[m - 2]) &lt;= 0) m--; ch[m++] = p[i]; } if (n &gt; 1) m--; ch.resize(m); return ch;}/** * @brief 旋转卡壳 * @param[in] points 点集 * @return 直径 */int diameter2(vector&lt;Point&gt;&amp; points) { //旋转卡壳 vector&lt;Point&gt; p = ConvexHull(points); int n = p.size(); if (n == 1) return 0; if (n == 2) return Dist2(p[0], p[1]); p.push_back(p[0]); int ans = 0; for (int u = 0, v = 1; u &lt; n; ++u) { for(;;) { int diff = Cross(p[u + 1] - p[u], p[v + 1] - p[v]); if (diff &lt;= 0) { ans = max(ans, (int)Dist2(p[u], p[v])); if (diff == 0) ans = max(ans, (int)Dist2(p[u], p[v + 1])); break; } v = (v + 1) % n; } } return ans;}/** * @brief 切多边形 * @param[in] poly 多边形 * @param[in] A,B 直线上两点 * @return 新多边形 */Polygon CutPolygon(Polygon poly, Point A, Point B) { Polygon newpoly; int n = poly.size(); for (int i = 0; i &lt; n; ++i) { Point C = poly[i]; Point D = poly[(i + 1) % n]; if (dcmp(Cross(B - A, C - A)) &gt;= 0) newpoly.push_back(C); if (dcmp(Cross(B - A, C - D)) != 0) { Point ip = GetLineIntersection(A, B - A, C, D - C); if (OnSegment(ip, C, D)) newpoly.push_back(ip); } } return newpoly;}/** * @brief 半平面交 * @param[in] L 直线集 * @return 多边形 */vector&lt;Point&gt; HalfplaneIntersection(vector&lt;Line&gt; L) { int n = L.size(); sort(L.begin(), L.end()); int first, last; vector&lt;Point&gt; p(n); vector&lt;Line&gt; q(n); vector&lt;Point&gt; ans; q[first = last = 0] = L[0]; for (int i = 1; i &lt; n; i++) { while (first &lt; last &amp;&amp; !OnLeft(L[i], p[last - 1])) last--; while (first &lt; last &amp;&amp; !OnLeft(L[i], p[first])) first++; q[++last] = L[i]; if (fabs(Cross(q[last].v, q[last - 1].v)) &lt; eps) { last--; if (OnLeft(q[last], L[i].p)) q[last] = L[i]; } if (first &lt; last) p[last - 1] = GetLineIntersection(q[last - 1], q[last]); } while (first &lt; last &amp;&amp; !OnLeft(q[first], p[last - 1])) last--; if (last - first &lt;= 1) return ans; p[last] = GetLineIntersection(q[last], q[first]); for (int i = first; i &lt;= last; i++) ans.push_back(p[i]); return ans;}","link":"/p/1aba30fe.html"},{"title":"「NOIp2018」题解","text":"emmm，今天开始从2018向前做NOIp的真题，并写一些题解，太蒻了Orz $D1T1$ 铺设道路嗯～13年原题，__贪心AC__ 题解对区间进行“填坑”贪心策略： 1if (d[i] &gt; d[i - 1]) ans += d[i] - d[i - 1]; $proof:$ 假设现在有一个坑，旁边还有一个坑。 那肯定会同时填上两个坑，所以__小的坑会被大的坑带着填上__，及__小坑免费，大坑减少a[i] - a[i - 1]__$Q.E.D$结果还要加上a[1] 代码12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 100010;int n, d[maxn];long long ans;int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;d[i]); } for (int i = 2; i &lt;= n; ++i) { if (d[i] &gt; d[i - 1]) { ans += d[i] - d[i - 1]; } } printf(&quot;%lld&quot;, ans + d[1]); return 0;}/* 41ms 1220kB */ $D1T2$ 货币系统表面上是数论，其实就是个__动态规划__ 题解首先设$A = (n, a) \\ \\ B = (m, b)$可以证明$B \\subseteq A$$proof:$ 我们设$x\\in A$且$x$不能被$A$集合内除它以外的元素组成。 然后我们假设$x \\notin B$，那么就说明$B$集合中必然存在一些元素能够组成$x$。 那么这些元素至少存在一个不在集合$A$内并且不能被集合$A$里的元素组成的数（因为如果不存在的话集合$A$内的元素就可以组成$x$了），可以看到这与集合$B$的定义产生了矛盾。 综上所述，$A$集合内不能被其它数组成的数必然存在于$B$集合内$Q.E.D$ 然后动态规划dp[i]表示$i$面值最多能被几张钱表示则若其不能被表示dp[i] = -inf能表示且只有它自己则dp[i] = 1初始化dp[] = -inf; dp[0] = 0状态转移方程为dp[j] = max(dp[j], dp[j - a[i]] + 1) 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int n, T, ans, a[1010], dp[30010];int main() { scanf(&quot;%d&quot;, &amp;T); while (T--) { memset(dp, -0x3f, sizeof(dp)); memset(a, 0, sizeof(a)); ans = 0; dp[0] = 0; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); } for (int i = 1; i &lt;= n; ++i) { for (int j = a[i]; j &lt;= 25010; ++j) { dp[j] = max(dp[j], dp[j - a[i]] + 1); } } for (int i = 1; i &lt;= n; ++i) { if (dp[a[i]] == 1) { ans++; } } printf(&quot;%d\\n&quot;, ans); } return 0;}/* 862ms 944kB */ $D1T3$ 赛道修建这题比较复杂，先得部分分 $I.$ $m = 1$ 时最简单的情况求一条最长链，即求树的直径（记录一下最大值和次大值，每次把最大值传到它的父亲）可以通过第$1,4,5,6$个点，$20$分 代码12345678910111213141516171819namespace Meq1 { int dfs(int now, int fa) { int res1 = 0, res2 = 0; for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; res2 = max(res2, dfs(to, now) + edges[i].val); if (res2 &gt; res1) swap(res1, res2); } ans = max(ans, res1 + res2); return res1; } void solve() { dfs(1, 0); printf(&quot;%d\\n&quot;, ans); return ; }} $II.$ $a_i = 1$ 时即一个菊花图把所有边权记录下来，从大到小排序。设边权为$w$，答案即为$w_1+w_{2m-1},w_2+w_{2m-2},…,w_m+w_{m+1}$的最小值可以通过$1,5,7,8$四个点，$20$分，加上$m = 1$的情况共$35$分 代码123456789101112131415161718192021namespace Aeq1 { int arr[maxn]; bool cmp(int a, int b) { return a &gt; b; } void solve() { for (int i = head[1]; i; i = edges[i].nxt) { int to = edges[i].to; arr[to - 1] = edges[i].val; } sort(arr + 1, arr + n, cmp); ans = inf; for (int i = 1; i &lt;= m; ++i) { ans = min(ans, arr[i] + arr[2 * m - i + 1]); } printf(&quot;%d\\n&quot;, ans); return ; }} $III.$ $b_i = a_i + 1$ 时为一条链把所有边权记录下来，这种情况等价于将序列分割成$m$段，使$m$段区间和的最小值最大那么二分$m$段区间和的最小值，然后贪心扫一遍可以通过$2,9,10,11$四个点，$20$分，加上一共$55$分 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace BeqApl1 { int arr[maxn], ans; int Dfs(int now, int fa) { int res1 = 0, res2 = 0; for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; res2 = max(res2, Dfs(to, now) + edges[i].val); if (res2 &gt; res1) swap(res1, res2); } ans = max(ans, res1 + res2); return res1; } void dfs(int now, int fa) { for (int i = head[now]; i; i = edges[i].nxt) { int to = edges[i].to; if (to == fa) continue; dfs(to, now); arr[now] = edges[i].val; } } bool judge(int x) { int t = 0, now = 0; for (int i = 1; i &lt; n; ++i) { if (now + arr[i] &gt;= x) { now = 0; t++; } else { now += arr[i]; } } return t &gt;= m; } void solve() { dfs(1, 0); Dfs(1, 0); int l = 1, r = ans, mid; while (l &lt; r) { mid = l + r + 1 &gt;&gt; 1; if (judge(mid)) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot;, l); return ; }} 正解最小值最大，显然是二分这个最小值$lim$对于一个节点$u$，我们可以记录一个连接到$u$的赛道的长度$val_i$，那么可以分成两种情况进行讨论：$$\\begin{cases} val_i+dis \\geq lim \\text{直接给答案+1} \\\\ val_i+dis&lt; lim \\text{利用优先队列维护}\\end{cases}$$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;using namespace std;void read(int&amp; x) { x = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + ch - 48; ch = getchar();}}const int maxn = 50050;const int inf = 0x3f3f3f3f;int n, m, cnt, num, s[maxn], mid;struct Edge { int from, to, val; Edge(int u, int v, int w) : from(u), to(v), val(w) {}};vector&lt;Edge&gt; G[maxn];void add(int u, int v, int w) { G[u].push_back(Edge(u, v, w)); G[v].push_back(Edge(v, u, w));}int dfs(int u, int fa) { priority_queue&lt;int&gt; lh; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; sh; int ln = 0, sn = 1; for (int i = 0; i &lt; G[u].size(); ++i) { if (G[u][i].to != fa) { int d = G[u][i].val + dfs(G[u][i].to, u); sh.push(d); lh.push(d); ln++; } } while (ln &gt; 0 &amp;&amp; lh.top() &gt;= mid) {num++; lh.pop(); ln--;} int now = 0; while (ln &gt; sn) { if (u != 1 &amp;&amp; lh.top() + sh.top() &gt;= mid) { int cnt = 0; while (ln &gt; sn &amp;&amp; lh.top() + sh.top() &gt;= mid) {s[++cnt] = lh.top(); lh.pop(); ln--;} num++; sh.pop(); sn++; while (cnt &gt; 1) {lh.push(s[--cnt]); ln++;} } else if (u == 1 &amp;&amp; lh.top() + sh.top() &gt;= mid) { lh.pop(); sh.pop(); ln--; sn++; num++; } else { now = sh.top(); sh.pop(); sn++; } if (num &gt;= m) break; } if (ln &gt;= sn &amp;&amp; !lh.empty()) return lh.top(); else return now;}bool check() { num = 0; dfs(1, 0); if (num &gt;= m) return true; else return false;}int main() { read(n); read(m); int all = 0; for (int i = 1; i &lt; n; ++i) { int u, v, w; read(u); read(v); read(w); add(u, v, w); all += w; } int l = 0, r = all / m, ans = 0; while (l &lt;= r) { mid = (l + r) &gt;&gt; 1; if (check()) { l = mid + 1; ans = mid; } else { r = mid - 1; } } printf(&quot;%d\\n&quot;, ans); return 0;}/* 1050ms 11964kB with O2 */ $D2T1$ 旅行分两种情况讨论 $I.$ $m = n - 1$即无环，只要给一个点所能到达的点的编号进行一次从小到大的排序，在树上dfs一遍即可解决样例1图示： 代码123456789101112131415161718192021222324namespace SolveOne { int cnt = 0; bool vis[maxn]; void dfs(int u, int fa) { ans[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v]) { dfs(v, u); } } } void solve() { for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } dfs(1, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}/* 1050ms 11964kB with O2 */ $II.$ $m = n$存在一个环（基环树）手算一下样例2可以发现，有且仅有一条边不会通过逐个删边尝试即可，删边后和$m = n - 1$相同样例2图示： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 5050;const int inf = 0x3f3f3f3f;inline int read() { int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();} while (isdigit(ch)) {x = x * 10 + ch - 48; ch = getchar();} return x * f;}int n, m, ans[maxn], in[maxn][2];vector&lt;int&gt; G[maxn];namespace SolveOne { int cnt = 0; bool vis[maxn]; void dfs(int u, int fa) { ans[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v]) { dfs(v, u); } } } void solve() { for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } dfs(1, 0); for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}namespace SolveTwo { int cnt = 0, res[maxn], du, dv; bool vis[maxn]; bool notdel(int u, int v) { //判断该边是否被删 if ((u == du &amp;&amp; v == dv) || (u == dv &amp;&amp; v == du)) { return false; } return true; } void dfs(int u, int fa) { res[++cnt] = u; vis[u] = true; for (int i = 0; i &lt; G[u].size(); ++i) { int v = G[u][i]; if (!vis[v] &amp;&amp; notdel(u, v)) { dfs(v, u); } } } bool judge() { //判断是否为更优情况 for (int i = 1; i &lt;= n; ++i) { if (ans[i] != res[i]) { return ans[i] &gt; res[i]; } } return false; } void solve() { memset(ans, 0x3f, sizeof(ans)); for (int i = 1; i &lt;= n; ++i) { sort(G[i].begin(), G[i].end()); } for (int i = 1; i &lt;= m; ++i) { cnt = 0; memset(res, 0, sizeof(res)); memset(vis, 0, sizeof(vis)); du = in[i][0]; //删边 dv = in[i][1]; dfs(1, 0); if (judge() &amp;&amp; cnt == n) { //如果更优则更改ans[] memcpy(ans, res, sizeof(res)); } } for (int i = 1; i &lt;= n; ++i) { printf(&quot;%d &quot;, ans[i]); } }}int main() { n = read(); m = read(); for (int i = 1; i &lt;= m; ++i) { int u = read(), v = read(); G[u].push_back(v); G[v].push_back(u); in[i][0] = u; //存储输入信息 in[i][1] = v; } if (m == n - 1) { SolveOne::solve(); } else { SolveTwo::solve(); } return 0;}/* 2244ms 1276kB */ $D2T2$ 填数游戏暴力推柿子首先明确一个概念:本文的对角线指的是从左下方到右上方的有向线段$\\mathcal{Lemma}\\ I.$ 对角线上的数只会相同或递减$proof:$由上图两条黑线和题目描述即可证明$Q.E.D$ $\\mathcal{Lemma}\\ II.$ 若$(x-1, y)$与$(x, y-1)$的数相同,则以$(x,y)$为左上角,整个图形右下角的子矩阵的每条对角线(蓝)上填的数字相同$proof:$由图上两条橙线及题目描述即可证明$Q.E.D$ $\\mathcal{Lemma}\\ III.$ $Ans(n,m)=Ans(m,n)$ 正式推式子(默认$n \\leq m$) $I.$ $n = 1$ 时每个格内都有2种填法,故$\\Ans(1,m)=2^{m}$ $II.$ $n = 2$ 时两个角上各两种,剩余$m-1$条对角线每条有3种(11,10,00)故$Ans(2,m)=2\\times 2\\times 3^{m-1}=4\\times 3^{m-1}$ $III. $ $n \\geq 4$ 时 (只考虑$n = m$时)$case I.$ 左上角两数相同图中数字表示每条对角线方案数可以得出$Ans(caseI.)=2\\times 2\\times 4^{n-2}\\times 2^{n-1}=8^{n-1}$ $case II.$ 第三条对角线数字相同图中红色数字表示方案数可以得出$Ans(caseII.)=2\\times 2\\times 5\\times 4^{n-4}\\times 2^{n-1}=5\\times 2^{3n-7}$ $case III.$ 第三条对角线上数字不同可以发现左侧两行只能填01,所以可能会再次出现对角数字相同的情况 第一个出现 最后一个出现 倒数第二个出现 没有出现 注意第三条对角线可能有100,110两种情况所以$Ans(case III.)=2\\times (2\\times 4\\times 5\\times 2^{n-1}\\times \\sum_{i=0}^{n-5}{4^i} + 2\\times 4\\times 3\\times 2^{n-2} + 2\\times 3\\times 2^{n-2})$ $Ans(n, n)=Ans(case I.) + Ans(case II.) + Ans(case III.)$$$Ans(n,n)=\\frac{83\\times 8^n + 5\\times 2^{n+7}}{384}$$ $IV.$ $n = 3$证明与前类似$$Ans(3,m)=112\\times 3^{m-3}$$ $V.$ $n \\neq m$ 时与前类似$$Ans(n,n+1)=\\frac{83\\times 8^n + 2^{n+8}}{128}$$同时易证得$Ans(n,m+1)=3\\times Ans(n,m)$ 于是就解决了 代码123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define mod 1000000007using namespace std;typedef long long LL;int n, m;LL poww(LL a, LL b) { LL res = 1; for ( ; b; a = a * a % mod, b &gt;&gt;= 1){ if (b &amp; 1) { res = res * a % mod; } } return res;}int main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); if (n &gt; m) swap(n, m); if (n == 1) printf(&quot;%lld\\n&quot;, poww(2, m)); else if (n == 2) printf(&quot;%lld\\n&quot;, 4 * poww(3, m - 1) % mod); else if (n == 3) printf(&quot;%lld\\n&quot;, 112 * poww(3, m - 3) % mod); else { if (m == n) printf(&quot;%lld\\n&quot;, ((83 * poww(8, n) % mod + 5 * poww(2, n + 7) % mod) * 190104168 % mod)); else printf(&quot;%lld\\n&quot;, ((83 * poww(8, n) % mod + poww(2, n + 8)) * poww(3, m - n - 1) % mod * 570312504 % mod )); } return 0;}/* 55ms 1048kB */ $D2T3$ 保卫王国动态DP,树剖,蒟蒻不会 逃 如有疑问,可以在下方评论区留言","link":"/p/34a76f7d.html"},{"title":"Hexo搭建博客","text":"由于mkdocs上有很多不足，例如没有标签，分类，评论，计数等等，故转至使用Hexo搭建博客，以下是我折腾的过程 安装Hexo我是用的是Ubuntu16.04系统，其他系统安装方法可到官网查询在nodejs官网下载node.js，并解压添加环境变量echo &quot;export PATH=$PATH:/home/tony/node-v8.11.4-linux-x64/bin&quot; &gt;&gt; ~/.zshrc（如果使用的是bash，将最后一句改为~/.bashrc）source ~/.zshrc应用更改 下载hexonpm install -g hexo-cli 搭建博客123$ mkdir blog$ cd blog$ hexo init 使用hexo s启动服务,在浏览器中输入localhost:4000便可看到预览网页 部署到GitPages创建&lt;username&gt;.github.io存储库更改_config.yml文件中这一部分 1234deploy: type: git repository: git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 使用hexo d -g发布 主题我当前使用的是maupassant主题详细配置见官方中文文档 参考Hexo官网zzq浅谈用Hexo+GitHub搭建自己的blogHexo博客搭建说明书（指北书）从零搭建 Hexo + Github 博客","link":"/p/178c0d2c.html"},{"title":"更新日志","text":"本博客在2019.3.10更改至由Hexo驱动，并在2019.3.12完成更改。原文章时间均改为2019.1.9，算法模板时间改为2019.1.10。","link":"/p/5a717bf0.html"},{"title":"Cpp算法-并查集","text":"说明n, m, q点数、边数、问题数x, y需要合并的两个数ufs[]并查集find(int)查找并查集中一个数的祖先unionn(int, int)合并两个数所在集合 实现1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 10010;int ufs[maxn];int n, m, x, y, q;int find(int x){ if (ufs[x] != x) return ufs[x] = find(ufs[x]); return ufs[x] = x;}void unionn(int x, int y){ int fx = find(x); int fy = find(y); if (fx != fy) { ufs[fx] = fy; }}int main(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) ufs[i] = i; for (int i = 1; i &lt;= m; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); unionn(x, y); } scanf(&quot;%d&quot;, &amp;q); for (int i = 1; i &lt;= q; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); if (find(x) == find(y)) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } return 0;}","link":"/p/9603fc0b.html"},{"title":"Cpp算法-STL标准库","text":"模板 1234template &lt;typename T&gt;/** * 写函数/结构体 */ 例12345678910111213141516171819template &lt;typename T&gt;struct Point{ T x, y; Point(T x = 0, T y = 0):x(x), y(y) {}};template &lt;typename T&gt;Point&lt;T&gt; operator + (const Point&lt;T&gt;&amp; A, const Point&lt;T&gt;&amp; B){ return Point&lt;T&gt;(A.x + B.x, A.y + B.y);}template &lt;typename T&gt;ostream&amp; operator &lt;&lt; (ostream&amp; out, const Point&lt;T&gt;&amp; p){ out &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;; return out;} vector(不定长数组) 声明vector&lt;数据类型&gt; 名; 例 vector&lt;int&gt; a; 简单用法a.size();读取大小a.resize();改变大小a.push_back(x);尾部添加元素xa.pop_back();删除最后一个元素a.clear();清空a.empty()询问是否为空(bool类型)a[]访问元素(可修改) priority_queue(优先队列/堆) 声明头文件: #include &lt;queue&gt;参数: priority_queue&lt;Type, Container, Functional&gt;&emsp;Type数据类型 不可省&emsp;Container容器(vector,deque)默认vector&emsp;Functional比较方式,默认operator &lt;大根堆 使用与queue类似 小根堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;使用仿函数greater&lt;&gt; 自定义类型(struct)12345struct Node{ int x, y; Node(int a = 0, int b = 0):x(a), y(b){}}; 重载operator &lt;1234567bool operator &lt; (Node a, Node b){ if (a.x == b.x) return a.y &gt; b.y; return a.x &gt; b.x;}priority_queue&lt;Node&gt; q; x值大的优先级低,排在队前x相等,y大的优先级低 重写仿函数12345678910struct cmp{ bool operator () (Node a, Node b) { if (a.x == b.x) return a.y &gt; b.y; return a.x &gt; b.x; }}priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; q;","link":"/p/ac108281.html"},{"title":"Cpp算法-背包问题","text":"01背包问题有 $n$ 件物品，和一容积为 $V$ 的背包，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 由题意易知状态转移方程： $F_{i,j} = max(F_{i-1,j}\\ , F_{i-1,j-w_i} + c_i)$ $F_{i, j}$ 为前 $i$ 件物品放入容量为 $V$ 的背包中最大价值时间复杂度 $O(n\\times V)$ ，空间复杂度 $O(n\\times V)$ 框架注意倒序，保证f[n][V]为结果 12345678for (int i = 1; i &lt;= n; ++i){ for (int j = V; j &gt;= w[i]; --j) { f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[n][V]) 空间复杂度优化降至一维数组时间复杂度 $O(n\\times V)$ ，空间复杂度 $O(V)$ 12345678for (int i = 1; i &lt;= n; ++i){ for (int j = V; j &gt;= w[i]; --j) { f[j] = max(f[j], f[j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[V]); 完全背包问题有 $n$ 种物品（每种 无限件 ），和一容积为 $V$ 的背包，第 $i$ 种物品的体积为 $w_i$ ，价值为 $c_i$ 。将第几种物品取任意件装入，使体积不超过总体积，且价值和最大，求最大价值。 将01背包第二个循环改为正序即可状态转移方程：$F_j = max(F_j\\ , F_{j-w_i}+c_i)$ 框架12345678for (int i = 1; i &lt;= n; ++i){ for (int j = w[i]; j &lt;= V; ++j) { f[j] = max(f[j], f[j - w[i]] + c[i]); }}printf(&quot;%d&quot;, f[V]); 多重背包问题有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 解法 $I.$ 化为完全背包状态转移方程：$F_{i,v} = max(F_{i-1,v-k\\times w_i} + k\\times c_i | 0\\leqslant k\\leqslant n_i)$时间复杂度：$O(V\\times \\sum{n_i})$ 框架1234567891011for (int i = 1; i &lt;= N; ++i){ for (int j = V; j &gt;= 0; --j) { for (int k = 0; k &lt;= n[i]; ++k) { f[i][j] = max(f[i - 1][j], [i - 1][j - k * w[i]] + k * c[i]) } }}printf(&quot;%d&quot;, f[N][V]); 解法 $II.$ 化为01背包把 $n_i$ 件一种物品化为单独的 $n_i$ 件物品即可时间复杂度：$O(V\\times \\sum{n_i})$框架略 解法 $III.$ 二进制优化$$n_i\\to 1+2+4+\\dots +2^{k-1}+\\dots +(n_i-2^k+1)$$$$\\sum{n_i}\\to \\sum{\\log_2{n_i}}$$时间复杂度：$O(V\\times \\sum{\\log_2{n_i}})$ 框架123456789101112131415161718for (int i = 1; i &lt;= n; ++i){ int w, c, n, t = 1; scanf(&quot;%d %d %d&quot;, &amp;w, &amp;c, &amp;n); while(n &gt;= t) { v[++N] = x * t; w[N] = y * t; n -= t; t *= 2; } v[++N] = x * n; w[N] = y * n;}for (int i = 1; i &lt;= N; ++i) for (int j = V; j &gt;= v[i]; --j) f[j] = max(f[j], f[j - v[i]] + w[i]);printf(&quot;%d&quot;, f[V]); 混合三种背包问题有 $N$ 种物品，和一容积为 $V$ 的背包，第 $i$ 种物品有 $n_i$ 件或无穷件，体积为 $w_i$ ，价值为 $c_i$ 。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 伪框架12345678910111213for (int i = 1; i &lt;= N; ++i){ if (第i件是有穷件) { for (int j = V; j &gt;= 0; --j) f[j] = max(f[j], f[j - w[i]] + c[i]); } else //有无穷件 { for (int j = 0; j &lt;= V; ++j) f[j] = max(f[j], f[j - w[i]] + c[i]); }} 二维费用的背包问题有 $N$ 件物品，容积为 $V,U$ 的两个背包，每件物品有两种费用，选择物品需要付出两种代价，第 $i$ 件代价为 $a_i,b_i$，价值为 $c_i$。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 改为二维数组即可状态转移方程：$F_{v,u} = max(F_{v,u}\\ , F_{v-a_i,u-b_i} + c_i)$$F_{v,u}$ 表示前面的物品付出代价分别为 $v,u$ 时的最大价值框架略 循环顺序 类01背包：v = V..0 u = U..0 类完全背包：v = 0..V u = 0..U 类多重背包：拆分物品 分组的背包问题有 $K$ 组物品， $V$ 的背包，第 $k$ 组有 $N_k$ 件物品，第 $i$ 件物品的体积为 $w_i$ ，价值为 $c_i$ ，每组中只能选一件物品。将第几件物品装入，使体积不超过总体积，且价值和最大，求最大价值。 框架12345678for (int k = 1; k &lt;= K; ++k){ for (int v = V; v &gt;= 0; --v) { for (int i = 1; i &lt;= N[k]; ++i) f[v] = max(f[v], f[v - w[i]] + c[i]); }} 背包问题的方案数状态转移方程：$F_{i,v} = sum(F_{i-1,v}, F_{i-1,v-w_i})\\ \\ \\ (F_{0,0} = 1)$ 框架1234567f[0] = 1;for (int i = 1; i &lt;= N; ++i){ for (int j = w[i]; j &lt;= V; ++j) f[j] += f[j - w[i]];}printf(&quot;%d&quot;, f[V]);","link":"/p/990bbe9a.html"},{"title":"Cpp算法-堆","text":"说明heap[]堆heap_size堆大小put(int)压入一个数get()弹出堆顶 普通实现12345678910111213141516171819202122232425262728293031323334int heap[maxn];int heap_size = 0;void put(int d){ int now, next; heap[++heap_size] = d; now = heap_size; while (now &gt; 1) { next = now &gt;&gt; 1; if (heap[now] &lt;= heap[next]) break; swap(heap[now], heap[next]); now = next; } return;}int get(){ int now, next, res; res = heap[1]; heap[1] = heap[heap_size--]; now = 1; while (now * 2 &lt;= heap_size) { next = now * 2; if (next &lt; heap_size &amp;&amp; heap[next + 1] &lt; heap[next]) next++; if (heap[now] &lt;= heap[next]) break; swap(heap[now], heap[next]); now = next; } return res;} STL实现1234567891011121314151617int heap[maxn];int heap_size = 0;void put(int d){ heap[++heap_size] = d; push_heap(heap + 1, heap + heap_size + 1); //push_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); return;}int get(){ pop_heap(heap + 1, heap + heap_size + 1); //pop_heap(heap + 1, heap + heap_size + 1, greater&lt;int&gt;()); return heap[heap_size--];}","link":"/p/bb233fbc.html"},{"title":"Cpp算法-图论-SPFA","text":"说明n, m, s点数、边数、源点cnt, head[], edge[], add(int, int, int)链式前向星dist[]各点到源点路径长vis[]记录 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 10010;const int maxm = 500010;int n, m, s, dist[maxn], vis[maxn];int cnt, head[maxn];struct Edge{ int next, to, dis;}edge[maxm];void add(int from, int to, int dis){ edge[++cnt].next = head[from]; edge[cnt].to = to; edge[cnt].dis = dis; head[from] = cnt;}void SPFA(){ queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) { dist[i] = INT_MAX; } q.push(s); dist[s] = 0; vis[s] = true; while (!q.empty()) { int u = q.front(); q.pop(); vis[u] = 0; for (int i = head[u]; i; i = edge[i].next) { int v = edge[i].to; if (dist[v] &gt; dist[u] + edge[i].dis) { dist[v] = dist[u] + edge[i].dis; if (!vis[v]) { vis[v] = true; q.push(v); } } } } return;}","link":"/p/8ed8c69a.html"},{"title":"Cpp算法-图论-链式前向星","text":"说明cnt记数head[]记录边的头struct Edge{int, int, int}边信息: 开始点、结束点、权值add_edge(int, int, int)添加边 实现123456789101112int cnt, head[maxn];struct Edge{ int next, to, val;}edge[maxm];void add_edge(int from, int to, int val){ edge[++cnt].next = head[from]; edge[cnt].to = to; edge[cnt].val = val; head[from] = cnt;}","link":"/p/dda660a4.html"},{"title":"Cpp算法-图论-Prim","text":"说明n, m, _map[][]点数、边数、邻接矩阵dist[]树根到各点路径长pre[]生成树路径 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int maxn = 101;int n, m, dist[maxn], _map[maxn][maxn], pre[maxn];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) _map[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) _map[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); _map[from][to] = w; } return;}void Prim(){ int i, j, k; int min; bool p[maxn]; for (int i = 2; i &lt;= n; ++i) { p[i] = false; dist[i] = _map[1][i]; pre[i] = 1; } dist[1] = 0; p[1] = true; for (int i = 1; i &lt;= n - 1; ++i) { min = INT_MAX; k = 0; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; dist[j] &lt; min) { min = dist[j] k = j; } } if (k == 0) return; p[k] = true; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; _map[k][j] != INT_MAX &amp;&amp; dist[j] &gt; _map[k][j]) { dist[j] = _map[k][j]; pre[j] = k; } } } return;}","link":"/p/8760af74.html"},{"title":"Cpp算法-图论-Kruskal","text":"说明ufs[], find(int), unionn(int, int)并查集结构edge[]链式前向星cmp(Edge, Edge)边排序方案 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int maxn = 1010;int ufs[maxn];int find(int x){ if (ufs[x] != x) return ufs[x] = find(ufs[x]); return ufs[x] = x;}void unionn(int x, int y){ int a = find(x); int b = find(y); if (a != b) { ufs[a] = b; }}const int maxm = 100010;struct Edge{ int a, b, w; bool select;}edge[maxm];bool cmp(Edge a, Edge b){ if (a.w != b.w) return a.w &lt; b.w; if (a.a != b.a) return a.a &lt; b.a; return a.b &lt; b.b; }void kruskal(){ for (int i = 1; i &lt;= n; ++i) { ufs[i] = i; } int k = 0, x, y; sort(edge + 1, edge + 1 + m, cmp); for (int i = 1; i &lt;= m; ++i) { if (k == n - 1) break; x = find(edge[i].a); y = find(edge[i].b); if (x != y) { unionn(x, y); k++; edge[i].select = true; } }}","link":"/p/c4fb1928.html"},{"title":"Cpp算法-字符串算法-KMP","text":"例：洛谷P3375 说明pre()求前缀数组kmp()匹配字符串 实现12345678910111213141516171819202122232425262728293031323334353637383940char s1[1000010], s2[1000010];int nxt[1000010], l1, l2;void pre(){ nxt[1] = 0; int j = 0; for (int i = 1; i &lt; l2; ++i) { while (j &gt; 0 &amp;&amp; s2[j + 1] != s2[i + 1]) j = nxt[j]; if (s2[j + 1] == s2[i + 1]) j++; nxt[i + 1] = j; }}void kmp(){ int j = 0; for (int i = 0; i &lt; l1; ++i) { while (j &gt; 0 &amp;&amp; s2[j + 1] != s1[i + 1]) j = nxt[j]; if (s2[j + 1] == s1[i + 1]) j++; if (j == l2) { printf(&quot;%d\\n&quot;, i - l2 + 2); j = nxt[j]; } }}int main(){ cin &gt;&gt; s1 + 1; cin &gt;&gt; s2 + 1; l1 = strlen(s1 + 1); l2 = strlen(s2 + 1); pre(); kmp(); return 0;}","link":"/p/632c6631.html"},{"title":"Cpp算法-字符串算法-哈希表","text":"例：洛谷P4305 说明hash[]哈希表find(int x)查找哈希表中 $x$ 的位置push(int x)将 $x$ 插入到哈希表中check(int x)查找 $x$ 是否在哈希表中 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#define p 100003#define hash(a) a%pint h[p], t, n, x;int find(int x){ int y; if (x &lt; 0) y = hash(-x); else y = hash(x); while (h[y] &amp;&amp; h[y] != x) y = hash(++y); return y;}void push(int x){ h[find(x)] = x;}bool check(int x){ return h[find(x)] == x;}int main(){ scanf(&quot;%d&quot;, &amp;t); while (t--) { memset(h, 0, sizeof(h)); scanf(&quot;%d&quot;, &amp;n); while (n--) { scanf(&quot;%d&quot;, &amp;x); if (!check(x)) { printf(&quot;%d &quot;, x); push(x); } } printf(&quot;\\n&quot;); } return 0;}","link":"/p/666f05c6.html"},{"title":"Cpp算法-字符串算法-字符串哈希","text":"例：洛谷P3370 单哈希(自然溢出)123456789101112typedef unsigned long long ULL;ULL base = 131, a[10010];char s[10010];ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = Ans * base + (ULL)s[i]; return Ans &amp; 0x7fffffff;} 单哈希(单模数)123456789101112typedef unsigned long long ULL;ULL base = 131, a[10010], mod = 19260817;char s[10010];ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod; return Ans;} 单哈希(大模数)12345678910111213typedef unsigned long long ULL;ULL base = 131, a[10010], mod = 212370440130137957LL;char s[10010];int prime = 233317;ULL hash(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; ++i) Ans = (Ans * base + (ULL)s[i]) % mod + prime; return Ans;} 双哈希12345678910111213141516171819202122232425typedef unsigned long long ULL;ULL base = 131, mod1=19260817, mod2=19660813;char s[10010];struct data{ ULL x,y;}a[10010];ULL hash1(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod1; return Ans;}ULL hash2(char* s){ int len = strlen(s); ULL Ans = 0; for (int i = 0; i &lt; len; i++) Ans = (Ans * base + (ULL)s[i]) % mod2; return Ans;}","link":"/p/114af1e8.html"},{"title":"Cpp算法-数论-线性筛素数","text":"说明p[] 最终结果 实现123456789101112131415161718bool vis[N];int p[N], cnt;void get_prime(){ for (int i = 2; i &lt; N; ++i) { if (!vis[i]) p[++cnt] = i; for (int j = 1; j &lt;= cnt; ++j) { int v = i * p[j]; if (v &gt;= N) break; vis[v] = true; if (i % p[j] == 0) continue; } }}","link":"/p/cff9d95.html"},{"title":"Cpp算法-图论-Floyd","text":"说明n, m, G[][]点数、边数、邻接矩阵dist[][]每对顶点间路径长度pre[][]每对顶点之间路径make()建图 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445const int maxn = 110;int n, m, G[maxn][maxn], dist[maxn][maxn], pre[maxn][maxn];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) G[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) G[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); G[from][to] = w; } return;}void Floyd(){ for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { dist[i][j] = G[i][j]; pre[i][j] = i; } } for (int k = 1; k &lt;= n; ++k) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= n; ++j) { if (dist[i][k] != INT_MAX &amp;&amp; dist[k][j] != INT_MAX &amp;&amp; dist[i][k] + dist[k][j] &lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; pre[i][j] = pre[k][j]; } } } } return;}","link":"/p/ba77762f.html"},{"title":"Cpp算法-图论-欧拉回路","text":"邻接矩阵说明G[][]邻接矩阵deg[]度ans[]欧拉回路n, e点数、边数 实现123456789101112131415161718192021222324252627282930313233343536int G[maxn][maxn], deg[maxn], ans[maxn];int n, e, x, y, ansi, s;void Euler(int i){ for (int j = 1; j &lt;= n; ++j) { if (G[i][j]) { G[i][j] = G[j][i] = 0; Euler(j); } } ans[++ansi] = i;}int main(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;e); for (int i = 1; i &lt;= e; ++i) { scanf(&quot;%d %d&quot;, &amp;x, &amp;y); G[x][y] = G[y][x] = 1; deg[x]++; deg[y]++; } s = 1; for (int i = 1; i &lt;= n; ++i) if (deg[i] % 2 == 1) s = i; Euler(s); for (int i = 1; i &lt;= ansi; ++i) printf(&quot;%d &quot;, ans[i]); printf(&quot;\\n&quot;); return 0;} 链式前向星说明n, m点数、边数head, edge[]链式前向星ans[], ansi路径、数组大小vis[]记录make()建图 实现12345678910111213141516171819202122232425262728293031323334353637int head[maxn];struct Node{ int to, next;}edge[maxm];void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int k = 1; k &lt;= m; ++k) { int i, j; scanf(&quot;%d %d&quot;, &amp;i, &amp;j); edge[k].to = i; edge[k].next = head[i]; head[i] = k; } return;}int ans[maxm];int ansi = 0;bool vis[2 * maxm];void dfs(int now){ for (int k = head[now]; k != 0; k = edge[k].next) { if (!vis[k]) { vis[k] = true; vis[k ^ 1] = true; dfs(edge[k].to); ans[ansi++] = k; } }}","link":"/p/57662471.html"},{"title":"Cpp算法-动态规划","text":"待完成 多阶段过程决策的最优化问题12345678910111213141516graph LR A --5--&gt; B1 A --3--&gt; B2 B1 --1--&gt; C1 B1 --6--&gt; C2 B1 --3--&gt; C3 B2 --8--&gt; C2 B2 --4--&gt; C4 C1 --5--&gt; D1 C1 --6--&gt; D2 C2 --5--&gt; D1 C3 --8--&gt; D3 C4 --3--&gt; D3 D1 --3--&gt; E D2 --4--&gt; E D3 --3--&gt; E !!! tldr “题目及注解” 求上图从 $A$ 到 $E$ 的最短距离 $K$: 阶段 $D(X_I, (X+1)_J)$: 从 $X_I$ 到 $(X+1)_J$ 的距离 $F_K(X_I)$: $K$ 阶段下 $X_I$ 到终点 $E$ 的最短距离 倒推:$$K=4\\qquad F_4(D_1)=3\\qquad F_4(D_2)=4\\qquad F_4(D_3)=3$$$$K=5\\qquad F_3(C_1)=min(D(C_1,D_1)+F_4(D_1),D(C_1,D_2)+F_4(D_2))=min(5+3,6+4)=8F_3(C_2)$$","link":"/p/8364d7e9.html"},{"title":"Cpp算法-图论-Dijkstra","text":"说明n, m点数、边数G[][]邻接矩阵存图dist[]路径长度pre[]路径make()建图 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int maxn = 10010;int n, m, G[maxn][maxn], dist[maxn], pre[maxn], s;void make(){ scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) G[i][j] = INT_MAX; for (int i = 1; i &lt;= n; ++i) G[i][i] = 0; for (int i = 1; i &lt;= m; ++i) { int from, to, w; scanf(&quot;%d %d %d&quot;, &amp;from, &amp;to, &amp;w); G[from][to] = w; } return;}void Dijkstra(){ int k, min; bool p[maxn]; for (int i = 1; i &lt;= n; ++i) { p[i] = false; if (i != s) { dist[i] = G[s][i]; pre[i] = s; } } dist[s] = 0; p[s] = true; for (int i = 1; i &lt;= n - 1; ++i) { min = INT_MAX; k = 0; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; dist[j] &lt; min) { min = dist[j]; k = j; } } if (k == 0) return; p[k] = true; for (int j = 1; j &lt;= n; ++j) { if (!p[j] &amp;&amp; G[k][j] != INT_MAX &amp;&amp; dist[j] &gt; dist[k] + G[k][j]) { dist[j] = dist[k] + G[k][j]; pre[j] = k; } } } return;} 堆优化(链式前向星)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Edge{ int to, nxt, t;}edge[maxm &lt;&lt; 1];int head[maxn], cnt;void add(int a, int b, int t){ edge[++cnt].to = b; edge[cnt].nxt = head[a]; edge[cnt].t = t; head[a] = cnt;}struct heap{ int u, d; bool operator &lt; (const heap&amp; a) const { return d &gt; a.d; }};void Dijkstra(){ priority_queue&lt;heap&gt; q; for (int i = 0; i &lt;= n; ++i) dist[i] = INF; dist[1] = 0; q.push((heap){1, 0}); while (!q.empty()) { heap top = q.top(); q.pop(); int tx = top.u; int td = top.d; if (td != dist[tx]) continue; for (int i = head[tx]; i; i = edge[i].nxt) { int v = edge[i].to; if (dist[v] &gt; dist[tx] + edge[i].t) { dist[v] = dist[tx] + edge[i].t; dy[v] = i; dx[v] = tx; //记录路径 q.push((heap){v, dist[v]}); } } }} 路径123456int q = n, p[maxm];while (q != 1){ p[++tot] = dy[q]; q = dx[q];}","link":"/p/982e7a01.html"},{"title":"Cpp算法-树状数组","text":"树状数组模板：洛谷P3374 说明tree[]树状数组lowbit(int)神奇的函数add(int x, int k)第 $x$ 个数加上 $k$ sum(int x)前 $x$ 个数的和 实现1234567891011121314151617181920212223242526int tree[2000010];int lowbit(int k){ return k &amp; -k;}void add(int x, int k){ while (x &lt;= n) { tree[x] += k; x += lowbit(x); }}int sum(int x){ int ans = 0; while (x != 0) { ans += tree[x]; x -= lowbit(x); } return ans;}","link":"/p/72c90980.html"},{"title":"Cpp算法-大整数类","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;iosfwd&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include&lt;cstring&gt;using namespace std;const int maxl = 5000;#define max(a, b) a&gt;b ? a : b#define min(a, b) a&lt;b ? a : bclass BigInteger{ public: int len, s[maxl]; BigInteger(); BigInteger(const char*); BigInteger(int); bool sign; string toStr() const; friend istream&amp; operator&gt;&gt;(istream&amp;, BigInteger&amp;); friend ostream&amp; operator&lt;&lt;(ostream&amp;, BigInteger&amp;); BigInteger operator=(const char*); BigInteger operator=(int); BigInteger operator=(const string); bool operator&gt;(const BigInteger&amp;) const; bool operator&gt;=(const BigInteger&amp;) const; bool operator&gt;(const BigInteger&amp;) const; bool operator&gt;=(const BigInteger&amp;) const; bool operator==(const BigInteger&amp;) const; bool operator!=(const BigInteger&amp;) const; BigInteger operator+(const BigInteger&amp;) const; BigInteger operator++(); BigInteger operator++(int); BigInteger operator+=(const BigInteger&amp;); BigInteger operator-(const BigInteger&amp;) const; BigInteger operator--(); BigInteger operator--(int); BigInteger operator-=(const BigInteger&amp;); BigInteger operator*(const BigInteger&amp;) const; BigInteger operator*(const int num) const; BigInteger operator*=(const BigInteger&amp;); BigInteger operator/(const BigInteger&amp;) const; BigInteger operator/=(const BigInteger&amp;); BigInteger operator%(const BigInteger&amp;) const; BigInteger factorial() const; BigInteger Sqrt() const; BigInteger Pow(const BigInteger&amp;) const; void clean(); ~BigInteger;};BigInteger::BigInteger(){ memset(s, 0, sizeof(s)); len = 1; sign = 1;}BigInteger::BigInteger(const char *num){ *this = num;}BigInteger::BigInteger(int num){ *this = num;}string BigInteger::toStr() const{ string res; res = &quot;&quot;; for (int i = 0; i &lt; len; ++i) res = (char)(s[i] + '0') + res; if (res == &quot;&quot;) res = &quot;0&quot;; if (!sign &amp;&amp; res != &quot;0&quot;) res = &quot;-&quot; + res; return res;}istream&amp; operator&gt;&gt;(istream&amp; in, BigInteger&amp; num){ string str; in&gt;&gt;str; num = str; return in;}ostream&amp; operator&lt;&lt;(ostream&amp; out, BigInteger&amp; num){ out&lt;&lt;num.toStr(); return out;}BigInteger BigInteger::operator=(const char* num){ memset(s, 0, sizeof(s)); char a[maxl] = &quot;&quot;; if (num[0] != &quot;-&quot;) strcpy(a, num); else for (int i = 1; i &lt; strlen(num); ++i) a[i - 1] = num[i]; sign = !(num[0] == &quot;-&quot;); len = strlen(a); for (int i = 0; i &lt; strlen(a); ++i) s[i] = a[len - i - 1] - 48; return *this;}BigInteger BigInteger::operator=(int num){ if (num &lt; 0) sign = 0, num = -num; else sign = 1; char temp[MAX_L]; sprintf(temp, &quot;%d&quot;, num); *this = temp; return *this;}BigInteger BigInteger::operator=(const string num){ const char* tmp; tmp = num.c_str(); *this = tmp; return *this;}bool BigInteger::operator&lt;(const BigInteger&amp; num) const{ if (sign^num.sign) return num.sign; if (len != num.len) return len &lt; num.len; for (int i = len - 1; i &gt;= 0; --i) if (s[i] != num.s[i]) return sign ? (s[i] &lt; num.s[i]) : (s[i] &gt; num.s[i]) return !sign;}bool BigInteger::operator&gt;(const BigInteger&amp; num) const{ return num &lt; *this;}bool BigInteger::operator&lt;=(const BigInteger&amp; num) const{ return !(*this &gt; num);}bool BigInteger::operator&gt;=(const BigInteger&amp; num) const{ return !(*this &lt; num);}bool BigInteger::operator!=(const BigInteger&amp; num) const{ return *this &gt; num || *this &lt; num;}bool BigInteger::operator==(const BigInteger&amp; num) const{ return !(num != *this);}BigInteger BigInteger::operator+(const BigInteger&amp; num) const{ if (sign^num.sign) { BigInteger tmp = sign ? num : *this; tmp.sign = 1; return sign ? *this - tmp : num - tmp; } BigInteger result; result.len = 0; int temp = 0; for (int i = 0; temp || i &lt; (max(len, num.len)); i++) { int t = s[i] + num.s[i] + temp; result.s[result.len++] = t % 10; temp = t / 10; } result.sign = sign; return result;}BigInteger BigInteger::operator++(){ *this = *this + 1; return *this;}BigInteger BigInteger::operator++(int){ BigInteger old = *this; ++(*this); return old;}BigInteger BigInteger::operator+=(const BigInteger&amp; num){ *this = *this + num; return *this;}BigInteger BigInteger::operator-(const BigInteger&amp; num) const{ BigInteger b = num, a = *this; if (!num.sign &amp;&amp; !sign) { b.sign = 1; a.sign = 1; return b - a; } if (!b.sign) { b.sign = 1; return a + b; } if (!a.sign) { a.sign = 1; b = BigInteger(0) - (a + b); return b; } if (a &lt; b) { BigInteger c = (b - a); c.sign = false; return c; } BigInteger result; result.len = 0; for (int i = 0, g = 0; i &lt; a.len; i++) { int x = a.s[i] - g; if (i &lt; b.len) x -= b.s[i]; if (x &gt;= 0) g = 0; else { g = 1; x += 10; } result.s[result.len++] = x; } result.clean(); return result;}BigInteger BigInteger::operator--(){ *this = *this - 1; return *this;}BigInteger BigInteger::operator--(int){ BigInteger old = *this; --(*this); return old;}BigInteger BigInteger::operator-=(const BigInteger&amp; num){ *this = *this - num; return *this;}BigInteger BigInteger::operator*(const BigInteger&amp; num) const{ BigInteger result; result.len = len + num.len; for (int i = 0; i &lt; len; i++) for (int j = 0; j &lt; num.len; j++) result.s[i + j] += s[i] * num.s[j]; for (int i = 0; i &lt; result.len; i++) { result.s[i + 1] += result.s[i] / 10; result.s[i] %= 10; } result.clean(); result.sign = !(sign^num.sign); return result;}BigInteger BigInteger::operator*(const int num) const{ BigInteger x = num; BigInteger z = *this; return *this;}BigInteger BigInteger::operator/(const BigInteger&amp; num) const{ BigInteger ans; ans.len = len - num.len + 1; if (ans.len &lt; 0) { ans.len = 1; return ans; } BigInteger divisor = *this, divid = num; divisor.sign = divid.sign = 1; int k = ans.len - 1; int j = len - 1; while (k &gt;= 0) { while (divisor.s[j] == 0) j--; if (k &gt; j) k = j; char z[MAX_L]; memset(z, 0, sizeof(z)); for (int i = j; i &gt;= k; i--) z[j - i] = divisor.s[i] + '0'; BigInteger dividend = z; if (dividend &lt; divid) { k--; continue; } int key = 0; while (divid*key &lt;= dividend) key++; key--; ans.s[k] = key; BigInteger temp = divid*key; for (int i = 0; i &lt; k; i++) temp = temp * 10; divisor = divisor - temp; k--; } ans.clean(); ans.sign = !(sign^num.sign); return ans;}BigInteger BigInteger::operator/=(const BigInteger&amp; num){ *this = *this / num; return *this;}BigInteger BigInteger::operator%(const BigInteger&amp; num) const{ BigInteger a = *this, b = num; a.sign = b.sign = 1; BigInteger result, temp = a / b*b; result = a - temp; result.sign = sign; return result;}BigInteger BigInteger::Pow(const BigInteger&amp; num) const{ BigInteger result = 1; for (BigInteger i = 0; i &lt; num; i++) result = result * (*this); return result;}BigInteger BigInteger::factorial() const{ BigInteger result = 1; for (BigInteger i = 1; i &lt;= *this; i++) result *= i; return result;}void BigInteger::clean(){ if (len == 0) len++; while (len &gt; 1 &amp;&amp; s[len - 1] == '\\0') len--;}BigInteger BigInteger::Sqrt() const{ if(*this &lt; 0) return - 1; if(*this &lt;= 1)return *this; BigInteger l = 0, r = *this, mid; while(r - l &gt; 1) { mid = (l + r) / 2; if(mid * mid &gt; *this) r = mid; else l = mid; } return l;}BigInteger::~BigInteger(){}","link":"/p/b995b9d7.html"},{"title":"Cpp算法-BFS","text":"说明本文实现只是框架，应当灵活运用，bfs()函数内部根据情况灵活更改广搜算法基于树、队列实现，具体思路: 将当前点的子节点入队，当前点出队，如果子节点满足条件则记录并重复此过程 框架数组模拟队列12345678910111213141516171819202122232425void bfs(){ int head = 1, tail = 2; vis[start_x][start_y] = true; //标记起始点 que[head][0] = start_x; que[head][1] = start_y; //起始点入队 while(head &lt; tail) //队不为空 { int x = que[head][0], y = que[head][1] //获取队首点 for (int i = 0; i &lt; 子节点数; ++i) { int x2 = x子节点, y2 = y子节点; if (x2, y2满足条件 &amp;&amp; !vis[x2][y2]) { 记录结果; vis[x2][y2] = true; que[tail][0] = x2; que[tail][0] = y2; tail++; //入队 } } head++; //队首出队 } return} STL-queue123456789101112131415161718192021222324252627282930313233struct Node{ int x, y;}node, top;queue&lt;Node&gt; que;void bfs(){ vis[sx][sy] = true; node.x = sx; node.y = sy; que.push(node); ans[sx][sy] = 0; while(!que.empty()) { top = que.front(); for (int i = 0; i &lt; 8; ++i) { int x2 = ..., y2 = ...; if (x2, y2满足条件 &amp;&amp; !vis[x2][y2]) { 记录结果; vis[x2][y2] = true; node.x = x2; node.y = y2; que.push(node); } } que.pop(); } return;} 例洛谷P1443 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, sx, sy, vis[210][210], ans[210][210];int gox[8] = {-2, -1, 1, 2, 2, 1, -1, -2};int goy[8] = {1, 2, 2, 1, -1, -2, -2, -1};struct horse{ int x, y;}node, top;queue&lt;horse&gt; que;void bfs(){ vis[sx][sy] = 1; node.x = sx; node.y = sy; que.push(node); ans[sx][sy] = 0; while(!que.empty()) { top = que.front(); for (int i = 0; i &lt; 8; ++i) { int x2 = top.x + gox[i]; int y2 = top.y + goy[i]; if (x2 &gt;= 1 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= 1 &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2]) { ans[x2][y2] = ans[top.x][top.y] + 1; vis[x2][y2] = 1; node.x = x2; node.y = y2; que.push(node); } } que.pop(); } return;}int main(){ scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;sx, &amp;sy); memset(ans, -1, sizeof(ans)); bfs(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) printf(&quot;%-5d&quot;, ans[i][j]); printf(&quot;\\n&quot;); } return 0;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, sx, sy, vis[210][210], que[50000][2], ans[210][210];int gox[8] = {-2, -1, 1, 2, 2, 1, -1, -2};int goy[8] = {1, 2, 2, 1, -1, -2, -2, -1};void bfs(){ int head = 1, tail = 2; vis[sx][sy] = 1; que[head][0] = sx; que[head][1] = sy; ans[sx][sy] = 0; while (head &lt; tail) { int x, x2, y, y2; x = que[head][0]; y = que[head][1]; for (int i = 0; i &lt; 8; ++i) { x2 = x + gox[i]; y2 = y + goy[i]; if (x2 &gt;= 1 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt;= 1 &amp;&amp; y2 &lt;= m &amp;&amp; !vis[x2][y2]) { ans[x2][y2] = ans[x][y] + 1; vis[x2][y2] = 1; que[tail][0] = x2; que[tail][1] = y2; tail++; } } head++; } return;}int main(){ scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;m, &amp;sx, &amp;sy); memset(ans, -1, sizeof(ans)); bfs(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) printf(&quot;%-5d&quot;, ans[i][j]); printf(&quot;\\n&quot;); } return 0;}","link":"/p/99890668.html"},{"title":"Cpp算法-DFS","text":"说明本文实现只是框架，应当灵活运用，dfs(…)函数返回值类型、参数列表根据情况灵活更改 框架1234567891011121314151617void dfs(参数列表){ if (到达目的地) 输出结果; else { for (int i = 0; i &lt; 行动方法数; ++i) { if (下一步可行) { 记录此步; dfs(改动后的参数列表); 取消记录此步; } } } return;} 例洛谷P1605 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, t, sx, sy, fx, fy, ans;int mg[6][6], now[6][6];int go[4][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};void dfs(int x, int y){ int x2, y2; if (x == fx &amp;&amp; y == fy) ans++; else { for (int i = 0; i &lt; 4; ++i) { x2 = x + go[i][0]; y2 = y + go[i][1]; if (x2 &gt; 0 &amp;&amp; x2 &lt;= n &amp;&amp; y2 &gt; 0 &amp;&amp; y2 &lt;= m &amp;&amp; mg[x2][y2] == 0 &amp;&amp; now[x2][y2] == 0) { now[x2][y2] = 1; dfs(x2, y2); now[x2][y2] = 0; } } } return;}int main(){ memset(mg, 0, sizeof(mg)); scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;t); scanf(&quot;%d %d %d %d&quot;, &amp;sx, &amp;sy, &amp;fx, &amp;fy); for (int i = 1; i &lt;= t; ++i) { int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); mg[x][y] = 1; } now[sx][sy] = 1; ans = 0; dfs(sx, sy); printf(&quot;%d&quot;, ans); return 0;}","link":"/p/9d047ada.html"},{"title":"Linux美化方案","text":"I. 初步系统优化 更改系统时间 安装python sudo apt install python 安装git并添加ssh密钥 sudo apt install git git config --global user.name &quot;your_name&quot; git config --global user.email &quot;you@example.com&quot; ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;一路回车 cat ~/.ssh/id_rsa.pub并复制粘贴到github上 ssh -T git@github.com测试 git clone https://github.com/Tony031218/Beautiful_Linux.git克隆下本仓库 添加语言 settings -> Region&Language -> manage installed language -> install/remove languages -> input sources 软件更新 sudo apt update sudo apt upgrade 安装GDebi sudo apt install gdebi 卸载libreoffice 安装 WPS(可选) sudo apt remove libreoffice-common 从http://www.wps.cn/product/wpslinux/ 上下载WPS sudo dpkg -i wps-office_10.1.0.6757_amd64.deb 卸载firefox 安装 Chrome(可选) sudo apt remove firefox wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome* sudo apt -f install 更换更新源 左下角 -&gt; all -&gt; Software&amp;Updates sudo apt update 安装vim sudo apt install vim 菜单栏位置 gsettings set com.canonical.Unity.Launcher launcher-position Bottom底部 gsettings set com.canonical.Unity.Launcher launcher-position Left左侧 II. 主题配置 安装 Unity-tweak-toolsudo apt install unity-tweak-tool如果出现报错需要安装缺失的包 安装 Flatabulous 主题sudo add-apt-repository ppa:noobslab/themessudo apt updatesudo apt install flatabulous-theme主题sudo add-apt-repository ppa:noobslab/iconssudo apt updatesudo apt install ultra-flat-icons图标unity-tweak-tool -&gt; 主题/图标 字体Monaco Powerline 也可以选择其他字体,但一定要支持Powerline的,否则后文会出现乱码 III. 终端Terminal美化 Terminal zsh sudo apt install zsh git clone https://github.com/robbyrussell/oh-my-zsh.git cd oh-my-zsh/tools ./install.sh 更换默认shell chsh按步骤来输入zsh地址 zsh插件 自动补全 git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 快速跳转 git clone https://github.com/joelthelion/autojump.git cd autojump ./install.py按要求把代码填写到~/.zshrc文件尾 配置 vim ~/.zshrc 修改60行左右的pluginsplugins=(git autojump zsh-suggestions) 修改皮肤 ~/.zshrc中的ZSH_THEME=&quot;robbyrussell&quot;更改 IV. vim美化 molokai mkdir ~/.vim/colors 将本仓库中的molokai.vim复制到~/.vim/colors/下 Powerline sudo apt install python-pip pip install git+git://github.com/powerline/powerline pip show powerline-status 按照具体位置更改~/.vimrc中的set rtp+=...一行(后文) 插件 pathogen插件管理 mkdir -p ~/.vim/autoload ~/.vim/bundle curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim nerdtree文件浏览器 cd ~/.vim/bundle git clone https://github.com/scrooloose/nerdtree.git taglist大纲界面taglist官网 下载后解压到~/.vim/bundle/下 vimrc 将本仓库中的vimrc.txt复制到~/.vimrc中 内包含括号匹配,html标签匹配,powerline配置(可能需要改动),cpp.sh.java.py的文件头自动输入,插件的配置(F3打开nerdtree,F4打开taglist) 参考 CSDN博客powerlinevim插件monaco powerline字体monokai主题WPS","link":"/p/f2ddc0e6.html"},{"title":"Git简单用法","text":"Git是一款版本控制软件，配合GitHub可以更好的控制代码 SSH Key1234$ ssh-keygen -t rsa -C &quot;975062472@qq.com&quot;$ cd ~/.ssh$ cat id_rsa.pub$ ssh -T git@github.com 创建仓库12345678910$ mkdir study_cpp$ cd study_cpp/$ echo &quot;# test&quot; &gt;&gt; README.md$ lsREADME.md$ git init$ git add README.md$ git commit -m &quot;添加 README.md 文件&quot;$ git remote add origin git@github.com:Tony031218/study_cpp.git$ git push -u origin master 克隆1$ git clone git@github.com:Tony031218/study_cpp 提取12$ git fetch origin$ git merge origin/master 推送123$ git add &lt;filename&gt;$ git commit -m &quot;推送信息&quot;$ git push origin master 远程仓库1234$ git remote add origin2 git@github.com:Tony031218/study_cpp.git$ git remote -v$ git remote rm origin2$ git remote -v 分支12345$ git checkout -b graph //创建分支，并切换过去$ git checkout master //回到主分支$ git push origin graph //将分支推送到远程仓库$ git pull //将本地仓库更新$ git diff graph master //显示差别 克隆分支1234$ git clone -b &lt;branch_name&gt; &lt;repo_url&gt; //克隆单个分支$ cd &lt;repo&gt;$ git branch -a //查看所有分支$ git checkout -b &lt;branch_name&gt; origin/&lt;branch_name&gt; //关联分支","link":"/p/e779c345.html"},{"title":"Markdown语法","text":"Markdown是一款简洁实用的文本标记语言，可以在mkdocs,hexo中使用 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 下划线 1234---*******---- 目录[TOC] 文字样式** **加粗* *倾斜*** ***倾斜加粗~~ ~~删除 引用&gt;一级 &gt;&gt;二级 引用 二级引用 引用 空行&amp;nbsp; 或 &lt;br/&gt;&nbsp; 空格&amp;emsp;&emsp;&emsp;空格 图片![图片名](图片地址 &quot;title&quot;) 或使用html标签&lt;img src=&quot;...&quot; width=&quot;...&quot; height=&quot;...&quot; /&gt; 链接[网页名](地址 &quot;title&quot;)百度 代码块12345678#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ printf(&quot;hello markdown&quot;); return 0;} 序表 有序1 有序2 有序3 + 或 - 或 * 无序 无序 无序 一级无序 二级无序 三级无序 四级无序 任务列表- [ ] ...- [x] ...mkdocs需要pymdown中的pymdownx模块GitHub支持 表格123|表头|表头|表头||:----------|:----------:|----------:|| 左对齐 |居中|右对齐| 表头 表头 表头 左对齐 居中 右对齐 内联CSS&lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: 'Consolas';&quot;&gt;CSS&lt;/p&gt; CSS 语义标记123456&lt;i&gt;斜体&lt;/i&gt;&lt;b&gt;加粗&lt;/b&gt;&lt;em&gt;强调&lt;/em&gt;上标： Z&lt;sup&gt;a&lt;/sup&gt;下标： Z&lt;sub&gt;a&lt;/sub&gt;键盘文本： &lt;kbd&gt;Ctrl&lt;/kbd&gt; 斜体 加粗 强调 上标： Za 下标： Za 键盘文本： Ctrl 公式文档末尾添加 12345678&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt;MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});&lt;/script&gt; 使用$\\LaTeX$语法编写公式$$x \\href{why-equal.html} {=} y^2 + 1$$$$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}$$ MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]} });","link":"/p/3c50d03d.html"},{"title":"MkDocs使用方法","text":"mkdocs是一款基于python markdown的项目文档工具,可以用来编写一个网站 安装安装python3及pip1234$ sudo apt install python3 #安装python$ sudo apt install python3-pip #安装pip$ python3 --version #检查python是否安装成功$ pip3 --version #检查pip是否安装成功 安装mkdocs12# pip3 install mkdocs #注意以root权限安装# mkdocs --version #检查是否安装成功 使用12$ mkdocs new test #创建一个名为test的文件夹,存储代码$ cd test 此时的目录结构 1234test/ ├── docs/ #存放markdown文档 │ └── index.md #主页 └── mkdocs.yml #配置文件 1$ mkdocs serve #开启内建服务器 在浏览器中输入127.0.0.1:8000预览,终端键入Ctrl+C关闭服务器 1$ mkdocs build #生成静态网页代码 这时已经生成了site/文件夹,可以将里面的内容部署到网站上了 配置文件site_name: 必须存在,文档主标题名称site_favicon: 图标,存放在docs/文件夹下theme: 主题样式例如: 12345theme: name: 'material' #使用material主题,需要pip安装mkdocs-material language: 'zh' #使用中文 feature: tabs: true #使用上方tab栏（可改为false） 目录结构123nav: - 'Index': index.md - 'About': about.md 扩展执行$ pip3 install pymdown-extensions安装扩展包 12345markdown_extensions: - admonition #支持注解 - codehilite: #代码块高亮 linenums: true #代码块显示行号 - pymdownx.tasklist #支持任务列表 !!! warning “注意” 一定要事先安装好扩展，否则不能出现预期效果 参考MkDocs中文文档MkDocs官方文档cyent的教程","link":"/p/ce42b873.html"}],"tags":[{"name":"Cpp","slug":"Cpp","link":"/tags/Cpp/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Haskell","slug":"Haskell","link":"/tags/Haskell/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"},{"name":"mkdocs","slug":"mkdocs","link":"/tags/mkdocs/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"manim","slug":"manim","link":"/tags/manim/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"Writeup","slug":"Writeup","link":"/tags/Writeup/"},{"name":"NOIp","slug":"NOIp","link":"/tags/NOIp/"},{"name":"游记","slug":"游记","link":"/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"CSP-S","slug":"CSP-S","link":"/tags/CSP-S/"},{"name":"题解","slug":"题解","link":"/tags/%E9%A2%98%E8%A7%A3/"},{"name":"范畴论","slug":"范畴论","link":"/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"},{"name":"莫队","slug":"莫队","link":"/tags/%E8%8E%AB%E9%98%9F/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"Luogu","slug":"Luogu","link":"/tags/Luogu/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"差分约束","slug":"差分约束","link":"/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"},{"name":"dsu on tree","slug":"dsu-on-tree","link":"/tags/dsu-on-tree/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"左偏树","slug":"左偏树","link":"/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"},{"name":"并查集","slug":"并查集","link":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","link":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"网络流","slug":"网络流","link":"/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"},{"name":"费用流","slug":"费用流","link":"/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"},{"name":"最短路","slug":"最短路","link":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"bfs","slug":"bfs","link":"/tags/bfs/"},{"name":"状态压缩","slug":"状态压缩","link":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"最大流","slug":"最大流","link":"/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"AtCoder","slug":"AtCoder","link":"/tags/AtCoder/"},{"name":"SPOJ","slug":"SPOJ","link":"/tags/SPOJ/"},{"name":"计算几何","slug":"计算几何","link":"/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}],"categories":[{"name":"C++算法","slug":"C-算法","link":"/categories/C-%E7%AE%97%E6%B3%95/"},{"name":"manim","slug":"manim","link":"/categories/manim/"},{"name":"Writeup","slug":"Writeup","link":"/categories/Writeup/"},{"name":"游记","slug":"游记","link":"/categories/%E6%B8%B8%E8%AE%B0/"},{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"笔记","slug":"manim/笔记","link":"/categories/manim/%E7%AC%94%E8%AE%B0/"},{"name":"笔记","slug":"C-算法/笔记","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"C-算法/笔记/数据结构","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"C-算法/笔记/图论","link":"/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"网络流24题","slug":"题解/网络流24题","link":"/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"}]}