<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>「Learn Haskell」#5 函子、应用函子与单子 - TonyCrane&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="TonyCrane&#039;s Blog"><meta name="msapplication-TileImage" content="/tonycrane.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="TonyCrane&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="&amp;lt; #4 #6 &amp;gt;   Functors函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b 函数来实现这个功能，它接收一"><meta property="og:type" content="blog"><meta property="og:title" content="「Learn Haskell」#5 函子、应用函子与单子"><meta property="og:url" content="https://blog.tonycrane.cc/p/290ecb74.html"><meta property="og:site_name" content="TonyCrane&#039;s Blog"><meta property="og:description" content="&amp;lt; #4 #6 &amp;gt;   Functors函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b 函数来实现这个功能，它接收一"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.tonycrane.cc/img/og_image.png"><meta property="article:published_time" content="2021-07-09T07:12:39.000Z"><meta property="article:modified_time" content="2021-07-25T04:54:13.884Z"><meta property="article:author" content="TonyCrane"><meta property="article:tag" content="Haskell"><meta property="article:tag" content="笔记"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.tonycrane.cc/p/290ecb74.html"},"headline":"「Learn Haskell」#5 函子、应用函子与单子","image":["https://blog.tonycrane.cc/img/og_image.png"],"datePublished":"2021-07-09T07:12:39.000Z","dateModified":"2021-07-25T04:54:13.884Z","author":{"@type":"Person","name":"TonyCrane"},"publisher":{"@type":"Organization","name":"TonyCrane's Blog","logo":{"@type":"ImageObject","url":"https://blog.tonycrane.cc/BlogLogo.png"}},"description":"&lt; #4 #6 &gt;   Functors函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用fmap :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一"}</script><link rel="canonical" href="https://blog.tonycrane.cc/p/290ecb74.html"><link rel="icon" href="/tonycrane.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro&amp;family=JetBrains+Mono:ital,wght@0,300;0,400;0,600;0,700;1,400;1,700"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?4fb5d144c1a2304049b314651f3033bc";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://gcore.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-GQ1YD8G8PG" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-GQ1YD8G8PG');</script><!--!--><!--!--><script src="https://gcore.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="TonyCrane's Blog" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/BlogLogo.png" alt="TonyCrane&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/friends">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item colormode" id="colormode" title="颜色主题" href="javascript:;"><i class="fas fa-sun"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-09T07:12:39.000Z" title="2021/7/9 15:12:39">2021-07-09</time>发表</span><span class="level-item"><time dateTime="2021-07-25T04:54:13.884Z" title="2021/7/25 12:54:13">2021-07-25</time>更新</span><span class="level-item">1 小时读完 (大约6844个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">「Learn Haskell」#5 函子、应用函子与单子</h1><div class="content"><div style="display: flex; justify-content: space-between;">

<p><a href="/p/a5bbe48a.html">&lt; #4</a></p>
<p><a href="/p/d4bb2633.html">#6 &gt;</a></p>
</div>

<h2 id="Functors"><a href="#Functors" class="headerlink" title="Functors"></a>Functors</h2><p>函子（Functor）是一个类型类（typeclass），和其他类型类一样，它规定了其实例类必须实现的功能（例如Eq类型类规定了它的实例必须是可以比较是否相等的），Functor规定类它的实例必须是可以进行映射的。Functor要求使用<code>fmap</code> :: (a -&gt; b) -&gt; f a -&gt; f b 函数来实现这个功能，它接收一个a -&gt; b类型的函数、一个内部元素为a类型的函子，返回一个内部元素为b类型的函子</p>
<span id="more"></span>

<p>Functor可以比作盒子，那fmap函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子</p>
<p>函子的实例必须是一个Kind为* -&gt; *的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。fmap中的<code>f a</code>和<code>f b</code>也是因为<code>f</code>是一个类型构造器，在接收类型a/b后才会变成一个具体类型（f a和f b）出现在函数类型声明中</p>
<p>Functor的定义是:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) :: a -&gt; f a -&gt; f b</span><br><span class="line">    (&lt;$) = fmap . const</span><br></pre></td></tr></table></figure>
<p>可以发现Functor不仅需要fmap函数，还需要一个&lt;$函数，它接收一个a类型的变量和一个内容为b类型的函子，返回一个内容为a类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>
<p>但它不是声明一个函子实例必须的，因为它可以使用fmap和const函数复合来实现，其中const的类型签名：</p>
<p style="text-align: center;">const :: a -> b -> a</p>

<p>即接收两个参数，但始终只返回第一个参数</p>
<h3 id="Functor实例"><a href="#Functor实例" class="headerlink" title="Functor实例"></a>Functor实例</h3><h4 id><a href="#" class="headerlink" title="[]"></a>[]</h4><p>列表[]是一个函子，它通过map函数来实现fmap的功能：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">    fmap = map</span><br></pre></td></tr></table></figure>
<p style="text-align: center;">map :: (a -> b) -> [a] -> [b]</p>

<p>map和fmap要求的相同，达成的目的也一致。map接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表</p>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe也具有kind * -&gt; *，它也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="Either-a"><a href="#Either-a" class="headerlink" title="Either a"></a>Either a</h4><p>Either的kind是* -&gt; * -&gt; *，显然它不是函子，但是固定了一个传入类型的Either a的kind是* -&gt; *，也是一个函子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> (<span class="type">Either</span> <span class="title">a</span>) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (<span class="type">Left</span> x) = <span class="type">Left</span> x</span><br><span class="line">    fmap f (<span class="type">Right</span> x) = <span class="type">Right</span> (f x)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Left</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Left</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Right</span> <span class="number">4</span>)</span><br><span class="line"><span class="type">Right</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>因为使用Either时一般用右值表示正常结果，左值表示异常信息，所以使用fmap时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在）</p>
<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>IO也是一个函子，使用fmap对IO中内容应用函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fmap f action = <span class="keyword">do</span></span><br><span class="line">        result &lt;- action</span><br><span class="line">        return (f result)</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; fmap (<span class="string">&quot;input: &quot;</span>++) getLine</span><br><span class="line"><span class="title">test</span></span><br><span class="line"><span class="string">&quot;input: test&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="a"><a href="#a" class="headerlink" title="(,) a"></a>(,) a</h4><p>(,)表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了(,) a，它的kind是* -&gt; *。也是一个函子，进行fmap函数时只对第二个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,) a) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (x, y) = (x, f y)</span><br></pre></td></tr></table></figure>
<p>只剩一个元素的三元组和四元组也都是函子，fmap也只对最后一个元素应用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,) a b) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c) = (a, b, f c)</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((,,,) a b c) <span class="keyword">where</span></span></span><br><span class="line">    fmap f (a, b, c, d) = (a, b, c, f d)</span><br></pre></td></tr></table></figure>

<h4 id="gt-r"><a href="#gt-r" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>-&gt;也是一个类型构造器，它的kind：</p>
<p style="text-align: center;">(->) :: * -> * -> *</p>

<p>一个映射（一元函数）的类型a -&gt; b也可以写成(-&gt;) a b，它是由类型a和类型b输入到类型构造器-&gt;中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是(-&gt;) r（其中<code>r</code>是输入的类型）</p>
<p>规定的fmap的类型签名是：</p>
<p style="text-align: center;">fmap :: (a -> b) -> f a -> f b</p>

<p>其中的f是函子，而在这个实例中(-&gt;) r就是函子，将其带入f可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> ((-> r) a) -> ((-> r) b)</p>

<p>把其中的(-&gt;)换成中缀可以得到：</p>
<p style="text-align: center;">fmap :: (a -> b) -> (r -> a) -> (r -> b)</p>

<p>传入两个函数，一个类型为a -&gt; b，一个类型为r -&gt; a，返回一个函数，类型为r -&gt; b。<br>不难推测这个fmap是将这两个函数复合了，先对输入对r应用第二个函数产生类型a的结果，然后在应用第一个函数产生类型b的结果，所以(-&gt;) r定义的fmap是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap f g = (\x -&gt; f (g x))</span><br></pre></td></tr></table></figure>
<p>所以(-&gt;) r的fmap其实就是函数复合(.)：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    fmap = (.)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t fmap (*<span class="number">3</span>) (+<span class="number">100</span>)  </span><br><span class="line"><span class="title">fmap</span> (*<span class="number">3</span>) (+<span class="number">100</span>) :: (<span class="type">Num</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">3</span>) (+<span class="number">100</span>) <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) `fmap` (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">3</span>) . (+<span class="number">100</span>) $ <span class="number">1</span>  </span><br><span class="line"><span class="number">303</span></span><br></pre></td></tr></table></figure>

<h3 id="Functor-Laws"><a href="#Functor-Laws" class="headerlink" title="Functor Laws"></a>Functor Laws</h3><p>所有的函子都应该满足两个定律。这两个定律不是Haskell强制要求的，但应该确保一个函子满足这两个定律：</p>
<ol>
<li><code>fmap id = id</code>（其中id为函数<code>(\x -&gt; x)</code>）：即对一个函子fmap id，那它应该返回本身（fmap id a = id a = a，a为一个函子），比如： <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap id [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; fmap id (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><code>fmap (f . g) = fmap f . fmap g</code>：即函子的fmap支持结合律<br> fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中<code>a</code>为一个函子<br> fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x)) <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap ((*<span class="number">3</span>) . (+<span class="number">100</span>)) (<span class="type">Just</span> <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">303</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可</p>
<h3 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h3><p>对于函子和fmap，有两种理解方法</p>
<ol>
<li>函子是一种容器（container）；fmap接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器</li>
<li>函子是一种计算上下文（context）；fmap是柯里化的，把其类型签名看作<p style="text-align: center;">fmap :: (a -> b) -> (f a -> f b)</p>
接收一个函数返回另一个函数，传入函数g :: a -> b，fmap将其转换为新的函数
<p style="text-align: center;">fmap g :: f a -> f b</p>
使普通的函数g可以在计算上下文<code>f</code>中使用，这种转换也被称为提升（lift）</li>
</ol>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;$&gt;"></a>&lt;$&gt;</h4><p><code>&lt;$&gt;</code>函数是<code>fmap</code>的中缀形式（它看着类似<code>$</code>，<code>f $ 3</code>将f应用在单个值3上，而<code>f &lt;$&gt; [1, 2, 3]</code>将f应用在一个函子上，也就是应用在一个函子内部的所有值上）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fmap (*<span class="number">2</span>) (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; (*<span class="number">2</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="gt"><a href="#gt" class="headerlink" title="$&gt;"></a>$&gt;</h4><p><code>$&gt;</code>函数包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">($>) :: Functor f => f a -> b -> f b</p> 

<p>Functor定义时要求了<code>&lt;$</code>函数，将函子内部的元素全部替换为指定的某个值，而<code>$&gt;</code>正好将<code>&lt;$</code>函数的两个参数反了过来，相当于<code>flip (&lt;$)</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; &#x27;a&#x27; &lt;$ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] $&gt; &#x27;a&#x27;</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="void"><a href="#void" class="headerlink" title="void"></a>void</h4><p><code>void</code>函数也包含在<code>Data.Functor</code>模块中</p>
<p style="text-align: center;">void :: Functor f => f a -> f ()</p>

<p>void函数把一个函子内部的全部元素都变成空（<code>()</code>），<code>void x</code>相当于<code>() &lt;$ x</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; void [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[(), (), ()]</span><br><span class="line"><span class="title">ghci</span>&gt; void (<span class="type">Just</span> <span class="number">2</span>)</span><br><span class="line"><span class="type">Just</span> ()</span><br></pre></td></tr></table></figure>

<h2 id="Applicative-Functor"><a href="#Applicative-Functor" class="headerlink" title="Applicative Functor"></a>Applicative Functor</h2><p>应用函子（Applicative Functor）是函子的升级版，它包含在<code>Control.Applicative</code>模块中。</p>
<p>fmap进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，fmap就处理不了了，但是应用函子的方法可以处理。应用函子的定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">    pure :: a -&gt; f a</span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure>
<p>应用函子要求实现两个函数：</p>
<ul>
<li><code>pure</code> :: a -&gt; f a，不难理解，pure接收一个值，并将其放在默认的上下文/容器中。对于列表，pure = []；对于Maybe，pure = Just</li>
<li><code>&lt;*&gt;</code> :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于fmap :: (a -&gt; b) -&gt; f a -&gt; f b，但不同的是&lt;*&gt;的第一个参数的类型是f (a -&gt; b)不是a -&gt; b。所以&lt;*&gt;的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，&lt;*&gt;接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。</li>
</ul>
<h3 id="Applicative-Functor实例"><a href="#Applicative-Functor实例" class="headerlink" title="Applicative Functor实例"></a>Applicative Functor实例</h3><h4 id="Maybe-1"><a href="#Maybe-1" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = <span class="type">Just</span></span><br><span class="line">    <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">    (<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：将一个值放在默认的上下文中，而对于Maybe，默认的上下文就是Just，所以pure x = Just x</li>
<li><code>&lt;*&gt;</code>函数：将装有函数的函子中的函数应用另一个函子中<ul>
<li>第一个参数是Nothing，即第一个函子不包含函数，那返回的结果就也会是Nothing</li>
<li>第一个参数是装有函数f的函子Just f，将其中的函数f应用在函子something中，只需要将f提取出来使用fmap应用在函子something中即可</li>
</ul>
</li>
</ul>
<p>实际应用的例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">3</span>) &lt;$&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>第一个例子，Just (+3)是一个包含函数(+3)的函子，将其应用在函子Just 9中，将Just (+3)中的函数(+3)提取出来，应用在Just 9中，得到了Just 12</p>
<p>第二个例子，可以发现，在这里pure (+3)和Just (+3)等效，因为pure将函数(+3)放在默认上下文中，也就是Just中了</p>
<p>而&lt;*&gt;能做的不止这些，他可以连续传入更多函子作为参数，比如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; pure (+) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">9</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br><span class="line"><span class="title">ghci</span>&gt; pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line"><span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>&lt;*&gt;函数一样是默认左结合的，pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9相当于(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 9，而pure (+) &lt;*&gt; Just 3将(+)应用在Just 3上，得到的就是Just (+3)一个包含函数的函子，又将其通过&lt;*&gt;应用在了Just 9上，得到了Just 12:</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span> &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (pure (\x y z -&gt; x + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span> &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= (<span class="type">Just</span> (\y z -&gt; <span class="number">3</span> + y + z) &lt;*&gt; <span class="type">Just</span> <span class="number">4</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> (\z -&gt; <span class="number">3</span> + <span class="number">4</span> + z) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span> = <span class="type">Just</span> (+<span class="number">7</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">5</span></span><br><span class="line">= <span class="type">Just</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>所以可以使用类似pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; …来将一个普通多元函数f应用在多个函子上。</p>
<p>而且pure f &lt;*&gt; x实际上先将普通函数f放在上下文中，然后执行&lt;*&gt;时再将其提取出来执行fmap，所以它就相当于将普通函数应用在函子x上，即fmap f x，也可以写成f &lt;$&gt; x。所以常用的写法就是：</p>
<p style="text-align: center;">f <$> x <*> y <*> ...</*></*></$></p>

<h4 id="-1"><a href="#-1" class="headerlink" title="[]"></a>[]</h4><p>列表也是一个应用函子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">    pure x = [x]</span><br><span class="line">    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pure</code>函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表[x]</li>
<li><code>&lt;*&gt;</code>函数：列表的&lt;*&gt;函数是通过列表推导来实现的。因为不同于Maybe的Just只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表</li>
</ul>
<p>使用例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">3</span>), (*<span class="number">2</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [(+), (*)]  &lt;*&gt;  [<span class="number">1</span>, <span class="number">2</span>]  &lt;*&gt;  [<span class="number">3</span>, <span class="number">4</span>]  </span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<h4 id="IO-1"><a href="#IO-1" class="headerlink" title="IO"></a>IO</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    pure = return</span><br><span class="line">    a &lt;*&gt; b = <span class="keyword">do</span></span><br><span class="line">        f &lt;- a</span><br><span class="line">        x &lt;- b</span><br><span class="line">        return (f x)</span><br></pre></td></tr></table></figure>
<p>也不难理解，pure函数直接将传入的值return，相当于放在了IO的上下文中。而&lt;*&gt;函数先将两个IO中内容提取出来，然后应用函数后return，形成新的IO函子</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine</span><br><span class="line"><span class="type">Line1</span></span><br><span class="line"><span class="type">Line2</span></span><br><span class="line"><span class="string">&quot;Line1Line2&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="gt-r-1"><a href="#gt-r-1" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>(-&gt;) r同样也是一个应用函子，和函子的分析一样，先来分析它的&lt;*&gt;函数的类型签名：</p>
<p style="text-align: center;"><*> :: f (a -> b) -> f a -> f b</*></p>

<p>其中f为(-&gt;) r，将其代入并替换为中缀：</p>
<p style="text-align: center;"><*> :: (r -> a -> b) -> (r -> a) -> (r -> b)</*></p>

<p>可以看出它接收两个函数f :: r -&gt; a -&gt; b、g :: r -&gt; a，返回另一个函数h :: (r -&gt; b)</p>
<p>那么返回的函数的输入为r，输出为b，所以先对输入应用函数g得到a，然后在对r和a应用f得到b，所以推测&lt;*&gt;函数的操作就是：</p>
<p style="text-align: center;">\x -> f x (g x)</p>

<p>于是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    pure x = (\_ -&gt; x)</span><br><span class="line">    f &lt;*&gt; g = \x -&gt; f x (g x)</span><br></pre></td></tr></table></figure>
<p>将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以pure函数定义为(_ -&gt; x)，即无论输入什么，都返回x</p>
<p>应用函子的&lt;*&gt;函数接收两个函子，返回一个新的函子。对于(-&gt;) r，它接收两个函数，返回一个新的函数。具体例子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line"><span class="number">508</span></span><br></pre></td></tr></table></figure>
<p>执行这句时发生了什么？：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) &lt;$&gt; (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= ((+) . (+<span class="number">3</span>)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span> = (\a -&gt; (+) ((+<span class="number">3</span>) a)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\a b -&gt; (a + <span class="number">3</span> + b)) &lt;*&gt; (*<span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + ((*<span class="number">100</span>) x)) $ <span class="number">5</span></span><br><span class="line">= (\x -&gt; x + <span class="number">3</span> + x * <span class="number">100</span>) $ <span class="number">5</span></span><br><span class="line">= <span class="number">5</span> + <span class="number">3</span> + <span class="number">5</span> * <span class="number">100</span> = <span class="number">508</span></span><br><span class="line">= (<span class="number">5</span> + <span class="number">3</span>) + (<span class="number">5</span> * <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>所以就相当于先对输入分别执行(+3)和(*100)，然后将两个结果执行了(+)</p>
<p>同样：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; (*<span class="number">2</span>) &lt;*&gt; (/<span class="number">2</span>) $ <span class="number">5</span>  </span><br><span class="line">[<span class="number">8.0</span>,<span class="number">10.0</span>,<span class="number">2.5</span>]  </span><br></pre></td></tr></table></figure>
<p>先对5分别执行(+3)、(*2)、(/2)，然后将得到的三个结果传入(\x y z -&gt; [x,y,z])得到了最终的结果</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i</span><br><span class="line">= (\x -&gt; f (g x) (h x) (i x))</span><br></pre></td></tr></table></figure>

<h4 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h4><p>普通列表实现的&lt;*&gt;函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表ZipList，包含在<code>Control.Applicative</code>模块中</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">ZipList</span> <span class="keyword">where</span></span></span><br><span class="line">    pure x = <span class="type">ZipList</span> (repeat x)</span><br><span class="line">    <span class="type">ZipList</span> fs &lt;*&gt; <span class="type">ZipList</span> xs = <span class="type">ZipList</span> (zipWith ($) fs xs)</span><br></pre></td></tr></table></figure>
<p>但是ZipList并不是Show的实例，所以不能直接显示出来，要使用<code>getZipList</code>来获取它内部的列表：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; getZipList $ (+) &lt;$&gt; <span class="type">ZipList</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] &lt;*&gt; <span class="type">ZipList</span> [<span class="number">100</span>,<span class="number">100.</span>.]  </span><br><span class="line">[<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; getZipList $ (,,) &lt;$&gt; <span class="type">ZipList</span> <span class="string">&quot;dog&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;cat&quot;</span> &lt;*&gt; <span class="type">ZipList</span> <span class="string">&quot;rat&quot;</span>  </span><br><span class="line">[(&#x27;d&#x27;,&#x27;c&#x27;,&#x27;r&#x27;),(&#x27;o&#x27;,&#x27;a&#x27;,&#x27;a&#x27;),(&#x27;g&#x27;,&#x27;t&#x27;,&#x27;t&#x27;)]  </span><br></pre></td></tr></table></figure>

<h3 id="Applicative-Functor-Laws"><a href="#Applicative-Functor-Laws" class="headerlink" title="Applicative Functor Laws"></a>Applicative Functor Laws</h3><p>应用函子一般有四个定律，都是保证pure的正确性的：</p>
<ol>
<li><code>Identity law</code>：pure id &lt;*&gt; v = v</li>
<li><code>Homomorphism</code>：pure f &lt;*&gt; pure x = pure (f x)</li>
<li><code>Interchange</code>：u &lt;*&gt; pure v = pure ($ v) &lt;*&gt; u</li>
<li><code>Composition</code>：u &lt;*&gt; (v &lt;*&gt; w) = pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w</li>
</ol>
<h3 id="Intuition-1"><a href="#Intuition-1" class="headerlink" title="Intuition"></a>Intuition</h3><p>理解应用函子的方式也是将其看作是计算上下文（context），比如要计算：<br>$$<br>[[\ \ g\ x_1\ x_2\ \cdots\ x_n\ \ ]]<br>$$</p>
<p>其中$x_i$的类型是$f\ t_i$，$f$是应用函子（看作上下文）。而函数$g$的类型是：</p>
<p>$$<br>t_1\to t_2\to\cdots\to t_n\to t<br>$$</p>
<p>所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。$g\ x_1$可以通过fmap来执行，将$g$提升（lift）到$x_1$的上下文中，然后应用在$x_1$上。但是fmap返回的结果是一个函子，换句话说，$g\ x_1$结果的类型是：</p>
<p>$$<br>f\ \ (t_2\to t_3\to\cdots\to t_n\to t)<br>$$</p>
<p>但是fmap并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的&lt;*&gt;函数提供了这个方法，所以计算$[[\ g\ x_1\ x_2\ \cdots\ x_n\ ]]$，只需要：</p>
<p style="text-align: center;">g <$> x1 <*> x2 <*> ... <*> xn</*></*></*></$></p>

<p>而pure函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数$x_2$如果不在上下文中，需要用pure提升到上下文中才能按上面计算：</p>
<p style="text-align: center;">g <$> x1 <*> pure x2 <*> ... <*> xn</*></*></*></$></p>

<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="liftA-amp-liftA2-amp-liftA3"><a href="#liftA-amp-liftA2-amp-liftA3" class="headerlink" title="liftA &amp; liftA2 &amp; liftA3"></a>liftA &amp; liftA2 &amp; liftA3</h4><p style="text-align: center;">liftA :: Applicative f => (a -> b) -> f a -> f b</p>
<p style="text-align: center;">liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c</p>
<p style="text-align: center;">liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d</p>

<p>不难推测liftA就是fmap，<code>liftA2 f x1 x2</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2</code>，<code>liftA3 f x1 x2 x3</code>相当于<code>f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3</code></p>
<h4 id="lt-amp-gt"><a href="#lt-amp-gt" class="headerlink" title="&lt;* &amp; *&gt;"></a>&lt;* &amp; *&gt;</h4><p>类型类似函子的<code>&lt;$</code>和<code>$&gt;</code>：</p>
<p style="text-align: center;">(&lt;*) :: Applicative f => f a -> f b -> f a</p>
<p style="text-align: center;">(*>) :: Applicative f => f a -> f b -> f b</p>

<p>&lt;*接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。*&gt;反过来</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> &lt;* <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">3</span> *&gt; <span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="type">Just</span> <span class="number">4</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &lt;* <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> *&gt; <span class="type">Just</span> <span class="number">3</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt;* [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] *&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [] &lt;* [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="title">ghci</span>&gt; [] *&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h4 id="lt-gt-1"><a href="#lt-gt-1" class="headerlink" title="&lt;**&gt;"></a>&lt;**&gt;</h4><p style="text-align: center;">(**) :: Applicative f => f a -> f (a -> b) -> f b</p>

<p>接收的参数是&lt;*&gt;反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和flip(&lt;*&gt;)不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)] &lt;*&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>, <span class="number">2</span>] &lt;**&gt; [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="title">ghci</span>&gt; flip(&lt;*&gt;) [<span class="number">1</span>, <span class="number">2</span>] [(+<span class="number">1</span>), (+<span class="number">2</span>), (+<span class="number">3</span>)]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<h4 id="when-amp-unless"><a href="#when-amp-unless" class="headerlink" title="when &amp; unless"></a>when &amp; unless</h4><p style="text-align: center;">when :: Applicative f => Bool -> f () -> f ()</p>

<p>传入的第一个是一个结果为Bool类型的测试，如果测试为True，则调用第二个参数，否则返回pure ()。（when函数在上文IO操作中使用过）</p>
<p>unless则与when相反，测试为True返回pure ()</p>
<h4 id="sequenceA"><a href="#sequenceA" class="headerlink" title="sequenceA"></a>sequenceA</h4><p style="text-align: center;">sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)</p>

<p>应用在列表上时，它的类型相当于：</p>
<p style="text-align: center;">[f a] -> f [a]</p>

<p>所以在列表上它的使用方法：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Just</span> <span class="number">2</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Just</span> [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [<span class="type">Just</span> <span class="number">3</span>, <span class="type">Nothing</span>, <span class="type">Just</span> <span class="number">1</span>]  </span><br><span class="line"><span class="type">Nothing</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(+<span class="number">3</span>),(+<span class="number">2</span>),(+<span class="number">1</span>)] <span class="number">3</span>  </span><br><span class="line">[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]  </span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">6</span>]]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>],[]]  </span><br><span class="line">[]  </span><br></pre></td></tr></table></figure>
<p>它在对同一个参数应用不同函数时很有用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; map (\f -&gt; f <span class="number">7</span>) [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd]  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; sequenceA [(&gt;<span class="number">4</span>), (&lt;<span class="number">10</span>), odd] <span class="number">7</span>  </span><br><span class="line">[<span class="type">True</span>,<span class="type">True</span>,<span class="type">True</span>]  </span><br></pre></td></tr></table></figure>

<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>单子（Monad）是对Applicative Functor的扩展（但是诞生比Applicative早），Functor的<code>&lt;$&gt;</code>函数实现了将普通函数应用在上下文值上，Applicative的<code>&lt;*&gt;</code>函数将上下文中函数应用在上下文值上。而Monad提供了一个函数<code>&gt;&gt;=</code>（bind），将一个接收普通值返回上下文值的函数应用在上下文值上：</p>
<!--more-->
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">    (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">    return :: a -&gt; m a</span><br><span class="line">    m &gt;&gt; n = m &gt;&gt;= \_ -&gt; n</span><br><span class="line">    return = pure</span><br></pre></td></tr></table></figure>
<ul>
<li><code>return</code>函数：和<code>pure</code>一样，只是有另一个名字</li>
<li><code>&gt;&gt;</code>函数：提供了默认的实现方法，它的作用和Applicative的*&gt;函数一样</li>
<li><code>&gt;&gt;=</code>函数（bind）：比Applicative升级的函数，第一个参数是一个单子，第二个参数是一个接收值返回单子的函数，将这个函数应用在第一个参数单子中的值上，并返回得到的新单子</li>
</ul>
<h3 id="Monad实例"><a href="#Monad实例" class="headerlink" title="Monad实例"></a>Monad实例</h3><h4 id="Maybe-2"><a href="#Maybe-2" class="headerlink" title="Maybe"></a>Maybe</h4><p>Maybe是一个单子实例，Applicative已经为它实现了return，因此只需要&gt;&gt;=函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    (<span class="type">Just</span> x) &gt;&gt;= f = f x </span><br><span class="line">    <span class="type">Nothing</span>  &gt;&gt;= _ = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>根据定义就很容易实现Maybe的&gt;&gt;=函数了，而且也很好理解</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; return (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Nothing</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>)</span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line"><span class="title">ghci</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= \x -&gt; <span class="type">Just</span> (x + <span class="number">1</span>) &gt;&gt; <span class="type">Nothing</span> &gt;&gt;= \y -&gt; <span class="type">Just</span> (y + <span class="number">1</span>)</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>最后一个例子中出现了&gt;&gt; Nothing，这时Nothing前的部分全都相当于没用，因为&gt;&gt;操作符的左右两边只要有一个出现Nothing，那整体就会是Nothing。这个特性可以用于在中途随时判断失误，只要有一处失误，结果就会是Nothing</p>
<h4 id="-2"><a href="#-2" class="headerlink" title="[]"></a>[]</h4><p>列表也是一个单子：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> [] <span class="keyword">where</span></span></span><br><span class="line">    xs &gt;&gt;= f = concat (map f xs)</span><br></pre></td></tr></table></figure>
<p>将这个函数应用在xs的每个值上，将返回的所有列表平铺成一个列表：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] &gt;&gt;= \x -&gt; [x,-x]  </span><br><span class="line">[<span class="number">3</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">-4</span>,<span class="number">5</span>,<span class="number">-5</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1</span>,<span class="number">2</span>] &gt;&gt;= \n -&gt; [&#x27;a&#x27;,&#x27;b&#x27;] &gt;&gt;= \ch -&gt; return (n,ch)  </span><br><span class="line">[(<span class="number">1</span>,&#x27;a&#x27;),(<span class="number">1</span>,&#x27;b&#x27;),(<span class="number">2</span>,&#x27;a&#x27;),(<span class="number">2</span>,&#x27;b&#x27;)]  </span><br></pre></td></tr></table></figure>

<h4 id="IO-2"><a href="#IO-2" class="headerlink" title="IO"></a>IO</h4><p>IO也是一个单子，但是实现方法比较深奥（逃</p>
<h4 id="gt-r-2"><a href="#gt-r-2" class="headerlink" title="(-&gt;) r"></a>(-&gt;) r</h4><p>(-&gt;) r也是一个单子，和Functor、Applicative一样，先分析它的&gt;&gt;=类型签名：</p>
<p style="text-align: center;">(>>=) :: (-> r) a -> (a -> (-> r) b) -> (-> r) b</p>
<p style="text-align: center;">(>>=) :: (r -> a) -> (a -> r -> b) -> (r -> b)</p>

<p>也可以看出来，它接收两个函数f :: r -&gt; a、g :: a -&gt; r -&gt; b，然后返回一个新的函数h :: r -&gt; b</p>
<p>那么函数h接收一个类型为r的参数，返回一个类型为b的值。所以先对输入应用f得到类型为a的中间值，然后再将这个值和输入参数一起传入函数g得到结果。所以函数h的定义应该是：</p>
<p style="text-align: center;">\x -> g (f x) x</p>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></span></span><br><span class="line">    f &gt;&gt;= g = \x -&gt; g (f x) x</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (+<span class="number">3</span>) &gt;&gt;= (+) $ <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="title">ghci</span>&gt; (+) &lt;$&gt; (+<span class="number">3</span>) &lt;*&gt; id $ <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="do-notation"><a href="#do-notation" class="headerlink" title="do-notation"></a>do-notation</h3><p>Haskell的do语句为链式的&gt;&gt;=应用提供了类似命令式（imperative style）的语法糖。比如<code>a &gt;&gt;= \x -&gt; b &gt;&gt; c &gt;&gt;= \y -&gt; d</code>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">a</span> &gt;&gt;= \x -&gt;</span><br><span class="line"><span class="title">b</span> &gt;&gt;</span><br><span class="line"><span class="title">c</span> &gt;&gt;= \y -&gt;</span><br><span class="line"><span class="title">d</span></span><br></pre></td></tr></table></figure>
<p>其中有abcd四个值，可以看出a中内容绑定到了x上，c中内容绑定到了y上。使用do语句来表示这个操作可以写成：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x &lt;- a </span><br><span class="line">   ;      b </span><br><span class="line">   ; y &lt;- c </span><br><span class="line">   ;      d </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>其中的大括号和分号可以省略不写（挤在一行时不能省略）。do语句也只是一个语法糖，它可以递归地转换成普通的Monad操作语句：</p>
<ul>
<li><code>do e</code>：e</li>
<li><code>do &#123; e; ... &#125;</code>：e &gt;&gt; do { … }</li>
<li><code>do &#123; v &lt;- e; ... &#125;</code>：e &gt;&gt;= \v -&gt; do { … }</li>
<li><code>do &#123; let ...; ... &#125;</code>：let … in do { … }</li>
</ul>
<h4 id="ApplicativeDo"><a href="#ApplicativeDo" class="headerlink" title="ApplicativeDo"></a>ApplicativeDo</h4><p>比如如下一个do语句：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> x &lt;- a </span><br><span class="line">   y &lt;- b </span><br><span class="line">   z &lt;- c </span><br><span class="line">   return (f x y z)</span><br></pre></td></tr></table></figure>
<p>它可以转化成：</p>
<p style="text-align: center;">a >>= \x -> b >>= \y -> c >>= \z -> return (f x y z)</p>

<p>但是经过观察可以发现，整个语句实际上将函数f应用在了三个上下文中的值上，所以仅用Applicative的&lt;$&gt;和&lt;*&gt;完全可以实现：</p>
<p style="text-align: center;">f <$> a <*> b <*> c</*></*></$></p>

<p>而且在运行的时候Applicative的效率会比Monad高，所以Haskell会将do语句尽可能优先转换为Applicative的表示方法然后再计算</p>
<h3 id="Monad-Laws"><a href="#Monad-Laws" class="headerlink" title="Monad Laws"></a>Monad Laws</h3><ol>
<li><code>Left identity</code>： return a &gt;&gt;= k      <code>=</code> k a</li>
<li><code>Right identity</code>：m        &gt;&gt;= return <code>=</code> m</li>
<li><code>Associativity</code>：(m &gt;&gt;= g) &gt;&gt;= h      <code>=</code> m &gt;&gt;= (\x -&gt; g x &gt;&gt;= h)</li>
</ol>
<p>前两个定律很好理解：</p>
<ul>
<li>将a注入上下文之后绑定（bind）给函数k(:: a -&gt; m a)，相当于直接将a直接传入函数k</li>
<li>将已经包含在上下文中的值绑定给return函数，相当于保持不变</li>
</ul>
<p>第三个定律是结合律，把它写成更像结合律的表示方法是：</p>
<p style="text-align: center;">(m >>= (\x -> g x)) >>= h <code>=</code> m >>= (\x -> g x >>= h)</p>

<h4 id="组合运算符（-gt-gt-）形式"><a href="#组合运算符（-gt-gt-）形式" class="headerlink" title="组合运算符（&gt;=&gt;）形式"></a>组合运算符（&gt;=&gt;）形式</h4><p><code>Control.Monad</code>模块中还定义了函数<code>&gt;=&gt;</code>（Kleisli-composition operator）：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">infixr</span> <span class="number">1</span> &gt;=&gt;</span><br><span class="line">(&gt;=&gt;) :: <span class="type">Monad</span> m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)</span><br><span class="line"><span class="title">f</span> &gt;=&gt; g = \x -&gt; f x &gt;&gt;= g</span><br></pre></td></tr></table></figure>
<p>使用&gt;=&gt;运算符可以将两个用于绑定的函数结合在一起。用它表示的Monad定律更加清晰直观：</p>
<ol>
<li><code>Left identity</code>：return &gt;=&gt; f <code>=</code> f</li>
<li><code>Right identity</code>：f &gt;=&gt; return <code>=</code> f</li>
<li><code>Associativity</code>：(f &gt;=&gt; g) &gt;=&gt; h <code>=</code> f &gt;=&gt; (g &gt;=&gt; h)</li>
</ol>
<h4 id="do-notation形式"><a href="#do-notation形式" class="headerlink" title="do-notation形式"></a>do-notation形式</h4><p>Monad的这三个定律还可以使用do语句来描述：</p>
<ol>
<li><code>Left identity</code>： <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x&#x27; &lt;- return x;</span><br><span class="line">     f x&#x27;             =   <span class="keyword">do</span> &#123; f x &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Right identity</code>： <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> &#123; x &lt;- m; </span><br><span class="line">     return x         =   <span class="keyword">do</span> &#123; m &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Associativity</code>： <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> &#123; y &lt;- <span class="keyword">do</span> &#123; x &lt;- m;       <span class="keyword">do</span> &#123; x &lt;- m;              <span class="keyword">do</span> &#123; x &lt;- m;</span><br><span class="line">               f x                <span class="keyword">do</span> &#123; y &lt;- f x;            y &lt;- f x;</span><br><span class="line">             &#125;           =             g y         =        g y</span><br><span class="line">     g y                             &#125;                    &#125;</span><br><span class="line">   &#125;                            &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Intuition-2"><a href="#Intuition-2" class="headerlink" title="Intuition"></a>Intuition</h3><p>Monad也可以很自然地看成Applicative的升级版，比如Applicative的操作全部是固定的，而Monad的操作可以在中途突然改变</p>
<p>同时Monad也完成了Functor和Applicative无法完成的操作。比如要用fmap和实现&gt;&gt;=函数（即达成操作 m a -&gt; (a -&gt; m b) -&gt; m b），先假设 f :: a -&gt; m b，那么fmap f的类型就会是 m a -&gt; m (m b)，将m a应用在fmap f上会得到结果m (m b)，而不是m b。但是目前只可以使用pure将一个值装入上下文中（a -&gt; m a），而没有一个函数可以从上下文中提取值（m a -&gt; a）。那么就需要定义一个新的函数来实现这个操作的效果（m (m b) -&gt; m b）。因此Monad的另一个等效的定义方法是：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad&#x27;</span> m <span class="keyword">where</span></span></span><br><span class="line">    join :: m (m a) -&gt; m a </span><br><span class="line">    </span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b </span><br><span class="line">    x &gt;&gt;= f = join $ fmap f x</span><br></pre></td></tr></table></figure>
<p>但是定义&gt;&gt;=函数会更为直观方便，所以Haskell采用了用&gt;&gt;=函数定义Monad的方法</p>
<p>同时Haskell还提供了join函数的定义：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">join</span> :: <span class="type">Monad</span> m =&gt; m (m a) -&gt; m a </span><br><span class="line"><span class="title">join</span> x = x &gt;&gt;= id</span><br></pre></td></tr></table></figure>

<h3 id="常用函数-2"><a href="#常用函数-2" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="liftM-amp-ap"><a href="#liftM-amp-ap" class="headerlink" title="liftM &amp; ap"></a>liftM &amp; ap</h4><p style="text-align: center;">liftM :: Monad m => (a -> b) -> m a -> m b</p>
<p style="text-align: center;">ap :: Monad m => m (a -> b) -> m a -> m b</p>

<p>所以liftM其实就是fmap、ap就是&lt;*&gt;，但是老版本的GHC定义Monad并没有Functor、Applicative的约束，所以实现了liftM、ap，并且保留了这个名字</p>
<p>因此一个单子也可以通过<code>pure = return</code>、<code>(&lt;*&gt;) = ap</code>直接成为应用函子的实例</p>
<h4 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h4><p style="text-align: center;">sequence :: Monad m => [m a] -> m [a]</p>

<p>sequence的作用显而易见，而且在IO部分也使用到了。但是这个版本是在<code>GHC.Base</code>模块中定义的，还有一个更广泛的使用Traversable的定义在<code>Data.Traversable</code>模块中 </p>
<h4 id="replicateM"><a href="#replicateM" class="headerlink" title="replicateM"></a>replicateM</h4><p style="text-align: center;">replicateM :: Applicative m => Int -> m a -> m [a]</p>

<h4 id="mapM-amp-forM"><a href="#mapM-amp-forM" class="headerlink" title="mapM &amp; forM"></a>mapM &amp; forM</h4><p style="text-align: center;">mapM :: Monad m => (a -> m b) -> [a] -> m [b]</p>
<p style="text-align: center;">forM :: Monad m => [a] -> (a -> m b) -> m [b]</p>

<p>forM的用法在IO部分已经说过，mapM和forM都在<code>Data.Traversable</code>模块中有广泛版本</p>
<p>还有一些其他的函数：filterM、zipWithM、foldM、forever，通过名字就可以看出用法，是将原来仅使用与列表的函数提升至可以适用于所有单子</p>
<p>并且在函数名后加下划线，比如sequence_、mapM_，会忽略返回值（最终结果为<code>m ()</code>）</p>
<h4 id="lt-lt-amp-gt-gt-amp-lt-lt"><a href="#lt-lt-amp-gt-gt-amp-lt-lt" class="headerlink" title="=&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;"></a>=&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;</h4><p>（<code>&gt;=&gt;</code>操作符在上面<a href="#%E7%BB%84%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-gt-gt-%EF%BC%89%E5%BD%A2%E5%BC%8F">Monad Laws</a>部分已经给出了定义）</p>
<ul>
<li>x &gt;&gt;= f <code>=</code> f =&lt;&lt; x </li>
<li>f &gt;=&gt; g <code>=</code> g &lt;=&lt; f </li>
</ul>
<h2 id="MonadFail"><a href="#MonadFail" class="headerlink" title="MonadFail"></a>MonadFail</h2><p>MonadFail定义在<code>Control.Monad.Fail</code>模块中：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monad</span> m =&gt; <span class="type">MonadFail</span> m <span class="keyword">where</span></span></span><br><span class="line">    fail :: <span class="type">String</span> -&gt; m a </span><br></pre></td></tr></table></figure>
<p>它只要求在Monad的基础上实现fail函数，接收一个字符串返回一个单子。这会使在do语句中产生错误时直接变为错误值（空值）使最终的返回值为错误值</p>
<h3 id="MonadFail实例"><a href="#MonadFail实例" class="headerlink" title="MonadFail实例"></a>MonadFail实例</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    fail _ = <span class="type">Nothing</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> [] <span class="keyword">where</span></span></span><br><span class="line">    fail _ = []</span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">MonadFail</span> <span class="type">IO</span> <span class="keyword">where</span></span></span><br><span class="line">    fail = failIO</span><br></pre></td></tr></table></figure>
<p>Maybe和[]的fail函数都与第一个参数无关，直接返回空值（Nothing、[]）；而IO的fail函数直接使用failIO，实现方法也是深奥（接着逃</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">exampleFail</span> :: <span class="type">Maybe</span> <span class="type">Char</span> </span><br><span class="line"><span class="title">exampleFail</span> = <span class="keyword">do</span></span><br><span class="line">    (x:xs) &lt;- <span class="type">Just</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    return x </span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; exampleFail</span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure>
<p>在这个例子的do语句中，在提取Just “”中的值时用了模式匹配，但是因为其内容为空字符串，x:xs匹配会出现错误，这时就会触发fail函数直接返回Nothing</p>
<h3 id="MonadFail-Law"><a href="#MonadFail-Law" class="headerlink" title="MonadFail Law"></a>MonadFail Law</h3><ul>
<li>fail s &gt;&gt;= m <code>=</code> fail s </li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia - Haskell wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></li>
<li><a target="_blank" rel="noopener" href="http://02s949.coding-pages.com/2018/08/15/haskellc/">Haskell学习 - functor</a></li>
</ul>
<hr>
<div style="text-align: center;">

<p style="font-size: 1.3rem; font-weight: bold;">目录</p>

<p>#0&nbsp;|&nbsp;<a href="/p/b3ca5c18.html">总章</a>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<br>#1&nbsp;|&nbsp;<a href="/p/d63b5b5f.html">基础语法与函数</a>&emsp;&emsp;&emsp;<br>#2&nbsp;|&nbsp;<a href="/p/53e482b7.html">高阶函数与模块</a>&emsp;&emsp;&emsp;<br>#3&nbsp;|&nbsp;<a href="/p/369b7e08.html">类型与类型类</a>&emsp;&emsp;&emsp;&emsp;<br>#4&nbsp;|&nbsp;<a href="/p/a5bbe48a.html">输入输出与文件</a>&emsp;&emsp;&emsp;<br>#5&nbsp;|&nbsp;<a href="/p/290ecb74.html">函子、应用函子与单子</a><br>#6&nbsp;|&nbsp;<a href="/p/d4bb2633.html">半群与幺半群</a>&emsp;&emsp;&emsp;&emsp;<br>#7&nbsp;|&nbsp;<a href="/p/68ef8146.html">一些其它类型类</a>&emsp;&emsp;&emsp;<br>#A&nbsp;|&nbsp;<a href="/p/96c32eae.html">Haskell与范畴论</a>&emsp;&nbsp;&thinsp;</p>
</div></div><div class="article-licensing box"><div class="licensing-title"><p>「Learn Haskell」#5 函子、应用函子与单子</p><p><a href="https://blog.tonycrane.cc/p/290ecb74.html">https://blog.tonycrane.cc/p/290ecb74.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>TonyCrane</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-07-09</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-07-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Haskell/">Haskell</a><a class="link-muted mr-2" rel="tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/p/d4bb2633.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">「Learn Haskell」#6 半群与幺半群</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/p/a5bbe48a.html"><span class="level-item">「Learn Haskell」#4 输入输出与文件</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><script src="https://giscus.app/client.js" data-repo="TonyCrane/TonyCrane.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxNzQ3Nzg0MzY=" data-category="General" data-category-id="DIC_kwDOCmroRM4CT8Di" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="light" data-lang="zh-CN" crossorigin="anonymous" async></script><script>const t = localStorage.getItem("theme")
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
if (t === null) {
    if (isDarkMode) {
        var giscus = document.querySelector("script[src*=giscus]")
        giscus.setAttribute("data-theme", "https://gcore.jsdelivr.net/gh/TonyCrane/note/docs/css/giscus.css")
    } else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        if (isNight) {
            var giscus = document.querySelector("script[src*=giscus]")
            giscus.setAttribute("data-theme", "https://gcore.jsdelivr.net/gh/TonyCrane/note/docs/css/giscus.css")
        }
    }
} else if (JSON.parse(t).value === "dark") {
    var giscus = document.querySelector("script[src*=giscus]")
    giscus.setAttribute("data-theme", "https://gcore.jsdelivr.net/gh/TonyCrane/note/docs/css/giscus.css")
}</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/tonycrane.png" alt="鹤翔万里"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">鹤翔万里</p><p class="is-size-6 is-block">TonyCrane</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Jilin -&gt; Hangzhou, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">106</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">47</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://space.bilibili.com/171431343" target="_blank" rel="noopener">BiliBili主页</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/TonyCrane"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Notebook" href="https://note.tonycrane.cc/"><i class="fas fa-book"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="QQ" href="https://qm.qq.com/cgi-bin/qm/qr?k=IrHKn7S1NdpfCsCfxlIPe9_t0wuRAS3s&amp;noverify=0"><i class="fab fa-qq"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:tonycrane@foxmail.com"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Telegram" href="https://t.me/TonyCraneSky"><i class="fab fa-telegram"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-02-01T16:37:23.000Z">2023-02-02</time></p><p class="title"><a href="/p/dc8d460.html">「杂谈」由 PA 实验引发的一些思考</a></p><p class="categories"><a href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a> / <a href="/categories/%E6%9D%82%E8%B0%88/%E5%AD%A6%E4%B9%A0/">学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-26T21:18:19.000Z">2022-10-27</time></p><p class="title"><a href="/p/169d9f3d.html">「Hackergame 2022」#3 Writup 囤囤囤 1</a></p><p class="categories"><a href="/categories/Writeup/">Writeup</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-26T21:18:13.000Z">2022-10-27</time></p><p class="title"><a href="/p/4fd94ed.html">「Hackergame 2022」#2 Writup 囤囤囤 0</a></p><p class="categories"><a href="/categories/Writeup/">Writeup</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-26T21:13:38.000Z">2022-10-27</time></p><p class="title"><a href="/p/c8afb596.html">「Hackergame 2022」#1 Writup 开局杀题</a></p><p class="categories"><a href="/categories/Writeup/">Writeup</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-26T20:43:30.000Z">2022-10-27</time></p><p class="title"><a href="/p/630bfdd5.html">「Hackergame 2022」#0 赛后总结</a></p><p class="categories"><a href="/categories/Writeup/">Writeup</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">六月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">十二月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/07/"><span class="level-start"><span class="level-item">七月 2021</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/06/"><span class="level-start"><span class="level-item">六月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/AtCoder/"><span class="tag">AtCoder</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSP-S/"><span class="tag">CSP-S</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CTF/"><span class="tag">CTF</span><span class="tag">16</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Cpp/"><span class="tag">Cpp</span><span class="tag">67</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Haskell/"><span class="tag">Haskell</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Luogu/"><span class="tag">Luogu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NOIp/"><span class="tag">NOIp</span><span class="tag">33</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SPOJ/"><span class="tag">SPOJ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Writeup/"><span class="tag">Writeup</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bfs/"><span class="tag">bfs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/blog/"><span class="tag">blog</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bug/"><span class="tag">bug</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dsu-on-tree/"><span class="tag">dsu on tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/github/"><span class="tag">github</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/manim/"><span class="tag">manim</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/markdown/"><span class="tag">markdown</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mkdocs/"><span class="tag">mkdocs</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AD%A6%E4%B9%A0/"><span class="tag">学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"><span class="tag">左偏树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"><span class="tag">差分约束</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"><span class="tag">并查集</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E8%AE%BA/"><span class="tag">数论</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"><span class="tag">最大流</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"><span class="tag">最短路</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%82%E8%B0%88/"><span class="tag">杂谈</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"><span class="tag">树状数组</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B8%B8%E8%AE%B0/"><span class="tag">游记</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"><span class="tag">状态压缩</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%B4%BB/"><span class="tag">生活</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">29</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">32</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"><span class="tag">线段树</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"><span class="tag">网络流</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8C%83%E7%95%B4%E8%AE%BA/"><span class="tag">范畴论</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8E%AB%E9%98%9F/"><span class="tag">莫队</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"><span class="tag">计算几何</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"><span class="tag">费用流</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%98%E8%A7%A3/"><span class="tag">题解</span><span class="tag">36</span></a></div></div></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C-%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">C++算法</span></span><span class="level-end"><span class="level-item tag">32</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">笔记</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul><li><a class="level is-mobile" href="/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/%E5%9B%BE%E8%AE%BA/"><span class="level-start"><span class="level-item">图论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C-%E7%AE%97%E6%B3%95/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="/categories/Writeup/"><span class="level-start"><span class="level-item">Writeup</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/manim/"><span class="level-start"><span class="level-item">manim</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/manim/%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">杂谈</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%9D%82%E8%B0%88/%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E6%B8%B8%E8%AE%B0/"><span class="level-start"><span class="level-item">游记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB/"><span class="level-start"><span class="level-item">生活</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%94%9F%E6%B4%BB/%E6%9D%82%E8%B0%88/"><span class="level-start"><span class="level-item">杂谈</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E9%A2%98%E8%A7%A3/"><span class="level-start"><span class="level-item">题解</span></span><span class="level-end"><span class="level-item tag">33</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E9%A2%98%E8%A7%A3/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"><span class="level-start"><span class="level-item">网络流24题</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Functors"><span class="level-left"><span class="level-item">1</span><span class="level-item">Functors</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Functor实例"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Functor实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">[]</span></span></a></li><li><a class="level is-mobile" href="#Maybe"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">Maybe</span></span></a></li><li><a class="level is-mobile" href="#Either-a"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">Either a</span></span></a></li><li><a class="level is-mobile" href="#IO"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">IO</span></span></a></li><li><a class="level is-mobile" href="#a"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">(,) a</span></span></a></li><li><a class="level is-mobile" href="#gt-r"><span class="level-left"><span class="level-item">1.1.6</span><span class="level-item">(-&gt;) r</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Functor-Laws"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Functor Laws</span></span></a></li><li><a class="level is-mobile" href="#Intuition"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Intuition</span></span></a></li><li><a class="level is-mobile" href="#常用函数"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">常用函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#lt-gt"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">&lt;$&gt;</span></span></a></li><li><a class="level is-mobile" href="#gt"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">$&gt;</span></span></a></li><li><a class="level is-mobile" href="#void"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">void</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Applicative-Functor"><span class="level-left"><span class="level-item">2</span><span class="level-item">Applicative Functor</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Applicative-Functor实例"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Applicative Functor实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Maybe-1"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">Maybe</span></span></a></li><li><a class="level is-mobile" href="#-1"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">[]</span></span></a></li><li><a class="level is-mobile" href="#IO-1"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">IO</span></span></a></li><li><a class="level is-mobile" href="#gt-r-1"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">(-&gt;) r</span></span></a></li><li><a class="level is-mobile" href="#ZipList"><span class="level-left"><span class="level-item">2.1.5</span><span class="level-item">ZipList</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Applicative-Functor-Laws"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Applicative Functor Laws</span></span></a></li><li><a class="level is-mobile" href="#Intuition-1"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Intuition</span></span></a></li><li><a class="level is-mobile" href="#常用函数-1"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">常用函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#liftA-amp-liftA2-amp-liftA3"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">liftA &amp; liftA2 &amp; liftA3</span></span></a></li><li><a class="level is-mobile" href="#lt-amp-gt"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">&lt;* &amp; *&gt;</span></span></a></li><li><a class="level is-mobile" href="#lt-gt-1"><span class="level-left"><span class="level-item">2.4.3</span><span class="level-item">&lt;**&gt;</span></span></a></li><li><a class="level is-mobile" href="#when-amp-unless"><span class="level-left"><span class="level-item">2.4.4</span><span class="level-item">when &amp; unless</span></span></a></li><li><a class="level is-mobile" href="#sequenceA"><span class="level-left"><span class="level-item">2.4.5</span><span class="level-item">sequenceA</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Monad"><span class="level-left"><span class="level-item">3</span><span class="level-item">Monad</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Monad实例"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Monad实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Maybe-2"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">Maybe</span></span></a></li><li><a class="level is-mobile" href="#-2"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">[]</span></span></a></li><li><a class="level is-mobile" href="#IO-2"><span class="level-left"><span class="level-item">3.1.3</span><span class="level-item">IO</span></span></a></li><li><a class="level is-mobile" href="#gt-r-2"><span class="level-left"><span class="level-item">3.1.4</span><span class="level-item">(-&gt;) r</span></span></a></li></ul></li><li><a class="level is-mobile" href="#do-notation"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">do-notation</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ApplicativeDo"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">ApplicativeDo</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Monad-Laws"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Monad Laws</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#组合运算符（-gt-gt-）形式"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">组合运算符（&gt;=&gt;）形式</span></span></a></li><li><a class="level is-mobile" href="#do-notation形式"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">do-notation形式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Intuition-2"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Intuition</span></span></a></li><li><a class="level is-mobile" href="#常用函数-2"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">常用函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#liftM-amp-ap"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">liftM &amp; ap</span></span></a></li><li><a class="level is-mobile" href="#sequence"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">sequence</span></span></a></li><li><a class="level is-mobile" href="#replicateM"><span class="level-left"><span class="level-item">3.5.3</span><span class="level-item">replicateM</span></span></a></li><li><a class="level is-mobile" href="#mapM-amp-forM"><span class="level-left"><span class="level-item">3.5.4</span><span class="level-item">mapM &amp; forM</span></span></a></li><li><a class="level is-mobile" href="#lt-lt-amp-gt-gt-amp-lt-lt"><span class="level-left"><span class="level-item">3.5.5</span><span class="level-item">=&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#MonadFail"><span class="level-left"><span class="level-item">4</span><span class="level-item">MonadFail</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#MonadFail实例"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">MonadFail实例</span></span></a></li><li><a class="level is-mobile" href="#MonadFail-Law"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">MonadFail Law</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reference"><span class="level-left"><span class="level-item">5</span><span class="level-item">Reference</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/BlogLogo.png" alt="TonyCrane&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 TonyCrane</span><br>Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> with theme <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a> modified by <a href="https://github.com/TonyCrane" target="_blank" rel="noopener">TonyCrane</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></footer><script src="https://gcore.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://gcore.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://gcore.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://gcore.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://gcore.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://gcore.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://gcore.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/darkmode.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>